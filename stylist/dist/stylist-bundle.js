(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.stylist = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":33}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.dsv = {}));
}(this, function (exports) { 'use strict';

  var dsv = function(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n]"),
        delimiterCode = delimiter.charCodeAt(0);

    function parse(text, f) {
      var o;
      return parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) { return f(a(row), i); } : a;
      });
    }

    function parseRows(text, f) {
      var EOL = {}, // sentinel value for end-of-line
          EOF = {}, // sentinel value for end-of-file
          rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // the current line number
          t, // the current token
          eol; // is the current token followed by EOL?

      function token() {
        if (I >= N) return EOF; // special case: end of file
        if (eol) return eol = false, EOL; // special case: end of line

        // special case: quotes
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, "\"");
        }

        // common case: find next delimiter or newline
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; // \n
          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
          else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }

        // special case: last token before EOF
        return text.slice(j);
      }

      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }

      return rows;
    }

    function format(rows) {
      if (Array.isArray(rows[0])) return formatRows(rows); // deprecated; use formatRows
      var fieldSet = Object.create(null), fields = [];

      // Compute unique fields in order of discovery.
      rows.forEach(function(row) {
        for (var field in row) {
          if (!((field += "") in fieldSet)) {
            fields.push(fieldSet[field] = field);
          }
        }
      });

      return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(text) {
      return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatRows: formatRows
    };
  }

  exports.csv = dsv(",");
  exports.tsv = dsv("\t");

  exports.dsv = dsv;

}));
},{}],4:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.format = {}));
}(this, function (exports) { 'use strict';

  var zhCn = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["¥", ""]
  };

  var ruRu = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0руб."]
  };

  var ptBr = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["R$", ""]
  };

  var plPl = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "zł"]
  };

  var nlNl = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€\xa0", ""]
  };

  var mkMk = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0ден."]
  };

  var jaJp = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["", "円"]
  };

  var itIt = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€", ""]
  };

  var heIl = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["₪", ""]
  };

  var frFr = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var frCa = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "$"]
  };

  var fiFi = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var esEs = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var enUs = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  };

  var enGb = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["£", ""]
  };

  var enCa = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  };

  var deDe = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var caEs = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };


  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, p + i - 1)[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };


  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function locale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function format(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      return function(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            var i = -1, n = value.length, c;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      };
    }

    function formatPrefix(specifier, value) {
      var f = format((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: format,
      formatPrefix: formatPrefix
    };
  }

  function precisionRound(step, max) {
    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  var localeDefinitions = {
    "ca-ES": caEs,
    "de-DE": deDe,
    "en-CA": enCa,
    "en-GB": enGb,
    "en-US": enUs,
    "es-ES": esEs,
    "fi-FI": fiFi,
    "fr-CA": frCa,
    "fr-FR": frFr,
    "he-IL": heIl,
    "it-IT": itIt,
    "ja-JP": jaJp,
    "mk-MK": mkMk,
    "nl-NL": nlNl,
    "pl-PL": plPl,
    "pt-BR": ptBr,
    "ru-RU": ruRu,
    "zh-CN": zhCn
  };

  var defaultLocale = locale(enUs);
  exports.format = defaultLocale.format;
  exports.formatPrefix = defaultLocale.formatPrefix;

  function localeFormat(definition) {
    if (typeof definition === "string") {
      if (!localeDefinitions.hasOwnProperty(definition)) return null;
      definition = localeDefinitions[definition];
    }
    return locale(definition);
  }
  ;

  exports.localeFormat = localeFormat;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

}));
},{}],5:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.timeFormat = {}));
}(this, function (exports) { 'use strict';

  var zhCn = {
    dateTime: "%a %b %e %X %Y",
    date: "%Y/%-m/%-d",
    time: "%H:%M:%S",
    periods: ["上午", "下午"],
    days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    shortDays: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    shortMonths: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
  };

  var ruRu = {
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
    shortDays: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
    months: ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
    shortMonths: ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
  };

  var ptBr = {
    dateTime: "%A, %e de %B de %Y. %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
    shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
    months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
    shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
  };

  var plPl = {
    dateTime: "%A, %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
    shortDays: ["Niedz.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
    months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
    shortMonths: ["Stycz.", "Luty", "Marz.", "Kwie.", "Maj", "Czerw.", "Lipc.", "Sierp.", "Wrz.", "Paźdz.", "Listop.", "Grudz."]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */
  };

  var nlNl = {
    dateTime: "%a %e %B %Y %T",
    date: "%d-%m-%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
    shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
    months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
    shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
  };

  var mkMk = {
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
    shortDays: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
    months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
    shortMonths: ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
  };

  var jaJp = {
    dateTime: "%Y %b %e %a %X",
    date: "%Y/%m/%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
    shortDays: ["日", "月", "火", "水", "木", "金", "土"],
    months: ["睦月", "如月", "弥生", "卯月", "皐月", "水無月", "文月", "葉月", "長月", "神無月", "霜月", "師走"],
    shortMonths: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
  };

  var itIt = {
    dateTime: "%A %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
    shortDays: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
    months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
    shortMonths: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
  };

  var heIl = {
    dateTime: "%A, %e ב%B %Y %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
    shortDays: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
    months: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
    shortMonths: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"]
  };

  var frFr = {
    dateTime: "%A, le %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
  };

  var frCa = {
    dateTime: "%a %e %b %Y %X",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["", ""],
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["jan", "fév", "mar", "avr", "mai", "jui", "jul", "aoû", "sep", "oct", "nov", "déc"]
  };

  var fiFi = {
    dateTime: "%A, %-d. %Bta %Y klo %X",
    date: "%-d.%-m.%Y",
    time: "%H:%M:%S",
    periods: ["a.m.", "p.m."],
    days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"],
    shortDays: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
    months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
    shortMonths: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kesä", "Heinä", "Elo", "Syys", "Loka", "Marras", "Joulu"]
  };

  var esEs = {
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
    shortDays: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
    months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
    shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
  };

  var enUs = {
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var enGb = {
    dateTime: "%a %e %b %X %Y",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var enCa = {
    dateTime: "%a %b %e %X %Y",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var deDe = {
    dateTime: "%A, der %e. %B %Y, %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
  };

  var caEs = {
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
    shortDays: ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
    months: ["gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre"],
    shortMonths: ["gen.", "febr.", "març", "abr.", "maig", "juny", "jul.", "ag.", "set.", "oct.", "nov.", "des."]
  };

  var t0 = new Date;
  var t1 = new Date;

  function newInterval(floori, offseti, count) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.round = function(date) {
      var d0 = new Date(+date),
          d1 = new Date(date - 1);
      floori(d0), floori(d1), offseti(d1, 1);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), date;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [];
      start = new Date(start - 1);
      stop = new Date(+stop);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      offseti(start, 1), floori(start);
      if (start < stop) range.push(new Date(+start));
      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        while (--step >= 0) while (offseti(date, 1), !test(date));
      });
    };

    if (count) interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    return interval;
  }

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);

  var year = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / 864e5;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / 6048e5;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);

  var utcYear = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCMonth(0, 1);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  });

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
  }

  function locale(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "S": formatSeconds,
      "U": formatWeekNumberSunday,
      "w": formatWeekdayNumber,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "S": formatUTCSeconds,
      "U": formatUTCWeekNumberSunday,
      "w": formatUTCWeekdayNumber,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "S": parseSeconds,
      "U": parseWeekNumberSunday,
      "w": parseWeekdayNumber,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            if (format = formats[c]) c = format(date, pad == null ? (c === "e" ? " " : "0") : pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function(string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string, 0);
        if (i != string.length) return null;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          if ("w" in d && ("W" in d || "U" in d)) {
            var day = utcDate(newYear(d.y)).getUTCDay();
            if ("W" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;
            d.m = 0;
            d.d = d.w + d.U * 7 - (day + 6) % 7;
          }
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        if ("w" in d && ("W" in d || "U" in d)) {
          var day = newDate(newYear(d.y)).getDay();
          if ("W" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;
          d.m = 0;
          d.d = d.w + d.U * 7 - (day + 6) % 7;
        }
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function parsePeriod(d, string, i) {
      var n = periodLookup[string.slice(i, i += 2).toLowerCase()];
      return n == null ? -1 : (d.p = n, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.parse = newParse(specifier, localDate);
        f.toString = function() { return specifier; };
        return f;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.parse = newParse(specifier, utcDate);
        f.toString = function() { return specifier; };
        return f;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"};
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
    if (n) {
      d.Z = n[1] ? 0              // 'Z' for UTC
          : n[3] ? -(n[2] + n[3]) // sign differs from getTimezoneOffset!
                 : -n[2] * 100;
      return i + n[0].length;
    }
    return -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(year(d), d), p, 2);
  }

  function formatWeekdayNumber(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(year(d), d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d), d), p, 2);
  }

  function formatUTCWeekdayNumber(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };

  formatIsoNative.toString = function() {
    return isoSpecifier;
  };

  var formatIso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z")
      ? formatIsoNative
      : enUs.utcFormat(isoSpecifier);

  var isoFormat = formatIso;

  var localeDefinitions = {
    "ca-ES": caEs,
    "de-DE": deDe,
    "en-CA": enCa,
    "en-GB": enGb,
    "en-US": enUs,
    "es-ES": esEs,
    "fi-FI": fiFi,
    "fr-CA": frCa,
    "fr-FR": frFr,
    "he-IL": heIl,
    "it-IT": itIt,
    "ja-JP": jaJp,
    "mk-MK": mkMk,
    "nl-NL": nlNl,
    "pl-PL": plPl,
    "pt-BR": ptBr,
    "ru-RU": ruRu,
    "zh-CN": zhCn
  };

  var defaultLocale = locale(enUs);
  exports.format = defaultLocale.format;
  exports.utcFormat = defaultLocale.utcFormat;

  function localeFormat(definition) {
    if (typeof definition === "string") {
      if (!localeDefinitions.hasOwnProperty(definition)) return null;
      definition = localeDefinitions[definition];
    }
    return locale(definition);
  }
  ;

  exports.localeFormat = localeFormat;
  exports.isoFormat = isoFormat;

}));
},{}],6:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.time = {}));
}(this, function (exports) { 'use strict';

  var t1 = new Date;

  var t0 = new Date;

  function newInterval(floori, offseti, count) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.round = function(date) {
      var d0 = new Date(+date),
          d1 = new Date(date - 1);
      floori(d0), floori(d1), offseti(d1, 1);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), date;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [];
      start = new Date(start - 1);
      stop = new Date(+stop);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      offseti(start, 1), floori(start);
      if (start < stop) range.push(new Date(+start));
      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        while (--step >= 0) while (offseti(date, 1), !test(date));
      });
    };

    if (count) interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    return interval;
  }

  var second = newInterval(function(date) {
    date.setMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  });

  exports.seconds = second.range;

  var minute = newInterval(function(date) {
    date.setSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  });

  exports.minutes = minute.range;

  var hour = newInterval(function(date) {
    date.setMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  });

  exports.hours = hour.range;

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
  });

  exports.days = day.range;

  function weekday(i) {
    return newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
    });
  }

  exports.sunday = weekday(0);

  exports.sundays = exports.sunday.range;

  exports.monday = weekday(1);

  exports.mondays = exports.monday.range;

  exports.tuesday = weekday(2);

  exports.tuesdays = exports.tuesday.range;

  exports.wednesday = weekday(3);

  exports.wednesdays = exports.wednesday.range;

  exports.thursday = weekday(4);

  exports.thursdays = exports.thursday.range;

  exports.friday = weekday(5);

  exports.fridays = exports.friday.range;

  exports.saturday = weekday(6);

  exports.saturdays = exports.saturday.range;

  var week = exports.sunday;

  exports.weeks = week.range;

  var month = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setDate(1);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  });

  exports.months = month.range;

  var year = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  });

  exports.years = year.range;

  var utcSecond = newInterval(function(date) {
    date.setUTCMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  });

  exports.utcSeconds = utcSecond.range;

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  });

  exports.utcMinutes = utcMinute.range;

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  });

  exports.utcHours = utcHour.range;

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / 864e5;
  });

  exports.utcDays = utcDay.range;

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / 6048e5;
    });
  }

  exports.utcSunday = utcWeekday(0);

  exports.utcSundays = exports.utcSunday.range;

  exports.utcMonday = utcWeekday(1);

  exports.utcMondays = exports.utcMonday.range;

  exports.utcTuesday = utcWeekday(2);

  exports.utcTuesdays = exports.utcTuesday.range;

  exports.utcWednesday = utcWeekday(3);

  exports.utcWednesdays = exports.utcWednesday.range;

  exports.utcThursday = utcWeekday(4);

  exports.utcThursdays = exports.utcThursday.range;

  exports.utcFriday = utcWeekday(5);

  exports.utcFridays = exports.utcFriday.range;

  exports.utcSaturday = utcWeekday(6);

  exports.utcSaturdays = exports.utcSaturday.range;

  var utcWeek = exports.utcSunday;

  exports.utcWeeks = utcWeek.range;

  var utcMonth = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCDate(1);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  });

  exports.utcMonths = utcMonth.range;

  var utcYear = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCMonth(0, 1);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  });

  exports.utcYears = utcYear.range;

  exports.interval = newInterval;
  exports.second = second;
  exports.minute = minute;
  exports.hour = hour;
  exports.day = day;
  exports.week = week;
  exports.month = month;
  exports.year = year;
  exports.utcSecond = utcSecond;
  exports.utcMinute = utcMinute;
  exports.utcHour = utcHour;
  exports.utcDay = utcDay;
  exports.utcWeek = utcWeek;
  exports.utcMonth = utcMonth;
  exports.utcYear = utcYear;

}));
},{}],7:[function(require,module,exports){
var util = require('../util'),
    Measures = require('./measures'),
    Collector = require('./collector');

function Aggregator() {
  this._cells = {};
  this._aggr = [];
  this._stream = false;
}

var Flags = Aggregator.Flags = {
  ADD_CELL: 1,
  MOD_CELL: 2
};

var proto = Aggregator.prototype;

// Parameters

proto.stream = function(v) {
  if (v == null) return this._stream;
  this._stream = !!v;
  this._aggr = [];
  return this;
};

// key accessor to use for streaming removes
proto.key = function(key) {
  if (key == null) return this._key;
  this._key = util.$(key);
  return this;
};

// Input: array of objects of the form
// {name: string, get: function}
proto.groupby = function(dims) {
  this._dims = util.array(dims).map(function(d, i) {
    d = util.isString(d) ? {name: d, get: util.$(d)}
      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}
      : (d.name && util.isFunction(d.get)) ? d : null;
    if (d == null) throw 'Invalid groupby argument: ' + d;
    return d;
  });
  return this.clear();
};

// Input: array of objects of the form
// {name: string, ops: [string, ...]}
proto.summarize = function(fields) {
  fields = summarize_args(fields);
  this._count = true;
  var aggr = (this._aggr = []),
      m, f, i, j, op, as, get;

  for (i=0; i<fields.length; ++i) {
    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {
      op = f.ops[j];
      if (op !== 'count') this._count = false;
      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));
      m.push(Measures[op](as));
    }
    get = f.get && util.$(f.get) ||
      (f.name === '*' ? util.identity : util.$(f.name));
    aggr.push({
      name: f.name,
      measures: Measures.create(
        m,
        this._stream, // streaming remove flag
        get,          // input tuple getter
        this._assign) // output tuple setter
    });
  }
  return this.clear();
};

// Convenience method to summarize by count
proto.count = function() {
  return this.summarize({'*':'count'});
};

// Override to perform custom tuple value assignment
proto._assign = function(object, name, value) {
  object[name] = value;
};

function summarize_args(fields) {
  if (util.isArray(fields)) { return fields; }
  if (fields == null) { return []; }
  var a = [], name, ops;
  for (name in fields) {
    ops = util.array(fields[name]);
    a.push({name: name, ops: ops});
  }
  return a;
}

// Cell Management

proto.clear = function() {
  return (this._cells = {}, this);
};

proto._cellkey = function(x) {
  var d = this._dims,
      n = d.length, i,
      k = String(d[0].get(x));
  for (i=1; i<n; ++i) {
    k += '|' + d[i].get(x);
  }
  return k;
};

proto._cell = function(x) {
  var key = this._dims.length ? this._cellkey(x) : '';
  return this._cells[key] || (this._cells[key] = this._newcell(x, key));
};

proto._newcell = function(x, key) {
  var cell = {
    num:   0,
    tuple: this._newtuple(x, key),
    flag:  Flags.ADD_CELL,
    aggs:  {}
  };

  var aggr = this._aggr, i;
  for (i=0; i<aggr.length; ++i) {
    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);
  }
  if (cell.collect) {
    cell.data = new Collector(this._key);
  }
  return cell;
};

proto._newtuple = function(x) {
  var dims = this._dims,
      t = {}, i, n;
  for (i=0, n=dims.length; i<n; ++i) {
    t[dims[i].name] = dims[i].get(x);
  }
  return this._ingest(t);
};

// Override to perform custom tuple ingestion
proto._ingest = util.identity;

// Process Tuples

proto._add = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num += 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.add(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].add(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_add) this._on_add(x, cell);
};

proto._rem = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num -= 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.rem(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].rem(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_rem) this._on_rem(x, cell);
};

proto._mod = function(curr, prev) {
  var cell0 = this._cell(prev),
      cell1 = this._cell(curr),
      aggr = this._aggr, i;

  if (cell0 !== cell1) {
    cell0.num -= 1;
    cell1.num += 1;
    if (cell0.collect) cell0.data.rem(prev);
    if (cell1.collect) cell1.data.add(curr);
  } else if (cell0.collect && !util.isObject(curr)) {
    cell0.data.rem(prev);
    cell0.data.add(curr);
  }

  for (i=0; i<aggr.length; ++i) {
    cell0.aggs[aggr[i].name].rem(prev);
    cell1.aggs[aggr[i].name].add(curr);
  }
  cell0.flag |= Flags.MOD_CELL;
  cell1.flag |= Flags.MOD_CELL;
  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);
};

proto.result = function() {
  var result = [],
      aggr = this._aggr,
      cell, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    if (cell.num > 0) {
      // consolidate collector values
      if (cell.collect) {
        cell.data.values();
      }
      // update tuple properties
      for (i=0; i<aggr.length; ++i) {
        cell.aggs[aggr[i].name].set();
      }
      // add output tuple
      result.push(cell.tuple);
    } else {
      delete this._cells[k];
    }
    cell.flag = 0;
  }

  this._rems = false;
  return result;
};

proto.changes = function(output) {
  var changes = output || {add:[], rem:[], mod:[]},
      aggr = this._aggr,
      cell, flag, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    flag = cell.flag;

    // consolidate collector values
    if (cell.collect) {
      cell.data.values();
    }

    // update tuple properties
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].set();
    }

    // organize output tuples
    if (cell.num <= 0) {
      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??
      delete this._cells[k];
      if (this._on_drop) this._on_drop(cell);
    } else {
      if (this._on_keep) this._on_keep(cell);
      if (flag & Flags.ADD_CELL) {
        changes.add.push(cell.tuple);
      } else if (flag & Flags.MOD_CELL) {
        changes.mod.push(cell.tuple);
      }
    }

    cell.flag = 0;
  }

  this._rems = false;
  return changes;
};

proto.execute = function(input) {
  return this.clear().insert(input).result();
};

proto.insert = function(input) {
  this._consolidate();
  for (var i=0; i<input.length; ++i) {
    this._add(input[i]);
  }
  return this;
};

proto.remove = function(input) {
  if (!this._stream) {
    throw 'Aggregator not configured for streaming removes.' +
      ' Call stream(true) prior to calling summarize.';
  }
  for (var i=0; i<input.length; ++i) {
    this._rem(input[i]);
  }
  this._rems = true;
  return this;
};

// consolidate removals
proto._consolidate = function() {
  if (!this._rems) return;
  for (var k in this._cells) {
    if (this._cells[k].collect) {
      this._cells[k].data.values();
    }
  }
  this._rems = false;
};

module.exports = Aggregator;
},{"../util":29,"./collector":8,"./measures":10}],8:[function(require,module,exports){
var util = require('../util');
var stats = require('../stats');

var REM = '__dl_rem__';

function Collector(key) {
  this._add = [];
  this._rem = [];
  this._key = key || null;
  this._last = null;
}

var proto = Collector.prototype;

proto.add = function(v) {
  this._add.push(v);
};

proto.rem = function(v) {
  this._rem.push(v);
};

proto.values = function() {
  this._get = null;
  if (this._rem.length === 0) return this._add;

  var a = this._add,
      r = this._rem,
      k = this._key,
      x = Array(a.length - r.length),
      i, j, n, m;

  if (!util.isObject(r[0])) {
    // processing raw values
    m = stats.count.map(r);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (m[a[i]] > 0) {
        m[a[i]] -= 1;
      } else {
        x[j++] = a[i];
      }
    }
  } else if (k) {
    // has unique key field, so use that
    m = util.toMap(r, k);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }
    }
  } else {
    // no unique key, mark tuples directly
    for (i=0, n=r.length; i<n; ++i) {
      r[i][REM] = 1;
    }
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!a[i][REM]) { x[j++] = a[i]; }
    }
    for (i=0, n=r.length; i<n; ++i) {
      delete r[i][REM];
    }
  }

  this._rem = [];
  return (this._add = x);
};

// memoizing statistics methods

proto.extent = function(get) {
  if (this._get !== get || !this._ext) {
    var v = this.values(),
        i = stats.extent.index(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;    
  }
  return this._ext;
};

proto.argmin = function(get) {
  return this.extent(get)[0];
};

proto.argmax = function(get) {
  return this.extent(get)[1];
};

proto.min = function(get) {
  var m = this.extent(get)[0];
  return m ? get(m) : +Infinity;
};

proto.max = function(get) {
  var m = this.extent(get)[1];
  return m ? get(m) : -Infinity;
};

proto.quartile = function(get) {
  if (this._get !== get || !this._q) {
    this._q = stats.quartile(this.values(), get);
    this._get = get;    
  }
  return this._q;
};

proto.q1 = function(get) {
  return this.quartile(get)[0];
};

proto.q2 = function(get) {
  return this.quartile(get)[1];
};

proto.q3 = function(get) {
  return this.quartile(get)[2];
};

module.exports = Collector;

},{"../stats":26,"../util":29}],9:[function(require,module,exports){
var util = require('../util');
var Aggregator = require('./aggregator');

module.exports = function() {
  // flatten arguments into a single array
  var args = [].reduce.call(arguments, function(a, x) {
    return a.concat(util.array(x));
  }, []);
  // create and return an aggregator
  return new Aggregator()
    .groupby(args)
    .summarize({'*':'values'});
};

},{"../util":29,"./aggregator":7}],10:[function(require,module,exports){
var util = require('../util');

var types = {
  'values': measure({
    name: 'values',
    init: 'cell.collect = true;',
    set:  'cell.data.values()', idx: -1
  }),
  'count': measure({
    name: 'count',
    set:  'cell.num'
  }),
  'missing': measure({
    name: 'missing',
    set:  'this.missing'
  }),
  'valid': measure({
    name: 'valid',
    set:  'this.valid'
  }),
  'sum': measure({
    name: 'sum',
    init: 'this.sum = 0;',
    add:  'this.sum += v;',
    rem:  'this.sum -= v;',
    set:  'this.sum'
  }),
  'mean': measure({
    name: 'mean',
    init: 'this.mean = 0;',
    add:  'var d = v - this.mean; this.mean += d / this.valid;',
    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',
    set:  'this.mean'
  }),
  'average': measure({
    name: 'average',
    set:  'this.mean',
    req:  ['mean'], idx: 1
  }),
  'variance': measure({
    name: 'variance',
    init: 'this.dev = 0;',
    add:  'this.dev += d * (v - this.mean);',
    rem:  'this.dev -= d * (v - this.mean);',
    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',
    req:  ['mean'], idx: 1
  }),
  'variancep': measure({
    name: 'variancep',
    set:  'this.valid > 1 ? this.dev / this.valid : 0',
    req:  ['variance'], idx: 2
  }),
  'stdev': measure({
    name: 'stdev',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',
    req:  ['variance'], idx: 2
  }),
  'stdevp': measure({
    name: 'stdevp',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',
    req:  ['variance'], idx: 2
  }),
  'median': measure({
    name: 'median',
    set:  'cell.data.q2(this.get)',
    req:  ['values'], idx: 3
  }),
  'q1': measure({
    name: 'q1',
    set:  'cell.data.q1(this.get)',
    req:  ['values'], idx: 3
  }),
  'q3': measure({
    name: 'q3',
    set:  'cell.data.q3(this.get)',
    req:  ['values'], idx: 3
  }),
  'distinct': measure({
    name: 'distinct',
    set:  'this.distinct(cell.data.values(), this.get)',
    req:  ['values'], idx: 3
  }),
  'argmin': measure({
    name: 'argmin',
    add:  'if (v < this.min) this.argmin = t;',
    rem:  'if (v <= this.min) this.argmin = null;',
    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',
    req:  ['min'], str: ['values'], idx: 3
  }),
  'argmax': measure({
    name: 'argmax',
    add:  'if (v > this.max) this.argmax = t;',
    rem:  'if (v >= this.max) this.argmax = null;',
    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',
    req:  ['max'], str: ['values'], idx: 3
  }),
  'min': measure({
    name: 'min',
    init: 'this.min = +Infinity;',
    add:  'if (v < this.min) this.min = v;',
    rem:  'if (v <= this.min) this.min = NaN;',
    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',
    str:  ['values'], idx: 4
  }),
  'max': measure({
    name: 'max',
    init: 'this.max = -Infinity;',
    add:  'if (v > this.max) this.max = v;',
    rem:  'if (v >= this.max) this.max = NaN;',
    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',
    str:  ['values'], idx: 4
  }),
  'modeskew': measure({
    name: 'modeskew',
    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',
    req:  ['mean', 'stdev', 'median'], idx: 5
  })
};

function measure(base) {
  return function(out) {
    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);
    m.out = out || base.name;
    return m;
  };
}

function resolve(agg, stream) {
  function collect(m, a) {
    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }
    if (a.req) a.req.forEach(helper);
    if (stream && a.str) a.str.forEach(helper);
    return m;
  }
  var map = agg.reduce(
    collect,
    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})
  );
  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });
}

function create(agg, stream, accessor, mutator) {
  var all = resolve(agg, stream),
      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',
      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',
      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',
      set = 'var t = this.tuple; var cell = this.cell;';

  all.forEach(function(a) {
    if (a.idx < 0) {
      ctr = a.init + ctr;
      add = a.add + add;
      rem = a.rem + rem;
    } else {
      ctr += a.init;
      add += a.add;
      rem += a.rem;
    }
  });
  agg.slice()
    .sort(function(a, b) { return a.idx - b.idx; })
    .forEach(function(a) {
      set += 'this.assign(t,\''+a.out+'\','+a.set+');';
    });
  set += 'return t;';

  /* jshint evil: true */
  ctr = Function('cell', 't', ctr);
  ctr.prototype.assign = mutator;
  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);
  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);
  ctr.prototype.set = Function(set);
  ctr.prototype.get = accessor;
  ctr.prototype.distinct = require('../stats').count.distinct;
  ctr.prototype.isValid = util.isValid;
  ctr.fields = agg.map(util.$('out'));
  return ctr;
}

types.create = create;
module.exports = types;
},{"../stats":26,"../util":29}],11:[function(require,module,exports){
var util = require('../util'),
    time = require('../time'),
    EPSILON = 1e-15;

function bins(opt) {
  if (!opt) { throw Error("Missing binning options."); }

  // determine range
  var maxb = opt.maxbins || 15,
      base = opt.base || 10,
      logb = Math.log(base),
      div = opt.div || [5, 2],      
      min = opt.min,
      max = opt.max,
      span = max - min,
      step, level, minstep, precision, v, i, eps;

  if (opt.step) {
    // if step size is explicitly given, use that
    step = opt.step;
  } else if (opt.steps) {
    // if provided, limit choice to acceptable step sizes
    step = opt.steps[Math.min(
      opt.steps.length - 1,
      bisect(opt.steps, span/maxb, 0, opt.steps.length)
    )];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = opt.minstep || 0;
    step = Math.max(
      minstep,
      Math.pow(base, Math.round(Math.log(span) / logb) - level)
    );
    
    // increase step size if too many bins
    do { step *= base; } while (Math.ceil(span/step) > maxb);

    // decrease step size if allowed
    for (i=0; i<div.length; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  }

  // update precision, min and max
  v = Math.log(step);
  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;
  eps = Math.pow(base, -precision - 1);
  min = Math.min(min, Math.floor(min / step + eps) * step);
  max = Math.ceil(max / step) * step;

  return {
    start: min,
    stop:  max,
    step:  step,
    unit:  {precision: precision},
    value: value,
    index: index
  };
}

function bisect(a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
}

function value(v) {
  return this.step * Math.floor(v / this.step + EPSILON);
}

function index(v) {
  return Math.floor((v - this.start) / this.step + EPSILON);
}

function date_value(v) {
  return this.unit.date(value.call(this, v));
}

function date_index(v) {
  return index.call(this, this.unit.unit(v));
}

bins.date = function(opt) {
  if (!opt) { throw Error("Missing date binning options."); }

  // find time step, then bin
  var units = opt.utc ? time.utc : time,
      dmin = opt.min,
      dmax = opt.max,
      maxb = opt.maxbins || 20,
      minb = opt.minbins || 4,
      span = (+dmax) - (+dmin),
      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),
      spec = bins({
        min:     unit.min != null ? unit.min : unit.unit(dmin),
        max:     unit.max != null ? unit.max : unit.unit(dmax),
        maxbins: maxb,
        minstep: unit.minstep,
        steps:   unit.step
      });

  spec.unit = unit;
  spec.index = date_index;
  if (!opt.raw) spec.value = date_value;
  return spec;
};

module.exports = bins;

},{"../time":28,"../util":29}],12:[function(require,module,exports){
var bins = require('./bins'),
    gen  = require('../generate'),
    type = require('../import/type'),
    util = require('../util'),
    stats = require('../stats');

var qtype = {
  'integer': 1,
  'number': 1,
  'date': 1
};

function $bin(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return !b ? (opt.accessor || util.identity) :
    util.$func('bin', b.unit.unit ?
      function(x) { return b.value(b.unit.unit(x)); } :
      function(x) { return b.value(x); }
    )(opt.accessor);
}

function histogram(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return b ?
    numerical(values, opt.accessor, b) :
    categorical(values, opt.accessor, opt && opt.sort);
}

function spec(opt) {
  var t = opt.type, b = null;
  if (t == null || qtype[t]) {
    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;
    b = (t === 'date') ? bins.date(opt) : bins(opt);
  }
  return b;
}

function options() {
  var a = arguments,
      i = 0,
      values = util.isArray(a[i]) ? a[i++] : null,
      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,
      opt = util.extend({}, a[i]);
  
  if (values) {
    opt.type = opt.type || type(values, f);
    if (qtype[opt.type]) {
      var ext = stats.extent(values, f);
      opt = util.extend({min: ext[0], max: ext[1]}, opt);
    }
  }
  if (f) { opt.accessor = f; }
  return opt;
}

function numerical(values, f, b) {
  var h = gen.range(b.start, b.stop + b.step/2, b.step)
    .map(function(v) { return {value: b.value(v), count: 0}; });

  for (var i=0, v, j; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      j = b.index(v);
      if (j < 0 || j >= h.length || !isFinite(j)) continue;
      h[j].count += 1;
    }
  }
  h.bins = b;
  return h;
}

function categorical(values, f, sort) {
  var u = stats.unique(values, f),
      c = stats.count.map(values, f);
  return u.map(function(k) { return {value: k, count: c[k]}; })
    .sort(util.comparator(sort ? '-count' : '+value'));
}

module.exports = {
  $bin: $bin,
  histogram: histogram
};
},{"../generate":14,"../import/type":23,"../stats":26,"../util":29,"./bins":11}],13:[function(require,module,exports){
var d3_time = require('d3-time'),
    d3_timeF = require('d3-time-format'),
    d3_numberF = require('d3-format'),
    numberF = d3_numberF, // defaults to EN-US
    timeF = d3_timeF;     // defaults to EN-US

function numberLocale(l) {
  var f = d3_numberF.localeFormat(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  numberF = f;
}

function timeLocale(l) {
  var f = d3_timeF.localeFormat(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  timeF = f;
}

module.exports = {
  // Update number formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-format
  numberLocale: numberLocale,
  number:       function(f) { return numberF.format(f); },
  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },

  // Update time formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-time-format
  timeLocale:   timeLocale,
  time:         function(f) { return timeF.format(f); },  
  utc:          function(f) { return timeF.utcFormat(f); },

  // Set number and time locale simultaneously.
  locale:       function(l) { numberLocale(l); timeLocale(l); },

  // automatic formatting functions
  auto: {
    number:   numberAutoFormat,
    time:     function() { return timeAutoFormat(); },
    utc:      function() { return utcAutoFormat(); }
  }
};

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function intervals(domain, count) {
  if (!domain.length) domain = [0];
  if (count == null) count = 10;

  var start = domain[0],
      stop = domain[domain.length - 1];

  if (stop < start) { error = stop; stop = start; start = error; }

  var span = (stop - start) || (count = 1, start || stop || 1),
      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),
      error = span / count / step;

  // Filter ticks to get closer to the desired count.
  if (error >= e10) step *= 10;
  else if (error >= e5) step *= 5;
  else if (error >= e2) step *= 2;

  // Round start and stop values to step interval.
  return [
    Math.ceil(start / step) * step,
    Math.floor(stop / step) * step + step / 2, // inclusive
    step
  ];
}

function numberAutoFormat(domain, count, f) {
  var range = intervals(domain, count);
  if (f == null) {
    f = ',.' + d3_numberF.precisionFixed(range[2]) + 'f';
  } else {
    switch (f = d3_numberF.formatSpecifier(f), f.type) {
      case 's': {
        var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));
        if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);
        return numberF.formatPrefix(f, value);
      }
      case '':
      case 'e':
      case 'g':
      case 'p':
      case 'r': {
        if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');
        break;
      }
      case 'f':
      case '%': {
        if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - (f.type === '%') * 2;
        break;
      }
    }
  }
  return numberF.format(f);
}

function timeAutoFormat() {
  var f = timeF.format,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.second(date) < d ? formatMillisecond
        : d3_time.minute(date) < d ? formatSecond
        : d3_time.hour(date) < d ? formatMinute
        : d3_time.day(date) < d ? formatHour
        : d3_time.month(date) < d ?
          (d3_time.week(date) < d ? formatDay : formatWeek)
        : d3_time.year(date) < d ? formatMonth
        : formatYear)(date);
  };
}

function utcAutoFormat() {
  var f = timeF.utcFormat,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.utcSecond(date) < d ? formatMillisecond
        : d3_time.utcMinute(date) < d ? formatSecond
        : d3_time.utcHour(date) < d ? formatMinute
        : d3_time.utcDay(date) < d ? formatHour
        : d3_time.utcMonth(date) < d ?
          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)
        : d3_time.utcYear(date) < d ? formatMonth
        : formatYear)(date);
  };
}

},{"d3-format":4,"d3-time":6,"d3-time-format":5}],14:[function(require,module,exports){
var gen = module.exports = {};

gen.repeat = function(val, n) {
  var a = Array(n), i;
  for (i=0; i<n; ++i) a[i] = val;
  return a;
};

gen.zeros = function(n) {
  return gen.repeat(0, n);
};

gen.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step == Infinity) throw new Error('Infinite range');
  var range = [], i = -1, j;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
  else while ((j = start + step * ++i) < stop) range.push(j);
  return range;
};

gen.random = {};

gen.random.uniform = function(min, max) {
  if (max === undefined) {
    max = min === undefined ? 1 : min;
    min = 0;
  }
  var d = max - min;
  var f = function() {
    return min + d * Math.random();
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};

gen.random.integer = function(a, b) {
  if (b === undefined) {
    b = a;
    a = 0;
  }
  var d = b - a;
  var f = function() {
    return a + Math.floor(d * Math.random());
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};

gen.random.normal = function(mean, stdev) {
  mean = mean || 0;
  stdev = stdev || 1;
  var next;
  var f = function() {
    var x = 0, y = 0, rds, c;
    if (next !== undefined) {
      x = next;
      next = undefined;
      return x;
    }
    do {
      x = Math.random()*2-1;
      y = Math.random()*2-1;
      rds = x*x + y*y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
    next = mean + y*c*stdev;
    return mean + x*c*stdev;
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};
},{}],15:[function(require,module,exports){
var util = require('../../util');
var d3_dsv = require('d3-dsv');

function dsv(data, format) {
  if (data) {
    var h = format.header;
    data = (h ? h.join(format.delimiter) + '\n' : '') + data;
  }
  return d3_dsv.dsv(format.delimiter).parse(data);
}

dsv.delimiter = function(delim) {
  var fmt = {delimiter: delim};
  return function(data, format) {
    return dsv(data, format ? util.extend(format, fmt) : fmt);
  };
};

module.exports = dsv;
},{"../../util":29,"d3-dsv":3}],16:[function(require,module,exports){
var dsv = require('./dsv');

module.exports = {
  json: require('./json'),
  topojson: require('./topojson'),
  treejson: require('./treejson'),
  dsv: dsv,
  csv: dsv.delimiter(','),
  tsv: dsv.delimiter('\t')
};
},{"./dsv":15,"./json":17,"./topojson":18,"./treejson":19}],17:[function(require,module,exports){
var util = require('../../util');

module.exports = function(data, format) {
  var d = util.isObject(data) && !util.isBuffer(data) ?
    data : JSON.parse(data);
  if (format && format.property) {
    d = util.accessor(format.property)(d);
  }
  return d;
};

},{"../../util":29}],18:[function(require,module,exports){
(function (global){
var json = require('./json');

var reader = function(data, format) {
  var topojson = reader.topojson;
  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }

  var t = json(data, format), obj;

  if (format && format.feature) {
    if ((obj = t.objects[format.feature])) {
      return topojson.feature(t, obj).features;
    } else {
      throw Error('Invalid TopoJSON object: ' + format.feature);
    }
  } else if (format && format.mesh) {
    if ((obj = t.objects[format.mesh])) {
      return [topojson.mesh(t, t.objects[format.mesh])];
    } else {
      throw Error('Invalid TopoJSON object: ' + format.mesh);
    }
  } else {
    throw Error('Missing TopoJSON feature or mesh parameter.');
  }
};

reader.topojson = (typeof window !== "undefined" ? window['topojson'] : typeof global !== "undefined" ? global['topojson'] : null);
module.exports = reader;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./json":17}],19:[function(require,module,exports){
var json = require('./json');

module.exports = function(data, format) {
  data = json(data, format);
  return toTable(data, (format && format.children));
};

function toTable(root, childrenField) {
  childrenField = childrenField || 'children';
  var table = [];
  
  function visit(node) {
    table.push(node);
    var children = node[childrenField];
    if (children) {
      for (var i=0; i<children.length; ++i) {
        visit(children[i], node);
      }
    }
  }
  
  visit(root, null);
  return (table.root = root, table);
}
},{"./json":17}],20:[function(require,module,exports){
// Matches absolute URLs with optional protocol
//   https://...    file://...    //...
var protocol_re = /^([A-Za-z]+:)?\/\//;

// Special treatment in node.js for the file: protocol
var fileProtocol = 'file://';

// Validate and cleanup URL to ensure that it is allowed to be accessed
// Returns cleaned up URL, or false if access is not allowed
function sanitizeUrl(opt) {
  var url = opt.url;
  if (!url && opt.file) { return fileProtocol + opt.file; }

  // In case this is a relative url (has no host), prepend opt.baseURL
  if (opt.baseURL && !protocol_re.test(url)) {
    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {
      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    }
    url = opt.baseURL + url;
  }
  // relative protocol, starts with '//'
  if (!load.useXHR && startsWith(url, '//')) {
    url = (opt.defaultProtocol || 'http') + ':' + url;
  }
  // If opt.domainWhiteList is set, only allows url, whose hostname
  // * Is the same as the origin (window.location.hostname)
  // * Equals one of the values in the whitelist
  // * Is a proper subdomain of one of the values in the whitelist
  if (opt.domainWhiteList) {
    var domain, origin;
    if (load.useXHR) {
      var a = document.createElement('a');
      a.href = url;
      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
      // IE doesn't populate all link properties when setting .href with a relative URL,
      // however .href will return an absolute URL which then can be used on itself
      // to populate these additional fields.
      if (a.host === '') {
        a.href = a.href;
      }
      domain = a.hostname.toLowerCase();
      origin = window.location.hostname;
    } else {
      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5
      var parts = require('url').parse(url);
      domain = parts.hostname;
      origin = null;
    }

    if (origin !== domain) {
      var whiteListed = opt.domainWhiteList.some(function(d) {
        var idx = domain.length - d.length;
        return d === domain ||
          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);
      });
      if (!whiteListed) {
        throw 'URL is not whitelisted: ' + url;
      }
    }
  }
  return url;
}

function load(opt, callback) {
  var error = callback || function(e) { throw e; }, url;

  try {
    url = load.sanitizeUrl(opt); // enable override
  } catch (err) {
    error(err);
    return;
  }

  if (!url) {
    error('Invalid URL: ' + opt.url);
  } else if (load.useXHR) {
    // on client, use xhr
    return xhr(url, callback);
  } else if (startsWith(url, fileProtocol)) {
    // on server, if url starts with 'file://', strip it and load from file
    return file(url.slice(fileProtocol.length), callback);
  } else if (url.indexOf('://') < 0) { // TODO better protocol check?
    // on server, if no protocol assume file
    return file(url, callback);
  } else {
    // for regular URLs on server
    return http(url, callback);
  }
}

function xhrHasResponse(request) {
  var type = request.responseType;
  return type && type !== 'text' ?
    request.response : // null on error
    request.responseText; // '' on error
}

function xhr(url, callback) {
  var async = !!callback;
  var request = new XMLHttpRequest();
  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)
  if (this.XDomainRequest &&
      !('withCredentials' in request) &&
      /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();

  function respond() {
    var status = request.status;
    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
      callback(null, request.responseText);
    } else {
      callback(request, null);
    }
  }

  if (async) {
    if ('onload' in request) {
      request.onload = request.onerror = respond;
    } else {
      request.onreadystatechange = function() {
        if (request.readyState > 3) respond();
      };
    }
  }
  
  request.open('GET', url, async);
  request.send();
  
  if (!async && xhrHasResponse(request)) {
    return request.responseText;
  }
}

function file(filename, callback) {
  var fs = require('fs');
  if (!callback) {
    return fs.readFileSync(filename, 'utf8');
  }
  fs.readFile(filename, callback);
}

function http(url, callback) {
  if (!callback) {
    return require('sync-request')('GET', url).getBody();
  }
  
  var options = {url: url, encoding: null, gzip: true};
  require('request')(options, function(error, response, body) {
    if (!error && response.statusCode === 200) {
      callback(null, body);
    } else {
      error = error ||
        'Load failed with response code ' + response.statusCode + '.';
      callback(error, null);
    }
  });
}

function startsWith(string, searchString) {
  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;
}

load.sanitizeUrl = sanitizeUrl;

load.useXHR = (typeof XMLHttpRequest !== 'undefined');

module.exports = load;

},{"fs":2,"request":2,"sync-request":2,"url":2}],21:[function(require,module,exports){
var util = require('../util');
var type = require('./type');
var formats = require('./formats');

function read(data, format) {
  var type = (format && format.type) || 'json';
  data = formats[type](data, format);
  if (format && format.parse) parse(data, format.parse);
  return data;
}

function parse(data, types) {
  var cols, parsers, d, i, j, clen, len = data.length;

  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);
  cols = util.keys(types);
  parsers = cols.map(function(c) { return type.parsers[types[c]]; });

  for (i=0, clen=cols.length; i<len; ++i) {
    d = data[i];
    for (j=0; j<clen; ++j) {
      d[cols[j]] = parsers[j](d[cols[j]]);
    }
  }
  type.annotation(data, types);
}

read.formats = formats;
module.exports = read;

},{"../util":29,"./formats":16,"./type":23}],22:[function(require,module,exports){
var util = require('../util');
var load = require('./load');
var read = require('./read');

module.exports = util
  .keys(read.formats)
  .reduce(function(out, type) {
    out[type] = function(opt, format, callback) {
      // process arguments
      if (util.isString(opt)) { opt = {url: opt}; }
      if (arguments.length === 2 && util.isFunction(format)) {
        callback = format;
        format = undefined;
      }

      // set up read format
      format = util.extend({parse: 'auto'}, format);
      format.type = type;

      // load data
      var data = load(opt, callback ? function(error, data) {
        if (error) { callback(error, null); return; }
        try {
          // data loaded, now parse it (async)
          data = read(data, format);
          callback(null, data);
        } catch (e) {
          callback(e, null);
        }
      } : undefined);
      
      // data loaded, now parse it (sync)
      if (!callback) return read(data, format);
    };
    return out;
  }, {});

},{"../util":29,"./load":20,"./read":21}],23:[function(require,module,exports){
var util = require('../util');

var TYPES = '__types__';

var PARSERS = {
  boolean: util.boolean,
  integer: util.number,
  number:  util.number,
  date:    util.date,
  string:  function(x) { return x==='' ? null : x; }
};

var TESTS = {
  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },
  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },
  number: function(x) { return !isNaN(+x) && !util.isDate(x); },
  date: function(x) { return !isNaN(Date.parse(x)); }
};

function annotation(data, types) {
  if (!types) return data && data[TYPES] || null;
  data[TYPES] = types;
}

function type(values, f) {
  f = util.$(f);
  var v, i, n;

  // if data array has type annotations, use them
  if (values[TYPES]) {
    v = f(values[TYPES]);
    if (util.isString(v)) return v;
  }

  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {
    v = f ? f(values[i]) : values[i];
  }

  return util.isDate(v) ? 'date' :
    util.isNumber(v)    ? 'number' :
    util.isBoolean(v)   ? 'boolean' :
    util.isString(v)    ? 'string' : null;
}

function typeAll(data, fields) {
  if (!data.length) return;
  fields = fields || util.keys(data[0]);
  return fields.reduce(function(types, f) {
    return (types[f] = type(data, f), types);
  }, {});
}

function infer(values, f) {
  f = util.$(f);
  var i, j, v;

  // types to test for, in precedence order
  var types = ['boolean', 'integer', 'number', 'date'];

  for (i=0; i<values.length; ++i) {
    // get next value to test
    v = f ? f(values[i]) : values[i];
    // test value against remaining types
    for (j=0; j<types.length; ++j) {
      if (util.isValid(v) && !TESTS[types[j]](v)) {
        types.splice(j, 1);
        j -= 1;
      }
    }
    // if no types left, return 'string'
    if (types.length === 0) return 'string';
  }

  return types[0];
}

function inferAll(data, fields) {
  fields = fields || util.keys(data[0]);
  return fields.reduce(function(types, f) {
    types[f] = infer(data, f);
    return types;
  }, {});
}

type.annotation = annotation;
type.all = typeAll;
type.infer = infer;
type.inferAll = inferAll;
type.parsers = PARSERS;
module.exports = type;
},{"../util":29}],24:[function(require,module,exports){
var util = require('./util');

var dl = {
  version:    '1.4.6',
  load:       require('./import/load'),
  read:       require('./import/read'),
  type:       require('./import/type'),
  Aggregator: require('./aggregate/aggregator'),
  groupby:    require('./aggregate/groupby'),
  bins:       require('./bins/bins'),
  $bin:       require('./bins/histogram').$bin,
  histogram:  require('./bins/histogram').histogram,
  format:     require('./format'),
  print:      require('./print'),
  template:   require('./template'),
  time:       require('./time')
};

util.extend(dl, util);
util.extend(dl, require('./generate'));
util.extend(dl, require('./stats'));
util.extend(dl, require('./import/readers'));

module.exports = dl;
},{"./aggregate/aggregator":7,"./aggregate/groupby":9,"./bins/bins":11,"./bins/histogram":12,"./format":13,"./generate":14,"./import/load":20,"./import/read":21,"./import/readers":22,"./import/type":23,"./print":25,"./stats":26,"./template":27,"./time":28,"./util":29}],25:[function(require,module,exports){
var util = require('./util');
var type = require('./import/type');
var stats = require('./stats');
var template = require('./template');

var FMT = {
  'date':    '|time:"%m/%d/%Y %H:%M:%S"',
  'number':  '|number:".4f"',
  'integer': '|number:"d"'
};

var POS = {
  'number':  'left',
  'integer': 'left'
};

module.exports.table = function(data, opt) {
  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);
  var fields = opt.fields || util.keys(data[0]),
      types = type.all(data);

  if (opt.start || opt.limit) {
    var a = opt.start || 0,
        b = opt.limit ? a + opt.limit : data.length;
    data = data.slice(a, b);
  }

  // determine char width of fields
  var lens = fields.map(function(name) {
    var format = FMT[types[name]] || '',
        t = template('{{' + name + format + '}}'),
        l = stats.max(data, function(x) { return t(x).length; });
    l = Math.max(Math.min(name.length, opt.minwidth), l);
    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;
  });

  // print header row
  var head = fields.map(function(name, i) {
    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);
  }).join(opt.separator);

  // build template function for each row
  var tmpl = template(fields.map(function(name, i) {
    return '{{' +
      name +
      (FMT[types[name]] || '') +
      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +
      ('|truncate:' + lens[i]) +
    '}}';
  }).join(opt.separator));

  // print table
  return head + "\n" + data.map(tmpl).join('\n');
};

module.exports.summary = function(s) {
  s = s ? s.__summary__ ? s : stats.summary(s) : this;
  var str = [], i, n;
  for (i=0, n=s.length; i<n; ++i) {
    str.push('-- ' + s[i].field + ' --');
    if (s[i].type === 'string' || s[i].distinct < 10) {
      str.push(printCategoricalProfile(s[i]));
    } else {
      str.push(printQuantitativeProfile(s[i]));
    }
    str.push('');
  }
  return str.join('\n');
};

function printQuantitativeProfile(p) {
  return [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'min:      ' + p.min,
    'max:      ' + p.max,
    'median:   ' + p.median,
    'mean:     ' + p.mean,
    'stdev:    ' + p.stdev,
    'modeskew: ' + p.modeskew
  ].join('\n');
}

function printCategoricalProfile(p) {
  var list = [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'top values: '
  ];
  var u = p.unique;
  var top = util.keys(u)
    .sort(function(a,b) { return u[b] - u[a]; })
    .slice(0, 6)
    .map(function(v) { return ' \'' + v + '\' (' + u[v] + ')'; });
  return list.concat(top).join('\n');
}
},{"./import/type":23,"./stats":26,"./template":27,"./util":29}],26:[function(require,module,exports){
var util = require('./util');
var type = require('./import/type');
var gen = require('./generate');
var stats = {};

// Collect unique values.
// Output: an array of unique values, in first-observed order
stats.unique = function(values, f, results) {
  f = util.$(f);
  results = results || [];
  var u = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    results.push(v);
  }
  return results;
};

// Return the length of the input array.
stats.count = function(values) {
  return values && values.length || 0;
};

// Count the number of non-null, non-undefined, non-NaN values.
stats.count.valid = function(values, f) {
  f = util.$(f);
  var v, i, n, valid = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) valid += 1;
  }
  return valid;
};

// Count the number of null or undefined values.
stats.count.missing = function(values, f) {
  f = util.$(f);
  var v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v == null) count += 1;
  }
  return count;
};

// Count the number of distinct values.
// Null, undefined and NaN are each considered distinct values.
stats.count.distinct = function(values, f) {
  f = util.$(f);
  var u = {}, v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    count += 1;
  }
  return count;
};

// Construct a map from distinct values to occurrence counts.
stats.count.map = function(values, f) {
  f = util.$(f);
  var map = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    map[v] = (v in map) ? map[v] + 1 : 1;
  }
  return map;
};

// Compute the median of an array of numbers.
stats.median = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  return stats.quantile(values, 0.5);
};

// Computes the quartile boundaries of an array of numbers.
stats.quartile = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  var q = stats.quantile;
  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
};

// Compute the quantile of a sorted array of numbers.
// Adapted from the D3.js implementation.
stats.quantile = function(values, f, p) {
  if (p === undefined) { p = f; f = util.identity; }
  f = util.$(f);
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = +f(values[h - 1]),
      e = H - h;
  return e ? v + e * (f(values[h]) - v) : v;
};

// Compute the sum of an array of numbers.
stats.sum = function(values, f) {
  f = util.$(f);
  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) sum += v;
  }
  return sum;
};

// Compute the mean (average) of an array of numbers.
stats.mean = function(values, f) {
  f = util.$(f);
  var mean = 0, delta, i, n, c, v;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
    }
  }
  return mean;
};

// Compute the sample variance of an array of numbers.
stats.variance = function(values, f) {
  f = util.$(f);
  if (!util.isArray(values) || values.length < 2) return 0;
  var mean = 0, M2 = 0, delta, i, c, v;
  for (i=0, c=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
      M2 = M2 + delta * (v - mean);
    }
  }
  M2 = M2 / (c - 1);
  return M2;
};

// Compute the sample standard deviation of an array of numbers.
stats.stdev = function(values, f) {
  return Math.sqrt(stats.variance(values, f));
};

// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
stats.modeskew = function(values, f) {
  var avg = stats.mean(values, f),
      med = stats.median(values, f),
      std = stats.stdev(values, f);
  return std === 0 ? 0 : (avg - med) / std;
};

// Find the minimum value in an array.
stats.min = function(values, f) {
  return stats.extent(values, f)[0];
};

// Find the maximum value in an array.
stats.max = function(values, f) {
  return stats.extent(values, f)[1];
};

// Find the minimum and maximum of an array of values.
stats.extent = function(values, f) {
  f = util.$(f);
  var a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) a = v;
      if (v > b) b = v;
    }
  }
  return [a, b];
};

// Find the integer indices of the minimum and maximum values.
stats.extent.index = function(values, f) {
  f = util.$(f);
  var x = -1, y = -1, a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; x = y = i; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) { a = v; x = i; }
      if (v > b) { b = v; y = i; }
    }
  }
  return [x, y];
};

// Compute the dot product of two arrays of numbers.
stats.dot = function(values, a, b) {
  var sum = 0, i, v;
  if (!b) {
    if (values.length !== a.length) {
      throw Error('Array lengths must match.');
    }
    for (i=0; i<values.length; ++i) {
      v = values[i] * a[i];
      if (v === v) sum += v;
    }
  } else {
    a = util.$(a);
    b = util.$(b);
    for (i=0; i<values.length; ++i) {
      v = a(values[i]) * b(values[i]);
      if (v === v) sum += v;
    }
  }
  return sum;
};

// Compute ascending rank scores for an array of values.
// Ties are assigned their collective mean rank.
stats.rank = function(values, f) {
  f = util.$(f) || util.identity;
  var a = values.map(function(v, i) {
      return {idx: i, val: f(v)};
    })
    .sort(util.comparator('val'));

  var n = values.length,
      r = Array(n),
      tie = -1, p = {}, i, v, mu;

  for (i=0; i<n; ++i) {
    v = a[i].val;
    if (tie < 0 && p === v) {
      tie = i - 1;
    } else if (tie > -1 && p !== v) {
      mu = 1 + (i-1 + tie) / 2;
      for (; tie<i; ++tie) r[a[tie].idx] = mu;
      tie = -1;
    }
    r[a[i].idx] = i + 1;
    p = v;
  }

  if (tie > -1) {
    mu = 1 + (n-1 + tie) / 2;
    for (; tie<n; ++tie) r[a[tie].idx] = mu;
  }

  return r;
};

// Compute the sample Pearson product-moment correlation of two arrays of numbers.
stats.cor = function(values, a, b) {
  var fn = b;
  b = fn ? values.map(util.$(b)) : a;
  a = fn ? values.map(util.$(a)) : values;

  var dot = stats.dot(a, b),
      mua = stats.mean(a),
      mub = stats.mean(b),
      sda = stats.stdev(a),
      sdb = stats.stdev(b),
      n = values.length;

  return (dot - n*mua*mub) / ((n-1) * sda * sdb);
};

// Compute the Spearman rank correlation of two arrays of values.
stats.cor.rank = function(values, a, b) {
  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),
      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),
      n = values.length, i, s, d;

  for (i=0, s=0; i<n; ++i) {
    d = ra[i] - rb[i];
    s += d * d;
  }

  return 1 - 6*s / (n * (n*n-1));
};

// Compute the distance correlation of two arrays of numbers.
// http://en.wikipedia.org/wiki/Distance_correlation
stats.cor.dist = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a;

  var A = stats.dist.mat(X),
      B = stats.dist.mat(Y),
      n = A.length,
      i, aa, bb, ab;

  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
    aa += A[i]*A[i];
    bb += B[i]*B[i];
    ab += A[i]*B[i];
  }

  return Math.sqrt(ab / Math.sqrt(aa*bb));
};

// Compute the vector distance between two arrays of numbers.
// Default is Euclidean (exp=2) distance, configurable via exp argument.
stats.dist = function(values, a, b, exp) {
  var f = util.isFunction(b) || util.isString(b),
      X = values,
      Y = f ? values : a,
      e = f ? exp : b,
      L2 = e === 2 || e == null,
      n = values.length, s = 0, d, i;
  if (f) {
    a = util.$(a);
    b = util.$(b);
  }
  for (i=0; i<n; ++i) {
    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
    s += L2 ? d*d : Math.pow(Math.abs(d), e);
  }
  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
};

// Construct a mean-centered distance matrix for an array of numbers.
stats.dist.mat = function(X) {
  var n = X.length,
      m = n*n,
      A = Array(m),
      R = gen.zeros(n),
      M = 0, v, i, j;

  for (i=0; i<n; ++i) {
    A[i*n+i] = 0;
    for (j=i+1; j<n; ++j) {
      A[i*n+j] = (v = Math.abs(X[i] - X[j]));
      A[j*n+i] = v;
      R[i] += v;
      R[j] += v;
    }
  }

  for (i=0; i<n; ++i) {
    M += R[i];
    R[i] /= n;
  }
  M /= m;

  for (i=0; i<n; ++i) {
    for (j=i; j<n; ++j) {
      A[i*n+j] += M - R[i] - R[j];
      A[j*n+i] = A[i*n+j];
    }
  }

  return A;
};

// Compute the Shannon entropy (log base 2) of an array of counts.
stats.entropy = function(counts, f) {
  f = util.$(f);
  var i, p, s = 0, H = 0, n = counts.length;
  for (i=0; i<n; ++i) {
    s += (f ? f(counts[i]) : counts[i]);
  }
  if (s === 0) return 0;
  for (i=0; i<n; ++i) {
    p = (f ? f(counts[i]) : counts[i]) / s;
    if (p) H += p * Math.log(p);
  }
  return -H / Math.LN2;
};

// Compute the mutual information between two discrete variables.
// Returns an array of the form [MI, MI_distance] 
// MI_distance is defined as 1 - I(a,b) / H(a,b).
// http://en.wikipedia.org/wiki/Mutual_information
stats.mutual = function(values, a, b, counts) {
  var x = counts ? values.map(util.$(a)) : values,
      y = counts ? values.map(util.$(b)) : a,
      z = counts ? values.map(util.$(counts)) : b;

  var px = {},
      py = {},
      n = z.length,
      s = 0, I = 0, H = 0, p, t, i;

  for (i=0; i<n; ++i) {
    px[x[i]] = 0;
    py[y[i]] = 0;
  }

  for (i=0; i<n; ++i) {
    px[x[i]] += z[i];
    py[y[i]] += z[i];
    s += z[i];
  }

  t = 1 / (s * Math.LN2);
  for (i=0; i<n; ++i) {
    if (z[i] === 0) continue;
    p = (s * z[i]) / (px[x[i]] * py[y[i]]);
    I += z[i] * t * Math.log(p);
    H += z[i] * t * Math.log(z[i]/s);
  }

  return [I, 1 + I/H];
};

// Compute the mutual information between two discrete variables.
stats.mutual.info = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[0];
};

// Compute the mutual information distance between two discrete variables.
// MI_distance is defined as 1 - I(a,b) / H(a,b).
stats.mutual.dist = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[1];
};

// Compute a profile of summary statistics for a variable.
stats.profile = function(values, f) {
  var mean = 0,
      valid = 0,
      missing = 0,
      distinct = 0,
      min = null,
      max = null,
      M2 = 0,
      vals = [],
      u = {}, delta, sd, i, v, x;

  // compute summary stats
  for (i=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];

    // update unique values
    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);

    if (v == null) {
      ++missing;
    } else if (util.isValid(v)) {
      // update stats
      x = (typeof v === 'string') ? v.length : v;
      if (min===null || x < min) min = x;
      if (max===null || x > max) max = x;
      delta = x - mean;
      mean = mean + delta / (++valid);
      M2 = M2 + delta * (x - mean);
      vals.push(x);
    }
  }
  M2 = M2 / (valid - 1);
  sd = Math.sqrt(M2);

  // sort values for median and iqr
  vals.sort(util.cmp);

  return {
    type:     type(values, f),
    unique:   u,
    count:    values.length,
    valid:    valid,
    missing:  missing,
    distinct: distinct,
    min:      min,
    max:      max,
    mean:     mean,
    stdev:    sd,
    median:   (v = stats.quantile(vals, 0.5)),
    q1:       stats.quantile(vals, 0.25),
    q3:       stats.quantile(vals, 0.75),
    modeskew: sd === 0 ? 0 : (mean - v) / sd
  };
};

// Compute profiles for all variables in a data set.
stats.summary = function(data, fields) {
  fields = fields || util.keys(data[0]);
  var s = fields.map(function(f) {
    var p = stats.profile(data, util.$(f));
    return (p.field = f, p);
  });
  return (s.__summary__ = true, s);
};

module.exports = stats;
},{"./generate":14,"./import/type":23,"./util":29}],27:[function(require,module,exports){
var util = require('./util'),
    format = require('./format');

var context = {
  formats:    [],
  format_map: {},
  truncate:   util.truncate,
  pad:        util.pad
};

function template(text) {
  var src = source(text, 'd');
  src = 'var __t; return ' + src + ';';

  /* jshint evil: true */
  return (new Function('d', src)).bind(context);
}

template.source = source;
template.context = context;
module.exports = template;

// Clear cache of format objects.
// This can *break* prior template functions, so invoke with care!
template.clearFormatCache = function() {
  context.formats = [];
  context.format_map = {};
};

// Generate property access code for use within template source.
// object: the name of the object (variable) containing template data
// property: the property access string, verbatim from template tag
template.property = function(object, property) {
  var src = util.field(property).map(util.str).join('][');
  return object + '[' + src + ']';
};

// Generate source code for a template function.
// text: the template text
// variable: the name of the data object variable ('obj' by default)
// properties: optional hash for collecting all accessed properties
function source(text, variable, properties) {
  variable = variable || 'obj';
  var index = 0;
  var src = '\'';
  var regex = template_re;

  // Compile the template source, escaping string literals appropriately.
  text.replace(regex, function(match, interpolate, offset) {
    src += text
      .slice(index, offset)
      .replace(template_escaper, template_escapeChar);
    index = offset + match.length;

    if (interpolate) {
      src += '\'\n+((__t=(' +
        template_var(interpolate, variable, properties) +
        '))==null?\'\':__t)+\n\'';
    }

    // Adobe VMs need the match returned to produce the correct offest.
    return match;
  });
  return src + '\'';
}

function template_var(text, variable, properties) {
  var filters = text.match(filter_re);
  var prop = filters.shift().trim();
  var stringCast = true;

  function strcall(fn) {
    fn = fn || '';
    if (stringCast) {
      stringCast = false;
      src = 'String(' + src + ')' + fn;
    } else {
      src += fn;
    }
    return src;
  }

  function date() {
    return '(typeof ' + src + '==="number"?new Date('+src+'):'+src+')';
  }

  function number_format(fmt, key) {
    a = template_format(args[0], key, fmt);
    stringCast = false;
    src = 'this.formats['+a+']('+src+')';
  }
  
  function time_format(fmt, key) {
    a = template_format(args[0], key, fmt);
    stringCast = false;
    src = 'this.formats['+a+']('+date()+')';
  }

  if (properties) properties[prop] = 1;
  var src = template.property(variable, prop);

  for (var i=0; i<filters.length; ++i) {
    var f = filters[i], args = null, pidx, a, b;

    if ((pidx=f.indexOf(':')) > 0) {
      f = f.slice(0, pidx);
      args = filters[i].slice(pidx+1)
        .match(args_re)
        .map(function(s) { return s.trim(); });
    }
    f = f.trim();

    switch (f) {
      case 'length':
        strcall('.length');
        break;
      case 'lower':
        strcall('.toLowerCase()');
        break;
      case 'upper':
        strcall('.toUpperCase()');
        break;
      case 'lower-locale':
        strcall('.toLocaleLowerCase()');
        break;
      case 'upper-locale':
        strcall('.toLocaleUpperCase()');
        break;
      case 'trim':
        strcall('.trim()');
        break;
      case 'left':
        a = util.number(args[0]);
        strcall('.slice(0,' + a + ')');
        break;
      case 'right':
        a = util.number(args[0]);
        strcall('.slice(-' + a +')');
        break;
      case 'mid':
        a = util.number(args[0]);
        b = a + util.number(args[1]);
        strcall('.slice(+'+a+','+b+')');
        break;
      case 'slice':
        a = util.number(args[0]);
        strcall('.slice('+ a +
          (args.length > 1 ? ',' + util.number(args[1]) : '') +
          ')');
        break;
      case 'truncate':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.truncate(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'pad':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.pad(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'number':
        number_format(format.number, 'number');
        break;
      case 'time':
        time_format(format.time, 'time');
        break;
      case 'time-utc':
        time_format(format.utc, 'time-utc');
        break;
      default:
        throw Error('Unrecognized template filter: ' + f);
    }
  }

  return src;
}

var template_re = /\{\{(.+?)\}\}|$/g,
    filter_re = /(?:"[^"]*"|\'[^\']*\'|[^\|"]+|[^\|\']+)+/g,
    args_re = /(?:"[^"]*"|\'[^\']*\'|[^,"]+|[^,\']+)+/g;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var template_escapes = {
  '\'':     '\'',
  '\\':     '\\',
  '\r':     'r',
  '\n':     'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var template_escaper = /\\|'|\r|\n|\u2028|\u2029/g;

function template_escapeChar(match) {
  return '\\' + template_escapes[match];
}

function template_format(pattern, key, fmt) {
  if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
      (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
    pattern = pattern.slice(1, -1);
  } else {
    throw Error('Format pattern must be quoted: ' + pattern);
  }
  key = key + ':' + pattern;
  if (!context.format_map[key]) {
    var f = fmt(pattern);
    var i = context.formats.length;
    context.formats.push(f);
    context.format_map[key] = i;
  }
  return context.format_map[key];
}

},{"./format":13,"./util":29}],28:[function(require,module,exports){
var d3_time = require('d3-time');

var tempDate = new Date(),
    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD
    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);

function date(d) {
  return (tempDate.setTime(+d), tempDate);
}

// create a time unit entry
function entry(type, date, unit, step, min, max) {
  var e = {
    type: type,
    date: date,
    unit: unit
  };
  if (step) {
    e.step = step;
  } else {
    e.minstep = 1;
  }
  if (min != null) e.min = min;
  if (max != null) e.max = max;
  return e;
}

function create(type, unit, base, step, min, max) {
  return entry(type,
    function(d) { return unit.offset(base, d); },
    function(d) { return unit.count(base, d); },
    step, min, max);
}

var locale = [
  create('second', d3_time.second, baseDate),
  create('minute', d3_time.minute, baseDate),
  create('hour',   d3_time.hour,   baseDate),
  create('day',    d3_time.day,    baseDate, [1, 7]),
  create('month',  d3_time.month,  baseDate, [1, 3, 6]),
  create('year',   d3_time.year,   baseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(1970, 0, 1, 0, 0, d); },
    function(d) { return date(d).getSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(1970, 0, 1, 0, d); },
    function(d) { return date(d).getMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(1970, 0, 1, d); },
    function(d) { return date(d).getHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(1970, 0, 4+d); },
    function(d) { return date(d).getDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(1970, 0, d); },
    function(d) { return date(d).getDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(1970, d % 12, 1); },
    function(d) { return date(d).getMonth(); },
    [1], 0, 11
  )
];

var utc = [
  create('second', d3_time.utcSecond, utcBaseDate),
  create('minute', d3_time.utcMinute, utcBaseDate),
  create('hour',   d3_time.utcHour,   utcBaseDate),
  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),
  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),
  create('year',   d3_time.utcYear,   utcBaseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },
    function(d) { return date(d).getUTCSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },
    function(d) { return date(d).getUTCMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },
    function(d) { return date(d).getUTCHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },
    function(d) { return date(d).getUTCDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(Date.UTC(1970, 0, d)); },
    function(d) { return date(d).getUTCDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },
    function(d) { return date(d).getUTCMonth(); },
    [1], 0, 11
  )
];

var STEPS = [
  [31536e6, 5],  // 1-year
  [7776e6, 4],   // 3-month
  [2592e6, 4],   // 1-month
  [12096e5, 3],  // 2-week
  [6048e5, 3],   // 1-week
  [1728e5, 3],   // 2-day
  [864e5, 3],    // 1-day
  [432e5, 2],    // 12-hour
  [216e5, 2],    // 6-hour
  [108e5, 2],    // 3-hour
  [36e5, 2],     // 1-hour
  [18e5, 1],     // 30-minute
  [9e5, 1],      // 15-minute
  [3e5, 1],      // 5-minute
  [6e4, 1],      // 1-minute
  [3e4, 0],      // 30-second
  [15e3, 0],     // 15-second
  [5e3, 0],      // 5-second
  [1e3, 0]       // 1-second
];

function find(units, span, minb, maxb) {
  var step = STEPS[0], i, n, bins;

  for (i=1, n=STEPS.length; i<n; ++i) {
    step = STEPS[i];
    if (span > step[0]) {
      bins = span / step[0];
      if (bins > maxb) {
        return units[STEPS[i-1][1]];
      }
      if (bins >= minb) {
        return units[step[1]];
      }
    }
  }
  return units[STEPS[n-1][1]];
}

function toUnitMap(units) {
  var map = {}, i, n;
  for (i=0, n=units.length; i<n; ++i) {
    map[units[i].type] = units[i];
  }
  map.find = function(span, minb, maxb) {
    return find(units, span, minb, maxb);
  };
  return map;
}

module.exports = toUnitMap(locale);
module.exports.utc = toUnitMap(utc);

},{"d3-time":6}],29:[function(require,module,exports){
var buffer = require('buffer'),
    time = require('./time'),
    utc = time.utc;

var u = module.exports = {};

// utility functions

var FNAME = '__name__';

u.namedfunc = function(name, f) { return (f[FNAME] = name, f); };

u.name = function(f) { return f==null ? null : f[FNAME]; };

u.identity = function(x) { return x; };

u.true = u.namedfunc('true', function() { return true; });

u.false = u.namedfunc('false', function() { return false; });

u.duplicate = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};

u.equal = function(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
};

u.extend = function(obj) {
  for (var x, name, i=1, len=arguments.length; i<len; ++i) {
    x = arguments[i];
    for (name in x) { obj[name] = x[name]; }
  }
  return obj;
};

u.length = function(x) {
  return x != null && x.length != null ? x.length : null;
};

u.keys = function(x) {
  var keys = [], k;
  for (k in x) keys.push(k);
  return keys;
};

u.vals = function(x) {
  var vals = [], k;
  for (k in x) vals.push(x[k]);
  return vals;
};

u.toMap = function(list, f) {
  return (f = u.$(f)) ?
    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :
    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});
};

u.keystr = function(values) {
  // use to ensure consistent key generation across modules
  var n = values.length;
  if (!n) return '';
  for (var s=String(values[0]), i=1; i<n; ++i) {
    s += '|' + String(values[i]);
  }
  return s;
};

// type checking functions

var toString = Object.prototype.toString;

u.isObject = function(obj) {
  return obj === Object(obj);
};

u.isFunction = function(obj) {
  return toString.call(obj) === '[object Function]';
};

u.isString = function(obj) {
  return typeof value === 'string' || toString.call(obj) === '[object String]';
};

u.isArray = Array.isArray || function(obj) {
  return toString.call(obj) === '[object Array]';
};

u.isNumber = function(obj) {
  return typeof obj === 'number' || toString.call(obj) === '[object Number]';
};

u.isBoolean = function(obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

u.isDate = function(obj) {
  return toString.call(obj) === '[object Date]';
};

u.isValid = function(obj) {
  return obj != null && obj === obj;
};

u.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;

// type coercion functions

u.number = function(s) {
  return s == null || s === '' ? null : +s;
};

u.boolean = function(s) {
  return s == null || s === '' ? null : s==='false' ? false : !!s;
};

u.date = function(s) {
  return s == null || s === '' ? null : Date.parse(s);
};

u.array = function(x) {
  return x != null ? (u.isArray(x) ? x : [x]) : [];
};

u.str = function(x) {
  return u.isArray(x) ? '[' + x.map(u.str) + ']'
    : u.isObject(x) ? JSON.stringify(x)
    : u.isString(x) ? ('\''+util_escape_str(x)+'\'') : x;
};

var escape_str_re = /(^|[^\\])'/g;

function util_escape_str(x) {
  return x.replace(escape_str_re, '$1\\\'');
}

// data access functions

var field_re = /\[(.*?)\]|[^.\[]+/g;

u.field = function(f) {
  return String(f).match(field_re).map(function(d) {
    return d[0] !== '[' ? d :
      d[1] !== "'" && d[1] !== '"' ? d.slice(1, -1) :
      d.slice(2, -2).replace(/\\(["'])/g, '$1');
  });
};

u.accessor = function(f) {
  var s;
  return f==null || u.isFunction(f) ? f :
    u.namedfunc(f, (s = u.field(f)).length > 1 ?
      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :
      function(x) { return x[f]; }
    );
};

// short-cut for accessor
u.$ = u.accessor;

u.mutator = function(f) {
  var s;
  return u.isString(f) && (s=u.field(f)).length > 1 ?
    function(x, v) {
      for (var i=0; i<s.length-1; ++i) x = x[s[i]];
      x[s[i]] = v;
    } :
    function(x, v) { x[f] = v; };
};


u.$func = function(name, op) {
  return function(f) {
    f = u.$(f) || u.identity;
    var n = name + (u.name(f) ? '_'+u.name(f) : '');
    return u.namedfunc(n, function(d) { return op(f(d)); });
  };
};

u.$valid  = u.$func('valid', u.isValid);
u.$length = u.$func('length', u.length);

u.$in = function(f, values) {
  f = u.$(f);
  var map = u.isArray(values) ? u.toMap(values) : values;
  return function(d) { return !!map[f(d)]; };
};

u.$year   = u.$func('year', time.year.unit);
u.$month  = u.$func('month', time.months.unit);
u.$date   = u.$func('date', time.dates.unit);
u.$day    = u.$func('day', time.weekdays.unit);
u.$hour   = u.$func('hour', time.hours.unit);
u.$minute = u.$func('minute', time.minutes.unit);
u.$second = u.$func('second', time.seconds.unit);

u.$utcYear   = u.$func('utcYear', utc.year.unit);
u.$utcMonth  = u.$func('utcMonth', utc.months.unit);
u.$utcDate   = u.$func('utcDate', utc.dates.unit);
u.$utcDay    = u.$func('utcDay', utc.weekdays.unit);
u.$utcHour   = u.$func('utcHour', utc.hours.unit);
u.$utcMinute = u.$func('utcMinute', utc.minutes.unit);
u.$utcSecond = u.$func('utcSecond', utc.seconds.unit);

// comparison / sorting functions

u.comparator = function(sort) {
  var sign = [];
  if (sort === undefined) sort = [];
  sort = u.array(sort).map(function(f) {
    var s = 1;
    if      (f[0] === '-') { s = -1; f = f.slice(1); }
    else if (f[0] === '+') { s = +1; f = f.slice(1); }
    sign.push(s);
    return u.accessor(f);
  });
  return function(a,b) {
    var i, n, f, x, y;
    for (i=0, n=sort.length; i<n; ++i) {
      f = sort[i]; x = f(a); y = f(b);
      if (x < y) return -1 * sign[i];
      if (x > y) return sign[i];
    }
    return 0;
  };
};

u.cmp = function(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else if (a >= b) {
    return 0;
  } else if (a === null) {
    return -1;
  } else if (b === null) {
    return 1;
  }
  return NaN;
};

u.numcmp = function(a, b) { return a - b; };

u.stablesort = function(array, sortBy, keyFn) {
  var indices = array.reduce(function(idx, v, i) {
    return (idx[keyFn(v)] = i, idx);
  }, {});

  array.sort(function(a, b) {
    var sa = sortBy(a),
        sb = sortBy(b);
    return sa < sb ? -1 : sa > sb ? 1
         : (indices[keyFn(a)] - indices[keyFn(b)]);
  });

  return array;
};


// string functions

u.pad = function(s, length, pos, padchar) {
  padchar = padchar || " ";
  var d = length - s.length;
  if (d <= 0) return s;
  switch (pos) {
    case 'left':
      return strrep(d, padchar) + s;
    case 'middle':
    case 'center':
      return strrep(Math.floor(d/2), padchar) +
         s + strrep(Math.ceil(d/2), padchar);
    default:
      return s + strrep(d, padchar);
  }
};

function strrep(n, str) {
  var s = "", i;
  for (i=0; i<n; ++i) s += str;
  return s;
}

u.truncate = function(s, length, pos, word, ellipsis) {
  var len = s.length;
  if (len <= length) return s;
  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\u2026';
  var l = Math.max(0, length - ellipsis.length);

  switch (pos) {
    case 'left':
      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));
    case 'middle':
    case 'center':
      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);
      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +
        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));
    default:
      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;
  }
};

function truncateOnWord(s, len, rev) {
  var cnt = 0, tok = s.split(truncate_word_re);
  if (rev) {
    s = (tok = tok.reverse())
      .filter(function(w) { cnt += w.length; return cnt <= len; })
      .reverse();
  } else {
    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });
  }
  return s.length ? s.join('').trim() : tok[0].slice(0, len);
}

var truncate_word_re = /([\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF])/;

},{"./time":28,"buffer":2}],30:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],31:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],32:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],33:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":32,"_process":31,"inherits":30}],34:[function(require,module,exports){
var DEPS = require('./Dependencies').ALL;

function create(cs, reflow) {
  var out = {};
  copy(cs, out);

  out.add = [];
  out.mod = [];
  out.rem = [];

  out.reflow = reflow;

  return out;
}

function copy(a, b) {
  b.stamp = a ? a.stamp : 0;
  b.sort  = a ? a.sort  : null;
  b.facet = a ? a.facet : null;
  b.trans = a ? a.trans : null;
  b.dirty = a ? a.dirty : [];
  b.request = a ? a.request : null;
  for (var d, i=0, n=DEPS.length; i<n; ++i) {
    b[d=DEPS[i]] = a ? a[d] : {};
  }
}

module.exports = {
  create: create,
  copy: copy
};
},{"./Dependencies":37}],35:[function(require,module,exports){
var log = require('vega-logging'),
    Tuple = require('./Tuple'),
    Base = require('./Node').prototype;

function Collector(graph) {
  Base.init.call(this, graph);
  this._data = [];
  this.router(true).collector(true);
}

var prototype = (Collector.prototype = Object.create(Base));
prototype.constructor = Collector;

prototype.data = function() {
  return this._data;
};

prototype.evaluate = function(input) {
  log.debug(input, ["collecting"]);

  if (input.rem.length) {
    this._data = Tuple.idFilter(this._data, input.rem);
  }

  if (input.add.length) {
    this._data = this._data.length ? this._data.concat(input.add) : input.add;
  }

  if (input.sort) {
    this._data.sort(input.sort);
  }

  if (input.reflow) {
    input.mod = input.mod.concat(
      Tuple.idFilter(this._data, input.add, input.mod, input.rem));
    input.reflow = false;
  }

  return input;
};

module.exports = Collector;
},{"./Node":40,"./Tuple":42,"vega-logging":49}],36:[function(require,module,exports){
var log = require('vega-logging'),
    ChangeSet = require('./ChangeSet'), 
    Collector = require('./Collector'),
    Tuple = require('./Tuple'),
    Node = require('./Node'); // jshint ignore:line

function DataSource(graph, name, facet) {
  this._graph = graph;
  this._name = name;
  this._data = [];
  this._source = null;
  this._facet  = facet;
  this._input  = ChangeSet.create();
  this._output = null; // Output changeset

  this._inputNode  = null;
  this._outputNode = null;
  this._pipeline  = null; // Pipeline of transformations.
  this._collector = null; // Collector to materialize output of pipeline.
  this._mutates = false;  // Does any pipeline operator mutate tuples?
}

var prototype = DataSource.prototype;

prototype.name = function(name) {
  if (!arguments.length) return this._name;
  return (this._name = name, this);
};

prototype.source = function(src) {
  if (!arguments.length) return this._source;
  return (this._source = this._graph.data(src));
};

prototype.insert = function(tuples) {
  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));
  return this;
};

prototype.remove = function(where) {
  var remove = this._data.filter(where);
  this._input.rem = this._input.rem.concat(remove);
  return this;
};

prototype.update = function(where, field, func) {
  var mod = this._input.mod,
      ids = Tuple.idMap(mod);

  this._input.fields[field] = 1;

  this._data.filter(where).forEach(function(x) {
    var prev = x[field],
        next = func(x);
    if (prev !== next) {
      Tuple.set(x, field, next);
      if (ids[x._id] !== 1) {
        mod.push(x);
        ids[x._id] = 1;
      }
    }
  });

  return this;
};

prototype.values = function(data) {
  if (!arguments.length) return this._collector.data();

  // Replace backing data
  this._input.rem = this._data.slice();
  if (data) { this.insert(data); }
  return this;
};

prototype.mutates = function(m) {
  if (!arguments.length) return this._mutates;
  this._mutates = this._mutates || m;
  return this;
};

prototype.last = function() {
  return this._output;
};

prototype.fire = function(input) {
  if (input) this._input = input;
  this._graph.propagate(this._input, this._pipeline[0]);
  return this;
};

prototype.pipeline = function(pipeline) {
  if (!arguments.length) return this._pipeline;

  var graph = this._graph,
      status;

  pipeline.unshift(this._inputNode = DataSourceInput(this));
  status = graph.preprocess(pipeline);

  if (status.router) {
    pipeline.push(status.collector = new Collector(graph));
  }

  pipeline.push(this._outputNode = DataSourceOutput(this));
  this._collector = status.collector;
  this._mutates = !!status.mutates;
  graph.connect(this._pipeline = pipeline);

  return this;
};

prototype.synchronize = function() {
  this._graph.synchronize(this._pipeline);
  return this;
};

prototype.listener = function() { 
  return DataSourceListener(this).addListener(this._inputNode);
};

prototype.addListener = function(l) {
  if (l instanceof DataSource) {
    this._collector.addListener(l.listener());
  } else {
    this._outputNode.addListener(l);      
  }
  return this;
};

prototype.removeListener = function(l) {
  this._outputNode.removeListener(l);
};

prototype.listeners = function(ds) {
  return (ds ? this._collector : this._outputNode).listeners();
};

// Input node applies the datasource's delta, and propagates it to 
// the rest of the pipeline. It receives touches to reflow data.
function DataSourceInput(ds) {
  var input = new Node(ds._graph)
    .router(true)
    .collector(true);

  input.data = function() {
    return ds._data;
  };

  input.evaluate = function(input) {
    log.debug(input, ['input', ds._name]);

    var delta = ds._input, 
        out = ChangeSet.create(input), f;

    // Delta might contain fields updated through API
    for (f in delta.fields) {
      out.fields[f] = 1;
    }

    // update data
    if (delta.rem.length) {
      ds._data = Tuple.idFilter(ds._data, delta.rem);
    }

    if (delta.add.length) {
      ds._data = ds._data.concat(delta.add);
    }

    // if reflowing, add any other tuples not currently in changeset
    if (input.reflow) {
      delta.mod = delta.mod.concat(
        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));
    }

    // reset change list
    ds._input = ChangeSet.create();

    out.add = delta.add; 
    out.mod = delta.mod;
    out.rem = delta.rem;
    out.facet = ds._facet;
    return out;
  };

  return input;
}

// Output node captures the last changeset seen by this datasource
// (needed for joins and builds) and materializes any nested data.
// If this datasource is faceted, materializes the values in the facet.
function DataSourceOutput(ds) {
  var output = new Node(ds._graph)
    .router(true)
    .reflows(true)
    .collector(true);

  output.data = function() {
    return ds._collector ? ds._collector.data() : ds._data;
  };

  output.evaluate = function(input) {
    log.debug(input, ['output', ds._name]);

    var out = ChangeSet.create(input, true);

    if (ds._facet) {
      ds._facet.values = ds.values();
      input.facet = null;
    }

    ds._output = input;
    out.data[ds._name] = 1;
    return out;
  };

  return output;
}

function DataSourceListener(ds) {
  var l = new Node(ds._graph).router(true);

  l.evaluate = function(input) {
    // Tuple derivation carries a cost. So only derive if the pipeline has
    // operators that mutate, and thus would override the source data.
    if (ds.mutates()) {  
      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly
          output = ChangeSet.create(input);

      output.add = input.add.map(function(t) {
        return (map[t._id] = Tuple.derive(t));
      });

      output.mod = input.mod.map(function(t) {
        return Tuple.rederive(t, map[t._id]);
      });

      output.rem = input.rem.map(function(t) { 
        var o = map[t._id];
        return (map[t._id] = null, o);
      });

      return (ds._input = output);
    } else {
      return (ds._input = input);
    }
  };

  return l;
}

module.exports = DataSource;

},{"./ChangeSet":34,"./Collector":35,"./Node":40,"./Tuple":42,"vega-logging":49}],37:[function(require,module,exports){
var deps = module.exports = {
  ALL: ['data', 'fields', 'scales', 'signals']
};
deps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });

},{}],38:[function(require,module,exports){
var dl = require('datalib'),
    Heap = require('./Heap'),
    ChangeSet = require('./ChangeSet'),
    DataSource = require('./DataSource'),
    Collector = require('./Collector'),
    Tuple = require('./Tuple'),
    Signal = require('./Signal'),
    Deps = require('./Dependencies');

function Graph() {
}

var prototype = Graph.prototype;

prototype.init = function() {
  this._stamp = 0;
  this._rank  = 0;

  this._data = {};
  this._signals = {};

  this.doNotPropagate = {};
};

prototype.rank = function() {
  return ++this._rank;
};

prototype.values = function(type, names, hash) {
  var data = (type === Deps.SIGNALS ? this._signals : this._data),
      n = (names !== undefined ? names : dl.keys(data)),
      vals, i;

  if (Array.isArray(n)) {
    vals = hash || {};
    for (i=0; i<n.length; ++i) {
      vals[n[i]] = data[n[i]].values();
    }
    return vals;
  } else {
    return data[n].values();
  }
};

// Retain for backwards-compatibility
prototype.dataValues = function(names) {
  return this.values(Deps.DATA, names);
};

// Retain for backwards-compatibility
prototype.signalValues = function(names) {
  return this.values(Deps.SIGNALS, names);
};

prototype.data = function(name, pipeline, facet) {
  var db = this._data;
  if (!arguments.length) {
    var all = [], key;
    for (key in db) { all.push(db[key]); }
    return all;
  } else if (arguments.length === 1) {
    return db[name];
  } else {
    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));
  }
};

prototype.signal = function(name, init) {
  if (arguments.length === 1) {
    var m = this;
    return Array.isArray(name) ?
      name.map(function(n) { return m._signals[n]; }) :
      this._signals[name];
  } else {
    return (this._signals[name] = new Signal(this, name, init));
  }
};

prototype.signalRef = function(ref) {
  if (!Array.isArray(ref)) {
    ref = dl.field(ref);
  }

  var value = this.signal(ref[0]).value();
  if (ref.length > 1) {
    for (var i=1, n=ref.length; i<n; ++i) {
      value = value[ref[i]];
    }
  }
  return value;
};

// Stamp should be specified with caution. It is necessary for inline datasources,
// which need to be populated during the same cycle even though propagation has
// passed that part of the dataflow graph.  
prototype.propagate = function(pulse, node, stamp) {
  var pulses = {},
      listeners, next, nplse, tpls, ntpls, i, len;

  // new PQ with each propagation cycle so that we can pulse branches
  // of the dataflow graph during a propagation (e.g., when creating
  // a new inline datasource).
  var pq = new Heap(function(a, b) {
    // Sort on qrank (queue-rank).
    // Rank can change during propagation due to rewiring.
    return a._qrank - b._qrank;
  });

  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');

  pulse.stamp = stamp || ++this._stamp;
  pulses[node._id] = pulse;
  pq.push(node.qrank(true));

  while (pq.size() > 0) {
    node  = pq.peek();
    pulse = pulses[node._id];

    if (node.rank() !== node.qrank()) {
      // A node's rank might change during a propagation. Re-queue if so.
      pq.replace(node.qrank(true));
    } else {
      // Evaluate node and propagate pulse.
      pq.pop();
      pulses[node._id] = null;
      listeners = node._listeners;
      pulse = this.evaluate(pulse, node);

      // Propagate the pulse. 
      if (pulse !== this.doNotPropagate) {
        // Ensure reflow pulses always send reflow pulses even if skipped.
        if (!pulse.reflow && node.reflows()) {
          pulse = ChangeSet.create(pulse, true);
        }

        for (i=0, len=listeners.length; i<len; ++i) {
          next = listeners[i];

          if ((nplse = pulses[next._id]) !== undefined) {
            if (nplse === null) throw Error('Already propagated to node.');
            if (nplse === pulse) continue;  // Re-queueing the same pulse.

            // We've already queued this node. Ensure there should be at most one
            // pulse with tuples (add/mod/rem), and the remainder will be reflows. 
            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;
            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;

            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');

            // Combine reflow and tuples into a single pulse. 
            pulses[next._id] = tpls ? pulse : nplse;
            pulses[next._id].reflow = pulse.reflow || nplse.reflow;
          } else {
            // First time we're seeing this node, queue it for propagation.
            pq.push(next.qrank(true));
            pulses[next._id] = pulse;
          }
        }
      }
    }
  }
};

// Process a new branch of the dataflow graph prior to connection:
// (1) Insert new Collector nodes as needed. 
// (2) Track + return mutation/routing status of the branch.
prototype.preprocess = function(branch) {
  var graph = this,
      mutates = 0,
      node, router, collector, collects;

  for (var i=0; i<branch.length; ++i) {
    node = branch[i];

    // Batch nodes need access to a materialized dataset. 
    if (node.batch() && !node._collector) {
      if (router || !collector) {
        node = new Collector(graph);
        branch.splice(i, 0, node);
        router = false;
      } else {
        node._collector = collector;
      }
    }

    if ((collects = node.collector())) collector = node;
    router  = router  || node.router() && !collects;
    mutates = mutates || node.mutates();

    // A collector needs to be inserted after tuple-producing
    // nodes for correct previous value tracking.
    if (node.produces()) {
      branch.splice(i+1, 0, new Collector(graph));
      router = false;
    }
  }

  return {router: router, collector: collector, mutates: mutates};
};

prototype.connect = function(branch) {
  var collector, node, data, signals, i, n, j, m;

  // connect the pipeline
  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (node.collector()) collector = node;

    data = node.dependency(Deps.DATA);
    for (j=0, m=data.length; j<m; ++j) {
      this.data(data[j]).addListener(collector);
    }

    signals = node.dependency(Deps.SIGNALS);
    for (j=0, m=signals.length; j<m; ++j) {
      this.signal(signals[j]).addListener(collector);
    }

    if (i > 0) branch[i-1].addListener(node);
  }

  return branch;
};

prototype.disconnect = function(branch) {
  var collector, node, data, signals, i, n, j, m;

  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (node.collector()) collector = node;

    data = node.dependency(Deps.DATA);
    for (j=0, m=data.length; j<m; ++j) {
      this.data(data[j]).removeListener(collector);
    }

    signals = node.dependency(Deps.SIGNALS);
    for (j=0, m=signals.length; j<m; ++j) {
      this.signal(signals[j]).removeListener(collector);
    }

    node.disconnect();
  }

  return branch;
};

prototype.synchronize = function(branch) {
  var ids = {},
      node, data, i, n, j, m, d, id;

  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (!node.collector()) continue;

    for (j=0, data=node.data(), m=data.length; j<m; ++j) {
      id = (d = data[j])._id;
      if (ids[id]) continue; 
      Tuple.prev_update(d);
      ids[id] = 1; 
    }
  }

  return this;
};

prototype.reevaluate = function(pulse, node) {
  var reflowed = pulse.reflow && node.last() >= pulse.stamp,
      run = node.router() || pulse.add.length || pulse.rem.length;

  return run || !reflowed || node.reevaluate(pulse);
};

prototype.evaluate = function(pulse, node) {
  if (!this.reevaluate(pulse, node)) return pulse;
  pulse = node.evaluate(pulse);
  node.last(pulse.stamp);
  return pulse;
};

module.exports = Graph;

},{"./ChangeSet":34,"./Collector":35,"./DataSource":36,"./Dependencies":37,"./Heap":39,"./Signal":41,"./Tuple":42,"datalib":24}],39:[function(require,module,exports){
function Heap(comparator) {
  this.cmp = comparator;
  this.nodes = [];
}

var prototype = Heap.prototype;

prototype.size = function() {
  return this.nodes.length;
};

prototype.clear = function() {
  return (this.nodes = [], this);
};

prototype.peek = function() {
  return this.nodes[0];
};

prototype.push = function(x) {
  var array = this.nodes;
  array.push(x);
  return _siftdown(array, 0, array.length-1, this.cmp);
};

prototype.pop = function() {
  var array = this.nodes,
      last = array.pop(),
      item;

  if (array.length) {
    item = array[0];
    array[0] = last;
    _siftup(array, 0, this.cmp);
  } else {
    item = last;
  }
  return item;
};

prototype.replace = function(item) {
  var array = this.nodes,
      retval = array[0];
  array[0] = item;
  _siftup(array, 0, this.cmp);
  return retval;
};

prototype.pushpop = function(item) {
  var array = this.nodes, ref = array[0];
  if (array.length && this.cmp(ref, item) < 0) {
    array[0] = item;
    item = ref;
    _siftup(array, 0, this.cmp);
  }
  return item;
};

function _siftdown(array, start, idx, cmp) {
  var item, parent, pidx;

  item = array[idx];
  while (idx > start) {
    pidx = (idx - 1) >> 1;
    parent = array[pidx];
    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return (array[idx] = item);
}

function _siftup(array, idx, cmp) {
  var start = idx,
      end = array.length,
      item = array[idx],
      cidx = 2 * idx + 1, ridx;

  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }
    array[idx] = array[cidx];
    idx = cidx;
    cidx = 2 * idx + 1;
  }
  array[idx] = item;
  return _siftdown(array, start, idx, cmp);
}

module.exports = Heap;

},{}],40:[function(require,module,exports){
var DEPS = require('./Dependencies').ALL,
    nodeID = 0;

function Node(graph) {
  if (graph) this.init(graph);
}

var Flags = Node.Flags = {
  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.
  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.
  Produces:   0x04, // Produces new tuples. 
  Mutates:    0x08, // Sets properties of incoming tuples.
  Reflows:    0x10, // Forwards a reflow pulse.
  Batch:      0x20  // Performs batch data processing, needs collector.
};

var prototype = Node.prototype;

prototype.init = function(graph) {
  this._id = ++nodeID;
  this._graph = graph;
  this._rank  = graph.rank(); // Topological sort by rank
  this._qrank = null; // Rank when enqueued for propagation
  this._stamp = 0;    // Last stamp seen

  this._listeners = [];
  this._listeners._ids = {}; // To prevent duplicate listeners

  // Initialize dependencies.
  this._deps = {};
  for (var i=0, n=DEPS.length; i<n; ++i) {
    this._deps[DEPS[i]] = [];
  }

  // Initialize status flags.
  this._flags = 0;

  return this;
};

prototype.rank = function() {
  return this._rank;
};

prototype.qrank = function(/* set */) {
  if (!arguments.length) return this._qrank;
  return (this._qrank = this._rank, this);
};

prototype.last = function(stamp) { 
  if (!arguments.length) return this._stamp;
  return (this._stamp = stamp, this);
};

// -- status flags ---

prototype._setf = function(v, b) {
  if (b) { this._flags |= v; } else { this._flags &= ~v; }
  return this;
};

prototype.router = function(state) {
  if (!arguments.length) return (this._flags & Flags.Router);
  return this._setf(Flags.Router, state);
};

prototype.collector = function(state) {
  if (!arguments.length) return (this._flags & Flags.Collector);
  return this._setf(Flags.Collector, state);
};

prototype.produces = function(state) {
  if (!arguments.length) return (this._flags & Flags.Produces);
  return this._setf(Flags.Produces, state);
};

prototype.mutates = function(state) {
  if (!arguments.length) return (this._flags & Flags.Mutates);
  return this._setf(Flags.Mutates, state);
};

prototype.reflows = function(state) {
  if (!arguments.length) return (this._flags & Flags.Reflows);
  return this._setf(Flags.Reflows, state);
};

prototype.batch = function(state) {
  if (!arguments.length) return (this._flags & Flags.Batch);
  return this._setf(Flags.Batch, state);
};

prototype.dependency = function(type, deps) {
  var d = this._deps[type],
      n = d._names || (d._names = {});  // To prevent dupe deps

  // Get dependencies of the given type
  if (arguments.length === 1) {
    return d;
  }

  if (deps === null) {
    // Clear dependencies of the given type
    d.splice(0, d.length);
    d._names = {};
  } else if (!Array.isArray(deps)) {
    // Separate this case to avoid cost of array creation
    if (n[deps]) return this;
    d.push(deps);
    n[deps] = 1;
  } else {
    for (var i=0, len=deps.length, dep; i<len; ++i) {
      dep = deps[i];
      if (n[dep]) continue;
      d.push(dep);
      n[dep] = 1;
    }
  }

  return this;
};

prototype.listeners = function() {
  return this._listeners;
};

prototype.addListener = function(l) {
  if (!(l instanceof Node)) {
    throw Error('Listener is not a Node');
  }
  if (this._listeners._ids[l._id]) return this;

  this._listeners.push(l);
  this._listeners._ids[l._id] = 1;
  if (this._rank > l._rank) {
    var q = [l],
        g = this._graph, cur;
    while (q.length) {
      cur = q.shift();
      cur._rank = g.rank();
      q.unshift.apply(q, cur.listeners());
    }
  }

  return this;
};

prototype.removeListener = function(l) {
  if (!this._listeners._ids[l._id]) return false;
  
  var idx = this._listeners.indexOf(l),
      b = idx >= 0;

  if (b) {
    this._listeners.splice(idx, 1);
    this._listeners._ids[l._id] = null;
  }
  return b;
};

prototype.disconnect = function() {
  this._listeners = [];
  this._listeners._ids = {};
};

// Evaluate this dataflow node for the current pulse.
// Subclasses should override to perform custom processing.
prototype.evaluate = function(pulse) {
  return pulse;
};

// Should this node be re-evaluated for the current pulse?
// Searches pulse to see if any dependencies have updated.
prototype.reevaluate = function(pulse) {
  var prop, dep, i, n, j, m;

  for (i=0, n=DEPS.length; i<n; ++i) {
    prop = DEPS[i];
    dep = this._deps[prop];
    for (j=0, m=dep.length; j<m; ++j) {
      if (pulse[prop][dep[j]]) return true;
    }
  }

  return false;
};

Node.reset = function() { nodeID = 0; };

module.exports = Node;

},{"./Dependencies":37}],41:[function(require,module,exports){
var ChangeSet = require('./ChangeSet'),
    Node = require('./Node'), // jshint ignore:line
    Base = Node.prototype;

function Signal(graph, name, initialValue) {
  Base.init.call(this, graph);
  this._name  = name;
  this._value = initialValue;
  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.
  this._handlers = [];
  return this;
}

var prototype = (Signal.prototype = Object.create(Base));
prototype.constructor = Signal;

prototype.name = function() {
  return this._name;
};

prototype.value = function(val) {
  if (!arguments.length) return this._value;
  return (this._value = val, this);
};

// Alias to value, for shared API with DataSource
prototype.values = prototype.value;

prototype.verbose = function(v) {
  if (!arguments.length) return this._verbose;
  return (this._verbose = !!v, this);
};

prototype.evaluate = function(input) {
  return input.signals[this._name] ? input : this._graph.doNotPropagate;
};

prototype.fire = function(cs) {
  if (!cs) cs = ChangeSet.create(null, true);
  cs.signals[this._name] = 1;
  this._graph.propagate(cs, this);
};

prototype.on = function(handler) {
  var signal = this,
      node = new Node(this._graph);

  node.evaluate = function(input) {
    handler(signal.name(), signal.value());
    return input;
  };

  this._handlers.push({
    handler: handler,
    node: node
  });

  return this.addListener(node);
};

prototype.off = function(handler) {
  var h = this._handlers, i, x;

  for (i=h.length; --i>=0;) {
    if (!handler || h[i].handler === handler) {
      x = h.splice(i, 1)[0];
      this.removeListener(x.node);
    }
  }

  return this;
};

module.exports = Signal;

},{"./ChangeSet":34,"./Node":40}],42:[function(require,module,exports){
var tupleID = 0;

function ingest(datum) {
  datum = (datum === Object(datum)) ? datum : {data: datum};
  datum._id = ++tupleID;
  if (datum._prev) datum._prev = null;
  return datum;
}

function idMap(a, ids) {
  ids = ids || {};
  for (var i=0, n=a.length; i<n; ++i) {
    ids[a[i]._id] = 1;
  }
  return ids;
}

function copy(t, c) {
  c = c || {};
  for (var k in t) {
    if (k !== '_prev' && k !== '_id') c[k] = t[k];
  }
  return c;
}

module.exports = {
  ingest: ingest,
  idMap: idMap,

  derive: function(d) {
    return ingest(copy(d));
  },

  rederive: function(d, t) {
    return copy(d, t);
  },

  set: function(t, k, v) {
    return t[k] === v ? 0 : (t[k] = v, 1);
  },

  prev: function(t) {
    return t._prev || t;
  },

  prev_init: function(t) {
    if (!t._prev) { t._prev = {_id: t._id}; }
  },

  prev_update: function(t) {
    var p = t._prev, k, v;
    if (p) for (k in t) {
      if (k !== '_prev' && k !== '_id') {
        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;
      }
    }
  },

  reset: function() { tupleID = 0; },

  idFilter: function(data) {
    var ids = {};
    for (var i=arguments.length; --i>0;) {
      idMap(arguments[i], ids);
    }
    return data.filter(function(x) { return !ids[x._id]; });
  }
};

},{}],43:[function(require,module,exports){
module.exports = {
  ChangeSet:    require('./ChangeSet'),
  Collector:    require('./Collector'),
  DataSource:   require('./DataSource'),
  Dependencies: require('./Dependencies'),
  Graph:        require('./Graph'),
  Node:         require('./Node'),
  Signal:       require('./Signal'),
  Tuple:        require('./Tuple'),
  debug:        require('vega-logging').debug
};

},{"./ChangeSet":34,"./Collector":35,"./DataSource":36,"./Dependencies":37,"./Graph":38,"./Node":40,"./Signal":41,"./Tuple":42,"vega-logging":49}],44:[function(require,module,exports){
function toMap(list) {
  var map = {}, i, n;
  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;
  return map;
}

function keys(object) {
  var list = [], k;
  for (k in object) list.push(k);
  return list;
}

module.exports = function(opt) {
  opt = opt || {};
  var constants = opt.constants || require('./constants'),
      functions = (opt.functions || require('./functions'))(codegen),
      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,
      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,
      memberDepth = 0,
      FIELD_VAR = opt.fieldVar || 'datum',
      GLOBAL_VAR = opt.globalVar || 'signals',
      globals = {},
      fields = {};

  function codegen_wrap(ast) {    
    var retval = {
      code: codegen(ast),
      globals: keys(globals),
      fields: keys(fields)
    };
    globals = {};
    fields = {};
    return retval;
  }

  function lookupGlobal(id) {
    return GLOBAL_VAR + '["' + id + '"]';
  }

  function codegen(ast) {
    if (typeof ast === 'string') return ast;
    var generator = CODEGEN_TYPES[ast.type];
    if (generator == null) {
      throw new Error('Unsupported type: ' + ast.type);
    }
    return generator(ast);
  }

  var CODEGEN_TYPES = {
    'Literal': function(n) {
        return n.raw;
      },
    'Identifier': function(n) {
        var id = n.name;
        if (memberDepth > 0) {
          return id;
        }
        if (constants.hasOwnProperty(id)) {
          return constants[id];
        }
        if (idWhiteList) {
          if (idWhiteList.hasOwnProperty(id)) {
            return id;
          } else {
            globals[id] = 1;
            return lookupGlobal(id);
          }
        }
        if (idBlackList && idBlackList.hasOwnProperty(id)) {
          throw new Error('Illegal identifier: ' + id);
        }
        return id;
      },
    'Program': function(n) {
        return n.body.map(codegen).join('\n');
      },
    'MemberExpression': function(n) {
        var d = !n.computed;
        var o = codegen(n.object);
        if (d) memberDepth += 1;
        var p = codegen(n.property);
        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...
        if (d) memberDepth -= 1;
        return o + (d ? '.'+p : '['+p+']');
      },
    'CallExpression': function(n) {
        if (n.callee.type !== 'Identifier') {
          throw new Error('Illegal callee type: ' + n.callee.type);
        }
        var callee = n.callee.name;
        var args = n.arguments;
        var fn = functions.hasOwnProperty(callee) && functions[callee];
        if (!fn) throw new Error('Unrecognized function: ' + callee);
        return fn instanceof Function ?
          fn(args) :
          fn + '(' + args.map(codegen).join(',') + ')';
      },
    'ArrayExpression': function(n) {
        return '[' + n.elements.map(codegen).join(',') + ']';
      },
    'BinaryExpression': function(n) {
        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
      },
    'UnaryExpression': function(n) {
        return '(' + n.operator + codegen(n.argument) + ')';
      },
    'ConditionalExpression': function(n) {
        return '(' + codegen(n.test) +
          '?' + codegen(n.consequent) +
          ':' + codegen(n.alternate) +
          ')';
      },
    'LogicalExpression': function(n) {
        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
      },
    'ObjectExpression': function(n) {
        return '{' + n.properties.map(codegen).join(',') + '}';
      },
    'Property': function(n) {
        memberDepth += 1;
        var k = codegen(n.key);
        memberDepth -= 1;
        return k + ':' + codegen(n.value);
      },
    'ExpressionStatement': function(n) {
        return codegen(n.expression);
      }
  };

  codegen_wrap.functions = functions;
  codegen_wrap.constants = constants;
  return codegen_wrap;
};

},{"./constants":45,"./functions":46}],45:[function(require,module,exports){
module.exports = {
  'NaN':     'NaN',
  'E':       'Math.E',
  'LN2':     'Math.LN2',
  'LN10':    'Math.LN10',
  'LOG2E':   'Math.LOG2E',
  'LOG10E':  'Math.LOG10E',
  'PI':      'Math.PI',
  'SQRT1_2': 'Math.SQRT1_2',
  'SQRT2':   'Math.SQRT2'
};
},{}],46:[function(require,module,exports){
module.exports = function(codegen) {

  function fncall(name, args, cast, type) {
    var obj = codegen(args[0]);
    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }
    return obj + '.' + name + (type < 0 ? '' : type === 0 ?
      '()' :
      '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return function(args) {
      return fncall(name, args, cast, type);
    };
  }

  var DATE = 'new Date',
      STRING = 'String',
      REGEXP = 'RegExp';

  return {
    // MATH functions
    'isNaN':    'isNaN',
    'isFinite': 'isFinite',
    'abs':      'Math.abs',
    'acos':     'Math.acos',
    'asin':     'Math.asin',
    'atan':     'Math.atan',
    'atan2':    'Math.atan2',
    'ceil':     'Math.ceil',
    'cos':      'Math.cos',
    'exp':      'Math.exp',
    'floor':    'Math.floor',
    'log':      'Math.log',
    'max':      'Math.max',
    'min':      'Math.min',
    'pow':      'Math.pow',
    'random':   'Math.random',
    'round':    'Math.round',
    'sin':      'Math.sin',
    'sqrt':     'Math.sqrt',
    'tan':      'Math.tan',

    'clamp': function(args) {
      if (args.length < 3)
        throw new Error('Missing arguments to clamp function.');
      if (args.length > 3)
      throw new Error('Too many arguments to clamp function.');
      var a = args.map(codegen);
      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';
    },

    // DATE functions
    'now':             'Date.now',
    'datetime':        DATE,
    'date':            fn('getDate', DATE, 0),
    'day':             fn('getDay', DATE, 0),
    'year':            fn('getFullYear', DATE, 0),
    'month':           fn('getMonth', DATE, 0),
    'hours':           fn('getHours', DATE, 0),
    'minutes':         fn('getMinutes', DATE, 0),
    'seconds':         fn('getSeconds', DATE, 0),
    'milliseconds':    fn('getMilliseconds', DATE, 0),
    'time':            fn('getTime', DATE, 0),
    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),
    'utcdate':         fn('getUTCDate', DATE, 0),
    'utcday':          fn('getUTCDay', DATE, 0),
    'utcyear':         fn('getUTCFullYear', DATE, 0),
    'utcmonth':        fn('getUTCMonth', DATE, 0),
    'utchours':        fn('getUTCHours', DATE, 0),
    'utcminutes':      fn('getUTCMinutes', DATE, 0),
    'utcseconds':      fn('getUTCSeconds', DATE, 0),
    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),

    // shared sequence functions
    'length':      fn('length', null, -1),
    'indexof':     fn('indexOf', null),
    'lastindexof': fn('lastIndexOf', null),

    // STRING functions
    'parseFloat':  'parseFloat',
    'parseInt':    'parseInt',
    'upper':       fn('toUpperCase', STRING, 0),
    'lower':       fn('toLowerCase', STRING, 0),
    'slice':       fn('slice', STRING),
    'substring':   fn('substring', STRING),

    // REGEXP functions
    'regexp':  REGEXP,
    'test':    fn('test', REGEXP),

    // Control Flow functions
    'if': function(args) {
        if (args.length < 3)
          throw new Error('Missing arguments to if function.');
        if (args.length > 3)
        throw new Error('Too many arguments to if function.');
        var a = args.map(codegen);
        return a[0]+'?'+a[1]+':'+a[2];
      }
  };
};
},{}],47:[function(require,module,exports){
var parser = require('./parser'),
    codegen = require('./codegen');
    
var expr = module.exports = {
  parse: function(input, opt) {
      return parser.parse('('+input+')', opt);
    },
  code: function(opt) {
      return codegen(opt);
    },
  compiler: function(args, opt) {
      args = args.slice();
      var generator = codegen(opt),
          len = args.length,
          compile = function(str) {
            var value = generator(expr.parse(str));
            args[len] = '"use strict"; return (' + value.code + ');';
            value.fn = Function.apply(null, args);
            return value;
          };
      compile.codegen = generator;
      return compile;
    },
  functions: require('./functions'),
  constants: require('./constants')
};

},{"./codegen":44,"./constants":45,"./functions":46,"./parser":48}],48:[function(require,module,exports){
/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* istanbul ignore next */
module.exports = (function() {
  'use strict';

  var Token,
      TokenName,
      Syntax,
      PropertyKind,
      Messages,
      Regex,
      source,
      strict,
      index,
      lineNumber,
      lineStart,
      length,
      lookahead,
      state,
      extra;

  Token = {
      BooleanLiteral: 1,
      EOF: 2,
      Identifier: 3,
      Keyword: 4,
      NullLiteral: 5,
      NumericLiteral: 6,
      Punctuator: 7,
      StringLiteral: 8,
      RegularExpression: 9
  };

  TokenName = {};
  TokenName[Token.BooleanLiteral] = 'Boolean';
  TokenName[Token.EOF] = '<end>';
  TokenName[Token.Identifier] = 'Identifier';
  TokenName[Token.Keyword] = 'Keyword';
  TokenName[Token.NullLiteral] = 'Null';
  TokenName[Token.NumericLiteral] = 'Numeric';
  TokenName[Token.Punctuator] = 'Punctuator';
  TokenName[Token.StringLiteral] = 'String';
  TokenName[Token.RegularExpression] = 'RegularExpression';

  Syntax = {
      AssignmentExpression: 'AssignmentExpression',
      ArrayExpression: 'ArrayExpression',
      BinaryExpression: 'BinaryExpression',
      CallExpression: 'CallExpression',
      ConditionalExpression: 'ConditionalExpression',
      ExpressionStatement: 'ExpressionStatement',
      Identifier: 'Identifier',
      Literal: 'Literal',
      LogicalExpression: 'LogicalExpression',
      MemberExpression: 'MemberExpression',
      ObjectExpression: 'ObjectExpression',
      Program: 'Program',
      Property: 'Property',
      UnaryExpression: 'UnaryExpression'
  };

  PropertyKind = {
      Data: 1,
      Get: 2,
      Set: 4
  };

  // Error messages should be identical to V8.
  Messages = {
      UnexpectedToken:  'Unexpected token %0',
      UnexpectedNumber:  'Unexpected number',
      UnexpectedString:  'Unexpected string',
      UnexpectedIdentifier:  'Unexpected identifier',
      UnexpectedReserved:  'Unexpected reserved word',
      UnexpectedEOS:  'Unexpected end of input',
      NewlineAfterThrow:  'Illegal newline after throw',
      InvalidRegExp: 'Invalid regular expression',
      UnterminatedRegExp:  'Invalid regular expression: missing /',
      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
      InvalidLHSInForIn:  'Invalid left-hand side in for-in',
      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
      NoCatchOrFinally:  'Missing catch or finally after try',
      UnknownLabel: 'Undefined label \'%0\'',
      Redeclaration: '%0 \'%1\' has already been declared',
      IllegalContinue: 'Illegal continue statement',
      IllegalBreak: 'Illegal break statement',
      IllegalReturn: 'Illegal return statement',
      StrictModeWith:  'Strict mode code may not include a with statement',
      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
      StrictVarName:  'Variable name may not be eval or arguments in strict mode',
      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
      StrictDelete:  'Delete of an unqualified identifier in strict mode.',
      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
      StrictReservedWord:  'Use of future reserved word in strict mode'
  };

  // See also tools/generate-unicode-regex.py.
  Regex = {
      NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
      NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
  };

  // Ensure the condition is true, otherwise throw an error.
  // This is only to have a better contract semantic, i.e. another safety net
  // to catch a logic error. The condition shall be fulfilled in normal case.
  // Do NOT use this to enforce a certain condition on any user input.

  function assert(condition, message) {
      if (!condition) {
          throw new Error('ASSERT: ' + message);
      }
  }

  function isDecimalDigit(ch) {
      return (ch >= 0x30 && ch <= 0x39);   // 0..9
  }

  function isHexDigit(ch) {
      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
  }

  function isOctalDigit(ch) {
      return '01234567'.indexOf(ch) >= 0;
  }

  // 7.2 White Space

  function isWhiteSpace(ch) {
      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
  }

  // 7.3 Line Terminators

  function isLineTerminator(ch) {
      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
  }

  // 7.6 Identifier Names and Identifiers

  function isIdentifierStart(ch) {
      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
          (ch === 0x5C) ||                      // \ (backslash)
          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
  }

  function isIdentifierPart(ch) {
      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
          (ch >= 0x30 && ch <= 0x39) ||         // 0..9
          (ch === 0x5C) ||                      // \ (backslash)
          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
  }

  // 7.6.1.2 Future Reserved Words

  function isFutureReservedWord(id) {
      switch (id) {
      case 'class':
      case 'enum':
      case 'export':
      case 'extends':
      case 'import':
      case 'super':
          return true;
      default:
          return false;
      }
  }

  function isStrictModeReservedWord(id) {
      switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'yield':
      case 'let':
          return true;
      default:
          return false;
      }
  }

  // 7.6.1.1 Keywords

  function isKeyword(id) {
      if (strict && isStrictModeReservedWord(id)) {
          return true;
      }

      // 'const' is specialized as Keyword in V8.
      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
      // Some others are from future reserved words.

      switch (id.length) {
      case 2:
          return (id === 'if') || (id === 'in') || (id === 'do');
      case 3:
          return (id === 'var') || (id === 'for') || (id === 'new') ||
              (id === 'try') || (id === 'let');
      case 4:
          return (id === 'this') || (id === 'else') || (id === 'case') ||
              (id === 'void') || (id === 'with') || (id === 'enum');
      case 5:
          return (id === 'while') || (id === 'break') || (id === 'catch') ||
              (id === 'throw') || (id === 'const') || (id === 'yield') ||
              (id === 'class') || (id === 'super');
      case 6:
          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
              (id === 'switch') || (id === 'export') || (id === 'import');
      case 7:
          return (id === 'default') || (id === 'finally') || (id === 'extends');
      case 8:
          return (id === 'function') || (id === 'continue') || (id === 'debugger');
      case 10:
          return (id === 'instanceof');
      default:
          return false;
      }
  }

  function skipComment() {
      var ch, start;

      start = (index === 0);
      while (index < length) {
          ch = source.charCodeAt(index);

          if (isWhiteSpace(ch)) {
              ++index;
          } else if (isLineTerminator(ch)) {
              ++index;
              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                  ++index;
              }
              ++lineNumber;
              lineStart = index;
              start = true;
          } else {
              break;
          }
      }
  }

  function scanHexEscape(prefix) {
      var i, len, ch, code = 0;

      len = (prefix === 'u') ? 4 : 2;
      for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
              ch = source[index++];
              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
          } else {
              return '';
          }
      }
      return String.fromCharCode(code);
  }

  function scanUnicodeCodePointEscape() {
      var ch, code, cu1, cu2;

      ch = source[index];
      code = 0;

      // At least, one hex digit is required.
      if (ch === '}') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      while (index < length) {
          ch = source[index++];
          if (!isHexDigit(ch)) {
              break;
          }
          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
      }

      if (code > 0x10FFFF || ch !== '}') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      // UTF-16 Encoding
      if (code <= 0xFFFF) {
          return String.fromCharCode(code);
      }
      cu1 = ((code - 0x10000) >> 10) + 0xD800;
      cu2 = ((code - 0x10000) & 1023) + 0xDC00;
      return String.fromCharCode(cu1, cu2);
  }

  function getEscapedIdentifier() {
      var ch, id;

      ch = source.charCodeAt(index++);
      id = String.fromCharCode(ch);

      // '\u' (U+005C, U+0075) denotes an escaped character.
      if (ch === 0x5C) {
          if (source.charCodeAt(index) !== 0x75) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          ++index;
          ch = scanHexEscape('u');
          if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          id = ch;
      }

      while (index < length) {
          ch = source.charCodeAt(index);
          if (!isIdentifierPart(ch)) {
              break;
          }
          ++index;
          id += String.fromCharCode(ch);

          // '\u' (U+005C, U+0075) denotes an escaped character.
          if (ch === 0x5C) {
              id = id.substr(0, id.length - 1);
              if (source.charCodeAt(index) !== 0x75) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              ++index;
              ch = scanHexEscape('u');
              if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              id += ch;
          }
      }

      return id;
  }

  function getIdentifier() {
      var start, ch;

      start = index++;
      while (index < length) {
          ch = source.charCodeAt(index);
          if (ch === 0x5C) {
              // Blackslash (U+005C) marks Unicode escape sequence.
              index = start;
              return getEscapedIdentifier();
          }
          if (isIdentifierPart(ch)) {
              ++index;
          } else {
              break;
          }
      }

      return source.slice(start, index);
  }

  function scanIdentifier() {
      var start, id, type;

      start = index;

      // Backslash (U+005C) starts an escaped character.
      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

      // There is no keyword or literal with only one character.
      // Thus, it must be an identifier.
      if (id.length === 1) {
          type = Token.Identifier;
      } else if (isKeyword(id)) {
          type = Token.Keyword;
      } else if (id === 'null') {
          type = Token.NullLiteral;
      } else if (id === 'true' || id === 'false') {
          type = Token.BooleanLiteral;
      } else {
          type = Token.Identifier;
      }

      return {
          type: type,
          value: id,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  // 7.7 Punctuators

  function scanPunctuator() {
      var start = index,
          code = source.charCodeAt(index),
          code2,
          ch1 = source[index],
          ch2,
          ch3,
          ch4;

      switch (code) {

      // Check for most common single-character punctuators.
      case 0x2E:  // . dot
      case 0x28:  // ( open bracket
      case 0x29:  // ) close bracket
      case 0x3B:  // ; semicolon
      case 0x2C:  // , comma
      case 0x7B:  // { open curly brace
      case 0x7D:  // } close curly brace
      case 0x5B:  // [
      case 0x5D:  // ]
      case 0x3A:  // :
      case 0x3F:  // ?
      case 0x7E:  // ~
          ++index;
          if (extra.tokenize) {
              if (code === 0x28) {
                  extra.openParenToken = extra.tokens.length;
              } else if (code === 0x7B) {
                  extra.openCurlyToken = extra.tokens.length;
              }
          }
          return {
              type: Token.Punctuator,
              value: String.fromCharCode(code),
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };

      default:
          code2 = source.charCodeAt(index + 1);

          // '=' (U+003D) marks an assignment or comparison operator.
          if (code2 === 0x3D) {
              switch (code) {
              case 0x2B:  // +
              case 0x2D:  // -
              case 0x2F:  // /
              case 0x3C:  // <
              case 0x3E:  // >
              case 0x5E:  // ^
              case 0x7C:  // |
              case 0x25:  // %
              case 0x26:  // &
              case 0x2A:  // *
                  index += 2;
                  return {
                      type: Token.Punctuator,
                      value: String.fromCharCode(code) + String.fromCharCode(code2),
                      lineNumber: lineNumber,
                      lineStart: lineStart,
                      start: start,
                      end: index
                  };

              case 0x21: // !
              case 0x3D: // =
                  index += 2;

                  // !== and ===
                  if (source.charCodeAt(index) === 0x3D) {
                      ++index;
                  }
                  return {
                      type: Token.Punctuator,
                      value: source.slice(start, index),
                      lineNumber: lineNumber,
                      lineStart: lineStart,
                      start: start,
                      end: index
                  };
              }
          }
      }

      // 4-character punctuator: >>>=

      ch4 = source.substr(index, 4);

      if (ch4 === '>>>=') {
          index += 4;
          return {
              type: Token.Punctuator,
              value: ch4,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // 3-character punctuators: === !== >>> <<= >>=

      ch3 = ch4.substr(0, 3);

      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
          index += 3;
          return {
              type: Token.Punctuator,
              value: ch3,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // Other 2-character punctuators: ++ -- << >> && ||
      ch2 = ch3.substr(0, 2);

      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
          index += 2;
          return {
              type: Token.Punctuator,
              value: ch2,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // 1-character punctuators: < > = ! + - * % & | ^ /

      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
          ++index;
          return {
              type: Token.Punctuator,
              value: ch1,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
  }

  // 7.8.3 Numeric Literals

  function scanHexLiteral(start) {
      var number = '';

      while (index < length) {
          if (!isHexDigit(source[index])) {
              break;
          }
          number += source[index++];
      }

      if (number.length === 0) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseInt('0x' + number, 16),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function scanOctalLiteral(start) {
      var number = '0' + source[index++];
      while (index < length) {
          if (!isOctalDigit(source[index])) {
              break;
          }
          number += source[index++];
      }

      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseInt(number, 8),
          octal: true,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function scanNumericLiteral() {
      var number, start, ch;

      ch = source[index];
      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
          'Numeric literal must start with a decimal digit or a decimal point');

      start = index;
      number = '';
      if (ch !== '.') {
          number = source[index++];
          ch = source[index];

          // Hex number starts with '0x'.
          // Octal number starts with '0'.
          if (number === '0') {
              if (ch === 'x' || ch === 'X') {
                  ++index;
                  return scanHexLiteral(start);
              }
              if (isOctalDigit(ch)) {
                  return scanOctalLiteral(start);
              }

              // decimal number starts with '0' such as '09' is illegal.
              if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
          }

          while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
          }
          ch = source[index];
      }

      if (ch === '.') {
          number += source[index++];
          while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
          }
          ch = source[index];
      }

      if (ch === 'e' || ch === 'E') {
          number += source[index++];

          ch = source[index];
          if (ch === '+' || ch === '-') {
              number += source[index++];
          }
          if (isDecimalDigit(source.charCodeAt(index))) {
              while (isDecimalDigit(source.charCodeAt(index))) {
                  number += source[index++];
              }
          } else {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
      }

      if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  // 7.8.4 String Literals

  function scanStringLiteral() {
      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
      startLineNumber = lineNumber;
      startLineStart = lineStart;

      quote = source[index];
      assert((quote === '\'' || quote === '"'),
          'String literal must starts with a quote');

      start = index;
      ++index;

      while (index < length) {
          ch = source[index++];

          if (ch === quote) {
              quote = '';
              break;
          } else if (ch === '\\') {
              ch = source[index++];
              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                  case 'u':
                  case 'x':
                      if (source[index] === '{') {
                          ++index;
                          str += scanUnicodeCodePointEscape();
                      } else {
                          restore = index;
                          unescaped = scanHexEscape(ch);
                          if (unescaped) {
                              str += unescaped;
                          } else {
                              index = restore;
                              str += ch;
                          }
                      }
                      break;
                  case 'n':
                      str += '\n';
                      break;
                  case 'r':
                      str += '\r';
                      break;
                  case 't':
                      str += '\t';
                      break;
                  case 'b':
                      str += '\b';
                      break;
                  case 'f':
                      str += '\f';
                      break;
                  case 'v':
                      str += '\x0B';
                      break;

                  default:
                      if (isOctalDigit(ch)) {
                          code = '01234567'.indexOf(ch);

                          // \0 is not octal escape sequence
                          if (code !== 0) {
                              octal = true;
                          }

                          if (index < length && isOctalDigit(source[index])) {
                              octal = true;
                              code = code * 8 + '01234567'.indexOf(source[index++]);

                              // 3 digits are only allowed when string starts
                              // with 0, 1, 2, 3
                              if ('0123'.indexOf(ch) >= 0 &&
                                      index < length &&
                                      isOctalDigit(source[index])) {
                                  code = code * 8 + '01234567'.indexOf(source[index++]);
                              }
                          }
                          str += String.fromCharCode(code);
                      } else {
                          str += ch;
                      }
                      break;
                  }
              } else {
                  ++lineNumber;
                  if (ch ===  '\r' && source[index] === '\n') {
                      ++index;
                  }
                  lineStart = index;
              }
          } else if (isLineTerminator(ch.charCodeAt(0))) {
              break;
          } else {
              str += ch;
          }
      }

      if (quote !== '') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.StringLiteral,
          value: str,
          octal: octal,
          startLineNumber: startLineNumber,
          startLineStart: startLineStart,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function testRegExp(pattern, flags) {
      var tmp = pattern,
          value;

      if (flags.indexOf('u') >= 0) {
          // Replace each astral symbol and every Unicode code point
          // escape sequence with a single ASCII symbol to avoid throwing on
          // regular expressions that are only valid in combination with the
          // `/u` flag.
          // Note: replacing with the ASCII symbol `x` might cause false
          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
          // perfectly valid pattern that is equivalent to `[a-b]`, but it
          // would be replaced by `[x-b]` which throws an error.
          tmp = tmp
              .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                  if (parseInt($1, 16) <= 0x10FFFF) {
                      return 'x';
                  }
                  throwError({}, Messages.InvalidRegExp);
              })
              .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
      }

      // First, detect invalid regular expressions.
      try {
          value = new RegExp(tmp);
      } catch (e) {
          throwError({}, Messages.InvalidRegExp);
      }

      // Return a regular expression object for this pattern-flag pair, or
      // `null` in case the current environment doesn't support the flags it
      // uses.
      try {
          return new RegExp(pattern, flags);
      } catch (exception) {
          return null;
      }
  }

  function scanRegExpBody() {
      var ch, str, classMarker, terminated, body;

      ch = source[index];
      assert(ch === '/', 'Regular expression literal must start with a slash');
      str = source[index++];

      classMarker = false;
      terminated = false;
      while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === '\\') {
              ch = source[index++];
              // ECMA-262 7.8.5
              if (isLineTerminator(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnterminatedRegExp);
              }
              str += ch;
          } else if (isLineTerminator(ch.charCodeAt(0))) {
              throwError({}, Messages.UnterminatedRegExp);
          } else if (classMarker) {
              if (ch === ']') {
                  classMarker = false;
              }
          } else {
              if (ch === '/') {
                  terminated = true;
                  break;
              } else if (ch === '[') {
                  classMarker = true;
              }
          }
      }

      if (!terminated) {
          throwError({}, Messages.UnterminatedRegExp);
      }

      // Exclude leading and trailing slash.
      body = str.substr(1, str.length - 2);
      return {
          value: body,
          literal: str
      };
  }

  function scanRegExpFlags() {
      var ch, str, flags, restore;

      str = '';
      flags = '';
      while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch.charCodeAt(0))) {
              break;
          }

          ++index;
          if (ch === '\\' && index < length) {
              ch = source[index];
              if (ch === 'u') {
                  ++index;
                  restore = index;
                  ch = scanHexEscape('u');
                  if (ch) {
                      flags += ch;
                      for (str += '\\u'; restore < index; ++restore) {
                          str += source[restore];
                      }
                  } else {
                      index = restore;
                      flags += 'u';
                      str += '\\u';
                  }
                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
              } else {
                  str += '\\';
                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
          } else {
              flags += ch;
              str += ch;
          }
      }

      return {
          value: flags,
          literal: str
      };
  }

  function scanRegExp() {
      var start, body, flags, value;

      lookahead = null;
      skipComment();
      start = index;

      body = scanRegExpBody();
      flags = scanRegExpFlags();
      value = testRegExp(body.value, flags.value);

      if (extra.tokenize) {
          return {
              type: Token.RegularExpression,
              value: value,
              regex: {
                  pattern: body.value,
                  flags: flags.value
              },
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      return {
          literal: body.literal + flags.literal,
          value: value,
          regex: {
              pattern: body.value,
              flags: flags.value
          },
          start: start,
          end: index
      };
  }

  function collectRegex() {
      var pos, loc, regex, token;

      skipComment();

      pos = index;
      loc = {
          start: {
              line: lineNumber,
              column: index - lineStart
          }
      };

      regex = scanRegExp();

      loc.end = {
          line: lineNumber,
          column: index - lineStart
      };

      if (!extra.tokenize) {
          // Pop the previous token, which is likely '/' or '/='
          if (extra.tokens.length > 0) {
              token = extra.tokens[extra.tokens.length - 1];
              if (token.range[0] === pos && token.type === 'Punctuator') {
                  if (token.value === '/' || token.value === '/=') {
                      extra.tokens.pop();
                  }
              }
          }

          extra.tokens.push({
              type: 'RegularExpression',
              value: regex.literal,
              regex: regex.regex,
              range: [pos, index],
              loc: loc
          });
      }

      return regex;
  }

  function isIdentifierName(token) {
      return token.type === Token.Identifier ||
          token.type === Token.Keyword ||
          token.type === Token.BooleanLiteral ||
          token.type === Token.NullLiteral;
  }

  function advanceSlash() {
      var prevToken,
          checkToken;
      // Using the following algorithm:
      // https://github.com/mozilla/sweet.js/wiki/design
      prevToken = extra.tokens[extra.tokens.length - 1];
      if (!prevToken) {
          // Nothing before that: it cannot be a division.
          return collectRegex();
      }
      if (prevToken.type === 'Punctuator') {
          if (prevToken.value === ']') {
              return scanPunctuator();
          }
          if (prevToken.value === ')') {
              checkToken = extra.tokens[extra.openParenToken - 1];
              if (checkToken &&
                      checkToken.type === 'Keyword' &&
                      (checkToken.value === 'if' ||
                       checkToken.value === 'while' ||
                       checkToken.value === 'for' ||
                       checkToken.value === 'with')) {
                  return collectRegex();
              }
              return scanPunctuator();
          }
          if (prevToken.value === '}') {
              // Dividing a function by anything makes little sense,
              // but we have to check for that.
              if (extra.tokens[extra.openCurlyToken - 3] &&
                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                  // Anonymous function.
                  checkToken = extra.tokens[extra.openCurlyToken - 4];
                  if (!checkToken) {
                      return scanPunctuator();
                  }
              } else if (extra.tokens[extra.openCurlyToken - 4] &&
                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                  // Named function.
                  checkToken = extra.tokens[extra.openCurlyToken - 5];
                  if (!checkToken) {
                      return collectRegex();
                  }
              } else {
                  return scanPunctuator();
              }
              return scanPunctuator();
          }
          return collectRegex();
      }
      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
          return collectRegex();
      }
      return scanPunctuator();
  }

  function advance() {
      var ch;

      skipComment();

      if (index >= length) {
          return {
              type: Token.EOF,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: index,
              end: index
          };
      }

      ch = source.charCodeAt(index);

      if (isIdentifierStart(ch)) {
          return scanIdentifier();
      }

      // Very common: ( and ) and ;
      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
          return scanPunctuator();
      }

      // String literal starts with single quote (U+0027) or double quote (U+0022).
      if (ch === 0x27 || ch === 0x22) {
          return scanStringLiteral();
      }


      // Dot (.) U+002E can also start a floating-point number, hence the need
      // to check the next character.
      if (ch === 0x2E) {
          if (isDecimalDigit(source.charCodeAt(index + 1))) {
              return scanNumericLiteral();
          }
          return scanPunctuator();
      }

      if (isDecimalDigit(ch)) {
          return scanNumericLiteral();
      }

      // Slash (/) U+002F can also start a regex.
      if (extra.tokenize && ch === 0x2F) {
          return advanceSlash();
      }

      return scanPunctuator();
  }

  function collectToken() {
      var loc, token, value, entry;

      skipComment();
      loc = {
          start: {
              line: lineNumber,
              column: index - lineStart
          }
      };

      token = advance();
      loc.end = {
          line: lineNumber,
          column: index - lineStart
      };

      if (token.type !== Token.EOF) {
          value = source.slice(token.start, token.end);
          entry = {
              type: TokenName[token.type],
              value: value,
              range: [token.start, token.end],
              loc: loc
          };
          if (token.regex) {
              entry.regex = {
                  pattern: token.regex.pattern,
                  flags: token.regex.flags
              };
          }
          extra.tokens.push(entry);
      }

      return token;
  }

  function lex() {
      var token;

      token = lookahead;
      index = token.end;
      lineNumber = token.lineNumber;
      lineStart = token.lineStart;

      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

      index = token.end;
      lineNumber = token.lineNumber;
      lineStart = token.lineStart;

      return token;
  }

  function peek() {
      var pos, line, start;

      pos = index;
      line = lineNumber;
      start = lineStart;
      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
      index = pos;
      lineNumber = line;
      lineStart = start;
  }

  function Position() {
      this.line = lineNumber;
      this.column = index - lineStart;
  }

  function SourceLocation() {
      this.start = new Position();
      this.end = null;
  }

  function WrappingSourceLocation(startToken) {
      if (startToken.type === Token.StringLiteral) {
          this.start = {
              line: startToken.startLineNumber,
              column: startToken.start - startToken.startLineStart
          };
      } else {
          this.start = {
              line: startToken.lineNumber,
              column: startToken.start - startToken.lineStart
          };
      }
      this.end = null;
  }

  function Node() {
      // Skip comment.
      index = lookahead.start;
      if (lookahead.type === Token.StringLiteral) {
          lineNumber = lookahead.startLineNumber;
          lineStart = lookahead.startLineStart;
      } else {
          lineNumber = lookahead.lineNumber;
          lineStart = lookahead.lineStart;
      }
      if (extra.range) {
          this.range = [index, 0];
      }
      if (extra.loc) {
          this.loc = new SourceLocation();
      }
  }

  function WrappingNode(startToken) {
      if (extra.range) {
          this.range = [startToken.start, 0];
      }
      if (extra.loc) {
          this.loc = new WrappingSourceLocation(startToken);
      }
  }

  WrappingNode.prototype = Node.prototype = {

      finish: function () {
          if (extra.range) {
              this.range[1] = index;
          }
          if (extra.loc) {
              this.loc.end = new Position();
              if (extra.source) {
                  this.loc.source = extra.source;
              }
          }
      },

      finishArrayExpression: function (elements) {
          this.type = Syntax.ArrayExpression;
          this.elements = elements;
          this.finish();
          return this;
      },

      finishAssignmentExpression: function (operator, left, right) {
          this.type = Syntax.AssignmentExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
      },

      finishBinaryExpression: function (operator, left, right) {
          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
      },

      finishCallExpression: function (callee, args) {
          this.type = Syntax.CallExpression;
          this.callee = callee;
          this.arguments = args;
          this.finish();
          return this;
      },

      finishConditionalExpression: function (test, consequent, alternate) {
          this.type = Syntax.ConditionalExpression;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
          this.finish();
          return this;
      },

      finishExpressionStatement: function (expression) {
          this.type = Syntax.ExpressionStatement;
          this.expression = expression;
          this.finish();
          return this;
      },

      finishIdentifier: function (name) {
          this.type = Syntax.Identifier;
          this.name = name;
          this.finish();
          return this;
      },

      finishLiteral: function (token) {
          this.type = Syntax.Literal;
          this.value = token.value;
          this.raw = source.slice(token.start, token.end);
          if (token.regex) {
              if (this.raw == '//') {
                this.raw = '/(?:)/';
              }
              this.regex = token.regex;
          }
          this.finish();
          return this;
      },

      finishMemberExpression: function (accessor, object, property) {
          this.type = Syntax.MemberExpression;
          this.computed = accessor === '[';
          this.object = object;
          this.property = property;
          this.finish();
          return this;
      },

      finishObjectExpression: function (properties) {
          this.type = Syntax.ObjectExpression;
          this.properties = properties;
          this.finish();
          return this;
      },

      finishProgram: function (body) {
          this.type = Syntax.Program;
          this.body = body;
          this.finish();
          return this;
      },

      finishProperty: function (kind, key, value) {
          this.type = Syntax.Property;
          this.key = key;
          this.value = value;
          this.kind = kind;
          this.finish();
          return this;
      },

      finishUnaryExpression: function (operator, argument) {
          this.type = Syntax.UnaryExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = true;
          this.finish();
          return this;
      }
  };

  // Return true if there is a line terminator before the next token.

  function peekLineTerminator() {
      var pos, line, start, found;

      pos = index;
      line = lineNumber;
      start = lineStart;
      skipComment();
      found = lineNumber !== line;
      index = pos;
      lineNumber = line;
      lineStart = start;

      return found;
  }

  // Throw an exception

  function throwError(token, messageFormat) {
      var error,
          args = Array.prototype.slice.call(arguments, 2),
          msg = messageFormat.replace(
              /%(\d)/g,
              function (whole, index) {
                  assert(index < args.length, 'Message reference must be in range');
                  return args[index];
              }
          );

      if (typeof token.lineNumber === 'number') {
          error = new Error('Line ' + token.lineNumber + ': ' + msg);
          error.index = token.start;
          error.lineNumber = token.lineNumber;
          error.column = token.start - lineStart + 1;
      } else {
          error = new Error('Line ' + lineNumber + ': ' + msg);
          error.index = index;
          error.lineNumber = lineNumber;
          error.column = index - lineStart + 1;
      }

      error.description = msg;
      throw error;
  }

  function throwErrorTolerant() {
      try {
          throwError.apply(null, arguments);
      } catch (e) {
          if (extra.errors) {
              extra.errors.push(e);
          } else {
              throw e;
          }
      }
  }


  // Throw an exception because of the token.

  function throwUnexpected(token) {
      if (token.type === Token.EOF) {
          throwError(token, Messages.UnexpectedEOS);
      }

      if (token.type === Token.NumericLiteral) {
          throwError(token, Messages.UnexpectedNumber);
      }

      if (token.type === Token.StringLiteral) {
          throwError(token, Messages.UnexpectedString);
      }

      if (token.type === Token.Identifier) {
          throwError(token, Messages.UnexpectedIdentifier);
      }

      if (token.type === Token.Keyword) {
          if (isFutureReservedWord(token.value)) {
              throwError(token, Messages.UnexpectedReserved);
          } else if (strict && isStrictModeReservedWord(token.value)) {
              throwErrorTolerant(token, Messages.StrictReservedWord);
              return;
          }
          throwError(token, Messages.UnexpectedToken, token.value);
      }

      // BooleanLiteral, NullLiteral, or Punctuator.
      throwError(token, Messages.UnexpectedToken, token.value);
  }

  // Expect the next token to match the specified punctuator.
  // If not, an exception will be thrown.

  function expect(value) {
      var token = lex();
      if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpected(token);
      }
  }

  /**
   * @name expectTolerant
   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates
   * to <code>expect(value)</code>
   * @param {String} value The value we are expecting the lookahead token to have
   * @since 2.0
   */
  function expectTolerant(value) {
      if (extra.errors) {
          var token = lookahead;
          if (token.type !== Token.Punctuator && token.value !== value) {
              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
          } else {
              lex();
          }
      } else {
          expect(value);
      }
  }

  // Return true if the next token matches the specified punctuator.

  function match(value) {
      return lookahead.type === Token.Punctuator && lookahead.value === value;
  }

  // Return true if the next token matches the specified keyword

  function matchKeyword(keyword) {
      return lookahead.type === Token.Keyword && lookahead.value === keyword;
  }

  function consumeSemicolon() {
      var line;

      // Catch the very common case first: immediately a semicolon (U+003B).
      if (source.charCodeAt(index) === 0x3B || match(';')) {
          lex();
          return;
      }

      line = lineNumber;
      skipComment();
      if (lineNumber !== line) {
          return;
      }

      if (lookahead.type !== Token.EOF && !match('}')) {
          throwUnexpected(lookahead);
      }
  }

  // 11.1.4 Array Initialiser

  function parseArrayInitialiser() {
      var elements = [], node = new Node();

      expect('[');

      while (!match(']')) {
          if (match(',')) {
              lex();
              elements.push(null);
          } else {
              elements.push(parseAssignmentExpression());

              if (!match(']')) {
                  expect(',');
              }
          }
      }

      lex();

      return node.finishArrayExpression(elements);
  }

  // 11.1.5 Object Initialiser

  function parseObjectPropertyKey() {
      var token, node = new Node();

      token = lex();

      // Note: This function is called only from parseObjectProperty(), where
      // EOF and Punctuator tokens are already filtered out.

      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
              throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return node.finishLiteral(token);
      }

      return node.finishIdentifier(token.value);
  }

  function parseObjectProperty() {
      var token, key, id, value, node = new Node();

      token = lookahead;

      if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          expect(':');
          value = parseAssignmentExpression();
          return node.finishProperty('init', id, value);
      }
      if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpected(token);
      } else {
          key = parseObjectPropertyKey();
          expect(':');
          value = parseAssignmentExpression();
          return node.finishProperty('init', key, value);
      }
  }

  function parseObjectInitialiser() {
      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();

      expect('{');

      while (!match('}')) {
          property = parseObjectProperty();

          if (property.key.type === Syntax.Identifier) {
              name = property.key.name;
          } else {
              name = toString(property.key.value);
          }
          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

          key = '$' + name;
          if (Object.prototype.hasOwnProperty.call(map, key)) {
              if (map[key] === PropertyKind.Data) {
                  if (strict && kind === PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                  } else if (kind !== PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.AccessorDataProperty);
                  }
              } else {
                  if (kind === PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.AccessorDataProperty);
                  } else if (map[key] & kind) {
                      throwErrorTolerant({}, Messages.AccessorGetSet);
                  }
              }
              map[key] |= kind;
          } else {
              map[key] = kind;
          }

          properties.push(property);

          if (!match('}')) {
              expectTolerant(',');
          }
      }

      expect('}');

      return node.finishObjectExpression(properties);
  }

  // 11.1.6 The Grouping Operator

  function parseGroupExpression() {
      var expr;

      expect('(');

      ++state.parenthesisCount;

      expr = parseExpression();

      expect(')');

      return expr;
  }


  // 11.1 Primary Expressions

  var legalKeywords = {"if":1, "this":1};

  function parsePrimaryExpression() {
      var type, token, expr, node;

      if (match('(')) {
          return parseGroupExpression();
      }

      if (match('[')) {
          return parseArrayInitialiser();
      }

      if (match('{')) {
          return parseObjectInitialiser();
      }

      type = lookahead.type;
      node = new Node();

      if (type === Token.Identifier || legalKeywords[lookahead.value]) {
          expr = node.finishIdentifier(lex().value);
      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && lookahead.octal) {
              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
          }
          expr = node.finishLiteral(lex());
      } else if (type === Token.Keyword) {
          throw new Error("Disabled.");
      } else if (type === Token.BooleanLiteral) {
          token = lex();
          token.value = (token.value === 'true');
          expr = node.finishLiteral(token);
      } else if (type === Token.NullLiteral) {
          token = lex();
          token.value = null;
          expr = node.finishLiteral(token);
      } else if (match('/') || match('/=')) {
          if (typeof extra.tokens !== 'undefined') {
              expr = node.finishLiteral(collectRegex());
          } else {
              expr = node.finishLiteral(scanRegExp());
          }
          peek();
      } else {
          throwUnexpected(lex());
      }

      return expr;
  }

  // 11.2 Left-Hand-Side Expressions

  function parseArguments() {
      var args = [];

      expect('(');

      if (!match(')')) {
          while (index < length) {
              args.push(parseAssignmentExpression());
              if (match(')')) {
                  break;
              }
              expectTolerant(',');
          }
      }

      expect(')');

      return args;
  }

  function parseNonComputedProperty() {
      var token, node = new Node();

      token = lex();

      if (!isIdentifierName(token)) {
          throwUnexpected(token);
      }

      return node.finishIdentifier(token.value);
  }

  function parseNonComputedMember() {
      expect('.');

      return parseNonComputedProperty();
  }

  function parseComputedMember() {
      var expr;

      expect('[');

      expr = parseExpression();

      expect(']');

      return expr;
  }

  function parseLeftHandSideExpressionAllowCall() {
      var expr, args, property, startToken, previousAllowIn = state.allowIn;

      startToken = lookahead;
      state.allowIn = true;
      expr = parsePrimaryExpression();

      for (;;) {
          if (match('.')) {
              property = parseNonComputedMember();
              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
          } else if (match('(')) {
              args = parseArguments();
              expr = new WrappingNode(startToken).finishCallExpression(expr, args);
          } else if (match('[')) {
              property = parseComputedMember();
              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
          } else {
              break;
          }
      }
      state.allowIn = previousAllowIn;

      return expr;
  }

  // 11.3 Postfix Expressions

  function parsePostfixExpression() {
      var expr = parseLeftHandSideExpressionAllowCall();

      if (lookahead.type === Token.Punctuator) {
          if ((match('++') || match('--')) && !peekLineTerminator()) {
              throw new Error("Disabled.");
          }
      }

      return expr;
  }

  // 11.4 Unary Operators

  function parseUnaryExpression() {
      var token, expr, startToken;

      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
          expr = parsePostfixExpression();
      } else if (match('++') || match('--')) {
          throw new Error("Disabled.");
      } else if (match('+') || match('-') || match('~') || match('!')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
          throw new Error("Disabled.");
      } else {
          expr = parsePostfixExpression();
      }

      return expr;
  }

  function binaryPrecedence(token, allowIn) {
      var prec = 0;

      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return 0;
      }

      switch (token.value) {
      case '||':
          prec = 1;
          break;

      case '&&':
          prec = 2;
          break;

      case '|':
          prec = 3;
          break;

      case '^':
          prec = 4;
          break;

      case '&':
          prec = 5;
          break;

      case '==':
      case '!=':
      case '===':
      case '!==':
          prec = 6;
          break;

      case '<':
      case '>':
      case '<=':
      case '>=':
      case 'instanceof':
          prec = 7;
          break;

      case 'in':
          prec = allowIn ? 7 : 0;
          break;

      case '<<':
      case '>>':
      case '>>>':
          prec = 8;
          break;

      case '+':
      case '-':
          prec = 9;
          break;

      case '*':
      case '/':
      case '%':
          prec = 11;
          break;

      default:
          break;
      }

      return prec;
  }

  // 11.5 Multiplicative Operators
  // 11.6 Additive Operators
  // 11.7 Bitwise Shift Operators
  // 11.8 Relational Operators
  // 11.9 Equality Operators
  // 11.10 Binary Bitwise Operators
  // 11.11 Binary Logical Operators

  function parseBinaryExpression() {
      var marker, markers, expr, token, prec, stack, right, operator, left, i;

      marker = lookahead;
      left = parseUnaryExpression();

      token = lookahead;
      prec = binaryPrecedence(token, state.allowIn);
      if (prec === 0) {
          return left;
      }
      token.prec = prec;
      lex();

      markers = [marker, lookahead];
      right = parseUnaryExpression();

      stack = [left, token, right];

      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

          // Reduce: make a binary expression from the three topmost entries.
          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
              right = stack.pop();
              operator = stack.pop().value;
              left = stack.pop();
              markers.pop();
              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
              stack.push(expr);
          }

          // Shift.
          token = lex();
          token.prec = prec;
          stack.push(token);
          markers.push(lookahead);
          expr = parseUnaryExpression();
          stack.push(expr);
      }

      // Final reduce to clean-up the stack.
      i = stack.length - 1;
      expr = stack[i];
      markers.pop();
      while (i > 1) {
          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
          i -= 2;
      }

      return expr;
  }

  // 11.12 Conditional Operator

  function parseConditionalExpression() {
      var expr, previousAllowIn, consequent, alternate, startToken;

      startToken = lookahead;

      expr = parseBinaryExpression();

      if (match('?')) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(':');
          alternate = parseAssignmentExpression();

          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
      }

      return expr;
  }

  // 11.13 Assignment Operators

  function parseAssignmentExpression() {
      var oldParenthesisCount, token, expr, startToken;

      oldParenthesisCount = state.parenthesisCount;

      startToken = lookahead;
      token = lookahead;

      expr = parseConditionalExpression();

      return expr;
  }

  // 11.14 Comma Operator

  function parseExpression() {
      var expr = parseAssignmentExpression();

      if (match(',')) {
          throw new Error("Disabled."); // no sequence expressions
      }

      return expr;
  }

  // 12.4 Expression Statement

  function parseExpressionStatement(node) {
      var expr = parseExpression();
      consumeSemicolon();
      return node.finishExpressionStatement(expr);
  }

  // 12 Statements

  function parseStatement() {
      var type = lookahead.type,
          expr,
          node;

      if (type === Token.EOF) {
          throwUnexpected(lookahead);
      }

      if (type === Token.Punctuator && lookahead.value === '{') {
          throw new Error("Disabled."); // block statement
      }

      node = new Node();

      if (type === Token.Punctuator) {
          switch (lookahead.value) {
          case ';':
              throw new Error("Disabled."); // empty statement
          case '(':
              return parseExpressionStatement(node);
          default:
              break;
          }
      } else if (type === Token.Keyword) {
          throw new Error("Disabled."); // keyword
      }

      expr = parseExpression();
      consumeSemicolon();
      return node.finishExpressionStatement(expr);
  }

  // 14 Program

  function parseSourceElement() {
      if (lookahead.type === Token.Keyword) {
          switch (lookahead.value) {
          case 'const':
          case 'let':
              throw new Error("Disabled.");
          case 'function':
              throw new Error("Disabled.");
          default:
              return parseStatement();
          }
      }

      if (lookahead.type !== Token.EOF) {
          return parseStatement();
      }
  }

  function parseSourceElements() {
      var sourceElement, sourceElements = [], token, directive, firstRestricted;

      while (index < length) {
          token = lookahead;
          if (token.type !== Token.StringLiteral) {
              break;
          }

          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
              // this is not directive
              break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
              strict = true;
              if (firstRestricted) {
                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
              }
          } else {
              if (!firstRestricted && token.octal) {
                  firstRestricted = token;
              }
          }
      }

      while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
              break;
          }
          sourceElements.push(sourceElement);
      }
      return sourceElements;
  }

  function parseProgram() {
      var body, node;

      skipComment();
      peek();
      node = new Node();
      strict = true; // assume strict

      body = parseSourceElements();
      return node.finishProgram(body);
  }

  function filterTokenLocation() {
      var i, entry, token, tokens = [];

      for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
              type: entry.type,
              value: entry.value
          };
          if (entry.regex) {
              token.regex = {
                  pattern: entry.regex.pattern,
                  flags: entry.regex.flags
              };
          }
          if (extra.range) {
              token.range = entry.range;
          }
          if (extra.loc) {
              token.loc = entry.loc;
          }
          tokens.push(token);
      }

      extra.tokens = tokens;
  }

  function tokenize(code, options) {
      var toString,
          tokens;

      toString = String;
      if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
      }

      source = code;
      index = 0;
      lineNumber = (source.length > 0) ? 1 : 0;
      lineStart = 0;
      length = source.length;
      lookahead = null;
      state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
      };

      extra = {};

      // Options matching.
      options = options || {};

      // Of course we collect tokens here.
      options.tokens = true;
      extra.tokens = [];
      extra.tokenize = true;
      // The following two fields are necessary to compute the Regex tokens.
      extra.openParenToken = -1;
      extra.openCurlyToken = -1;

      extra.range = (typeof options.range === 'boolean') && options.range;
      extra.loc = (typeof options.loc === 'boolean') && options.loc;

      if (typeof options.tolerant === 'boolean' && options.tolerant) {
          extra.errors = [];
      }

      try {
          peek();
          if (lookahead.type === Token.EOF) {
              return extra.tokens;
          }

          lex();
          while (lookahead.type !== Token.EOF) {
              try {
                  lex();
              } catch (lexError) {
                  if (extra.errors) {
                      extra.errors.push(lexError);
                      // We have to break on the first error
                      // to avoid infinite loops.
                      break;
                  } else {
                      throw lexError;
                  }
              }
          }

          filterTokenLocation();
          tokens = extra.tokens;
          if (typeof extra.errors !== 'undefined') {
              tokens.errors = extra.errors;
          }
      } catch (e) {
          throw e;
      } finally {
          extra = {};
      }
      return tokens;
  }

  function parse(code, options) {
      var program, toString;

      toString = String;
      if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
      }

      source = code;
      index = 0;
      lineNumber = (source.length > 0) ? 1 : 0;
      lineStart = 0;
      length = source.length;
      lookahead = null;
      state = {
          allowIn: true,
          labelSet: {},
          parenthesisCount: 0,
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
      };

      extra = {};
      if (typeof options !== 'undefined') {
          extra.range = (typeof options.range === 'boolean') && options.range;
          extra.loc = (typeof options.loc === 'boolean') && options.loc;

          if (extra.loc && options.source !== null && options.source !== undefined) {
              extra.source = toString(options.source);
          }

          if (typeof options.tokens === 'boolean' && options.tokens) {
              extra.tokens = [];
          }
          if (typeof options.tolerant === 'boolean' && options.tolerant) {
              extra.errors = [];
          }
      }

      try {
          program = parseProgram();
          if (typeof extra.tokens !== 'undefined') {
              filterTokenLocation();
              program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== 'undefined') {
              program.errors = extra.errors;
          }
      } catch (e) {
          throw e;
      } finally {
          extra = {};
      }

      return program;
  }

  return {
    tokenize: tokenize,
    parse: parse
  };

})();
},{}],49:[function(require,module,exports){
var ts = Date.now();

function write(msg) {
  msg = '[Vega Log] ' + msg;
  console.log(msg);
}

function error(msg) {
  msg = '[Vega Err] ' + msg;
  console.error(msg);
}

function debug(input, args) {
  if (!debug.enable) return;
  var log = Function.prototype.bind.call(console.log, console);
  var state = {
    prevTime:  Date.now() - ts,
    stamp: input.stamp
  };

  if (input.add) {
    state.add = input.add.length;
    state.mod = input.mod.length;
    state.rem = input.rem.length;
    state.reflow = !!input.reflow;
  }

  log.apply(console, (args.push(JSON.stringify(state)), args));
  ts = Date.now();
}

module.exports = {
  log:   write,
  error: error,
  debug: (debug.enable = false, debug)
};

},{}],50:[function(require,module,exports){
module.exports = {
  path:       require('./path'),
  render:     require('./render'),
  Item:       require('./util/Item'),
  bound:      require('./util/bound'),
  Bounds:     require('./util/Bounds'),
  canvas:     require('./util/canvas'),
  Gradient:   require('./util/Gradient'),
  toJSON:     require('./util/scene').toJSON,
  fromJSON:   require('./util/scene').fromJSON
};
},{"./path":52,"./render":72,"./util/Bounds":78,"./util/Gradient":80,"./util/Item":82,"./util/bound":83,"./util/canvas":84,"./util/scene":86}],51:[function(require,module,exports){
var segmentCache = {},
    bezierCache = {},
    join = [].join;

// Copied from Inkscape svgtopdf, thanks!
function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var key = join.call(arguments);
  if (segmentCache[key]) {
    return segmentCache[key];
  }

  var th = rotateX * (Math.PI/180);
  var sin_th = Math.sin(th);
  var cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  var a00 = cos_th / rx;
  var a01 = sin_th / rx;
  var a10 = (-sin_th) / ry;
  var a11 = (cos_th) / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;

  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
  var sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  var sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);

  var th0 = Math.atan2(y0-yc, x0-xc);
  var th1 = Math.atan2(y1-yc, x1-xc);

  var th_arc = th1-th0;
  if (th_arc < 0 && sweep === 1){
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }

  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
  var result = [];
  for (var i=0; i<segs; ++i) {
    var th2 = th0 + i * th_arc / segs;
    var th3 = th0 + (i+1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return (segmentCache[key] = result);
}

function bezier(params) {
  var key = join.call(params);
  if (bezierCache[key]) {
    return bezierCache[key];
  }
  
  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];

  var a00 = cos_th * rx;
  var a01 = -sin_th * ry;
  var a10 = sin_th * rx;
  var a11 = cos_th * ry;

  var cos_th0 = Math.cos(th0);
  var sin_th0 = Math.sin(th0);
  var cos_th1 = Math.cos(th1);
  var sin_th1 = Math.sin(th1);

  var th_half = 0.5 * (th1 - th0);
  var sin_th_h2 = Math.sin(th_half * 0.5);
  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  var x1 = cx + cos_th0 - t * sin_th0;
  var y1 = cy + sin_th0 + t * cos_th0;
  var x3 = cx + cos_th1;
  var y3 = cy + sin_th1;
  var x2 = x3 + t * sin_th1;
  var y2 = y3 - t * cos_th1;

  return (bezierCache[key] = [
    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,
    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,
    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3
  ]);
}

module.exports = {
  segments: segments,
  bezier: bezier,
  cache: {
    segments: segmentCache,
    bezier: bezierCache
  }
};

},{}],52:[function(require,module,exports){
module.exports = {
  parse:  require('./parse'),
  render: require('./render')
};

},{"./parse":53,"./render":54}],53:[function(require,module,exports){
// Path parsing and rendering code adapted from fabric.js -- Thanks!
var cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },
    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\d)([-+])/g, /\s|,|###/];

module.exports = function(pathstr) {
  var result = [],
      path,
      curr,
      chunks,
      parsed, param,
      cmd, len, i, j, n, m;

  // First, break path into command sequence
  path = pathstr
    .slice()
    .replace(regexp[0], '###$1')
    .split(regexp[1])
    .slice(1);

  // Next, parse each command in turn
  for (i=0, n=path.length; i<n; ++i) {
    curr = path[i];
    chunks = curr
      .slice(1)
      .trim()
      .replace(regexp[2],'$1###$2')
      .split(regexp[3]);
    cmd = curr.charAt(0);

    parsed = [cmd];
    for (j=0, m=chunks.length; j<m; ++j) {
      if ((param = +chunks[j]) === param) { // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length-1 > len) {
      for (j=1, m=parsed.length; j<m; j+=len) {
        result.push([cmd].concat(parsed.slice(j, j+len)));
      }
    }
    else {
      result.push(parsed);
    }
  }

  return result;
};

},{}],54:[function(require,module,exports){
var arc = require('./arc');

module.exports = function(g, path, l, t) {
  var current, // current instruction
      previous = null,
      x = 0, // current x
      y = 0, // current y
      controlX = 0, // current control point x
      controlY = 0, // current control point y
      tempX,
      tempY,
      tempControlX,
      tempControlY;

  if (l == null) l = 0;
  if (t == null) t = 0;

  g.beginPath();

  for (var i=0, len=path.length; i<len; ++i) {
    current = path[i];

    switch (current[0]) { // first letter

      case 'l': // lineto, relative
        x += current[1];
        y += current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'L': // lineto, absolute
        x = current[1];
        y = current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'h': // horizontal lineto, relative
        x += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'H': // horizontal lineto, absolute
        x = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'v': // vertical lineto, relative
        y += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'V': // verical lineto, absolute
        y = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'm': // moveTo, relative
        x += current[1];
        y += current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'M': // moveTo, absolute
        x = current[1];
        y = current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'c': // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        g.bezierCurveTo(
          x + current[1] + l, // x1
          y + current[2] + t, // y1
          controlX + l, // x2
          controlY + t, // y2
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'C': // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        g.bezierCurveTo(
          current[1] + l,
          current[2] + t,
          controlX + l,
          controlY + t,
          x + l,
          y + t
        );
        break;

      case 's': // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          x + current[1] + l,
          y + current[2] + t,
          tempX + l,
          tempY + t
        );

        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = x + current[1];
        controlY = y + current[2];

        x = tempX;
        y = tempY;
        break;

      case 'S': // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        // calculate reflection of previous control points
        controlX = 2*x - controlX;
        controlY = 2*y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = current[1];
        controlY = current[2];

        break;

      case 'q': // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];

        controlX = x + current[1];
        controlY = y + current[2];

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'Q': // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];

        g.quadraticCurveTo(
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't': // shorthand quadraticCurveTo, relative

        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        }
        else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        }
        else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2];

        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + x + l,
          current[7] + y + t
        ]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + l,
          current[7] + t
        ]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        g.closePath();
        break;
    }
    previous = current;
  }
};

function drawArc(g, x, y, coords) {
  var seg = arc.segments(
    coords[5], // end x
    coords[6], // end y
    coords[0], // radius x
    coords[1], // radius y
    coords[3], // large flag
    coords[4], // sweep flag
    coords[2], // rotation
    x, y
  );
  for (var i=0; i<seg.length; ++i) {
    var bez = arc.bezier(seg[i]);
    g.bezierCurveTo.apply(g, bez);
  }
}

},{"./arc":51}],55:[function(require,module,exports){
function Handler() {
  this._active = null;
  this._handlers = {};
}

var prototype = Handler.prototype;

prototype.initialize = function(el, pad, obj) {
  this._el = el;
  this._obj = obj || null;
  return this.padding(pad);
};

prototype.element = function() {
  return this._el;
};

prototype.padding = function(pad) {
  this._padding = pad || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.scene = function(scene) {
  if (!arguments.length) return this._scene;
  this._scene = scene;
  return this;
};

// add an event handler
// subclasses should override
prototype.on = function(/*type, handler*/) {};

// remove an event handler
// subclasses should override
prototype.off = function(/*type, handler*/) {};

// return an array with all registered event handlers
prototype.handlers = function() {
  var h = this._handlers, a = [], k;
  for (k in h) { a.push.apply(a, h[k]); }
  return a;
};

prototype.eventName = function(name) {
  var i = name.indexOf('.');
  return i < 0 ? name : name.slice(0,i);
};

module.exports = Handler;
},{}],56:[function(require,module,exports){
function Renderer() {
  this._el = null;
  this._bgcolor = null;
}

var prototype = Renderer.prototype;

prototype.initialize = function(el, width, height, padding) {
  this._el = el;
  return this.resize(width, height, padding);
};

// Returns the parent container element for a visualization
prototype.element = function() {
  return this._el;
};

// Returns the scene element (e.g., canvas or SVG) of the visualization
// Subclasses must override if the first child is not the scene element
prototype.scene = function() {
  return this._el && this._el.firstChild;
};

prototype.background = function(bgcolor) {
  if (arguments.length === 0) return this._bgcolor;
  this._bgcolor = bgcolor;
  return this;
};

prototype.resize = function(width, height, padding) {
  this._width = width;
  this._height = height;
  this._padding = padding || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.render = function(/*scene, items*/) {
  return this;
};

module.exports = Renderer;
},{}],57:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler'),
    marks = require('./marks');

function CanvasHandler() {
  Handler.call(this);
  this._down = null;
  this._touch = null;
  this._first = true;
}

var base = Handler.prototype;
var prototype = (CanvasHandler.prototype = Object.create(base));
prototype.constructor = CanvasHandler;

prototype.initialize = function(el, pad, obj) {
  // add event listeners
  var canvas = this._canvas = DOM.find(el, 'canvas');
  if (canvas) {
    var that = this;
    this.events.forEach(function(type) {
      canvas.addEventListener(type, function(evt) {
        if (prototype[type]) {
          prototype[type].call(that, evt);
        } else {
          that.fire(type, evt);
        }
      });
    });
  }

  return base.initialize.call(this, el, pad, obj);
};

prototype.canvas = function() {
  return this._canvas;
};

// retrieve the current canvas context
prototype.context = function() {
  return this._canvas.getContext('2d');
};

// supported events
prototype.events = [
  'keydown',
  'keypress',
  'keyup',
  'mousedown',
  'mouseup',
  'mousemove',
  'mouseout',
  'mouseover',
  'click',
  'dblclick',
  'wheel',
  'mousewheel',
  'touchstart',
  'touchmove',
  'touchend'
];

// to keep firefox happy
prototype.DOMMouseScroll = function(evt) {
  this.fire('mousewheel', evt);
};

prototype.mousemove = function(evt) {
  var a = this._active,
      p = this.pickEvent(evt);

  if (p === a) {
    // active item and picked item are the same
    this.fire('mousemove', evt); // fire move
  } else {
    // active item and picked item are different
    this.fire('mouseout', evt);  // fire out for prior active item
    this._active = p;            // set new active item
    this.fire('mouseover', evt); // fire over for new active item
    this.fire('mousemove', evt); // fire move for new active item
  }
};

prototype.mouseout = function(evt) {
  this.fire('mouseout', evt);
  this._active = null;
};

prototype.mousedown = function(evt) {
  this._down = this._active;
  this.fire('mousedown', evt);
};

prototype.click = function(evt) {
  if (this._down === this._active) {
    this.fire('click', evt);
    this._down = null;
  }
};

prototype.touchstart = function(evt) {
  this._touch = this.pickEvent(evt.changedTouches[0]);

  if (this._first) {
    this._active = this._touch;
    this._first = false;
  }

  this.fire('touchstart', evt, true);
};

prototype.touchmove = function(evt) {
  this.fire('touchmove', evt, true);
};

prototype.touchend = function(evt) {
  this.fire('touchend', evt, true);
  this._touch = null;
};

// fire an event
prototype.fire = function(type, evt, touch) {
  var a = touch ? this._touch : this._active,
      h = this._handlers[type], i, len;
  if (h) {
    evt.vegaType = type;
    for (i=0, len=h.length; i<len; ++i) {
      h[i].handler.call(this._obj, evt, a);
    }
  }
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers;
  (h[name] || (h[name] = [])).push({
    type: type,
    handler: handler
  });
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type !== type) continue;
    if (!handler || h[i].handler === handler) h.splice(i, 1);
  }
  return this;
};

prototype.pickEvent = function(evt) {
  var rect = this._canvas.getBoundingClientRect(),
      pad = this._padding, x, y;
  return this.pick(this._scene,
    x = (evt.clientX - rect.left),
    y = (evt.clientY - rect.top),
    x - pad.left, y - pad.top);
};

// find the scenegraph item at the current mouse position
// x, y -- the absolute x, y mouse coordinates on the canvas element
// gx, gy -- the relative coordinates within the current group
prototype.pick = function(scene, x, y, gx, gy) {
  var g = this.context(),
      mark = marks[scene.marktype];
  return mark.pick.call(this, g, scene, x, y, gx, gy);
};

module.exports = CanvasHandler;

},{"../../util/dom":85,"../Handler":55,"./marks":64}],58:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Bounds = require('../../util/Bounds'),
    ImageLoader = require('../../util/ImageLoader'),
    Canvas = require('../../util/canvas'),
    Renderer = require('../Renderer'),
    marks = require('./marks');

function CanvasRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
}

CanvasRenderer.RETINA = true;

var base = Renderer.prototype;
var prototype = (CanvasRenderer.prototype = Object.create(base));
prototype.constructor = CanvasRenderer;

prototype.initialize = function(el, width, height, padding) {
  this._canvas = Canvas.instance(width, height);
  if (el) {
    DOM.clear(el, 0).appendChild(this._canvas);
    this._canvas.setAttribute('class', 'marks');
  }
  return base.initialize.call(this, el, width, height, padding);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  Canvas.resize(this._canvas, this._width, this._height,
    this._padding, CanvasRenderer.RETINA);
  return this;
};

prototype.canvas = function() {
  return this._canvas;
};

prototype.context = function() {
  return this._canvas ? this._canvas.getContext('2d') : null;
};

prototype.pendingImages = function() {
  return this._loader.pending();
};

function clipToBounds(g, items) {
  if (!items) return null;

  var b = new Bounds(), i, n, item, mark, group;
  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    group = mark.group;
    item = marks[mark.marktype].nested ? mark : item;
    b.union(translate(item.bounds, group));
    if (item['bounds:prev']) {
      b.union(translate(item['bounds:prev'], group));
    }
  }
  b.round();

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();

  return b;
}

function translate(bounds, group) {
  if (group == null) return bounds;
  var b = bounds.clone();
  for (; group != null; group = group.mark.group) {
    b.translate(group.x || 0, group.y || 0);
  }
  return b;
}

prototype.render = function(scene, items) {
  var g = this.context(),
      p = this._padding,
      w = this._width + p.left + p.right,
      h = this._height + p.top + p.bottom,
      b;

  // setup
  this._scene = scene; // cache scene for async redraw
  g.save();
  b = clipToBounds(g, items);
  this.clear(-p.left, -p.top, w, h);

  // render
  this.draw(g, scene, b);
  
  // takedown
  g.restore();
  this._scene = null; // clear scene cache

  return this;
};

prototype.draw = function(ctx, scene, bounds) {
  var mark = marks[scene.marktype];
  mark.draw.call(this, ctx, scene, bounds);
};

prototype.clear = function(x, y, w, h) {
  var g = this.context();
  g.clearRect(x, y, w, h);
  if (this._bgcolor != null) {
    g.fillStyle = this._bgcolor;
    g.fillRect(x, y, w, h); 
  }
};

prototype.loadImage = function(uri) {
  var renderer = this,
      scene = this._scene;
  return this._loader.loadImage(uri, function() {
    renderer.renderAsync(scene);
  });
};

prototype.renderAsync = function(scene) {
  // TODO make safe for multiple scene rendering?
  var renderer = this;
  if (renderer._async_id) {
    clearTimeout(renderer._async_id);
  }
  renderer._async_id = setTimeout(function() {
    renderer.render(scene);
    delete renderer._async_id;
  }, 10);
};

module.exports = CanvasRenderer;

},{"../../util/Bounds":78,"../../util/ImageLoader":81,"../../util/canvas":84,"../../util/dom":85,"../Renderer":56,"./marks":64}],59:[function(require,module,exports){
module.exports = {
  Handler:  require('./CanvasHandler'),
  Renderer: require('./CanvasRenderer')
};
},{"./CanvasHandler":57,"./CanvasRenderer":58}],60:[function(require,module,exports){
var util = require('./util');
var halfpi = Math.PI / 2;

function path(g, o) {
  var x = o.x || 0,
      y = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi;
  g.beginPath();
  if (ir === 0) g.moveTo(x, y);
  else g.arc(x, y, ir, sa, ea, 0);
  g.arc(x, y, or, ea, sa, 1);
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":71}],61:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    areaPath = require('../../../util/svg').path.area;

function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(areaPath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":53,"../../../path/render":54,"../../../util/svg":87,"./util":71}],62:[function(require,module,exports){
var util = require('./util'),
    EMPTY = [];

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var groups = scene.items,
      renderer = this,
      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;

  for (i=0, n=groups.length; i<n; ++i) {
    group = groups[i];
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    gx = group.x || 0;
    gy = group.y || 0;
    w = group.width || 0;
    h = group.height || 0;

    // draw group background
    if (group.stroke || group.fill) {
      opac = group.opacity == null ? 1 : group.opacity;
      if (opac > 0) {
        if (group.fill && util.fill(g, group, opac)) {
          g.fillRect(gx, gy, w, h);
        }
        if (group.stroke && util.stroke(g, group, opac)) {
          g.strokeRect(gx, gy, w, h);
        }
      }
    }

    // setup graphics context
    g.save();
    g.translate(gx, gy);
    if (group.clip) {
      g.beginPath();
      g.rect(0, 0, w, h);
      g.clip();
    }
    if (bounds) bounds.translate(-gx, -gy);

    // draw group contents
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer === 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=items.length; j<m; ++j) {
      renderer.draw(g, items[j], bounds);
    }
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer !== 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=legends.length; j<m; ++j) {
      renderer.draw(g, legends[j], bounds);
    }

    // restore graphics context
    if (bounds) bounds.translate(gx, gy);
    g.restore();
  }    
}

function pick(g, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy)) {
    return null;
  }

  var groups = scene.items || EMPTY, subscene,
      group, axes, items, legends, hits, dx, dy, i, j, b;

  for (i=groups.length; --i>=0;) {
    group = groups[i];

    // first hit test against bounding box
    // if a group is clipped, that should be handled by the bounds check.
    b = group.bounds;
    if (b && !b.contains(gx, gy)) continue;

    // passed bounds check, so test sub-groups
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    dx = (group.x || 0);
    dy = (group.y || 0);

    g.save();
    g.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    for (j=legends.length; --j>=0;) {
      subscene = legends[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interactive !== false && subscene.layer !== 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=items.length; --j>=0;) {
      subscene = items[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interative !== false && subscene.layer === 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    g.restore();

    if (scene.interactive !== false && (group.fill || group.stroke) &&
        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {
      return group;
    }
  }

  return null;
}

module.exports = {
  draw: draw,
  pick: pick
};

},{"./util":71}],63:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var renderer = this,
      items = scene.items, o;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    if (!(o.image && o.image.url === o.url)) {
      o.image = renderer.loadImage(o.url);
      o.image.url = o.url;
    }

    var x = o.x || 0,
        y = o.y || 0,
        w = o.width || (o.image && o.image.width) || 0,
        h = o.height || (o.image && o.image.height) || 0,
        opac;
    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);
    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);

    if (o.image.loaded) {
      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;
      g.drawImage(o.image, x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":71}],64:[function(require,module,exports){
module.exports = {
  arc:    require('./arc'),
  area:   require('./area'),
  group:  require('./group'),
  image:  require('./image'),
  line:   require('./line'),
  path:   require('./path'),
  rect:   require('./rect'),
  rule:   require('./rule'),
  symbol: require('./symbol'),
  text:   require('./text')
};

},{"./arc":60,"./area":61,"./group":62,"./image":63,"./line":65,"./path":66,"./rect":67,"./rule":68,"./symbol":69,"./text":70}],65:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    linePath = require('../../../util/svg').path.line;
    
function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(linePath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path, false);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":53,"../../../path/render":54,"../../../util/svg":87,"./util":71}],66:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render');

function path(g, o) {
  if (o.path == null) return true;
  var p = o.pathCache || (o.pathCache = parse(o.path));
  render(g, p, o.x, o.y);
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};

},{"../../../path/parse":53,"../../../path/render":54,"./util":71}],67:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, w, h;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    x = o.x || 0;
    y = o.y || 0;
    w = o.width || 0;
    h = o.height || 0;

    if (o.fill && util.fill(g, o, opac)) {
      g.fillRect(x, y, w, h);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeRect(x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":71}],68:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x1, y1, x2, y2;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;
      
    x1 = o.x || 0;
    y1 = o.y || 0;
    x2 = o.x2 != null ? o.x2 : x1;
    y2 = o.y2 != null ? o.y2 : y1;

    if (o.stroke && util.stroke(g, o, opac)) {
      g.beginPath();
      g.moveTo(x1, y1);
      g.lineTo(x2, y2);
      g.stroke();
    }
  }
}

function stroke(g, o) {
  var x1 = o.x || 0,
      y1 = o.y || 0,
      x2 = o.x2 != null ? o.x2 : x1,
      y2 = o.y2 != null ? o.y2 : y1,
      lw = o.strokeWidth,
      lc = o.strokeCap;

  g.lineWidth = lw != null ? lw : 1;
  g.lineCap   = lc != null ? lc : 'butt';
  g.beginPath();
  g.moveTo(x1, y1);
  g.lineTo(x2, y2);
}

function hit(g, o, x, y) {
  if (!g.isPointInStroke) return false;
  stroke(g, o);
  return g.isPointInStroke(x, y);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"./util":71}],69:[function(require,module,exports){
var util = require('./util');

var sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180);

function path(g, o) {
  var size = o.size != null ? o.size : 100,
      x = o.x, y = o.y, r, t, rx, ry;

  g.beginPath();

  if (o.shape == null || o.shape === 'circle') {
    r = Math.sqrt(size / Math.PI);
    g.arc(x, y, r, 0, 2*Math.PI, 0);
    g.closePath();
    return;
  }

  switch (o.shape) {
    case 'cross':
      r = Math.sqrt(size / 5) / 2;
      t = 3*r;
      g.moveTo(x-t, y-r);
      g.lineTo(x-r, y-r);
      g.lineTo(x-r, y-t);
      g.lineTo(x+r, y-t);
      g.lineTo(x+r, y-r);
      g.lineTo(x+t, y-r);
      g.lineTo(x+t, y+r);
      g.lineTo(x+r, y+r);
      g.lineTo(x+r, y+t);
      g.lineTo(x-r, y+t);
      g.lineTo(x-r, y+r);
      g.lineTo(x-t, y+r);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y);
      g.lineTo(x, y+ry);
      g.lineTo(x-rx, y);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      g.rect(x-r, y-r, t, t);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y+ry);
      g.lineTo(x+rx, y-ry);
      g.lineTo(x-rx, y-ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y+ry);
      g.lineTo(x-rx, y+ry);
  }
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":71}],70:[function(require,module,exports){
var Bounds = require('../../../util/Bounds'),
    textBounds = require('../../../util/bound').text,
    text = require('../../../util/text'),
    util = require('./util'),
    tempBounds = new Bounds();

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, r, t, str;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    str = text.value(o.text);
    if (!str) continue;
    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    g.font = text.font(o);
    g.textAlign = o.align || 'left';

    x = (o.x || 0);
    y = (o.y || 0);
    if ((r = o.radius)) {
      t = (o.theta || 0) - Math.PI/2;
      x += r * Math.cos(t);
      y += r * Math.sin(t);
    }

    if (o.angle) {
      g.save();
      g.translate(x, y);
      g.rotate(o.angle * Math.PI/180);
      x = y = 0; // reset x, y
    }
    x += (o.dx || 0);
    y += (o.dy || 0) + text.offset(o);

    if (o.fill && util.fill(g, o, opac)) {
      g.fillText(str, x, y);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeText(str, x, y);
    }
    if (o.angle) g.restore();
  }
}

function hit(g, o, x, y, gx, gy) {
  if (o.fontSize <= 0) return false;
  if (!o.angle) return true; // bounds sufficient if no rotation

  // project point into space of unrotated bounds
  var b = textBounds(o, tempBounds, true),
      a = -o.angle * Math.PI / 180,
      cos = Math.cos(a),
      sin = Math.sin(a),
      ox = o.x,
      oy = o.y,
      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),
      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);

  return b.contains(px, py);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"../../../util/Bounds":78,"../../../util/bound":83,"../../../util/text":88,"./util":71}],71:[function(require,module,exports){
function drawPathOne(path, g, o, items) {
  if (path(g, items)) return;

  var opac = o.opacity == null ? 1 : o.opacity;
  if (opac===0) return;

  if (o.fill && fill(g, o, opac)) { g.fill(); }
  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }
}

function drawPathAll(path, g, scene, bounds) {
  var i, len, item;
  for (i=0, len=scene.items.length; i<len; ++i) {
    item = scene.items[i];
    if (!bounds || bounds.intersects(item.bounds)) {
      drawPathOne(path, g, item, item);
    }
  }
}

function drawAll(pathFunc) {
  return function(g, scene, bounds) {
    drawPathAll(pathFunc, g, scene, bounds);
  };
}

function drawOne(pathFunc) {
  return function(g, scene, bounds) {
    if (!scene.items.length) return;
    if (!bounds || bounds.intersects(scene.bounds)) {
      drawPathOne(pathFunc, g, scene.items[0], scene.items);
    }
  };
}

var trueFunc = function() { return true; };

function pick(test) {
  if (!test) test = trueFunc;

  return function(g, scene, x, y, gx, gy) {
    if (!scene.items.length) return null;

    var o, b, i;

    if (g.pixelratio != null && g.pixelratio !== 1) {
      x *= g.pixelratio;
      y *= g.pixelratio;
    }

    for (i=scene.items.length; --i >= 0;) {
      o = scene.items[i]; b = o.bounds;
      // first hit test against bounding box
      if ((b && !b.contains(gx, gy)) || !b) continue;
      // if in bounding box, perform more careful test
      if (test(g, o, x, y, gx, gy)) return o;
    }
    return null;
  };
}

function testPath(path, filled) {
  return function(g, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = (filled == null) ? item.fill : filled,
        stroke = item.stroke && g.isPointInStroke, lw, lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      g.lineWidth = lw != null ? lw : 1;
      g.lineCap   = lc != null ? lc : 'butt';
    }

    return path(g, o) ? false :
      (fill && g.isPointInPath(x, y)) ||
      (stroke && g.isPointInStroke(x, y));
  };
}

function pickPath(path) {
  return pick(testPath(path));
}

function fill(g, o, opacity) {
  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.fillStyle = color(g, o, o.fill);
    return true;
  } else {
    return false;
  }
}

function stroke(g, o, opacity) {
  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;
  if (lw <= 0) return false;

  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.strokeStyle = color(g, o, o.stroke);
    g.lineWidth = lw;
    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';
    g.vgLineDash(o.strokeDash || null);
    g.vgLineDashOffset(o.strokeDashOffset || 0);
    return true;
  } else {
    return false;
  }
}

function color(g, o, value) {
  return (value.id) ?
    gradient(g, value, o.bounds) :
    value;
}

function gradient(g, p, b) {
  var w = b.width(),
      h = b.height(),
      x1 = b.x1 + p.x1 * w,
      y1 = b.y1 + p.y1 * h,
      x2 = b.x1 + p.x2 * w,
      y2 = b.y1 + p.y2 * h,
      grad = g.createLinearGradient(x1, y1, x2, y2),
      stop = p.stops,
      i, n;

  for (i=0, n=stop.length; i<n; ++i) {
    grad.addColorStop(stop[i].offset, stop[i].color);
  }
  return grad;
}

module.exports = {
  drawOne:  drawOne,
  drawAll:  drawAll,
  pick:     pick,
  pickPath: pickPath,
  testPath: testPath,
  stroke:   stroke,
  fill:     fill,
  color:    color,
  gradient: gradient
};

},{}],72:[function(require,module,exports){
module.exports = {
  'canvas': require('./canvas'),
  'svg':    require('./svg')
};

},{"./canvas":59,"./svg":76}],73:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler');

function SVGHandler() {
  Handler.call(this);
}

var base = Handler.prototype;
var prototype = (SVGHandler.prototype = Object.create(base));
prototype.constructor = SVGHandler;

prototype.initialize = function(el, pad, obj) {
  this._svg = DOM.find(el, 'svg');
  return base.initialize.call(this, el, pad, obj);
};

prototype.svg = function() {
  return this._svg;
};

// wrap an event listener for the SVG DOM
prototype.listener = function(handler) {
  var that = this;
  return function(evt) {
    var target = evt.target,
        item = target.__data__;
    evt.vegaType = evt.type;
    item = Array.isArray(item) ? item[0] : item;
    handler.call(that._obj, evt, item);
  };
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers,
      x = {
        type:     type,
        handler:  handler,
        listener: this.listener(handler)
      };

  (h[name] || (h[name] = [])).push(x);
  svg.addEventListener(name, x.listener);
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type === type && !handler || h[i].handler === handler) {
      svg.removeEventListener(name, h[i].listener);
      h.splice(i, 1);
    }
  }
  return this;
};

module.exports = SVGHandler;

},{"../../util/dom":85,"../Handler":55}],74:[function(require,module,exports){
var ImageLoader = require('../../util/ImageLoader'),
    Renderer = require('../Renderer'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    SVG = require('../../util/svg'),
    ns = SVG.metadata.xmlns,
    marks = require('./marks');

function SVGRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
  this._dirtyID = 0;
}

var base = Renderer.prototype;
var prototype = (SVGRenderer.prototype = Object.create(base));
prototype.constructor = SVGRenderer;

prototype.initialize = function(el, width, height, padding) {
  if (el) {
    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');
    DOM.clear(el, 1);
    // set the svg root group
    this._root = DOM.child(this._svg, 0, 'g', ns);
    DOM.clear(this._svg, 1);
  }

  // create the svg definitions cache
  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };

  // set background color if defined
  this.background(this._bgcolor);

  return base.initialize.call(this, el, width, height, padding);
};

prototype.background = function(bgcolor) {
  if (arguments.length && this._svg) {
    this._svg.style.setProperty('background-color', bgcolor);
  }
  return base.background.apply(this, arguments);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  
  if (this._svg) {
    var w = this._width,
        h = this._height,
        p = this._padding;
  
    this._svg.setAttribute('width', w + p.left + p.right);
    this._svg.setAttribute('height', h + p.top + p.bottom);
    
    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');
  }

  return this;
};

prototype.svg = function() {
  if (!this._svg) return null;

  var attr = {
    'class':  'marks',
    'width':  this._width + this._padding.left + this._padding.right,
    'height': this._height + this._padding.top + this._padding.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};


// -- Render entry point --

prototype.render = function(scene, items) {
  if (this._dirtyCheck(items)) {
    if (this._dirtyAll) this._resetDefs();
    this.draw(this._root, scene, -1);
    DOM.clear(this._root, 1);
  }
  this.updateDefs();
  return this;
};

prototype.draw = function(el, scene, index) {
  this.drawMark(el, scene, index, marks[scene.marktype]);
};


// -- Manage SVG definitions ('defs') block --

prototype.updateDefs = function() {
  var svg = this._svg,
      defs = this._defs,
      el = defs.el,
      index = 0, id;

  for (id in defs.gradient) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateGradient(el, defs.gradient[id], index++);
  }

  for (id in defs.clipping) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateClipping(el, defs.clipping[id], index++);
  }

  // clean-up
  if (el) {
    if (index === 0) {
      svg.removeChild(el);
      defs.el = null;
    } else {
      DOM.clear(el, index);      
    }
  }
};

function updateGradient(el, grad, index) {
  var i, n, stop;

  el = DOM.child(el, index, 'linearGradient', ns);
  el.setAttribute('id', grad.id);
  el.setAttribute('x1', grad.x1);
  el.setAttribute('x2', grad.x2);
  el.setAttribute('y1', grad.y1);
  el.setAttribute('y2', grad.y2);
  
  for (i=0, n=grad.stops.length; i<n; ++i) {
    stop = DOM.child(el, i, 'stop', ns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }
  DOM.clear(el, i);
}

function updateClipping(el, clip, index) {
  var rect;

  el = DOM.child(el, index, 'clipPath', ns);
  el.setAttribute('id', clip.id);
  rect = DOM.child(el, 0, 'rect', ns);
  rect.setAttribute('x', 0);
  rect.setAttribute('y', 0);
  rect.setAttribute('width', clip.width);
  rect.setAttribute('height', clip.height);
}

prototype._resetDefs = function() {
  var def = this._defs;
  def.clip_id = 1;
  def.gradient = {};
  def.clipping = {};
};


// -- Manage rendering of items marked as dirty --

prototype.isDirty = function(item) {
  return this._dirtyAll || item.dirty === this._dirtyID;
};

prototype._dirtyCheck = function(items) {
  this._dirtyAll = true;
  if (!items) return true;

  var id = ++this._dirtyID,
      item, mark, type, mdef, i, n, o;

  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    if (mark.marktype !== type) {
      // memoize mark instance lookup
      type = mark.marktype;
      mdef = marks[type];
    }

    if (item.status === 'exit') { // EXIT
      if (item._svg) {
        if (mdef.nest && item.mark.items.length) {
          // if nested mark with remaining points, update instead
          this._update(mdef, item._svg, item.mark.items[0]);
          o = item.mark.items[0];
          o._svg = item._svg;
          o._update = id;
        } else {
          // otherwise remove from DOM
          DOM.remove(item._svg);
        }
        item._svg = null;
      }
      continue;
    }

    item = (mdef.nest ? mark.items[0] : item);
    if (item._update === id) { // Already processed
      continue;
    } else if (item._svg) { // UPDATE
      this._update(mdef, item._svg, item);
    } else { // ENTER
      this._dirtyAll = false;
      dirtyParents(item, id);
    }
    item._update = id;
  }
  return !this._dirtyAll;
};

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item=item.mark.group) {
    item.dirty = id;
    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
}


// -- Construct & maintain scenegraph to SVG mapping ---

// Draw a mark container.
prototype.drawMark = function(el, scene, index, mdef) {
  if (!this.isDirty(scene)) return;

  var items = mdef.nest ?
        (scene.items && scene.items.length ? [scene.items[0]] : []) :
        scene.items || [],
      events = scene.interactive === false ? 'none' : null,
      isGroup = (mdef.tag === 'g'),
      className = DOM.cssClass(scene),
      p, i, n, c, d, insert;

  p = DOM.child(el, index+1, 'g', ns, className);
  p.setAttribute('class', className);
  scene._svg = p;
  if (!isGroup && events) {
    p.style.setProperty('pointer-events', events);
  }

  for (i=0, n=items.length; i<n; ++i) {
    if (this.isDirty(d = items[i])) {
      insert = !(this._dirtyAll || d._svg);
      c = bind(p, mdef, d, i, insert);
      this._update(mdef, c, d);
      if (isGroup) {
        if (insert) this._dirtyAll = true;
        this._recurse(c, d);
        if (insert) this._dirtyAll = false;
      }
    }
  }
  DOM.clear(p, i);
  return p;
};

// Recursively process group contents.
prototype._recurse = function(el, group) {
  var items = group.items || [],
      legends = group.legendItems || [],
      axes = group.axisItems || [],
      idx = 0, j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    this.draw(el, items[j], idx++);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    this.drawMark(el, legends[j], idx++, marks.group);
  }

  // remove any extraneous DOM elements
  DOM.clear(el, 1 + idx);
};

// Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.
function bind(el, mdef, item, index, insert) {
  // create svg element, bind item data for D3 compatibility
  var node = DOM.child(el, index, mdef.tag, ns, null, insert);
  node.__data__ = item;
  node.__values__ = {fill: 'default'};

  // create background rect
  if (mdef.tag === 'g') {
    var bg = DOM.child(node, 0, 'rect', ns, 'background');
    bg.__data__ = item;
  }

  // add pointer from scenegraph item to svg element
  return (item._svg = node);
}


// -- Set attributes & styles on SVG elements ---

var href = (typeof window !== 'undefined' ? window.location.href : ''),
    element = null, // temp var for current SVG element
    values = null;  // temp var for current values hash

// Extra configuration for certain mark types
var mark_extras = {
  group: function(mdef, el, item) {
    element = el.childNodes[0];
    values = el.__values__; // use parent's values hash
    mdef.background(emit, item, this);

    var value = item.mark.interactive === false ? 'none' : null;
    if (value !== values.events) {
      element.style.setProperty('pointer-events', value);
      values.events = value;
    }
  },
  text: function(mdef, el, item) {
    var str = text.value(item.text);
    if (str !== values.text) {
      el.textContent = str;
      values.text = str;
    }
    str = text.font(item);
    if (str !== values.font) {
      el.style.setProperty('font', str);
      values.font = str;
    }
  }
};

prototype._update = function(mdef, el, item) {
  // set dom element and values cache
  // provides access to emit method
  element = el;
  values = el.__values__;

  // apply svg attributes
  mdef.attr(emit, item, this);

  // some marks need special treatment
  var extra = mark_extras[mdef.type];
  if (extra) extra(mdef, el, item);

  // apply svg css styles
  // note: element may be modified by 'extra' method
  this.style(element, item);
};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return;

  if (value != null) {
    // if value is provided, update DOM attribute
    if (ns) {
      element.setAttributeNS(ns, name, value);
    } else {
      element.setAttribute(name, value);
    }
  } else {
    // else remove DOM attribute
    if (ns) {
      element.removeAttributeNS(ns, name);
    } else {
      element.removeAttribute(name);
    }
  }

  // note current value for future comparison
  values[name] = value;
}

prototype.style = function(el, o) {
  if (o == null) return;
  var i, n, prop, name, value;

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    value = o[prop];
    if (value === values[prop]) continue;

    name = SVG.styles[prop];
    if (value == null) {
      if (name === 'fill') {
        el.style.setProperty(name, 'none');
      } else {
        el.style.removeProperty(name);
      }
    } else {
      if (value.id) {
        // ensure definition is included
        this._defs.gradient[value.id] = value;
        value = 'url(' + href + '#' + value.id + ')';
      }
      el.style.setProperty(name, value+'');
    }

    values[prop] = value;
  }
};

module.exports = SVGRenderer;

},{"../../util/ImageLoader":81,"../../util/dom":85,"../../util/svg":87,"../../util/text":88,"../Renderer":56,"./marks":77}],75:[function(require,module,exports){
var Renderer = require('../Renderer'),
    ImageLoader = require('../../util/ImageLoader'),
    SVG = require('../../util/svg'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    openTag = DOM.openTag,
    closeTag = DOM.closeTag,
    MARKS = require('./marks');

function SVGStringRenderer(loadConfig) {
  Renderer.call(this);

  this._loader = new ImageLoader(loadConfig);

  this._text = {
    head: '',
    root: '',
    foot: '',
    defs: '',
    body: ''
  };

  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };
}

var base = Renderer.prototype;
var prototype = (SVGStringRenderer.prototype = Object.create(base));
prototype.constructor = SVGStringRenderer;

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  var p = this._padding,
      t = this._text;

  var attr = {
    'class':  'marks',
    'width':  this._width + p.left + p.right,
    'height': this._height + p.top + p.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  t.head = openTag('svg', attr);
  t.root = openTag('g', {
    transform: 'translate(' + p.left + ',' + p.top + ')'
  });
  t.foot = closeTag('g') + closeTag('svg');

  return this;
};

prototype.svg = function() {
  var t = this._text;
  return t.head + t.defs + t.root + t.body + t.foot;
};

prototype.render = function(scene) {
  this._text.body = this.mark(scene);
  this._text.defs = this.buildDefs();
  return this;
};

prototype.reset = function() {
  this._defs.clip_id = 0;
  return this;
};

prototype.buildDefs = function() {
  var all = this._defs,
      defs = '',
      i, id, def, stops;

  for (id in all.gradient) {
    def = all.gradient[id];
    stops = def.stops;

    defs += openTag('linearGradient', {
      id: id,
      x1: def.x1,
      x2: def.x2,
      y1: def.y1,
      y2: def.y2
    });
    
    for (i=0; i<stops.length; ++i) {
      defs += openTag('stop', {
        offset: stops[i].offset,
        'stop-color': stops[i].color
      }) + closeTag('stop');
    }
    
    defs += closeTag('linearGradient');
  }
  
  for (id in all.clipping) {
    def = all.clipping[id];

    defs += openTag('clipPath', {id: id});

    defs += openTag('rect', {
      x: 0,
      y: 0,
      width: def.width,
      height: def.height
    }) + closeTag('rect');

    defs += closeTag('clipPath');
  }
  
  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};

var object;

function emit(name, value, ns, prefixed) {
  object[prefixed || name] = value;
}

prototype.attributes = function(attr, item) {
  object = {};
  attr(emit, item, this);
  return object;
};

prototype.mark = function(scene) {
  var mdef = MARKS[scene.marktype],
      tag  = mdef.tag,
      attr = mdef.attr,
      nest = mdef.nest || false,
      data = nest ?
          (scene.items && scene.items.length ? [scene.items[0]] : []) :
          (scene.items || []),
      defs = this._defs,
      str = '',
      style, i, item;

  if (tag !== 'g' && scene.interactive === false) {
    style = 'style="pointer-events: none;"';
  }

  // render opening group tag
  str += openTag('g', {
    'class': DOM.cssClass(scene)
  }, style);

  // render contained elements
  for (i=0; i<data.length; ++i) {
    item = data[i];
    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;
    str += openTag(tag, this.attributes(attr, item), style);
    if (tag === 'text') {
      str += escape_text(text.value(item.text));
    } else if (tag === 'g') {
      str += openTag('rect',
        this.attributes(mdef.background, item),
        styles(item, scene, 'bgrect', defs)) + closeTag('rect');
      str += this.markGroup(item);
    }
    str += closeTag(tag);
  }

  // render closing group tag
  return str + closeTag('g');
};

prototype.markGroup = function(scene) {
  var str = '',
      axes = scene.axisItems || [],
      items = scene.items || [],
      legends = scene.legendItems || [],
      j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    str += this.mark(items[j]);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    str += this.mark(legends[j]);
  }

  return str;
};

function styles(o, mark, tag, defs) {
  if (o == null) return '';
  var i, n, prop, name, value, s = '';

  if (tag === 'bgrect' && mark.interactive === false) {
    s += 'pointer-events: none;';
  }

  if (tag === 'text') {
    s += 'font: ' + text.font(o) + ';';
  }

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    name = SVG.styles[prop];
    value = o[prop];

    if (value == null) {
      if (name === 'fill') {
        s += (s.length ? ' ' : '') + 'fill: none;';
      }
    } else {
      if (value.id) {
        // ensure definition is included
        defs.gradient[value.id] = value;
        value = 'url(#' + value.id + ')';
      }
      s += (s.length ? ' ' : '') + name + ': ' + value + ';';
    }
  }

  return s ? 'style="' + s + '"' : null;
}

function escape_text(s) {
  return s.replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
}

module.exports = SVGStringRenderer;

},{"../../util/ImageLoader":81,"../../util/dom":85,"../../util/svg":87,"../../util/text":88,"../Renderer":56,"./marks":77}],76:[function(require,module,exports){
module.exports = {
  Handler:  require('./SVGHandler'),
  Renderer: require('./SVGRenderer'),
  string: {
    Renderer : require('./SVGStringRenderer')
  }
};
},{"./SVGHandler":73,"./SVGRenderer":74,"./SVGStringRenderer":75}],77:[function(require,module,exports){
var text = require('../../util/text'),
    SVG = require('../../util/svg'),
    textAlign = SVG.textAlign,
    path = SVG.path;

function translateItem(o) {
  return translate(o.x || 0, o.y || 0);
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}

module.exports = {
  arc: {
    tag:  'path',
    type: 'arc',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.arc(o));
    }
  },
  area: {
    tag:  'path',
    type: 'area',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.area(items));
    }
  },
  group: {
    tag:  'g',
    type: 'group',
    attr: function(emit, o, renderer) {
      var id = null, defs, c;
      emit('transform', translateItem(o));
      if (o.clip) {
        defs = renderer._defs;
        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);
        c = defs.clipping[id] || (defs.clipping[id] = {id: id});
        c.width = o.width || 0;
        c.height = o.height || 0;
      }
      emit('clip-path', id ? ('url(#' + id + ')') : null);
    },
    background: function(emit, o) {
      emit('class', 'background');
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  image: {
    tag:  'image',
    type: 'image',
    attr: function(emit, o, renderer) {
      var x = o.x || 0,
          y = o.y || 0,
          w = o.width || 0,
          h = o.height || 0,
          url = renderer.imageURL(o.url);

      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);
      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);

      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');
      emit('transform', translate(x, y));
      emit('width', w);
      emit('height', h);
    }
  },
  line: {
    tag:  'path',
    type: 'line',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.line(items));
    }
  },
  path: {
    tag:  'path',
    type: 'path',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', o.path);
    }
  },
  rect: {
    tag:  'rect',
    type: 'rect',
    nest: false,
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  rule: {
    tag:  'line',
    type: 'rule',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);
      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);
    }
  },
  symbol: {
    tag:  'path',
    type: 'symbol',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.symbol(o));
    }
  },
  text: {
    tag:  'text',
    type: 'text',
    nest: false,
    attr: function(emit, o) {
      var dx = (o.dx || 0),
          dy = (o.dy || 0) + text.offset(o),
          x = (o.x || 0),
          y = (o.y || 0),
          a = o.angle || 0,
          r = o.radius || 0, t;

      if (r) {
        t = (o.theta || 0) - Math.PI/2;
        x += r * Math.cos(t);
        y += r * Math.sin(t);
      }

      emit('text-anchor', textAlign[o.align] || 'start');
      
      if (a) {
        t = translate(x, y) + ' rotate('+a+')';
        if (dx || dy) t += ' ' + translate(dx, dy);
      } else {
        t = translate(x+dx, y+dy);
      }
      emit('transform', t);
    }
  }
};

},{"../../util/svg":87,"../../util/text":88}],78:[function(require,module,exports){
function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}

var prototype = Bounds.prototype;

prototype.clone = function() {
  return new Bounds(this);
};

prototype.clear = function() {
  this.x1 = +Number.MAX_VALUE;
  this.y1 = +Number.MAX_VALUE;
  this.x2 = -Number.MAX_VALUE;
  this.y2 = -Number.MAX_VALUE;
  return this;
};

prototype.set = function(x1, y1, x2, y2) {
  this.x1 = x1;
  this.y1 = y1;
  this.x2 = x2;
  this.y2 = y2;
  return this;
};

prototype.add = function(x, y) {
  if (x < this.x1) this.x1 = x;
  if (y < this.y1) this.y1 = y;
  if (x > this.x2) this.x2 = x;
  if (y > this.y2) this.y2 = y;
  return this;
};

prototype.expand = function(d) {
  this.x1 -= d;
  this.y1 -= d;
  this.x2 += d;
  this.y2 += d;
  return this;
};

prototype.round = function() {
  this.x1 = Math.floor(this.x1);
  this.y1 = Math.floor(this.y1);
  this.x2 = Math.ceil(this.x2);
  this.y2 = Math.ceil(this.y2);
  return this;
};

prototype.translate = function(dx, dy) {
  this.x1 += dx;
  this.x2 += dx;
  this.y1 += dy;
  this.y2 += dy;
  return this;
};

prototype.rotate = function(angle, x, y) {
  var cos = Math.cos(angle),
      sin = Math.sin(angle),
      cx = x - x*cos + y*sin,
      cy = y - x*sin - y*cos,
      x1 = this.x1, x2 = this.x2,
      y1 = this.y1, y2 = this.y2;

  return this.clear()
    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)
    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)
    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)
    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);
};

prototype.union = function(b) {
  if (b.x1 < this.x1) this.x1 = b.x1;
  if (b.y1 < this.y1) this.y1 = b.y1;
  if (b.x2 > this.x2) this.x2 = b.x2;
  if (b.y2 > this.y2) this.y2 = b.y2;
  return this;
};

prototype.encloses = function(b) {
  return b && (
    this.x1 <= b.x1 &&
    this.x2 >= b.x2 &&
    this.y1 <= b.y1 &&
    this.y2 >= b.y2
  );
};

prototype.intersects = function(b) {
  return b && !(
    this.x2 < b.x1 ||
    this.x1 > b.x2 ||
    this.y2 < b.y1 ||
    this.y1 > b.y2
  );
};

prototype.contains = function(x, y) {
  return !(
    x < this.x1 ||
    x > this.x2 ||
    y < this.y1 ||
    y > this.y2
  );
};

prototype.width = function() {
  return this.x2 - this.x1;
};

prototype.height = function() {
  return this.y2 - this.y1;
};

module.exports = Bounds;

},{}],79:[function(require,module,exports){
module.exports = function(b) {
  function noop() { }
  function add(x,y) { b.add(x, y); }

  return {
    bounds: function(_) {
      if (!arguments.length) return b;
      return (b = _, this);
    },
    beginPath: noop,
    closePath: noop,
    moveTo: add,
    lineTo: add,
    quadraticCurveTo: function(x1, y1, x2, y2) {
      b.add(x1, y1);
      b.add(x2, y2);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      b.add(x1, y1);
      b.add(x2, y2);
      b.add(x3, y3);
    }
  };
};

},{}],80:[function(require,module,exports){
var gradient_id = 0;

function Gradient(type) {
  this.id = 'gradient_' + (gradient_id++);
  this.type = type || 'linear';
  this.stops = [];
  this.x1 = 0;
  this.x2 = 1;
  this.y1 = 0;
  this.y2 = 0;
}

var prototype = Gradient.prototype;

prototype.stop = function(offset, color) {
  this.stops.push({
    offset: offset,
    color: color
  });
  return this;
};

module.exports = Gradient;
},{}],81:[function(require,module,exports){
(function (global){
var load = require('datalib/src/import/load');

function ImageLoader(loadConfig) {
  this._pending = 0;
  this._config = loadConfig || ImageLoader.Config; 
}

// Overridable global default load configuration
ImageLoader.Config = null;

var prototype = ImageLoader.prototype;

prototype.pending = function() {
  return this._pending;
};

prototype.params = function(uri) {
  var p = {url: uri}, k;
  for (k in this._config) { p[k] = this._config[k]; }
  return p;
};

prototype.imageURL = function(uri) {
  return load.sanitizeUrl(this.params(uri));
};

function browser(uri, callback) {
  var url = load.sanitizeUrl(this.params(uri));
  if (!url) { // error
    if (callback) callback(uri, null);
    return null;
  }

  var loader = this,
      image = new Image();

  loader._pending += 1;

  image.onload = function() {
    loader._pending -= 1;
    image.loaded = true;
    if (callback) callback(null, image);
  };
  image.src = url;

  return image;
}

function server(uri, callback) {
  var loader = this,
      image = new ((typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null).Image)();

  loader._pending += 1;

  load(this.params(uri), function(err, data) {
    loader._pending -= 1;
    if (err) {
      if (callback) callback(err, null);
      return null;
    }
    image.src = data;
    image.loaded = true;
    if (callback) callback(null, image);
  });

  return image;
}

prototype.loadImage = function(uri, callback) {
  return load.useXHR ?
    browser.call(this, uri, callback) :
    server.call(this, uri, callback);
};

module.exports = ImageLoader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"datalib/src/import/load":20}],82:[function(require,module,exports){
function Item(mark) {
  this.mark = mark;
}

var prototype = Item.prototype;

prototype.hasPropertySet = function(name) {
  var props = this.mark.def.properties;
  return props && props[name] != null;
};

prototype.cousin = function(offset, index) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      group = mark.group,
      iidx = index==null ? mark.items.indexOf(this) : index,
      midx = group.items.indexOf(mark) + offset;
  return group.items[midx].items[iidx];
};

prototype.sibling = function(offset) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      iidx = mark.items.indexOf(this) + offset;
  return mark.items[iidx];
};

prototype.remove = function() {
  var item = this,
      list = item.mark.items,
      i = list.indexOf(item);
  if (i >= 0) {
    if (i===list.length-1) {
      list.pop();
    } else {
      list.splice(i, 1);
    }
  }
  return item;
};

prototype.touch = function() {
  if (this.pathCache) this.pathCache = null;
};

module.exports = Item;
},{}],83:[function(require,module,exports){
var BoundsContext = require('./BoundsContext'),
    Bounds = require('./Bounds'),
    canvas = require('./canvas'),
    svg = require('./svg'),
    text = require('./text'),
    paths = require('../path'),
    parse = paths.parse,
    drawPath = paths.render,
    areaPath = svg.path.area,
    linePath = svg.path.line,
    halfpi = Math.PI / 2,
    sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180),
    g2D = null,
    bc = BoundsContext();

function context() {
  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));
}

function strokeBounds(o, bounds) {
  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {
    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);
  }
  return bounds;
}

function pathBounds(o, path, bounds, x, y) {
  if (path == null) {
    bounds.set(0, 0, 0, 0);
  } else {
    drawPath(bc.bounds(bounds), path, x, y);
    strokeBounds(o, bounds);
  }
  return bounds;
}

function path(o, bounds) {
  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;
  return pathBounds(o, p, bounds, o.x, o.y);
}

function area(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(areaPath(items)));
  return pathBounds(item, p, bounds);
}

function line(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(linePath(items)));
  return pathBounds(item, p, bounds);
}

function rect(o, bounds) {
  var x, y;
  return strokeBounds(o, bounds.set(
    x = o.x || 0,
    y = o.y || 0,
    (x + o.width) || 0,
    (y + o.height) || 0
  ));
}

function image(o, bounds) {
  var x = o.x || 0,
      y = o.y || 0,
      w = o.width || 0,
      h = o.height || 0;
  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));
  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));
  return bounds.set(x, y, x+w, y+h);
}

function rule(o, bounds) {
  var x1, y1;
  return strokeBounds(o, bounds.set(
    x1 = o.x || 0,
    y1 = o.y || 0,
    o.x2 != null ? o.x2 : x1,
    o.y2 != null ? o.y2 : y1
  ));
}

function arc(o, bounds) {
  var cx = o.x || 0,
      cy = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi,
      xmin = Infinity, xmax = -Infinity,
      ymin = Infinity, ymax = -Infinity,
      a, i, n, x, y, ix, iy, ox, oy;

  var angles = [sa, ea],
      s = sa - (sa % halfpi);
  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {
    angles.push(s);
  }

  for (i=0, n=angles.length; i<n; ++i) {
    a = angles[i];
    x = Math.cos(a); ix = ir*x; ox = or*x;
    y = Math.sin(a); iy = ir*y; oy = or*y;
    xmin = Math.min(xmin, ix, ox);
    xmax = Math.max(xmax, ix, ox);
    ymin = Math.min(ymin, iy, oy);
    ymax = Math.max(ymax, iy, oy);
  }

  return strokeBounds(o, bounds.set(
    cx + xmin,
    cy + ymin,
    cx + xmax,
    cy + ymax
  ));
}

function symbol(o, bounds) {
  var size = o.size != null ? o.size : 100,
      x = o.x || 0,
      y = o.y || 0,
      r, t, rx, ry;

  switch (o.shape) {
    case 'cross':
      t = 3 * Math.sqrt(size / 5) / 2;
      bounds.set(x-t, y-t, x+t, y+t);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      bounds.set(x-r, y-r, x+r, y+r);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    default:
      r = Math.sqrt(size/Math.PI);
      bounds.set(x-r, y-r, x+r, y+r);
  }

  return strokeBounds(o, bounds);
}

function textMark(o, bounds, noRotate) {
  var g = context(),
      h = text.size(o),
      a = o.align,
      r = o.radius || 0,
      x = (o.x || 0),
      y = (o.y || 0),
      dx = (o.dx || 0),
      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset
      w, t;

  if (r) {
    t = (o.theta || 0) - Math.PI/2;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  // horizontal alignment
  g.font = text.font(o);
  w = g.measureText(text.value(o.text)).width;
  if (a === 'center') {
    dx -= (w / 2);
  } else if (a === 'right') {
    dx -= w;
  } else {
    // left by default, do nothing
  }

  bounds.set(dx+=x, dy+=y, dx+w, dy+h);
  if (o.angle && !noRotate) {
    bounds.rotate(o.angle*Math.PI/180, x, y);
  }
  return bounds.expand(noRotate ? 0 : 1);
}

function group(g, bounds, includeLegends) {
  var axes = g.axisItems || [],
      items = g.items || [],
      legends = g.legendItems || [],
      j, m;

  if (!g.clip) {
    for (j=0, m=axes.length; j<m; ++j) {
      bounds.union(axes[j].bounds);
    }
    for (j=0, m=items.length; j<m; ++j) {
      bounds.union(items[j].bounds);
    }
    if (includeLegends) {
      for (j=0, m=legends.length; j<m; ++j) {
        bounds.union(legends[j].bounds);
      }
    }
  }
  if (g.clip || g.width || g.height) {
    strokeBounds(g, bounds
      .add(0, 0)
      .add(g.width || 0, g.height || 0));
  }
  return bounds.translate(g.x || 0, g.y || 0);
}

var methods = {
  group:  group,
  symbol: symbol,
  image:  image,
  rect:   rect,
  rule:   rule,
  arc:    arc,
  text:   textMark,
  path:   path,
  area:   area,
  line:   line
};
methods.area.nest = true;
methods.line.nest = true;

function itemBounds(item, func, opt) {
  var type = item.mark.marktype;
  func = func || methods[type];
  if (func.nest) item = item.mark;

  var curr = item.bounds,
      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());

  if (curr) {
    prev.clear().union(curr);
    curr.clear();
  } else {
    item.bounds = new Bounds();
  }
  func(item, item.bounds, opt);
  if (!curr) prev.clear().union(item.bounds);
  return item.bounds;
}

var DUMMY_ITEM = {mark: null};

function markBounds(mark, bounds, opt) {
  var type  = mark.marktype,
      func  = methods[type],
      items = mark.items,
      hasi  = items && items.length,
      i, n, o, b;

  if (func.nest) {
    o = hasi ? items[0]
      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it
    b = itemBounds(o, func, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasi) {  
    for (i=0, n=items.length; i<n; ++i) {
      bounds.union(itemBounds(items[i], func, opt));
    }
  }
  return (mark.bounds = bounds);
}

module.exports = {
  mark:  markBounds,
  item:  itemBounds,
  text:  textMark,
  group: group
};

},{"../path":52,"./Bounds":78,"./BoundsContext":79,"./canvas":84,"./svg":87,"./text":88}],84:[function(require,module,exports){
(function (global){
function instance(w, h) {
  w = w || 1;
  h = h || 1;
  var canvas;

  if (typeof document !== 'undefined' && document.createElement) {
    canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
  } else {
    var Canvas = (typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null);
    if (!Canvas.prototype) return null;
    canvas = new Canvas(w, h);
  }
  return lineDash(canvas);
}

function resize(canvas, w, h, p, retina) {
  var g = this._ctx = canvas.getContext('2d'), 
      s = 1;

  canvas.width = w + p.left + p.right;
  canvas.height = h + p.top + p.bottom;

  // if browser canvas, attempt to modify for retina display
  if (retina && typeof HTMLElement !== 'undefined' &&
      canvas instanceof HTMLElement)
  {
    g.pixelratio = (s = pixelRatio(canvas) || 1);
  }

  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);
  return canvas;
}

function pixelRatio(canvas) {
  var g = canvas.getContext('2d');

  // get canvas pixel data
  var devicePixelRatio = window && window.devicePixelRatio || 1,
      backingStoreRatio = (
        g.webkitBackingStorePixelRatio ||
        g.mozBackingStorePixelRatio ||
        g.msBackingStorePixelRatio ||
        g.oBackingStorePixelRatio ||
        g.backingStorePixelRatio) || 1,
      ratio = devicePixelRatio / backingStoreRatio;

  if (devicePixelRatio !== backingStoreRatio) {
    // set actual and visible canvas size
    var w = canvas.width,
        h = canvas.height;
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  return ratio;
}

function lineDash(canvas) {
  var g = canvas.getContext('2d');
  if (g.vgLineDash) return; // already initialized!

  var NOOP = function() {},
      NODASH = [];
  
  if (g.setLineDash) {
    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };
    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };
  } else if (g.webkitLineDash !== undefined) {
  	g.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };
    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };
  } else if (g.mozDash !== undefined) {
    g.vgLineDash = function(dash) { this.mozDash = dash; };
    g.vgLineDashOffset = NOOP;
  } else {
    g.vgLineDash = NOOP;
    g.vgLineDashOffset = NOOP;
  }
  return canvas;
}

module.exports = {
  instance:   instance,
  resize:     resize,
  lineDash:   lineDash
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],85:[function(require,module,exports){
// create a new DOM element
function create(doc, tag, ns) {
  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);
}

// remove element from DOM
// recursively remove parent elements if empty
function remove(el) {
  if (!el) return;
  var p = el.parentNode;
  if (p) {
    p.removeChild(el);
    if (!p.childNodes || !p.childNodes.length) remove(p);
  }
}

module.exports = {
  // find first child element with matching tag
  find: function(el, tag) {
    tag = tag.toLowerCase();
    for (var i=0, n=el.childNodes.length; i<n; ++i) {
      if (el.childNodes[i].tagName.toLowerCase() === tag) {
        return el.childNodes[i];
      }
    }
  },
  // retrieve child element at given index
  // create & insert if doesn't exist or if tag/className do not match
  child: function(el, index, tag, ns, className, insert) {
    var a, b;
    a = b = el.childNodes[index];
    if (!a || insert ||
        a.tagName.toLowerCase() !== tag.toLowerCase() ||
        className && a.getAttribute('class') != className) {
      a = create(el.ownerDocument, tag, ns);
      el.insertBefore(a, b);
      if (className) a.setAttribute('class', className);
    }
    return a;
  },
  // remove all child elements at or above the given index
  clear: function(el, index) {
    var curr = el.childNodes.length;
    while (curr > index) {
      el.removeChild(el.childNodes[--curr]);
    }
    return el;
  },
  remove: remove,
  // generate css class name for mark
  cssClass: function(mark) {
    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');
  },
  // generate string for an opening xml tag
  // tag: the name of the xml tag
  // attr: hash of attribute name-value pairs to include
  // raw: additional raw string to include in tag markup
  openTag: function(tag, attr, raw) {
    var s = '<' + tag, key, val;
    if (attr) {
      for (key in attr) {
        val = attr[key];
        if (val != null) {
          s += ' ' + key + '="' + val + '"';
        }
      }
    }
    if (raw) s += ' ' + raw;
    return s + '>';
  },
  // generate string for closing xml tag
  // tag: the name of the xml tag
  closeTag: function(tag) {
    return '</' + tag + '>';
  }
};

},{}],86:[function(require,module,exports){
var bound = require('../util/bound');

var sets = [
  'items',
  'axisItems',
  'legendItems'
];

var keys = [
  'marktype', 'name', 'interactive', 'clip',
  'items', 'axisItems', 'legendItems', 'layer',
  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout
  'fill', 'fillOpacity', 'opacity',                             // fill
  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke
  'strokeDash', 'strokeDashOffset',                             // stroke dash
  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc
  'interpolate', 'tension', 'orient',                           // area, line
  'url',                                                        // image
  'path',                                                       // path
  'x2', 'y2',                                                   // rule
  'size', 'shape',                                              // symbol
  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text
  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font
];

function toJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}

function fromJSON(json) {
  var scene = (typeof json === 'string' ? JSON.parse(json) : json);
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      i, n, s, m, items;

  for (s=0, m=sets.length; s<m; ++s) {
    if ((items = scene[sets[s]])) {
      for (i=0, n=items.length; i<n; ++i) {
        items[i][type ? 'mark' : 'group'] = scene;
        if (!type || type === 'group') {
          initialize(items[i]);
        }
      }
    }
  }

  if (type) bound.mark(scene);
  return scene;
}

module.exports = {
  toJSON:   toJSON,
  fromJSON: fromJSON
};
},{"../util/bound":83}],87:[function(require,module,exports){
(function (global){
var d3_svg = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null).svg;

function x(o)     { return o.x || 0; }
function y(o)     { return o.y || 0; }
function xw(o)    { return (o.x || 0) + (o.width || 0); }
function yh(o)    { return (o.y || 0) + (o.height || 0); }
function size(o)  { return o.size == null ? 100 : o.size; }
function shape(o) { return o.shape || 'circle'; }

var areav = d3_svg.area().x(x).y1(y).y0(yh),
    areah = d3_svg.area().y(y).x1(x).x0(xw),
    line  = d3_svg.line().x(x).y(y);

module.exports = {
  metadata: {
    'version': '1.1',
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink'
  },
  path: {
    arc: d3_svg.arc(),
    symbol: d3_svg.symbol().type(shape).size(size),
    area: function(items) {
      var o = items[0];
      return (o.orient === 'horizontal' ? areah : areav)
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    },
    line: function(items) {
      var o = items[0];
      return line
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    }
  },
  textAlign: {
    'left':   'start',
    'center': 'middle',
    'right':  'end'
  },
  textBaseline: {
    'top':    'before-edge',
    'bottom': 'after-edge',
    'middle': 'central'
  },
  styles: {
    'fill':             'fill',
    'fillOpacity':      'fill-opacity',
    'stroke':           'stroke',
    'strokeWidth':      'stroke-width',
    'strokeOpacity':    'stroke-opacity',
    'strokeCap':        'stroke-linecap',
    'strokeDash':       'stroke-dasharray',
    'strokeDashOffset': 'stroke-dashoffset',
    'opacity':          'opacity'
  },
  styleProperties: [
    'fill',
    'fillOpacity',
    'stroke',
    'strokeWidth',
    'strokeOpacity',
    'strokeCap',
    'strokeDash',
    'strokeDashOffset',
    'opacity'
  ]
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],88:[function(require,module,exports){
function size(item) {
  return item.fontSize != null ? item.fontSize : 11;
}

module.exports = {
  size: size,
  value: function(s) {
    return s != null ? String(s) : '';
  },
  font: function(item, quote) {
    var font = item.font;
    if (quote && font) {
      font = String(font).replace(/\"/g, '\'');
    }
    return '' +
      (item.fontStyle ? item.fontStyle + ' ' : '') +
      (item.fontVariant ? item.fontVariant + ' ' : '') +
      (item.fontWeight ? item.fontWeight + ' ' : '') +
      size(item) + 'px ' +
      (font || 'sans-serif');
  },
  offset: function(item) {
    // perform our own font baseline calculation
    // why? not all browsers support SVG 1.1 'alignment-baseline' :(
    var baseline = item.baseline,
        h = size(item);
    return Math.round(
      baseline === 'top'    ?  0.93*h :
      baseline === 'middle' ?  0.30*h :
      baseline === 'bottom' ? -0.21*h : 0
    );
  }
};

},{}],89:[function(require,module,exports){
module.exports = {
  version: '2.2.6',
  dataflow: require('vega-dataflow'),
  parse: require('./src/parse/'),
  scene: {
    Bounder: require('./src/scene/Bounder'),
    Builder: require('./src/scene/Builder'),
    Encoder: require('./src/scene/Encoder'),
    GroupBuilder: require('./src/scene/GroupBuilder'),
  },
  transforms: require('./src/transforms'),
  schema: require('./src/core/schema'),
  config: require('./src/core/config'),
  util:  require('datalib'),
  debug: require('vega-logging').debug
};
},{"./src/core/config":93,"./src/core/schema":94,"./src/parse/":100,"./src/scene/Bounder":112,"./src/scene/Builder":113,"./src/scene/Encoder":114,"./src/scene/GroupBuilder":115,"./src/transforms":144,"datalib":24,"vega-dataflow":43,"vega-logging":49}],90:[function(require,module,exports){
var sg = require('vega-scenegraph').render,
    canvas = sg.canvas,
    svg = sg.svg.string,
    View = require('./View');

function HeadlessView(width, height, model) {
  View.call(null, width, height, model);
  this._type = 'canvas';
  this._renderers = {canvas: canvas, svg: svg};
}

var prototype = (HeadlessView.prototype = new View());

prototype.renderer = function(type) {
  if(type) this._type = type;
  return View.prototype.renderer.apply(this, arguments);
};

prototype.canvas = function() {
  return (this._type === 'canvas') ? this._renderer.canvas() : null;
};

prototype.canvasAsync = function(callback) {
  var r = this._renderer, view = this;
  
  function wait() {
    if (r.pendingImages() === 0) {
      view.render(); // re-render with all images
      callback(view.canvas());
    } else {
      setTimeout(wait, 10);
    }
  }

  // if images loading, poll until ready
  if (this._type !== 'canvas') return null;
  if (r.pendingImages() > 0) { wait(); } else { callback(this.canvas()); }
};

prototype.svg = function() {
  return (this._type === 'svg') ? this._renderer.svg() : null;
};

prototype.initialize = function() {    
  var w = this._width,
      h = this._height,
      bg  = this._bgcolor,
      pad = this._padding,
      config = this.model().config();

  if (this._viewport) {
    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);
    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);
  }

  this._renderer = (this._renderer || new this._io.Renderer(config.load))
    .initialize(null, w, h, pad)
    .background(bg);
  
  return this;
};

module.exports = HeadlessView;
},{"./View":92,"vega-scenegraph":50}],91:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    ChangeSet = df.ChangeSet,
    Base = df.Graph.prototype,
    Node  = df.Node, // jshint ignore:line
    GroupBuilder = require('../scene/GroupBuilder'),
    visit = require('../scene/visit'),
    config = require('./config');

function Model(cfg) {
  this._defs = {};
  this._predicates = {};
  this._scene = null;

  this._node = null;
  this._builder = null; // Top-level scenegraph builder

  this._reset = {axes: false, legends: false};

  this.config(cfg);
  Base.init.call(this);
}

var prototype = (Model.prototype = Object.create(Base));
prototype.constructor = Model;

prototype.defs = function(defs) {
  if (!arguments.length) return this._defs;
  this._defs = defs;
  return this;
};

prototype.config = function(cfg) {
  if (!arguments.length) return this._config;
  this._config = Object.create(config);
  for (var name in cfg) {
    var x = cfg[name], y = this._config[name];
    if (dl.isObject(x) && dl.isObject(y)) {
      dl.extend(y, x);
    } else {
      this._config[name] = x;
    }
  }

  return this;
};

prototype.width = function(width) {
  if (this._defs) this._defs.width = width;
  if (this._defs && this._defs.marks) this._defs.marks.width = width;
  if (this._scene) {
    this._scene.items[0].width = width;
    this._scene.items[0]._dirty = true;
  }
  this._reset.axes = true;
  return this;
};

prototype.height = function(height) {
  if (this._defs) this._defs.height = height;
  if (this._defs && this._defs.marks) this._defs.marks.height = height;
  if (this._scene) {
    this._scene.items[0].height = height;
    this._scene.items[0]._dirty = true;
  }
  this._reset.axes = true;
  return this;
};

prototype.node = function() {
  return this._node || (this._node = new Node(this));
};

prototype.data = function() {
  var data = Base.data.apply(this, arguments);
  if (arguments.length > 1) {  // new Datasource
    this.node().addListener(data.pipeline()[0]);
  }
  return data;
};

function predicates(name) {
  var m = this, pred = {};
  if (!dl.isArray(name)) return this._predicates[name];
  name.forEach(function(n) { pred[n] = m._predicates[n]; });
  return pred;
}

prototype.predicate = function(name, predicate) {
  if (arguments.length === 1) return predicates.call(this, name);
  return (this._predicates[name] = predicate);
};

prototype.predicates = function() { return this._predicates; };

prototype.scene = function(renderer) {
  if (!arguments.length) return this._scene;
  if (this._builder) this.node().removeListener(this._builder.disconnect());
  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});
  this.node().addListener(this._builder.connect());
  var p = this._builder.pipeline();
  p[p.length-1].addListener(renderer);
  return this;
};

prototype.reset = function() {
  if (this._scene && this._reset.axes) {
    visit(this._scene, function(item) {
      if (item.axes) item.axes.forEach(function(axis) { axis.reset(); });
    });
    this._reset.axes = false;
  }
  if (this._scene && this._reset.legends) {
    visit(this._scene, function(item) {
      if (item.legends) item.legends.forEach(function(l) { l.reset(); });
    });
    this._reset.legends = false;
  }
  return this;
};

prototype.addListener = function(l) {
  this.node().addListener(l);
};

prototype.removeListener = function(l) {
  this.node().removeListener(l); 
};

prototype.fire = function(cs) {
  if (!cs) cs = ChangeSet.create();
  this.propagate(cs, this.node());
};

module.exports = Model;
},{"../scene/GroupBuilder":115,"../scene/visit":120,"./config":93,"datalib":24,"vega-dataflow":43}],92:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    sg = require('vega-scenegraph').render,
    log = require('vega-logging'),
    Deps = df.Dependencies,
    parseStreams = require('../parse/streams'),
    Encoder = require('../scene/Encoder'),
    Transition = require('../scene/Transition');

function View(el, width, height) {
  this._el    = null;
  this._model = null;
  this._width = this.__width = width || 500;
  this._height  = this.__height = height || 300;
  this._bgcolor = null;
  this._autopad = 1;
  this._padding = {top:0, left:0, bottom:0, right:0};
  this._viewport = null;
  this._renderer = null;
  this._handler  = null;
  this._streamer = null; // Targeted update for streaming changes
  this._changeset = null;
  this._repaint = true; // Full re-render on every re-init
  this._renderers = sg;
  this._io  = null;
  this._api = {}; // Stash streaming data API sandboxes.
}

var prototype = View.prototype;

prototype.model = function(model) {
  if (!arguments.length) return this._model;
  if (this._model !== model) {
    this._model = model;
    this._streamer = new df.Node(model);
    this._streamer._rank = -1;  // HACK: To reduce re-ranking churn.
    this._changeset = df.ChangeSet.create();
    if (this._handler) this._handler.model(model);
  }
  return this;
};

// Sandboxed streaming data API
function streaming(src) {
  var view = this,
      ds = this._model.data(src),
      name = ds.name(),
      listener = ds.pipeline()[0],
      streamer = this._streamer,
      api = {};

  // If we have it stashed, don't create a new closure. 
  if (this._api[src]) return this._api[src];

  api.insert = function(vals) {
    ds.insert(dl.duplicate(vals));  // Don't pollute the environment
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return api;
  };

  api.update = function() {
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return (ds.update.apply(ds, arguments), api);
  };

  api.remove = function() {
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return (ds.remove.apply(ds, arguments), api);
  };

  api.values = function() { return ds.values(); };    

  return (this._api[src] = api);
}

prototype.data = function(data) {
  var v = this;
  if (!arguments.length) return v._model.values();
  else if (dl.isString(data)) return streaming.call(v, data);
  else if (dl.isObject(data)) {
    dl.keys(data).forEach(function(k) {
      var api = streaming.call(v, k);
      data[k](api);
    });
  }
  return this;
};

prototype.signal = function(name, value) {
  var m  = this._model,
      cs = this._changeset,
      streamer = this._streamer,
      setter = name; 

  if (!arguments.length) {
    return m.values(Deps.SIGNALS);
  } else if (arguments.length == 1 && dl.isString(name)) {
    return m.values(Deps.SIGNALS, name);
  }

  if (arguments.length == 2) {
    setter = {};
    setter[name] = value;
  }

  dl.keys(setter).forEach(function(k) {
    streamer.addListener(m.signal(k).value(setter[k]));
    cs.signals[k] = 1;
    cs.reflow = true;
  });

  return this;
};

prototype.width = function(width) {
  if (!arguments.length) return this.__width;
  if (this.__width !== width) {
    this._width = this.__width = width;
    this.model().width(width);
    this.initialize();
    if (this._strict) this._autopad = 1;
  }
  return this;
};

prototype.height = function(height) {
  if (!arguments.length) return this.__height;
  if (this.__height !== height) {
    this._height = this.__height = height;
    this.model().height(height);
    this.initialize();
    if (this._strict) this._autopad = 1;
  }
  return this;
};

prototype.background = function(bgcolor) {
  if (!arguments.length) return this._bgcolor;
  if (this._bgcolor !== bgcolor) {
    this._bgcolor = bgcolor;
    this.initialize();
  }
  return this;
};

prototype.padding = function(pad) {
  if (!arguments.length) return this._padding;
  if (this._padding !== pad) {
    if (dl.isString(pad)) {
      this._autopad = 1;
      this._padding = {top:0, left:0, bottom:0, right:0};
      this._strict = (pad === 'strict');
    } else {
      this._autopad = 0;
      this._padding = pad;
      this._strict = false;
    }
    if (this._renderer) this._renderer.resize(this._width, this._height, pad);
    if (this._handler)  this._handler.padding(pad);
  }
  return (this._repaint = true, this);
};

prototype.autopad = function(opt) {
  if (this._autopad < 1) return this;
  else this._autopad = 0;

  var b = this.model().scene().bounds,
      pad = this._padding,
      config = this.model().config(),
      inset = config.autopadInset,
      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,
      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,
      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0;
  b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;
  pad = {left:l, top:t, right:r, bottom:b};

  if (this._strict) {
    this._autopad = 0;
    this._padding = pad;
    this._width = Math.max(0, this.__width - (l+r));
    this._height = Math.max(0, this.__height - (t+b));

    this._model.width(this._width)
      .height(this._height).reset();

    this.initialize()
      .update({props:'enter'}).update({props:'update'});
  } else {
    this.padding(pad).update(opt);
  }
  return this;
};

prototype.viewport = function(size) {
  if (!arguments.length) return this._viewport;
  if (this._viewport !== size) {
    this._viewport = size;
    this.initialize();
  }
  return this;
};

prototype.renderer = function(type) {
  if (!arguments.length) return this._renderer;
  if (this._renderers[type]) type = this._renderers[type];
  else if (dl.isString(type)) throw new Error('Unknown renderer: ' + type);
  else if (!type) throw new Error('No renderer specified');

  if (this._io !== type) {
    this._io = type;
    this._renderer = null;
    this.initialize();
    if (this._build) this.render();
  }
  return this;
};

prototype.initialize = function(el) {
  var v = this, prevHandler,
      w = v._width, h = v._height, pad = v._padding, bg = v._bgcolor,
      config = this.model().config();

  if (!arguments.length || el === null) {
    el = this._el ? this._el.parentNode : null;
    if (!el) return this;  // This View cannot init w/o an
  }

  // clear pre-existing container
  d3.select(el).select('div.vega').remove();
  
  // add div container
  this._el = el = d3.select(el)
    .append('div')
    .attr('class', 'vega')
    .style('position', 'relative')
    .node();
  if (v._viewport) {
    d3.select(el)
      .style('width',  (v._viewport[0] || w)+'px')
      .style('height', (v._viewport[1] || h)+'px')
      .style('overflow', 'auto');
  }

  // renderer
  sg.canvas.Renderer.RETINA = config.render.retina;
  v._renderer = (v._renderer || new this._io.Renderer(config.load))
    .initialize(el, w, h, pad)
    .background(bg);
  
  // input handler
  prevHandler = v._handler;
  v._handler = new this._io.Handler()
    .initialize(el, pad, v);

  if (prevHandler) {
    prevHandler.handlers().forEach(function(h) {
      v._handler.on(h.type, h.handler);
    });
  } else {
    // Register event listeners for signal stream definitions.
    v._detach = parseStreams(this);
  }
  
  return (this._repaint = true, this);
};

prototype.destroy = function() {
  if (this._detach) this._detach();
};

function build() {
  var v = this;
  v._renderNode = new df.Node(v._model)
    .router(true);

  v._renderNode.evaluate = function(input) {
    log.debug(input, ['rendering']);

    var s = v._model.scene(),
        h = v._handler;

    if (h && h.scene) h.scene(s);

    if (input.trans) {
      input.trans.start(function(items) { v._renderer.render(s, items); });
    } else if (v._repaint) {
      v._renderer.render(s);
      v._repaint = false;
    } else if (input.dirty.length) {
      v._renderer.render(s, input.dirty);
    }

    if (input.dirty.length) {
      input.dirty.forEach(function(i) { i._dirty = false; });
      s.items[0]._dirty = false;
    }

    // For all updated datasources, clear their previous values.
    for (var d in input.data) { v._model.data(d).synchronize(); }
    return input;
  };

  return (v._model.scene(v._renderNode), true);  
}

prototype.update = function(opt) {
  opt = opt || {};
  var v = this,
      trans = opt.duration ? new Transition(opt.duration, opt.ease) : null;

  var cs = v._changeset;
  if (trans) cs.trans = trans;
  if (opt.props !== undefined) {
    if (dl.keys(cs.data).length > 0) {
      throw Error(
        'New data values are not reflected in the visualization.' +
        ' Please call view.update() before updating a specified property set.'
      );
    }

    cs.reflow  = true;
    cs.request = opt.props;
  }

  var built = v._build;
  v._build = v._build || build.call(this);

  // If specific items are specified, short-circuit dataflow graph.
  // Else-If there are streaming updates, perform a targeted propagation.
  // Otherwise, reevaluate the entire model (datasources + scene).
  if (opt.items && built) { 
    Encoder.update(this._model, opt.trans, opt.props, opt.items, cs.dirty);
    v._renderNode.evaluate(cs);
  } else if (v._streamer.listeners().length && built) {
    v._model.propagate(cs, v._streamer);
    v._streamer.disconnect();
  } else {
    v._model.fire(cs);
  }

  v._changeset = df.ChangeSet.create();

  return v.autopad(opt);
};

prototype.toImageURL = function(type) {
  var v = this, Renderer;

  // lookup appropriate renderer
  switch (type || 'png') {
    case 'canvas':
    case 'png':
      Renderer = sg.canvas.Renderer; break;
    case 'svg':
      Renderer = sg.svg.string.Renderer; break;
    default: throw Error('Unrecognized renderer type: ' + type);
  }

  var retina = sg.canvas.Renderer.RETINA;
  sg.canvas.Renderer.RETINA = false; // ignore retina screen

  // render the scenegraph
  var ren = new Renderer(v._model.config.load)
    .initialize(null, v._width, v._height, v._padding)
    .render(v._model.scene());

  sg.canvas.Renderer.RETINA = retina; // restore retina settings

  // return data url
  if (type === 'svg') {
    var blob = new Blob([ren.svg()], {type: 'image/svg+xml'});
    return window.URL.createObjectURL(blob);
  } else {
    return ren.canvas().toDataURL('image/png');
  }
};

prototype.render = function(items) {
  this._renderer.render(this._model.scene(), items);
  return this;
};

prototype.on = function() {
  this._handler.on.apply(this._handler, arguments);
  return this;
};

prototype.onSignal = function(name, handler) {
  this._model.signal(name).on(handler);
  return this;
};

prototype.off = function() {
  this._handler.off.apply(this._handler, arguments);
  return this;
};

prototype.offSignal = function(name, handler) {
  this._model.signal(name).off(handler);
  return this;
};

View.factory = function(model) {
  var HeadlessView = require('./HeadlessView');
  return function(opt) {
    opt = opt || {};
    var defs = model.defs();
    var v = (opt.el ? new View() : new HeadlessView())
      .model(model)
      .renderer(opt.renderer || 'canvas')
      .width(defs.width)
      .height(defs.height)
      .background(defs.background)
      .padding(defs.padding)
      .viewport(defs.viewport)
      .initialize(opt.el);

    if (opt.data) v.data(opt.data);

    if (opt.hover !== false && opt.el) {
      v.on('mouseover', function(evt, item) {
        if (item && item.hasPropertySet('hover')) {
          this.update({props:'hover', items:item});
        }
      })
      .on('mouseout', function(evt, item) {
        if (item && item.hasPropertySet('hover')) {
          this.update({props:'update', items:item});
        }
      });
    }
  
    return v;
  };    
};

module.exports = View;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../parse/streams":110,"../scene/Encoder":114,"../scene/Transition":117,"./HeadlessView":90,"datalib":24,"vega-dataflow":43,"vega-logging":49,"vega-scenegraph":50}],93:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    config = {};

config.load = {
  // base url for loading external data files
  // used only for server-side operation
  baseURL: '',
  // Allows domain restriction when using data loading via XHR.
  // To enable, set it to a list of allowed domains
  // e.g., ['wikipedia.org', 'eff.org']
  domainWhiteList: false
};

// inset padding for automatic padding calculation
config.autopadInset = 5;

// extensible scale lookup table
// all d3.scale.* instances also supported
config.scale = {
  time: d3.time.scale,
  utc:  d3.time.scale.utc
};

// default rendering settings
config.render = {
  retina: true
};

// default axis properties
config.axis = {
  orient: 'bottom',
  ticks: 10,
  padding: 3,
  axisColor: '#000',
  gridColor: '#000',
  gridOpacity: 0.15,
  tickColor: '#000',
  tickLabelColor: '#000',
  axisWidth: 1,
  tickWidth: 1,
  tickSize: 6,
  tickLabelFontSize: 11,
  tickLabelFont: 'sans-serif',
  titleColor: '#000',
  titleFont: 'sans-serif',
  titleFontSize: 11,
  titleFontWeight: 'bold',
  titleOffset: 35
};

// default legend properties
config.legend = {
  orient: 'right',
  offset: 20,
  padding: 3,
  gradientStrokeColor: '#888',
  gradientStrokeWidth: 1,
  gradientHeight: 16,
  gradientWidth: 100,
  labelColor: '#000',
  labelFontSize: 10,
  labelFont: 'sans-serif',
  labelAlign: 'left',
  labelBaseline: 'middle',
  labelOffset: 8,
  symbolShape: 'circle',
  symbolSize: 50,
  symbolColor: '#888',
  symbolStrokeWidth: 1,
  titleColor: '#000',
  titleFont: 'sans-serif',
  titleFontSize: 11,
  titleFontWeight: 'bold'
};

// default color values
config.color = {
  rgb: [128, 128, 128],
  lab: [50, 0, 0],
  hcl: [0, 0, 50],
  hsl: [0, 0, 0.5]
};

// default scale ranges
config.range = {
  category10:  d3.scale.category10().range(),
  category20:  d3.scale.category20().range(),
  category20b: d3.scale.category20b().range(),
  category20c: d3.scale.category20c().range(),
  shapes: [
    'circle',
    'cross',
    'diamond',
    'square',
    'triangle-down',
    'triangle-up'
  ]
};

module.exports = config;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],94:[function(require,module,exports){
var dl = require('datalib'),
    parse = require('../parse'),
    Scale = require('../scene/Scale'),
    config = require('./config');

function compile(module, opt, schema) {
  var s = module.schema;
  if (!s) return;
  if (s.refs) dl.extend(schema.refs, s.refs);
  if (s.defs) dl.extend(schema.defs, s.defs);
}

module.exports = function(opt) {
  var schema = null;
  opt = opt || {};

  // Compile if we're not loading the schema from a URL. 
  // Load from a URL to extend the existing base schema.
  if (opt.url) {
    schema = dl.json(dl.extend({url: opt.url}, config.load));
  } else {
    schema = {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "title": "Vega Visualization Specification Language",
      "defs": {}, 
      "refs": {}, 
      "$ref": "#/defs/spec"
    };

    dl.keys(parse).forEach(function(k) { compile(parse[k], opt, schema); });

    // Scales aren't in the parser, add schema manually
    compile(Scale, opt, schema);
  }

  // Extend schema to support custom mark properties or property sets.
  if (opt.properties) dl.keys(opt.properties).forEach(function(k) {
    schema.defs.propset.properties[k] = {"$ref": "#/refs/"+opt.properties[k]+"Value"};
  });

  if (opt.propertySets) dl.keys(opt.propertySets).forEach(function(k) {
    schema.defs.mark.properties.properties.properties[k] = {"$ref": "#/defs/propset"};
  });

  return schema;
};
},{"../parse":100,"../scene/Scale":116,"./config":93,"datalib":24}],95:[function(require,module,exports){
var dl = require('datalib'),
    axs = require('../scene/axis');

var ORIENT = {
  "x":      "bottom",
  "y":      "left",
  "top":    "top",
  "bottom": "bottom",
  "left":   "left",
  "right":  "right"
};

function parseAxes(model, spec, axes, group) {
  var config = model.config();
  (spec || []).forEach(function(def, index) {
    axes[index] = axes[index] || axs(model);
    parseAxis(config, def, index, axes[index], group);
  });
}

function parseAxis(config, def, index, axis, group) {
  // axis scale
  if (def.scale !== undefined) {
    axis.scale(group.scale(def.scale));
  }

  // axis orientation
  axis.orient(def.orient || ORIENT[def.type]);
  // axis offset
  axis.offset(def.offset || 0);
  // axis layer
  axis.layer(def.layer || "front");
  // axis grid lines
  axis.grid(def.grid || false);
  // axis title
  axis.title(def.title || null);
  // axis title offset
  axis.titleOffset(def.titleOffset != null ?
    def.titleOffset : config.axis.titleOffset);
  // axis values
  axis.tickValues(def.values || null);
  // axis label formatting
  axis.tickFormat(def.format || null);
  axis.tickFormatType(def.formatType || null);
  // axis tick subdivision
  axis.tickSubdivide(def.subdivide || 0);
  // axis tick padding
  axis.tickPadding(def.tickPadding || config.axis.padding);

  // axis tick size(s)
  var size = [];
  if (def.tickSize !== undefined) {
    for (var i=0; i<3; ++i) size.push(def.tickSize);
  } else {
    var ts = config.axis.tickSize;
    size = [ts, ts, ts];
  }
  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;
  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;
  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;
  if (size.length) {
    axis.tickSize.apply(axis, size);
  }

  // axis tick count
  axis.tickCount(def.ticks || config.axis.ticks);

  // style properties
  var p = def.properties;
  if (p && p.ticks) {
    axis.majorTickProperties(p.majorTicks ?
      dl.extend({}, p.ticks, p.majorTicks) : p.ticks);
    axis.minorTickProperties(p.minorTicks ?
      dl.extend({}, p.ticks, p.minorTicks) : p.ticks);
  } else {
    axis.majorTickProperties(p && p.majorTicks || {});
    axis.minorTickProperties(p && p.minorTicks || {});
  }
  axis.tickLabelProperties(p && p.labels || {});
  axis.titleProperties(p && p.title || {});
  axis.gridLineProperties(p && p.grid || {});
  axis.domainProperties(p && p.axis || {});
}

module.exports = parseAxes;
},{"../scene/axis":118,"datalib":24}],96:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null);

function parseBg(bg) {
  // return null if input is null or undefined
  if (bg == null) return null;
  // run through d3 rgb to sanity check
  return d3.rgb(bg) + "";  
}

module.exports = parseBg;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],97:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    parseTransforms = require('./transforms'),
    parseModify = require('./modify');

function parseData(model, spec, callback) {
  var config = model.config(),
      count = 0;

  function loaded(d) {
    return function(error, data) {
      if (error) {
        log.error('LOADING FAILED: ' + d.url + ' ' + error);
      } else {
        model.data(d.name).values(dl.read(data, d.format));
      }
      if (--count === 0) callback();
    };
  }

  // process each data set definition
  (spec || []).forEach(function(d) {
    if (d.url) {
      count += 1;
      dl.load(dl.extend({url: d.url}, config.load), loaded(d));
    }
    parseData.datasource(model, d);
  });

  if (count === 0) setTimeout(callback, 1);
  return spec;
}

parseData.datasource = function(model, d) {
  var transform = (d.transform || []).map(function(t) {
        return parseTransforms(model, t); 
      }),
      mod = (d.modify || []).map(function(m) {
        return parseModify(model, m, d);
      }),
      ds = model.data(d.name, mod.concat(transform));

  if (d.values) {
    ds.values(dl.read(d.values, d.format));
  } else if (d.source) {
    // Derived ds will be pulsed by its src rather than the model.
    ds.source(d.source).addListener(ds);  
    model.removeListener(ds.pipeline()[0]); 
  }

  return ds;    
};

module.exports = parseData;
},{"./modify":104,"./transforms":111,"datalib":24,"vega-logging":49}],98:[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = ",",
        peg$c2 = { type: "literal", value: ",", description: "\",\"" },
        peg$c3 = function(o, m) { return [o].concat(m); },
        peg$c4 = function(o) { return [o]; },
        peg$c5 = "[",
        peg$c6 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c7 = "]",
        peg$c8 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c9 = ">",
        peg$c10 = { type: "literal", value: ">", description: "\">\"" },
        peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}; },
        peg$c12 = [],
        peg$c13 = function(s, f) { return (s.filters = f, s); },
        peg$c14 = function(s) { return s; },
        peg$c15 = "(",
        peg$c16 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c17 = ")",
        peg$c18 = { type: "literal", value: ")", description: "\")\"" },
        peg$c19 = function(m) { return {stream: m}; },
        peg$c20 = "@",
        peg$c21 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(n, e) { return {event: e, name: n}; },
        peg$c25 = function(m, e) { return {event: e, mark: m}; },
        peg$c26 = function(t, e) { return {event: e, target: t}; },
        peg$c27 = function(e) { return {event: e}; },
        peg$c28 = function(s) { return {signal: s}; },
        peg$c29 = "rect",
        peg$c30 = { type: "literal", value: "rect", description: "\"rect\"" },
        peg$c31 = "symbol",
        peg$c32 = { type: "literal", value: "symbol", description: "\"symbol\"" },
        peg$c33 = "path",
        peg$c34 = { type: "literal", value: "path", description: "\"path\"" },
        peg$c35 = "arc",
        peg$c36 = { type: "literal", value: "arc", description: "\"arc\"" },
        peg$c37 = "area",
        peg$c38 = { type: "literal", value: "area", description: "\"area\"" },
        peg$c39 = "line",
        peg$c40 = { type: "literal", value: "line", description: "\"line\"" },
        peg$c41 = "rule",
        peg$c42 = { type: "literal", value: "rule", description: "\"rule\"" },
        peg$c43 = "image",
        peg$c44 = { type: "literal", value: "image", description: "\"image\"" },
        peg$c45 = "text",
        peg$c46 = { type: "literal", value: "text", description: "\"text\"" },
        peg$c47 = "group",
        peg$c48 = { type: "literal", value: "group", description: "\"group\"" },
        peg$c49 = "mousedown",
        peg$c50 = { type: "literal", value: "mousedown", description: "\"mousedown\"" },
        peg$c51 = "mouseup",
        peg$c52 = { type: "literal", value: "mouseup", description: "\"mouseup\"" },
        peg$c53 = "click",
        peg$c54 = { type: "literal", value: "click", description: "\"click\"" },
        peg$c55 = "dblclick",
        peg$c56 = { type: "literal", value: "dblclick", description: "\"dblclick\"" },
        peg$c57 = "wheel",
        peg$c58 = { type: "literal", value: "wheel", description: "\"wheel\"" },
        peg$c59 = "keydown",
        peg$c60 = { type: "literal", value: "keydown", description: "\"keydown\"" },
        peg$c61 = "keypress",
        peg$c62 = { type: "literal", value: "keypress", description: "\"keypress\"" },
        peg$c63 = "keyup",
        peg$c64 = { type: "literal", value: "keyup", description: "\"keyup\"" },
        peg$c65 = "mousewheel",
        peg$c66 = { type: "literal", value: "mousewheel", description: "\"mousewheel\"" },
        peg$c67 = "mousemove",
        peg$c68 = { type: "literal", value: "mousemove", description: "\"mousemove\"" },
        peg$c69 = "mouseout",
        peg$c70 = { type: "literal", value: "mouseout", description: "\"mouseout\"" },
        peg$c71 = "mouseover",
        peg$c72 = { type: "literal", value: "mouseover", description: "\"mouseover\"" },
        peg$c73 = "mouseenter",
        peg$c74 = { type: "literal", value: "mouseenter", description: "\"mouseenter\"" },
        peg$c75 = "touchstart",
        peg$c76 = { type: "literal", value: "touchstart", description: "\"touchstart\"" },
        peg$c77 = "touchmove",
        peg$c78 = { type: "literal", value: "touchmove", description: "\"touchmove\"" },
        peg$c79 = "touchend",
        peg$c80 = { type: "literal", value: "touchend", description: "\"touchend\"" },
        peg$c81 = function(e) { return e; },
        peg$c82 = /^[a-zA-Z0-9_\-]/,
        peg$c83 = { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
        peg$c84 = function(n) { return n.join(""); },
        peg$c85 = /^[a-zA-Z0-9\-_  #.>+~[\]=|\^$*]/,
        peg$c86 = { type: "class", value: "[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]", description: "[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]" },
        peg$c87 = function(c) { return c.join(""); },
        peg$c88 = /^['"a-zA-Z0-9_().><=! \t-&|~]/,
        peg$c89 = { type: "class", value: "['\"a-zA-Z0-9_().><=! \\t-&|~]", description: "['\"a-zA-Z0-9_().><=! \\t-&|~]" },
        peg$c90 = function(v) { return v.join(""); },
        peg$c91 = /^[ \t\r\n]/,
        peg$c92 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemerged();

      return s0;
    }

    function peg$parsemerged() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseordered();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesep();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c1;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c2); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsesep();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemerged();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c3(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseordered();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c4(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseordered() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesep();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefiltered();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsesep();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c2); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsesep();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsefiltered();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesep();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s9 = peg$c7;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c8); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesep();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 62) {
                            s11 = peg$c9;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c10); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parsesep();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseordered();
                              if (s13 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c11(s3, s7, s13);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsefiltered();
      }

      return s0;
    }

    function peg$parsefiltered() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsestream();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsefilter();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsefilter();
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c13(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsestream();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c14(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsestream() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemerged();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c19(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s1 = peg$c20;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s3 = peg$c22;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseeventType();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c24(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemarkType();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c22;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseeventType();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c25(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecss();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c22;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c23); }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseeventType();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseeventType();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c27(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsename();
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c28(s1);
                }
                s0 = s1;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsemarkType() {
      var s0;

      if (input.substr(peg$currPos, 4) === peg$c29) {
        s0 = peg$c29;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c31) {
          s0 = peg$c31;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s0 = peg$c33;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c35) {
              s0 = peg$c35;
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c37) {
                s0 = peg$c37;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c39) {
                  s0 = peg$c39;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c40); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c41) {
                    s0 = peg$c41;
                    peg$currPos += 4;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c42); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c43) {
                      s0 = peg$c43;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c44); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c45) {
                        s0 = peg$c45;
                        peg$currPos += 4;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c46); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c47) {
                          s0 = peg$c47;
                          peg$currPos += 5;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c48); }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseeventType() {
      var s0;

      if (input.substr(peg$currPos, 9) === peg$c49) {
        s0 = peg$c49;
        peg$currPos += 9;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c51) {
          s0 = peg$c51;
          peg$currPos += 7;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c53) {
            s0 = peg$c53;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c54); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c55) {
              s0 = peg$c55;
              peg$currPos += 8;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c57) {
                s0 = peg$c57;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c58); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c59) {
                  s0 = peg$c59;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c60); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c61) {
                    s0 = peg$c61;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c62); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c63) {
                      s0 = peg$c63;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c64); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 10) === peg$c65) {
                        s0 = peg$c65;
                        peg$currPos += 10;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c66); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c67) {
                          s0 = peg$c67;
                          peg$currPos += 9;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c68); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c69) {
                            s0 = peg$c69;
                            peg$currPos += 8;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c70); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c71) {
                              s0 = peg$c71;
                              peg$currPos += 9;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c72); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 10) === peg$c73) {
                                s0 = peg$c73;
                                peg$currPos += 10;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c74); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 10) === peg$c75) {
                                  s0 = peg$c75;
                                  peg$currPos += 10;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c76); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 9) === peg$c77) {
                                    s0 = peg$c77;
                                    peg$currPos += 9;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c78); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c79) {
                                      s0 = peg$c79;
                                      peg$currPos += 8;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c80); }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsefilter() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpr();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c81(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsename() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c82.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c82.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c83); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c84(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsecss() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c85.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c86); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c87(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseexpr() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c88.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c88.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c89); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c90(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsesep() {
      var s0, s1;

      s0 = [];
      if (peg$c91.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c91.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
},{}],99:[function(require,module,exports){
var expr = require('vega-expression'),
    args = ['datum', 'event', 'signals'];

module.exports = expr.compiler(args, {
  idWhiteList: args,
  fieldVar:    args[0],
  globalVar:   args[2],
  functions:   function(codegen) {
    var fn = expr.functions(codegen);
    fn.eventItem = function() { return 'event.vg.item'; };
    fn.eventGroup = 'event.vg.getGroup';
    fn.eventX = 'event.vg.getX';
    fn.eventY = 'event.vg.getY';
    fn.open = 'window.open';
    return fn;
  }
});
},{"vega-expression":47}],100:[function(require,module,exports){
module.exports = {
  axes: require('./axes'),
  background: require('./background'),
  data: require('./data'),
  events: require('./events'),
  expr: require('./expr'),
  legends: require('./legends'),
  mark: require('./mark'),
  marks: require('./marks'),
  modify: require('./modify'),
  padding: require('./padding'),
  predicates: require('./predicates'),
  properties: require('./properties'),
  signals: require('./signals'),
  spec: require('./spec'),
  streams: require('./streams'),
  transforms: require('./transforms')
};
},{"./axes":95,"./background":96,"./data":97,"./events":98,"./expr":99,"./legends":101,"./mark":102,"./marks":103,"./modify":104,"./padding":105,"./predicates":106,"./properties":107,"./signals":108,"./spec":109,"./streams":110,"./transforms":111}],101:[function(require,module,exports){
var lgnd = require('../scene/legend');

function parseLegends(model, spec, legends, group) {
  (spec || []).forEach(function(def, index) {
    legends[index] = legends[index] || lgnd(model);
    parseLegend(def, index, legends[index], group);
  });
}

function parseLegend(def, index, legend, group) {
  // legend scales
  legend.size  (def.size   ? group.scale(def.size)   : null);
  legend.shape (def.shape  ? group.scale(def.shape)  : null);
  legend.fill  (def.fill   ? group.scale(def.fill)   : null);
  legend.stroke(def.stroke ? group.scale(def.stroke) : null);

  // legend orientation
  if (def.orient) legend.orient(def.orient);

  // legend offset
  if (def.offset != null) legend.offset(def.offset);

  // legend title
  legend.title(def.title || null);

  // legend values
  legend.values(def.values || null);

  // legend label formatting
  legend.format(def.format !== undefined ? def.format : null);

  // style properties
  var p = def.properties;
  legend.titleProperties(p && p.title || {});
  legend.labelProperties(p && p.labels || {});
  legend.legendProperties(p && p.legend || {});
  legend.symbolProperties(p && p.symbols || {});
  legend.gradientProperties(p && p.gradient || {});
}

module.exports = parseLegends;
},{"../scene/legend":119}],102:[function(require,module,exports){
var dl = require('datalib'),
    parseProperties = require('./properties');

function parseMark(model, mark) {
  var props = mark.properties,
      group = mark.marks;

  // parse mark property definitions
  dl.keys(props).forEach(function(k) {
    props[k] = parseProperties(model, mark.type, props[k]);
  });

  // parse delay function
  if (mark.delay) {
    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});
  }

  // recurse if group type
  if (group) {
    mark.marks = group.map(function(g) { return parseMark(model, g); });
  }
    
  return mark;
}

module.exports = parseMark;
},{"./properties":107,"datalib":24}],103:[function(require,module,exports){
var parseMark = require('./mark');

function parseRootMark(model, spec, width, height) {
  return {
    type: "group",
    width: width,
    height: height,
    scales: spec.scales || [],
    axes: spec.axes || [],
    legends: spec.legends || [],
    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })
  };
}

module.exports = parseRootMark;
},{"./mark":102}],104:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Tuple = df.Tuple,
    Deps = df.Dependencies;

var Types = {
  INSERT: "insert",
  REMOVE: "remove",
  TOGGLE: "toggle",
  CLEAR:  "clear"
};

var EMPTY = [];

var filter = function(field, value, src, dest) {
  for(var i = src.length-1; i >= 0; --i) {
    if (src[i][field] == value)
      dest.push.apply(dest, src.splice(i, 1));
  }
};

function parseModify(model, def, ds) {
  var signal = def.signal ? dl.field(def.signal) : null, 
      signalName = signal ? signal[0] : null,
      predicate = def.predicate ? model.predicate(def.predicate.name || def.predicate) : null,
      reeval = (predicate === null),
      node = new Node(model).router(def.type === Types.CLEAR);

  node.evaluate = function(input) {
    if (predicate !== null) {  // TODO: predicate args
      var db = model.values(Deps.DATA, predicate.data || EMPTY),
          sg = model.values(Deps.SIGNALS, predicate.signals || EMPTY);
      reeval = predicate.call(predicate, {}, db, sg, model._predicates);
    }

    log.debug(input, [def.type+"ing", reeval]);
    if (!reeval) return input;

    var datum = {}, 
        value = signal ? model.signalRef(def.signal) : null,
        d = model.data(ds.name),
        t = null;

    datum[def.field] = value;

    // We have to modify ds._data so that subsequent pulses contain
    // our dynamic data. W/o modifying ds._data, only the output
    // collector will contain dynamic tuples. 
    if (def.type === Types.INSERT) {
      t = Tuple.ingest(datum);
      input.add.push(t);
      d._data.push(t);
    } else if (def.type === Types.REMOVE) {
      filter(def.field, value, input.add, input.rem);
      filter(def.field, value, input.mod, input.rem);
      d._data = d._data.filter(function(x) { return x[def.field] !== value; });
    } else if (def.type === Types.TOGGLE) {
      var add = [], rem = [];
      filter(def.field, value, input.rem, add);
      filter(def.field, value, input.add, rem);
      filter(def.field, value, input.mod, rem);
      if (!(add.length || rem.length)) add.push(Tuple.ingest(datum));

      input.add.push.apply(input.add, add);
      d._data.push.apply(d._data, add);
      input.rem.push.apply(input.rem, rem);
      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1; });
    } else if (def.type === Types.CLEAR) {
      input.rem.push.apply(input.rem, input.add);
      input.rem.push.apply(input.rem, input.mod);
      input.add = [];
      input.mod = [];
      d._data  = [];
    } 

    input.fields[def.field] = 1;
    return input;
  };

  if (signalName) node.dependency(Deps.SIGNALS, signalName);
  
  if (predicate) {
    node.dependency(Deps.DATA, predicate.data);
    node.dependency(Deps.SIGNALS, predicate.signals);
  }
  
  return node;
}

module.exports = parseModify;
},{"datalib":24,"vega-dataflow":43,"vega-logging":49}],105:[function(require,module,exports){
var dl = require('datalib');

function parsePadding(pad) {
  if (pad == null) return "auto";
  else if (dl.isString(pad)) return pad==="strict" ? "strict" : "auto";
  else if (dl.isObject(pad)) return pad;
  var p = dl.isNumber(pad) ? pad : 20;
  return {top:p, left:p, right:p, bottom:p};
}

module.exports = parsePadding;
},{"datalib":24}],106:[function(require,module,exports){
var dl = require('datalib');

var types = {
  '=':   parseComparator,
  '==':  parseComparator,
  '!=':  parseComparator,
  '>':   parseComparator,
  '>=':  parseComparator,
  '<':   parseComparator,
  '<=':  parseComparator,
  'and': parseLogical,
  '&&':  parseLogical,
  'or':  parseLogical,
  '||':  parseLogical,
  'in':  parseIn
};

var nullScale = function() { return 0; };
nullScale.invert = nullScale;

function parsePredicates(model, spec) {
  (spec || []).forEach(function(s) {
    var parse = types[s.type](model, s);
    
    /* jshint evil:true */
    var pred  = Function("args", "db", "signals", "predicates", parse.code);
    pred.root = function() { return model.scene().items[0]; }; // For global scales
    pred.nullScale = nullScale;
    pred.isFunction = dl.isFunction;
    pred.signals = parse.signals;
    pred.data = parse.data;

    model.predicate(s.name, pred);
  });

  return spec;
}

function parseSignal(signal, signals) {
  var s = dl.field(signal),
      code = "signals["+s.map(dl.str).join("][")+"]";
  signals[s[0]] = 1;
  return code;
}

function parseOperands(model, operands) {
  var decl = [], defs = [],
      signals = {}, db = {};

  function setSignal(s) { signals[s] = 1; }
  function setData(d) { db[d] = 1; }

  dl.array(operands).forEach(function(o, i) {
    var name = "o" + i,
        def = "";

    if (o.value !== undefined) {
      def = dl.str(o.value);
    } else if (o.arg) {
      def = "args["+dl.str(o.arg)+"]";
    } else if (o.signal) {
      def = parseSignal(o.signal, signals);
    } else if (o.predicate) {
      var ref = o.predicate,
          predName = ref && (ref.name || ref),
          pred = model.predicate(predName),
          p = "predicates["+dl.str(predName)+"]";

      pred.signals.forEach(setSignal);
      pred.data.forEach(setData);

      if (dl.isObject(ref)) {
        dl.keys(ref).forEach(function(k) {
          if (k === "name") return;
          var i = ref[k];
          def += "args["+dl.str(k)+"] = ";
          if (i.signal) {
            def += parseSignal(i.signal, signals);
          } else if (i.arg) {
            def += "args["+dl.str(i.arg)+"]";
          }
          def += ", ";
        });  
      } 

      def += p+".call("+p+", args, db, signals, predicates)";
    }

    decl.push(name);
    defs.push(name+"=("+def+")");
  });

  return {
    code: "var " + decl.join(", ") + ";\n" + defs.join(";\n") + ";\n",
    signals: dl.keys(signals),
    data: dl.keys(db)
  };
}

function parseComparator(model, spec) {
  var ops = parseOperands(model, spec.operands);
  if (spec.type === '=') spec.type = '==';

  ops.code += "o0 = o0 instanceof Date ? o0.getTime() : o0;\n" +
    "o1 = o1 instanceof Date ? o1.getTime() : o1;\n";

  return {
    code: ops.code + "return " + ["o0", "o1"].join(spec.type) + ";",
    signals: ops.signals,
    data: ops.data
  };
}

function parseLogical(model, spec) {
  var ops = parseOperands(model, spec.operands),
      o = [], i = 0, len = spec.operands.length;

  while (o.push("o"+i++) < len);
  if (spec.type === 'and') spec.type = '&&';
  else if (spec.type === 'or') spec.type = '||';

  return {
    code: ops.code + "return " + o.join(spec.type) + ";",
    signals: ops.signals,
    data: ops.data
  };
}

function parseIn(model, spec) {
  var o = [spec.item], code = "";
  if (spec.range) o.push.apply(o, spec.range);
  if (spec.scale) {
    code = parseScale(spec.scale, o);
  }

  var ops = parseOperands(model, o);
  code = ops.code + code + "\n  var ordSet = null;\n";

  if (spec.data) {
    var field = dl.field(spec.field).map(dl.str);
    code += "var where = function(d) { return d["+field.join("][")+"] == o0 };\n";
    code += "return db["+dl.str(spec.data)+"].filter(where).length > 0;";
  } else if (spec.range) {
    // TODO: inclusive/exclusive range?
    if (spec.scale) {
      code += "if (scale.length == 2) {\n" + // inverting ordinal scales
        "  ordSet = scale(o1, o2);\n" +
        "} else {\n" +
        "  o1 = scale(o1);\no2 = scale(o2);\n" +
        "}";
    }

    code += "return ordSet !== null ? ordSet.indexOf(o0) !== -1 :\n" + 
      "  o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1;";
  }

  return {
    code: code, 
    signals: ops.signals, 
    data: ops.data.concat(spec.data ? [spec.data] : [])
  };
}

// Populate ops such that ultimate scale/inversion function will be in `scale` var. 
function parseScale(spec, ops) {
  var code = "var scale = ", 
      idx  = ops.length;

  if (dl.isString(spec)) {
    ops.push({ value: spec });
    code += "this.root().scale(o"+idx+")";
  } else if (spec.arg) {  // Scale function is being passed as an arg
    ops.push(spec);
    code += "o"+idx;
  } else if (spec.name) { // Full scale parameter {name: ..}
    ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);
    code += "(this.isFunction(o"+idx+") ? o"+idx+" : ";
    if (spec.scope) {
      ops.push(spec.scope);
      code += "((o"+(idx+1)+".scale || this.root().scale)(o"+idx+") || this.nullScale)";
    } else {
      code += "this.root().scale(o"+idx+")";
    }
    code += ")";
  }

  if (spec.invert === true) {  // Allow spec.invert.arg?
    code += ".invert";
  }

  return code+";\n";
}

module.exports = parsePredicates;
},{"datalib":24}],107:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    log = require('vega-logging'),
    Tuple = require('vega-dataflow').Tuple;

var DEPS = ["signals", "scales", "data", "fields"];

function properties(model, mark, spec) {
  var config = model.config(),
      code = "",
      names = dl.keys(spec),
      i, len, name, ref, vars = {}, 
      deps = {
        signals: {},
        scales:  {},
        data:    {},
        fields:  {},
        nested:  [],
        _nRefs:  {},  // Temp stash to de-dupe nested refs.
        reflow:  false
      };
      
  code += "var o = trans ? {} : item, d=0, set=this.tpl.set, tmpl=signals||{}, t;\n" +
          // Stash for dl.template
          "tmpl.datum  = item.datum;\n" + 
          "tmpl.group  = group;\n" + 
          "tmpl.parent = group.datum;\n";

  function handleDep(p) {
    if (ref[p] == null) return;
    var k = dl.array(ref[p]), i, n;
    for (i=0, n=k.length; i<n; ++i) {
      deps[p][k[i]] = 1;
    }
  }

  function handleNestedRefs(r) {
    var k = (r.parent ? "parent_" : "group_")+r.level;
    deps._nRefs[k] = r;
  }

  for (i=0, len=names.length; i<len; ++i) {
    ref = spec[name = names[i]];
    code += (i > 0) ? "\n  " : "  ";
    if (ref.rule) {
      ref = rule(model, name, ref.rule);
      code += "\n  " + ref.code;
    } else {
      ref = valueRef(config, name, ref);
      code += "d += set(o, "+dl.str(name)+", "+ref.val+");";
    }

    vars[name] = true;
    DEPS.forEach(handleDep);
    deps.reflow = deps.reflow || ref.reflow;
    if (ref.nested.length) ref.nested.forEach(handleNestedRefs);
  }

  // If nested references are present, sort them based on their level
  // to speed up determination of whether encoders should be reeval'd.
  dl.keys(deps._nRefs).forEach(function(k) { deps.nested.push(deps._nRefs[k]); });
  deps.nested.sort(function(a, b) { 
    a = a.level;
    b = b.level;
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; 
  });

  if (vars.x2) {
    if (vars.x) {
      code += "\n  if (o.x > o.x2) { " +
              "\n    t = o.x;" +
              "\n    d += set(o, 'x', o.x2);" +
              "\n    d += set(o, 'x2', t); " +
              "\n  };";
      code += "\n  d += set(o, 'width', (o.x2 - o.x));";
    } else if (vars.width) {
      code += "\n  d += set(o, 'x', (o.x2 - o.width));";
    } else {
      code += "\n  d += set(o, 'x', o.x2);";
    }
  }

  if (vars.xc) {
    if (vars.width) {
      code += "\n  d += set(o, 'x', (o.xc - o.width/2));" ;
    } else {
      code += "\n  d += set(o, 'x', o.xc);" ;
    }
  }

  if (vars.y2) {
    if (vars.y) {
      code += "\n  if (o.y > o.y2) { " +
              "\n    t = o.y;" +
              "\n    d += set(o, 'y', o.y2);" +
              "\n    d += set(o, 'y2', t);" +
              "\n  };";
      code += "\n  d += set(o, 'height', (o.y2 - o.y));";
    } else if (vars.height) {
      code += "\n  d += set(o, 'y', (o.y2 - o.height));";
    } else {
      code += "\n  d += set(o, 'y', o.y2);";
    }
  }

  if (vars.yc) {
    if (vars.height) {
      code += "\n  d += set(o, 'y', (o.yc - o.height/2));" ;
    } else {
      code += "\n  d += set(o, 'y', o.yc);" ;
    }
  }
  
  if (hasPath(mark, vars)) code += "\n  d += (item.touch(), 1);";
  code += "\n  if (trans) trans.interpolate(item, o);";
  code += "\n  return d > 0;";

  try {
    /* jshint evil:true */
    var encoder = Function('item', 'group', 'trans', 'db', 
      'signals', 'predicates', code);
    encoder.tpl  = Tuple;
    encoder.util = dl;
    encoder.d3   = d3; // For color spaces
    dl.extend(encoder, dl.template.context);
    return {
      encode:  encoder,
      signals: dl.keys(deps.signals),
      scales:  dl.keys(deps.scales),
      data:    dl.keys(deps.data),
      fields:  dl.keys(deps.fields),
      nested:  deps.nested,
      reflow:  deps.reflow
    };
  } catch (e) {
    log.error(e);
    log.log(code);
  }
}

function dependencies(a, b) {
  if (!dl.isObject(a)) {
    a = {reflow: false, nested: []};
    DEPS.forEach(function(d) { a[d] = []; });
  }

  if (dl.isObject(b)) {
    a.reflow = a.reflow || b.reflow;
    a.nested.push.apply(a.nested, b.nested);
    DEPS.forEach(function(d) { a[d].push.apply(a[d], b[d]); });
  }

  return a;
}

function hasPath(mark, vars) {
  return vars.path ||
    ((mark==='area' || mark==='line') &&
      (vars.x || vars.x2 || vars.width ||
       vars.y || vars.y2 || vars.height ||
       vars.tension || vars.interpolate));
}

function rule(model, name, rules) {
  var config  = model.config(),
      deps = dependencies(),
      inputs  = [], code = '';

  (rules||[]).forEach(function(r, i) {
    var def = r.predicate,
        predName = def && (def.name || def),
        pred = model.predicate(predName),
        p = 'predicates['+dl.str(predName)+']',
        input = [], args = name+'_arg'+i,
        ref;

    if (dl.isObject(def)) {
      dl.keys(def).forEach(function(k) {
        if (k === 'name') return;
        var ref = valueRef(config, i, def[k]);
        input.push(dl.str(k)+': '+ref.val);
        dependencies(deps, ref);
      });
    }

    ref = valueRef(config, name, r);
    dependencies(deps, ref);

    if (predName) {
      deps.signals.push.apply(deps.signals, pred.signals);
      deps.data.push.apply(deps.data, pred.data);
      inputs.push(args+" = {\n    "+input.join(",\n    ")+"\n  }");
      code += "if ("+p+".call("+p+","+args+", db, signals, predicates)) {" +
        "\n    d += set(o, "+dl.str(name)+", "+ref.val+");";
      code += rules[i+1] ? "\n  } else " : "  }";
    } else {
      code += "{" + 
        "\n    d += set(o, "+dl.str(name)+", "+ref.val+");"+
        "\n  }\n";
    }
  });

  code = "var " + inputs.join(",\n      ") + ";\n  " + code;
  return (deps.code = code, deps);
}

function valueRef(config, name, ref) {
  if (ref == null) return null;

  if (name==='fill' || name==='stroke') {
    if (ref.c) {
      return colorRef(config, 'hcl', ref.h, ref.c, ref.l);
    } else if (ref.h || ref.s) {
      return colorRef(config, 'hsl', ref.h, ref.s, ref.l);
    } else if (ref.l || ref.a) {
      return colorRef(config, 'lab', ref.l, ref.a, ref.b);
    } else if (ref.r || ref.g || ref.b) {
      return colorRef(config, 'rgb', ref.r, ref.g, ref.b);
    }
  }

  // initialize value
  var val = null, scale = null, 
      deps = dependencies(),
      sgRef = null, fRef = null, sRef = null, tmpl = {};

  if (ref.template !== undefined) {
    val = dl.template.source(ref.template, 'tmpl', tmpl);
    dl.keys(tmpl).forEach(function(k) {
      var f = dl.field(k),
          a = f.shift();
      if (a === 'parent' || a === 'group') {
        deps.nested.push({ 
          parent: a === 'parent',
          group:  a === 'group', 
          level:  1
        });
      } else if (a === 'datum') {
        deps.fields.push(f[0]);
      } else {
        deps.signals.push(a);
      }
    });
  }

  if (ref.value !== undefined) {
    val = dl.str(ref.value);
  }

  if (ref.signal !== undefined) {
    sgRef = dl.field(ref.signal);
    val = 'signals['+sgRef.map(dl.str).join('][')+']'; 
    deps.signals.push(sgRef.shift());
  }

  if (ref.field !== undefined) {
    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;
    fRef = fieldRef(ref.field);
    val  = fRef.val;
    dependencies(deps, fRef);
  }

  if (ref.scale !== undefined) {
    sRef  = scaleRef(ref.scale);
    scale = sRef.val;
    dependencies(deps, sRef);
    deps.scales.push(ref.scale.name || ref.scale);

    // run through scale function if val specified.
    // if no val, scale function is predicate arg.
    if (val !== null || ref.band || ref.mult || ref.offset) {
      val = scale + (ref.band ? '.rangeBand()' : 
        '('+(val !== null ? val : 'item.datum.data')+')');
    } else {
      val = scale;
    }
  }
  
  // multiply, offset, return value
  val = '(' + (ref.mult?(dl.number(ref.mult)+' * '):'') + val + ')' +
        (ref.offset ? ' + ' + dl.number(ref.offset) : '');

  // Collate dependencies
  return (deps.val = val, deps);
}

function colorRef(config, type, x, y, z) {
  var xx = x ? valueRef(config, '', x) : config.color[type][0],
      yy = y ? valueRef(config, '', y) : config.color[type][1],
      zz = z ? valueRef(config, '', z) : config.color[type][2],
      deps = dependencies();

  [xx, yy, zz].forEach(function(v) {
    if (dl.isArray) return;
    dependencies(deps, v);
  });

  var val = '(this.d3.' + type + '(' + [xx.val, yy.val, zz.val].join(',') + ') + "")';
  return (deps.val = val, deps);
}

// {field: {datum: "foo"} }  -> item.datum.foo
// {field: {group: "foo"} }  -> group.foo
// {field: {parent: "foo"} } -> group.datum.foo
function fieldRef(ref) {
  if (dl.isString(ref)) {
    return {val: dl.field(ref).map(dl.str).join('][')};
  } 

  // Resolve nesting/parent lookups
  var l = ref.level || 1,
      nested = (ref.group || ref.parent) && l,
      scope = nested ? Array(l).join('group.mark.') : '',
      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),
      val = r.val,
      deps = dependencies(null, r);

  if (ref.datum) {
    val = 'item.datum['+val+']';
    deps.fields.push(ref.datum);
  } else if (ref.group) {
    val = scope+'group['+val+']';
    deps.nested.push({ level: l, group: true });
  } else if (ref.parent) {
    val = scope+'group.datum['+val+']';
    deps.nested.push({ level: l, parent: true });
  } else if (ref.signal) {
    val = 'signals['+val+']';
    deps.signals.push(dl.field(ref.signal)[0]);
    deps.reflow = true;
  }

  return (deps.val = val, deps);
}

// {scale: "x"}
// {scale: {name: "x"}},
// {scale: fieldRef}
function scaleRef(ref) {
  var scale = null,
      fr = null,
      deps = dependencies();

  if (dl.isString(ref)) {
    scale = dl.str(ref);
  } else if (ref.name) {
    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;
  } else {
    scale = (fr = fieldRef(ref)).val;
  }

  scale = '(item.mark._scaleRefs['+scale+'] = 1, group.scale('+scale+'))';
  if (ref.invert) scale += '.invert';

  // Mark scale refs as they're dealt with separately in mark._scaleRefs.
  if (fr) fr.nested.forEach(function(g) { g.scale = true; });
  return fr ? (fr.val = scale, fr) : (deps.val = scale, deps);
}

module.exports = properties;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"datalib":24,"vega-dataflow":43,"vega-logging":49}],108:[function(require,module,exports){
var dl = require('datalib'),
    SIGNALS = require('vega-dataflow').Dependencies.SIGNALS,
    expr = require('./expr');

var RESERVED = ['datum', 'event', 'signals']
  .concat(dl.keys(expr.codegen.functions));

function parseSignals(model, spec) {
  // process each signal definition
  (spec || []).forEach(function(s) {
    if (RESERVED.indexOf(s.name) !== -1) {
      throw Error('Signal name "'+s.name+'" is a '+
        'reserved keyword ('+RESERVED.join(', ')+').');
    }

    var signal = model.signal(s.name, s.init)
      .verbose(s.verbose);

    if (s.init && s.init.expr) {
      s.init.expr = expr(s.init.expr);
      signal.value(exprVal(model, s.init));
    }

    if (s.expr) {
      s.expr = expr(s.expr);
      signal.evaluate = function(input) {
        var val = exprVal(model, s);
        if (val !== signal.value() || signal.verbose()) {
          signal.value(val);
          input.signals[s.name] = 1;
          return input;
        }
        return model.doNotPropagate;        
      };
      signal.dependency(SIGNALS, s.expr.globals);
      s.expr.globals.forEach(function(dep) {
        model.signal(dep).addListener(signal);
      });
    }
  });

  return spec;
}

function exprVal(model, spec) {
  var e = spec.expr,
      val = e.fn(null, null, model.values(SIGNALS, e.globals));
  return spec.scale ? parseSignals.scale(model, spec, val) : val;
}

parseSignals.scale = function scale(model, spec, value, datum, evt) {
  var def = spec.scale,
      name  = def.name || def.signal || def,
      scope = def.scope, e;

  if (scope) {
    if (scope.signal) {
      scope = model.signalRef(scope.signal);
    } else if (dl.isString(scope)) { // Scope is an expression
      e = def._expr = (def._expr || expr(scope));
      scope = e.fn(datum, evt, model.values(SIGNALS, e.globals));
    }
  }

  if (!scope || !scope.scale) {
    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];
  }

  var s = scope.scale(name);
  return !s ? value : (def.invert ? s.invert(value) : s(value));
};

module.exports = parseSignals;
},{"./expr":99,"datalib":24,"vega-dataflow":43}],109:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    Model = require('../core/Model'),
    View = require('../core/View');

function parseSpec(spec, callback) {
  var vf = arguments[arguments.length-1],
      viewFactory = arguments.length > 2 && dl.isFunction(vf) ? vf : View.factory,
      config = arguments[2] !== viewFactory ? arguments[2] : {},
      model = new Model(config);

  function parse(spec) {
    // protect against subsequent spec modification
    spec = dl.duplicate(spec);

    var parsers = require('./'),
        width = spec.width || 500,
        height = spec.height || 500,
        viewport = spec.viewport || null;

    model.defs({
      width: width,
      height: height,
      viewport: viewport,
      background: parsers.background(spec.background),
      padding: parsers.padding(spec.padding),
      signals: parsers.signals(model, spec.signals),
      predicates: parsers.predicates(model, spec.predicates),
      marks: parsers.marks(model, spec, width, height),
      data: parsers.data(model, spec.data, function() {
        callback(viewFactory(model));
      })
    });    
  }

  if (dl.isObject(spec)) {
    parse(spec);
  } else if (dl.isString(spec)) {
    var opts = dl.extend({url: spec}, model.config().load);
    dl.load(opts, function(err, data) {
      if (err) {
        log.error('LOADING SPECIFICATION FAILED: ' + err.statusText);
      } else {
        try { 
          parse(JSON.parse(data)); 
        } catch (e) { 
          log.error('INVALID SPECIFICATION: Must be a valid JSON object. '+e); 
        }
      }
    });
  } else {
    log.error('INVALID SPECIFICATION: Must be a valid JSON object or URL.');
  }
}

module.exports = parseSpec;
},{"../core/Model":91,"../core/View":92,"./":100,"datalib":24,"vega-logging":49}],110:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    SIGNALS = df.Dependencies.SIGNALS,
    parseSignals = require('./signals'),
    selector = require('./events'),
    expr = require('./expr');

var GATEKEEPER = '_vgGATEKEEPER';

var vgEvent = {
  getGroup: function(name) { return name ? this.name[name] : this.group; },
  getXY: function(item) {
      var p = {x: this.x, y: this.y};
      if (typeof item === 'string') {
        item = this.name[item];
      }
      for (; item; item = item.mark && item.mark.group) {
        p.x -= item.x || 0;
        p.y -= item.y || 0;
      }
      return p;
    },
  getX: function(item) { return this.getXY(item).x; },
  getY: function(item) { return this.getXY(item).y; }
};

function parseStreams(view) {
  var model = view.model(),
      spec  = model.defs().signals,
      registry = {handlers: {}, nodes: {}},
      internal = dl.duplicate(registry),  // Internal event processing
      external = dl.duplicate(registry);  // External event processing

  (spec || []).forEach(function(sig) {
    var signal = model.signal(sig.name);
    if (sig.expr) return;  // Cannot have an expr and stream definition.

    (sig.streams || []).forEach(function(stream) {
      var sel = selector.parse(stream.type),
          exp = expr(stream.expr);
      mergedStream(signal, sel, exp, stream);
    });
  });

  // We register the event listeners all together so that if multiple
  // signals are registered on the same event, they will receive the
  // new value on the same pulse. 
  dl.keys(internal.handlers).forEach(function(type) {
    view.on(type, function(evt, item) {
      evt.preventDefault(); // stop text selection
      extendEvent(evt, item);
      fire(internal, type, (item && item.datum) || {}, evt);
    });
  });

  // add external event listeners
  dl.keys(external.handlers).forEach(function(type) {
    if (typeof window === 'undefined') return; // No external support

    var h = external.handlers[type],
        t = type.split(':'), // --> no element pseudo-selectors
        elt = (t[0] === 'window') ? [window] :
              window.document.querySelectorAll(t[0]);

    function handler(evt) {
      extendEvent(evt);
      fire(external, type, d3.select(this).datum(), evt);
    }

    for (var i=0; i<elt.length; ++i) {
      elt[i].addEventListener(t[1], handler);
    }

    h.elements = elt;
    h.listener = handler;
  });

  // remove external event listeners
  external.detach = function() {
    dl.keys(external.handlers).forEach(function(type) {
      var h = external.handlers[type],
          t = type.split(':'),
          elt = h.elements || [];

      for (var i=0; i<elt.length; ++i) {
        elt[i].removeEventListener(t[1], h.listener);
      }
    });
  };

  // export detach method
  return external.detach;

  // -- helper functions -----

  function extendEvent(evt, item) {
    var mouse = d3.mouse((d3.event=evt, view.renderer().scene())),
        pad = view.padding(),
        names = {}, mark, group, i;

    if (item) {
      mark = item.mark;
      group = mark.marktype === 'group' ? item : mark.group;
      for (i=item; i!=null; i=i.mark.group) {
        if (i.mark.def.name) {
          names[i.mark.def.name] = i;
        }
      }
    }
    names.root = view.model().scene().items[0];

    evt.vg = Object.create(vgEvent);
    evt.vg.group = group;
    evt.vg.item = item || {};
    evt.vg.name = names;
    evt.vg.x = mouse[0] - pad.left;
    evt.vg.y = mouse[1] - pad.top;
  }

  function fire(registry, type, datum, evt) {
    var handlers = registry.handlers[type],
        node = registry.nodes[type],
        cs = df.ChangeSet.create(null, true),
        filtered = false,
        val, i, n, h;

    function invoke(f) {
      return !f.fn(datum, evt, model.values(SIGNALS, f.globals));
    }

    for (i=0, n=handlers.length; i<n; ++i) {
      h = handlers[i];
      filtered = h.filters.some(invoke);
      if (filtered) continue;
      
      val = h.exp.fn(datum, evt, model.values(SIGNALS, h.exp.globals));
      if (h.spec.scale) {
        val = parseSignals.scale(model, h.spec, val, datum, evt);
      }

      if (val !== h.signal.value() || h.signal.verbose()) {
        h.signal.value(val);
        cs.signals[h.signal.name()] = 1;
      }
    }

    model.propagate(cs, node);
  }

  function mergedStream(sig, selector, exp, spec) {
    selector.forEach(function(s) {
      if (s.event)       domEvent(sig, s, exp, spec);
      else if (s.signal) signal(sig, s, exp, spec);
      else if (s.start)  orderedStream(sig, s, exp, spec);
      else if (s.stream) mergedStream(sig, s.stream, exp, spec);
    });
  }

  function domEvent(sig, selector, exp, spec) {
    var evt = selector.event,
        name = selector.name,
        mark = selector.mark,
        target   = selector.target,
        filters  = selector.filters || [],
        registry = target ? external : internal,
        type = target ? target+':'+evt : evt,
        node = registry.nodes[type] || (registry.nodes[type] = new df.Node(model)),
        handlers = registry.handlers[type] || (registry.handlers[type] = []);

    if (name) {
      filters.push('!!event.vg.name["' + name + '"]'); // Mimic event bubbling
    } else if (mark) {
      filters.push('event.vg.item.mark && event.vg.item.mark.marktype==='+dl.str(mark));
    }

    handlers.push({
      signal: sig,
      exp: exp,
      spec: spec,
      filters: filters.map(function(f) { return expr(f); })
    });

    node.addListener(sig);
  }

  function signal(sig, selector, exp, spec) {
    var n = new df.Node(model);
    n.evaluate = function(input) {
      if (!input.signals[selector.signal]) return model.doNotPropagate;
      var val = exp.fn(null, null, model.values(SIGNALS, exp.globals));
      if (spec.scale) {
        val = parseSignals.scale(model, spec, val);
      }

      if (val !== sig.value() || sig.verbose()) {
        sig.value(val);
        input.signals[sig.name()] = 1;
        input.reflow = true;        
      }

      return input;  
    };
    n.dependency(df.Dependencies.SIGNALS, selector.signal);
    n.addListener(sig);
    model.signal(selector.signal).addListener(n);
  }

  function orderedStream(sig, selector, exp, spec) {
    var name = sig.name(), 
        gk = name + GATEKEEPER, 
        trueFn  = expr('true'), 
        falseFn = expr('false'),
        middle  = selector.middle,
        filters = middle.filters || (middle.filters = []),
        gatekeeper = model.signal(gk) || model.signal(gk, false);

    // Register an anonymous signal to act as a gatekeeper. Its value is
    // true or false depending on whether the start or end streams occur. 
    // The middle signal then simply filters for the gatekeeper's value. 
    mergedStream(gatekeeper, [selector.start], trueFn, {});
    mergedStream(gatekeeper, [selector.end], falseFn, {});

    filters.push(gatekeeper.name());
    mergedStream(sig, [selector.middle], exp, spec);
  }
}

module.exports = parseStreams;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./events":98,"./expr":99,"./signals":108,"datalib":24,"vega-dataflow":43}],111:[function(require,module,exports){
var dl = require('datalib'),
    transforms = require('../transforms/index');

function parseTransforms(model, def) {
  var tx = new transforms[def.type](model);
  
  // We want to rename output fields before setting any other properties,
  // as subsequent properties may require output to be set (e.g. group by).
  if(def.output) tx.output(def.output);

  dl.keys(def).forEach(function(k) {
    if(k === 'type' || k === 'output') return;
    tx.param(k, def[k]);
  });

  return tx;
}

module.exports = parseTransforms;
},{"../transforms/index":144,"datalib":24}],112:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    log = require('vega-logging'),
    bound = require('vega-scenegraph').bound,
    Encoder = require('./Encoder');

function Bounder(graph, mark) {
  this._mark = mark;
  return Node.prototype.init.call(this, graph)
    .router(true)
    .reflows(true)
    .mutates(true);
}

var proto = (Bounder.prototype = new Node());

proto.evaluate = function(input) {
  log.debug(input, ['bounds', this._mark.marktype]);

  var type  = this._mark.marktype,
      isGrp = type === 'group',
      items = this._mark.items,
      hasLegends = dl.array(this._mark.def.legends).length > 0,
      i, ilen, j, jlen, group, legend;

  if (input.add.length || input.rem.length || !items.length || 
      input.mod.length === items.length ||
      type === 'area' || type === 'line') {
    bound.mark(this._mark, null, isGrp && !hasLegends);
  } else {
    input.mod.forEach(function(item) { bound.item(item); });
  }

  if (isGrp && hasLegends) {
    for (i=0, ilen=items.length; i<ilen; ++i) {
      group = items[i];
      group._legendPositions = null;
      for (j=0, jlen=group.legendItems.length; j<jlen; ++j) {
        legend = group.legendItems[j];
        Encoder.update(this._graph, input.trans, 'vg_legendPosition', legend.items, input.dirty);
        bound.mark(legend, null, false);
      }
    }

    bound.mark(this._mark, null, true);
  }

  return df.ChangeSet.create(input, true);
};

module.exports = Bounder;
},{"./Encoder":114,"datalib":24,"vega-dataflow":43,"vega-logging":49,"vega-scenegraph":50}],113:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    Item = require('vega-scenegraph').Item,
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Tuple = df.Tuple,
    ChangeSet = df.ChangeSet,
    Sentinel = {},
    Encoder  = require('./Encoder'),
    Bounder  = require('./Bounder'),
    parseData = require('../parse/data');

function Builder() {    
  return arguments.length ? this.init.apply(this, arguments) : this;
}

var Status = Builder.STATUS = {
  ENTER:  'enter',
  UPDATE: 'update',
  EXIT:   'exit'
};

var CONNECTED = 1, DISCONNECTED = 2;

var proto = (Builder.prototype = new Node());

proto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {
  Node.prototype.init.call(this, graph)
    .router(true)
    .collector(true);

  this._def   = def;
  this._mark  = mark;
  this._from  = (def.from ? def.from.data : null) || inheritFrom;
  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;
  this._map   = {};
  this._status = null; // Connected or disconnected?

  mark.def = def;
  mark.marktype = def.type;
  mark.interactive = (def.interactive !== false);
  mark.items = [];
  if (dl.isValid(def.name)) mark.name = def.name;

  this._parent = parent;
  this._parent_id = parent_id;

  if (def.from && (def.from.mark || def.from.transform || def.from.modify)) {
    inlineDs.call(this);
  }

  // Non-group mark builders are super nodes. Encoder and Bounder remain 
  // separate operators but are embedded and called by Builder.evaluate.
  this._isSuper = (this._def.type !== 'group'); 
  this._encoder = new Encoder(this._graph, this._mark, this);
  this._bounder = new Bounder(this._graph, this._mark);
  this._output  = null; // Output changeset for reactive geom as Bounder reflows

  if (this._ds) { this._encoder.dependency(Deps.DATA, this._from); }

  // Since Builders are super nodes, copy over encoder dependencies
  // (bounder has no registered dependencies).
  this.dependency(Deps.DATA, this._encoder.dependency(Deps.DATA));
  this.dependency(Deps.SCALES, this._encoder.dependency(Deps.SCALES));
  this.dependency(Deps.SIGNALS, this._encoder.dependency(Deps.SIGNALS));

  return this;
};

// Reactive geometry and mark-level transformations are handled here 
// because they need their group's data-joined context. 
function inlineDs() {
  var from = this._def.from,
      geom = from.mark,
      src, name, spec, sibling, output, input;

  if (geom) {
    name = ['vg', this._parent_id, geom].join('_');
    spec = {
      name: name,
      transform: from.transform, 
      modify: from.modify
    };
  } else {
    src = this._graph.data(this._from);
    name = ['vg', this._from, this._def.type, src.listeners(true).length].join('_');
    spec = {
      name: name,
      source: this._from,
      transform: from.transform,
      modify: from.modify
    };
  }

  this._from = name;
  this._ds = parseData.datasource(this._graph, spec);
  var node;

  if (geom) {
    sibling = this.sibling(geom);

    // Bounder reflows, so we need an intermediary node to propagate
    // the output constructed by the Builder.
    node = new Node(this._graph).addListener(this._ds.listener());
    node.evaluate = function() { return sibling._output; };

    if (sibling._isSuper) {
      sibling.addListener(node);
    } else {
      sibling._bounder.addListener(node);
    }
  } else {
    // At this point, we have a new datasource but it is empty as
    // the propagation cycle has already crossed the datasources. 
    // So, we repulse just this datasource. This should be safe
    // as the ds isn't connected to the scenegraph yet.
    output = this._ds.source().last();
    input  = ChangeSet.create(output);

    input.add = output.add;
    input.mod = output.mod;
    input.rem = output.rem;
    input.stamp = null;
    this._graph.propagate(input, this._ds.listener(), output.stamp);
  }
}

proto.ds = function() { return this._ds; };
proto.parent   = function() { return this._parent; };
proto.encoder  = function() { return this._encoder; };
proto.pipeline = function() { return [this]; };

proto.connect = function() {
  var builder = this;

  this._graph.connect(this.pipeline());
  this._encoder._scales.forEach(function(s) {
    if (!(s = builder._parent.scale(s))) return;
    s.addListener(builder);
  });

  if (this._parent) {
    if (this._isSuper) this.addListener(this._parent._collector);
    else this._bounder.addListener(this._parent._collector);
  }

  return (this._status = CONNECTED, this);
};

proto.disconnect = function() {
  var builder = this;
  if (!this._listeners.length) return this;

  function disconnectScales(scales) {
    for(var i=0, len=scales.length, s; i<len; ++i) {
      if (!(s = builder._parent.scale(scales[i]))) continue;
      s.removeListener(builder);
    }
  }

  Node.prototype.disconnect.call(this);
  this._graph.disconnect(this.pipeline());
  disconnectScales(this._encoder._scales);
  disconnectScales(dl.keys(this._mark._scaleRefs));
  
  return (this._status = DISCONNECTED, this);
};

proto.sibling = function(name) {
  return this._parent.child(name, this._parent_id);
};

proto.evaluate = function(input) {
  log.debug(input, ['building', (this._from || this._def.from), this._def.type]);

  var self = this,
      def = this._mark.def,
      props  = def.properties || {},
      update = props.update   || {},
      output, fullUpdate, fcs, data, name;

  if (this._ds) {
    output = ChangeSet.create(input);

    // We need to determine if any encoder dependencies have been updated.
    // However, the encoder's data source will likely be updated, and shouldn't
    // trigger all items to mod.
    data = output.data[(name=this._ds.name())];
    delete output.data[name];
    fullUpdate = this._encoder.reevaluate(output);
    output.data[name] = data;

    // If a scale or signal in the update propset has been updated, 
    // send forward all items for reencoding if we do an early return.
    if (fullUpdate) output.mod = this._mark.items.slice();

    fcs = this._ds.last();
    if (!fcs) throw Error('Builder evaluated before backing DataSource.');
    if (fcs.stamp > this._stamp) {
      output = join.call(this, fcs, this._ds.values(), true, fullUpdate);
    }
  } else {
    data = dl.isFunction(this._def.from) ? this._def.from() : [Sentinel];
    output = join.call(this, input, data);
  }

  // Stash output before Bounder for downstream reactive geometry.
  this._output = output = this._graph.evaluate(output, this._encoder);

  // Add any new scale references to the dependency list, and ensure
  // they're connected.
  if (update.nested && update.nested.length && this._status === CONNECTED) {
    dl.keys(this._mark._scaleRefs).forEach(function(s) {
      var scale = self._parent.scale(s);
      if (!scale) return;

      scale.addListener(self);
      self.dependency(Deps.SCALES, s);
      self._encoder.dependency(Deps.SCALES, s);
    });
  }

  // Supernodes calculate bounds too, but only on items marked dirty.
  if (this._isSuper) {
    output.mod = output.mod.filter(function(x) { return x._dirty; });
    output = this._graph.evaluate(output, this._bounder);
  }

  return output;
};

function newItem() {
  var item = Tuple.ingest(new Item(this._mark));

  // For the root node's item
  if (this._def.width)  Tuple.set(item, 'width',  this._def.width);
  if (this._def.height) Tuple.set(item, 'height', this._def.height);
  return item;
}

function join(input, data, ds, fullUpdate) {
  var output = ChangeSet.create(input),
      keyf = keyFunction(this._def.key || (ds ? '_id' : null)),
      prev = this._mark.items || [],
      rem  = ds ? input.rem : prev,
      mod  = Tuple.idMap((!ds || fullUpdate) ? data : input.mod),
      next = [],
      i, key, len, item, datum, enter, diff;

  // Only mark rems as exiting. Due to keyf, there may be an add/mod 
  // tuple that replaces it.
  for (i=0, len=rem.length; i<len; ++i) {
    item = (rem[i] === prev[i]) ? prev[i] :
      keyf ? this._map[keyf(rem[i])] : rem[i];
    item.status = Status.EXIT;
  }

  for(i=0, len=data.length; i<len; ++i) {
    datum = data[i];
    item  = keyf ? this._map[key = keyf(datum)] : prev[i];
    enter = item ? false : (item = newItem.call(this), true);
    item.status = enter ? Status.ENTER : Status.UPDATE;
    diff = !enter && item.datum !== datum;
    item.datum = datum;

    if (keyf) {
      Tuple.set(item, 'key', key);
      this._map[key] = item;
    }

    if (enter) {
      output.add.push(item);
    } else if (diff || mod[datum._id]) {
      output.mod.push(item);
    }

    next.push(item);
  }

  for (i=0, len=rem.length; i<len; ++i) {
    item = (rem[i] === prev[i]) ? prev[i] :
      keyf ? this._map[key = keyf(rem[i])] : rem[i];
    if (item.status === Status.EXIT) {
      item._dirty = true;
      input.dirty.push(item);
      next.push(item);
      output.rem.push(item);
      if (keyf) this._map[key] = null;
    }
  }

  return (this._mark.items = next, output);
}

function keyFunction(key) {
  if (key == null) return null;
  var f = dl.array(key).map(dl.accessor);
  return function(d) {
    for (var s='', i=0, n=f.length; i<n; ++i) {
      if (i>0) s += '|';
      s += String(f[i](d));
    }
    return s;
  };
}

module.exports = Builder;
},{"../parse/data":97,"./Bounder":112,"./Encoder":114,"datalib":24,"vega-dataflow":43,"vega-logging":49,"vega-scenegraph":50}],114:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    bound = require('vega-scenegraph').bound;

var EMPTY = {};

function Encoder(graph, mark, builder) {
  var props  = mark.def.properties || {},
      enter  = props.enter,
      update = props.update,
      exit   = props.exit;

  Node.prototype.init.call(this, graph);

  this._mark = mark;
  this._builder = builder;
  var s = this._scales = [];

  // Only scales used in the 'update' property set are set as
  // encoder depedencies to have targeted reevaluations. However,
  // we still want scales in 'enter' and 'exit' to be evaluated
  // before the encoder. 
  if (enter) s.push.apply(s, enter.scales);

  if (update) {
    this.dependency(Deps.DATA, update.data);
    this.dependency(Deps.SIGNALS, update.signals);
    this.dependency(Deps.FIELDS, update.fields);
    this.dependency(Deps.SCALES, update.scales);
    s.push.apply(s, update.scales);
  }

  if (exit) s.push.apply(s, exit.scales);

  return this.mutates(true);
}

var proto = (Encoder.prototype = new Node());

proto.evaluate = function(input) {
  log.debug(input, ['encoding', this._mark.def.type]);
  var graph = this._graph,
      props = this._mark.def.properties || {},
      items = this._mark.items,
      enter  = props.enter,
      update = props.update,
      exit   = props.exit,
      dirty  = input.dirty,
      preds  = graph.predicates(),
      req = input.request,
      group = this._mark.group,
      guide = group && (group.mark.axis || group.mark.legend),
      db = EMPTY, sg = EMPTY, i, len, item, prop;

  if (req && !guide) {
    if ((prop = props[req]) && input.mod.length) {
      db = prop.data ? graph.values(Deps.DATA, prop.data) : null;
      sg = prop.signals ? graph.values(Deps.SIGNALS, prop.signals) : null;

      for (i=0, len=input.mod.length; i<len; ++i) {
        item = input.mod[i];
        encode.call(this, prop, item, input.trans, db, sg, preds, dirty);
      }
    }

    return input; // exit early if given request
  }

  db = values(Deps.DATA, graph, input, props);
  sg = values(Deps.SIGNALS, graph, input, props);

  // Items marked for removal are at the tail of items. Process them first.
  for (i=0, len=input.rem.length; i<len; ++i) {
    item = input.rem[i];
    if (exit) encode.call(this, exit, item, input.trans, db, sg, preds, dirty); 
    if (input.trans && !exit) input.trans.interpolate(item, EMPTY);
    else if (!input.trans) items.pop();
  }

  var update_status = require('./Builder').STATUS.UPDATE;
  for (i=0, len=input.add.length; i<len; ++i) {
    item = input.add[i];
    if (enter)  encode.call(this, enter,  item, input.trans, db, sg, preds, dirty);
    if (update) encode.call(this, update, item, input.trans, db, sg, preds, dirty);
    item.status = update_status;
  }

  if (update) {
    for (i=0, len=input.mod.length; i<len; ++i) {
      item = input.mod[i];
      encode.call(this, update, item, input.trans, db, sg, preds, dirty);
    }
  }

  return input;
};

// Only marshal necessary data and signal values
function values(type, graph, input, props) {
  var p, x, o, add = input.add.length;
  if ((p=props.enter) && (x=p[type]).length && add) {
    o = graph.values(type, x, (o=o||{}));
  }
  if ((p=props.exit) && (x=p[type]).length && input.rem.length) {
    o = graph.values(type, x, (o=o||{})); 
  }
  if ((p=props.update) && (x=p[type]).length && (add || input.mod.length)) {
    o = graph.values(type, x, (o=o||{}));
  }
  return o || EMPTY;
}

function encode(prop, item, trans, db, sg, preds, dirty) {
  var enc = prop.encode,
      wasDirty = item._dirty,
      isDirty  = enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);

  item._dirty = isDirty || wasDirty;
  if (isDirty && !wasDirty) dirty.push(item);
}

// If a specified property set called, or update property set 
// uses nested fieldrefs, reevaluate all items.
proto.reevaluate = function(pulse) {
  var def = this._mark.def,
      props = def.properties || {},
      reeval = dl.isFunction(def.from) || def.orient || pulse.request || 
        Node.prototype.reevaluate.call(this, pulse);

  return reeval || (props.update ? nestedRefs.call(this) : false);
};

// Test if any nested refs trigger a reflow of mark items.
function nestedRefs() {
  var refs = this._mark.def.properties.update.nested,
      parent = this._builder,
      level = 0,
      i = 0, len = refs.length,
      ref, ds, stamp;

  for (; i<len; ++i) {
    ref = refs[i];

    // Scale references are resolved via this._mark._scaleRefs which are
    // added to dependency lists + connected in Builder.evaluate.
    if (ref.scale) continue;

    for (; level<ref.level; ++level) {
      parent = parent.parent();
      ds = parent.ds();
    }

    // Compare stamps to determine if a change in a group's properties
    // or data should trigger a reeval. We cannot check anything fancier
    // (e.g., pulse.fields) as the ref may use item.datum.
    stamp = (ref.group ? parent.encoder() : ds.last())._stamp;
    if (stamp > this._stamp) return true;
  }

  return false;
}

// Short-circuit encoder if user specifies items
Encoder.update = function(graph, trans, request, items, dirty) {
  items = dl.array(items);
  var preds = graph.predicates(), 
      db = graph.values(Deps.DATA),
      sg = graph.values(Deps.SIGNALS),
      i, len, item, props, prop;

  for (i=0, len=items.length; i<len; ++i) {
    item = items[i];
    props = item.mark.def.properties;
    prop = props && props[request];
    if (prop) {
      encode.call(null, prop, item, trans, db, sg, preds, dirty);
      bound.item(item);
    }
  }

};

module.exports = Encoder;
},{"./Builder":113,"datalib":24,"vega-dataflow":43,"vega-logging":49,"vega-scenegraph":50}],115:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Collector = df.Collector,
    log = require('vega-logging'),
    Builder = require('./Builder'),
    Scale = require('./Scale'),
    parseAxes = require('../parse/axes'),
    parseLegends = require('../parse/legends');

function GroupBuilder() {
  this._children = {};
  this._scaler = null;
  this._recursor = null;

  this._scales = {};
  this.scale = scale.bind(this);
  return arguments.length ? this.init.apply(this, arguments) : this;
}

var Types = GroupBuilder.TYPES = {
  GROUP:  "group",
  MARK:   "mark",
  AXIS:   "axis",
  LEGEND: "legend"
};

var proto = (GroupBuilder.prototype = new Builder());

proto.init = function(graph, def) {
  var builder = this, name;

  this._scaler = new Node(graph);

  (def.scales||[]).forEach(function(s) {
    s = builder.scale((name=s.name), new Scale(graph, s, builder));
    builder.scale(name+":prev", s);
    builder._scaler.addListener(s);  // Scales should be computed after group is encoded
  });

  this._recursor = new Node(graph);
  this._recursor.evaluate = recurse.bind(this);

  var scales = (def.axes||[]).reduce(function(acc, x) {
    return (acc[x.scale] = 1, acc);
  }, {});

  scales = (def.legends||[]).reduce(function(acc, x) {
    return (acc[x.size || x.shape || x.fill || x.stroke], acc);
  }, scales);

  this._recursor.dependency(Deps.SCALES, dl.keys(scales));

  // We only need a collector for up-propagation of bounds calculation,
  // so only GroupBuilders, and not regular Builders, have collectors.
  this._collector = new Collector(graph);

  return Builder.prototype.init.apply(this, arguments);
};

proto.evaluate = function() {
  var output = Builder.prototype.evaluate.apply(this, arguments),
      builder = this;

  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });
  return output;
};

proto.pipeline = function() {
  return [this, this._scaler, this._recursor, this._collector, this._bounder];
};

proto.disconnect = function() {
  var builder = this;
  dl.keys(builder._children).forEach(function(group_id) {
    builder._children[group_id].forEach(function(c) {
      builder._recursor.removeListener(c.builder);
      c.builder.disconnect();
    });
  });

  builder._children = {};
  return Builder.prototype.disconnect.call(this);
};

proto.child = function(name, group_id) {
  var children = this._children[group_id],
      i = 0, len = children.length,
      child;

  for (; i<len; ++i) {
    child = children[i];
    if (child.type == Types.MARK && child.builder._def.name == name) break;
  }

  return child.builder;
};

function recurse(input) {
  var builder = this,
      hasMarks = dl.array(this._def.marks).length > 0,
      hasAxes = dl.array(this._def.axes).length > 0,
      hasLegends = dl.array(this._def.legends).length > 0,
      i, j, c, len, group, pipeline, def, inline = false;

  for (i=0, len=input.add.length; i<len; ++i) {
    group = input.add[i];
    if (hasMarks) buildMarks.call(this, input, group);
    if (hasAxes)  buildAxes.call(this, input, group);
    if (hasLegends) buildLegends.call(this, input, group);
  }

  // Wire up new children builders in reverse to minimize graph rewrites.
  for (i=input.add.length-1; i>=0; --i) {
    group = input.add[i];
    for (j=this._children[group._id].length-1; j>=0; --j) {
      c = this._children[group._id][j];
      c.builder.connect();
      pipeline = c.builder.pipeline();
      def = c.builder._def;

      // This new child needs to be built during this propagation cycle.
      // We could add its builder as a listener off the _recursor node, 
      // but try to inline it if we can to minimize graph dispatches.
      inline = (def.type !== Types.GROUP);
      inline = inline && (this._graph.data(c.from) !== undefined); 
      inline = inline && (pipeline[pipeline.length-1].listeners().length === 1); // Reactive geom source
      inline = inline && (def.from && !def.from.mark); // Reactive geom target
      c.inline = inline;

      if (inline) this._graph.evaluate(input, c.builder);
      else this._recursor.addListener(c.builder);
    }
  }

  function removeTemp(c) {
    if (c.type == Types.MARK && !c.inline &&
        builder._graph.data(c.from) !== undefined) {
      builder._recursor.removeListener(c.builder);
    }
  }

  function updateAxis(a) { 
    var scale = a.scale();
    if (!input.scales[scale.scaleName]) return;
    a.reset().def();
  }
  
  function updateLegend(l) { 
    var scale = l.size() || l.shape() || l.fill() || l.stroke();
    if (!input.scales[scale.scaleName]) return;
    l.reset().def();
  }

  for (i=0, len=input.mod.length; i<len; ++i) {
    group = input.mod[i];

    // Remove temporary connection for marks that draw from a source
    if (hasMarks) builder._children[group._id].forEach(removeTemp);

    // Update axis data defs
    if (hasAxes) group.axes.forEach(updateAxis);

    // Update legend data defs
    if (hasLegends) group.legends.forEach(updateLegend);
  }

  function disconnectChildren(c) { 
    builder._recursor.removeListener(c.builder);
    c.builder.disconnect(); 
  }

  for (i=0, len=input.rem.length; i<len; ++i) {
    group = input.rem[i];
    // For deleted groups, disconnect their children
    builder._children[group._id].forEach(disconnectChildren);
    delete builder._children[group._id];
  }

  return input;
}

function scale(name, x) {
  var group = this, s = null;
  if (arguments.length === 2) return (group._scales[name] = x, x);
  while (s == null) {
    s = group._scales[name];
    group = group.mark ? group.mark.group : group._parent;
    if (!group) break;
  }
  return s;
}

function buildGroup(input, group) {
  log.debug(input, ["building group", group._id]);

  group._scales = group._scales || {};    
  group.scale = scale.bind(group);

  group.items = group.items || [];
  this._children[group._id] = this._children[group._id] || [];

  group.axes = group.axes || [];
  group.axisItems = group.axisItems || [];

  group.legends = group.legends || [];
  group.legendItems = group.legendItems || [];
}

function buildMarks(input, group) {
  log.debug(input, ["building children marks #"+group._id]);
  var marks = this._def.marks,
      mark, from, inherit, i, len, b;

  for (i=0, len=marks.length; i<len; ++i) {
    mark = marks[i];
    from = mark.from || {};
    inherit = group.datum._facetID;
    group.items[i] = {group: group, _scaleRefs: {}};
    b = (mark.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(this._graph, mark, group.items[i], this, group._id, inherit);
    this._children[group._id].push({ 
      builder: b, 
      from: from.data || (from.mark ? ("vg_" + group._id + "_" + from.mark) : inherit), 
      type: Types.MARK 
    });
  }
}

function buildAxes(input, group) {
  var axes = group.axes,
      axisItems = group.axisItems,
      builder = this;

  parseAxes(this._graph, this._def.axes, axes, group);
  axes.forEach(function(a, i) {
    var scale = builder._def.axes[i].scale,
        def = a.def(),
        b = null;

    axisItems[i] = {group: group, axis: true, layer: def.layer};
    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(builder._graph, def, axisItems[i], builder)
      .dependency(Deps.SCALES, scale);
    builder._children[group._id].push({ builder: b, type: Types.AXIS, scale: scale });
  });
}

function buildLegends(input, group) {
  var legends = group.legends,
      legendItems = group.legendItems,
      builder = this;

  parseLegends(this._graph, this._def.legends, legends, group);
  legends.forEach(function(l, i) {
    var scale = l.size() || l.shape() || l.fill() || l.stroke(),
        def = l.def(),
        b = null;

    legendItems[i] = {group: group, legend: true};
    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(builder._graph, def, legendItems[i], builder)
      .dependency(Deps.SCALES, scale);
    builder._children[group._id].push({ builder: b, type: Types.LEGEND, scale: scale });
  });
}

module.exports = GroupBuilder;
},{"../parse/axes":95,"../parse/legends":101,"./Builder":113,"./Scale":116,"datalib":24,"vega-dataflow":43,"vega-logging":49}],116:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    log = require('vega-logging'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Aggregate = require('../transforms/Aggregate');

var Properties = {
  width: 1,
  height: 1
};

var Types = {
  LINEAR: 'linear',
  ORDINAL: 'ordinal',
  LOG: 'log',
  POWER: 'pow',
  SQRT: 'sqrt',
  TIME: 'time',
  TIME_UTC: 'utc',
  QUANTILE: 'quantile',
  QUANTIZE: 'quantize',
  THRESHOLD: 'threshold'
};

var DataRef = {
  DOMAIN: 'domain',
  RANGE: 'range',

  COUNT: 'count',
  GROUPBY: 'groupby',
  MIN: 'min',
  MAX: 'max',
  VALUE: 'value',

  ASC: 'asc',
  DESC: 'desc'
};

function Scale(graph, def, parent) {
  this._def     = def;
  this._parent  = parent;
  this._updated = false;
  return Node.prototype.init.call(this, graph).reflows(true);
}

var proto = (Scale.prototype = new Node());

proto.evaluate = function(input) {
  var self = this,
      fn = function(group) { scale.call(self, group); };

  this._updated = false;
  input.add.forEach(fn);
  input.mod.forEach(fn);

  // Scales are at the end of an encoding pipeline, so they should forward a
  // reflow pulse. Thus, if multiple scales update in the parent group, we don't
  // reevaluate child marks multiple times. 
  if (this._updated) {
    input.scales[this._def.name] = 1;
    log.debug(input, ["scale", this._def.name]);  
  } 
  return df.ChangeSet.create(input, true);
};

// All of a scale's dependencies are registered during propagation as we parse
// dataRefs. So a scale must be responsible for connecting itself to dependents.
proto.dependency = function(type, deps) {
  if (arguments.length == 2) {
    var method = (type === Deps.DATA ? 'data' : 'signal');
    deps = dl.array(deps);
    for (var i=0, len=deps.length; i<len; ++i) {
      this._graph[method](deps[i]).addListener(this._parent);
    }
  }

  return Node.prototype.dependency.call(this, type, deps);
};

function scale(group) {
  var name = this._def.name,
      prev = name + ':prev',
      s = instance.call(this, group.scale(name)),
      m = s.type===Types.ORDINAL ? ordinal : quantitative,
      rng = range.call(this, group);

  m.call(this, s, rng, group);

  group.scale(name, s);
  group.scale(prev, group.scale(prev) || s);

  return s;
}

function instance(scale) {
  var config = this._graph.config(),
      type = this._def.type || Types.LINEAR;
  if (!scale || type !== scale.type) {
    var ctor = config.scale[type] || d3.scale[type];
    if (!ctor) throw Error('Unrecognized scale type: ' + type);
    (scale = ctor()).type = scale.type || type;
    scale.scaleName = this._def.name;
    scale._prev = {};
  }
  return scale;
}

function ordinal(scale, rng, group) {
  var def = this._def,
      prev = scale._prev,
      dataDrivenRange = false,
      pad = signal.call(this, def.padding) || 0,
      outer = def.outerPadding == null ? pad : signal.call(this, def.outerPadding),
      points = def.points && signal.call(this, def.points),
      round = signal.call(this, def.round) || def.round == null,
      domain, str;
  
  // range pre-processing for data-driven ranges
  if (dl.isObject(def.range) && !dl.isArray(def.range)) {
    dataDrivenRange = true;
    rng = dataRef.call(this, DataRef.RANGE, def.range, scale, group);
  }
  
  // domain
  domain = dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
  if (domain && !dl.equal(prev.domain, domain)) {
    scale.domain(domain);
    prev.domain = domain;
    this._updated = true;
  } 

  // range
  if (dl.equal(prev.range, rng)) return;

  // width-defined range
  if (def.bandWidth) {
    var bw = signal.call(this, def.bandWidth),
        len = domain.length,
        space = def.points ? (pad*bw) : (pad*bw*(len-1) + 2*outer),
        start;
    if (rng[0] > rng[1]) {
      start = rng[1] || 0;
      rng = [start + (bw * len + space), start];
    } else {
      start = rng[0] || 0;
      rng = [start, start + (bw * len + space)];
    }
  }

  str = typeof rng[0] === 'string';
  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {
    scale.range(rng); // color or shape values
  } else if (points && round) {
    scale.rangeRoundPoints(rng, pad);
  } else if (points) {
    scale.rangePoints(rng, pad);
  } else if (round) {
    scale.rangeRoundBands(rng, pad, outer);
  } else {
    scale.rangeBands(rng, pad, outer);
  }

  if (!scale.invert) {
    scale.invert = function(x, y) {
      if (arguments.length === 1) {
        return scale.domain()[d3.bisect(scale.range(), x) - 1];
      } else if (arguments.length === 2) {  // Invert extents
        if (!dl.isNumber(x) || !dl.isNumber(y)) {
          throw Error('Extents to ordinal invert are not numbers ('+x+', '+y+').');
        }

        var points = [],
            rng = scale.range(),
            i = 0, len = rng.length, r;

        for(; i<len; ++i) {
          r = rng[i];
          if (x < y ? x <= r && r <= y : y <= r && r <= x) {
            points.push(r);
          }
        }

        return points.map(function(p) { return scale.invert(p); });
      }
    };
  }

  prev.range = rng;
  this._updated = true;
}

function quantitative(scale, rng, group) {
  var def = this._def,
      prev = scale._prev,
      round = signal.call(this, def.round),
      exponent = signal.call(this, def.exponent),
      clamp = signal.call(this, def.clamp),
      nice = signal.call(this, def.nice),
      domain, interval;

  // domain
  domain = (def.type === Types.QUANTILE) ?
    dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group) :
    domainMinMax.call(this, scale, group);
  if (domain && !dl.equal(prev.domain, domain)) {
    scale.domain(domain);
    prev.domain = domain;
    this._updated = true;
  } 

  // range
  // vertical scales should flip by default, so use XOR here
  if (signal.call(this, def.range) === 'height') rng = rng.reverse();
  if (dl.equal(prev.range, rng)) return;
  scale[round && scale.rangeRound ? 'rangeRound' : 'range'](rng);
  prev.range = rng;
  this._updated = true;

  // TODO: Support signals for these properties. Until then, only eval
  // them once.
  if (this._stamp > 0) return;
  if (exponent && def.type===Types.POWER) scale.exponent(exponent);
  if (clamp) scale.clamp(true);
  if (nice) {
    if (def.type === Types.TIME) {
      interval = d3.time[nice];
      if (!interval) log.error('Unrecognized interval: ' + interval);
      scale.nice(interval);
    } else {
      scale.nice();
    }
  }
}

function isUniques(scale) { 
  return scale.type === Types.ORDINAL || scale.type === Types.QUANTILE; 
}

function getRefs(def) { 
  return def.fields || dl.array(def);
}

function inherits(refs) {
  return refs.some(function(r) {
    if (!r.data) return true;
    return r.data && dl.array(r.field).some(function(f) {
      return f.parent;
    });
  });
}

function getFields(ref, group) {
  return dl.array(ref.field).map(function(f) {
    return f.parent ?
      dl.accessor(f.parent)(group.datum) :
      f; // String or {'signal'}
  });
}

// Scale datarefs can be computed over multiple schema types. 
// This function determines the type of aggregator created, and
// what data is sent to it: values, tuples, or multi-tuples that must
// be standardized into a consistent schema. 
function aggrType(def, scale) {
  var refs = getRefs(def);

  // If we're operating over only a single domain, send full tuples
  // through for efficiency (fewer accessor creations/calls)
  if (refs.length == 1 && dl.array(refs[0].field).length == 1) {
    return Aggregate.TYPES.TUPLE;
  }

  // With quantitative scales, we only care about min/max.
  if (!isUniques(scale)) return Aggregate.TYPES.VALUE;

  // If we don't sort, then we can send values directly to aggrs as well
  if (!dl.isObject(def.sort)) return Aggregate.TYPES.VALUE;

  return Aggregate.TYPES.MULTI;
}

function getCache(which, def, scale, group) {
  var refs = getRefs(def),
      inherit = inherits(refs),
      atype = aggrType(def, scale),
      uniques = isUniques(scale),
      sort = def.sort,
      ck = '_'+which,
      fields = getFields(refs[0], group);

  if (scale[ck] || this[ck]) return scale[ck] || this[ck];

  var cache = new Aggregate(this._graph).type(atype),
      groupby, summarize;

  // If a scale's dataref doesn't inherit data from the group, we can
  // store the dataref aggregator at the Scale (dataflow node) level. 
  if (inherit) {
    scale[ck] = cache;
  } else {
    this[ck]  = cache;
  }

  if (uniques) {
    if (atype === Aggregate.TYPES.VALUE) {
      groupby = [{ name: DataRef.GROUPBY, get: dl.identity }];
      summarize = {'*': DataRef.COUNT};
    } else if (atype === Aggregate.TYPES.TUPLE) {
      groupby = [{ name: DataRef.GROUPBY, get: dl.$(fields[0]) }];
      summarize = dl.isObject(sort) ? [{
        field: DataRef.VALUE,
        get:  dl.$(sort.field),
        ops: [sort.op]
      }] : {'*': DataRef.COUNT};
    } else {  // atype === Aggregate.TYPES.MULTI
      groupby   = DataRef.GROUPBY;
      summarize = [{ field: DataRef.VALUE, ops: [sort.op] }]; 
    }
  } else {
    groupby = [];
    summarize = [{
      field: DataRef.VALUE,
      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,
      ops: [DataRef.MIN, DataRef.MAX],
      as:  [DataRef.MIN, DataRef.MAX]
    }];
  }

  cache.param('groupby', groupby)
    .param('summarize', summarize);

  return (cache._lastUpdate = -1, cache);
}

function dataRef(which, def, scale, group) {
  if (def == null) { return []; }
  if (dl.isArray(def)) return def.map(signal.bind(this));

  var self = this, graph = this._graph,
      refs = getRefs(def),
      inherit = inherits(refs),
      atype = aggrType(def, scale),
      cache = getCache.apply(this, arguments),
      sort  = def.sort,
      uniques = isUniques(scale),
      i, rlen, j, flen, ref, fields, field, data, from, so, cmp;

  function addDep(s) {
    self.dependency(Deps.SIGNALS, s);
  }

  if (inherit || (!inherit && cache._lastUpdate < this._stamp)) {
    for (i=0, rlen=refs.length; i<rlen; ++i) {
      ref = refs[i];
      from = ref.data || group.datum._facetID;
      data = graph.data(from).last();

      if (data.stamp <= this._stamp) continue;

      fields = getFields(ref, group);
      for (j=0, flen=fields.length; j<flen; ++j) {
        field = fields[j];

        if (atype === Aggregate.TYPES.VALUE) {
          cache.accessors(null, field);
        } else if (atype === Aggregate.TYPES.MULTI) {
          cache.accessors(field, ref.sort || sort.field);
        } // Else (Tuple-case) is handled by the aggregator accessors by default

        cache.evaluate(data);
      }

      this.dependency(Deps.DATA, from);
      cache.dependency(Deps.SIGNALS).forEach(addDep);
    }

    cache._lastUpdate = this._stamp;

    data = cache.aggr().result();
    if (uniques) {
      if (dl.isObject(sort)) {
        cmp = (so = sort.order) && so.signal ? graph.signalRef(so.signal) : so;
        cmp = (cmp == DataRef.DESC ? '-' : '+') + sort.op + '_' + DataRef.VALUE;
        cmp = dl.comparator(cmp);
      } else if (sort === true) {
        cmp = dl.comparator(DataRef.GROUPBY);
      }

      if (cmp) data = data.sort(cmp);
      cache._values = data.map(function(d) { return d[DataRef.GROUPBY]; });
    } else {
      data = data[0];
      cache._values = !dl.isValid(data) ? [] : [data[DataRef.MIN], data[DataRef.MAX]];
    }
  }

  return cache._values;
}

function signal(v) {
  if (!v || !v.signal) return v;
  var s = v.signal, ref;
  this.dependency(Deps.SIGNALS, (ref = dl.field(s))[0]);
  return this._graph.signalRef(ref);
}

function domainMinMax(scale, group) {
  var def = this._def,
      domain = [null, null], s, z;

  if (def.domain !== undefined) {
    domain = (!dl.isObject(def.domain)) ? domain :
      dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
  }

  z = domain.length - 1;
  if (def.domainMin !== undefined) {
    if (dl.isObject(def.domainMin)) {
      if (def.domainMin.signal) {
        domain[0] = dl.isValid(s=signal.call(this, def.domainMin)) ? s : domain[0];
      } else {
        domain[0] = dataRef.call(this, DataRef.DOMAIN+DataRef.MIN, def.domainMin, scale, group)[0];
      }
    } else {
      domain[0] = def.domainMin;
    }
  }
  if (def.domainMax !== undefined) {
    if (dl.isObject(def.domainMax)) {
      if (def.domainMax.signal) {
        domain[z] = dl.isValid(s=signal.call(this, def.domainMax)) ? s : domain[z];
      } else {
        domain[z] = dataRef.call(this, DataRef.DOMAIN+DataRef.MAX, def.domainMax, scale, group)[1];
      }
    } else {
      domain[z] = def.domainMax;
    }
  }
  if (def.type !== Types.LOG && def.type !== Types.TIME && (def.zero || def.zero===undefined)) {
    domain[0] = Math.min(0, domain[0]);
    domain[z] = Math.max(0, domain[z]);
  }
  return domain;
}

function range(group) {
  var def = this._def,
      config = this._graph.config(),
      rangeVal = signal.call(this, def.range),
      rng = [null, null];

  if (rangeVal !== undefined) {
    if (typeof rangeVal === 'string') {
      if (Properties[rangeVal]) {
        rng = [0, group[rangeVal]];
      } else if (config.range[rangeVal]) {
        rng = config.range[rangeVal];
      } else {
        log.error('Unrecogized range: ' + rangeVal);
        return rng;
      }
    } else if (dl.isArray(rangeVal)) {
      rng = dl.duplicate(rangeVal).map(signal.bind(this));
    } else if (dl.isObject(rangeVal)) {
      return null; // early exit
    } else {
      rng = [0, rangeVal];
    }
  }
  if (def.rangeMin !== undefined) {
    rng[0] = def.rangeMin.signal ?
      signal.call(this, def.rangeMin) :
      def.rangeMin;
  }
  if (def.rangeMax !== undefined) {
    rng[rng.length-1] = def.rangeMax.signal ?
      signal.call(this, def.rangeMax) :
      def.rangeMax;
  }
  
  if (def.reverse !== undefined) {
    var rev = signal.call(this, def.reverse);
    if (dl.isObject(rev)) {
      rev = dl.accessor(rev.field)(group.datum);
    }
    if (rev) rng = rng.reverse();
  }
  
  return rng;
}

module.exports = Scale;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transforms/Aggregate":121,"datalib":24,"vega-dataflow":43,"vega-logging":49}],117:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    bound = require('vega-scenegraph').bound,
    Tuple = require('vega-dataflow').Tuple,
    Status = require('./Builder').STATUS;

function Transition(duration, ease) {
  this.duration = duration || 500;
  this.ease = ease && d3.ease(ease) || d3.ease('cubic-in-out');
  this.updates = {next: null};
}

var prototype = Transition.prototype;

var skip = {
  'text': 1,
  'url':  1
};

prototype.interpolate = function(item, values) {
  var key, curr, next, interp, list = null;

  for (key in values) {
    curr = item[key];
    next = values[key];      
    if (curr !== next) {
      if (skip[key] || curr === undefined) {
        // skip interpolation for specific keys or undefined start values
        Tuple.set(item, key, next);
      } else if (typeof curr === 'number' && !isFinite(curr)) {
        // for NaN or infinite numeric values, skip to final value
        Tuple.set(item, key, next);
      } else {
        // otherwise lookup interpolator
        interp = d3.interpolate(curr, next);
        interp.property = key;
        (list || (list=[])).push(interp);
      }
    }
  }

  if (list === null && item.status === Status.EXIT) {
    list = []; // ensure exiting items are included
  }

  if (list != null) {
    list.item = item;
    list.ease = item.mark.ease || this.ease;
    list.next = this.updates.next;
    this.updates.next = list;
  }
  return this;
};

prototype.start = function(callback) {
  var t = this, prev = t.updates, curr = prev.next;
  for (; curr!=null; prev=curr, curr=prev.next) {
    if (curr.item.status === Status.EXIT) {
      // Only mark item as exited when it is removed.
      curr.item.status = Status.UPDATE;
      curr.remove = true;
    }
  }
  t.callback = callback;
  d3.timer(function(elapsed) { return step.call(t, elapsed); });
};

function step(elapsed) {
  var list = this.updates, prev = list, curr = prev.next,
      duration = this.duration,
      item, delay, f, e, i, n, stop = true;

  for (; curr!=null; prev=curr, curr=prev.next) {
    item = curr.item;
    delay = item.delay || 0;

    f = (elapsed - delay) / duration;
    if (f < 0) { stop = false; continue; }
    if (f > 1) f = 1;
    e = curr.ease(f);

    for (i=0, n=curr.length; i<n; ++i) {
      item[curr[i].property] = curr[i](e);
    }
    item.touch();
    bound.item(item);

    if (f === 1) {
      if (curr.remove) {
        item.status = Status.EXIT;
        item.remove();
      }
      prev.next = curr.next;
      curr = prev;
    } else {
      stop = false;
    }
  }

  this.callback();
  return stop;
}

module.exports = Transition;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Builder":113,"vega-dataflow":43,"vega-scenegraph":50}],118:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    parseMark = require('../parse/mark');

var TIME    = 'time',
    UTC     = 'utc',
    STRING  = 'string',
    ORDINAL = 'ordinal',
    NUMBER  = 'number';

function axs(model) {
  var scale,
      config = model.config(),
      orient = config.axis.orient,
      offset = 0,
      titleOffset = config.axis.titleOffset,
      axisDef = {},
      layer = 'front',
      grid = false,
      title = null,
      tickMajorSize = config.axis.tickSize,
      tickMinorSize = config.axis.tickSize,
      tickEndSize = config.axis.tickSize,
      tickPadding = config.axis.padding,
      tickValues = null,
      tickFormatString = null,
      tickFormatType = null,
      tickSubdivide = 0,
      tickCount = config.axis.ticks,
      gridLineStyle = {},
      tickLabelStyle = {},
      majorTickStyle = {},
      minorTickStyle = {},
      titleStyle = {},
      domainStyle = {},
      m = { // Axis marks as references for updates
        gridLines:  {},
        majorTicks: {},
        minorTicks: {},
        tickLabels: {},
        domain: {},
        title:  {}
      };

  var axis = {};

  function reset() {
    axisDef.type = null;
  }

  function ingest(d) {
    return {data: d};
  }

  function getTickFormat() {
    var formatType = tickFormatType || inferFormatType();
    return getFormatter(formatType, tickFormatString);
  }

  function inferFormatType() {
    switch (scale.type) {
      case TIME:    return TIME;
      case UTC:     return UTC;
      case ORDINAL: return STRING;
      default:      return NUMBER;
    }
  }

  // Adapted from d3 log scale
  // TODO customize? replace with range-size-aware filtering?
  function logFilter(domain, count, f) {
    if (count == null) return f;
    var base = scale.base(),
        k = Math.min(base, scale.ticks().length / count),
        v = domain[0] > 0 ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
        e;
    function log(x) {
      return (domain[0] < 0 ?
        -Math.log(x > 0 ? 0 : -x) :
        Math.log(x < 0 ? 0 : x)) / Math.log(base);
    }
    function pow(x) {
      return domain[0] < 0 ? -Math.pow(base, -x) : Math.pow(base, x);
    }
    return function(d) {
      return pow(v(log(d) + e)) / d >= k ? f(d) : '';
    };
  }

  function getFormatter(formatType, str) {
    var fmt = dl.format,
        log = scale.type === 'log',
        domain, f;

    switch (formatType) {
      case NUMBER:
         domain = scale.domain();
         f = fmt.auto.number(domain, tickCount, str || (log ? '.1r' : null));
         return log ? logFilter(domain, tickCount, f) : f;
      case TIME: return (str ? fmt : fmt.auto).time(str);
      case UTC:  return (str ? fmt : fmt.auto).utc(str);
      default:   return String;
    }
  }
  
  function getTicks(format) {
    var major = tickValues || (scale.ticks ? scale.ticks(tickCount) : scale.domain()),
        minor = axisSubdivide(scale, major, tickSubdivide).map(ingest);
    major = major.map(function(d) { return (d = ingest(d), d.label = format(d.data), d); });
    return [major, minor];
  }

  axis.def = function() {
    if (!axisDef.type) axis_def(scale);

    var ticks = getTicks(getTickFormat());
    var tdata = title ? [title].map(ingest) : [];

    axisDef.marks[0].from = function() { return grid ? ticks[0] : []; };
    axisDef.marks[1].from = function() { return ticks[0]; };
    axisDef.marks[2].from = function() { return ticks[1]; };
    axisDef.marks[3].from = axisDef.marks[1].from;
    axisDef.marks[4].from = function() { return [1]; };
    axisDef.marks[5].from = function() { return tdata; };
    axisDef.offset = offset;
    axisDef.orient = orient;
    axisDef.layer = layer;

    return axisDef;
  };

  function axis_def(scale) {
    // setup scale mapping
    var newScale, oldScale, range;
    if (scale.type === ORDINAL) {
      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};
      oldScale = newScale;
    } else {
      newScale = {scale: scale.scaleName, offset: 0.5};
      oldScale = {scale: scale.scaleName+':prev', offset: 0.5};
    }
    range = axisScaleRange(scale);

    // setup axis marks
    dl.extend(m.gridLines, axisTicks(config));
    dl.extend(m.majorTicks, axisTicks(config));
    dl.extend(m.minorTicks, axisTicks(config));
    dl.extend(m.tickLabels, axisTickLabels(config));
    dl.extend(m.domain, axisDomain(config));
    dl.extend(m.title, axisTitle(config));
    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};
    m.gridLines.properties.enter.strokeOpacity = {value: config.axis.gridOpacity};

    // extend axis marks based on axis orientation
    axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);
    axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);
    axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);
    axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);

    axisDomainExtend(orient, m.domain, range, tickEndSize);
    axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset
    
    // add / override custom style properties
    dl.extend(m.gridLines.properties.update, gridLineStyle);
    dl.extend(m.majorTicks.properties.update, majorTickStyle);
    dl.extend(m.minorTicks.properties.update, minorTickStyle);
    dl.extend(m.tickLabels.properties.update, tickLabelStyle);
    dl.extend(m.domain.properties.update, domainStyle);
    dl.extend(m.title.properties.update, titleStyle);

    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];
    dl.extend(axisDef, {
      type: 'group',
      interactive: false,
      properties: { 
        enter: {
          encode: axisUpdate,
          scales: [scale.scaleName],
          signals: [], data: []
        },
        update: {
          encode: axisUpdate,
          scales: [scale.scaleName],
          signals: [], data: []
        }
      }
    });

    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    if (scale !== x) { scale = x; reset(); }
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    if (orient !== x) {
      orient = x in axisOrients ? x + '' : config.axis.orient;
      reset();
    }
    return axis;
  };

  axis.title = function(x) {
    if (!arguments.length) return title;
    if (title !== x) { title = x; reset(); }
    return axis;
  };

  axis.tickCount = function(x) {
    if (!arguments.length) return tickCount;
    tickCount = x;
    return axis;
  };

  axis.tickValues = function(x) {
    if (!arguments.length) return tickValues;
    tickValues = x;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormatString;
    if (tickFormatString !== x) {
      tickFormatString = x;
      reset();
    }
    return axis;
  };

  axis.tickFormatType = function(x) {
    if (!arguments.length) return tickFormatType;
    if (tickFormatType !== x) {
      tickFormatType = x;
      reset();
    }
    return axis;
  };

  axis.tickSize = function(x, y) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1,
        major = +x,
        minor = n > 1 ? +y : tickMajorSize,
        end   = n > 0 ? +arguments[n] : tickMajorSize;

    if (tickMajorSize !== major ||
        tickMinorSize !== minor ||
        tickEndSize !== end) {
      reset();
    }

    tickMajorSize = major;
    tickMinorSize = minor;
    tickEndSize = end;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };
  
  axis.offset = function(x) {
    if (!arguments.length) return offset;
    offset = dl.isObject(x) ? x : +x;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    if (tickPadding !== +x) { tickPadding = +x; reset(); }
    return axis;
  };

  axis.titleOffset = function(x) {
    if (!arguments.length) return titleOffset;
    if (titleOffset !== +x) { titleOffset = +x; reset(); }
    return axis;
  };

  axis.layer = function(x) {
    if (!arguments.length) return layer;
    if (layer !== x) { layer = x; reset(); }
    return axis;
  };

  axis.grid = function(x) {
    if (!arguments.length) return grid;
    if (grid !== x) { grid = x; reset(); }
    return axis;
  };

  axis.gridLineProperties = function(x) {
    if (!arguments.length) return gridLineStyle;
    if (gridLineStyle !== x) { gridLineStyle = x; }
    return axis;
  };

  axis.majorTickProperties = function(x) {
    if (!arguments.length) return majorTickStyle;
    if (majorTickStyle !== x) { majorTickStyle = x; }
    return axis;
  };

  axis.minorTickProperties = function(x) {
    if (!arguments.length) return minorTickStyle;
    if (minorTickStyle !== x) { minorTickStyle = x; }
    return axis;
  };

  axis.tickLabelProperties = function(x) {
    if (!arguments.length) return tickLabelStyle;
    if (tickLabelStyle !== x) { tickLabelStyle = x; }
    return axis;
  };

  axis.titleProperties = function(x) {
    if (!arguments.length) return titleStyle;
    if (titleStyle !== x) { titleStyle = x; }
    return axis;
  };

  axis.domainProperties = function(x) {
    if (!arguments.length) return domainStyle;
    if (domainStyle !== x) { domainStyle = x; }
    return axis;
  };
  
  axis.reset = function() { 
    reset(); 
    return axis; 
  };

  return axis;
}

var axisOrients = {top: 1, right: 1, bottom: 1, left: 1};

function axisSubdivide(scale, ticks, m) {
  var subticks = [];
  if (m && ticks.length > 1) {
    var extent = axisScaleExtent(scale.domain()),
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i < n) {
      for (j = m; --j > 0;) {
        if ((v = +ticks[i] - j * d) >= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}

function axisScaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function axisScaleRange(scale) {
  return scale.rangeExtent ?
    scale.rangeExtent() :
    axisScaleExtent(scale.range());
}

var axisAlign = {
  bottom: 'center',
  top: 'center',
  left: 'right',
  right: 'left'
};

var axisBaseline = {
  bottom: 'top',
  top: 'bottom',
  left: 'middle',
  right: 'middle'
};

function axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {
  size = Math.max(size, 0) + pad;
  if (orient === 'left' || orient === 'top') {
    size *= -1;
  }  
  if (orient === 'top' || orient === 'bottom') {
    dl.extend(labels.properties.enter, {
      x: oldScale,
      y: {value: size},
    });
    dl.extend(labels.properties.update, {
      x: newScale,
      y: {value: size},
      align: {value: 'center'},
      baseline: {value: axisBaseline[orient]}
    });
  } else {
    dl.extend(labels.properties.enter, {
      x: {value: size},
      y: oldScale,
    });
    dl.extend(labels.properties.update, {
      x: {value: size},
      y: newScale,
      align: {value: axisAlign[orient]},
      baseline: {value: 'middle'}
    });
  }
}

function axisTicksExtend(orient, ticks, oldScale, newScale, size) {
  var sign = (orient === 'left' || orient === 'top') ? -1 : 1;
  if (size === Infinity) {
    size = (orient === 'top' || orient === 'bottom') ?
      {field: {group: 'height', level: 2}, mult: -sign} :
      {field: {group: 'width',  level: 2}, mult: -sign};
  } else {
    size = {value: sign * size};
  }
  if (orient === 'top' || orient === 'bottom') {
    dl.extend(ticks.properties.enter, {
      x:  oldScale,
      y:  {value: 0},
      y2: size
    });
    dl.extend(ticks.properties.update, {
      x:  newScale,
      y:  {value: 0},
      y2: size
    });
    dl.extend(ticks.properties.exit, {
      x:  newScale,
    });        
  } else {
    dl.extend(ticks.properties.enter, {
      x:  {value: 0},
      x2: size,
      y:  oldScale
    });
    dl.extend(ticks.properties.update, {
      x:  {value: 0},
      x2: size,
      y:  newScale
    });
    dl.extend(ticks.properties.exit, {
      y:  newScale,
    });
  }
}

function axisTitleExtend(orient, title, range, offset) {
  var mid = ~~((range[0] + range[1]) / 2),
      sign = (orient === 'top' || orient === 'left') ? -1 : 1;
  
  if (orient === 'bottom' || orient === 'top') {
    dl.extend(title.properties.update, {
      x: {value: mid},
      y: {value: sign*offset},
      angle: {value: 0}
    });
  } else {
    dl.extend(title.properties.update, {
      x: {value: sign*offset},
      y: {value: mid},
      angle: {value: orient === 'left' ? -90 : 90}
    });
  }
}

function axisDomainExtend(orient, domain, range, size) {
  var path;
  if (orient === 'top' || orient === 'left') {
    size = -1 * size;
  }
  if (orient === 'bottom' || orient === 'top') {
    path = 'M' + range[0] + ',' + size + 'V0H' + range[1] + 'V' + size;
  } else {
    path = 'M' + size + ',' + range[0] + 'H0V' + range[1] + 'H' + size;
  }
  domain.properties.update.path = {value: path};
}

function axisUpdate(item, group, trans) {
  var o = trans ? {} : item,
      offset = item.mark.def.offset,
      orient = item.mark.def.orient,
      width  = group.width,
      height = group.height; // TODO fallback to global w,h?

  if (dl.isArray(offset)) {
    var ofx = offset[0],
        ofy = offset[1];

    switch (orient) {
      case 'left':   { Tuple.set(o, 'x', -ofx); Tuple.set(o, 'y', ofy); break; }
      case 'right':  { Tuple.set(o, 'x', width + ofx); Tuple.set(o, 'y', ofy); break; }
      case 'bottom': { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', height + ofy); break; }
      case 'top':    { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', -ofy); break; }
      default:       { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', ofy); }
    }
  } else {
    if (dl.isObject(offset)) {
      offset = -group.scale(offset.scale)(offset.value);
    }

    switch (orient) {
      case 'left':   { Tuple.set(o, 'x', -offset); Tuple.set(o, 'y', 0); break; }
      case 'right':  { Tuple.set(o, 'x', width + offset); Tuple.set(o, 'y', 0); break; }
      case 'bottom': { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', height + offset); break; }
      case 'top':    { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', -offset); break; }
      default:       { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', 0); }
    }
  }

  if (trans) trans.interpolate(item, o);
  return true;
}

function axisTicks(config) {
  return {
    type: 'rule',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        stroke: {value: config.axis.tickColor},
        strokeWidth: {value: config.axis.tickWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function axisTickLabels(config) {
  return {
    type: 'text',
    interactive: true,
    key: 'data',
    properties: {
      enter: {
        fill: {value: config.axis.tickLabelColor},
        font: {value: config.axis.tickLabelFont},
        fontSize: {value: config.axis.tickLabelFontSize},
        opacity: {value: 1e-6},
        text: {field: 'label'}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function axisTitle(config) {
  return {
    type: 'text',
    interactive: true,
    properties: {
      enter: {
        font: {value: config.axis.titleFont},
        fontSize: {value: config.axis.titleFontSize},
        fontWeight: {value: config.axis.titleFontWeight},
        fill: {value: config.axis.titleColor},
        align: {value: 'center'},
        baseline: {value: 'middle'},
        text: {field: 'data'}
      },
      update: {}
    }
  };
}

function axisDomain(config) {
  return {
    type: 'path',
    interactive: false,
    properties: {
      enter: {
        x: {value: 0.5},
        y: {value: 0.5},
        stroke: {value: config.axis.axisColor},
        strokeWidth: {value: config.axis.axisWidth}
      },
      update: {}
    }
  };
}

module.exports = axs;
},{"../parse/mark":102,"datalib":24,"vega-dataflow":43}],119:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Gradient = require('vega-scenegraph').Gradient,
    parseProperties = require('../parse/properties'),
    parseMark = require('../parse/mark');

function lgnd(model) {
  var size = null,
      shape = null,
      fill = null,
      stroke = null,
      spacing = null,
      values = null,
      format = null,
      formatString = null,
      config = model.config(),
      title,
      orient = 'right',
      offset = config.legend.offset,
      padding = config.legend.padding,
      tickArguments = [5],
      legendStyle = {},
      symbolStyle = {},
      gradientStyle = {},
      titleStyle = {},
      labelStyle = {},
      m = { // Legend marks as references for updates
        titles:  {},
        symbols: {},
        labels:  {},
        gradient: {}
      };

  var legend = {},
      legendDef = {};

  function reset() { legendDef.type = null; }
  function ingest(d, i) { return {data: d, index: i}; }

  legend.def = function() {
    var scale = size || shape || fill || stroke;
    
    format = !formatString ? null : ((scale.type === 'time') ?
      dl.format.time(formatString) : dl.format.number(formatString));
    
    if (!legendDef.type) {
      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type) ?
        quantDef(scale) : ordinalDef(scale);      
    }
    legendDef.orient = orient;
    legendDef.offset = offset;
    legendDef.padding = padding;
    return legendDef;
  };

  function discrete(type) {
    return type==='ordinal' || type==='quantize' ||
           type==='quantile' || type==='threshold';
  }

  function ordinalDef(scale) {
    var def = o_legend_def(size, shape, fill, stroke);

    // generate data
    var data = (values == null ?
      (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :
      values).map(ingest);
    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;
    
    // determine spacing between legend entries
    var fs, range, offset, pad=5, domain = d3.range(data.length);
    if (size) {
      range = data.map(function(x) { return Math.sqrt(size(x.data)); });
      offset = d3.max(range);
      range = range.reduce(function(a,b,i,z) {
          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;
          return (a[i] += b/2, a); }, [0]).map(Math.round);
    } else {
      offset = Math.round(Math.sqrt(config.legend.symbolSize));
      range = spacing ||
        (fs = labelStyle.fontSize) && (fs.value + pad) ||
        (config.legend.labelFontSize + pad);
      range = domain.map(function(d,i) {
        return Math.round(offset/2 + i*range);
      });
    }

    // account for padding and title size
    var sz = padding, ts;
    if (title) {
      ts = titleStyle.fontSize;
      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);
    }
    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;
    
    // build scale for label layout
    var scaleSpec = {
      name: 'legend',
      type: 'ordinal',
      points: true,
      domain: domain,
      range: range
    };
    
    // update legend def
    var tdata = (title ? [title] : []).map(ingest);
    data.forEach(function(d) {
      d.label = fmt(d.data);
      d.offset = offset;
    });
    def.scales = [ scaleSpec ];
    def.marks[0].from = function() { return tdata; };
    def.marks[1].from = function() { return data; };
    def.marks[2].from = def.marks[1].from;

    return def;
  }

  function o_legend_def(size, shape, fill, stroke) {
    // setup legend marks
    var titles  = dl.extend(m.titles, vg_legendTitle(config)),
        symbols = dl.extend(m.symbols, vg_legendSymbols(config)),
        labels  = dl.extend(m.labels, vg_vLegendLabels(config));

    // extend legend marks
    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);
    
    // add / override custom style properties
    dl.extend(titles.properties.update,  titleStyle);
    dl.extend(symbols.properties.update, symbolStyle);
    dl.extend(labels.properties.update,  labelStyle);

    // padding from legend border
    titles.properties.enter.x.value += padding;
    titles.properties.enter.y.value += padding;
    labels.properties.enter.x.offset += padding + 1;
    symbols.properties.enter.x.offset = padding + 1;
    labels.properties.update.x.offset += padding + 1;
    symbols.properties.update.x.offset = padding + 1;

    dl.extend(legendDef, {
      type: 'group',
      interactive: false,
      properties: {
        enter: parseProperties(model, 'group', legendStyle),
        vg_legendPosition: {
          encode: vg_legendPosition,
          signals: [], scales:[], data: [], fields: []
        }
      }
    });

    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });
    return legendDef;
  }

  function quantDef(scale) {
    var def = q_legend_def(scale),
        dom = scale.domain(),
        data = (values == null ?
          (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :
          values).map(ingest),
        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,
        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;

    // build scale for label layout
    var layoutSpec = {
      name: 'legend',
      type: scale.type,
      round: true,
      zero: false,
      domain: [dom[0], dom[dom.length-1]],
      range: [padding, width+padding]
    };
    if (scale.type==='pow') layoutSpec.exponent = scale.exponent();
    
    // update legend def
    var tdata = (title ? [title] : []).map(ingest);
    data.forEach(function(d,i) {
      d.label = fmt(d.data);
      d.align = i==(data.length-1) ? 'right' : i===0 ? 'left' : 'center';
    });
    def.scales = [ layoutSpec ];
    def.marks[0].from = function() { return tdata; };
    def.marks[1].from = function() { return [1]; };
    def.marks[2].from = function() { return data; };
    return def;
  }
  
  function q_legend_def(scale) {
    // setup legend marks
    var titles = dl.extend(m.titles, vg_legendTitle(config)),
        gradient = dl.extend(m.gradient, vg_legendGradient(config)),
        labels = dl.extend(m.labels, vg_hLegendLabels(config)),
        grad = new Gradient();

    // setup color gradient
    var dom = scale.domain(),
        min = dom[0],
        max = dom[dom.length-1],
        f = scale.copy().domain([min, max]).range([0,1]);
        
    var stops = (scale.type !== 'linear' && scale.ticks) ?
      scale.ticks.call(scale, 15) : dom;
    if (min !== stops[0]) stops.unshift(min);
    if (max !== stops[stops.length-1]) stops.push(max);

    for (var i=0, n=stops.length; i<n; ++i) {
      grad.stop(f(stops[i]), scale(stops[i]));
    }
    gradient.properties.enter.fill = {value: grad};

    // add / override custom style properties
    dl.extend(titles.properties.update, titleStyle);
    dl.extend(gradient.properties.update, gradientStyle);
    dl.extend(labels.properties.update, labelStyle);

    // account for gradient size
    var gp = gradient.properties, gh = gradientStyle.height,
        hh = (gh && gh.value) || gp.enter.height.value;
    labels.properties.enter.y.value = hh;
    labels.properties.update.y.value = hh;

    // account for title size as needed
    if (title) {
      var tp = titles.properties, fs = titleStyle.fontSize,
          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);
      gradient.properties.enter.y.value += sz;
      labels.properties.enter.y.value += sz;
      gradient.properties.update.y.value += sz;
      labels.properties.update.y.value += sz;
    }
    
    // padding from legend border
    titles.properties.enter.x.value += padding;
    titles.properties.enter.y.value += padding;
    gradient.properties.enter.x.value += padding;
    gradient.properties.enter.y.value += padding;
    labels.properties.enter.y.value += padding;
    gradient.properties.update.x.value += padding;
    gradient.properties.update.y.value += padding;
    labels.properties.update.y.value += padding;

    dl.extend(legendDef, {
      type: 'group',
      interactive: false,
      properties: {
        enter: parseProperties(model, 'group', legendStyle),
        vg_legendPosition: {
          encode: vg_legendPosition,
          signals: [], scales: [], data: [], fields: []
        }
      }
    });

    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });
    return legendDef;
  }

  legend.size = function(x) {
    if (!arguments.length) return size;
    if (size !== x) { size = x; reset(); }
    return legend;
  };

  legend.shape = function(x) {
    if (!arguments.length) return shape;
    if (shape !== x) { shape = x; reset(); }
    return legend;
  };

  legend.fill = function(x) {
    if (!arguments.length) return fill;
    if (fill !== x) { fill = x; reset(); }
    return legend;
  };
  
  legend.stroke = function(x) {
    if (!arguments.length) return stroke;
    if (stroke !== x) { stroke = x; reset(); }
    return legend;
  };

  legend.title = function(x) {
    if (!arguments.length) return title;
    if (title !== x) { title = x; reset(); }
    return legend;
  };

  legend.format = function(x) {
    if (!arguments.length) return formatString;
    if (formatString !== x) {
      formatString = x;
      reset();
    }
    return legend;
  };

  legend.spacing = function(x) {
    if (!arguments.length) return spacing;
    if (spacing !== +x) { spacing = +x; reset(); }
    return legend;
  };

  legend.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x in vg_legendOrients ? x + '' : config.legend.orient;
    return legend;
  };

  legend.offset = function(x) {
    if (!arguments.length) return offset;
    offset = +x;
    return legend;
  };

  legend.values = function(x) {
    if (!arguments.length) return values;
    values = x;
    return legend;
  };

  legend.legendProperties = function(x) {
    if (!arguments.length) return legendStyle;
    legendStyle = x;
    return legend;
  };

  legend.symbolProperties = function(x) {
    if (!arguments.length) return symbolStyle;
    symbolStyle = x;
    return legend;
  };

  legend.gradientProperties = function(x) {
    if (!arguments.length) return gradientStyle;
    gradientStyle = x;
    return legend;
  };

  legend.labelProperties = function(x) {
    if (!arguments.length) return labelStyle;
    labelStyle = x;
    return legend;
  };
  
  legend.titleProperties = function(x) {
    if (!arguments.length) return titleStyle;
    titleStyle = x;
    return legend;
  };

  legend.reset = function() { 
    reset(); 
    return legend;
  };

  return legend;
}

var vg_legendOrients = {right: 1, left: 1};

function vg_legendPosition(item, group, trans, db, signals, predicates) {
  var o = trans ? {} : item, gx,
      offset = item.mark.def.offset,
      orient = item.mark.def.orient,
      pad    = item.mark.def.padding * 2,
      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),
      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),
      pos = group._legendPositions || 
        (group._legendPositions = {right: 0.5, left: 0.5});

  o.x = 0.5;
  o.width = lw;
  o.y = pos[orient];
  pos[orient] += (o.height = lh);

  // HACK: use to estimate group bounds during animated transition
  if (!trans && group.bounds) {
    group.bounds.delta = group.bounds.x2 - group.width;
  }

  switch (orient) {
    case 'left':  {
      gx = group.bounds ? group.bounds.x1 : 0;
      o.x += gx - offset - lw;
      break;
    }
    case 'right': {
      gx = group.width + (group.bounds && trans ? group.bounds.delta : 0);
      o.x += gx + offset;
      break;
    }
  }
  
  if (trans) trans.interpolate(item, o);
  var enc = item.mark.def.properties.enter.encode;
  enc.call(enc, item, group, trans, db, signals, predicates);
  return true;
}

function vg_legendSymbolExtend(mark, size, shape, fill, stroke) {
  var e = mark.properties.enter,
      u = mark.properties.update;
  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: 'data'};
  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: 'data'};
  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: 'data'};
  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: 'data'};
}

function vg_legendTitle(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {value: 0},
        y: {value: 0},
        fill: {value: cfg.titleColor},
        font: {value: cfg.titleFont},
        fontSize: {value: cfg.titleFontSize},
        fontWeight: {value: cfg.titleFontWeight},
        baseline: {value: 'top'},
        text: {field: 'data'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function vg_legendSymbols(config) {
  var cfg = config.legend;
  return {
    type: 'symbol',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {field: 'offset', mult: 0.5},
        y: {scale: 'legend', field: 'index'},
        shape: {value: cfg.symbolShape},
        size: {value: cfg.symbolSize},
        stroke: {value: cfg.symbolColor},
        strokeWidth: {value: cfg.symbolStrokeWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {field: 'offset', mult: 0.5},
        y: {scale: 'legend', field: 'index'},
        opacity: {value: 1}
      }
    }
  };
}

function vg_vLegendLabels(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {field: 'offset', offset: 5},
        y: {scale: 'legend', field: 'index'},
        fill: {value: cfg.labelColor},
        font: {value: cfg.labelFont},
        fontSize: {value: cfg.labelFontSize},
        align: {value: cfg.labelAlign},
        baseline: {value: cfg.labelBaseline},
        text: {field: 'label'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        opacity: {value: 1},
        x: {field: 'offset', offset: 5},
        y: {scale: 'legend', field: 'index'},
      }
    }
  };
}

function vg_legendGradient(config) {
  var cfg = config.legend;
  return {
    type: 'rect',
    interactive: false,
    properties: {
      enter: {
        x: {value: 0},
        y: {value: 0},
        width: {value: cfg.gradientWidth},
        height: {value: cfg.gradientHeight},
        stroke: {value: cfg.gradientStrokeColor},
        strokeWidth: {value: cfg.gradientStrokeWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {value: 0},
        y: {value: 0},
        opacity: {value: 1}
      }
    }
  };
}

function vg_hLegendLabels(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {scale: 'legend', field: 'data'},
        y: {value: 20},
        dy: {value: 2},
        fill: {value: cfg.labelColor},
        font: {value: cfg.labelFont},
        fontSize: {value: cfg.labelFontSize},
        align: {field: 'align'},
        baseline: {value: 'top'},
        text: {field: 'label'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {scale: 'legend', field: 'data'},
        y: {value: 20},
        opacity: {value: 1}
      }
    }
  };
}

module.exports = lgnd;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../parse/mark":102,"../parse/properties":107,"datalib":24,"vega-scenegraph":50}],120:[function(require,module,exports){
module.exports = function visit(node, func) {
  var i, n, s, m, items;
  if (func(node)) return true;

  var sets = ['items', 'axisItems', 'legendItems'];
  for (s=0, m=sets.length; s<m; ++s) {
    if ((items = node[sets[s]])) {
      for (i=0, n=items.length; i<n; ++i) {
        if (visit(items[i], func)) return true;
      }
    }
  }
};
},{}],121:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    log = require('vega-logging'),
    ChangeSet = df.ChangeSet,
    Tuple = df.Tuple,
    Deps = df.Dependencies,
    Transform = require('./Transform'),
    Facetor = require('./Facetor');

function Aggregate(graph) {
  Transform.prototype.init.call(this, graph);

  Transform.addParameters(this, {
    groupby: {type: 'array<field>'},
    summarize: {
      type: 'custom', 
      set: function(summarize) {
        var signalDeps = {},
            tx = this._transform,
            i, len, f, fields, name, ops;

        if (!dl.isArray(fields = summarize)) { // Object syntax from dl
          fields = [];
          for (name in summarize) {
            ops = dl.array(summarize[name]);
            fields.push({field: name, ops: ops});
          }
        }

        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }

        for (i=0, len=fields.length; i<len; ++i) {
          f = fields[i];
          if (f.field.signal) { signalDeps[f.field.signal] = 1; }
          dl.array(f.ops).forEach(sg);
          dl.array(f.as).forEach(sg);
        }

        tx._fields = fields;
        tx._aggr = null;
        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));
        return tx;
      }
    }
  });

  this._aggr  = null; // dl.Aggregator
  this._input = null; // Used by Facetor._on_keep.
  this._args  = null; // To cull re-computation.
  this._fields = [];
  this._out = [];

  this._type = TYPES.TUPLE; 
  this._acc = {groupby: dl.true, value: dl.true};

  return this.router(true).produces(true);
}

var prototype = (Aggregate.prototype = Object.create(Transform.prototype));
prototype.constructor = Aggregate;

var TYPES = Aggregate.TYPES = {
  VALUE: 1, 
  TUPLE: 2, 
  MULTI: 3
};

Aggregate.VALID_OPS = [
  'values', 'count', 'valid', 'missing', 'distinct', 
  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', 
  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', 
  'argmin', 'argmax'
];

prototype.type = function(type) { 
  return (this._type = type, this); 
};

prototype.accessors = function(groupby, value) {
  var acc = this._acc;
  acc.groupby = dl.$(groupby) || dl.true;
  acc.value = dl.$(value) || dl.true;
};

prototype.aggr = function() {
  if (this._aggr) return this._aggr;

  var g = this._graph,
      hasGetter = false,
      args = [],
      groupby = this.param('groupby').field,
      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };

  // Prepare summarize fields.
  var fields = this._fields.map(function(f) {
    var field = {
      name: value(f.field),
      as:   dl.array(f.as),
      ops:  dl.array(value(f.ops)).map(value),
      get:  f.get
    };
    hasGetter = hasGetter || field.get != null;
    args.push(field.name);
    return field;
  });

  // If there is an arbitrary getter, all bets are off.
  // Otherwise, we can check argument fields to cull re-computation.
  groupby.forEach(function(g) {
    if (g.get) hasGetter = true;
    args.push(g.name || g);
  });
  this._args = hasGetter || !fields.length ? null : args;

  if (!fields.length) fields = {'*': 'values'};

  // Instatiate our aggregator instance.
  // Facetor is a special subclass that can facet into data pipelines.
  var aggr = this._aggr = new Facetor()
    .groupby(groupby)
    .stream(true)
    .summarize(fields);

  // Collect output fields sets by this aggregate.
  this._out = getFields(aggr);

  // If we are processing tuples, key them by '_id'.
  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }

  return aggr;
};

function getFields(aggr) {
  // Collect the output fields set by this aggregate.
  var f = [], i, n, j, m, dims, vals, meas;

  dims = aggr._dims;
  for (i=0, n=dims.length; i<n; ++i) {
    f.push(dims[i].name);
  }

  vals = aggr._aggr;
  for (i=0, n=vals.length; i<n; ++i) {
    meas = vals[i].measures.fields;
    for (j=0, m=meas.length; j<m; ++j) {
      f.push(meas[j]);
    }
  }

  return f;
}

prototype.transform = function(input, reset) {
  log.debug(input, ['aggregate']);
  this._input = input; // Used by Facetor._on_keep.

  var output = ChangeSet.create(input),
      aggr = this.aggr(),
      out = this._out,
      args = this._args,
      reeval = true,
      p = Tuple.prev,
      add, rem, mod, i;

  // Upon reset, retract prior tuples and re-initialize.
  if (reset) {
    output.rem.push.apply(output.rem, aggr.result());
    aggr.clear();
    this._aggr = null;
    aggr = this.aggr();
  }

  // Get update methods according to input type.
  if (this._type === TYPES.TUPLE) {
    add = function(x) { aggr._add(x); Tuple.prev_init(x); };
    rem = function(x) { aggr._rem(p(x)); };
    mod = function(x) { aggr._mod(x, p(x)); };
  } else {
    var gby = this._acc.groupby,
        val = this._acc.value,
        get = this._type === TYPES.VALUE ? val : function(x) {
          return { _id: x._id, groupby: gby(x), value: val(x) };
        };
    add = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };
    rem = function(x) { aggr._rem(get(p(x))); };
    mod = function(x) { aggr._mod(get(x), get(p(x))); };
  }

  input.add.forEach(add);
  if (reset) {
    // A signal change triggered reflow. Add everything.
    // No need for rem, we cleared the aggregator.
    input.mod.forEach(add);
  } else {
    input.rem.forEach(rem);

    // If possible, check argument fields to see if we need to re-process mods.
    if (args) for (i=0, reeval=false; i<args.length; ++i) {
      if (input.fields[args[i]]) { reeval = true; break; }
    }
    if (reeval) input.mod.forEach(mod);
  }

  // Indicate output fields and return aggregate tuples.
  for (i=0; i<out.length; ++i) {
    output.fields[out[i]] = 1;
  }
  return aggr.changes(output);
};

module.exports = Aggregate;
},{"./Facetor":127,"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],122:[function(require,module,exports){
var Base = require('./Transform').prototype;

function BatchTransform() {
  // Nearest appropriate collector. 
  // Set by the dataflow Graph during connection.
  this._collector = null; 
}

var prototype = (BatchTransform.prototype = Object.create(Base));
prototype.constructor = BatchTransform;

prototype.init = function(graph) {
  Base.init.call(this, graph);
  return this.batch(true);
};

prototype.transform = function(input) {
  return this.batchTransform(input, this._collector.data());
};

prototype.batchTransform = function(/* input, data */) {
};

module.exports = BatchTransform;
},{"./Transform":140}],123:[function(require,module,exports){
var bins = require('datalib').bins,
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Bin(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field: {type: 'field'},
    min: {type: 'value'},
    max: {type: 'value'},
    base: {type: 'value', default: 10},
    maxbins: {type: 'value', default: 20},
    step: {type: 'value'},
    steps: {type: 'value'},
    minstep: {type: 'value'},
    div: {type: 'array<value>', default: [5, 2]}
  });

  this._output = {bin: 'bin'};
  return this.mutates(true);
}

var prototype = (Bin.prototype = Object.create(Transform.prototype));
prototype.constructor = Bin;

prototype.transform = function(input) {
  log.debug(input, ['binning']);

  var output  = this._output.bin,
      step    = this.param('step'),
      steps   = this.param('steps'),
      minstep = this.param('minstep'),
      get     = this.param('field').accessor,
      opt = {
        min: this.param('min'),
        max: this.param('max'),
        base: this.param('base'),
        maxbins: this.param('maxbins'),
        div: this.param('div')
      };

  if (step) opt.step = step;
  if (steps) opt.steps = steps;
  if (minstep) opt.minstep = minstep;
  var b = bins(opt);

  function update(d) {
    var v = get(d);
    v = v == null ? null
      : b.start + b.step * ~~((v - b.start) / b.step);
    Tuple.set(d, output, v);
  }
  input.add.forEach(update);
  input.mod.forEach(update);
  input.rem.forEach(update);

  input.fields[output] = 1;
  return input;
};

module.exports = Bin;
},{"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],124:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function CountPattern(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field:     {type: 'field', default: 'data'},
    pattern:   {type: 'value', default: '[\\w\']+'},
    case:      {type: 'value', default: 'lower'},
    stopwords: {type: 'value', default: ''}
  });

  this._output = {text: 'text', count: 'count'};

  return this.router(true).produces(true);
}

var prototype = (CountPattern.prototype = Object.create(Transform.prototype));
prototype.constructor = CountPattern;

prototype.transform = function(input, reset) {
  log.debug(input, ['countpattern']);

  var get = this.param('field').accessor,
      pattern = this.param('pattern'),
      stop = this.param('stopwords'),
      rem = false;

  // update parameters
  if (this._stop !== stop) {
    this._stop = stop;
    this._stop_re = new RegExp('^' + stop + '$', 'i');
    reset = true;
  }

  if (this._pattern !== pattern) {
    this._pattern = pattern;
    this._match = new RegExp(this._pattern, 'g');
    reset = true;
  }

  if (reset) this._counts = {};

  function curr(t) { return (Tuple.prev_init(t), get(t)); }
  function prev(t) { return get(Tuple.prev(t)); }

  this._add(input.add, curr);
  if (!reset) this._rem(input.rem, prev);
  if (reset || (rem = input.fields[get.field])) {
    if (rem) this._rem(input.mod, prev);
    this._add(input.mod, curr);
  }

  // generate output tuples
  return this._changeset(input);
};

prototype._changeset = function(input) {
  var counts = this._counts,
      tuples = this._tuples || (this._tuples = {}),
      change = df.ChangeSet.create(input),
      out = this._output, w, t, c;

  for (w in counts) {
    t = tuples[w];
    c = counts[w] || 0;
    if (!t && c) {
      tuples[w] = (t = Tuple.ingest({}));
      t[out.text] = w;
      t[out.count] = c;
      change.add.push(t);
    } else if (c === 0) {
      if (t) change.rem.push(t);
      delete counts[w];
      delete tuples[w];
    } else if (t[out.count] !== c) {
      Tuple.set(t, out.count, c);
      change.mod.push(t);
    }
  }
  return change;
};

prototype._tokenize = function(text) {
  switch (this.param('case')) {
    case 'upper': text = text.toUpperCase(); break;
    case 'lower': text = text.toLowerCase(); break;
  }
  return text.match(this._match);
};

prototype._add = function(tuples, get) {
  var counts = this._counts,
      stop = this._stop_re,
      tok, i, j, t;

  for (j=0; j<tuples.length; ++j) {
    tok = this._tokenize(get(tuples[j]));
    for (i=0; i<tok.length; ++i) {
      if (!stop.test(t=tok[i])) {
        counts[t] = 1 + (counts[t] || 0);
      }
    }
  }
};

prototype._rem = function(tuples, get) {
  var counts = this._counts,
      stop = this._stop_re,
      tok, i, j, t;

  for (j=0; j<tuples.length; ++j) {
    tok = this._tokenize(get(tuples[j]));
    for (i=0; i<tok.length; ++i) {
      if (!stop.test(t=tok[i])) {
        counts[t] -= 1;
      }
    }
  }
};

module.exports = CountPattern;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],125:[function(require,module,exports){
var df = require('vega-dataflow'),
    ChangeSet = df.ChangeSet,
    Tuple = df.Tuple,
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Cross(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    with: {type: 'data'},
    diagonal: {type: 'value', default: 'true'},
    filter: {type: 'expr'}
  });

  this._output = {'left': 'a', 'right': 'b'};
  this._lastRem  = null; // Most recent stamp that rem occured. 
  this._lastWith = null; // Last time we crossed w/withds.
  this._ids   = {};
  this._cache = {};

  return this.router(true).produces(true);
}

var prototype = (Cross.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Cross;

// Each cached incoming tuple also has a stamp to track if we need to do
// lazy filtering of removed tuples.
function cache(x, t) {
  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};
  c.c.push(t);
}

function add(output, left, data, diag, test, x) {
  var i = 0, len = data.length, t = {}, y, id;

  for (; i<len; ++i) {
    y = data[i];
    id = left ? x._id+'_'+y._id : y._id+'_'+x._id;
    if (this._ids[id]) continue;
    if (x._id == y._id && !diag) continue;

    t[this._output.left]  = left ? x : y;
    t[this._output.right] = left ? y : x;

    // Only ingest a tuple if we keep it around.
    if (!test || test(t)) {
      output.add.push(t=Tuple.ingest(t));
      cache.call(this, x, t);
      cache.call(this, y, t);
      this._ids[id] = 1;
      t = {};
    }    
  }
}

function mod(output, left, x) {
  var cross = this,
      c = this._cache[x._id];

  if (this._lastRem > c.s) {  // Removed tuples haven't been filtered yet
    c.c = c.c.filter(function(y) {
      var t = y[cross._output[left ? 'right' : 'left']];
      return cross._cache[t._id] !== null;
    });
    c.s = this._lastRem;
  }

  output.mod.push.apply(output.mod, c.c);
}

function rem(output, x) {
  output.rem.push.apply(output.rem, this._cache[x._id].c);
  this._cache[x._id] = null;
  this._lastRem = this._stamp;
}

function upFields(input, output) {
  if (input.add.length || input.rem.length) {
    output.fields[this._output.left]  = 1; 
    output.fields[this._output.right] = 1;
  }
}

prototype.batchTransform = function(input, data) {
  log.debug(input, ['crossing']);

  var w = this.param('with'),
      f = this.param('filter'),
      diag = this.param('diagonal'),
      graph = this._graph,
      signals = graph.values(SIGNALS, this.dependency(SIGNALS)),
      test = f ? function(x) {return f(x, null, signals); } : null,
      selfCross = (!w.name),
      woutput = selfCross ? input : w.source.last(),
      wdata   = selfCross ? data : w.source.values(),
      output  = ChangeSet.create(input),
      r = rem.bind(this, output);

  input.rem.forEach(r);
  input.add.forEach(add.bind(this, output, true, wdata, diag, test));

  if (!selfCross && woutput.stamp > this._lastWith) {
    woutput.rem.forEach(r);
    woutput.add.forEach(add.bind(this, output, false, data, diag, test));
    woutput.mod.forEach(mod.bind(this, output, false));
    upFields.call(this, woutput, output);
    this._lastWith = woutput.stamp;
  }

  // Mods need to come after all removals have been run.
  input.mod.forEach(mod.bind(this, output, true));
  upFields.call(this, input, output);

  return output;
};

module.exports = Cross;
},{"./BatchTransform":122,"./Transform":140,"vega-dataflow":43,"vega-logging":49}],126:[function(require,module,exports){
var Transform = require('./Transform'),
    Aggregate = require('./Aggregate');

function Facet(graph) {
  Transform.addParameters(this, {
    transform: {
      type: "custom",
      set: function(pipeline) {
        return (this._transform._pipeline = pipeline, this._transform);
      },
      get: function() {
        var parse = require('../parse/transforms'),
            facet = this._transform;
        return facet._pipeline.map(function(t) {
          return parse(facet._graph, t);
        });
      }      
    }
  });

  this._pipeline = [];
  return Aggregate.call(this, graph);
}

var prototype = (Facet.prototype = Object.create(Aggregate.prototype));
prototype.constructor = Facet;

prototype.aggr = function() {
  return Aggregate.prototype.aggr.call(this).facet(this);
};

module.exports = Facet;
},{"../parse/transforms":111,"./Aggregate":121,"./Transform":140}],127:[function(require,module,exports){
var dl = require('datalib'),
    Aggregator = dl.Aggregator,
    Base = Aggregator.prototype,
    df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    facetID = 0;

function Facetor() {
  Aggregator.call(this);
  this._facet = null;
  this._facetID = ++facetID;
}

var prototype = (Facetor.prototype = Object.create(Base));
prototype.constructor = Facetor;

prototype.facet = function(f) {
  return arguments.length ? (this._facet = f, this) : this._facet;
};

prototype._ingest = function(t) { 
  return Tuple.ingest(t, null);
};

prototype._assign = Tuple.set;

function disconnect_cell(facet) {
  log.debug({}, ['disconnecting cell', this.tuple._id]);
  var pipeline = this.ds.pipeline();
  facet.removeListener(pipeline[0]);
  facet._graph.removeListener(pipeline[0]);
  facet._graph.disconnect(pipeline);
}

prototype._newcell = function(x, key) {
  var cell  = Base._newcell.call(this, x, key),
      facet = this._facet;

  if (facet) {
    var graph = facet._graph,
        tuple = cell.tuple,
        pipeline = facet.param('transform');
    cell.ds = graph.data(tuple._facetID, pipeline, tuple);
    cell.disconnect = disconnect_cell;
    facet.addListener(pipeline[0]);
  }

  return cell;
};

prototype._newtuple = function(x, key) {
  var t = Base._newtuple.call(this, x);
  if (this._facet) {
    Tuple.set(t, 'key', key);
    Tuple.set(t, '_facetID', this._facetID + '_' + key);
  }
  return t;
};

prototype.clear = function() {
  if (this._facet) {
    for (var k in this._cells) {
      this._cells[k].disconnect(this._facet);
    }
  }
  return Base.clear.call(this);
};

prototype._on_add = function(x, cell) {
  if (this._facet) cell.ds._input.add.push(x);
};

prototype._on_rem = function(x, cell) {
  if (this._facet) cell.ds._input.rem.push(x);
};

prototype._on_mod = function(x, prev, cell0, cell1) {
  if (this._facet) { // Propagate tuples
    if (cell0 === cell1) {
      cell0.ds._input.mod.push(x);
    } else {
      cell0.ds._input.rem.push(x);
      cell1.ds._input.add.push(x);
    }
  }
};

prototype._on_drop = function(cell) {
  if (this._facet) cell.disconnect(this._facet);
};

prototype._on_keep = function(cell) {
  // propagate sort, signals, fields, etc.
  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);
};

module.exports = Facetor;
},{"datalib":24,"vega-dataflow":43,"vega-logging":49}],128:[function(require,module,exports){
var df = require('vega-dataflow'),
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Filter(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {test: {type: 'expr'}});

  this._skip = {};
  return this.router(true);
}

var prototype = (Filter.prototype = Object.create(Transform.prototype));
prototype.constructor = Filter;

prototype.transform = function(input) {
  log.debug(input, ['filtering']);

  var output = df.ChangeSet.create(input),
      graph = this._graph,
      skip = this._skip,
      test = this.param('test'),
      signals = graph.values(SIGNALS, this.dependency(SIGNALS));

  input.rem.forEach(function(x) {
    if (skip[x._id] !== 1) output.rem.push(x);
    else skip[x._id] = 0;
  });

  input.add.forEach(function(x) {
    if (test(x, null, signals)) output.add.push(x);
    else skip[x._id] = 1;
  });

  input.mod.forEach(function(x) {
    var b = test(x, null, signals),
        s = (skip[x._id] === 1);
    if (b && s) {
      skip[x._id] = 0;
      output.add.push(x);
    } else if (b && !s) {
      output.mod.push(x);
    } else if (!b && s) {
      // do nothing, keep skip true
    } else { // !b && !s
      output.rem.push(x);
      skip[x._id] = 1;
    }
  });

  return output;
};

module.exports = Filter;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],129:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Fold(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    fields: {type: 'array<field>'} 
  });

  this._output = {key: 'key', value: 'value'};
  this._cache = {};

  return this.router(true).produces(true);
}

var prototype = (Fold.prototype = Object.create(Transform.prototype));
prototype.constructor = Fold;

prototype._reset = function(input, output) { 
  for (var id in this._cache) {
    output.rem.push.apply(output.rem, this._cache[id]);
  }
  this._cache = {};
};

prototype._tuple = function(x, i, len) {
  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));
  return list[i] ? Tuple.rederive(x, list[i]) : (list[i] = Tuple.derive(x));
};

prototype._fn = function(data, on, out) {
  var i, j, n, m, d, t;
  for (i=0, n=data.length; i<n; ++i) {
    d = data[i];
    for (j=0, m=on.field.length; j<m; ++j) {
      t = this._tuple(d, j, m);  
      Tuple.set(t, this._output.key, on.field[j]);
      Tuple.set(t, this._output.value, on.accessor[j](d));
      out.push(t);
    }      
  }
};

prototype.transform = function(input, reset) {
  log.debug(input, ['folding']);

  var fold = this,
      on = this.param('fields'),
      output = df.ChangeSet.create(input);

  if (reset) this._reset(input, output);

  this._fn(input.add, on, output.add);
  this._fn(input.mod, on, reset ? output.add : output.mod);
  input.rem.forEach(function(x) {
    output.rem.push.apply(output.rem, fold._cache[x._id]);
    fold._cache[x._id] = null;
  });

  // If we're only propagating values, don't mark key/value as updated.
  if (input.add.length || input.rem.length || 
      on.field.some(function(f) { return !!input.fields[f]; })) {
    output.fields[this._output.key] = 1;
    output.fields[this._output.value] = 1;
  }
  return output;
};

module.exports = Fold;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],130:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    df = require('vega-dataflow'),
    Tuple = df.Tuple,
    ChangeSet = df.ChangeSet,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Force(graph) {
  Transform.prototype.init.call(this, graph);

  this._prev = null;
  this._interactive = false;
  this._setup = true;
  this._nodes  = [];
  this._links = [];
  this._layout = d3.layout.force();

  Transform.addParameters(this, {
    size: {type: 'array<value>', default: [500, 500]},
    bound: {type: 'value', default: true},
    links: {type: 'data'},

    // TODO: for now force these to be value params only (pun-intended)
    // Can update to include fields after Parameter refactoring.
    linkStrength: {type: 'value', default: 1},
    linkDistance: {type: 'value', default: 20},
    charge: {type: 'value', default: -30},

    chargeDistance: {type: 'value', default: Infinity},
    friction: {type: 'value', default: 0.9},
    theta: {type: 'value', default: 0.8},
    gravity: {type: 'value', default: 0.1},
    alpha: {type: 'value', default: 0.1},
    iterations: {type: 'value', default: 500},

    interactive: {type: 'value', default: this._interactive},    
    active: {type: 'value', default: this._prev},
    fixed: {type: 'data'}
  });

  this._output = {
    'x': 'layout_x',
    'y': 'layout_y'
  };

  return this.mutates(true);
}

var prototype = (Force.prototype = Object.create(Transform.prototype));
prototype.constructor = Force;

prototype.transform = function(nodeInput, reset) {
  log.debug(nodeInput, ['force']);
  reset = reset - (nodeInput.signals.active ? 1 : 0);

  // get variables
  var interactive = this.param('interactive'),
      linkSource = this.param('links').source,
      linkInput = linkSource.last(),
      active = this.param('active'),
      output = this._output,
      layout = this._layout,
      nodes = this._nodes,
      links = this._links;

  // configure nodes, links and layout
  if (linkInput.stamp < nodeInput.stamp) linkInput = null;
  this.configure(nodeInput, linkInput, interactive, reset);
  
  // run batch layout
  if (!interactive) {
    var iterations = this.param('iterations');
    for (var i=0; i<iterations; ++i) layout.tick();
    layout.stop();
  }

  // update node positions
  this.update(active);

  // re-up alpha on parameter change
  if (reset || active !== this._prev && active && active.update) {
    layout.alpha(this.param('alpha')); // re-start layout
  }

  // update active node status, 
  if (active !== this._prev) {
    this._prev = active;
  }

  // process removed nodes or edges
  if (nodeInput.rem.length) {
    layout.nodes(this._nodes = Tuple.idFilter(nodes, nodeInput.rem));
  }
  if (linkInput && linkInput.rem.length) {
    layout.links(this._links = Tuple.idFilter(links, linkInput.rem));
  }

  // return changeset
  nodeInput.fields[output.x] = 1;
  nodeInput.fields[output.y] = 1;
  return nodeInput;
};

prototype.configure = function(nodeInput, linkInput, interactive, reset) {
  // check if we need to run configuration
  var layout = this._layout,
      update = this._setup || nodeInput.add.length ||
            linkInput && linkInput.add.length ||
            interactive !== this._interactive ||
            this.param('charge') !== layout.charge() ||
            this.param('linkStrength') !== layout.linkStrength() ||
            this.param('linkDistance') !== layout.linkDistance();

  if (update || reset) {
    // a parameter changed, so update tick-only parameters
    layout
      .size(this.param('size'))
      .chargeDistance(this.param('chargeDistance'))
      .theta(this.param('theta'))
      .gravity(this.param('gravity'))
      .friction(this.param('friction'));
  }

  if (!update) return; // if no more updates needed, return now

  this._setup = false;
  this._interactive = interactive;

  var force = this,
      graph = this._graph,
      nodes = this._nodes,
      links = this._links, a, i;

  // process added nodes
  for (a=nodeInput.add, i=0; i<a.length; ++i) {
    nodes.push({tuple: a[i]});
  }

  // process added edges
  if (linkInput) for (a=linkInput.add, i=0; i<a.length; ++i) {
    // TODO add configurable source/target accessors
    // TODO support lookup by node id
    // TODO process 'mod' of edge source or target?
    links.push({
      tuple:  a[i],
      source: nodes[a[i].source],
      target: nodes[a[i].target]
    });
  }

  // setup handler for force layout tick events
  var tickHandler = !interactive ? null : function() {
    // re-schedule the transform, force reflow
    graph.propagate(ChangeSet.create(null, true), force);
  };

  // configure the rest of the layout
  layout
    .linkStrength(this.param('linkStrength'))
    .linkDistance(this.param('linkDistance'))
    .charge(this.param('charge'))
    .nodes(nodes)
    .links(links)
    .on('tick', tickHandler)
    .start().alpha(this.param('alpha'));
};

prototype.update = function(active) {
  var output = this._output,
      bound = this.param('bound'),
      fixed = this.param('fixed'),
      size = this.param('size'),
      nodes = this._nodes,
      lut = {}, id, i, n, t, x, y;

  if (fixed && fixed.source) {
    // TODO: could cache and update as needed?
    fixed = fixed.source.values();
    for (i=0, n=fixed.length; i<n; ++i) {
      lut[fixed[i].id] = 1;
    }
  }

  for (i=0; i<nodes.length; ++i) {
    n = nodes[i];
    t = n.tuple;
    id = t._id;

    if (active && active.id === id) {
      n.fixed = 1;
      if (active.update) {
        n.x = n.px = active.x;
        n.y = n.py = active.y;
      }
    } else {
      n.fixed = lut[id] || 0;
    }

    x = bound ? Math.max(0, Math.min(n.x, size[0])) : n.x;
    y = bound ? Math.max(0, Math.min(n.y, size[1])) : n.y;
    Tuple.set(t, output.x, x);
    Tuple.set(t, output.y, y);
  }
};

module.exports = Force;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],131:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Formula(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field: {type: 'value'},
    expr:  {type: 'expr'}
  });

  return this.mutates(true);
}

var prototype = (Formula.prototype = Object.create(Transform.prototype));
prototype.constructor = Formula;

prototype.transform = function(input) {
  log.debug(input, ['formulating']);

  var g = this._graph,
      field = this.param('field'),
      expr = this.param('expr'),
      signals = g.values(SIGNALS, this.dependency(SIGNALS));

  function set(x) {
    Tuple.set(x, field, expr(x, null, signals));
  }

  input.add.forEach(set);
  
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
  }

  input.fields[field] = 1;
  return input;
};

module.exports = Formula;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],132:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Geo(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, Geo.Parameters);
  Transform.addParameters(this, {
    lon: {type: 'field'},
    lat: {type: 'field'}
  });

  this._output = {
    'x': 'layout_x',
    'y': 'layout_y'
  };
  return this.mutates(true);
}

Geo.Parameters = {
  projection: {type: 'value', default: 'mercator'},
  center:     {type: 'array<value>'},
  translate:  {type: 'array<value>'},
  rotate:     {type: 'array<value>'},
  scale:      {type: 'value'},
  precision:  {type: 'value'},
  clipAngle:  {type: 'value'},
  clipExtent: {type: 'value'}
};

Geo.d3Projection = function() {
  var p = this.param('projection'),
      param = Geo.Parameters,
      proj, name, value;

  if (p !== this._mode) {
    this._mode = p;
    this._projection = d3.geo[p]();
  }
  proj = this._projection;

  for (name in param) {
    if (name === 'projection' || !proj[name]) continue;
    value = this.param(name);
    if (value === undefined || (dl.isArray(value) && value.length === 0)) {
      continue;
    }
    if (value !== proj[name]()) {
      proj[name](value);
    }
  }

  return proj;
};

var prototype = (Geo.prototype = Object.create(Transform.prototype));
prototype.constructor = Geo;

prototype.transform = function(input) {
  log.debug(input, ['geo']);

  var output = this._output,
      lon = this.param('lon').accessor,
      lat = this.param('lat').accessor,
      proj = Geo.d3Projection.call(this);

  function set(t) {
    var ll = [lon(t), lat(t)];
    var xy = proj(ll) || [null, null];
    Tuple.set(t, output.x, xy[0]);
    Tuple.set(t, output.y, xy[1]);
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.x] = 1;
  input.fields[output.y] = 1;
  return input;
};

module.exports = Geo;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],133:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Geo = require('./Geo'),
    Transform = require('./Transform');

function GeoPath(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, Geo.Parameters);
  Transform.addParameters(this, {
    field: {type: 'field', default: null},
  });

  this._output = {
    'path': 'layout_path'
  };
  return this.mutates(true);
}

var prototype = (GeoPath.prototype = Object.create(Transform.prototype));
prototype.constructor = GeoPath;

prototype.transform = function(input) {
  log.debug(input, ['geopath']);

  var output = this._output,
      geojson = this.param('field').accessor || dl.identity,
      proj = Geo.d3Projection.call(this),
      path = d3.geo.path().projection(proj);

  function set(t) {
    Tuple.set(t, output.path, path(geojson(t)));
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.path] = 1;
  return input;
};

module.exports = GeoPath;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Geo":132,"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],134:[function(require,module,exports){
var Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function LinkPath(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    sourceX:  {type: 'field', default: '_source.layout_x'},
    sourceY:  {type: 'field', default: '_source.layout_y'},
    targetX:  {type: 'field', default: '_target.layout_x'},
    targetY:  {type: 'field', default: '_target.layout_y'},
    tension:  {type: 'value', default: 0.2},
    shape:    {type: 'value', default: 'line'}
  });

  this._output = {'path': 'layout_path'};
  return this.mutates(true);
}

var prototype = (LinkPath.prototype = Object.create(Transform.prototype));
prototype.constructor = LinkPath;

function line(sx, sy, tx, ty) {
  return 'M' + sx + ',' + sy +
         'L' + tx + ',' + ty;
}

function curve(sx, sy, tx, ty, tension) {
  var dx = tx - sx,
      dy = ty - sy,
      ix = tension * (dx + dy),
      iy = tension * (dy - dx);
  return 'M' + sx + ',' + sy +
         'C' + (sx+ix) + ',' + (sy+iy) +
         ' ' + (tx+iy) + ',' + (ty-ix) +
         ' ' + tx + ',' + ty;
}

function diagonalX(sx, sy, tx, ty) {
  var m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy +
         'C' + m  + ',' + sy +
         ' ' + m  + ',' + ty +
         ' ' + tx + ',' + ty;
}

function diagonalY(sx, sy, tx, ty) {
  var m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy +
         'C' + sx + ',' + m +
         ' ' + tx + ',' + m +
         ' ' + tx + ',' + ty;
}

var shapes = {
  line:      line,
  curve:     curve,
  diagonal:  diagonalX,
  diagonalX: diagonalX,
  diagonalY: diagonalY
};

prototype.transform = function(input) {
  log.debug(input, ['linkpath']);

  var output = this._output,
      shape = shapes[this.param('shape')] || shapes.line,
      sourceX = this.param('sourceX').accessor,
      sourceY = this.param('sourceY').accessor,
      targetX = this.param('targetX').accessor,
      targetY = this.param('targetY').accessor,
      tension = this.param('tension');

  function set(t) {
    var path = shape(sourceX(t), sourceY(t), targetX(t), targetY(t), tension);
    Tuple.set(t, output.path, path);
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.path] = 1;
  return input;
};

module.exports = LinkPath;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],135:[function(require,module,exports){
var Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Lookup(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    on:      {type: 'data'},
    onKey:   {type: 'field', default: null},
    as:      {type: 'array<value>'},
    keys:    {type: 'array<field>', default: ['data']},
    default: {type: 'value'}
  });

  return this.mutates(true);
}

var prototype = (Lookup.prototype = Object.create(Transform.prototype));
prototype.constructor = Lookup;

prototype.transform = function(input, reset) {
  log.debug(input, ['lookup']);

  var on = this.param('on'),
      onLast = on.source.last(),
      onData = on.source.values(),
      onKey = this.param('onKey'),
      onF = onKey.field,
      keys = this.param('keys'),
      get = keys.accessor,
      as = this.param('as'),
      defaultValue = this.param('default'),
      lut = this._lut,
      i, v;

  // build lookup table on init, withKey modified, or tuple add/rem
  if (lut == null || this._on !== onF || onF && onLast.fields[onF] ||
      onLast.add.length || onLast.rem.length)
  {
    if (onF) { // build hash from withKey field
      onKey = onKey.accessor;
      for (lut={}, i=0; i<onData.length; ++i) {
        lut[onKey(v = onData[i])] = v;
      }
    } else { // otherwise, use index-based lookup
      lut = onData;
    }
    this._lut = lut;
    this._on = onF;
    reset = true;
  }

  function set(t) {
    for (var i=0; i<get.length; ++i) {
      var v = lut[get[i](t)] || defaultValue;
      Tuple.set(t, as[i], v);
    }
  }

  input.add.forEach(set);
  var run = keys.field.some(function(f) { return input.fields[f]; });
  if (run || reset) {
    input.mod.forEach(set);
    input.rem.forEach(set); 
  }

  as.forEach(function(k) { input.fields[k] = 1; });
  return input;
};

module.exports = Lookup;
},{"./Transform":140,"vega-dataflow":43,"vega-logging":49}],136:[function(require,module,exports){
var dl = require('datalib'),
    Deps = require('vega-dataflow').Dependencies,
    expr = require('../parse/expr');

var arrayType = /array/i,
    dataType  = /data/i,
    fieldType = /field/i,
    exprType  = /expr/i,
    valType   = /value/i;

function Parameter(name, type, transform) {
  this._name = name;
  this._type = type;
  this._transform = transform;

  // If parameter is defined w/signals, it must be resolved
  // on every pulse.
  this._value = [];
  this._accessors = [];
  this._resolution = false;
  this._signals = {};
}

var prototype = Parameter.prototype;

function get() {
  var isArray = arrayType.test(this._type),
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type);

  var val = isArray ? this._value : this._value[0],
      acc = isArray ? this._accessors : this._accessors[0];

  if (!dl.isValid(acc) && valType.test(this._type)) {
    return val;
  } else {
    return isData ? { name: val, source: acc } :
    isField ? { field: val, accessor: acc } : val;
  }
}

prototype.get = function() {
  var graph = this._transform._graph, 
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type),
      s, idx, val;

  // If we don't require resolution, return the value immediately.
  if (!this._resolution) return get.call(this);

  if (isData) {
    this._accessors = this._value.map(function(v) { return graph.data(v); });
    return get.call(this); // TODO: support signal as dataTypes
  }

  for (s in this._signals) {
    idx = this._signals[s];
    val = graph.signalRef(s);

    if (isField) {
      this._accessors[idx] = this._value[idx] != val ? 
        dl.accessor(val) : this._accessors[idx];
    }

    this._value[idx] = val;
  }

  return get.call(this);
};

prototype.set = function(value) {
  var p = this,
      isExpr = exprType.test(this._type),
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type);

  this._value = dl.array(value).map(function(v, i) {
    if (dl.isString(v)) {
      if (isExpr) {
        var e = expr(v);
        p._transform.dependency(Deps.FIELDS,  e.fields);
        p._transform.dependency(Deps.SIGNALS, e.globals);
        return e.fn;
      } else if (isField) {  // Backwards compatibility
        p._accessors[i] = dl.accessor(v);
        p._transform.dependency(Deps.FIELDS, dl.field(v));
      } else if (isData) {
        p._resolution = true;
        p._transform.dependency(Deps.DATA, v);
      }
      return v;
    } else if (v.value !== undefined) {
      return v.value;
    } else if (v.field !== undefined) {
      p._accessors[i] = dl.accessor(v.field);
      p._transform.dependency(Deps.FIELDS, dl.field(v.field));
      return v.field;
    } else if (v.signal !== undefined) {
      p._resolution = true;
      p._signals[v.signal] = i;
      p._transform.dependency(Deps.SIGNALS, v.signal);
      return v.signal;
    }

    return v;
  });

  return p._transform;
};

module.exports = Parameter;
},{"../parse/expr":99,"datalib":24,"vega-dataflow":43}],137:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Pie(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field:      {type: 'field', default: null},
    startAngle: {type: 'value', default: 0},
    endAngle:   {type: 'value', default: 2 * Math.PI},
    sort:       {type: 'value', default: false}
  });

  this._output = {
    'start': 'layout_start',
    'end':   'layout_end',
    'mid':   'layout_mid'
  };

  return this.mutates(true);
}

var prototype = (Pie.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Pie;

function ones() { return 1; }

prototype.batchTransform = function(input, data) {
  log.debug(input, ['pie']);

  var output = this._output,
      field = this.param('field').accessor || ones,
      start = this.param('startAngle'),
      stop = this.param('endAngle'),
      sort = this.param('sort');

  var values = data.map(field),
      a = start,
      k = (stop - start) / dl.sum(values),
      index = dl.range(data.length),
      i, t, v;

  if (sort) {
    index.sort(function(a, b) {
      return values[a] - values[b];
    });
  }

  for (i=0; i<index.length; ++i) {
    t = data[index[i]];
    v = values[index[i]];
    Tuple.set(t, output.start, a);
    Tuple.set(t, output.mid, (a + 0.5 * v * k));
    Tuple.set(t, output.end, (a += v * k));
  }

  input.fields[output.start] = 1;
  input.fields[output.end] = 1;
  input.fields[output.mid] = 1;
  return input;
};

module.exports = Pie;
},{"./BatchTransform":122,"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],138:[function(require,module,exports){
var dl = require('datalib'),
    log  = require('vega-logging'),
    Transform = require('./Transform');

function Sort(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {by: {type: 'array<field>'} });
  this.router(true);
}

var prototype = (Sort.prototype = Object.create(Transform.prototype));
prototype.constructor = Sort;

prototype.transform = function(input) {
  log.debug(input, ['sorting']);

  if (input.add.length || input.mod.length || input.rem.length) {
    input.sort = dl.comparator(this.param('by').field);
  }
  return input;
};

module.exports = Sort;
},{"./Transform":140,"datalib":24,"vega-logging":49}],139:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Stack(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    groupby: {type: 'array<field>'},
    sortby: {type: 'array<field>'},
    field: {type: 'field'},
    offset: {type: 'value', default: 'zero'}
  });

  this._output = {
    'start': 'layout_start',
    'end':   'layout_end',
    'mid':   'layout_mid'
  };
  return this.mutates(true);
}

var prototype = (Stack.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Stack;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['stacking']);

  var groupby = this.param('groupby').accessor,
      sortby = dl.comparator(this.param('sortby').field),
      field = this.param('field').accessor,
      offset = this.param('offset'),
      output = this._output;

  // partition, sum, and sort the stack groups
  var groups = partition(data, groupby, sortby, field);

  // compute stack layouts per group
  for (var i=0, max=groups.max; i<groups.length; ++i) {
    var group = groups[i],
        sum = group.sum,
        off = offset==='center' ? (max - sum)/2 : 0,
        scale = offset==='normalize' ? (1/sum) : 1,
        j, x, a, b = off, v = 0;

    // set stack coordinates for each datum in group
    for (j=0; j<group.length; ++j) {
      x = group[j];
      a = b; // use previous value for start point
      v += field(x);
      b = scale * v + off; // compute end point
      Tuple.set(x, output.start, a);
      Tuple.set(x, output.end, b);
      Tuple.set(x, output.mid, 0.5 * (a + b));
    }
  }

  input.fields[output.start] = 1;
  input.fields[output.end] = 1;
  input.fields[output.mid] = 1;
  return input;
};

function partition(data, groupby, sortby, field) {
  var groups = [],
      get = function(f) { return f(x); },
      map, i, x, k, g, s, max;

  // partition data points into stack groups
  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map={}, i=0; i<data.length; ++i) {
      x = data[i];
      k = groupby.map(get);
      g = map[k] || (groups.push(map[k] = []), map[k]);
      g.push(x);
    }
  }

  // compute sums of groups, sort groups as needed
  for (k=0, max=0; k<groups.length; ++k) {
    g = groups[k];
    for (i=0, s=0; i<g.length; ++i) {
      s += field(g[i]);
    }
    g.sum = s;
    if (s > max) max = s;
    if (sortby != null) g.sort(sortby);
  }
  groups.max = max;

  return groups;
}

module.exports = Stack;
},{"./BatchTransform":122,"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],140:[function(require,module,exports){
var df = require('vega-dataflow'),
    Base = df.Node.prototype, // jshint ignore:line
    Deps = df.Dependencies,
    Parameter = require('./Parameter');

function Transform(graph) {
  if (graph) Base.init.call(this, graph);
}

Transform.addParameters = function(proto, params) {
  proto._parameters = proto._parameters || {};
  for (var name in params) {
    var p = params[name],
        param = new Parameter(name, p.type, proto);

    proto._parameters[name] = param;

    if (p.type === 'custom') {
      if (p.set) param.set = p.set.bind(param);
      if (p.get) param.get = p.get.bind(param);
    }

    if (p.hasOwnProperty('default')) param.set(p.default);
  }
};

var prototype = (Transform.prototype = Object.create(Base));
prototype.constructor = Transform;

prototype.param = function(name, value) {
  var param = this._parameters[name];
  return (param === undefined) ? this :
    (arguments.length === 1) ? param.get() : param.set(value);
};

// Perform transformation. Subclasses should override.
prototype.transform = function(input/*, reset */) {
  return input;
};

prototype.evaluate = function(input) {
  // Many transforms store caches that must be invalidated if
  // a signal value has changed. 
  var reset = this._stamp < input.stamp &&
    this.dependency(Deps.SIGNALS).reduce(function(c, s) {
      return c += input.signals[s] ? 1 : 0;
    }, 0);
  return this.transform(input, reset);
};

prototype.output = function(map) {
  for (var key in this._output) {
    if (map[key] !== undefined) {
      this._output[key] = map[key];
    }
  }
  return this;
};

module.exports = Transform;
},{"./Parameter":136,"vega-dataflow":43}],141:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

var defaultRatio = 0.5 * (1 + Math.sqrt(5));

function Treemap(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    // hierarchy parameters
    sort: {type: 'array<field>', default: ['-value']},
    children: {type: 'field', default: 'children'},
    field: {type: 'field', default: 'value'},
    // treemap parameters
    size: {type: 'array<value>', default: [500, 500]},
    round: {type: 'value', default: true},
    sticky: {type: 'value', default: false},
    ratio: {type: 'value', default: defaultRatio},
    padding: {type: 'value', default: null},
    mode: {type: 'value', default: 'squarify'}
  });

  this._layout = d3.layout.treemap();

  this._output = {
    'x':      'layout_x',
    'y':      'layout_y',
    'width':  'layout_width',
    'height': 'layout_height',
    'depth':  'layout_depth',
  };
  return this.mutates(true);
}

var prototype = (Treemap.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Treemap;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['treemap']);

  // get variables
  var layout = this._layout,
      output = this._output;

  // configure layout
  layout
    .sort(dl.comparator(this.param('sort').field))
    .children(this.param('children').accessor)
    .value(this.param('field').accessor)
    .size(this.param('size'))
    .round(this.param('round'))
    .sticky(this.param('sticky'))
    .ratio(this.param('ratio'))
    .padding(this.param('padding'))
    .mode(this.param('mode'))
    .nodes(data[0]);

  // copy layout values to nodes
  data.forEach(function(n) {
    Tuple.set(n, output.x, n.x);
    Tuple.set(n, output.y, n.y);
    Tuple.set(n, output.width, n.dx);
    Tuple.set(n, output.height, n.dy);
    Tuple.set(n, output.depth, n.depth);
  });

  // return changeset
  input.fields[output.x] = 1;
  input.fields[output.y] = 1;
  input.fields[output.width] = 1;
  input.fields[output.height] = 1;
  return input;
};

module.exports = Treemap;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":122,"./Transform":140,"datalib":24,"vega-dataflow":43,"vega-logging":49}],142:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    Tuple = require('vega-dataflow/src/Tuple'),
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Voronoi(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    clipExtent: {type: 'array<value>', default: [[-1e5,-1e5],[1e5,1e5]]},
    x: {type: 'field', default: 'layout_x'},
    y: {type: 'field', default: 'layout_y'}
  });

  this._layout = d3.geom.voronoi();
  this._output = {'path': 'layout_path'};

  return this.mutates(true);
}

var prototype = (Voronoi.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Voronoi;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['voronoi']);

  // get variables
  var pathname = this._output.path;

  // configure layout
  var polygons = this._layout
    .clipExtent(this.param('clipExtent'))
    .x(this.param('x').accessor)
    .y(this.param('y').accessor)
    (data);

  // build and assign path strings
  for (var i=0; i<data.length; ++i) {
    Tuple.set(data[i], pathname, 'M' + polygons[i].join('L') + 'Z');
  }

  // return changeset
  input.fields[pathname] = 1;
  return input;
};

module.exports = Voronoi;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":122,"./Transform":140,"vega-dataflow/src/Tuple":42,"vega-logging":49}],143:[function(require,module,exports){
(function (global){
var dl = require('datalib'),
    d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    d3_cloud = (typeof window !== "undefined" ? window['d3']['layout']['cloud'] : typeof global !== "undefined" ? global['d3']['layout']['cloud'] : null),
    Tuple = require('vega-dataflow/src/Tuple'),
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Wordcloud(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    size: {type: 'array<value>', default: [900, 500]},
    text: {type: 'field', default: 'data'},
    rotate: {type: 'field|value', default: 0},
    font: {type: 'field|value', default: {value: 'sans-serif'}},
    fontSize: {type: 'field|value', default: 14},
    fontStyle: {type: 'field|value', default: {value: 'normal'}},
    fontWeight: {type: 'field|value', default: {value: 'normal'}},
    fontScale: {type: 'array<value>', default: [10, 50]},
    padding: {type: 'value', default: 1},
    spiral: {type: 'value', default: 'archimedean'}
  });

  this._layout = d3_cloud();

  this._output = {
    'x':          'layout_x',
    'y':          'layout_y',
    'font':       'layout_font',
    'fontSize':   'layout_fontSize',
    'fontStyle':  'layout_fontStyle',
    'fontWeight': 'layout_fontWeight',
    'rotate':     'layout_rotate',
  };

  return this.mutates(true);
}

var prototype = (Wordcloud.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Wordcloud;

function get(p) {
  return (p && p.accessor) || p;
}

function wrap(tuple) {
  var x = Object.create(tuple);
  x._tuple = tuple;
  return x;
}

prototype.batchTransform = function(input, data) {
  log.debug(input, ['wordcloud']);

  // get variables
  var layout = this._layout,
      output = this._output,
      fontSize = this.param('fontSize'),
      range = fontSize.accessor && this.param('fontScale'),
      size, scale;
  fontSize = fontSize.accessor || d3.functor(fontSize);
  
  // create font size scaling function as needed
  if (range.length) {
    scale = d3.scale.sqrt()
      .domain(dl.extent(data, size=fontSize))
      .range(range);
    fontSize = function(x) { return scale(size(x)); };
  }

  // configure layout
  layout
    .size(this.param('size'))
    .text(get(this.param('text')))
    .padding(this.param('padding'))
    .spiral(this.param('spiral'))
    .rotate(get(this.param('rotate')))
    .font(get(this.param('font')))
    .fontStyle(get(this.param('fontStyle')))
    .fontWeight(get(this.param('fontWeight')))
    .fontSize(fontSize)
    .words(data.map(wrap)) // wrap to avoid tuple writes
    .on('end', function(words) {
      var size = layout.size(),
          dx = size[0] >> 1,
          dy = size[1] >> 1,
          w, t, i, len;

      for (i=0, len=words.length; i<len; ++i) {
        w = words[i];
        t = w._tuple;
        Tuple.set(t, output.x, w.x + dx);
        Tuple.set(t, output.y, w.y + dy);
        Tuple.set(t, output.font, w.font);
        Tuple.set(t, output.fontSize, w.size);
        Tuple.set(t, output.fontStyle, w.style);
        Tuple.set(t, output.fontWeight, w.weight);
        Tuple.set(t, output.rotate, w.rotate);
      }
    })
    .start();

  // return changeset
  for (var key in output) input.fields[output[key]] = 1;
  return input;
};

module.exports = Wordcloud;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":122,"./Transform":140,"datalib":24,"vega-dataflow/src/Tuple":42,"vega-logging":49}],144:[function(require,module,exports){
module.exports = {
  aggregate:    require('./Aggregate'),
  bin:          require('./Bin'),
  cross:        require('./Cross'),
  countpattern: require('./CountPattern'),
  linkpath:     require('./LinkPath'),
  facet:        require('./Facet'),
  filter:       require('./Filter'),
  fold:         require('./Fold'),
  force:        require('./Force'),
  formula:      require('./Formula'),
  geo:          require('./Geo'),
  geopath:      require('./GeoPath'),
  lookup:       require('./Lookup'),
  pie:          require('./Pie'),
  sort:         require('./Sort'),
  stack:        require('./Stack'),
  treemap:      require('./Treemap'),
  voronoi:      require('./Voronoi'),
  wordcloud:    require('./Wordcloud')
};
},{"./Aggregate":121,"./Bin":123,"./CountPattern":124,"./Cross":125,"./Facet":126,"./Filter":128,"./Fold":129,"./Force":130,"./Formula":131,"./Geo":132,"./GeoPath":133,"./LinkPath":134,"./Lookup":135,"./Pie":137,"./Sort":138,"./Stack":139,"./Treemap":141,"./Voronoi":142,"./Wordcloud":143}],145:[function(require,module,exports){
/* This module defines and exposes JS pseudo-classes to support a complex view
 * model for editing illustrations.
 */

var utils = require('./ti-utils.js'),
    stylist = require('./stylist.js');

//global.stylist = stylist;

var TreeIllustrator = function(window, document, $, ko, stylist) {

    // Explicitly check for dependencies by passing them as args to the module
    if (typeof($) !== 'function') {
        alert("TreeIllustrator module cancelled, needs jQuery (as '$')");
        return null;
    }
    if (!ko || typeof(ko) !== 'object') {
        alert("TreeIllustrator module cancelled, needs KnockoutJS (as 'ko')");
        return null;
    }
    if (!stylist || typeof(stylist) !== 'object') {
        alert("TreeIllustrator module cancelled, needs 'stylist' module (as 'stylist')");
        return null;
    }

    // define some simple enumerations (for legibility, and to avoid typos)
    var units = {
        INCHES: 'INCHES',
        CENTIMETERS: 'CENTIMETERS'
    };
    var colorDepths = {
        FULL_COLOR: 'FULL_COLOR',
        GRAYSCALE: 'GRAYSCALE',
        BLACK_AND_WHITE: 'BLACK_AND_WHITE'
    };
    var treeLayouts = {
        RECTANGLE: 'RECTANGLE',
        CIRCLE: 'CIRCLE',
        TRIANGLE: 'TRIANGLE'
    };
    var alignments = {
        TOP: 'TOP',
        RIGHT: 'RIGHT',
        BOTTOM: 'BOTTOM',
        LEFT: 'LEFT',
        CENTER: 'CENTER'
    };
    var dataSourceTypes = {
        BUILT_IN: 'BUILT_IN',
        URL: 'URL',
        UPLOAD: 'UPLOAD'
    };
    var versionTypes = {
        CHECKSUM: 'CHECKSUM',   // e.g., a git SHA
        TIMESTAMP: 'TIMESTAMP', // e.g., a modification date
        SEMANTIC: 'SEMANTIC'    // a conventional version number, e.g., "3.2.0a"
    };
    var hostApplications = {
        JUPYTER_NOTEBOOK: 'JUPYTER_NOTEBOOK',    // a.k.a. IPython notebook
        //TODO: ARBOR_WORKFLOW: 'ARBOR_WORKFLOW' 
        //TODO: OPENTREE_TOOLS: 'OPENTREE_TOOLS'
        STANDALONE: 'STANDALONE'                 // "naked" stylist, perhaps from a static file
    };

    /* Here we can share information among all classes and instances */

    /* Cache data to improve performance or reduce network traffic: 
     *   - tree source loaded via AJAX
     *   - intermediate tree data (after one or more transforms)
     *   - supporting datasets
     *   - etc.
     * Note that initial use is by the 'stash' transform below.
     */
    var cache = { };
    var setCachedData = function(key, value) {
        // add (or update) the cache for this key
        cache[key] = value;
    }
    var getCachedData = function(key) {
        // retrieve this key's cache from the cache (or return null)
        return (key in cache) ? cache[key] : null;
    }
    var clearCachedData = function(key) {
        // add (or update) the cache for this key
        delete cache[key];
    }

    /* Return the data model for a new illustration (our JSON representation) */
    var getNewIllustrationModel = function(options) {
        if (!options) options = {};
        var obj = {
            'metadata': {
                'name': "Untitled illustration",
                'description': "",
                'authors': [ ],   // assign immediately to this user?
                'tags': [ ],
                'dois': [ ]
            },
            'styleGuide': {
                // maybe the defaults here are "anything goes" (all options enabled)?
                // TODO: Explicitly list all options somewhere else? 
                // TODO: Filter styles if they fall out of conformance?
                'name': "Default styles",
                'description': "Style guides are used to suggest and constrain the overall look of your illustration for a particular publication or context. You can try different styles using the <strong>Load styles...</strong> button.", // captured when assigned
                'source': {'type': dataSourceTypes.BUILT_IN, 'value': "DEFAULT"},
                'version': {'type': versionTypes.SEMANTIC, 'value': "0.1"},
                'constraints': {
                    // list constrained labels and values, if any (items not listed are unconstrained)
                    'printSizes': [
                        {
                            'name': "Letter size (portrait)",
                            'width': 8.5, 
                            'height': 11, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Letter size (landscape)",
                            'width': 11, 
                            'height': 8.5, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Quarter-page (portrait)",
                            'width': 4.25, 
                            'height': 5.5, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Quarter-page (landscape)",
                            'width': 5.5, 
                            'height': 4.25, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Custom size"
                        }
                    ],
                    'fontFamilies': [
                        {
                            'name': "Times New Roman",
                            'value': "Times New Roman, Times, serif"
                        },
                        {
                            'name': "Helvetica",
                            'value': "Helvetica, Arial, sans"
                        },
                        {
                            'name': "Arial",
                            'value': "Arial, sans"
                        },
                        {
                            'name': "Something else"
                        }
                    ],
                    'colorDepths': [
                        {
                            'name': "Full color",
                            'value': colorDepths.FULL_COLOR
                        },
                        {
                            'name': "Grayscale",
                            'value': colorDepths.GRAYSCALE
                        },
                        {
                            'name': "Black and white (no gray)",
                            'value': colorDepths.BLACK_AND_WHITE
                        }
                    ],
                    'minimumTextSize': 12,  
                        // specified in pt, but echoed using physical units above
                    'minimumLineThickness': 2,  
                        // specified in pt, but echoed using physical units above
                    'backgroundColor': "#fdd",
                    'border': "none",
                    // add default line color, thickness, node shape/size, etc.
                    'edgeColor': "#777",
                    'edgeThickness': 0.8,
                    'nodeColor': "#339",
                    'nodeShape': 'circle'  // TODO: should be an enumerated  value
                }
            },
            'style': {
                // choices and overrides from the style guide above
                'printSize': {
                    'units': units.INCHES,  // OR units.CENTIMETERS
                    'width': 8.5,  // in physical units
                    'height': 11,   // in physical units
                },
                'fontFamily': "Times New Roman, Times, serif",
                'backgroundColor': "#fdd",
                'border': "none",
                // add default line color, thickness, node shape/size, etc.
                'edgeColor': "#777",
                'edgeThickness': 0.8,
                'nodeColor': "#339",
                'nodeShape': 'circle'  // TODO: should be an enumerated  value
            },
            'elements': [
            ],
            'vegaSpec': {
                'width': 800,
                'height': 900,
                'padding': {
                    'top': 0,
                    'left': 0,
                    'bottom': 0,
                    'right': 0
                },
                'data': [ ],
                'style': { }
            }
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new tree (our JSON representation) */
    var getNewIllustratedTreeModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('tree'); 
        var landmarks = stylist.getPrintAreaLandmarks();
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'IllustratedTree',
                'name': "Untitled ("+ newID +")",
                'source': {
                    'type': dataSourceTypes.BUILT_IN, 
                    'value': './placeholder-tree.json',
                    'phylesystemStudyID': '',
                    'phylesystemTreeID': ''
                },
                'description': "",
                'dois': [ ]
            },
            'data': { },
            'layout': treeLayouts.CIRCLE,
            /* Overload the model with all layout properties. We'll use the
             * ones that current apply *and* retain last-known values for
             * others, in case the user switches back to a prior layout
             */
            'width': landmarks.width * 0.4,
            'height': landmarks.height * 0.4,
            'radius': Math.min(landmarks.height, landmarks.width) * 0.3,
            'tipsAlignment': alignments.RIGHT,
            'rootX': landmarks.centerX + utils.jiggle(5),   // TODO: use a bounding box instead?
            'rootY': landmarks.centerY + utils.jiggle(5),
            'nodeLabelField': 'ottTaxonName',         // matches the placeholder tree
            'style': {
                // incl. only deviations from the style guide above?
/*
                'edgeThickness': 1.0,  
                'edgeColor': '#999',
                'labelTextHeight': illustration.styleGuide.constraints.minimumTextSize()
*/
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new dataset (our JSON representation) */
    var getNewSupportingDatasetModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('dataset'); 
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'SupportingDataset',
                'name': "Untitled ("+ newID +")",
                'description': "",
                'dois': [ ]
            },
            'data': { },
            'style': {
                // incl. only deviations from the style guide above?
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new ornament (our JSON representation) */
    var getNewOrnamentModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('ornament'); 
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'Ornament',
                'name': "Untitled ("+ newID +")",
                'description': ""
            },
            'data': { },
            'style': {
                // incl. only deviations from the style guide above?
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Our principle view model [1] is a single illustration. This uses basic
     * Knockout observables as members, but adds custom behavior. We'll use a
     * family of pseudo-classes to define the main illustration and selected parts.
     *
     * [1] http://knockoutjs.com/documentation/observables.html
     */
    var Illustration = function(data) {
        if ( !(this instanceof Illustration) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new Illustration(data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" illustration object above
            data = getNewIllustrationModel();
        }

        // safely refer to this instance
        var self = this;

        /* define PRIVATE members (variables and methods)functions and with 'var' */

        /* We'll need to mint a unique, serial ID for each new illustration
         * element. Since we have a reasonable number of elements, we can
         * set the initial values for an illustration as it loads, by scanning
         * the existing elements of each type.
         */
        var nextAvailableID = {
            'tree': 0,
            'dataset': 0,
            'ornament': 0
        };
        // Each element nickname above is used in IDs, eg. 'tree-32'
        var initSerialElementIDs = function() {
            for (var aType in nextAvailableID) {
                nextAvailableID[ aType ] = 0;
            }
            var highestTreeIDFound = 0;
            var highestDatasetIDFound = 0;
            var highestOrnamentIDFound = 0;

            $.each(self.elements(), function(i, el) {
                var parts = el.id().split('-');
                var elementType = parts[0];
                var itsSerialID = parseInt(parts[1], 10);
                nextAvailableID[ elementType ] = Math.max( 
                    itsSerialID,
                    nextAvailableID[ elementType ] 
                );
            });
        }


        /* define PUBLIC variables (and privileged methods) with 'self' */

        self.getNextAvailableID = function( elementType ) {
            // creates a serial ID like 'dataset-4' or 'tree-12'
            var readyID = nextAvailableID[ elementType ];
            nextAvailableID[ elementType ] = readyID + 1;
            return (elementType +'-'+ nextAvailableID[ elementType ]);
        } 

        // REMINDER: computed observables should use 'deferEvaluation' in
        // case their dependencies will appear during ko.mapping
        self.styleGuideSourceHTML = ko.computed(function () {
            switch(self.styleGuide.source.type()) {
                case dataSourceTypes.URL:
                    var itsURL = self.styleGuide.source.value();
                    return '<a href='+ itsURL +' target="_blank">'+ itsURL +'</a>';
                case dataSourceTypes.BUILT_IN:
                    return "Built-in";
            }
            return "Undefined"; 
        }, self, {deferEvaluation:true});

        self.useChosenPrintSize = function() {
            var sizeName = $('#style-docsize-chooser').val();
            var selectedSize = getPrintSizeByName( sizeName );
            if (!selectedSize) {
                console.warn('useChosenPrintSize(): no matching size found!');
                return;
            }
            if (selectedSize.units) {
                // Custom size should retain current settings
                self.style.printSize.width( selectedSize.width() );
                self.style.printSize.height( selectedSize.height() );
                self.style.printSize.units( selectedSize.units() );
            }

            // update visible canvas and d3 viz
            stylist.refreshViz();
        };
        self.updatePrintSizeChooser = function() {
            // (de)select matching size after manual adjustments
            var matchingSize = $.grep(
                self.styleGuide.constraints.printSizes(), 
                function(o) {
                    if (!('units' in o)) return false; // 'Custom size' never matches
                    // NOTE use of != instead of !== below, because "11" == 11
                    if (o.units() != self.style.printSize.units()) return false;
                    if (o.width() != self.style.printSize.width()) return false;
                    if (o.height() != self.style.printSize.height()) return false;
                    return true;
                }
            )[0];
            var matchingSizeName = 'Custom size';
            if (matchingSize) {
                matchingSizeName = matchingSize.name();
            }
            $('#style-docsize-chooser').val(matchingSizeName);

            // update visible canvas and d3 viz
            stylist.refreshViz();
        };
        var getPrintSizeByName = function( name ) {
            var matchingSize = $.grep(
                self.styleGuide.constraints.printSizes(), function(o) {
                    return o.name() === name;
                }
            )[0];
            if (typeof matchingSize === 'undefined') {
                console.warn('getPrintSizeByname(): no such size as "'+ name +'"!');
            }
            return matchingSize;
        }
        self.unitsFullName = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "inches"
                case units.CENTIMETERS:
                    return "centimeters";
            }
        }, self, {deferEvaluation:true});
        self.unitsDisplayAbbreviation = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "in."
                case units.CENTIMETERS:
                    return "cm";
            }
        }, self, {deferEvaluation:true});
        self.unitsCssSuffix = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "in"
                case units.CENTIMETERS:
                    return "cm";
            }
        }, self, {deferEvaluation:true});

        self.useChosenFontFamily = function() {
            var fontName = $('#style-fontfamily-chooser').val();
            var selectedFont = getFontFamilyByName( fontName );
            if (!selectedFont) {
                console.warn('useChosenFontFamily(): no matching font found!');
                return;
            }
            if (selectedFont.value) {
                // Custom size should retain current settings
                self.style.fontFamily( selectedFont.value() );
            }
            if (fontName === 'Something else') {
                $('#style-fontfamily-options').show();
            } else {
                $('#style-fontfamily-options').hide();
            }
        };
        self.updateFontFamilyChooser = function() {
            // (de)select matching font after manual adjustments
            var matchingFont = $.grep(
                self.styleGuide.constraints.fontFamilies(), 
                function(o) {
                    if (!('value' in o)) return false; // 'Something else' never matches
                    if (o.value() !== self.style.fontFamily()) return false;
                    return true;
                }
            )[0];
            var matchingFontName = 'Something else';
            if (matchingFont) {
                matchingFontName = matchingFont.name();
                $('#style-fontfamily-options').hide();
            } else {
                $('#style-fontfamily-options').show();
            }
            $('#style-fontfamily-chooser').val(matchingFontName);
        };
        var getFontFamilyByName = function( name ) {
            var matchingFont = $.grep(
                self.styleGuide.constraints.fontFamilies(), function(o) {
                    return o.name() === name;
                }
            )[0];
            if (typeof matchingFont === 'undefined') {
                console.warn('getFontFamilyByname(): no such font as "'+ name +'"!');
            }
            return matchingFont;
        }

        self.minTextSizeHelper = ko.computed(function() {
            // explain this size in chosen units
            var html;
            var chosenSize = self.styleGuide.constraints.minimumTextSize();
            if (isNaN(chosenSize) || $.trim(chosenSize) === '') {
                // rejects any non-numeric chars, allows whitespace and decimal
                html = '<em>This value must be a number</em>';
            } else {
                // echo the new size (in pt) as inches/cm
                chosenSize = parseFloat(chosenSize);
                var convertedSize = self.style.printSize.units() === units.INCHES ?
                    stylist.pointsToInches( chosenSize ) :
                    stylist.pointsToCentimeters( chosenSize );
                convertedSize = convertedSize.toFixed(2);
                var unitSuffix = self.style.printSize.units() === units.INCHES ?
                    'inches' : 'cm';
                html = 'pt &nbsp;('+ convertedSize +' '+ unitSuffix +')';
            }
            return html;
        }, self, {deferEvaluation:true});

        self.minLineThicknessHelper = ko.computed(function() {
            // explain this size in chosen units
            var html;
            var chosenSize = self.styleGuide.constraints.minimumLineThickness();
            if (isNaN(chosenSize) || $.trim(chosenSize) === '') {
                // rejects any non-numeric chars, allows whitespace and decimal
                html = '<em>This value must be a number</em>';
            } else {
                // echo the new size (in pt) as inches/cm
                chosenSize = parseFloat(chosenSize);
                var convertedSize = self.style.printSize.units() === units.INCHES ?
                    stylist.pointsToInches( chosenSize ) :
                    stylist.pointsToCentimeters( chosenSize );
                convertedSize = convertedSize.toFixed(2);
                var unitSuffix = self.style.printSize.units() === units.INCHES ?
                    'inches' : 'cm';
                html = 'pt &nbsp;('+ convertedSize +' '+ unitSuffix +')';
            }
            return html;
        }, self, {deferEvaluation:true});

        self.moveElementUp = function(el) {
              var tempList = self.elements().slice(0);
              var currentPos = $.inArray(el, tempList);
              var previousPos = currentPos - 1;
              tempList[currentPos] = tempList[previousPos];
              tempList[previousPos] = el;
              self.elements(tempList);
        }
        self.moveElementDown = function(el) {
              var tempList = self.elements().slice(0);
              var currentPos = $.inArray(el, tempList);
              var nextPos = currentPos + 1;
              tempList[currentPos] = tempList[nextPos];
              tempList[nextPos] = el;
              self.elements(tempList);
        }
        self.confirmRemoveElement = function(el) {
            var displayName, removeMethod;
            if (el instanceof IllustratedTree) {
                if (confirm("Are you sure you want to remove this tree? This cannot be undone!")) {
                    self.removeIllustratedTree(el);
                }
            } else if (el instanceof SupportingDataset) {
                if (confirm("Are you sure you want to remove this dataset? This cannot be undone!")) {
                    self.removeSupportingDataset(el);
                }
            } else if (el instanceof Ornament) {
                if (confirm("Are you sure you want to remove this ornament? This cannot be undone!")) {
                    self.removeOrnament(el);
                }
            } else {
                console.error("confirmRemoveElement(): unexpeced element type: '"+ el.metadata.type() +"'!");
                return;
            }
        }

        /* Instead of explicitly defining all possible members, let's
         * trust the ko.mapping plugin to handle loading and saving 
         * illustration data from JS(ON), with mapping options to handle
         * any exceptional stuff.
         */
        var mappingOptions = {
            /* Use to handle special cases:
             *  'ignore' to keep some clutter out of the saved model
             *  'include' to force view-model properties to be saved
             *  'copy' to keep simple values simple (vs. observable)
             *  'observe' ONLY if it's easier to whitelist the observables
             *  'create' map some elements to object classes
             *  'update'? convert Dates to ISO date-strings, ints to floats
             *  'key': pin elements to specified keys
             * See http://knockoutjs.com/documentation/plugins-mapping.html
             */
            'ignore': [ 'constructor' ],
            'include': [ ],
            'copy': [ 'vegaSpec' ],
            // 'observe': [ ], // WARNING: using this flips default mapping!
            'elements': {
                'create': function(options) {
                    // create these as object instances
                    var data = options.data;
                    var dataParent = options.parent;
                    var _illustration = self;
                    switch(data.metadata.type) {
                        // pass illustration to get IDs as needed
                        case 'IllustratedTree':
                            return new IllustratedTree(_illustration, data);
                        case 'SupportingDataset':
                            return new SupportingDataset(_illustration, data);
                        case 'Ornament':
                            return new Ornament(_illustration, data);
                    }
                    // keep it simple by default
                    console.warn("Unexpected element type '"+ data.metadata.type +"'! Creating a generic observable...");
                    return ko.observable(data);
                },
                'key': function(data) {
                    // use 'id' attribute to pin these
                    return ko.utils.unwrapObservable(data.id);
                }
            }
        };
        /* Map incoming data from a JS object. NOTE that we can also do 
         * this piecemeal to (for example) apply new styles to an illustration.
         *
         * TODO: Add some valication or other sanity checks after mapping, to
         * make sure we're not getting nonsense from the saved model?
         */
        ko.mapping.fromJS(data, mappingOptions, self);

        // Add validation for fields that need it
        self.metadata.name.extend({required: true});

        // Reset serial element IDs for this illustration
        initSerialElementIDs();

        self.exportModelAsObject = function() {
            var obj = ko.mapping.toJS(self);
            // TODO: any cleanup here?
            return obj;
        };

        self.exportModelAsJSON = function() {
            var json = ko.mapping.toJSON(self);
            // TODO: any cleanup here?
            return json;
        };

    }
    /* define PUBLIC methods (that don't need private data) in its prototype */
    Illustration.prototype = {
        constructor: Illustration,

        applyStyleGuide: function(data) {
            var self = this;
            ko.mapping.fromJS(data, Illustration.mappingOptions, self.styleGuide);

            /* Some properties are *forced* (rather then suggested) to comply
             * with the active style guide. 
             *
             * TODO: Reconsider this! Each field should probably be defined
             * either as a constraint OR a per-illustration * style assertion.
             */
            var forcedStyles = [
                'backgroundColor',
                'border',
                'edgeColor',
                'edgeThickness',
                'nodeColor',
                'nodeShape'
            ];
            $.each(forcedStyles, function(i, propName) {
                self.style[propName]( self.styleGuide.constraints[propName]() );
            });

            self.updatePrintSizeChooser();
            self.updateFontFamilyChooser();
            stylist.refreshViz();
        },

        addIllustratedTree: function() {
            var self = this;
            var tree = new IllustratedTree(self);
            self.elements.push(tree);
            stylist.refreshViz();
            return tree;
        },
        removeIllustratedTree: function(tree) {
            var self = this;
            self.elements.remove(tree);
            stylist.refreshViz();
            delete tree;
        },

        addSupportingDataset: function() {
            var self = this;
            var ds  = new SupportingDataset(self);
            self.elements.push(ds);
            stylist.refreshViz();
            return ds;
        },
        removeSupportingDataset: function(ds) {
            var self = this;
            self.elements.remove(ds);
            stylist.refreshViz();
            delete ds;
        },

        addOrnament: function() {
            var self = this;
            var obj  = new Ornament(self);
            self.elements.push(obj);
            stylist.refreshViz();
            return obj;
        },
        removeOrnament: function(obj) {
            var self = this;
            self.elements.remove(obj);
            stylist.refreshViz();
            delete obj;
        },

        /* For a given node, retrieve the best possible label field
         * (optionally from a ranked list of fields) or its text.
         *
         * This is CURRENTLY UNUSED, but may be useful if we want to support
         * fallback labeling based on a ranked list of sources, for example
         *   ['explicitLabel', 'ottTaxonName', 'originalLabel']
         */
        getPreferredLabelField: function(node, rankedFields) {
            if (!rankedFields) {
                rankedFields = ['explicitLabel','ottTaxonName','originalLabel','ottId'];
            }
            var foundNonEmptyLabel = 'explicitLabel';  // a harmless default
            $.each(rankedFields, function(i,fieldName) {
                if (node[fieldName]) {
                    foundNonEmptyLabel = fieldName;
                    return false;  // stop checking
                }
            });
            console.warn("Using label field '"+ foundNonEmptyLabel +"' for this node:");
            console.warn(node);
            return foundNonEmptyLabel;
        },
        getPreferredLabelText: function(node, rankedFields) {
            var self = this;
            var preferredField = self.getPreferredLabelField(node, rankedFields);
            var preferredText = node[preferredField];
            if (typeof preferredText === 'string') {
                return preferredText;
            }
            return '';
       },

        /* For a given element (eg, a tree, node, edge, ornament, or the
         * illustration itself), get the most "local" matching style value for
         * the specified property. By default, this should conform to the 
         * illustration itself, or its active style guide.
         */
        getEffectiveStyle: function(obj, propName) {
            var self = this;
            if ('style' in obj) {
                if (propName in obj.style) {
                    // handle observables or simple values
                    var rawValue = ko.utils.unwrapObservable(obj.style[propName]);
                    var constrainedValue = self.getConstrainedStyle(propName, rawValue);
                    return constrainedValue;
                }
            }
            // property wasn't found locally; check the next "innermost" context 
            if (obj instanceof IllustratedTree) {
                return self.getEffectiveStyle(self, propName);
            } else if (obj instanceof Illustration) {
                console.error("getEffectiveStyle(): style '"+ propName +"' not found in this tree's style:");
                console.error(obj.style);
                return;
            } else if (obj instanceof SupportingDataset) {
                console.error("getEffectiveStyle(): SupportingDataset is not yet supported!");
                return;
            } else if (obj instanceof Ornament) {
                console.error("getEffectiveStyle(): Ornament is not yet supported!");
                return;
            } else {
                console.error("getEffectiveStyle(): unexpected context object:");
                console.error(obj);
                return;
            }
        },
        getConstrainedStyle: function (propName, rawValue) {
            var self = this;
            switch(propName) {
                case 'edgeThickness':
                case 'borderThickness':
                    // assume these are in common units (pt?)
                    var thinnest = self.styleGuide.constraints.minimumLineThickness();
                    return Math.max(rawValue, thinnest);
                // TODO: add (many) more cases here, or constrain elsewhere..
                default:
                    // anything goes, return unchanged
                    return rawValue;
            }
        },

        updateVegaSpec: function(options) {
            /* Sweep the Illustration model and (re)generated a full Vega spec.
             * This drives the d3 visualization in the editor viewport.
             */
            var self = this;
            var spec = self.vegaSpec;

            // clear all groups and marks, and restore the empty illustration-elements group
            spec.marks = [ ];
            // reckon the current width and height as internal px
            var pxPrintWidth = stylist.physicalUnitsToPixels(self.style.printSize.width(), stylist.internal_ppi);
            var pxPrintHeight = stylist.physicalUnitsToPixels(self.style.printSize.height(), stylist.internal_ppi);
            var illustrationElementsGroup = {
                "type": "group",
                "name": "illustration-elements",  // becomes marker class .illustration-elements
                "properties": {
                    "enter": {
                        "x": {"value": 0},
                        "y": {"value": 0},
                        "height": {"value": pxPrintHeight },
                        "width": {"value": pxPrintWidth }
                    }
                },
                "scales": [ ],
                "axes": [ ],
                "marks": [ ]
            };
            spec.marks.push( illustrationElementsGroup );

            // clear and rebuild data based on current elements
            spec.data = [ ];

            $.each(self.elements(), function(i, el) {
                // Add appropriate data *and* marks as needed
                if (el instanceof IllustratedTree) {
                    var dataSourceName = el.id();  // "tree-3" or similar
                    var treeData = {
                        'name': dataSourceName,
                        'format': {"type":"treejson"},  // initial match for JSON object, vs. array
                         // TODO: support args for "treesCollectionPosition", "treePosition" or "treeID"?
                        'transform': [
                            // TODO: add all possible properties (common to by all formats?)
                            // TODO: merge supporting data from other files? or do that downstream?
                            // TODO: final tailoring to phylogram layout (one, or several?)
                        ]
                    }

                    /* Define data source for this element (allow for inline tree data? in 
                     * existing datasets? other kinds of sources?)
                     * NOTE that we should use cached data when possible, to avoid 
                     * an AJAX fetch each time we tweak the visual presentation of a tree!
                     */
                    var treeSourceCacheKey = 'ELEMENT-SOURCE-';
                    switch (el.metadata.source.type()) { 
                        case dataSourceTypes.BUILT_IN:
                        case dataSourceTypes.URL:
                            treeSourceCacheKey += $.trim(el.metadata.source.value());
                            var cachedValue = getCachedData( treeSourceCacheKey );
                            if (cachedValue) {
                                // N.B. This data will be safely cloned by Vega when spec is parsed!
                                treeData.values = cachedValue;
                            } else {
                                treeData.url = el.metadata.source.value();
                            }
                            break;
                        case dataSourceTypes.UPLOAD:
                            var sourceValue = $.trim(el.metadata.source.value());
                            if (sourceValue === '') {
                                console.log("updateVegaSpec(): ignoring empty paste/uploads for now");
                                return;
                            }
                            var treeSourceCacheKey = ('PASTED-SOURCE-' + sourceValue);
                            var cachedValue = getCachedData( treeSourceCacheKey );
                            if (cachedValue) {
                                // N.B. This data will be safely cloned by Vega when spec is parsed!
                                treeData.values = cachedValue;
                            } else {
                                console.warn("Still waiting for pasted text (Newick?) of '"+ el.metadata.name() +"'to be converted...");
                            }
                            break;
                        // TODO: add cases for other data sources
                        default:
                            console.error("Unknown source type for tree!");
                    }

                    /* Build an appropriate chain of data transforms */

                    // Cache the source data, if not already found
                    treeData.transform.push({
                        "type": "stash", 
                        "cachePath": 'TreeIllustrator.cache',
                        "key": treeSourceCacheKey,
                        "flush": false
                    });

                    // Next transform imports data from its source format to our basic phyloTree
                    if (true) { 
                        treeData.transform.push({
                            "type": "nexson", 
                            "treesCollectionPosition":0, 
                            "treePosition":0
                        });
                    }

                    // TODO: Shape the phyloTree using preferred tree layout and styles
                    var phylogramTransform = { 
                        "type": "phylogram", 
                        //"layout": "cartesian",
                        //"radialArc": [90, 270],
                        //"radialSweep": 'CLOCKWISE',
                        "radialSweep": 'COUNTERCLOCKWISE',
                        //"branchStyle": "diagonal",  // other options here?
                        "branchLengths": "",  // empty/false, or a property name to compare?
                        "width": el.width(),
                        "height": el.height(), 
                        "radius": el.radius(), 
                        "tipsAlignment": el.tipsAlignment()
                    };
                    treeData.transform.push( phylogramTransform );
                    switch (el.layout()) { 
                        case treeLayouts.RECTANGLE:
                            phylogramTransform.layout = 'cartesian';
                            break;
                        case treeLayouts.CIRCLE:
                            phylogramTransform.layout = 'radial';
                            break;
                        case treeLayouts.TRIANGLE:
                            phylogramTransform.layout = 'cladogram';
                            break;
                    }

                    spec.data.push(treeData);

                    // set label properties (esp. positioning) based on the chosen layout
                    var textHeight = self.styleGuide.constraints.minimumTextSize();   // TODO: adjustable font size (convert pt to px)
                    var halfTextHeight = textHeight * 0.4;   // TODO: adjustable font size (convert pt to px)
                    var initialLabelProperties = {
                        "fontSize": {"value": textHeight} 
                    };
                    switch (el.layout()) { 
                        case treeLayouts.RECTANGLE:
                        case treeLayouts.TRIANGLE:
                            // Label offsets depend on orientation
                            var labelNudgeX, labelNudgeY, labelAlign, labelRotation;
                            var nodeLabelGap = 6;  // TODO: base this on font size
                            switch (el.tipsAlignment()) {
                                case alignments.TOP:
                                    // NOTE the odd mapping of X and Y
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = -90;
                                    break;
                                case alignments.RIGHT:
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = 0;
                                    break;
                                case alignments.BOTTOM:
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = 90;
                                    break;
                                case alignments.LEFT:
                                    labelNudgeX = -nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'right';
                                    labelRotation = 0;
                                    break;
                            }
                            // Add simple properties for cartesian / rectangular layouts
                            $.extend(initialLabelProperties, {
                                "x": {"field": "x"},
                                "y": {"field": "y"},
                                "dx": {"value": labelNudgeX},
                                "dy": {"value": labelNudgeY},
                                "align": {"value": labelAlign},
                                "angle": {"value": labelRotation}
                            });
                            break;

                        case treeLayouts.CIRCLE:
                           /* Add properties for radial/polar layouts.
                            * Radius and theta (angle from origin, in radians) are the
                            * alternatives to X and Y for polar projection, and assume
                            * that the x and y properties represent the origin or center
                            * of the layout, ie, the root node. See discussion at
                            *  https://github.com/trifacta/vega/pull/187
                            */
                            $.extend(initialLabelProperties, {
                                "x": {"value": 0},  // this is origin for radial/polar projection
                                "y": {"value": 0},
                                "radius": {"field": "radius"},  // px from origin
                                "theta": {"field": "theta"},  // in radians (what direction from origin)
                                "align": {"field": 'align'},  // NOTE that some labels are flipped 180deg for legibility
                                "angle": {"field": "angle"}   // in degrees
                            });
                            break;
                    }

                    // place new trees in the center of the printable area (slightly staggered for clarity)
                    var treeMarks = { 
                        "type": "group",
                        "name": el.id(),  // becomes marker class .tree-3 or similar
                        "properties": {
                            "enter": {
                                "x": {"value": el.rootX()},
                                "y": {"value": el.rootY()}
                            },
                            "update": {
                                //"transform": {"value":"scale(800,300)"}
                                //"transform": {"value":"rotate(25) scale(20,20)"}
                            }
                        },
                        "marks": [
                            { /* pathsfor tree edges 
                                 N.B. This expects pre-existing links with 'source' and 'target' properties! The 'link' transform is 
                                 just to provide a rendered path of the desired type. */
                              "type": "path",
                              //"from": {"data": "phyloTree", "property": "links", "transform": [{"type": "link", "shape": "line"}]},
                              "from": {
                                "data": dataSourceName,
                                "transform": [
                                  {"type":"pluck", "field":"phyloEdges" }
                                // how do apply the 'time' scale here? TRY brute-forcing x and y properties
                                  //{"type":"formula", "field":"source.x", "expr":"d.source.y"},
                                  //{"type":"formula", "field":"target.x", "expr":"d.target.y"},
                                  // {"type":"link", "shape":"line" }  // line | curve | diagonal | diagonalX | diagonalY
                                  // {"type":"phylogramLink", "shape":"rightAngleDiagonal" }  // rightAngleDiagonal | radialRightAngleDiagonal
                                ]
                              },
                              "properties": {
                                "update": {
                                  "path": {"field": "path"}, // , "transform":{"scale":"x"}},
                                  "stroke": {"value": self.getEffectiveStyle(el, 'edgeColor')},
                                  "strokeWidth": {"value": self.getEffectiveStyle(el, 'edgeThickness')}
                                },
                                "hover": {
                                 // "stroke": {"value": "red"}
                                    }
                                  }
                                }
                                ,
                                {   /* group node/label pairs, for easier event binding later */
                                    "type":"group",
                                    "marks":[
                                        {
                                            "type": "symbol",
                                            "from": {"data": dataSourceName, "transform": [{"type":"pluck", "field":"phyloNodes" }] },
                                            "properties": {
                                                "enter": {
                                                    "x": {"XXscale": "x", "field": "x", "mult":1},
                                                    "y": {"XXscale": "y", "field": "y", "mult":1}
                                                },
                                                "update": {
                                                    "shape": {"value":"circle"},
                                                    "size": {"value": 8},
                                                    "fill": {"value": "black"}
                                                },
                                                "hover": {
                                                    // "fill": {"value": "red"}
                                                }
                                            }
                                        } /* end of node marks */
                                        ,
                                        {  // label marks
                                            "type": "text",
                                            "from": {"data": dataSourceName, "transform": [{"type":"pluck", "field":"phyloNodes" }] },
                                            "properties": {
                                                "enter": initialLabelProperties,
                                                "update": {
                                                    "text": {"field": el.nodeLabelField() },
                                                    "fill": {"value":"black"}
                                                },
                                                "hover": {
                                                    "fill": {"value": "red"}
                                                }
                                        }
                                    } /* end of label marks */
                                ]
                            } /* end of grouped node+label */ 
                        ] /* end of inner group marks */
                    }; /* end of inner group */

                    illustrationElementsGroup.marks.push( treeMarks );

                } else if (el instanceof SupportingDataset) {
                    console.log("updateVegaSpec(): ignoring datasets for now");

                } else if (el instanceof Ornament) {
                    console.log("updateVegaSpec(): ignoring ornaments for now");

                } else {
                    console.error("updateVegaSpec(): unexpeced element type: '"+ el.metadata.type() +"'!");
                }
            });

        }
    };

    /* We need to be able to define custom styles for many different elements of
     * the scene graph, e.g., a tree, node, or caption.
     */
    var SceneGraph = function(data) {
        if ( !(this instanceof SceneGraph) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new SceneGraph(data);
        }
        // safely refer to this instance
        var self = this;

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }

    var IllustratedTree = function(illustration, data) {
        if ( !(this instanceof IllustratedTree) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new IllustratedTree(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" tree object above
            data = getNewIllustratedTreeModel(illustration);
        }

        // safely refer to this instance
        var self = this;

        // point back to my parent illustration?
        //self.illustration = illustration;

        // Bind to writable computed observables, so users can "think in physical units"
        self.physicalWidth = wrapFieldWithPhysicalUnits(self, 'width');
        self.physicalHeight = wrapFieldWithPhysicalUnits(self, 'height');
        self.physicalRadius = wrapFieldWithPhysicalUnits(self, 'radius');
        self.physicalRootX = wrapFieldWithPhysicalUnits(self, 'rootX');
        self.physicalRootY = wrapFieldWithPhysicalUnits(self, 'rootY');

        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // Add validation for fields that need it
        self.metadata.name.extend({required: true});

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }
    IllustratedTree.prototype = {
        constructor: IllustratedTree,

        useChosenLayout: function(newValue) {
            var self = this;
            if (newValue in treeLayouts) {
                self.layout(newValue);
            } else {
                console.error("useChosenLayout(): Unknown tree layout '"+ newValue +"'!"); 
            }
            stylist.refreshViz();
        }
        ,
        useChosenTreeDataSource: function() {
            var self = this;
            // pick up latest data from bound widgets
            var $chooser = $('#'+ self.id() +'-datasource-chooser');
            var $opentreeIDsPanel = $('#'+ self.id() +'-datasource-opentreeids-panel');
            var $nexsonUrlPanel = $('#'+ self.id() +'-datasource-nexsonurl-panel');
            var $fileUploadPanel = $('#'+ self.id() +'-datasource-upload-panel');
            var chosenSource = $chooser.val();
            switch(chosenSource) {
                /* Match against strings defined in `stylist.js`. We'll start
                 * with some special cases that drive changes to the UI.
                 */
                case "Enter OpenTree study and tree ids":
                    $opentreeIDsPanel.show();
                    $nexsonUrlPanel.hide();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var studyID = self.metadata.source.phylesystemStudyID(); 
                    var treeID = self.metadata.source.phylesystemTreeID();
                    var treeNexsonURL = 'http://api.opentreeoflife.org/phylesystem/v1/study/'
                                      + studyID +'/tree/'+ treeID +'?output_nexml2json=1.0.0';
                    self.metadata.source.value( treeNexsonURL );
                    break;

                case "Enter URL to NexSON 1.0":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Enter URL to a GitHub gist":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                        // TODO: Use another field for Gist URLs?
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Paste/enter tree data":
                //case "Upload tree data":
                //case "Newick string":
                //case "Newick string with extra data":
                //case "NEXUS":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.hide();
                    // enable "pasted text" field for this method
                    var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                    $pastedField.attr('disabled', false);
                    $fileUploadPanel.show();
                    break;

                default:
                    /* Handle common cases for listed tree sources:
                     *  - explicit "fetch" URLs for data on the web
                     *  - Jupyter kernel values from a hosting notebook
                     */
                    // Look for the matching URL at any level of this tree of *observable* arrays
                    var testLists = [stylist.availableTrees()];
                    $.each(stylist.availableTrees(), function(i, testItem) {
                        if ('children' in testItem) {
                            testLists.push(testItem.children());
                        }
                    });
                    var treeInfo = null;
                    $.each(testLists, function(i, testList) {
                        // ASSUMES unique display text for all items in nested list!
                        var selectedTrees = $.grep(testList, function(o) {
                            return o.name() === chosenSource;
                        });
                        if (selectedTrees.length > 0) {
                            treeInfo = selectedTrees[0];
                        }
                    });
                    if (!treeInfo) {
                        console.warn("No tree found under '"+ chosenSource +"'!");
                        return;
                    }
                    if ('url' in treeInfo) {
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        $fileUploadPanel.hide();
                        self.metadata.source.type(dataSourceTypes.URL);
                        self.metadata.source.value( treeInfo.url() );
                    } else if ('kernel' in treeInfo) { // or 'kernel'? 'nbkernel'?
                        // assume this is 'python' for now
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        // Disable the format chooser while we try to guess
                        var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                        $inputFormatChooser.attr('disabled', true);
                        // disable "pasted text" field (display only)
                        var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                        $pastedField.attr('disabled', true);
                        $fileUploadPanel.show();
                        // TODO: For a multi-kernel notebook, expect a specific kernel-id, eg 'python2'
                        var nbVarName = treeInfo.name().split(' ')[0];
                        getTreeSourceData(nbVarName, function(response) {
                            if ('data' in response) {
                                var treeSourceData = response.data;
                                /* To interpret this as tree source data, we'll 
                                 * need to figure out its format. Pass it to a 
                                 * series of "sniffers" to identify Newick, Nexson, etc.
                                 */
debugger;
// TODO: push this source into persistent storage?
///self.metadata.source.value(treeSourceData);
                                var matchingFormat = mostLikelyDataFormat(treeSourceData);
                                $inputFormatChooser.val(matchingFormat);
                                // show this text in the (disabled) text field
                                $pastedField.val(treeSourceData);
                            } else {
                                var msg = response.error || "No data returned (unspecified error)!";
                                console.error(msg);
                                alert(msg);
                            }
                            $inputFormatChooser.attr('disabled', false);
                        });
                    } else {
                        // Maybe this string should be added to the special cases above!
                        console.warn("No URL or kernel found for '"+ chosenSource +"'!");
                        return;
                    }
            }
            stylist.refreshViz();
        }
        ,
        useChosenLabelField: function() {
            var self = this;
            // pick up latest data from bound widgets
            var $chooser = $('#'+ self.id() +'-labelfield-chooser');
            self.nodeLabelTextField = $chooser.val();
            stylist.refreshViz();
        }
        ,
        convertPastedDataToTree: function(treeID) {
            // Try to convert pasted/uploaded text to nexson, using the conversion
            // methods in the main open tree curation tool.
            var self = this;  // the tree in question
            var $pastedField = $('#'+ self.id() +'-datasource-pasted');
            var pastedText = $.trim($pastedField.val());
            if (pastedText === '') {
                alert("Please paste Newick or other text into the text area provided, then try again.");
                // TODO: clear any cached and internal values regardless, to hide an old tree?
                return;
            }
            self.metadata.source.value( pastedText );
            self.metadata.source.type(dataSourceTypes.UPLOAD);
            var treeSourceCacheKey = ('PASTED-SOURCE-' + $.trim(self.metadata.source.value()));
            // TODO: build up cache key with format + content?
            var cachedValue = getCachedData( treeSourceCacheKey );
            if (cachedValue) {
                // N.B. This data will be safely cloned by Vega when spec is parsed!
                // NOTE that we should still refresh immediately, in case the cached tree data was loaded
                // created for another tree, or an earlier version of this one.
                stylist.refreshViz();
            } else {
                // call opentree web services to convert to nexson
                //TODO: Apply other pasted formats (and REMEMBER THEM in the saved illustration!)
                var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                //$inputFormatChooser.attr('disabled', true);
                var inputFormat = $inputFormatChooser.val();
                if (inputFormat === '') {
                    alert("Please choose the format of this tree data, then try again.");
                    return;
                }
                $.ajax({
                    type: 'POST',
                    dataType: 'json',
                    // crossDomain: true,
                    contentType: "application/json; charset=utf-8",
                    url: 'https://devtree.opentreeoflife.org/curator/to_nexson',
                    /* NOTE that idPrefix and firstAvailable*ID args are
                     * currently required to get well-formed Nexson!
                     */
                    data: ('{"output": "ot:nexson", '+
                            '"auth_token": "ANONYMOUS", '+
                            '"idPrefix": "", ' +
                            '"firstAvailableEdgeID": "1", '+
                            '"firstAvailableNodeID": "1", '+
                            '"firstAvailableOTUID": "1", '+
                            '"firstAvailableOTUsID": "1", '+
                            '"firstAvailableTreeID": "1", '+
                            '"firstAvailableTreesID": "1", '+
                            '"firstAvailableAnnotationID": "1", '+
                            '"firstAvailableAgentID": "1", '+
                            '"firstAvailableMessageID": "1", '+
                            '"inputFormat": '+ JSON.stringify(inputFormat) +', '+
                            '"content": '+ JSON.stringify($.trim(self.metadata.source.value())) +
                           ' }'),
                    processData: false,
                    complete: function( jqXHR, textStatus ) {
                        // report errors or malformed data, if any
                        if (textStatus !== 'success') {
                            if (jqXHR.status >= 500) {
                                // major server-side error, just show raw response for tech support
                                var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                                alert(errMsg);
                                return;
                            }
                            // Server blocked the save due to major validation errors!
                            var data = $.parseJSON(jqXHR.responseText);
                            // TODO: This should be properly parsed JSON, show it more sensibly
                            // (but for now, repeat the crude feedback used above)
                            var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                            alert(errMsg);
                            return;
                        }
                        // Pasted tree was converted successfully; capture the Nexson as a string
                        var data = $.parseJSON(jqXHR.responseText);

                        // fix any quirks to conform to our expected Nexson structure
                        fixUpConvertedNexson(data);

                        // store it in the cache, at the key defined above
                        setCachedData( treeSourceCacheKey, data );
                        // adjust node-label field to show "explicit" labels (this will trigger a display refresh)
                        var $labelChooser = $('#'+ self.id() +'-labelfield-chooser');
                        $labelChooser.val('explicitLabel').change();
                        //stylist.refreshViz();
                    }
                });
            }
        }
        ,
        useChosenTipsAlignment: function(newValue) {
            var self = this;
            if (newValue in alignments) {
                self.tipsAlignment(newValue);
            } else {
                console.error("useChosenTipsAlignment(): Unknown tree layout '"+ newValue +"'!"); 
            }
            stylist.refreshViz();
        }

    };

    var SupportingDataset = function(illustration, data) {
        if ( !(this instanceof SupportingDataset) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new SupportingDataset(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" dataset object above
            data = getNewSupportingDatasetModel(illustration);
        }

        // safely refer to this instance
        var self = this;
        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }
    var Ornament = function(illustration, data) {
        if ( !(this instanceof Ornament) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new Ornament(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" ornament object above
            data = getNewOrnamentModel(illustration);
        }

        // safely refer to this instance
        var self = this;
        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }


    /* We need to be able to define custom styles for many different elements of
     * the scene graph, e.g., a tree, node, or caption.
     */
    var StyleOverrides = function(data) {
        if ( !(this instanceof StyleOverrides) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new StyleOverrides(data);
        }
        // safely refer to this instance
        var self = this;

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }

    /* We'll often want to show values using the chosen physical units (inches
     * or cm), but store them as internal SVG pixels. This makes it easy to
     * declare these as computed properties, eg, wrap width => 'physicalWidth'
     */
    var wrapFieldWithPhysicalUnits = function(obj, fieldName, precision) {
        // Display using selected precision (number of places), with hundredths by default.
        precision = precision || 2;  
        return ko.computed({
            read: function() {
                var physicalValue = stylist.pixelsToPhysicalUnits(obj[ fieldName ](), stylist.internal_ppi);
                return Number(Math.round(physicalValue + "e+" + precision) + "e-" + precision);
            },
            write: function(value) {
                obj[ fieldName ]( stylist.physicalUnitsToPixels(value, stylist.internal_ppi));
            },
            owner: obj,
            deferEvaluation: true
        })
    }

    /* Newick (and other?) formats converted Nexson may be missing some
     * elements we expect. Add these now. */
    var fixUpConvertedNexson = function(data) {
        // 'data' is nexml in typical JSON wrapper
        var nexml = data.data.nexml;
        var nodeHasChildren = function(node, tree) {
            var childFound = false;
            $.each(tree.edge, function(i,edge) {
                if (edge['@source'] === node['@id']) {
                    childFound = true;
                }
            });
            return childFound;
        };
        $.each(nexml.trees, function(i,treeCollection) { // mark childless nodes with 'ot:isleaf'
            $.each(treeCollection.tree, function(i, tree) {
                var leafNodes = $.grep(tree.node, function(node) { 
                    if (nodeHasChildren(node,tree)) {
                        // modify internal nodes?
                    } else {
                        node['^ot:isLeaf'] = true;
                    }
                });
            });
        });
    }

    /* Use sniffers to determine the most likely format of input tree data */
    var mostLikelyDataFormat = function (data) {
        return utils.isProbablyNewick(data) ? 'newick' : 
                   utils.isProbablyNEXUS(data) ? 'nexus' :
                       utils.isProbablyNeXML(data) ? 'nexus' :
                           ''  // format unknown
    }

    /* expose class constructors (and static methods) for instantiation */
    return {
        // expose enumerations
        units: units,
        colorDepths: colorDepths,
        treeLayouts: treeLayouts,
        alignments: alignments,
        dataSourceTypes: dataSourceTypes,
        versionTypes: versionTypes,
        hostApplications: hostApplications,
        cache: cache,

        // expose view-model classes
        Illustration: Illustration,
        SceneGraph: SceneGraph,
        IllustratedTree: IllustratedTree,
        SupportingDataset: SupportingDataset,
        Ornament: Ornament,
        StyleOverrides: StyleOverrides
    };
}(window, document, $, ko, stylist);

for (var name in TreeIllustrator) {
    exports[ name ] = TreeIllustrator[ name ];
}

},{"./stylist.js":147,"./ti-utils.js":148}],146:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*! jQuery v1.8.3 jquery.com | jquery.org/license */
(function(e,t){function _(e){var t=M[e]={};return v.each(e.split(y),function(e,n){t[n]=!0}),t}function H(e,n,r){if(r===t&&e.nodeType===1){var i="data-"+n.replace(P,"-$1").toLowerCase();r=e.getAttribute(i);if(typeof r=="string"){try{r=r==="true"?!0:r==="false"?!1:r==="null"?null:+r+""===r?+r:D.test(r)?v.parseJSON(r):r}catch(s){}v.data(e,n,r)}else r=t}return r}function B(e){var t;for(t in e){if(t==="data"&&v.isEmptyObject(e[t]))continue;if(t!=="toJSON")return!1}return!0}function et(){return!1}function tt(){return!0}function ut(e){return!e||!e.parentNode||e.parentNode.nodeType===11}function at(e,t){do e=e[t];while(e&&e.nodeType!==1);return e}function ft(e,t,n){t=t||0;if(v.isFunction(t))return v.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return v.grep(e,function(e,r){return e===t===n});if(typeof t=="string"){var r=v.grep(e,function(e){return e.nodeType===1});if(it.test(t))return v.filter(t,r,!n);t=v.filter(t,r)}return v.grep(e,function(e,r){return v.inArray(e,t)>=0===n})}function lt(e){var t=ct.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function At(e,t){if(t.nodeType!==1||!v.hasData(e))return;var n,r,i,s=v._data(e),o=v._data(t,s),u=s.events;if(u){delete o.handle,o.events={};for(n in u)for(r=0,i=u[n].length;r<i;r++)v.event.add(t,n,u[n][r])}o.data&&(o.data=v.extend({},o.data))}function Ot(e,t){var n;if(t.nodeType!==1)return;t.clearAttributes&&t.clearAttributes(),t.mergeAttributes&&t.mergeAttributes(e),n=t.nodeName.toLowerCase(),n==="object"?(t.parentNode&&(t.outerHTML=e.outerHTML),v.support.html5Clone&&e.innerHTML&&!v.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):n==="input"&&Et.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):n==="option"?t.selected=e.defaultSelected:n==="input"||n==="textarea"?t.defaultValue=e.defaultValue:n==="script"&&t.text!==e.text&&(t.text=e.text),t.removeAttribute(v.expando)}function Mt(e){return typeof e.getElementsByTagName!="undefined"?e.getElementsByTagName("*"):typeof e.querySelectorAll!="undefined"?e.querySelectorAll("*"):[]}function _t(e){Et.test(e.type)&&(e.defaultChecked=e.checked)}function Qt(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Jt.length;while(i--){t=Jt[i]+n;if(t in e)return t}return r}function Gt(e,t){return e=t||e,v.css(e,"display")==="none"||!v.contains(e.ownerDocument,e)}function Yt(e,t){var n,r,i=[],s=0,o=e.length;for(;s<o;s++){n=e[s];if(!n.style)continue;i[s]=v._data(n,"olddisplay"),t?(!i[s]&&n.style.display==="none"&&(n.style.display=""),n.style.display===""&&Gt(n)&&(i[s]=v._data(n,"olddisplay",nn(n.nodeName)))):(r=Dt(n,"display"),!i[s]&&r!=="none"&&v._data(n,"olddisplay",r))}for(s=0;s<o;s++){n=e[s];if(!n.style)continue;if(!t||n.style.display==="none"||n.style.display==="")n.style.display=t?i[s]||"":"none"}return e}function Zt(e,t,n){var r=Rt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function en(e,t,n,r){var i=n===(r?"border":"content")?4:t==="width"?1:0,s=0;for(;i<4;i+=2)n==="margin"&&(s+=v.css(e,n+$t[i],!0)),r?(n==="content"&&(s-=parseFloat(Dt(e,"padding"+$t[i]))||0),n!=="margin"&&(s-=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0)):(s+=parseFloat(Dt(e,"padding"+$t[i]))||0,n!=="padding"&&(s+=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0));return s}function tn(e,t,n){var r=t==="width"?e.offsetWidth:e.offsetHeight,i=!0,s=v.support.boxSizing&&v.css(e,"boxSizing")==="border-box";if(r<=0||r==null){r=Dt(e,t);if(r<0||r==null)r=e.style[t];if(Ut.test(r))return r;i=s&&(v.support.boxSizingReliable||r===e.style[t]),r=parseFloat(r)||0}return r+en(e,t,n||(s?"border":"content"),i)+"px"}function nn(e){if(Wt[e])return Wt[e];var t=v("<"+e+">").appendTo(i.body),n=t.css("display");t.remove();if(n==="none"||n===""){Pt=i.body.appendChild(Pt||v.extend(i.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!Ht||!Pt.createElement)Ht=(Pt.contentWindow||Pt.contentDocument).document,Ht.write("<!doctype html><html><body>"),Ht.close();t=Ht.body.appendChild(Ht.createElement(e)),n=Dt(t,"display"),i.body.removeChild(Pt)}return Wt[e]=n,n}function fn(e,t,n,r){var i;if(v.isArray(t))v.each(t,function(t,i){n||sn.test(e)?r(e,i):fn(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&v.type(t)==="object")for(i in t)fn(e+"["+i+"]",t[i],n,r);else r(e,t)}function Cn(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i,s,o=t.toLowerCase().split(y),u=0,a=o.length;if(v.isFunction(n))for(;u<a;u++)r=o[u],s=/^\+/.test(r),s&&(r=r.substr(1)||"*"),i=e[r]=e[r]||[],i[s?"unshift":"push"](n)}}function kn(e,n,r,i,s,o){s=s||n.dataTypes[0],o=o||{},o[s]=!0;var u,a=e[s],f=0,l=a?a.length:0,c=e===Sn;for(;f<l&&(c||!u);f++)u=a[f](n,r,i),typeof u=="string"&&(!c||o[u]?u=t:(n.dataTypes.unshift(u),u=kn(e,n,r,i,u,o)));return(c||!u)&&!o["*"]&&(u=kn(e,n,r,i,"*",o)),u}function Ln(e,n){var r,i,s=v.ajaxSettings.flatOptions||{};for(r in n)n[r]!==t&&((s[r]?e:i||(i={}))[r]=n[r]);i&&v.extend(!0,e,i)}function An(e,n,r){var i,s,o,u,a=e.contents,f=e.dataTypes,l=e.responseFields;for(s in l)s in r&&(n[l[s]]=r[s]);while(f[0]==="*")f.shift(),i===t&&(i=e.mimeType||n.getResponseHeader("content-type"));if(i)for(s in a)if(a[s]&&a[s].test(i)){f.unshift(s);break}if(f[0]in r)o=f[0];else{for(s in r){if(!f[0]||e.converters[s+" "+f[0]]){o=s;break}u||(u=s)}o=o||u}if(o)return o!==f[0]&&f.unshift(o),r[o]}function On(e,t){var n,r,i,s,o=e.dataTypes.slice(),u=o[0],a={},f=0;e.dataFilter&&(t=e.dataFilter(t,e.dataType));if(o[1])for(n in e.converters)a[n.toLowerCase()]=e.converters[n];for(;i=o[++f];)if(i!=="*"){if(u!=="*"&&u!==i){n=a[u+" "+i]||a["* "+i];if(!n)for(r in a){s=r.split(" ");if(s[1]===i){n=a[u+" "+s[0]]||a["* "+s[0]];if(n){n===!0?n=a[r]:a[r]!==!0&&(i=s[0],o.splice(f--,0,i));break}}}if(n!==!0)if(n&&e["throws"])t=n(t);else try{t=n(t)}catch(l){return{state:"parsererror",error:n?l:"No conversion from "+u+" to "+i}}}u=i}return{state:"success",data:t}}function Fn(){try{return new e.XMLHttpRequest}catch(t){}}function In(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function $n(){return setTimeout(function(){qn=t},0),qn=v.now()}function Jn(e,t){v.each(t,function(t,n){var r=(Vn[t]||[]).concat(Vn["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function Kn(e,t,n){var r,i=0,s=0,o=Xn.length,u=v.Deferred().always(function(){delete a.elem}),a=function(){var t=qn||$n(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,i=1-r,s=0,o=f.tweens.length;for(;s<o;s++)f.tweens[s].run(i);return u.notifyWith(e,[f,i,n]),i<1&&o?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:v.extend({},t),opts:v.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:qn||$n(),duration:n.duration,tweens:[],createTween:function(t,n,r){var i=v.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(i),i},stop:function(t){var n=0,r=t?f.tweens.length:0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;Qn(l,f.opts.specialEasing);for(;i<o;i++){r=Xn[i].call(f,e,l,f.opts);if(r)return r}return Jn(f,l),v.isFunction(f.opts.start)&&f.opts.start.call(e,f),v.fx.timer(v.extend(a,{anim:f,queue:f.opts.queue,elem:e})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function Qn(e,t){var n,r,i,s,o;for(n in e){r=v.camelCase(n),i=t[r],s=e[n],v.isArray(s)&&(i=s[1],s=e[n]=s[0]),n!==r&&(e[r]=s,delete e[n]),o=v.cssHooks[r];if(o&&"expand"in o){s=o.expand(s),delete e[r];for(n in s)n in e||(e[n]=s[n],t[n]=i)}else t[r]=i}}function Gn(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},m=[],g=e.nodeType&&Gt(e);n.queue||(l=v._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,v.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],v.css(e,"display")==="inline"&&v.css(e,"float")==="none"&&(!v.support.inlineBlockNeedsLayout||nn(e.nodeName)==="inline"?p.display="inline-block":p.zoom=1)),n.overflow&&(p.overflow="hidden",v.support.shrinkWrapBlocks||h.done(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t){s=t[r];if(Un.exec(s)){delete t[r],a=a||s==="toggle";if(s===(g?"hide":"show"))continue;m.push(r)}}o=m.length;if(o){u=v._data(e,"fxshow")||v._data(e,"fxshow",{}),"hidden"in u&&(g=u.hidden),a&&(u.hidden=!g),g?v(e).show():h.done(function(){v(e).hide()}),h.done(function(){var t;v.removeData(e,"fxshow",!0);for(t in d)v.style(e,t,d[t])});for(r=0;r<o;r++)i=m[r],f=h.createTween(i,g?u[i]:0),d[i]=u[i]||v.style(e,i),i in u||(u[i]=f.start,g&&(f.end=f.start,f.start=i==="width"||i==="height"?1:0))}}function Yn(e,t,n,r,i){return new Yn.prototype.init(e,t,n,r,i)}function Zn(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=$t[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function tr(e){return v.isWindow(e)?e:e.nodeType===9?e.defaultView||e.parentWindow:!1}var n,r,i=e.document,s=e.location,o=e.navigator,u=e.jQuery,a=e.$,f=Array.prototype.push,l=Array.prototype.slice,c=Array.prototype.indexOf,h=Object.prototype.toString,p=Object.prototype.hasOwnProperty,d=String.prototype.trim,v=function(e,t){return new v.fn.init(e,t,n)},m=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,g=/\S/,y=/\s+/,b=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,w=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,E=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,S=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,T=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,N=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,C=/^-ms-/,k=/-([\da-z])/gi,L=function(e,t){return(t+"").toUpperCase()},A=function(){i.addEventListener?(i.removeEventListener("DOMContentLoaded",A,!1),v.ready()):i.readyState==="complete"&&(i.detachEvent("onreadystatechange",A),v.ready())},O={};v.fn=v.prototype={constructor:v,init:function(e,n,r){var s,o,u,a;if(!e)return this;if(e.nodeType)return this.context=this[0]=e,this.length=1,this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?s=[null,e,null]:s=w.exec(e);if(s&&(s[1]||!n)){if(s[1])return n=n instanceof v?n[0]:n,a=n&&n.nodeType?n.ownerDocument||n:i,e=v.parseHTML(s[1],a,!0),E.test(s[1])&&v.isPlainObject(n)&&this.attr.call(e,n,!0),v.merge(this,e);o=i.getElementById(s[2]);if(o&&o.parentNode){if(o.id!==s[2])return r.find(e);this.length=1,this[0]=o}return this.context=i,this.selector=e,this}return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e)}return v.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),v.makeArray(e,this))},selector:"",jquery:"1.8.3",length:0,size:function(){return this.length},toArray:function(){return l.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e,t,n){var r=v.merge(this.constructor(),e);return r.prevObject=this,r.context=this.context,t==="find"?r.selector=this.selector+(this.selector?" ":"")+n:t&&(r.selector=this.selector+"."+t+"("+n+")"),r},each:function(e,t){return v.each(this,e,t)},ready:function(e){return v.ready.promise().done(e),this},eq:function(e){return e=+e,e===-1?this.slice(e):this.slice(e,e+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(l.apply(this,arguments),"slice",l.call(arguments).join(","))},map:function(e){return this.pushStack(v.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:[].sort,splice:[].splice},v.fn.init.prototype=v.fn,v.extend=v.fn.extend=function(){var e,n,r,i,s,o,u=arguments[0]||{},a=1,f=arguments.length,l=!1;typeof u=="boolean"&&(l=u,u=arguments[1]||{},a=2),typeof u!="object"&&!v.isFunction(u)&&(u={}),f===a&&(u=this,--a);for(;a<f;a++)if((e=arguments[a])!=null)for(n in e){r=u[n],i=e[n];if(u===i)continue;l&&i&&(v.isPlainObject(i)||(s=v.isArray(i)))?(s?(s=!1,o=r&&v.isArray(r)?r:[]):o=r&&v.isPlainObject(r)?r:{},u[n]=v.extend(l,o,i)):i!==t&&(u[n]=i)}return u},v.extend({noConflict:function(t){return e.$===v&&(e.$=a),t&&e.jQuery===v&&(e.jQuery=u),v},isReady:!1,readyWait:1,holdReady:function(e){e?v.readyWait++:v.ready(!0)},ready:function(e){if(e===!0?--v.readyWait:v.isReady)return;if(!i.body)return setTimeout(v.ready,1);v.isReady=!0;if(e!==!0&&--v.readyWait>0)return;r.resolveWith(i,[v]),v.fn.trigger&&v(i).trigger("ready").off("ready")},isFunction:function(e){return v.type(e)==="function"},isArray:Array.isArray||function(e){return v.type(e)==="array"},isWindow:function(e){return e!=null&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):O[h.call(e)]||"object"},isPlainObject:function(e){if(!e||v.type(e)!=="object"||e.nodeType||v.isWindow(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||p.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){var r;return!e||typeof e!="string"?null:(typeof t=="boolean"&&(n=t,t=0),t=t||i,(r=E.exec(e))?[t.createElement(r[1])]:(r=v.buildFragment([e],t,n?null:[]),v.merge([],(r.cacheable?v.clone(r.fragment):r.fragment).childNodes)))},parseJSON:function(t){if(!t||typeof t!="string")return null;t=v.trim(t);if(e.JSON&&e.JSON.parse)return e.JSON.parse(t);if(S.test(t.replace(T,"@").replace(N,"]").replace(x,"")))return(new Function("return "+t))();v.error("Invalid JSON: "+t)},parseXML:function(n){var r,i;if(!n||typeof n!="string")return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(s){r=t}return(!r||!r.documentElement||r.getElementsByTagName("parsererror").length)&&v.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&g.test(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(C,"ms-").replace(k,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,n,r){var i,s=0,o=e.length,u=o===t||v.isFunction(e);if(r){if(u){for(i in e)if(n.apply(e[i],r)===!1)break}else for(;s<o;)if(n.apply(e[s++],r)===!1)break}else if(u){for(i in e)if(n.call(e[i],i,e[i])===!1)break}else for(;s<o;)if(n.call(e[s],s,e[s++])===!1)break;return e},trim:d&&!d.call("\ufeff\u00a0")?function(e){return e==null?"":d.call(e)}:function(e){return e==null?"":(e+"").replace(b,"")},makeArray:function(e,t){var n,r=t||[];return e!=null&&(n=v.type(e),e.length==null||n==="string"||n==="function"||n==="regexp"||v.isWindow(e)?f.call(r,e):v.merge(r,e)),r},inArray:function(e,t,n){var r;if(t){if(c)return c.call(t,e,n);r=t.length,n=n?n<0?Math.max(0,r+n):n:0;for(;n<r;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,s=0;if(typeof r=="number")for(;s<r;s++)e[i++]=n[s];else while(n[s]!==t)e[i++]=n[s++];return e.length=i,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,n,r){var i,s,o=[],u=0,a=e.length,f=e instanceof v||a!==t&&typeof a=="number"&&(a>0&&e[0]&&e[a-1]||a===0||v.isArray(e));if(f)for(;u<a;u++)i=n(e[u],u,r),i!=null&&(o[o.length]=i);else for(s in e)i=n(e[s],s,r),i!=null&&(o[o.length]=i);return o.concat.apply([],o)},guid:1,proxy:function(e,n){var r,i,s;return typeof n=="string"&&(r=e[n],n=e,e=r),v.isFunction(e)?(i=l.call(arguments,2),s=function(){return e.apply(n,i.concat(l.call(arguments)))},s.guid=e.guid=e.guid||v.guid++,s):t},access:function(e,n,r,i,s,o,u){var a,f=r==null,l=0,c=e.length;if(r&&typeof r=="object"){for(l in r)v.access(e,n,l,r[l],1,o,i);s=1}else if(i!==t){a=u===t&&v.isFunction(i),f&&(a?(a=n,n=function(e,t,n){return a.call(v(e),n)}):(n.call(e,i),n=null));if(n)for(;l<c;l++)n(e[l],r,a?i.call(e[l],l,n(e[l],r)):i,u);s=1}return s?e:f?n.call(e):c?n(e[0],r):o},now:function(){return(new Date).getTime()}}),v.ready.promise=function(t){if(!r){r=v.Deferred();if(i.readyState==="complete")setTimeout(v.ready,1);else if(i.addEventListener)i.addEventListener("DOMContentLoaded",A,!1),e.addEventListener("load",v.ready,!1);else{i.attachEvent("onreadystatechange",A),e.attachEvent("onload",v.ready);var n=!1;try{n=e.frameElement==null&&i.documentElement}catch(s){}n&&n.doScroll&&function o(){if(!v.isReady){try{n.doScroll("left")}catch(e){return setTimeout(o,50)}v.ready()}}()}}return r.promise(t)},v.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(e,t){O["[object "+t+"]"]=t.toLowerCase()}),n=v(i);var M={};v.Callbacks=function(e){e=typeof e=="string"?M[e]||_(e):v.extend({},e);var n,r,i,s,o,u,a=[],f=!e.once&&[],l=function(t){n=e.memory&&t,r=!0,u=s||0,s=0,o=a.length,i=!0;for(;a&&u<o;u++)if(a[u].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}i=!1,a&&(f?f.length&&l(f.shift()):n?a=[]:c.disable())},c={add:function(){if(a){var t=a.length;(function r(t){v.each(t,function(t,n){var i=v.type(n);i==="function"?(!e.unique||!c.has(n))&&a.push(n):n&&n.length&&i!=="string"&&r(n)})})(arguments),i?o=a.length:n&&(s=t,l(n))}return this},remove:function(){return a&&v.each(arguments,function(e,t){var n;while((n=v.inArray(t,a,n))>-1)a.splice(n,1),i&&(n<=o&&o--,n<=u&&u--)}),this},has:function(e){return v.inArray(e,a)>-1},empty:function(){return a=[],this},disable:function(){return a=f=n=t,this},disabled:function(){return!a},lock:function(){return f=t,n||c.disable(),this},locked:function(){return!f},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],a&&(!r||f)&&(i?f.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},v.extend({Deferred:function(e){var t=[["resolve","done",v.Callbacks("once memory"),"resolved"],["reject","fail",v.Callbacks("once memory"),"rejected"],["notify","progress",v.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return v.Deferred(function(n){v.each(t,function(t,r){var s=r[0],o=e[t];i[r[1]](v.isFunction(o)?function(){var e=o.apply(this,arguments);e&&v.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===i?n:this,[e])}:n[s])}),e=null}).promise()},promise:function(e){return e!=null?v.extend(e,r):r}},i={};return r.pipe=r.then,v.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=o.fire,i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=l.call(arguments),r=n.length,i=r!==1||e&&v.isFunction(e.promise)?r:0,s=i===1?e:v.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?l.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&v.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),v.support=function(){var t,n,r,s,o,u,a,f,l,c,h,p=i.createElement("div");p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=p.getElementsByTagName("*"),r=p.getElementsByTagName("a")[0];if(!n||!r||!n.length)return{};s=i.createElement("select"),o=s.appendChild(i.createElement("option")),u=p.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:r.getAttribute("href")==="/a",opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:u.value==="on",optSelected:o.selected,getSetAttribute:p.className!=="t",enctype:!!i.createElement("form").enctype,html5Clone:i.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:i.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},u.checked=!0,t.noCloneChecked=u.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!o.disabled;try{delete p.test}catch(d){t.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",h=function(){t.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick"),p.detachEvent("onclick",h)),u=i.createElement("input"),u.value="t",u.setAttribute("type","radio"),t.radioValue=u.value==="t",u.setAttribute("checked","checked"),u.setAttribute("name","t"),p.appendChild(u),a=i.createDocumentFragment(),a.appendChild(p.lastChild),t.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,t.appendChecked=u.checked,a.removeChild(u),a.appendChild(p);if(p.attachEvent)for(l in{submit:!0,change:!0,focusin:!0})f="on"+l,c=f in p,c||(p.setAttribute(f,"return;"),c=typeof p[f]=="function"),t[l+"Bubbles"]=c;return v(function(){var n,r,s,o,u="padding:0;margin:0;border:0;display:block;overflow:hidden;",a=i.getElementsByTagName("body")[0];if(!a)return;n=i.createElement("div"),n.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",a.insertBefore(n,a.firstChild),r=i.createElement("div"),n.appendChild(r),r.innerHTML="<table><tr><td></td><td>t</td></tr></table>",s=r.getElementsByTagName("td"),s[0].style.cssText="padding:0;margin:0;border:0;display:none",c=s[0].offsetHeight===0,s[0].style.display="",s[1].style.display="none",t.reliableHiddenOffsets=c&&s[0].offsetHeight===0,r.innerHTML="",r.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=r.offsetWidth===4,t.doesNotIncludeMarginInBodyOffset=a.offsetTop!==1,e.getComputedStyle&&(t.pixelPosition=(e.getComputedStyle(r,null)||{}).top!=="1%",t.boxSizingReliable=(e.getComputedStyle(r,null)||{width:"4px"}).width==="4px",o=i.createElement("div"),o.style.cssText=r.style.cssText=u,o.style.marginRight=o.style.width="0",r.style.width="1px",r.appendChild(o),t.reliableMarginRight=!parseFloat((e.getComputedStyle(o,null)||{}).marginRight)),typeof r.style.zoom!="undefined"&&(r.innerHTML="",r.style.cssText=u+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=r.offsetWidth===3,r.style.display="block",r.style.overflow="visible",r.innerHTML="<div></div>",r.firstChild.style.width="5px",t.shrinkWrapBlocks=r.offsetWidth!==3,n.style.zoom=1),a.removeChild(n),n=r=s=o=null}),a.removeChild(p),n=r=s=o=u=a=p=null,t}();var D=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;v.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(v.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?v.cache[e[v.expando]]:e[v.expando],!!e&&!B(e)},data:function(e,n,r,i){if(!v.acceptData(e))return;var s,o,u=v.expando,a=typeof n=="string",f=e.nodeType,l=f?v.cache:e,c=f?e[u]:e[u]&&u;if((!c||!l[c]||!i&&!l[c].data)&&a&&r===t)return;c||(f?e[u]=c=v.deletedIds.pop()||v.guid++:c=u),l[c]||(l[c]={},f||(l[c].toJSON=v.noop));if(typeof n=="object"||typeof n=="function")i?l[c]=v.extend(l[c],n):l[c].data=v.extend(l[c].data,n);return s=l[c],i||(s.data||(s.data={}),s=s.data),r!==t&&(s[v.camelCase(n)]=r),a?(o=s[n],o==null&&(o=s[v.camelCase(n)])):o=s,o},removeData:function(e,t,n){if(!v.acceptData(e))return;var r,i,s,o=e.nodeType,u=o?v.cache:e,a=o?e[v.expando]:v.expando;if(!u[a])return;if(t){r=n?u[a]:u[a].data;if(r){v.isArray(t)||(t in r?t=[t]:(t=v.camelCase(t),t in r?t=[t]:t=t.split(" ")));for(i=0,s=t.length;i<s;i++)delete r[t[i]];if(!(n?B:v.isEmptyObject)(r))return}}if(!n){delete u[a].data;if(!B(u[a]))return}o?v.cleanData([e],!0):v.support.deleteExpando||u!=u.window?delete u[a]:u[a]=null},_data:function(e,t,n){return v.data(e,t,n,!0)},acceptData:function(e){var t=e.nodeName&&v.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),v.fn.extend({data:function(e,n){var r,i,s,o,u,a=this[0],f=0,l=null;if(e===t){if(this.length){l=v.data(a);if(a.nodeType===1&&!v._data(a,"parsedAttrs")){s=a.attributes;for(u=s.length;f<u;f++)o=s[f].name,o.indexOf("data-")||(o=v.camelCase(o.substring(5)),H(a,o,l[o]));v._data(a,"parsedAttrs",!0)}}return l}return typeof e=="object"?this.each(function(){v.data(this,e)}):(r=e.split(".",2),r[1]=r[1]?"."+r[1]:"",i=r[1]+"!",v.access(this,function(n){if(n===t)return l=this.triggerHandler("getData"+i,[r[0]]),l===t&&a&&(l=v.data(a,e),l=H(a,e,l)),l===t&&r[1]?this.data(r[0]):l;r[1]=n,this.each(function(){var t=v(this);t.triggerHandler("setData"+i,r),v.data(this,e,n),t.triggerHandler("changeData"+i,r)})},null,n,arguments.length>1,null,!1))},removeData:function(e){return this.each(function(){v.removeData(this,e)})}}),v.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=v._data(e,t),n&&(!r||v.isArray(n)?r=v._data(e,t,v.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=v.queue(e,t),r=n.length,i=n.shift(),s=v._queueHooks(e,t),o=function(){v.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return v._data(e,n)||v._data(e,n,{empty:v.Callbacks("once memory").add(function(){v.removeData(e,t+"queue",!0),v.removeData(e,n,!0)})})}}),v.fn.extend({queue:function(e,n){var r=2;return typeof e!="string"&&(n=e,e="fx",r--),arguments.length<r?v.queue(this[0],e):n===t?this:this.each(function(){var t=v.queue(this,e,n);v._queueHooks(this,e),e==="fx"&&t[0]!=="inprogress"&&v.dequeue(this,e)})},dequeue:function(e){return this.each(function(){v.dequeue(this,e)})},delay:function(e,t){return e=v.fx?v.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,s=v.Deferred(),o=this,u=this.length,a=function(){--i||s.resolveWith(o,[o])};typeof e!="string"&&(n=e,e=t),e=e||"fx";while(u--)r=v._data(o[u],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(a));return a(),s.promise(n)}});var j,F,I,q=/[\t\r\n]/g,R=/\r/g,U=/^(?:button|input)$/i,z=/^(?:button|input|object|select|textarea)$/i,W=/^a(?:rea|)$/i,X=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,V=v.support.getSetAttribute;v.fn.extend({attr:function(e,t){return v.access(this,v.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){v.removeAttr(this,e)})},prop:function(e,t){return v.access(this,v.prop,e,t,arguments.length>1)},removeProp:function(e){return e=v.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,s,o,u;if(v.isFunction(e))return this.each(function(t){v(this).addClass(e.call(this,t,this.className))});if(e&&typeof e=="string"){t=e.split(y);for(n=0,r=this.length;n<r;n++){i=this[n];if(i.nodeType===1)if(!i.className&&t.length===1)i.className=e;else{s=" "+i.className+" ";for(o=0,u=t.length;o<u;o++)s.indexOf(" "+t[o]+" ")<0&&(s+=t[o]+" ");i.className=v.trim(s)}}}return this},removeClass:function(e){var n,r,i,s,o,u,a;if(v.isFunction(e))return this.each(function(t){v(this).removeClass(e.call(this,t,this.className))});if(e&&typeof e=="string"||e===t){n=(e||"").split(y);for(u=0,a=this.length;u<a;u++){i=this[u];if(i.nodeType===1&&i.className){r=(" "+i.className+" ").replace(q," ");for(s=0,o=n.length;s<o;s++)while(r.indexOf(" "+n[s]+" ")>=0)r=r.replace(" "+n[s]+" "," ");i.className=e?v.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return v.isFunction(e)?this.each(function(n){v(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var i,s=0,o=v(this),u=t,a=e.split(y);while(i=a[s++])u=r?u:!o.hasClass(i),o[u?"addClass":"removeClass"](i)}else if(n==="undefined"||n==="boolean")this.className&&v._data(this,"__className__",this.className),this.className=this.className||e===!1?"":v._data(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(q," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,s=this[0];if(!arguments.length){if(s)return n=v.valHooks[s.type]||v.valHooks[s.nodeName.toLowerCase()],n&&"get"in n&&(r=n.get(s,"value"))!==t?r:(r=s.value,typeof r=="string"?r.replace(R,""):r==null?"":r);return}return i=v.isFunction(e),this.each(function(r){var s,o=v(this);if(this.nodeType!==1)return;i?s=e.call(this,r,o.val()):s=e,s==null?s="":typeof s=="number"?s+="":v.isArray(s)&&(s=v.map(s,function(e){return e==null?"":e+""})),n=v.valHooks[this.type]||v.valHooks[this.nodeName.toLowerCase()];if(!n||!("set"in n)||n.set(this,s,"value")===t)this.value=s})}}),v.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(v.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!v.nodeName(n.parentNode,"optgroup"))){t=v(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n=v.makeArray(t);return v(e).find("option").each(function(){this.selected=v.inArray(v(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attrFn:{},attr:function(e,n,r,i){var s,o,u,a=e.nodeType;if(!e||a===3||a===8||a===2)return;if(i&&v.isFunction(v.fn[n]))return v(e)[n](r);if(typeof e.getAttribute=="undefined")return v.prop(e,n,r);u=a!==1||!v.isXMLDoc(e),u&&(n=n.toLowerCase(),o=v.attrHooks[n]||(X.test(n)?F:j));if(r!==t){if(r===null){v.removeAttr(e,n);return}return o&&"set"in o&&u&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r)}return o&&"get"in o&&u&&(s=o.get(e,n))!==null?s:(s=e.getAttribute(n),s===null?t:s)},removeAttr:function(e,t){var n,r,i,s,o=0;if(t&&e.nodeType===1){r=t.split(y);for(;o<r.length;o++)i=r[o],i&&(n=v.propFix[i]||i,s=X.test(i),s||v.attr(e,i,""),e.removeAttribute(V?i:n),s&&n in e&&(e[n]=!1))}},attrHooks:{type:{set:function(e,t){if(U.test(e.nodeName)&&e.parentNode)v.error("type property can't be changed");else if(!v.support.radioValue&&t==="radio"&&v.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}},value:{get:function(e,t){return j&&v.nodeName(e,"button")?j.get(e,t):t in e?e.value:null},set:function(e,t,n){if(j&&v.nodeName(e,"button"))return j.set(e,t,n);e.value=t}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,s,o,u=e.nodeType;if(!e||u===3||u===8||u===2)return;return o=u!==1||!v.isXMLDoc(e),o&&(n=v.propFix[n]||n,s=v.propHooks[n]),r!==t?s&&"set"in s&&(i=s.set(e,r,n))!==t?i:e[n]=r:s&&"get"in s&&(i=s.get(e,n))!==null?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):z.test(e.nodeName)||W.test(e.nodeName)&&e.href?0:t}}}}),F={get:function(e,n){var r,i=v.prop(e,n);return i===!0||typeof i!="boolean"&&(r=e.getAttributeNode(n))&&r.nodeValue!==!1?n.toLowerCase():t},set:function(e,t,n){var r;return t===!1?v.removeAttr(e,n):(r=v.propFix[n]||n,r in e&&(e[r]=!0),e.setAttribute(n,n.toLowerCase())),n}},V||(I={name:!0,id:!0,coords:!0},j=v.valHooks.button={get:function(e,n){var r;return r=e.getAttributeNode(n),r&&(I[n]?r.value!=="":r.specified)?r.value:t},set:function(e,t,n){var r=e.getAttributeNode(n);return r||(r=i.createAttribute(n),e.setAttributeNode(r)),r.value=t+""}},v.each(["width","height"],function(e,t){v.attrHooks[t]=v.extend(v.attrHooks[t],{set:function(e,n){if(n==="")return e.setAttribute(t,"auto"),n}})}),v.attrHooks.contenteditable={get:j.get,set:function(e,t,n){t===""&&(t="false"),j.set(e,t,n)}}),v.support.hrefNormalized||v.each(["href","src","width","height"],function(e,n){v.attrHooks[n]=v.extend(v.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return r===null?t:r}})}),v.support.style||(v.attrHooks.style={get:function(e){return e.style.cssText.toLowerCase()||t},set:function(e,t){return e.style.cssText=t+""}}),v.support.optSelected||(v.propHooks.selected=v.extend(v.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),v.support.enctype||(v.propFix.enctype="encoding"),v.support.checkOn||v.each(["radio","checkbox"],function(){v.valHooks[this]={get:function(e){return e.getAttribute("value")===null?"on":e.value}}}),v.each(["radio","checkbox"],function(){v.valHooks[this]=v.extend(v.valHooks[this],{set:function(e,t){if(v.isArray(t))return e.checked=v.inArray(v(e).val(),t)>=0}})});var $=/^(?:textarea|input|select)$/i,J=/^([^\.]*|)(?:\.(.+)|)$/,K=/(?:^|\s)hover(\.\S+|)\b/,Q=/^key/,G=/^(?:mouse|contextmenu)|click/,Y=/^(?:focusinfocus|focusoutblur)$/,Z=function(e){return v.event.special.hover?e:e.replace(K,"mouseenter$1 mouseleave$1")};v.event={add:function(e,n,r,i,s){var o,u,a,f,l,c,h,p,d,m,g;if(e.nodeType===3||e.nodeType===8||!n||!r||!(o=v._data(e)))return;r.handler&&(d=r,r=d.handler,s=d.selector),r.guid||(r.guid=v.guid++),a=o.events,a||(o.events=a={}),u=o.handle,u||(o.handle=u=function(e){return typeof v=="undefined"||!!e&&v.event.triggered===e.type?t:v.event.dispatch.apply(u.elem,arguments)},u.elem=e),n=v.trim(Z(n)).split(" ");for(f=0;f<n.length;f++){l=J.exec(n[f])||[],c=l[1],h=(l[2]||"").split(".").sort(),g=v.event.special[c]||{},c=(s?g.delegateType:g.bindType)||c,g=v.event.special[c]||{},p=v.extend({type:c,origType:l[1],data:i,handler:r,guid:r.guid,selector:s,needsContext:s&&v.expr.match.needsContext.test(s),namespace:h.join(".")},d),m=a[c];if(!m){m=a[c]=[],m.delegateCount=0;if(!g.setup||g.setup.call(e,i,h,u)===!1)e.addEventListener?e.addEventListener(c,u,!1):e.attachEvent&&e.attachEvent("on"+c,u)}g.add&&(g.add.call(e,p),p.handler.guid||(p.handler.guid=r.guid)),s?m.splice(m.delegateCount++,0,p):m.push(p),v.event.global[c]=!0}e=null},global:{},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,m,g=v.hasData(e)&&v._data(e);if(!g||!(h=g.events))return;t=v.trim(Z(t||"")).split(" ");for(s=0;s<t.length;s++){o=J.exec(t[s])||[],u=a=o[1],f=o[2];if(!u){for(u in h)v.event.remove(e,u+t[s],n,r,!0);continue}p=v.event.special[u]||{},u=(r?p.delegateType:p.bindType)||u,d=h[u]||[],l=d.length,f=f?new RegExp("(^|\\.)"+f.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(c=0;c<d.length;c++)m=d[c],(i||a===m.origType)&&(!n||n.guid===m.guid)&&(!f||f.test(m.namespace))&&(!r||r===m.selector||r==="**"&&m.selector)&&(d.splice(c--,1),m.selector&&d.delegateCount--,p.remove&&p.remove.call(e,m));d.length===0&&l!==d.length&&((!p.teardown||p.teardown.call(e,f,g.handle)===!1)&&v.removeEvent(e,u,g.handle),delete h[u])}v.isEmptyObject(h)&&(delete g.handle,v.removeData(e,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(n,r,s,o){if(!s||s.nodeType!==3&&s.nodeType!==8){var u,a,f,l,c,h,p,d,m,g,y=n.type||n,b=[];if(Y.test(y+v.event.triggered))return;y.indexOf("!")>=0&&(y=y.slice(0,-1),a=!0),y.indexOf(".")>=0&&(b=y.split("."),y=b.shift(),b.sort());if((!s||v.event.customEvent[y])&&!v.event.global[y])return;n=typeof n=="object"?n[v.expando]?n:new v.Event(y,n):new v.Event(y),n.type=y,n.isTrigger=!0,n.exclusive=a,n.namespace=b.join("."),n.namespace_re=n.namespace?new RegExp("(^|\\.)"+b.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,h=y.indexOf(":")<0?"on"+y:"";if(!s){u=v.cache;for(f in u)u[f].events&&u[f].events[y]&&v.event.trigger(n,r,u[f].handle.elem,!0);return}n.result=t,n.target||(n.target=s),r=r!=null?v.makeArray(r):[],r.unshift(n),p=v.event.special[y]||{};if(p.trigger&&p.trigger.apply(s,r)===!1)return;m=[[s,p.bindType||y]];if(!o&&!p.noBubble&&!v.isWindow(s)){g=p.delegateType||y,l=Y.test(g+y)?s:s.parentNode;for(c=s;l;l=l.parentNode)m.push([l,g]),c=l;c===(s.ownerDocument||i)&&m.push([c.defaultView||c.parentWindow||e,g])}for(f=0;f<m.length&&!n.isPropagationStopped();f++)l=m[f][0],n.type=m[f][1],d=(v._data(l,"events")||{})[n.type]&&v._data(l,"handle"),d&&d.apply(l,r),d=h&&l[h],d&&v.acceptData(l)&&d.apply&&d.apply(l,r)===!1&&n.preventDefault();return n.type=y,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(s.ownerDocument,r)===!1)&&(y!=="click"||!v.nodeName(s,"a"))&&v.acceptData(s)&&h&&s[y]&&(y!=="focus"&&y!=="blur"||n.target.offsetWidth!==0)&&!v.isWindow(s)&&(c=s[h],c&&(s[h]=null),v.event.triggered=y,s[y](),v.event.triggered=t,c&&(s[h]=c)),n.result}return},dispatch:function(n){n=v.event.fix(n||e.event);var r,i,s,o,u,a,f,c,h,p,d=(v._data(this,"events")||{})[n.type]||[],m=d.delegateCount,g=l.call(arguments),y=!n.exclusive&&!n.namespace,b=v.event.special[n.type]||{},w=[];g[0]=n,n.delegateTarget=this;if(b.preDispatch&&b.preDispatch.call(this,n)===!1)return;if(m&&(!n.button||n.type!=="click"))for(s=n.target;s!=this;s=s.parentNode||this)if(s.disabled!==!0||n.type!=="click"){u={},f=[];for(r=0;r<m;r++)c=d[r],h=c.selector,u[h]===t&&(u[h]=c.needsContext?v(h,this).index(s)>=0:v.find(h,this,null,[s]).length),u[h]&&f.push(c);f.length&&w.push({elem:s,matches:f})}d.length>m&&w.push({elem:this,matches:d.slice(m)});for(r=0;r<w.length&&!n.isPropagationStopped();r++){a=w[r],n.currentTarget=a.elem;for(i=0;i<a.matches.length&&!n.isImmediatePropagationStopped();i++){c=a.matches[i];if(y||!n.namespace&&!c.namespace||n.namespace_re&&n.namespace_re.test(c.namespace))n.data=c.data,n.handleObj=c,o=((v.event.special[c.origType]||{}).handle||c.handler).apply(a.elem,g),o!==t&&(n.result=o,o===!1&&(n.preventDefault(),n.stopPropagation()))}}return b.postDispatch&&b.postDispatch.call(this,n),n.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,s,o,u=n.button,a=n.fromElement;return e.pageX==null&&n.clientX!=null&&(r=e.target.ownerDocument||i,s=r.documentElement,o=r.body,e.pageX=n.clientX+(s&&s.scrollLeft||o&&o.scrollLeft||0)-(s&&s.clientLeft||o&&o.clientLeft||0),e.pageY=n.clientY+(s&&s.scrollTop||o&&o.scrollTop||0)-(s&&s.clientTop||o&&o.clientTop||0)),!e.relatedTarget&&a&&(e.relatedTarget=a===e.target?n.toElement:a),!e.which&&u!==t&&(e.which=u&1?1:u&2?3:u&4?2:0),e}},fix:function(e){if(e[v.expando])return e;var t,n,r=e,s=v.event.fixHooks[e.type]||{},o=s.props?this.props.concat(s.props):this.props;e=v.Event(r);for(t=o.length;t;)n=o[--t],e[n]=r[n];return e.target||(e.target=r.srcElement||i),e.target.nodeType===3&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,r):e},special:{load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(e,t,n){v.isWindow(this)&&(this.onbeforeunload=n)},teardown:function(e,t){this.onbeforeunload===t&&(this.onbeforeunload=null)}}},simulate:function(e,t,n,r){var i=v.extend(new v.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?v.event.trigger(i,null,t):v.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},v.event.handle=v.event.dispatch,v.removeEvent=i.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]=="undefined"&&(e[r]=null),e.detachEvent(r,n))},v.Event=function(e,t){if(!(this instanceof v.Event))return new v.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?tt:et):this.type=e,t&&v.extend(this,t),this.timeStamp=e&&e.timeStamp||v.now(),this[v.expando]=!0},v.Event.prototype={preventDefault:function(){this.isDefaultPrevented=tt;var e=this.originalEvent;if(!e)return;e.preventDefault?e.preventDefault():e.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=tt;var e=this.originalEvent;if(!e)return;e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=tt,this.stopPropagation()},isDefaultPrevented:et,isPropagationStopped:et,isImmediatePropagationStopped:et},v.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){v.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj,o=s.selector;if(!i||i!==r&&!v.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),v.support.submitBubbles||(v.event.special.submit={setup:function(){if(v.nodeName(this,"form"))return!1;v.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=v.nodeName(n,"input")||v.nodeName(n,"button")?n.form:t;r&&!v._data(r,"_submit_attached")&&(v.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),v._data(r,"_submit_attached",!0))})},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&v.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){if(v.nodeName(this,"form"))return!1;v.event.remove(this,"._submit")}}),v.support.changeBubbles||(v.event.special.change={setup:function(){if($.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")v.event.add(this,"propertychange._change",function(e){e.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),v.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),v.event.simulate("change",this,e,!0)});return!1}v.event.add(this,"beforeactivate._change",function(e){var t=e.target;$.test(t.nodeName)&&!v._data(t,"_change_attached")&&(v.event.add(t,"change._change",function(e){this.parentNode&&!e.isSimulated&&!e.isTrigger&&v.event.simulate("change",this.parentNode,e,!0)}),v._data(t,"_change_attached",!0))})},handle:function(e){var t=e.target;if(this!==t||e.isSimulated||e.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return e.handleObj.handler.apply(this,arguments)},teardown:function(){return v.event.remove(this,"._change"),!$.test(this.nodeName)}}),v.support.focusinBubbles||v.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){v.event.simulate(t,e.target,v.event.fix(e),!0)};v.event.special[t]={setup:function(){n++===0&&i.addEventListener(e,r,!0)},teardown:function(){--n===0&&i.removeEventListener(e,r,!0)}}}),v.fn.extend({on:function(e,n,r,i,s){var o,u;if(typeof e=="object"){typeof n!="string"&&(r=r||n,n=t);for(u in e)this.on(u,n,r,e[u],s);return this}r==null&&i==null?(i=n,r=n=t):i==null&&(typeof n=="string"?(i=r,r=t):(i=r,r=n,n=t));if(i===!1)i=et;else if(!i)return this;return s===1&&(o=i,i=function(e){return v().off(e),o.apply(this,arguments)},i.guid=o.guid||(o.guid=v.guid++)),this.each(function(){v.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,s;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,v(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if(typeof e=="object"){for(s in e)this.off(s,n,e[s]);return this}if(n===!1||typeof n=="function")r=n,n=t;return r===!1&&(r=et),this.each(function(){v.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},live:function(e,t,n){return v(this.context).on(e,this.selector,t,n),this},die:function(e,t){return v(this.context).off(e,this.selector||"**",t),this},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){v.event.trigger(e,t,this)})},triggerHandler:function(e,t){if(this[0])return v.event.trigger(e,t,this[0],!0)},toggle:function(e){var t=arguments,n=e.guid||v.guid++,r=0,i=function(n){var i=(v._data(this,"lastToggle"+e.guid)||0)%r;return v._data(this,"lastToggle"+e.guid,i+1),n.preventDefault(),t[i].apply(this,arguments)||!1};i.guid=n;while(r<t.length)t[r++].guid=n;return this.click(i)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){v.fn[t]=function(e,n){return n==null&&(n=e,e=null),arguments.length>0?this.on(t,null,e,n):this.trigger(t)},Q.test(t)&&(v.event.fixHooks[t]=v.event.keyHooks),G.test(t)&&(v.event.fixHooks[t]=v.event.mouseHooks)}),function(e,t){function nt(e,t,n,r){n=n||[],t=t||g;var i,s,a,f,l=t.nodeType;if(!e||typeof e!="string")return n;if(l!==1&&l!==9)return[];a=o(t);if(!a&&!r)if(i=R.exec(e))if(f=i[1]){if(l===9){s=t.getElementById(f);if(!s||!s.parentNode)return n;if(s.id===f)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(f))&&u(t,s)&&s.id===f)return n.push(s),n}else{if(i[2])return S.apply(n,x.call(t.getElementsByTagName(e),0)),n;if((f=i[3])&&Z&&t.getElementsByClassName)return S.apply(n,x.call(t.getElementsByClassName(f),0)),n}return vt(e.replace(j,"$1"),t,n,r,a)}function rt(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function it(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function st(e){return N(function(t){return t=+t,N(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function ot(e,t,n){if(e===t)return n;var r=e.nextSibling;while(r){if(r===t)return-1;r=r.nextSibling}return 1}function ut(e,t){var n,r,s,o,u,a,f,l=L[d][e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=F.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=I.exec(u))s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=r[0].replace(j," ");for(o in i.filter)(r=J[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=o,n.matches=r);if(!n)break}return t?u.length:u?nt.error(e):L(e,a).slice(0)}function at(e,t,r){var i=t.dir,s=r&&t.dir==="parentNode",o=w++;return t.first?function(t,n,r){while(t=t[i])if(s||t.nodeType===1)return e(t,n,r)}:function(t,r,u){if(!u){var a,f=b+" "+o+" ",l=f+n;while(t=t[i])if(s||t.nodeType===1){if((a=t[d])===l)return t.sizset;if(typeof a=="string"&&a.indexOf(f)===0){if(t.sizset)return t}else{t[d]=l;if(e(t,r,u))return t.sizset=!0,t;t.sizset=!1}}}else while(t=t[i])if(s||t.nodeType===1)if(e(t,r,u))return t}}function ft(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function lt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function ct(e,t,n,r,i,s){return r&&!r[d]&&(r=ct(r)),i&&!i[d]&&(i=ct(i,s)),N(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||dt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?lt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=lt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?T.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=lt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):S.apply(o,g)})}function ht(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],a=o?1:0,f=at(function(e){return e===t},u,!0),l=at(function(e){return T.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==c)||((t=n).nodeType?f(e,n,r):l(e,n,r))}];for(;a<s;a++)if(n=i.relative[e[a].type])h=[at(ft(h),n)];else{n=i.filter[e[a].type].apply(null,e[a].matches);if(n[d]){r=++a;for(;r<s;r++)if(i.relative[e[r].type])break;return ct(a>1&&ft(h),a>1&&e.slice(0,a-1).join("").replace(j,"$1"),n,a<r&&ht(e.slice(a,r)),r<s&&ht(e=e.slice(r)),r<s&&e.join(""))}h.push(n)}return ft(h)}function pt(e,t){var r=t.length>0,s=e.length>0,o=function(u,a,f,l,h){var p,d,v,m=[],y=0,w="0",x=u&&[],T=h!=null,N=c,C=u||s&&i.find.TAG("*",h&&a.parentNode||a),k=b+=N==null?1:Math.E;T&&(c=a!==g&&a,n=o.el);for(;(p=C[w])!=null;w++){if(s&&p){for(d=0;v=e[d];d++)if(v(p,a,f)){l.push(p);break}T&&(b=k,n=++o.el)}r&&((p=!v&&p)&&y--,u&&x.push(p))}y+=w;if(r&&w!==y){for(d=0;v=t[d];d++)v(x,m,a,f);if(u){if(y>0)while(w--)!x[w]&&!m[w]&&(m[w]=E.call(l));m=lt(m)}S.apply(l,m),T&&!u&&m.length>0&&y+t.length>1&&nt.uniqueSort(l)}return T&&(b=k,c=N),x};return o.el=0,r?N(o):o}function dt(e,t,n){var r=0,i=t.length;for(;r<i;r++)nt(e,t[r],n);return n}function vt(e,t,n,r,s){var o,u,f,l,c,h=ut(e),p=h.length;if(!r&&h.length===1){u=h[0]=h[0].slice(0);if(u.length>2&&(f=u[0]).type==="ID"&&t.nodeType===9&&!s&&i.relative[u[1].type]){t=i.find.ID(f.matches[0].replace($,""),t,s)[0];if(!t)return n;e=e.slice(u.shift().length)}for(o=J.POS.test(e)?-1:u.length-1;o>=0;o--){f=u[o];if(i.relative[l=f.type])break;if(c=i.find[l])if(r=c(f.matches[0].replace($,""),z.test(u[0].type)&&t.parentNode||t,s)){u.splice(o,1),e=r.length&&u.join("");if(!e)return S.apply(n,x.call(r,0)),n;break}}}return a(e,h)(r,t,s,n,z.test(e)),n}function mt(){}var n,r,i,s,o,u,a,f,l,c,h=!0,p="undefined",d=("sizcache"+Math.random()).replace(".",""),m=String,g=e.document,y=g.documentElement,b=0,w=0,E=[].pop,S=[].push,x=[].slice,T=[].indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},N=function(e,t){return e[d]=t==null||t,e},C=function(){var e={},t=[];return N(function(n,r){return t.push(n)>i.cacheLength&&delete e[t.shift()],e[n+" "]=r},e)},k=C(),L=C(),A=C(),O="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",_=M.replace("w","w#"),D="([*^$|!~]?=)",P="\\["+O+"*("+M+")"+O+"*(?:"+D+O+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+_+")|)|)"+O+"*\\]",H=":("+M+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+P+")|[^:]|\\\\.)*|.*))\\)|)",B=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+O+"*((?:-\\d)?\\d*)"+O+"*\\)|)(?=[^-]|$)",j=new RegExp("^"+O+"+|((?:^|[^\\\\])(?:\\\\.)*)"+O+"+$","g"),F=new RegExp("^"+O+"*,"+O+"*"),I=new RegExp("^"+O+"*([\\x20\\t\\r\\n\\f>+~])"+O+"*"),q=new RegExp(H),R=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,U=/^:not/,z=/[\x20\t\r\n\f]*[+~]/,W=/:not\($/,X=/h\d/i,V=/input|select|textarea|button/i,$=/\\(?!\\)/g,J={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),NAME:new RegExp("^\\[name=['\"]?("+M+")['\"]?\\]"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+H),POS:new RegExp(B,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+O+"*(even|odd|(([+-]|)(\\d*)n|)"+O+"*(?:([+-]|)"+O+"*(\\d+)|))"+O+"*\\)|)","i"),needsContext:new RegExp("^"+O+"*[>+~]|"+B,"i")},K=function(e){var t=g.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}},Q=K(function(e){return e.appendChild(g.createComment("")),!e.getElementsByTagName("*").length}),G=K(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==p&&e.firstChild.getAttribute("href")==="#"}),Y=K(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),Z=K(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!e.getElementsByClassName||!e.getElementsByClassName("e").length?!1:(e.lastChild.className="e",e.getElementsByClassName("e").length===2)}),et=K(function(e){e.id=d+0,e.innerHTML="<a name='"+d+"'></a><div name='"+d+"'></div>",y.insertBefore(e,y.firstChild);var t=g.getElementsByName&&g.getElementsByName(d).length===2+g.getElementsByName(d+0).length;return r=!g.getElementById(d),y.removeChild(e),t});try{x.call(y.childNodes,0)[0].nodeType}catch(tt){x=function(e){var t,n=[];for(;t=this[e];e++)n.push(t);return n}}nt.matches=function(e,t){return nt(e,null,null,t)},nt.matchesSelector=function(e,t){return nt(t,null,null,[e]).length>0},s=nt.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue}else for(;t=e[r];r++)n+=s(t);return n},o=nt.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},u=nt.contains=y.contains?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!(r&&r.nodeType===1&&n.contains&&n.contains(r))}:y.compareDocumentPosition?function(e,t){return t&&!!(e.compareDocumentPosition(t)&16)}:function(e,t){while(t=t.parentNode)if(t===e)return!0;return!1},nt.attr=function(e,t){var n,r=o(e);return r||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):r||Y?e.getAttribute(t):(n=e.getAttributeNode(t),n?typeof e[t]=="boolean"?e[t]?t:null:n.specified?n.value:null:null)},i=nt.selectors={cacheLength:50,createPseudo:N,match:J,attrHandle:G?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},find:{ID:r?function(e,t,n){if(typeof t.getElementById!==p&&!n){var r=t.getElementById(e);return r&&r.parentNode?[r]:[]}}:function(e,n,r){if(typeof n.getElementById!==p&&!r){var i=n.getElementById(e);return i?i.id===e||typeof i.getAttributeNode!==p&&i.getAttributeNode("id").value===e?[i]:t:[]}},TAG:Q?function(e,t){if(typeof t.getElementsByTagName!==p)return t.getElementsByTagName(e)}:function(e,t){var n=t.getElementsByTagName(e);if(e==="*"){var r,i=[],s=0;for(;r=n[s];s++)r.nodeType===1&&i.push(r);return i}return n},NAME:et&&function(e,t){if(typeof t.getElementsByName!==p)return t.getElementsByName(name)},CLASS:Z&&function(e,t,n){if(typeof t.getElementsByClassName!==p&&!n)return t.getElementsByClassName(e)}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace($,""),e[3]=(e[4]||e[5]||"").replace($,""),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1]==="nth"?(e[2]||nt.error(e[0]),e[3]=+(e[3]?e[4]+(e[5]||1):2*(e[2]==="even"||e[2]==="odd")),e[4]=+(e[6]+e[7]||e[2]==="odd")):e[2]&&nt.error(e[0]),e},PSEUDO:function(e){var t,n;if(J.CHILD.test(e[0]))return null;if(e[3])e[2]=e[3];else if(t=e[4])q.test(t)&&(n=ut(t,!0))&&(n=t.indexOf(")",t.length-n)-t.length)&&(t=t.slice(0,n),e[0]=e[0].slice(0,n)),e[2]=t;return e.slice(0,3)}},filter:{ID:r?function(e){return e=e.replace($,""),function(t){return t.getAttribute("id")===e}}:function(e){return e=e.replace($,""),function(t){var n=typeof t.getAttributeNode!==p&&t.getAttributeNode("id");return n&&n.value===e}},TAG:function(e){return e==="*"?function(){return!0}:(e=e.replace($,"").toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[d][e+" "];return t||(t=new RegExp("(^|"+O+")"+e+"("+O+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==p&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r,i){var s=nt.attr(r,e);return s==null?t==="!=":t?(s+="",t==="="?s===n:t==="!="?s!==n:t==="^="?n&&s.indexOf(n)===0:t==="*="?n&&s.indexOf(n)>-1:t==="$="?n&&s.substr(s.length-n.length)===n:t==="~="?(" "+s+" ").indexOf(n)>-1:t==="|="?s===n||s.substr(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r){return e==="nth"?function(e){var t,i,s=e.parentNode;if(n===1&&r===0)return!0;if(s){i=0;for(t=s.firstChild;t;t=t.nextSibling)if(t.nodeType===1){i++;if(e===t)break}}return i-=r,i===n||i%n===0&&i/n>=0}:function(t){var n=t;switch(e){case"only":case"first":while(n=n.previousSibling)if(n.nodeType===1)return!1;if(e==="first")return!0;n=t;case"last":while(n=n.nextSibling)if(n.nodeType===1)return!1;return!0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||nt.error("unsupported pseudo: "+e);return r[d]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?N(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=T.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:N(function(e){var t=[],n=[],r=a(e.replace(j,"$1"));return r[d]?N(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:N(function(e){return function(t){return nt(e,t).length>0}}),contains:N(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},parent:function(e){return!i.pseudos.empty(e)},empty:function(e){var t;e=e.firstChild;while(e){if(e.nodeName>"@"||(t=e.nodeType)===3||t===4)return!1;e=e.nextSibling}return!0},header:function(e){return X.test(e.nodeName)},text:function(e){var t,n;return e.nodeName.toLowerCase()==="input"&&(t=e.type)==="text"&&((n=e.getAttribute("type"))==null||n.toLowerCase()===t)},radio:rt("radio"),checkbox:rt("checkbox"),file:rt("file"),password:rt("password"),image:rt("image"),submit:it("submit"),reset:it("reset"),button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},input:function(e){return V.test(e.nodeName)},focus:function(e){var t=e.ownerDocument;return e===t.activeElement&&(!t.hasFocus||t.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},active:function(e){return e===e.ownerDocument.activeElement},first:st(function(){return[0]}),last:st(function(e,t){return[t-1]}),eq:st(function(e,t,n){return[n<0?n+t:n]}),even:st(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:st(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:st(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:st(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},f=y.compareDocumentPosition?function(e,t){return e===t?(l=!0,0):(!e.compareDocumentPosition||!t.compareDocumentPosition?e.compareDocumentPosition:e.compareDocumentPosition(t)&4)?-1:1}:function(e,t){if(e===t)return l=!0,0;if(e.sourceIndex&&t.sourceIndex)return e.sourceIndex-t.sourceIndex;var n,r,i=[],s=[],o=e.parentNode,u=t.parentNode,a=o;if(o===u)return ot(e,t);if(!o)return-1;if(!u)return 1;while(a)i.unshift(a),a=a.parentNode;a=u;while(a)s.unshift(a),a=a.parentNode;n=i.length,r=s.length;for(var f=0;f<n&&f<r;f++)if(i[f]!==s[f])return ot(i[f],s[f]);return f===n?ot(e,s[f],-1):ot(i[f],t,1)},[0,0].sort(f),h=!l,nt.uniqueSort=function(e){var t,n=[],r=1,i=0;l=h,e.sort(f);if(l){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e},nt.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},a=nt.compile=function(e,t){var n,r=[],i=[],s=A[d][e+" "];if(!s){t||(t=ut(e)),n=t.length;while(n--)s=ht(t[n]),s[d]?r.push(s):i.push(s);s=A(e,pt(i,r))}return s},g.querySelectorAll&&function(){var e,t=vt,n=/'|\\/g,r=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,i=[":focus"],s=[":active"],u=y.matchesSelector||y.mozMatchesSelector||y.webkitMatchesSelector||y.oMatchesSelector||y.msMatchesSelector;K(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||i.push("\\["+O+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||i.push(":checked")}),K(function(e){e.innerHTML="<p test=''></p>",e.querySelectorAll("[test^='']").length&&i.push("[*^$]="+O+"*(?:\"\"|'')"),e.innerHTML="<input type='hidden'/>",e.querySelectorAll(":enabled").length||i.push(":enabled",":disabled")}),i=new RegExp(i.join("|")),vt=function(e,r,s,o,u){if(!o&&!u&&!i.test(e)){var a,f,l=!0,c=d,h=r,p=r.nodeType===9&&e;if(r.nodeType===1&&r.nodeName.toLowerCase()!=="object"){a=ut(e),(l=r.getAttribute("id"))?c=l.replace(n,"\\$&"):r.setAttribute("id",c),c="[id='"+c+"'] ",f=a.length;while(f--)a[f]=c+a[f].join("");h=z.test(e)&&r.parentNode||r,p=a.join(",")}if(p)try{return S.apply(s,x.call(h.querySelectorAll(p),0)),s}catch(v){}finally{l||r.removeAttribute("id")}}return t(e,r,s,o,u)},u&&(K(function(t){e=u.call(t,"div");try{u.call(t,"[test!='']:sizzle"),s.push("!=",H)}catch(n){}}),s=new RegExp(s.join("|")),nt.matchesSelector=function(t,n){n=n.replace(r,"='$1']");if(!o(t)&&!s.test(n)&&!i.test(n))try{var a=u.call(t,n);if(a||e||t.document&&t.document.nodeType!==11)return a}catch(f){}return nt(n,null,null,[t]).length>0})}(),i.pseudos.nth=i.pseudos.eq,i.filters=mt.prototype=i.pseudos,i.setFilters=new mt,nt.attr=v.attr,v.find=nt,v.expr=nt.selectors,v.expr[":"]=v.expr.pseudos,v.unique=nt.uniqueSort,v.text=nt.getText,v.isXMLDoc=nt.isXML,v.contains=nt.contains}(e);var nt=/Until$/,rt=/^(?:parents|prev(?:Until|All))/,it=/^.[^:#\[\.,]*$/,st=v.expr.match.needsContext,ot={children:!0,contents:!0,next:!0,prev:!0};v.fn.extend({find:function(e){var t,n,r,i,s,o,u=this;if(typeof e!="string")return v(e).filter(function(){for(t=0,n=u.length;t<n;t++)if(v.contains(u[t],this))return!0});o=this.pushStack("","find",e);for(t=0,n=this.length;t<n;t++){r=o.length,v.find(e,this[t],o);if(t>0)for(i=r;i<o.length;i++)for(s=0;s<r;s++)if(o[s]===o[i]){o.splice(i--,1);break}}return o},has:function(e){var t,n=v(e,this),r=n.length;return this.filter(function(){for(t=0;t<r;t++)if(v.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1),"not",e)},filter:function(e){return this.pushStack(ft(this,e,!0),"filter",e)},is:function(e){return!!e&&(typeof e=="string"?st.test(e)?v(e,this.context).index(this[0])>=0:v.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=st.test(e)||typeof e!="string"?v(e,t||this.context):0;for(;r<i;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&n.nodeType!==11){if(o?o.index(n)>-1:v.find.matchesSelector(n,e)){s.push(n);break}n=n.parentNode}}return s=s.length>1?v.unique(s):s,this.pushStack(s,"closest",e)},index:function(e){return e?typeof e=="string"?v.inArray(this[0],v(e)):v.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?v(e,t):v.makeArray(e&&e.nodeType?[e]:e),r=v.merge(this.get(),n);return this.pushStack(ut(n[0])||ut(r[0])?r:v.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),v.fn.andSelf=v.fn.addBack,v.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return v.dir(e,"parentNode")},parentsUntil:function(e,t,n){return v.dir(e,"parentNode",n)},next:function(e){return at(e,"nextSibling")},prev:function(e){return at(e,"previousSibling")},nextAll:function(e){return v.dir(e,"nextSibling")},prevAll:function(e){return v.dir(e,"previousSibling")},nextUntil:function(e,t,n){return v.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return v.dir(e,"previousSibling",n)},siblings:function(e){return v.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return v.sibling(e.firstChild)},contents:function(e){return v.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:v.merge([],e.childNodes)}},function(e,t){v.fn[e]=function(n,r){var i=v.map(this,t,n);return nt.test(e)||(r=n),r&&typeof r=="string"&&(i=v.filter(r,i)),i=this.length>1&&!ot[e]?v.unique(i):i,this.length>1&&rt.test(e)&&(i=i.reverse()),this.pushStack(i,e,l.call(arguments).join(","))}}),v.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),t.length===1?v.find.matchesSelector(t[0],e)?[t[0]]:[]:v.find.matches(e,t)},dir:function(e,n,r){var i=[],s=e[n];while(s&&s.nodeType!==9&&(r===t||s.nodeType!==1||!v(s).is(r)))s.nodeType===1&&i.push(s),s=s[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var ct="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",ht=/ jQuery\d+="(?:null|\d+)"/g,pt=/^\s+/,dt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,vt=/<([\w:]+)/,mt=/<tbody/i,gt=/<|&#?\w+;/,yt=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,wt=new RegExp("<(?:"+ct+")[\\s/>]","i"),Et=/^(?:checkbox|radio)$/,St=/checked\s*(?:[^=]|=\s*.checked.)/i,xt=/\/(java|ecma)script/i,Tt=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,Nt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},Ct=lt(i),kt=Ct.appendChild(i.createElement("div"));Nt.optgroup=Nt.option,Nt.tbody=Nt.tfoot=Nt.colgroup=Nt.caption=Nt.thead,Nt.th=Nt.td,v.support.htmlSerialize||(Nt._default=[1,"X<div>","</div>"]),v.fn.extend({text:function(e){return v.access(this,function(e){return e===t?v.text(this):this.empty().append((this[0]&&this[0].ownerDocument||i).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(v.isFunction(e))return this.each(function(t){v(this).wrapAll(e.call(this,t))});if(this[0]){var t=v(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&e.firstChild.nodeType===1)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return v.isFunction(e)?this.each(function(t){v(this).wrapInner(e.call(this,t))}):this.each(function(){var t=v(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=v.isFunction(e);return this.each(function(n){v(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){v.nodeName(this,"body")||v(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(e,this.firstChild)})},before:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(e,this),"before",this.selector)}},after:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this.nextSibling)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(this,e),"after",this.selector)}},remove:function(e,t){var n,r=0;for(;(n=this[r])!=null;r++)if(!e||v.filter(e,[n]).length)!t&&n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),v.cleanData([n])),n.parentNode&&n.parentNode.removeChild(n);return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++){e.nodeType===1&&v.cleanData(e.getElementsByTagName("*"));while(e.firstChild)e.removeChild(e.firstChild)}return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return v.clone(this,e,t)})},html:function(e){return v.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return n.nodeType===1?n.innerHTML.replace(ht,""):t;if(typeof e=="string"&&!yt.test(e)&&(v.support.htmlSerialize||!wt.test(e))&&(v.support.leadingWhitespace||!pt.test(e))&&!Nt[(vt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(dt,"<$1></$2>");try{for(;r<i;r++)n=this[r]||{},n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),n.innerHTML=e);n=0}catch(s){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){return ut(this[0])?this.length?this.pushStack(v(v.isFunction(e)?e():e),"replaceWith",e):this:v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.replaceWith(e.call(this,t,r))}):(typeof e!="string"&&(e=v(e).detach()),this.each(function(){var t=this.nextSibling,n=this.parentNode;v(this).remove(),t?v(t).before(e):v(n).append(e)}))},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=[].concat.apply([],e);var i,s,o,u,a=0,f=e[0],l=[],c=this.length;if(!v.support.checkClone&&c>1&&typeof f=="string"&&St.test(f))return this.each(function(){v(this).domManip(e,n,r)});if(v.isFunction(f))return this.each(function(i){var s=v(this);e[0]=f.call(this,i,n?s.html():t),s.domManip(e,n,r)});if(this[0]){i=v.buildFragment(e,this,l),o=i.fragment,s=o.firstChild,o.childNodes.length===1&&(o=s);if(s){n=n&&v.nodeName(s,"tr");for(u=i.cacheable||c-1;a<c;a++)r.call(n&&v.nodeName(this[a],"table")?Lt(this[a],"tbody"):this[a],a===u?o:v.clone(o,!0,!0))}o=s=null,l.length&&v.each(l,function(e,t){t.src?v.ajax?v.ajax({url:t.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):v.error("no ajax"):v.globalEval((t.text||t.textContent||t.innerHTML||"").replace(Tt,"")),t.parentNode&&t.parentNode.removeChild(t)})}return this}}),v.buildFragment=function(e,n,r){var s,o,u,a=e[0];return n=n||i,n=!n.nodeType&&n[0]||n,n=n.ownerDocument||n,e.length===1&&typeof a=="string"&&a.length<512&&n===i&&a.charAt(0)==="<"&&!bt.test(a)&&(v.support.checkClone||!St.test(a))&&(v.support.html5Clone||!wt.test(a))&&(o=!0,s=v.fragments[a],u=s!==t),s||(s=n.createDocumentFragment(),v.clean(e,n,s,r),o&&(v.fragments[a]=u&&s)),{fragment:s,cacheable:o}},v.fragments={},v.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){v.fn[e]=function(n){var r,i=0,s=[],o=v(n),u=o.length,a=this.length===1&&this[0].parentNode;if((a==null||a&&a.nodeType===11&&a.childNodes.length===1)&&u===1)return o[t](this[0]),this;for(;i<u;i++)r=(i>0?this.clone(!0):this).get(),v(o[i])[t](r),s=s.concat(r);return this.pushStack(s,e,o.selector)}}),v.extend({clone:function(e,t,n){var r,i,s,o;v.support.html5Clone||v.isXMLDoc(e)||!wt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(kt.innerHTML=e.outerHTML,kt.removeChild(o=kt.firstChild));if((!v.support.noCloneEvent||!v.support.noCloneChecked)&&(e.nodeType===1||e.nodeType===11)&&!v.isXMLDoc(e)){Ot(e,o),r=Mt(e),i=Mt(o);for(s=0;r[s];++s)i[s]&&Ot(r[s],i[s])}if(t){At(e,o);if(n){r=Mt(e),i=Mt(o);for(s=0;r[s];++s)At(r[s],i[s])}}return r=i=null,o},clean:function(e,t,n,r){var s,o,u,a,f,l,c,h,p,d,m,g,y=t===i&&Ct,b=[];if(!t||typeof t.createDocumentFragment=="undefined")t=i;for(s=0;(u=e[s])!=null;s++){typeof u=="number"&&(u+="");if(!u)continue;if(typeof u=="string")if(!gt.test(u))u=t.createTextNode(u);else{y=y||lt(t),c=t.createElement("div"),y.appendChild(c),u=u.replace(dt,"<$1></$2>"),a=(vt.exec(u)||["",""])[1].toLowerCase(),f=Nt[a]||Nt._default,l=f[0],c.innerHTML=f[1]+u+f[2];while(l--)c=c.lastChild;if(!v.support.tbody){h=mt.test(u),p=a==="table"&&!h?c.firstChild&&c.firstChild.childNodes:f[1]==="<table>"&&!h?c.childNodes:[];for(o=p.length-1;o>=0;--o)v.nodeName(p[o],"tbody")&&!p[o].childNodes.length&&p[o].parentNode.removeChild(p[o])}!v.support.leadingWhitespace&&pt.test(u)&&c.insertBefore(t.createTextNode(pt.exec(u)[0]),c.firstChild),u=c.childNodes,c.parentNode.removeChild(c)}u.nodeType?b.push(u):v.merge(b,u)}c&&(u=c=y=null);if(!v.support.appendChecked)for(s=0;(u=b[s])!=null;s++)v.nodeName(u,"input")?_t(u):typeof u.getElementsByTagName!="undefined"&&v.grep(u.getElementsByTagName("input"),_t);if(n){m=function(e){if(!e.type||xt.test(e.type))return r?r.push(e.parentNode?e.parentNode.removeChild(e):e):n.appendChild(e)};for(s=0;(u=b[s])!=null;s++)if(!v.nodeName(u,"script")||!m(u))n.appendChild(u),typeof u.getElementsByTagName!="undefined"&&(g=v.grep(v.merge([],u.getElementsByTagName("script")),m),b.splice.apply(b,[s+1,0].concat(g)),s+=g.length)}return b},cleanData:function(e,t){var n,r,i,s,o=0,u=v.expando,a=v.cache,f=v.support.deleteExpando,l=v.event.special;for(;(i=e[o])!=null;o++)if(t||v.acceptData(i)){r=i[u],n=r&&a[r];if(n){if(n.events)for(s in n.events)l[s]?v.event.remove(i,s):v.removeEvent(i,s,n.handle);a[r]&&(delete a[r],f?delete i[u]:i.removeAttribute?i.removeAttribute(u):i[u]=null,v.deletedIds.push(r))}}}}),function(){var e,t;v.uaMatch=function(e){e=e.toLowerCase();var t=/(chrome)[ \/]([\w.]+)/.exec(e)||/(webkit)[ \/]([\w.]+)/.exec(e)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e)||/(msie) ([\w.]+)/.exec(e)||e.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)||[];return{browser:t[1]||"",version:t[2]||"0"}},e=v.uaMatch(o.userAgent),t={},e.browser&&(t[e.browser]=!0,t.version=e.version),t.chrome?t.webkit=!0:t.webkit&&(t.safari=!0),v.browser=t,v.sub=function(){function e(t,n){return new e.fn.init(t,n)}v.extend(!0,e,this),e.superclass=this,e.fn=e.prototype=this(),e.fn.constructor=e,e.sub=this.sub,e.fn.init=function(r,i){return i&&i instanceof v&&!(i instanceof e)&&(i=e(i)),v.fn.init.call(this,r,i,t)},e.fn.init.prototype=e.fn;var t=e(i);return e}}();var Dt,Pt,Ht,Bt=/alpha\([^)]*\)/i,jt=/opacity=([^)]*)/,Ft=/^(top|right|bottom|left)$/,It=/^(none|table(?!-c[ea]).+)/,qt=/^margin/,Rt=new RegExp("^("+m+")(.*)$","i"),Ut=new RegExp("^("+m+")(?!px)[a-z%]+$","i"),zt=new RegExp("^([-+])=("+m+")","i"),Wt={BODY:"block"},Xt={position:"absolute",visibility:"hidden",display:"block"},Vt={letterSpacing:0,fontWeight:400},$t=["Top","Right","Bottom","Left"],Jt=["Webkit","O","Moz","ms"],Kt=v.fn.toggle;v.fn.extend({css:function(e,n){return v.access(this,function(e,n,r){return r!==t?v.style(e,n,r):v.css(e,n)},e,n,arguments.length>1)},show:function(){return Yt(this,!0)},hide:function(){return Yt(this)},toggle:function(e,t){var n=typeof e=="boolean";return v.isFunction(e)&&v.isFunction(t)?Kt.apply(this,arguments):this.each(function(){(n?e:Gt(this))?v(this).show():v(this).hide()})}}),v.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Dt(e,"opacity");return n===""?"1":n}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":v.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var s,o,u,a=v.camelCase(n),f=e.style;n=v.cssProps[a]||(v.cssProps[a]=Qt(f,a)),u=v.cssHooks[n]||v.cssHooks[a];if(r===t)return u&&"get"in u&&(s=u.get(e,!1,i))!==t?s:f[n];o=typeof r,o==="string"&&(s=zt.exec(r))&&(r=(s[1]+1)*s[2]+parseFloat(v.css(e,n)),o="number");if(r==null||o==="number"&&isNaN(r))return;o==="number"&&!v.cssNumber[a]&&(r+="px");if(!u||!("set"in u)||(r=u.set(e,r,i))!==t)try{f[n]=r}catch(l){}},css:function(e,n,r,i){var s,o,u,a=v.camelCase(n);return n=v.cssProps[a]||(v.cssProps[a]=Qt(e.style,a)),u=v.cssHooks[n]||v.cssHooks[a],u&&"get"in u&&(s=u.get(e,!0,i)),s===t&&(s=Dt(e,n)),s==="normal"&&n in Vt&&(s=Vt[n]),r||i!==t?(o=parseFloat(s),r||v.isNumeric(o)?o||0:s):s},swap:function(e,t,n){var r,i,s={};for(i in t)s[i]=e.style[i],e.style[i]=t[i];r=n.call(e);for(i in t)e.style[i]=s[i];return r}}),e.getComputedStyle?Dt=function(t,n){var r,i,s,o,u=e.getComputedStyle(t,null),a=t.style;return u&&(r=u.getPropertyValue(n)||u[n],r===""&&!v.contains(t.ownerDocument,t)&&(r=v.style(t,n)),Ut.test(r)&&qt.test(n)&&(i=a.width,s=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=r,r=u.width,a.width=i,a.minWidth=s,a.maxWidth=o)),r}:i.documentElement.currentStyle&&(Dt=function(e,t){var n,r,i=e.currentStyle&&e.currentStyle[t],s=e.style;return i==null&&s&&s[t]&&(i=s[t]),Ut.test(i)&&!Ft.test(t)&&(n=s.left,r=e.runtimeStyle&&e.runtimeStyle.left,r&&(e.runtimeStyle.left=e.currentStyle.left),s.left=t==="fontSize"?"1em":i,i=s.pixelLeft+"px",s.left=n,r&&(e.runtimeStyle.left=r)),i===""?"auto":i}),v.each(["height","width"],function(e,t){v.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&It.test(Dt(e,"display"))?v.swap(e,Xt,function(){return tn(e,t,r)}):tn(e,t,r)},set:function(e,n,r){return Zt(e,n,r?en(e,t,r,v.support.boxSizing&&v.css(e,"boxSizing")==="border-box"):0)}}}),v.support.opacity||(v.cssHooks.opacity={get:function(e,t){return jt.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=v.isNumeric(t)?"alpha(opacity="+t*100+")":"",s=r&&r.filter||n.filter||"";n.zoom=1;if(t>=1&&v.trim(s.replace(Bt,""))===""&&n.removeAttribute){n.removeAttribute("filter");if(r&&!r.filter)return}n.filter=Bt.test(s)?s.replace(Bt,i):s+" "+i}}),v(function(){v.support.reliableMarginRight||(v.cssHooks.marginRight={get:function(e,t){return v.swap(e,{display:"inline-block"},function(){if(t)return Dt(e,"marginRight")})}}),!v.support.pixelPosition&&v.fn.position&&v.each(["top","left"],function(e,t){v.cssHooks[t]={get:function(e,n){if(n){var r=Dt(e,t);return Ut.test(r)?v(e).position()[t]+"px":r}}}})}),v.expr&&v.expr.filters&&(v.expr.filters.hidden=function(e){return e.offsetWidth===0&&e.offsetHeight===0||!v.support.reliableHiddenOffsets&&(e.style&&e.style.display||Dt(e,"display"))==="none"},v.expr.filters.visible=function(e){return!v.expr.filters.hidden(e)}),v.each({margin:"",padding:"",border:"Width"},function(e,t){v.cssHooks[e+t]={expand:function(n){var r,i=typeof n=="string"?n.split(" "):[n],s={};for(r=0;r<4;r++)s[e+$t[r]+t]=i[r]||i[r-2]||i[0];return s}},qt.test(e)||(v.cssHooks[e+t].set=Zt)});var rn=/%20/g,sn=/\[\]$/,on=/\r?\n/g,un=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,an=/^(?:select|textarea)/i;v.fn.extend({serialize:function(){return v.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?v.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||an.test(this.nodeName)||un.test(this.type))}).map(function(e,t){var n=v(this).val();return n==null?null:v.isArray(n)?v.map(n,function(e,n){return{name:t.name,value:e.replace(on,"\r\n")}}):{name:t.name,value:n.replace(on,"\r\n")}}).get()}}),v.param=function(e,n){var r,i=[],s=function(e,t){t=v.isFunction(t)?t():t==null?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};n===t&&(n=v.ajaxSettings&&v.ajaxSettings.traditional);if(v.isArray(e)||e.jquery&&!v.isPlainObject(e))v.each(e,function(){s(this.name,this.value)});else for(r in e)fn(r,e[r],n,s);return i.join("&").replace(rn,"+")};var ln,cn,hn=/#.*$/,pn=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,dn=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,vn=/^(?:GET|HEAD)$/,mn=/^\/\//,gn=/\?/,yn=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bn=/([?&])_=[^&]*/,wn=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,En=v.fn.load,Sn={},xn={},Tn=["*/"]+["*"];try{cn=s.href}catch(Nn){cn=i.createElement("a"),cn.href="",cn=cn.href}ln=wn.exec(cn.toLowerCase())||[],v.fn.load=function(e,n,r){if(typeof e!="string"&&En)return En.apply(this,arguments);if(!this.length)return this;var i,s,o,u=this,a=e.indexOf(" ");return a>=0&&(i=e.slice(a,e.length),e=e.slice(0,a)),v.isFunction(n)?(r=n,n=t):n&&typeof n=="object"&&(s="POST"),v.ajax({url:e,type:s,dataType:"html",data:n,complete:function(e,t){r&&u.each(r,o||[e.responseText,t,e])}}).done(function(e){o=arguments,u.html(i?v("<div>").append(e.replace(yn,"")).find(i):e)}),this},v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(e,t){v.fn[t]=function(e){return this.on(t,e)}}),v.each(["get","post"],function(e,n){v[n]=function(e,r,i,s){return v.isFunction(r)&&(s=s||i,i=r,r=t),v.ajax({type:n,url:e,data:r,success:i,dataType:s})}}),v.extend({getScript:function(e,n){return v.get(e,t,n,"script")},getJSON:function(e,t,n){return v.get(e,t,n,"json")},ajaxSetup:function(e,t){return t?Ln(e,v.ajaxSettings):(t=e,e=v.ajaxSettings),Ln(e,t),e},ajaxSettings:{url:cn,isLocal:dn.test(ln[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":Tn},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":v.parseJSON,"text xml":v.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:Cn(Sn),ajaxTransport:Cn(xn),ajax:function(e,n){function T(e,n,s,a){var l,y,b,w,S,T=n;if(E===2)return;E=2,u&&clearTimeout(u),o=t,i=a||"",x.readyState=e>0?4:0,s&&(w=An(c,x,s));if(e>=200&&e<300||e===304)c.ifModified&&(S=x.getResponseHeader("Last-Modified"),S&&(v.lastModified[r]=S),S=x.getResponseHeader("Etag"),S&&(v.etag[r]=S)),e===304?(T="notmodified",l=!0):(l=On(c,w),T=l.state,y=l.data,b=l.error,l=!b);else{b=T;if(!T||e)T="error",e<0&&(e=0)}x.status=e,x.statusText=(n||T)+"",l?d.resolveWith(h,[y,T,x]):d.rejectWith(h,[x,T,b]),x.statusCode(g),g=t,f&&p.trigger("ajax"+(l?"Success":"Error"),[x,c,l?y:b]),m.fireWith(h,[x,T]),f&&(p.trigger("ajaxComplete",[x,c]),--v.active||v.event.trigger("ajaxStop"))}typeof e=="object"&&(n=e,e=t),n=n||{};var r,i,s,o,u,a,f,l,c=v.ajaxSetup({},n),h=c.context||c,p=h!==c&&(h.nodeType||h instanceof v)?v(h):v.event,d=v.Deferred(),m=v.Callbacks("once memory"),g=c.statusCode||{},b={},w={},E=0,S="canceled",x={readyState:0,setRequestHeader:function(e,t){if(!E){var n=e.toLowerCase();e=w[n]=w[n]||e,b[e]=t}return this},getAllResponseHeaders:function(){return E===2?i:null},getResponseHeader:function(e){var n;if(E===2){if(!s){s={};while(n=pn.exec(i))s[n[1].toLowerCase()]=n[2]}n=s[e.toLowerCase()]}return n===t?null:n},overrideMimeType:function(e){return E||(c.mimeType=e),this},abort:function(e){return e=e||S,o&&o.abort(e),T(0,e),this}};d.promise(x),x.success=x.done,x.error=x.fail,x.complete=m.add,x.statusCode=function(e){if(e){var t;if(E<2)for(t in e)g[t]=[g[t],e[t]];else t=e[x.status],x.always(t)}return this},c.url=((e||c.url)+"").replace(hn,"").replace(mn,ln[1]+"//"),c.dataTypes=v.trim(c.dataType||"*").toLowerCase().split(y),c.crossDomain==null&&(a=wn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===ln[1]&&a[2]===ln[2]&&(a[3]||(a[1]==="http:"?80:443))==(ln[3]||(ln[1]==="http:"?80:443)))),c.data&&c.processData&&typeof c.data!="string"&&(c.data=v.param(c.data,c.traditional)),kn(Sn,c,n,x);if(E===2)return x;f=c.global,c.type=c.type.toUpperCase(),c.hasContent=!vn.test(c.type),f&&v.active++===0&&v.event.trigger("ajaxStart");if(!c.hasContent){c.data&&(c.url+=(gn.test(c.url)?"&":"?")+c.data,delete c.data),r=c.url;if(c.cache===!1){var N=v.now(),C=c.url.replace(bn,"$1_="+N);c.url=C+(C===c.url?(gn.test(c.url)?"&":"?")+"_="+N:"")}}(c.data&&c.hasContent&&c.contentType!==!1||n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),c.ifModified&&(r=r||c.url,v.lastModified[r]&&x.setRequestHeader("If-Modified-Since",v.lastModified[r]),v.etag[r]&&x.setRequestHeader("If-None-Match",v.etag[r])),x.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+(c.dataTypes[0]!=="*"?", "+Tn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)x.setRequestHeader(l,c.headers[l]);if(!c.beforeSend||c.beforeSend.call(h,x,c)!==!1&&E!==2){S="abort";for(l in{success:1,error:1,complete:1})x[l](c[l]);o=kn(xn,c,n,x);if(!o)T(-1,"No Transport");else{x.readyState=1,f&&p.trigger("ajaxSend",[x,c]),c.async&&c.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},c.timeout));try{E=1,o.send(b,T)}catch(k){if(!(E<2))throw k;T(-1,k)}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var Mn=[],_n=/\?/,Dn=/(=)\?(?=&|$)|\?\?/,Pn=v.now();v.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Mn.pop()||v.expando+"_"+Pn++;return this[e]=!0,e}}),v.ajaxPrefilter("json jsonp",function(n,r,i){var s,o,u,a=n.data,f=n.url,l=n.jsonp!==!1,c=l&&Dn.test(f),h=l&&!c&&typeof a=="string"&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Dn.test(a);if(n.dataTypes[0]==="jsonp"||c||h)return s=n.jsonpCallback=v.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,o=e[s],c?n.url=f.replace(Dn,"$1"+s):h?n.data=a.replace(Dn,"$1"+s):l&&(n.url+=(_n.test(f)?"&":"?")+n.jsonp+"="+s),n.converters["script json"]=function(){return u||v.error(s+" was not called"),u[0]},n.dataTypes[0]="json",e[s]=function(){u=arguments},i.always(function(){e[s]=o,n[s]&&(n.jsonpCallback=r.jsonpCallback,Mn.push(s)),u&&v.isFunction(o)&&o(u[0]),u=o=t}),"script"}),v.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(e){return v.globalEval(e),e}}}),v.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),v.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=i.head||i.getElementsByTagName("head")[0]||i.documentElement;return{send:function(s,o){n=i.createElement("script"),n.async="async",e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,i){if(i||!n.readyState||/loaded|complete/.test(n.readyState))n.onload=n.onreadystatechange=null,r&&n.parentNode&&r.removeChild(n),n=t,i||o(200,"success")},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(0,1)}}}});var Hn,Bn=e.ActiveXObject?function(){for(var e in Hn)Hn[e](0,1)}:!1,jn=0;v.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&Fn()||In()}:Fn,function(e){v.extend(v.support,{ajax:!!e,cors:!!e&&"withCredentials"in e})}(v.ajaxSettings.xhr()),v.support.ajax&&v.ajaxTransport(function(n){if(!n.crossDomain||v.support.cors){var r;return{send:function(i,s){var o,u,a=n.xhr();n.username?a.open(n.type,n.url,n.async,n.username,n.password):a.open(n.type,n.url,n.async);if(n.xhrFields)for(u in n.xhrFields)a[u]=n.xhrFields[u];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),!n.crossDomain&&!i["X-Requested-With"]&&(i["X-Requested-With"]="XMLHttpRequest");try{for(u in i)a.setRequestHeader(u,i[u])}catch(f){}a.send(n.hasContent&&n.data||null),r=function(e,i){var u,f,l,c,h;try{if(r&&(i||a.readyState===4)){r=t,o&&(a.onreadystatechange=v.noop,Bn&&delete Hn[o]);if(i)a.readyState!==4&&a.abort();else{u=a.status,l=a.getAllResponseHeaders(),c={},h=a.responseXML,h&&h.documentElement&&(c.xml=h);try{c.text=a.responseText}catch(p){}try{f=a.statusText}catch(p){f=""}!u&&n.isLocal&&!n.crossDomain?u=c.text?200:404:u===1223&&(u=204)}}}catch(d){i||s(-1,d)}c&&s(u,f,c,l)},n.async?a.readyState===4?setTimeout(r,0):(o=++jn,Bn&&(Hn||(Hn={},v(e).unload(Bn)),Hn[o]=r),a.onreadystatechange=r):r()},abort:function(){r&&r(0,1)}}}});var qn,Rn,Un=/^(?:toggle|show|hide)$/,zn=new RegExp("^(?:([-+])=|)("+m+")([a-z%]*)$","i"),Wn=/queueHooks$/,Xn=[Gn],Vn={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=zn.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(v.cssNumber[e]?"":"px");if(r!=="px"&&u){u=v.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,v.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};v.Animation=v.extend(Kn,{tweener:function(e,t){v.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],Vn[n]=Vn[n]||[],Vn[n].unshift(t)},prefilter:function(e,t){t?Xn.unshift(e):Xn.push(e)}}),v.Tween=Yn,Yn.prototype={constructor:Yn,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(v.cssNumber[n]?"":"px")},cur:function(){var e=Yn.propHooks[this.prop];return e&&e.get?e.get(this):Yn.propHooks._default.get(this)},run:function(e){var t,n=Yn.propHooks[this.prop];return this.options.duration?this.pos=t=v.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Yn.propHooks._default.set(this),this}},Yn.prototype.init.prototype=Yn.prototype,Yn.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=v.css(e.elem,e.prop,!1,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){v.fx.step[e.prop]?v.fx.step[e.prop](e):e.elem.style&&(e.elem.style[v.cssProps[e.prop]]!=null||v.cssHooks[e.prop])?v.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Yn.propHooks.scrollTop=Yn.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},v.each(["toggle","show","hide"],function(e,t){var n=v.fn[t];v.fn[t]=function(r,i,s){return r==null||typeof r=="boolean"||!e&&v.isFunction(r)&&v.isFunction(i)?n.apply(this,arguments):this.animate(Zn(t,!0),r,i,s)}}),v.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Gt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=v.isEmptyObject(e),s=v.speed(t,n,r),o=function(){var t=Kn(this,v.extend({},e),s);i&&t.stop(!0)};return i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return typeof e!="string"&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=e!=null&&e+"queueHooks",s=v.timers,o=v._data(this);if(n)o[n]&&o[n].stop&&i(o[n]);else for(n in o)o[n]&&o[n].stop&&Wn.test(n)&&i(o[n]);for(n=s.length;n--;)s[n].elem===this&&(e==null||s[n].queue===e)&&(s[n].anim.stop(r),t=!1,s.splice(n,1));(t||!r)&&v.dequeue(this,e)})}}),v.each({slideDown:Zn("show"),slideUp:Zn("hide"),slideToggle:Zn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){v.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),v.speed=function(e,t,n){var r=e&&typeof e=="object"?v.extend({},e):{complete:n||!n&&t||v.isFunction(e)&&e,duration:e,easing:n&&t||t&&!v.isFunction(t)&&t};r.duration=v.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in v.fx.speeds?v.fx.speeds[r.duration]:v.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){v.isFunction(r.old)&&r.old.call(this),r.queue&&v.dequeue(this,r.queue)},r},v.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},v.timers=[],v.fx=Yn.prototype.init,v.fx.tick=function(){var e,n=v.timers,r=0;qn=v.now();for(;r<n.length;r++)e=n[r],!e()&&n[r]===e&&n.splice(r--,1);n.length||v.fx.stop(),qn=t},v.fx.timer=function(e){e()&&v.timers.push(e)&&!Rn&&(Rn=setInterval(v.fx.tick,v.fx.interval))},v.fx.interval=13,v.fx.stop=function(){clearInterval(Rn),Rn=null},v.fx.speeds={slow:600,fast:200,_default:400},v.fx.step={},v.expr&&v.expr.filters&&(v.expr.filters.animated=function(e){return v.grep(v.timers,function(t){return e===t.elem}).length});var er=/^(?:body|html)$/i;v.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){v.offset.setOffset(this,e,t)});var n,r,i,s,o,u,a,f={top:0,left:0},l=this[0],c=l&&l.ownerDocument;if(!c)return;return(r=c.body)===l?v.offset.bodyOffset(l):(n=c.documentElement,v.contains(n,l)?(typeof l.getBoundingClientRect!="undefined"&&(f=l.getBoundingClientRect()),i=tr(c),s=n.clientTop||r.clientTop||0,o=n.clientLeft||r.clientLeft||0,u=i.pageYOffset||n.scrollTop,a=i.pageXOffset||n.scrollLeft,{top:f.top+u-s,left:f.left+a-o}):f)},v.offset={bodyOffset:function(e){var t=e.offsetTop,n=e.offsetLeft;return v.support.doesNotIncludeMarginInBodyOffset&&(t+=parseFloat(v.css(e,"marginTop"))||0,n+=parseFloat(v.css(e,"marginLeft"))||0),{top:t,left:n}},setOffset:function(e,t,n){var r=v.css(e,"position");r==="static"&&(e.style.position="relative");var i=v(e),s=i.offset(),o=v.css(e,"top"),u=v.css(e,"left"),a=(r==="absolute"||r==="fixed")&&v.inArray("auto",[o,u])>-1,f={},l={},c,h;a?(l=i.position(),c=l.top,h=l.left):(c=parseFloat(o)||0,h=parseFloat(u)||0),v.isFunction(t)&&(t=t.call(e,n,s)),t.top!=null&&(f.top=t.top-s.top+c),t.left!=null&&(f.left=t.left-s.left+h),"using"in t?t.using.call(e,f):i.css(f)}},v.fn.extend({position:function(){if(!this[0])return;var e=this[0],t=this.offsetParent(),n=this.offset(),r=er.test(t[0].nodeName)?{top:0,left:0}:t.offset();return n.top-=parseFloat(v.css(e,"marginTop"))||0,n.left-=parseFloat(v.css(e,"marginLeft"))||0,r.top+=parseFloat(v.css(t[0],"borderTopWidth"))||0,r.left+=parseFloat(v.css(t[0],"borderLeftWidth"))||0,{top:n.top-r.top,left:n.left-r.left}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||i.body;while(e&&!er.test(e.nodeName)&&v.css(e,"position")==="static")e=e.offsetParent;return e||i.body})}}),v.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);v.fn[e]=function(i){return v.access(this,function(e,i,s){var o=tr(e);if(s===t)return o?n in o?o[n]:o.document.documentElement[i]:e[i];o?o.scrollTo(r?v(o).scrollLeft():s,r?s:v(o).scrollTop()):e[i]=s},e,i,arguments.length,null)}}),v.each({Height:"height",Width:"width"},function(e,n){v.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){v.fn[i]=function(i,s){var o=arguments.length&&(r||typeof i!="boolean"),u=r||(i===!0||s===!0?"margin":"border");return v.access(this,function(n,r,i){var s;return v.isWindow(n)?n.document.documentElement["client"+e]:n.nodeType===9?(s=n.documentElement,Math.max(n.body["scroll"+e],s["scroll"+e],n.body["offset"+e],s["offset"+e],s["client"+e])):i===t?v.css(n,r,i,u):v.style(n,r,i,u)},n,o?i:t,o,null)}})}),e.jQuery=e.$=v,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return v})})(window);
; browserify_shim__define__module__export__(typeof $ != "undefined" ? $ : window.$);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],147:[function(require,module,exports){
(function (global){
/*
 * In this editor, we generate a declarative Vega spec (and its downstream d3
 * visualization) from a more descriptive scene-graph model. This corresponds
 * closely with a web UI that's bound and enabled using KnockoutJS.
 */

var $ = require('jquery'),
    vg = require('vega'),
    TreeIllustrator = require('./TreeIllustrator.js'),
    stashTransform = require('./vg.data.stash.js');
    pluckTransform = require('./vg.data.pluck.js');
    nexsonTransform = require('./vg.data.nexson.js');
    phylogramTransform = require('./vg.data.phylogram.js');

// expose TreeIllustrator to JS in the main UI 
global.TreeIllustrator = TreeIllustrator;
global.$ = $;

// register custom transforms with the installed vega
vg.transforms['stash'] = stashTransform;
vg.transforms['pluck'] = pluckTransform;
vg.transforms['nexson'] = nexsonTransform;
vg.transforms['phylogram'] = phylogramTransform;

// patch missing JS console on some (very) old browsers
if (typeof console == 'undefined') console = {
    log: function(msg) {},
    warn: function(msg) {},
    error: window.alert
}

// Test query-string variables, from http://stackoverflow.com/a/5158301
function getParameterByName(name) {
    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

/* Determine the current host application, so we can adapt to the advantages
 * and limitations of each:
 *  - storage options and requirements
 *      - slot- vs. URL-based storage
 *      - naming restrictions (uniqueness, etc)
 *  - data sources and formats, e.g.
 *      - values from a server-side kernel in Jupyter
 *      - user's resources in OpenTree repository
 *      - special adapters/validators for tree data
 *  - optional features and UI
 *  - adjustments to layout and style
 *
 * The host application should be specified on the query-string of
 * 'stylist.html', for example 
 *      .../stylist.html?hostApplication=JUPYTER_NOTEBOOK
 * The default value is a standalone page, which depends entirely on outside
 * web services for data and storage.
 */
var hostApplication = TreeIllustrator.hostApplications.STANDALONE;
// validate received host-app string against enumerated values
$.each(TreeIllustrator.hostApplications, function(i, testValue) {
    if (getParameterByName('hostApplication') == testValue) {
        hostApplication = testValue;
    }
});
console.log("Tree Illustrator host application: "+ hostApplication);

/* Offer all studies and trees from the Open Tree of Life repository,
 * plus other sources and tree formats. We'll make a tree of Knockout
 * observables, so we can update them (and the UI) on-the-fly.
 *
 * This should adapt to the current host application, for example:
 *  - "local" variables from an iPython notebook (incl. server-side kernel)
 *  - similar "local" data in an Arbor workflow
 *  - the current user's studies/trees/favorites in OpenTree
 *
 * N.B. The current display logic will hide any group that has no children.
 */
var availableTrees = ko.mapping.fromJS([
    {
        name: "Placeholder tree", 
        url: './placeholder-tree.json'
    },
    {
        name: "From notebook kernel",
        children: [
            /* A list of variables, each marked with its language/kernel */
        ]
    },
    {
        name: "Examples",
        children: [
            {
                name: "Tuovila, 2013", 
                url: buildStudyFetchURL( '2380' )
                /* NOTE that this one has two trees!
                treeID: 'tree4999',
                otusID: 'tree5000'
                */ 
            },
            {
                name: "Jansen, 2007", 
                url: buildStudyFetchURL( 'pg_10' )
            },
            {
                name: "Drew BT, 2014", 
                url: buildStudyFetchURL( 'pg_2821' )
            }
        ]
    },
    {
        name: "Paste/enter tree data"
        /*
        name: "Paste/enter tree data as...",
        children: [
            {
                name: "Newick string"
            },
            {
                name: "Newick string with extra data"
            },
            {
                name: "NEXUS"
            }
        ]
        */
    },
    {
        name: "Upload tree data"
        /*
        name: "Upload tree data as...",
        children: [
            {
                name: "Newick string"
            },
            {
                name: "Newick string with extra data"
            },
            {
                name: "NEXUS"
            }
        ]
        */
    },
    {
        name: "On the web",
        children: [
            {
                name: "Enter OpenTree study and tree ids"
            },
            {
                name: "Enter URL to NexSON 1.0"
            },
            {
                name: "Enter URL to a GitHub gist"
            }
        ]
    }
]);

function updateAvailableTrees() {
    /* Build an appropriate (nested) list of choices, based on the current host
     * application.
     *
     * N.B. this should be repeatable to update tree sources as they come and go.
     */
    switch(hostApplication) {
        case TreeIllustrator.hostApplications.JUPYTER_NOTEBOOK:
            /* Fetch notebook variables from the server-side kernel, via
             * Jupyter's JS API.
             * TODO: Can we deal with multiple kernels in the newest notebooks?
             * TODO: Can we distinguish R-via-Python from the Python kernel?
             */
            getTreeSourceList(function(response) {
                var notebookSourceList = ko.utils.arrayFirst(availableTrees(), function(item) {
                    return item.name() === 'From notebook kernel';
                });
                notebookSourceList.children.removeAll();
                if ('data' in response) {
                    var data = response.data;
                    if (data.length === 0) {
                        // explain the empty list, suggest a remedy
                        notebookSourceList.children.push({
                            name: ko.observable("No variables found! Run code cells and try again."),
                            disabled: ko.observable(true)  // info-only (not clickable)
                        });
                    } else {
                        // show any variables returned and their source kernel/lang
                        $.each(data, function(i, nbVar) {
                            // nbVar is a two-item list like ['Hi mom', 'str']
                            var nbVarName = nbVar[0],
                                nbVarType = nbVar[1],
                                nbVarLanguage = nbVar[2];
                            notebookSourceList.children.push({
                                name: ko.observable(nbVarName +" ("+ nbVarLanguage +" "+ nbVarType +")"),
                                kernel: ko.observable(nbVarLanguage)  
                                  // TODO: refers to kernel-id vs. language? eg 'python2'
                            });
                        });
                    }
                } else {
                    console.error(response.error || "No data returned (unspecified error)!");
                    // show the error in the source-list, and suggest a remedy
                    notebookSourceList.children.push({
                        name: ko.observable("ERROR loading notebook values. Run code cells and try again."),
                        disabled: ko.observable(true)  // info-only (not clickable)
                    });
                }
            })
            
            break;

        case TreeIllustrator.hostApplications.STANDALONE:
            // nothing to do here
            break;
    }
}

/* Conversion utilities for physical units
 */
var cm_per_inch = 2.54;
function inchesToCentimeters( inches ) {
    return inches * cm_per_inch;
}
function centimetersToInches( cm ) {
    return cm / cm_per_inch;
}

var pt_per_inch = 72.0;
function inchesToPoints( inches, ppi ) {
    return inches * pt_per_inch;
}
function pointsToInches( pt, ppi ) {
    return pt / pt_per_inch;
}

var pt_per_cm = pt_per_inch / cm_per_inch;
function centimetersToPoints( cm, ppi ) {
    return cm * pt_per_cm;
}
function pointsToCentimeters( pt, ppi ) {
    return pt / pt_per_cm;
}

function pixelsToInches( px, ppi ) {
    return px / ppi;
}
function inchesToPixels( inches, ppi ) {
    return inches * ppi;
}
function pixelsToCentimeters( px, ppi ) {
    return inchesToCentimeters(px / ppi);
}
function centimetersToPixels( cm, ppi ) {
    return centimetersToInches( cm ) * ppi;
}

function pixelsToPhysicalUnits( px, ppi ) {
    if (ill.style.printSize.units() === TreeIllustrator.units.INCHES) {
        return pixelsToInches( px, ppi );
    } else {
        return pixelsToCentimeters( px, ppi );
    }
}
function physicalUnitsToPixels( units, ppi ) {
    if (ill.style.printSize.units() === TreeIllustrator.units.INCHES) {
        return inchesToPixels( units, ppi );
    } else {
        return centimetersToPixels( units, ppi );
    }
}

function getPhysicalUnitSuffix() {
    if (physicalUnits === 'INCHES') {
        return 'in';
    } else {
        return 'cm';
    }
}

// ruler metrics (adjust for legibility)
var rulerWidth = 25;  // px

/* Maintain a few independent scales (in pixels/inch) to support the
 * illustration editor. These will sometimes align, but it's vital that we can
 * discriminate between them as each is suited for a different purposes.
 */
var browser_ppi;  // SVG resolution in current browser (not reliable!)
var internal_ppi = 90;  // SVG default pixels per inch (can be modified to suit printing device)
var display_ppi = internal_ppi;  // pixels per inch at current magnification (zoom level)

/* Track the values used for our viewport (overall size, margins vs. illustration)
 * for easy re-use in rulers, etc. For background, see SVG's viewBox docs: 
 * http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
 */
var viewbox = {
    'x': 0,
    'y': 0,
    'width': 0,
    'height': 0,
}
function updateViewportViewbox($viewport) {
    /* Adjust the main VG viewBox as needed to match the current illustration
     * size and chosen magnification. The result should be that scrollbars offer 
     * access to all SVG elements (in or out of the printed area), while the user
     * is free to choose arbitrary levels of magnification.
     */
    // TODO: maintain the current center point, but surrender empty territory
    if (!$viewport) {
        $viewport = $("#viz-outer-frame div.vega");
    }

    /* Make sure we have latest DIV size+proportions. (These can change if the
     * user toggles scrollbars or resizes the surrounding page.) This is the
     * new *minimum* size for our SVG element, to avoid gaps in the viewport!
     */
    var vpDiv = $viewport[0];
    var divWidth = vpDiv.clientWidth;
    var divHeight = vpDiv.clientHeight;
    var divProportions = divWidth / divHeight;

    /* What must be in the viewbox? All illustration elements (so we can scroll
     * to them), plus any padding needed (at current magnification) to fill the
     * viewport.
     */
    var ebox = getInclusiveIllustrationBoundingBox();
    // this is the area with all illustration elements
    var center = {
        x: ebox.x + (ebox.width / 2),
        y: ebox.y + (ebox.height / 2)
    };

    // copy to our persistent viewbox
    for (var prop in ebox) {
        viewbox[prop] = ebox[prop];
    }

    var proportionalWidth = Math.round(viewbox.width * viewportMagnification);
    var proportionalHeight = Math.round(viewbox.height * viewportMagnification);

    // compare its proportions to our *new* viewport; pad as needed to fill space
    var bbox = viewbox;
    if (proportionalWidth < divWidth) {
        // div is wider, pad viewbox width to match
        var adjustedWidth = divWidth / viewportMagnification;
        var extraWidth = adjustedWidth - viewbox.width;
        viewbox.width = adjustedWidth;
        viewbox.x -= (extraWidth / 2);
    } 
    if (proportionalHeight < divHeight) {
        // div is taller, pad viewbox height to match
        var adjustedHeight = divHeight / viewportMagnification;
        var extraHeight = adjustedHeight - viewbox.height;
        viewbox.height = adjustedHeight;
        viewbox.y -= (extraHeight / 2);
    }

    // move our background to the new viewport top-left corner
    d3.selectAll('#viewport-background, #viewport-bounds')
        .attr('x', viewbox.x)
        .attr('y', viewbox.y);

    // Update physical size of SVG element based on new viewbox and magnification
    proportionalWidth = Math.round(viewbox.width * viewportMagnification);
    proportionalHeight = Math.round(viewbox.height * viewportMagnification);
    var svgWidth = proportionalWidth;
    var svgHeight = proportionalHeight;

    // NOTE that we need to use el.setAttribute to keep mixed-case attribute names
    var svg = $viewport.find('svg')[0];

    // make sure we're at least filling the available viewport DIV
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);

    // TODO: nudge scrollbars to hold a steady view?

    svg.setAttribute('viewBox', (viewbox.x +' '+ viewbox.y +' '+ viewbox.width +' '+viewbox.height));
    $('#viewbox-indicator').html(svg.getAttribute('viewBox'));
    $('#mag-indicator').html(viewportMagnification);
    $('#svg-width-indicator').html(svg.getAttribute('width'));
    $('#svg-height-indicator').html(svg.getAttribute('height'));

    /*
    console.log('OLD div w: '+ svg.getAttribute('width'));
    console.log('  viewbox.width: '+ viewbox.width);
    console.log('  * magnification: '+ viewportMagnification);
    console.log('  NEW div w: '+ viewbox.width * viewportMagnification);
    console.log('  INT div w: '+ Math.round(viewbox.width * viewportMagnification));
    console.log('OLD div h: '+ svg.getAttribute('height'));
    console.log('  viewbox.height: '+ viewbox.height);
    console.log('  * magnification: '+ viewportMagnification);
    console.log('  NEW div h: '+ viewbox.height * viewportMagnification);
    console.log('  INT div h: '+ Math.round(viewbox.height * viewportMagnification));
    */
}

/* TODO: Load available styles from an external source or store. These might be
 * shared or private. Styles should include name and description, defaults for
 * most visual properties, and constraints (soft or hard) that we can test
 * against.
 */
var availableStyleGuides = null;
function showStyleGuidePicker() {
    // for now, load from a static JSON file 
    var lookupURL = './style-guides.json';

    //showModalScreen("Gathering style guides...", {SHOW_BUSY_BAR:true});
    $.ajax({
        global: false,  // suppress web2py's aggressive error handling?
        type: 'GET',
        dataType: 'json',
        // crossdomain: true,
        // contentType: "application/json; charset=utf-8",
        url: lookupURL,
        complete: function( jqXHR, textStatus ) {
            //hideModalScreen();
            if ((textStatus !== 'success') && (textStatus !== 'parsererror')) {
                var errMsg = 'Sorry, there was an error looking up the available style guides. (See JS console for details.)';
                alert(errMsg); 
                console.warn(errMsg +'\n\ntextStatus='+ textStatus +'\n\n'+ jqXHR.responseText);
                //showErrorMessage(errMsg);
                return;
            }
            // convert raw response to JSON
            var resultsJSON = $.parseJSON(jqXHR.responseText);
            if (resultsJSON.length === 0) {
                alert('No style guides found!');
            } else {
                availableStyleGuides = resultsJSON;
                var $chooser = $('#styleguide-chooser');
                $chooser.find('.found-matches').empty();
                var $currentNameDisplay = $chooser.find('#current-styleguide-name');
                $currentNameDisplay.html( ill.styleGuide.name() );
                if (ill.styleGuide.version) {
                    // pivot based on version type
                    switch(ill.styleGuide.version.type()) {
                        case TreeIllustrator.versionTypes.CHECKSUM:
                            $currentNameDisplay.append('<em class="version">&nbsp; &lt;'+ ill.styleGuide.version.value() +'&gt;</em>');
                            break;
                        case TreeIllustrator.versionTypes.TIMESTAMP:
                            $currentNameDisplay.append('<em class="version">&nbsp;  as of '+ ill.styleGuide.version.value() +'</em>');
                            break;
                        case TreeIllustrator.versionTypes.SEMANTIC:
                            $currentNameDisplay.append('<em class="version">&nbsp; v'+ ill.styleGuide.version.value() +'</em>');
                            break;
                        default:
                            $currentNameDisplay.append('<em class="version">Unknown version type: '+ ill.styleGuide.version.value() +'</em>');
                    }
                }
                $chooser.find('#current-styleguide-source').html( ill.styleGuideSourceHTML() );
                $.each(availableStyleGuides, function(i, match) {
                    // is this the illlustration's current style guide? compare name, source, version
                    var isAssignedStyleGuide = false;
                    var isPreviousVersionOfAssignedStyleGuide = false;
                    if ((match.name === ill.styleGuide.name()) && (match.source.value === ill.styleGuide.source.value())) {
                        isAssignedStyleGuide = true;
                        if (match.version.value !== ill.styleGuide.version.value()) {
                            isPreviousVersionOfAssignedStyleGuide = true;
                        }
                    }
                    var $matchInfo = $('<div class="match"><img class="thumbnail"></img><div class="name"></div><div>Source: <span class="source"></span></div><div class="description"></div></div>');
                    var $thumb = $matchInfo.find('.thumbnail');
                    if (isAssignedStyleGuide) {
                        $matchInfo.addClass('assigned');
                        if (isPreviousVersionOfAssignedStyleGuide) {
                            $matchInfo.addClass('previous-version');
                            $thumb.after('<a class="btn btn-small" href="#" onclick="stylist.applyChosenStyleGuide(this); return false;">Update</a>');
                        } else {
                            $thumb.after('<a class="btn btn-small disabled" href="#" onclick="alert(\'This style guide is already applied to the current illustration.\'); return false;">Assigned</a>');
                        }
                    } else if (match.constraints) {
                        $thumb.after('<a class="btn btn-small" href="#" onclick="stylist.applyChosenStyleGuide(this); return false;">Apply</a>');
                    } else {
                        $thumb.after('<a class="btn btn-small disabled" href="#" onclick="alert(\'Sorry, this is just an empty example.\'); return false;">Example</a>');
                    }
                    $matchInfo.find('.thumbnail').attr('src', match.thumbnailSrc || './broken.png');
                    var $nameDisplay = $matchInfo.find('.name');
                    $nameDisplay.html(match.name || '<em>No name found</em>');
                    if (match.version) {
                        // pivot based on version type
                        switch(match.version.type) {
                            case TreeIllustrator.versionTypes.CHECKSUM:
                                $nameDisplay.append('<em class="version">&nbsp; &lt;'+ match.version.value +'&gt;</em>');
                                break;
                            case TreeIllustrator.versionTypes.TIMESTAMP:
                                $nameDisplay.append('<em class="version">&nbsp;  as of '+ match.version.value +'</em>');
                                break;
                            case TreeIllustrator.versionTypes.SEMANTIC:
                                $nameDisplay.append('<em class="version">&nbsp; v'+ match.version.value +'</em>');
                                break;
                            default:
                                $nameDisplay.append('<em class="version">Unknown version type: '+ match.source.type +'</em>');
                        }
                    }
                    var $sourceDisplay = $matchInfo.find('.source');
                    if (match.source) {
                        // pivot based on source type
                        switch(match.source.type) {
                            case TreeIllustrator.dataSourceTypes.BUILT_IN:
                                $sourceDisplay.html('<strong>Built-in</em>');
                                break;
                            case TreeIllustrator.dataSourceTypes.URL:
                                $sourceDisplay.html('<a target="_blank" href="'+ match.source.value +'">'+ match.source.value +'</a>');
                                break;
                            default:
                                $sourceDisplay.html('<em>Unknown source type: '+ match.source.type +'</em>');
                        }
                    } else {
                        $sourceDisplay.html('<em>No source found</em>');
                    }
                    $matchInfo.find('.description').html( match.description || '<em>No description found</em>');
                    // add a unique key to determine the chosen style guide later
                    var sgKey = match.name +'|'+ (match.version ? match.version.value : "") +'|'+ (match.source ? match.source.value : "");
                    $matchInfo.append('<input type="hidden" class="match-key" value="'+ sgKey +'" />');
                    $chooser.find('.found-matches').append($matchInfo);
                });
                $chooser.off('shown').on('shown', function() {
                    // size scrolling list to fit in the current DOI-lookup popup window
                    var $chooser = $('#styleguide-chooser');
                    var resultsListHeight = $chooser.find('.modal-body').height() - $chooser.find('.before-matches').height();
                    $chooser.find('.found-matches')
                        .outerHeight(resultsListHeight)
                        .css('visibility','visible');
                });
                $chooser.find('.found-matches').css('visibility','hidden');
                $chooser.modal('show');
            }
        }
    });
}

/* The current Vega spec is generated using the chosen style (above) and 
 * the illustration source and decisions made in the web UI. When the
 * illustration is saved, the latest can also be embedded. Or perhaps we should
 * always generate it fresh from the source data and scene graph whenn
 * (re)loading the illustration?
 */
var vegaSpec;
function refreshViz(options) {
    if (!options) options = {}; 

    ill.updateVegaSpec();  // TODO: trigger updates on a more sensible basis

    vg.parse.spec(ill.vegaSpec, function(chart) {
      var view = chart({el:"#viz-outer-frame", renderer:"svg"});
      // , data:cachedData? })  <== MUST BE INLINE, NOT URL!
/*
        .on("mouseover", function(event, item) {
          // invoke hover properties on cousin one hop forward in scenegraph
          view.update({
            props: "hover",
            items: item.cousin(1)
          });
        })
        .on("mouseout", function(event, item) {
          // reset cousin item, using animated transition
          view.update({
            props: "update",
            items: item.cousin(1),
            duration: 250,
            ease: "linear"
          });
        })
*/
        view.update();

        if (options.SHOW_ALL) {
            resizeViewportToShowAll();
        } else {
            initTreeIllustratorWindow();
        }
    });
}

var ill;  

// Load an illustration from JS/JSON data (usu. called by convenience functions below)
function loadIllustrationData( data, newOrExisting ) {
    // Use an Illustration object as our primary view model for KnockoutJS
    // (by convention, it's usually named 'viewModel')
    ill = new TreeIllustrator.Illustration( data );
    // export the new illustration
    exports.ill = ill; 

    /* TODO: handle the newOrExisting storage info? or maybe this is
     * handled by the storage backend...
     */

    // add a single placeholder tree
    if (!data) {
        ill.addIllustratedTree();
    }

    // (re)bind to editor UI with Knockout
    var $boundElements = $('#editor'); // add other elements?
    $.each($boundElements, function(i, el) {
        ko.cleanNode(el);
        ko.applyBindings(ill,el);
    });

    refreshViz( {SHOW_ALL: true} );
}
function loadEmptyIllustration() {
    /* Load an empty illustration with a placeholder tree, with
     * no ID or slot assigned (i.e., treat this as a new illustration).
     *
     * TODO: Replace this with a simple template?
     */
    loadIllustrationData( null, 'NEW' );
}
// N.B. There should be additional convenience functions in the storage backend
//  - fetchAndLoadExistingIllustration( docID )
//  - fetchAndLoadIllustrationTemplate( templateID )

function fetchAndLoadExistingIllustration( docID ) {
    /* Load the JS (or JSON?) data provided, and keep track of its original ID/slot.
     */
    loadIllustration(docID, function(response) {
        if ('data' in response) {
            var data = response.data;
            loadIllustrationData( data, 'EXISTING' );
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}
function fetchAndLoadIllustrationTemplate( templateID ) {
    /* Load the JS (or JSON) data provided, but treat this as a new illustration.
     *
     * N.B. A template is basically an existing illustration document, with
     * internal prompts and placeholder trees/data, but we'll treat it as new.
     */
    // TODO: fetch using storage backend
    loadIllustration(docID, function(response) {
        if ('data' in response) {
            var template = response.data;
            loadIllustrationData( template, 'NEW' );
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}

$(document).ready(function() {
    // test for the preset ppi (pixels / inch) in this browser
    browser_ppi = $('#svg-toolbox').width() / 10.0;
    // NOTE that this is still unlikely to match the physical size of any particular monitor!
    // If that's important, we might want to let the user tweak this value.
    $('#browser-ppi-indicator').text(browser_ppi);
    $('#display-ppi-indicator').text(display_ppi);

    // show or disable the full-screen widgets
    var $fullScreenToggle = $('button#enter-full-screen');
    if ($.fullscreen.isNativelySupported()) {
        // ie, the current browser supports full-screen APIs
        $fullScreenToggle.show();
        $(document).bind('fscreenchange', function(e, state, elem) {
            // if we currently in fullscreen mode
            if ($.fullscreen.isFullScreen()) {
                $('#enter-full-screen').hide();
                $('#exit-full-screen').show();
            } else {
                $('#enter-full-screen').show();
                $('#exit-full-screen').hide();
            }
        });
    } else {
        // dim and disable the full-screen toggle
        $fullScreenToggle.css("opacity: 0.5;")
                         .click(function() {
                            alert("This browser does not support full-screen display.");
                            return false;
                         })
                         .show();
    }

    // TODO: Add "safety net" if there are unsaved changes
    // TODO: Add JSON support for older IE?

    // Update the list with initial values
    updateAvailableTrees();

    // Has my opener provided an initial illustration or template? If so, load it now
    var startingID = getParameterByName('startingID');
    console.log(">> startingID: "+ startingID +" <"+ typeof(startingID) +">");
    var startingType = getParameterByName('startingType');
    console.log(">> startingType: "+ startingType +" <"+ typeof(startingType) +">");
    // N.B. This should be a string, so '0' is a valid slot identifier!
    if (startingID) {
        switch (startingType) {
            case 'ILLUSTRATION':
                fetchAndLoadExistingIllustration( startingID );
                break;
            case 'TEMPLATE':
                fetchAndLoadIllustrationTemplate( startingID );
                break;
            default:
                console.error("No startingType provided (expected 'ILLUSTRATION' or 'TEMPLATE')!");
                return;
        }
    } else {
        loadEmptyIllustration();
    }

    matchViewportToWindowSize();

    // resizing the window should refresh/resize the viewport
    $(window).resize(function() {
        try {
            matchViewportToWindowSize();
            zoomViewport('REFRESH');
        } catch(e) {
            console.warn("Unable to complet resize:");
            console.warn(e);
        }
    });
});

function buildStudyFetchURL( studyID ) {
    // ASSUMES we're using the phylesystem API to load studies from the OpenTree dev site
    var template = "http://api.opentreeoflife.org/phylesystem/v1/study/{STUDY_ID}?output_nexml2json=1.0.0&auth_token=ANONYMOUS"
    return template.replace('{STUDY_ID}', studyID);
}

/*
function useChosenStyle() {
    viewModel.style = getChosenStyle();
    refreshViz();
}
function getChosenStyle() {
    var styleName = $('#style-chooser').val();
    return getStyleByName( styleName );
}
function getStyleByName( styleName ) {
    var selectedStyles = $.grep(availableStyles, function(o) {return o.name === styleName;});
    var styleInfo = null;
    if (selectedStyles.length > 0) {
        styleInfo = selectedStyles[0];
    }
    if (!styleName || !styleInfo) {
        console.warn("No style found under '"+ styleName +"'!");
        return null;
    }
    return styleInfo.style;
}
*/

function toggleFixedRulers(toggle) {
    var rulersAreHidden = $('#viz-outer-frame').hasClass('hide-rulers');
    var $toggleBtn = $(toggle);
    if (rulersAreHidden) {
        // show them now
        $('#viz-outer-frame').removeClass('hide-rulers');
        $toggleBtn.text('Hide rulers');
    } else {
        // hide them now
        $('#viz-outer-frame').addClass('hide-rulers');
        $toggleBtn.text('Show rulers');
    }
    updateViewportViewbox();
    zoomViewport('REFRESH');
}

function initTreeIllustratorWindow() {
    var $outerFrame = $("#viz-outer-frame");
    var $scrollingViewport = $outerFrame.find('div.vega');
    var $rulerUnitsDisplay = $outerFrame.find('#fixed-ruler-units');
    var $topRuler = $outerFrame.find('#fixed-ruler-top');
    var $leftRuler = $outerFrame.find('#fixed-ruler-left');
    //var scrollbarWidth = $scrollingViewport[0].offsetWidth - $scrollingViewport[0].clientWidth;
    var topRulerAdjustedWidth = $scrollingViewport[0].clientWidth;
    var leftRulerAdjustedHeight = $scrollingViewport[0].clientHeight;

    $rulerUnitsDisplay.css({
        'width': rulerWidth +"px",
        'height': rulerWidth +"px",
        'line-height': rulerWidth +"px",
        'font-size': Math.floor(rulerWidth / 2.5) +"px"
    });
    $topRuler.css({
        'height': rulerWidth+"px",
        // adjust width since there's no scrollbar here
        'width': topRulerAdjustedWidth +'px',
        'margin-right': -rulerWidth+"px"
    });
    $leftRuler.css({
        'width': rulerWidth+"px",
        // adjust height since there's no scrollbar here
        'height': leftRulerAdjustedHeight +'px',
        'margin-bottom': -rulerWidth+"px"
    });
    $scrollingViewport.css('margin-right', -(rulerWidth+1)+"px");

    // reset units display; clear old rulers
    $rulerUnitsDisplay.text( ill.style.printSize.units() === TreeIllustrator.units.INCHES ? "in" : "cm" );
    
    // adjust viewport/viewbox to reflect current magnification (display_ppi)
    updateViewportViewbox( $scrollingViewport );

    // sync scrolling of rulers to viewport
    //TODO: delegate these for one-time call!
    $scrollingViewport.off('scroll').on('scroll', function() {
        $topRuler.scrollLeft($scrollingViewport.scrollLeft());
        $leftRuler.scrollTop($scrollingViewport.scrollTop());
    });
    
    // sync resizing of rulers to viewport
    // (no event for this except on the window, it's an on-demand thing)
    var viewportWidth = $scrollingViewport[0].scrollWidth;
    var viewportHeight = $scrollingViewport[0].scrollHeight;
    var topRulerScale = d3.scale.linear()
        .domain([
            pixelsToPhysicalUnits(viewbox.x, internal_ppi),
            pixelsToPhysicalUnits(viewbox.x + viewbox.width, internal_ppi)
        ])
        .range([
            0,
            viewportWidth
        ]);
    var topRuler = d3.select("#fixed-ruler-top svg")
        .attr("width", viewportWidth+"px")
        .attr("height", rulerWidth+"px");
    drawRuler(topRuler, 'HORIZONTAL', ill.style.printSize.units(), topRulerScale);

    var leftRulerScale = d3.scale.linear()
        .domain([
            pixelsToPhysicalUnits(viewbox.y, internal_ppi),
            pixelsToPhysicalUnits(viewbox.y + viewbox.height, internal_ppi)
        ])
        .range([
            0,
            viewportHeight
        ]);
    var leftRuler = d3.select("#fixed-ruler-left svg")
        .attr("width", rulerWidth+"px")
        .attr("height", viewportHeight+"px");
    drawRuler(leftRuler, 'VERTICAL', ill.style.printSize.units(), leftRulerScale);
    
    enableViewportMask();
}

function roundToNearest( interval, input ) {
    // round to something more interesting than "any integer"
    // EXAMPLE: roundToNearest( 0.125, -0.52 ) ==>  -0.5
    // EXAMPLE: roundToNearest( 7, 46 ) ==>  49
    return Math.round(input / interval) * interval;
}

function drawRuler( svgParent, orientation, units, scale ) {
    /* Draw a ruler in the chosen context (assumes SVG or child of an SVG), with
        - appropriate units
        - sensible/legible subticks (eg, millimeters or sixteenths of an inch) 
        - size and adjust based on orientation (HORIZONTAL | VERTICAL)
     */
    // clear any prior ruler group
    svgParent.selectAll('*').remove();
    var nudgeTop = orientation === 'VERTICAL' ? 0 : rulerWidth - 1;
    var nudgeLeft = orientation === 'VERTICAL' ? rulerWidth - 1 : 0;

    var rulerAxis = d3.svg.axis()
        .scale(scale)
        .tickValues(d3.range(
            roundToNearest(1.0, scale.domain()[0]), 
            roundToNearest(1.0, scale.domain()[1] + 1), 
            1))
        .tickFormat(d3.format('d'))  // whole numbers
        .orient( orientation === 'VERTICAL' ? 'left' : 'top' );

    svgParent
        .append("g")
        .attr("class",'outer-axis')
        .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
        .call(rulerAxis);

    if (units === 'INCHES') {
        // trying subticks, using additional axes on the same scale
        var inchWidth = inchesToPixels(1, display_ppi);
        subticksAxis = d3.svg.axis()
            .scale(scale)
            .tickValues(d3.range(
                roundToNearest(0.5, scale.domain()[0]), 
                roundToNearest(0.5, scale.domain()[1]), 
                0.5))
            .tickFormat('') // unlabeled
            .tickSize(6)
            .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
        svgParent
            .append("g")
            .attr("class",'outer-axis')
            .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
            .call(subticksAxis);

        subticksAxis = d3.svg.axis()
            .scale(scale)
            .tickValues(d3.range(
                roundToNearest(0.25, scale.domain()[0]), 
                roundToNearest(0.25, scale.domain()[1]), 
                0.25))
            .tickFormat('') // unlabeled
            .tickSize(4)
            .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
        svgParent
            .append("g")
            .attr("class",'outer-axis subticks')
            .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
            .call(subticksAxis);

        if (inchWidth > 20) {
            subticksAxis = d3.svg.axis()
                .scale(scale)
                .tickValues(d3.range(
                    roundToNearest(0.125, scale.domain()[0]), 
                    roundToNearest(0.125, scale.domain()[1]), 
                    0.125))
                .tickFormat('') // unlabeled
                .tickSize(2)
                .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
            svgParent
                .append("g")
                .attr("class",'outer-axis subticks')
                .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
                .call(subticksAxis);
        }
    } else {
        // draw ticks for millimeters
        var cmWidth = centimetersToPixels(1, display_ppi);
        if (cmWidth > 30) {
            subticksAxis = d3.svg.axis()
                .scale(scale)
                .tickValues(d3.range(
                    roundToNearest(0.1, scale.domain()[0]), 
                    roundToNearest(0.1, scale.domain()[1]), 
                    0.1))
                .tickFormat('') // unlabeled
                .tickSize(3)
                .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
            svgParent
                .append("g")
                .attr("class",'outer-axis subticks')
                .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
                .call(subticksAxis);
        }
    }
}

var topBarHeight, bottomBarHeight;
function matchViewportToWindowSize() {
    if (!topBarHeight) {
        topBarHeight = $('#viz-top-control-bar').height();
        bottomBarHeight = $('#viz-bottom-control-bar').height();
        // freeze the control bars at their current height        
        $('#viz-top-control-bar').height(topBarHeight);
        $('#viz-bottom-control-bar').height(bottomBarHeight);
    }
    var columnHeight = $('#sticky-viewer-frame').height();
    var availableHeight = columnHeight - topBarHeight - bottomBarHeight;
    var $outerFrame = $("#viz-outer-frame");
    var nudge = -60;
    $outerFrame.height(availableHeight + nudge);
}

var viewportMagnification = 1.0;
function zoomViewport( directionOrZoomLevel ) {
    // let's use simple, proportional steps up and down
    var stepUp = 1.25;
    var stepDown = 0.8;  // should be inverse of stepUp
    var previousMagnification = viewportMagnification;

    switch(directionOrZoomLevel) {
        case 'REFRESH':
            // just update at the current magnification (e.g. when window is resized)
            break;
        case 'IN':
            viewportMagnification *= stepUp;
            break;
        case 'OUT':
            viewportMagnification *= stepDown;
            break;
        default: 
            // assume it's an explicit zoom level, where 1.0 means "actual size"
            viewportMagnification = directionOrZoomLevel;
            break;
    }
    display_ppi = internal_ppi * viewportMagnification;
    $('#display-ppi-indicator').text(display_ppi);

    // TODO: reset center point of viewbox? based on click XY, or current center?
    // TODO: update scrollTop, scrollLeft to stay in place?

    initTreeIllustratorWindow();
}

function resizeViewportToShowAll() {
    // show full illustration bounds (and all SVG elements!) in the viewport
    var bbox = getInclusiveIllustrationBoundingBox();

    // match the viewport's proportions (width/height)
    var $viewport = $("#viz-outer-frame div.vega");
    // NOTE that we want to match its *inner* size, not incl. scrollbars!
    var divWidth = $viewport[0].clientWidth;
    var divHeight = $viewport[0].clientHeight;
    // compare its proportions to our bounding box; pad as needed to match
    // TODO: this is duplicate code! refactor to DRY
    var divProportions = divWidth / divHeight;
    var bboxProportions = bbox.width / bbox.height;
    if (divProportions > bboxProportions) {
        // div is wider, pad bbox width to match
        var adjustedWidth = divProportions * bbox.height;
        var extraWidth = adjustedWidth - bbox.width;
        bbox.width = adjustedWidth;
        bbox.x -= (extraWidth / 2);
    } else {
        // div is taller (or equal), pad bbox height to match
        var flippedDivProportions = divHeight / divWidth;
        var adjustedHeight = flippedDivProportions * bbox.width;
        var extraHeight = adjustedHeight - bbox.height;
        bbox.height = adjustedHeight;
        bbox.x -= (extraHeight / 2);
    }

    // copy to our persistent viewbox
    for (var prop in bbox) {
        viewbox[prop] = bbox[prop];
    }

    // TODO: match the viewport's final size (disabled scrollbars)?
    
    /* Scale the proportional SVG to fit the viewport DIV. To do this, we
     * determine how big the new viewbox would be in pixels (using default_ppi)
     * and magnify this to fit the viewportDIV.
     */
    var newMagnification = divWidth / viewbox.width;
    // update the display
    zoomViewport( newMagnification );  // calls initTreeIllustratorWindow();
}
function getMinimalIllustrationBoundingBox() {
    // Return just the region defined for printing (copying its properties
    // to a simple Object, to prevent NoModificationAllowedError in IE)
    var bbox = $('#illustration-background')[0].getBBox();
    return $.extend({}, bbox);
}
function getInclusiveIllustrationBoundingBox() {
    // Fetch the region defined for printing, PLUS any "out of bounds" SVG
    // elements. Again, we'll copying its properties to a simple Object, to
    // prevent NoModificationAllowedError in IE.
    var bbox = d3.select('g.illustration-elements').node().getBBox();
    /* REMINDER: This designated group should contain all illustration elements
       and an invisible box matching the printed area. */
    return $.extend({}, bbox);
}
function getDiagnosticBoundingBox() {
    // gather outermost bounds based on diagnostic elements found
    var bbox = getMinimalIllustrationBoundingBox();
    var viewportSVG = d3.select("#viz-outer-frame div.vega svg");
    var rulers = viewportSVG.select("#rulers").node();
    if (rulers) {
        bbox = getCombinedBoundingBox( bbox, rulers.getBBox() );
    }
    var cropmarks = viewportSVG.select("#crop-marks").node();
    if (cropmarks) {
        bbox = getCombinedBoundingBox( bbox, cropmarks.getBBox() );
    }
    var description = viewportSVG.select("#description").node();
    if (description) {
        bbox = getCombinedBoundingBox( bbox, description.getBBox() );
    }
    return $.extend({}, bbox);
}
function getCombinedBoundingBox( box1, box2 ) {
    // reckon the "union" of two bounding boxes
    var bbox = $.extend({}, box1);
    // compare (obvious) left and top extents
    var bboxLeft = bbox.x;
    var box2Left = box2.x;
    if (box2Left < bboxLeft) {
        // increase width, then reset left edge
        bbox.width = bbox.width + (bboxLeft - box2Left);
        bbox.x = box2Left;
    }
    var bboxTop = bbox.y;
    var box2Top = box2.y;
    if (box2Top < bboxTop) {
        // increase height, then reset top edge
        bbox.height = bbox.height + (bboxTop - box2Top);
        bbox.y = box2Top;
    }
    // compare (implicit) right and bottom extents
    var bboxRight = bbox.x + bbox.width;
    var box2Right = box2.x + box2.width;
    if (box2Right > bboxRight) {
        bbox.width = box2Right - bbox.x;
    }
    var bboxBottom = bbox.y + bbox.height;
    var box2Bottom = box2.y + box2.height;
    if (box2Bottom > bboxBottom) {
        bbox.height = box2Bottom - bbox.y;
    }
    return bbox;
}

/* Annoying browser quirk! Firefox/Mac (and possibly others?) have different SVG
 * masking behavior, where the mask itself must transform along with the SVG it is
 * masking. In these cases, we need to match scale and "invert" X and Y
 * position of the mask.
 */
var svgMaskRequiresTransform = $.browser.mozilla;  //  && $.browser.version < "35";
/* NOTE that test this will fail when we upgrade to jQuery 1.9+! In that case, consider:
    * the jQuery Migrate plugin or this snippet:
      https://github.com/jquery/jquery-migrate/blob/e6bda6a84c294eb1319fceb48c09f51042c80892/src/core.js#L50
    * Modernizr (though it doesn't seem to detect this particular quirk)
    * sniffing the JS 'navigator' object for more information  
 */

/* Manage re-usable SVG elements in the viewport. These are typically defined
   in a persistent SVG defs element, where they can be modified and re-used
   (including multiple instances) for masking, clipping, and optional printed
   output like crop marks and diagnostic rulers.

   NOTE that we need to use d3 to create SVG elements. jQuery flubs the
   namespaces!
*/
function enableViewportMask() {
    //var toolboxSVG = d3.selectAll("#svg-toolbox");
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("enableViewportMask(): viewport SVG not found!");
        return null;
    }
    var mask = d3.select('#viewport-mask');

    if (svgMaskRequiresTransform) {
        // set explicit size and scale for the viewport mask itself
        d3.select("#viewport-mask")
            .attr('maskUnits', 'userSpaceOnUse')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', viewbox.width * viewportMagnification)
            .attr('height', viewbox.height * viewportMagnification);
        // scale the mask !? seems to be required for FF/Mac, at least
        var maskGroupTransform = 'translate('+ -(viewbox.x * viewportMagnification) +','+ -(viewbox.y * viewportMagnification) +') scale('+ viewportMagnification +')';
        //console.log(maskGroupTransform);
        d3.select("#mask-shapes")
            .attr('transform', maskGroupTransform);
    }

    // match the mask's viewport-bounds to the current viewport size
    d3.select("#viewport-bounds")
        .attr('x', viewbox.x)
        .attr('y', viewbox.y)
        .attr('width', viewbox.width)
        .attr('height', viewbox.height);
    // match the mask's illustration-bounds to the current illustration size
    d3.select("#illustration-bounds")
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi))
        .attr('height', physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi));

    // assign the mask to the main viewport (fades stuff outside the print area)
    viewportSVG.attr('mask', 'url(#viewport-mask)');

    if (viewportSVG.selectAll("#viewport-background").empty()) {
        // add milder backdrop for work area (outside the print area)
        viewportSVG.insert('rect', 'svg > g')
                .attr('id', 'viewport-background')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('fill', '#ccc');
        // add a white background for the print area
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'illustration-background')
                .attr('xlink:href', '#illustration-bounds')
                .style('stroke','#bbb');
    }
    d3.select('#viewport-background')
        .attr('x', viewbox.x)
        .attr('y', viewbox.y);
    viewportSVG.selectAll("#viewport-background, #illustration-background")
        .style("visibility", "visible");
}
function disableViewportMask() {
    // remove and clean up masking stuff (prior to printing?)
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.attr('mask', null);
/*
    viewportSVG.selectAll("#viewport-background").remove();
    viewportSVG.selectAll("#illustration-background").remove();
*/
    viewportSVG.selectAll("#viewport-background, #illustration-background")
        .style("visibility", "hidden");
}

function enablePrintingCropArea() {
    d3.select('div.vega svg g.illustration-elements')
        .style('clip-path','url(#printing-clip-path)');
}
function disablePrintingCropArea() {
    d3.select('div.vega svg g.illustration-elements')
        .style('clip-path','none');
}

/* Manage diagnostic markings (crop marks, description, rulers) for printed output */
function showPrintingDiagnostics() {
    showPrintingCropMarks();
    showPrintingDescription();
    showPrintingRulers();
}
function hidePrintingDiagnostics() {
    hidePrintingCropMarks();
    hidePrintingDescription();
    hidePrintingRulers();
}
function showPrintingCropMarks() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingCropMarks(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#crop-marks").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'crop-marks')
                .attr('xlink:href', '#printing-crop-marks');
    }
    // adjust placement of marks to match for illustration size
    var printTopEdge = 0;  // no need to set these
    var printLeftEdge = 0;
    var printBottomEdge = physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi);
    var printRightEdge = physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi);
    d3.select('#crop-mark-top-right')
        .attr('transform', "translate("+ printRightEdge +", 0)");
    d3.select('#crop-mark-bottom-left')
        .attr('transform', "translate(0, "+ printBottomEdge +")");
    d3.select('#crop-mark-bottom-right')
        .attr('transform', "translate("+ printRightEdge +", "+ printBottomEdge +")");
}
function hidePrintingCropMarks() {
    // remove all crop-mark instances
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#crop-marks").remove();
}
function showPrintingDescription() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingDescription(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#description").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'description')
                .attr('xlink:href', '#printing-description');
    }
    // NOTE that we need to move the *original* text element to get its proper bounding box!
    d3.select('#printing-description-name')
        .attr('x', -50)
        .attr('y', -110)
        .text("TODO: Add the actual illustration name, or 'Untitled'");
    var rightNow = new Date();
    var displayDateTime = "Generated "+ rightNow.toLocaleDateString() +" - "+ rightNow.toLocaleTimeString();
    d3.select('#printing-description-datetime')
        .attr('x', -50)
        .attr('y', -94)
        .text(displayDateTime);
}
function hidePrintingDescription() {
    // remove description instance
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#description").remove();
}
function showPrintingRulers() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingDescription(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#rulers").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'rulers')
                .attr('xlink:href', '#printing-rulers')
                .attr('x', 0)
                .attr('y', -60);
    }
    // set scale for inch ruler
    var unitWidth = inchesToPixels(1.0, internal_ppi);
    d3.select('#ruler-inches line')
        .attr('x2', 6 * unitWidth);
    d3.selectAll('#ruler-inches rect')
        .each(function(d,i) {
            d3.select(this)
                .attr('width', unitWidth)
                .attr('x', (i * 2 * unitWidth) + unitWidth)
        });
    // set scale for cm ruler
    unitWidth = centimetersToPixels(1.0, internal_ppi);
    d3.select('#ruler-cm line')
        .attr('x2', 16 * unitWidth);
    d3.selectAll('#ruler-cm rect')
        .each(function(d,i) {
            d3.select(this)
                .attr('width', unitWidth)
                .attr('x', (i * 2 * unitWidth) + unitWidth)
        });
}
function hidePrintingRulers() {
    // remove description instance
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#rulers").remove();
}

function getPrintableSVG( options ) {
    // TODO: Add an option to generate standalone SVG, vs. inline for HTML5
    if (!options) options = {};

    // shift SVG from editing to printing
    disableViewportMask();
    enablePrintingCropArea();
    if (options.INCLUDE_DIAGNOSTICS) {
        showPrintingDiagnostics();
    }

    // capture the viewbox and pixel dimensions of the current working view
    var illustration = d3.select('#viz-outer-frame div.vega svg');
    var workingView = {
        'width': illustration.attr("width"),
        'height': illustration.attr("height"),
        'viewBox': illustration.attr("viewBox")
    }

    // modify the viewbox to capture just the illustration elements (and possibly diagnostic stuff)
    var printViewBox = (options.INCLUDE_DIAGNOSTICS) ?
        getDiagnosticBoundingBox() : 
        getMinimalIllustrationBoundingBox();

    /*
    console.log("printViewBox: ");
    console.log(printViewBox);
    */

    // shift the main SVG dimensions to physical units (for more accurate print size)
    var unitSuffix = ill.unitsCssSuffix();
    // reckon physical size in default (print-ready) ppi to "freeze" the pixel size of the top-level SVG
    illustration
        /* N.B. Relying on "natural" SVG res (90 ppi) prints not-quite to scale!
        .attr("width", printViewBox.width)   // rely on built-in ?
        .attr("height", printViewBox.height)
        */
        // Explicitly state WRONG physical size, using browser PPI; prints correctly, but gives me a migraine
        .attr("width", pixelsToPhysicalUnits(printViewBox.width, browser_ppi) + unitSuffix)
        .attr("height", pixelsToPhysicalUnits(printViewBox.height, browser_ppi) + unitSuffix)
        .attr("viewBox", (printViewBox.x +' '+ printViewBox.y +' '+ printViewBox.width +' '+printViewBox.height));

    /*
    console.log( "w: "+ illustration.attr('width') );
    console.log( "h: "+ illustration.attr('height') );
    console.log( "v: "+ illustration.attr('viewBox') );
    console.log("display_ppi: "+ display_ppi);
    console.log("internal_ppi: "+ internal_ppi);
    console.log("browser_ppi: "+ internal_ppi);
    console.log("viewportMagnification: "+ viewportMagnification);
    */

    // momentarily "splice" persistent defs into the illustration, capture the result
    var toolbox = d3.select('#svg-toolbox');
    var defs = toolbox.select('defs');
    $(illustration.node()).prepend(defs);

    /*
     * Capture the resulting SVG (ie, The Moment of Truth)... 
     */
    var combinedSVG = $('#viz-outer-frame div.vega').html();

    // Replace Safari's weird namespace prefixes (NS1:, NS2:, etc) with the real deal
    combinedSVG = combinedSVG.replace(/NS\d+:/gi, 'xlink:');

    /*
     * ... then unwind all these changes to restore our normal working view. 
     */

    // replace the persistent defs
    $(toolbox.node()).prepend(defs);

    // restore pixel dimensions (in deference to Vega)
    illustration
        .attr("width", workingView.width)
        .attr("height", workingView.height)
        .attr("viewBox", workingView.viewBox);

    // reverse all the previous steps
    if (options.INCLUDE_DIAGNOSTICS) {
        hidePrintingDiagnostics();
    }
    disablePrintingCropArea();
    enableViewportMask();

    return combinedSVG;
}

function printIllustration() {
    // print standalone SVG as a simple document
    var w=window.open();
    if (!w) {
        alert("Please allow popups for this domain.");
        return;
    }
    var showDiagnostics = $('#toggle-printing-diagnostics').is(':checked');
    var leaveWindowOpen = $('#toggle-offer-svg').is(':checked');

    // generate a simple HTML5 page with inline SVG
    // TODO: generate standalone SVG document (to save or share) instead?
    var doc = w.document;
    doc.open("text/html", "replace");
    doc.write('<!DOCTYPE html><HTML><HEAD><TITLE>Tree Illustrator - SVG for printing</TITLE></HEAD><BODY></BODY></HTML>');
    doc.close();
    var outputSVG = getPrintableSVG( {INCLUDE_DIAGNOSTICS: showDiagnostics} );
    // let the browser render the new window so we can use its height
    setTimeout(function() {
        if (leaveWindowOpen) {
            // write just the SVG to the new window, to be copied to clipboard
            var itsClientHeight = $('html', doc)[0].clientHeight - 50;
            doc.body.innerHTML = '<textarea style="width: 95%; height: '+ itsClientHeight +'px;">'+ outputSVG +'</textarea>';
        } else {
            // normal print+close behavior
            doc.body.innerHTML = outputSVG;
            w.print();
            w.close();
        }
    }, 500);
}

/* Accordion UI helpers */
function accordionPanelShown(e) {
    var $heading = $(e.target).prev('.panel-heading');
    $heading.find("i.help-rollover")
        .text('Click to close this panel');
}
function accordionPanelHidden(e) {
    var $heading = $(e.target).prev('.panel-heading');
    $heading.find("i.help-rollover")
        .text('Click to open this panel');
}
function showAccordionHint(e) {
    $(e.target)
        .find("i.help-rollover")
        .show();
}
function hideAccordionHint(e) {
    $(e.target)
        .find("i.help-rollover")
        .hide();
}
$(document).ready(function() {
    $('#ti-main-accordion .panel-body').on('shown', accordionPanelShown);
    $('#ti-main-accordion .panel-body').on('hidden', accordionPanelHidden);

    $('#ti-main-accordion .panel-heading').on('mouseenter', showAccordionHint);
    $('#ti-main-accordion .panel-heading').on('mouseleave', hideAccordionHint);
});

function doNothing() {
    // occasionally useful in Knockout.js click bindings
    return;
}

function getPrintAreaLandmarks() {
    // gather interesting coordinates in internal pixels
    if (ill) {
        return {
            width: physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi),
            height: physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi),
            leftX: 0,
            centerX: physicalUnitsToPixels(ill.style.printSize.width() / 2.0, internal_ppi),
            rightX: physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi),
            topY: 0,
            centerY: physicalUnitsToPixels(ill.style.printSize.height() / 2.0, internal_ppi),
            bottomY: physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi)
        };
    }
    // return placeholder values
    return {
        width:   1.0,
        height:  1.0,
        leftX:   0.0,
        centerX: 0.5,
        rightX:  1.0,
        topY:    0.0,
        centerY: 0.5,
        bottomY: 1.0
    };
}
 
function enterFullScreen() {
    var test = $('#full-screen-area').fullscreen();
    return false;
}
function exitFullScreen() {
    $.fullscreen.exit();
    return false;
}

function applyChosenStyleGuide(clicked) {
    var $clicked = $(clicked);
    var $sgBlock = $clicked.closest('.match');
    // TODO: replace this dumb matching with KO binding to actual data
    var matchKey = $sgBlock.find('.match-key').val();
    console.log("> Looking for matchKey: "+ matchKey);
    var chosenStyleGuide = null;
    $.each(availableStyleGuides, function(i, sg) {
        // is this the illlustration's current style guide? compare name, source, version
        var testKey  = sg.name +'|'+ sg.version.value +'|'+ sg.source.value;
        console.log(">> comparing testKey: "+ testKey);
        if (testKey === matchKey) {
            chosenStyleGuide = sg;
            return false;
        }
    });
    if (!chosenStyleGuide) {
        alert('Unable to match the chosen style guide!');
        return;
    }
    // TODO: apply / merge this style guide into the current illustration
    ill.applyStyleGuide(chosenStyleGuide);
    // close the modal chooser
    $sgBlock.closest('.modal-styleguide-chooser').find('.modal-header .close').click();
}

// manage illustrations (using an adapter with API methods, already loaded)
var currentIllustrationList = null;
    // keep the latest ordered array (with positions, names, descriptions)
function loadIllustrationList(callback) {
    console.log("loadIllustrationList() STARTING...");
    getIllustrationList(function(response) {
        // show the returned list (or report any error) from the upstream response
        if ('data' in response) {
            // expect an ordered array with names and descriptions
            currentIllustrationList = response.data;
            if (callback) {
                callback();
            }
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}
function showIllustrationList() {
    if (currentIllustrationList) {
        // Show names and descriptions in a simple, general chooser
        var $chooser = $('#simple-chooser');
        $chooser.find('[id="dialog-heading"]').html('Choose an existing illustration');
        $chooser.find('.found-matches').empty();
        $.each(currentIllustrationList, function(i, match) {
            /* List item should include these properties
             *  - name
             *  - description
             *  - source
             * N.B. In slot-based storage, `i` is the only source information
             */
            var $matchInfo = $('<div class="match"><div class="name"></div><div class="description"></div></div>');
            $matchInfo.find('.name').html(match.name || '<em>No name found</em>')
            $matchInfo.find('.description').html(match.description || '');
            $matchInfo.click(function() {
                fetchAndLoadExistingIllustration( match.source || i);
                // close the modal chooser
                $(this).closest('.modal-simple-chooser').find('.modal-header .close').click();
            });
            $chooser.find('.found-matches').append($matchInfo);
        });
        $chooser.off('shown').on('shown', function() {
            // size scrolling list to fit in the current DOI-lookup popup window
            var $chooser = $('#simple-chooser');
            var resultsListHeight = $chooser.find('.modal-body').height() - $chooser.find('.before-matches').height();
            $chooser.find('.found-matches')
                .outerHeight(resultsListHeight)
                .css('visibility','visible');
        });
        $chooser.find('.found-matches').css('visibility','hidden');
        $chooser.modal('show');
    } else {
        // load the initial list, then return here
        loadIllustrationList(showIllustrationList);
    }
}
function saveCurrentIllustration(saveToID) {
    console.log("saveCurrentIllustration() STARTING...");
    // TODO: How should this ID be determined?
    //  - unique/serialized slug, ala tree collections?
    //  - if provided as incoming arg, use to Save As
    //  - add an explicit arg for SAVE, SAVE_AS, DUPLICATE
    //  - should these details be delegated to the storage adapter?
    //  - OR should we rely entirely on (and possibly modify) its internal metadata?
    // Current behavior (in IPython notebook) is to assume the current (nth)
    // storage slot, unless 'NEW' or another integer is asserted here.
    saveIllustration(saveToID, function(response) {
        // (re)load the saved illustration (or report any error)
        if (response.error) {
            console.error( response.error );
        } else {
            currentIllustrationList = response.data;
        }
    });
}

// Expose some members to outside code (eg, Knockout bindings, onClick
// attributes...)
var api = [
    'TreeIllustrator',
    'showIllustrationList',
    'fetchAndLoadExistingIllustration',
    'fetchAndLoadIllustrationTemplate',
    'saveCurrentIllustration',
    'inchesToCentimeters',
    'centimetersToInches',
    'inchesToPoints',
    'pointsToInches',
    'centimetersToPoints',
    'pointsToCentimeters',
    'pixelsToInches',
    'inchesToPixels',
    'pixelsToCentimeters',
    'centimetersToPixels',
    'pixelsToPhysicalUnits',
    'physicalUnitsToPixels',
    'pointsToCentimeters',
    'getPrintAreaLandmarks',
    'toggleFixedRulers',
    'refreshViz',
    'doNothing',
    'browser_ppi',
    'internal_ppi',
    'display_ppi',
    'availableTrees',
    'zoomViewport',
    'printIllustration',
    'resizeViewportToShowAll',
    'availableStyleGuides',
    'showStyleGuidePicker',
    'applyChosenStyleGuide',
    'enterFullScreen',
    'exitFullScreen',
    'ill'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TreeIllustrator.js":145,"./vg.data.nexson.js":149,"./vg.data.phylogram.js":150,"./vg.data.pluck.js":151,"./vg.data.stash.js":152,"jquery":146,"vega":89}],148:[function(require,module,exports){
/* 
 * Generally useful tools for modules in Tree Illustrator. They might be
 * concerned with display logic, geometry and transformation, text formatting;
 * anything that spans our normal lines of responsibility.
 */

function jiggle( range ) {
    // Return a number +- zero, within this range
    return Math.round(Math.random() * range * 2) - range; 
}


/* "Sniffers" to guess the format of user-entered tree data. 
 * N.B. these don't need to be fool-proof; they're just used to pre-select
 * the most likely format. 
 */
function isProbablyNewick(data) {
    if (typeof(data) !== 'string') {
        return false;
    }
    data = $.trim(data);
    // Look for expected start and end marks
    // N.B. this will reject a valid (but trivial) string like 'A;'
    if (data.startsWith('(') && data.endsWith(');')) {
        return true;
    }
    return false;
}

var matchesNEXUSBlockStarter = new RegExp('begin \\w+;');
function isProbablyNEXUS(data) {
    if (typeof(data) !== 'string') {
        return false;
    }
    // Look for required(?) first line
    if ($.trim(data).startsWith("#nexus")) {
        return true;
    }
    // ... or accept typical NEXUS block starter
    if (matchesNEXUSBlockStarter.test(data)) {
        return true;
    }
    return false;
}

function isProbablyNeXML(data) {
    /* NOTE that this is the most "expensive" sniffer, so it's probably
     * best to check the others first.
     */
    var testXML;
    if (data instanceof XMLDocument) {
        testXML = data;
    } else {
        try {
            testXML = $.parseXML(data);
            if (!testXML) {
                // if data is not a string, result is null 
                return false;
            }
        } catch (err) {
            // var failed to parse as XML
            ///console.error(err);
            return false;
        }
    }
    if ($(testXML).children().length === 0) {
        // XML is strangely empty
        return false;
    }
    var rootNodeName = $(testXML).children()[0].nodeName;
    switch( rootNodeName ) {
        case 'nex:nexml':
            break;
        case 'nexml':
            break;
        default:
            return false;
    }
    return true;
}


// export some members as a simple API
var api = [
    'jiggle',
    'isProbablyNewick',
    'isProbablyNEXUS',
    'isProbablyNeXML'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});


},{}],149:[function(require,module,exports){
/* 
 * Transform NEXson data into a form suitable for use in the Tree Illustrator
 * and d3.phylogram.js. This extends the Vega's vg.data space so we can take
 * advantage of its pipeline and other features. It's patterned after the 
 * project's treemap.js, which also does transformation tied to a specific 
 * d3 representation.
 * 
 * Anticipate other importers like this one for NEXML, etc. (assumes JSON? or
 * can we parse free-form text? YES, since vega handles CSV, etc.). Each one 
 * should produce the same output: a uniform JS object representing a
 * d3-ready tree (see https://github.com/OpenTreeOfLife/tree-illustrator/wiki/Building-on-D3-and-Vega#data-importers)
 */
var vg  = require('vega'),
    //d3  = require('d3'),
    log  = require('vega-logging'),
    Transform = require('vega/src/transforms/Transform');

function Nexson(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      treeID: {type: 'value'},
      treesCollectionPosition: {type: 'value', default: 0},
      treePosition: {type: 'value', default: 0}
  });
  return this.produces(true)
             .mutates(true);
}

var prototype = (Nexson.prototype = Object.create(Transform.prototype));
prototype.constructor = Nexson;

prototype.transform = function(input) {
  log.debug(input, ['converting to nexson']);

  var treeID = this.param('treeID'),
      treesCollectionPosition = this.param('treesCollectionPosition'),
      treePosition = this.param('treePosition'),
      nexml = null;

  /*
   * NEXson-specific logic, encapsulated for easy access to nexml, etc.
   *
   * Adapted from https://github.com/OpenTreeOfLife/opentree/blob/79aa1f4f72940c0f5708fd2ced56190d8c34ad9a/curator/static/js/study-editor.js
   */
  var fastLookups = {
      'NODES_BY_ID': null,
      'OTUS_BY_ID': null,
      'EDGES_BY_SOURCE_ID': null,
      'EDGES_BY_TARGET_ID': null
  };
  function getFastLookup( lookupName ) {
      // return (or build) a flat list of Nexson elements by ID
      if (lookupName in fastLookups) {
          if (fastLookups[ lookupName ] === null) {
              buildFastLookup( lookupName );
          }
          return fastLookups[ lookupName ];
      }
      console.error("No such lookup as '"+ lookupName +"'!");
      return null;
  }
  function buildFastLookup( lookupName ) {
      // (re)build and store a flat list of Nexson elements by ID
      if (lookupName in fastLookups) {
          clearFastLookup( lookupName );
          var newLookup = {};
          switch( lookupName ) {

              case 'NODES_BY_ID':
                  // assumes that all node ids are unique, across all trees
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.node, function( i, node ) {
                          var itsID = node['@id'];
                          if (itsID in newLookup) {
                              console.warn("Duplicate node ID '"+ itsID +"' found!");
                          }
                          newLookup[ itsID ] = node;
                      });
                  });
                  break;

              case 'OTUS_BY_ID':
                  // assumes that all node ids are unique, across all trees
                  // AND 'otus' collections!
                  $.each(nexml.otus, function( i, otusCollection ) {
                      $.each(otusCollection.otu, function( i, otu ) {
                          var itsID = otu['@id'];
                          if (itsID in newLookup) {
                              console.warn("Duplicate otu ID '"+ itsID +"' found!");
                          }
                          newLookup[ itsID ] = otu;
                      });
                  });
                  break;

              case 'EDGES_BY_SOURCE_ID':
                  // allow multiple values for each source (ie, multiple children)
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.edge, function( i, edge ) {
                          var sourceID = edge['@source'];
                          if (sourceID in newLookup) {
                              newLookup[ sourceID ].push( edge );
                          } else {
                              // create the array, if not found
                              newLookup[ sourceID ] = [ edge ];
                          }
                      });
                  });
                  break;

              case 'EDGES_BY_TARGET_ID':
                  // allow multiple values for each target (for conflicted trees)
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.edge, function( i, edge ) {
                          var targetID = edge['@target'];
                          if (targetID in newLookup) {
                              newLookup[ targetID ].push( edge );
                          } else {
                              // create the array, if not found
                              newLookup[ targetID ] = [ edge ];
                          }
                      });
                  });
                  break;

          }
          fastLookups[ lookupName ] = newLookup;
      } else {
          console.error("No such lookup as '"+ lookupName +"'!");
      }
  }
  function clearFastLookup( lookupName ) {
      // clear chosen lookup, on demand (eg, after merging in new OTUs)
      if (lookupName === 'ALL') {
          for (var aName in fastLookups) {
              fastLookups[ aName ] = null;
          }
          return;
      } else if (lookupName in fastLookups) {
          fastLookups[ lookupName ] = null;
          return;
      }
      console.error("No such lookup as '"+ lookupName +"'!");
  }
  function getNexsonChildren(d) {
      var parentID = d['@id'];
      var itsChildren = [];
      var childEdges = getTreeEdgesByID(null, parentID, 'SOURCE');

      // If this node has one child, it's probably a latent root-node that
      // should be hidden in the tree view.
      if (childEdges.length === 1) {
          // treat ITS child node as my immediate child in the displayed tree
          var onlyChildNodeID = childEdges[0]['@target'];
          childEdges = getTreeEdgesByID(null, onlyChildNodeID, 'SOURCE');
      }

      $.each(childEdges, function(index, edge) {
          var childID = edge['@target'];
          var childNode = getTreeNodeByID(childID);
          if (!('@id' in childNode)) {
              console.error(">>>>>>> childNode is a <"+ typeof(childNode) +">");
              console.error(childNode);
          }
          itsChildren.push( childNode );
      });
      // N.B. D3 layouts expect null, instead of an empty array
      ///return (itsChildren.length === 0) ? null: itsChildren;
      return itsChildren;
  }
  function getTreeNodeByID(id) {
      // There should be only one matching (or none) within a tree
      // (NOTE that we now use a flat collection across all trees, so there's no 'tree' argument)
      var lookup = getFastLookup('NODES_BY_ID');
      return lookup[ id ] || null;
  }
  function getOTUByID(id) {
      // There should be only one matching (or none) in this study
      var lookup = getFastLookup('OTUS_BY_ID');
      return lookup[ id ] || null;
  }
  function getTreeEdgesByID(tree, id, sourceOrTarget) {
      // look for any edges associated with the specified *node* ID; return
      // an array of 0, 1, or more matching edges within a tree
      //
      // 'sourceOrTarget' lets us filter, should be 'SOURCE', 'TARGET', 'ANY'
      var foundEdges = [];
      var matchingEdges = null;

      if ((sourceOrTarget === 'SOURCE') || (sourceOrTarget === 'ANY')) {
          // fetch and add edges with this source node
          var sourceLookup = getFastLookup('EDGES_BY_SOURCE_ID');
          matchingEdges = sourceLookup[ id ];
          if (matchingEdges) {
              foundEdges = foundEdges.concat( matchingEdges );
          }
      }

      if ((sourceOrTarget === 'TARGET') || (sourceOrTarget === 'ANY')) {
          // fetch and add edges with this target node
          var targetLookup = getFastLookup('EDGES_BY_TARGET_ID');
          matchingEdges = targetLookup[ id ];
          if (matchingEdges) {
              foundEdges = foundEdges.concat( matchingEdges );
          }
      }

      return foundEdges;
  }
  function getSpecifiedTree() {
    var tree = null;
    // try all incoming options to locate this tree
    if ($.trim(treeID) !== '') {
        tree = getTreeByID(treeID);
    } else {
        tree = getTreeByPosition(treesCollectionPosition, treePosition);
    }
    return tree;
  }
  function getTreeByID(id) {
      var allTrees = [];
      if (!nexml) {
          return null;
      }
      $.each(nexml.trees, function(i, treesCollection) {
          $.each(treesCollection.tree, function(i, tree) {
              allTrees.push( tree );
          });
      });
      var foundTree = null;
      $.each( allTrees, function(i, tree) {
          if (tree['@id'] === id) {
              foundTree = tree;
              return false;
          }
      });
      return foundTree;
  }
  function getTreeByPosition(collectionPos, treePos) {
    var collection = nexml.trees[collectionPos];
    var tree = collection.tree[treePos];
    return tree;
  }
  function getRootNode() {
    // use options to find the root node, or return null
    var foundRoot = null;
    var tree = getSpecifiedTree();
    if (!tree) {
        return null;
    }
    var specifiedRoot = tree['^ot:specifiedRoot'] || null;
    var rootNodeID = specifiedRoot ? specifiedRoot : tree.node[0]['@id'];
    $.each(tree.node, function(i, node) {
        // Find the node with this ID and see if it has an assigned OTU
        if (node['@id'] === rootNodeID) {
            foundRoot = node;
            return false;
        }
    });
    return foundRoot;
  }
  /* END of 'NEXson-specific logic' */

  function convert(fullNexson) {
    // convert a new (or changed?) tree to Tree Illustrator's preferred format
    nexml = fullNexson.data.nexml;

    var layout = d3.layout.cluster()  // or tree (seems most basic)
                   .children(getNexsonChildren),  // below
        params = [ 'size' ],  // ["round", "sticky", "ratio", "padding"],
        output = {
          //"x": "x",
          //"y": "y",
          //"dx": "width",
          //"dy": "height"
        };

    var rootNode = getRootNode();  // defined below
    if (!rootNode) {
      console.warn("No root node found!");
      console.warn("  treeID: "+ treeID);
      console.warn("  treesCollectionPosition: "+ treesCollectionPosition);
      console.warn("  treePosition: "+ treePosition);
      return false;
    }

    data = {
        // copy _id of source data
        '_id': fullNexson._id
    };

    data.phyloNodes = layout
      //.size(vg.data.size(size, group))
      //.value(value)
        .nodes(rootNode);

    // add all possible labels to each node
    var tree = getSpecifiedTree();
    $.each(data.phyloNodes, function(i, node) {
      /* N.B. It's best to provide at least an empty string for all
       * properties, to avoid showing 'undefined' labels in some browsers.
       */
      node.explicitLabel = '';
      node.originalLabel = '';
      node.ottTaxonName = '';
      node.ottId = '';
      if ('label' in node) {
        console.log(">> node "+ i +" has 'label'");
        node.explicitLabel = node['label'];
      }
      if ('@label' in node) {
        console.log(">> node "+ i +" has '@label'");
        node.explicitLabel = node['@label'];
      }
      if ('@otu' in node) {
        var itsOTU = getOTUByID( node['@otu'] );
        // attach OTU with possible label(s) here
        if (itsOTU) {
          // nudge the relevant properties into a generic form
          if ('^ot:originalLabel' in itsOTU) {
            node.originalLabel = itsOTU['^ot:originalLabel'];
          }
          if ('^ot:ottTaxonName' in itsOTU) {
            node.ottTaxonName = itsOTU['^ot:ottTaxonName'];
          }
          if ('^ot:ottId' in itsOTU) {
            node.ottId = itsOTU['^ot:ottId'];
          }
          if ('@label' in itsOTU) {
            // This is uncommon, but appears in our converted Newick.
            // Yield to an explicit label on the node itself!
            console.log(">> stealing otu label '"+ itsOTU['@label'] +"' for this node");
            if ($.trim(node.explicitLabel) === '') {
              node.explicitLabel = itsOTU['@label'];
            }
          }
        }
      }
    });

    data.phyloEdges = layout.links(data.phyloNodes);
/* translate incoming keys to their output names?
    var keys = vg.keys(output),
        len = keys.length;

    data.forEach(function(d) {
      var key, val;
      for (var i=0; i<len; ++i) {
        key = keys[i];
        if (key !== output[key]) {
          val = d[key];
          delete d[key];
          d[output[key]] = val;
        }
      }
      //d.children = getChildren(d);
    });
*/


/*
    console.log("OUTGOING data from nexson transform:");
    console.log(data);
*/
    return data;
  }
  
  //input.add.forEach(convert);
  for (var i = 0; i < input.add.length; i++) {
    // actually replace each item with the new stucture
    input.add[i] = convert(input.add[i]);
  }
  if (this.reevaluate(input)) {
    //input.mod.forEach(convert);
    for (var i = 0; i < input.mod.length; i++) {
      // actually replace each item with the new stucture
      input.mod[i] = convert(input.mod[i]);
    }
  }
  // return the modified ChangeSet
  return input;
};

module.exports = Nexson;

Nexson.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Nexson transform",
  "description": "Transforms NEXson data into a form suitable for use in the Tree Illustrator"
               + " and d3.phylogram.js.",
  "type": "object",
  "properties": {
    "type": {"enum": ["nexson"]},
    "treeID": {
      "description": "An explicit tree ID (should be definitive)",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    },
    "treesCollectionPosition": {
      "description": "Look in the nth 'trees' element (collection of 'tree')",
      "oneOf": [{"type": "integer"}, {"$ref": "#/refs/signal"}],  // TODO: signal?
      "default": 0
    },
    "treePosition": {
      "description": "Convert the nth 'tree' found in this collection", // TODO: confirm
      "oneOf": [{"type": "integer"}, {"$ref": "#/refs/signal"}],
      "default": 0
    }
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type"]  // TODO: add required params
};







if (false) {

vg.transforms.nexson = function() {
  var layout = d3.layout.cluster()  // or tree (seems most basic)
                 //.children(function(d) { return d.values; }),
                 //.size([20,20])  // defaults to [1.0, 1.0]
                 .children(getNexsonChildren),  // below
      value = vg.accessor("data"),
      fullNexson = null,
      nexml = null,
      //size = ["width", "height"],
      params = [ 'size' ],  // ["round", "sticky", "ratio", "padding"],
      output = {
        //"x": "x",
        //"y": "y",
        //"dx": "width",
        //"dy": "height"
      };

  // Expect the ID of the specified tree, or the position of the specified
  // trees collection and tree.
  var treeID = null,
      treesCollectionPosition = 0,
      treePosition = 0;

  function nexson(data, db, group) {
/*
console.log("INCOMING data to nexson transform:");
console.log(data);
*/
    fullNexson = data['data'];  // stash the complete NEXson!
    nexml = fullNexson.data.nexml;
    var rootNode = getRootNode();  // defined below
    if (!rootNode) {
        console.warn("No root node found!");
        console.warn("  treeID: "+ treeID);
        console.warn("  treesCollectionPosition: "+ treesCollectionPosition);
        console.warn("  treePosition: "+ treePosition);
        return false;
    }

    data = {};

    data.phyloNodes = layout
      //.size(vg.data.size(size, group))
      //.value(value)
      .nodes(rootNode);

    // add all possible labels to each node
    var tree = getSpecifiedTree();
    $.each(data.phyloNodes, function(i, node) {
        /* N.B. It's best to provide at least an empty string for all
         * properties, to avoid showing 'undefined' labels in some browsers.
         */
        node.explicitLabel = '';
        node.originalLabel = '';
        node.ottTaxonName = '';
        node.ottId = '';
        if ('label' in node) {
            console.log(">> node "+ i +" has 'label'");
            node.explicitLabel = node['label'];
        }
        if ('@label' in node) {
            console.log(">> node "+ i +" has '@label'");
            node.explicitLabel = node['@label'];
        }
        if ('@otu' in node) {
            var itsOTU = getOTUByID( node['@otu'] );
            // attach OTU with possible label(s) here
            if (itsOTU) {
                // nudge the relevant properties into a generic form
                if ('^ot:originalLabel' in itsOTU) {
                    node.originalLabel = itsOTU['^ot:originalLabel'];
                }
                if ('^ot:ottTaxonName' in itsOTU) {
                    node.ottTaxonName = itsOTU['^ot:ottTaxonName'];
                }
                if ('^ot:ottId' in itsOTU) {
                    node.ottId = itsOTU['^ot:ottId'];
                }
                if ('@label' in itsOTU) {
                    // This is uncommon, but appears in our converted Newick.
                    // Yield to an explicit label on the node itself!
                    console.log(">> stealing otu label '"+ itsOTU['@label'] +"' for this node");
                    if ($.trim(node.explicitLabel) === '') {
                        node.explicitLabel = itsOTU['@label'];
                    }
                }
            }
        }
    });
    
    data.phyloEdges = layout.links(data.phyloNodes);
/* translate incoming keys to their output names?
    var keys = vg.keys(output),
        len = keys.length;

    data.forEach(function(d) {
      var key, val;
      for (var i=0; i<len; ++i) {
        key = keys[i];
        if (key !== output[key]) {
          val = d[key];
          delete d[key];
          d[output[key]] = val;
        }
      }
      //d.children = getChildren(d);
    });
*/

    
/*
    console.log("OUTGOING data from nexson transform:");
    console.log(data);
*/
    return data;
  }

  nexson.value = function(field) {
    value = vg.accessor(field);
    return nexson;
  };

  params.forEach(function(name) {
    nexson[name] = function(x) {
      layout[name](x);
      return nexson;
    }
  });

  // stolen from facet.js
  nexson.keys = function(k) {
    keys = vg.array(k).map(vg.accessor);
    return nexson;
  };
  nexson.sort = function(s) {
    sort = vg.data.sort().by(s);
    return nexson;
  };

  // Expose methods to accept tree ID (or ordinal position of the 
  // desired trees collection and a tree within it).
  nexson.treeID = function(s) {
    treeID = s;
    return nexson;
  };
  nexson.treesCollectionPosition = function(n) {
    treesCollectionPosition = n;
    return nexson;
  };
  nexson.treePosition = function(n) {
    treePosition = n;
    return nexson;
  };

    /*
     * NEXson-specific logic, encapsulated for easy access to nexml, etc.
MOVED
     */

  nexson.output = function(map) {
    // build children
    vg.keys(output).forEach(function(k) {
      if (map[k] !== undefined) {
        output[k] = map[k];
      }
    });
    return nexson;
  };

  return nexson;
};

}



},{"vega":89,"vega-logging":49,"vega/src/transforms/Transform":140}],150:[function(require,module,exports){
/*
  (Heavily) adapted from Ken-ichi Ueda's 'd3.phylogram.js'

  Wrapper around a d3-based phylogram (tree where branch lengths are scaled),
  refactored into a Vega transform. What does this change?
    - Returns transformed data (an object with nodes and links, projected to
      the coordinate space based on the chosen layout).
    - Assumes all incoming data has proportional x/y values (0.0 to 1.0).
    - Doesn't render anything! Just passes the projected data for downstream
      rendering.

  This includes new and modified layouts, including
    - radial (circular) layout with *scaled* branch lengths
    - a traditional cladogram with straight, diagonal edges

  Copyright (c) 2014, Jim Allman
  Copyright (c) 2013, Ken-ichi Ueda

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer. Redistributions in binary
  form must reproduce the above copyright notice, this list of conditions and
  the following disclaimer in the documentation and/or other materials
  provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

  DOCUMENTATION

  buildCartesian(nodes, links, options)
    Creates a phylogram.
    Arguments:
      nodes: JS array of nodes
      links: JS array of links
    Options:
      tree
        Pre-constructed d3 tree layout.
      diagonal
        Function that creates the d attribute for an svg:path. Defaults to a
        right-angle diagonal.
      skipTicks
        Skip the tick rule.
      skipBranchLengthScaling
        Make a dendrogram instead of a phylogram.
  
  buildRadial(nodes, links, options)
    Creates a radial dendrogram.
    Options: same as build, but without diagonal, skipTicks, and
      skipBranchLengthScaling
  
  buildCladogram(nodes, links, options)
    Creates a "triangular" dendrogram
    Options: TODO

  rightAngleDiagonal()
    Similar to d3.diagonal except it create an orthogonal crook instead of a
    smooth Bezier curve.
    
  radialRightAngleDiagonal()
    d3.phylogram.rightAngleDiagonal for radial layouts.
*/
var vg  = require('vega'),
    log  = require('vega-logging'),
    Transform = require('vega/src/transforms/Transform');

function Phylogram(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    layout: {type: 'value', default: 'cartesian'},
    width: {type: 'value', default: 1.0},
    height: {type: 'value', default: 1.0},
    // some are only used in radial layout, ignored in others
    radius: {type: 'value', default: 0.5},
    radialArc: {type: 'array<value>', default: [0, 360]},
    radialSweep: {type: 'value', default: 'CLOCKWISE'},  // 'CLOCKWISE' | 'COUNTERCLOCKWISE'
    // others are used only in non-radial layouts
    tipsAlignment: {type: 'value', default: 'RIGHT'},
    branchStyle: {type: 'value', default: ''}, // usu. determined by layout
    branchLengths: {type: 'value', default: ''},
    nodeLabelSource: {type: 'value', default: 'MAPPED'}, // 'ORIGINAL' | 'MAPPED'
    showFallbackLabels: {type: 'value', default: true}
    // some are reckoned internally (not available to the caller)
    //descentAxis: {type: 'value', default: 'x'}, // 'x' | 'y'
    //orientation: {type: 'value', default: -90},
  });
  return this.produces(true)
             .mutates(true);
}

var prototype = (Phylogram.prototype = Object.create(Transform.prototype));
prototype.constructor = Phylogram;

prototype.transform = function(input) {
  log.debug(input, ['making a phylogram']);

  for (var i = 0; i < input.add.length; i++) {
    this.buildPhylogram(input.add[i]);
  }
  if (this.reevaluate(input)) {
    for (var i = 0; i < input.mod.length; i++) {
      this.buildPhylogram(input.mod[i]);
    }
  }
  /* N.B. Typical notation doesn't work here ('this' is not defined in the called func)
  input.add.forEach();
  if (this.reevaluate(input)) {
    input.mod.forEach(this.buildPhylogram);
  }
  */

  return input;
};

prototype.buildPhylogram = function(data) {
    // read in params
    var layout = this.param('layout');  // 'cartesian' | 'radial' | 'cladogram' | ???

    // NOTE that width and height refer to the final display, so these might
    // map to X or Y coordinates depending on orientation
    var width = this.param('width');
    var height = this.param('height');
    var radius = this.param('radius');  // for radial layout
    var radialArc = this.param('radialArc');  // angles of arc (radial layout only)
    var radialSweep = this.param('radialSweep');  // 'CLOCKWISE' or 'COUNTERCLOCKWISE'
    var branchStyle = this.param('branchStyle');
        // 'rightAngleDiagonal', 'radialRightAngleDiagonal', or a standard
        // D3 diagonal; by default, this will be based on the chosen layout
    var branchLengths = this.param('branchLengths');
    var tipsAlignment = this.param('tipsAlignment');
        // disregard for radial layouts?
    var orientation; // this.param('orientation');
        // degrees of rotation from default (0, -90, 90, 180)
        // NOTE that this is not set directly (from vega spec) but from within
    var descentAxis; // this.param('descentAxis');
        // needed to render paths correctly
        // TODO: add more from options below
    var nodeLabelSource = this.param('nodeLabelSource');  // 'ORIGINAL' or 'MAPPED'
        // choose preferred source for labels; fall back as needed and use marker classes
        // to distinguish these in display
    var showFallbackLabels = this.param('showFallbackLabels');  // boolean

    /* apply some internal constraints (formerly in param setters) */

    if (layout === 'radial') {
      // N.B. radial layout needs fixed (-90) orientation
      orientation = -90;
      descentAxis = 'x';
    } else {
      switch(tipsAlignment) {
        case 'TOP':
          orientation = 180;
          descentAxis = 'y';
          break;
        case 'RIGHT':
          orientation = -90;
          descentAxis = 'x';
          break;
        case 'BOTTOM':
          orientation = 0;
          descentAxis = 'y';
          break;
        case 'LEFT':
          orientation = 90;
          descentAxis = 'x';
          break;
      }
    }

    function phylogram(data) {
      // Expecting incoming data in the 'phylotree' format described here:
      //  https://github.com/OpenTreeOfLife/tree-illustrator/wiki/Building-on-D3-and-Vega

      //console.log('STARTING phylogram transform...');

      // scale all coordinates as directed
      if ((width !== 1.0) || (height !== 1.0)) {
          data.phyloNodes.map(scalePoint);
      }

      if (orientation !== 0) {
          // rotate all nodes by n degrees
          data.phyloNodes.map(rotatePointByOrientation);
      }

      // apply the chosen layout, in a 1x1 "virtual space"..?
      var layoutGenerator;
      switch(layout) {
          case 'radial':
              layoutGenerator = radialLayout;
              break;
          case 'cladogram':
              layoutGenerator = cladogramLayout;
              break;
          case 'cartesian':
          default:
              layoutGenerator = cartesianLayout;
      }
      layoutGenerator(data);

      // set (or revise) paths for all links
      var pathGenerator;
      switch(branchStyle) {
        case '':
            // if none specified, match the layout
            switch(layout) {
                case 'radial':
                    pathGenerator = radialRightAngleDiagonal();
                    break;
                case 'cladogram':
                    pathGenerator = straightLineDiagonal();
                    break;
                case 'cartesian':
                    pathGenerator = rightAngleDiagonal();
                    break;
                default:
                    // allow for moretraditional paths
                    pathGenerator = d3.svg[branchStyle]();
            }
            break;
        case 'straightLineDiagonal':
            pathGenerator = straightLineDiagonal();
            break;
        case 'radialRightAngleDiagonal':
            pathGenerator = radialRightAngleDiagonal();
            break;
        case 'rightAngleDiagonal':
            pathGenerator = rightAngleDiagonal();
            break;
        case 'diagonal':
            // intercept and switch its x/y bias
            if (descentAxis === 'x') {
                pathGenerator = function(d) {
                    // copied from vg.data.link > diagonalX
                    var s = d.source,
                        t = d.target,
                        m = (s.x + t.x) / 2;
                    return "M" + s.x + "," + s.y
                         + "C" + m   + "," + s.y
                         + " " + m   + "," + t.y
                         + " " + t.x + "," + t.y;
                }
            } else {
                pathGenerator = function(d) {
                    // copied from vg.data.link > diagonalY
                    var s = d.source,
                        t = d.target,
                        m = (s.y + t.y) / 2;
                    return "M" + s.x + "," + s.y
                         + "C" + s.x + "," + m
                         + " " + t.x + "," + m
                         + " " + t.x + "," + t.y;
                }
            }
            break;
        case 'radial':
            // intercept and switch its x/y bias
            pathGenerator = d3.svg.diagonal.radial();
                //.projection(function (d) { return [d.y, d.x]; });
            break;
        default:
            pathGenerator = d3.svg[branchStyle]();
            break;
      }

      data.phyloEdges.forEach(function(d, i) {
        d.path = pathGenerator(d);
      });

      // copy layout properties to the phylotree, for possible use downstream
      data.layout = layout;
      data.tipsAlignment = tipsAlignment;
      data.descentAxis = descentAxis;  // implicit in tipsAlignment?
      data.orientation = orientation;  // implicit in tipsAlignment?
      data.width = width;
      data.height = height;
      data.radius = radius;
      data.branchStyle = branchStyle;
      data.branchLengths = branchLengths;
      data.nodeLabelSource = nodeLabelSource;
      data.showFallbackLabels = showFallbackLabels;

      return data;
    }
      
    var displacePoint = function(point, delta) {
        // where 'delta' is an object with x and y properties
        point.x += delta.x;
        point.y += delta.y;
        return point;
    }

    // Return width *or* height, as appropriate for the current orientation
    var getOuterDimensionForX = function() {
        switch(orientation) {
            case 0:
            case 180:
            case -180:
                return width;

            case 90:
            case -90:
            case 270:
            case -270:
                return height;
        }
        console.error("getOuterDimensionForX(): Unexpected value for orientation: '"+ orientation +"'");
    }
    var getOuterDimensionForY = function() {
        switch(orientation) {
            case 0:
            case 180:
            case -180:
                return height;
            case 90:
            case -90:
            case 270:
            case -270:
                return width;
        }
        console.error("getOuterDimensionForY(): Unexpected value for orientation: '"+ orientation +"'");
    }

    var scalePoint = function(point) {
        // where point is any object having x and y properties
        // NOTE that we're scaling up from fractional values (0.0 - 1.0), so
        // the nominal width+height are also our scaling multipliers
        point.x *= getOuterDimensionForX();
        if (layout === 'radial') {
            point.y *= radius;
        } else {
            point.y *= getOuterDimensionForY();
        }
        // scale cartesian_x and y, if stored
        if ('cartesian_x' in point) {
            point.cartesian_x *= getOuterDimensionForX();
            point.cartesian_y *= getOuterDimensionForY();
        }
        return point;
    }

    var rotatePointByOrientation = function(point) {
        // use the vega input 'orientation' value to spin the tree
        return rotatePoint(point, orientation);
    }
    var rotatePointByY = function(point) {
        // Y coordinate should be between 0.0 and 1.0
        var yAngle = 360.0 * point.x;
        return rotatePoint(point, yAngle);
    }

    var rotatePoint = function(point, angle, pivot) {
        // where point is any object having x and y properties, and 'pivot'
        // is an optional second point
        var cos = Math.cos,
            sin = Math.sin,
            angle = degreesToRadians(angle || orientation), // convert to radians
            // default midpoint is origin (0,0)
            xm = (pivot && 'x' in pivot) ? pivot.x : 0,
            ym = (pivot && 'y' in pivot) ? pivot.y : 0,
            x = point.x,    // capture old x and y for this point
            y = point.y;

        // subtract midpoints, rotate from origin, then restore them
        point.x = (x - xm) * cos(angle) - (y - ym) * sin(angle) + xm;
        point.y = (x - xm) * sin(angle) + (y - ym) * cos(angle) + ym;
        if ('cartesian_x' in point) {
            cx = point.cartesian_x,    // capture old coords
            cy = point.cartesian_y;
            point.cartesian_x = (cx - xm) * cos(angle) - (cy - ym) * sin(angle) + xm;
            point.cartesian_y = (cx - xm) * sin(angle) + (cy - ym) * cos(angle) + ym;
        }
        return point;
    }

    function radiansToDegrees(r) {
        return (r * 180 / Math.PI);
    }
    function degreesToRadians(d) {
        return (d * Math.PI / 180);
    }
    function normalizeDegrees(d) {
        // convert to positive integer, e.g. -90 ==> 270
        return (d + (360 * 3)) % 360;
    }

  // Convert XY and radius to angle of a circle centered at 0,0
  var coordinateToAngle = function(coord, radius) {
    var wholeAngle = 2 * Math.PI,
        quarterAngle = wholeAngle / 4;
    
    var coordQuad = coord[0] >= 0 ?
            (coord[1] >= 0 ? 1 : 2) :
            (coord[1] >= 0 ? 4 : 3),
        coordBaseAngle = Math.abs(Math.asin(coord[1] / radius));
    
    // Since this is just based on the angle of the right triangle formed
    // by the coordinate and the origin, each quad will have different
    // offsets
    switch (coordQuad) {
      case 1:
        coordAngle = quarterAngle - coordBaseAngle;
        break;
      case 2:
        coordAngle = quarterAngle + coordBaseAngle;
        break;
      case 3:
        coordAngle = 2*quarterAngle + quarterAngle - coordBaseAngle;
        break
      case 4:
        coordAngle = 3*quarterAngle + coordBaseAngle;
    }
    return coordAngle;
  }

  /* path generators */

  var straightLineDiagonal = function(d) {
    // do-nothing projection (just isolates x and y)
    var projection = function(d) { return [d.x, d.y]; }
    
    var path = function(pathData) {
      return "M" + pathData[0] + ' ' + pathData[1];
    }
    
    function diagonal(d) {
      var pathData = [d.source, d.target];
      pathData = pathData.map(projection);
      return path(pathData);
    }
    
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    
    diagonal.path = function(x) {
      if (!arguments.length) return path;
      path = x;
      return diagonal;
    };
    
    return diagonal;
  }

  var rightAngleDiagonal = function(d) {
    // do-nothing projection (just isolates x and y)
    var projection = function(d) { return [d.x, d.y]; }
    
    var path = function(pathData) {
      return "M" + pathData[0] + ' ' + pathData[1] + " " + pathData[2];
    }
    
    function diagonal(d) {
      var midpointX = (d.source.x + d.target.x) / 2,
          midpointY = (d.source.y + d.target.y) / 2,
          pathData = (descentAxis === 'x') ?
                    [d.source, {x: d.source.x, y: d.target.y}, d.target] :
                    [d.source, {x: d.target.x, y: d.source.y}, d.target];
      pathData = pathData.map(projection);
      return path(pathData)
    }
    
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    
    diagonal.path = function(x) {
      if (!arguments.length) return path;
      path = x;
      return diagonal;
    };
    
    return diagonal;
  }
  
  var cartesianToPolarProjection = function(d, options) {
    options = options || {returnType: 'XY-ARRAY'}; // or 'POLAR-COORDS'
    // radius is simply the x coordinate
    var r = d.x;

    ///var a = (d.y - 0) / 180 * Math.PI;
    // a = angle? or something else?

    // Angle is influenced by the specified size, arc and sweep.
    // map Y coordinate to total specified width
    var totalArcDegrees;
    // force both angles to positive numbers
    var startAngle = (radialArc[0] + 360) % 360;
    var endAngle = (radialArc[1] + 360) % 360;
    // check for arcs that cross the zero line
    var shiftAngle;
    if (radialSweep === 'COUNTERCLOCKWISE') {
        if (endAngle > startAngle) {
            totalArcDegrees = endAngle - startAngle;
        } else {
            totalArcDegrees = (endAngle+360) - startAngle;
        }
        shiftAngle = startAngle;
    } else { // assumes 'CLOCKWISE')
        if (startAngle > endAngle) {
            totalArcDegrees = startAngle - endAngle;
        } else {
            totalArcDegrees = (startAngle+360) - endAngle;
        }
        shiftAngle = endAngle;
    }
    var proportionalY = ((d.y / getOuterDimensionForX()) * totalArcDegrees);
    // shift angle 90 degrees (from 0=down to 0=right)
    ///proportionalY -= 90;

    // OR rotate angle to the start or end angle?
    ///proportionalY = (proportionalY + shiftAngle + 360) % 360;

    var a = proportionalY / 180 * Math.PI;
    // remap angle to the specified arc, in the sweep direction

    // TODO: reckon angle based on height/width and sweep
    if (options.returnType === 'POLAR_COORDS') {
        // add radius and angle (theta) for label display in vega
        var labelAngle = normalizeDegrees(radiansToDegrees(a));
        var labelAlignment = 'left';
        // TODO: adjustable nudge separates label text from drawn node
        var nudgeRadius = 4; // px?
        // TODO: adjustable nudge (should vary with text size) shifts angle
        // from the label's baseline to the middle of its x-height
        var nudgeTheta = degreesToRadians(0.6);

        // test for upside-down labels (assuming 0 deg = due right)
        if ((labelAngle > 90) && (labelAngle < 270)) {
            // left-side labels should be flipped and aligned right
            labelAlignment = 'right';
            labelAngle = normalizeDegrees(labelAngle + 180);
            nudgeTheta =  -(nudgeTheta)
        }
        var nodeAndLabelProperties = {
            // X, Y coordinates for the node itself
            'x': r * Math.cos(a),
            'y': r * Math.sin(a),
            // additional properties for placing the label
            'radius': r + nudgeRadius,
            'theta': a - degreesToRadians(orientation) + nudgeTheta, // in radians!
            'angle': labelAngle,
            'align': labelAlignment
        };
        return nodeAndLabelProperties;
    } else {
        // return XY-COORDS by default
        return [r * Math.cos(a), r * Math.sin(a)];
    }
  }

  var radialRightAngleDiagonal = function(d) {
    // We need a standalone version of this, since we're mapping (preserved)
    // cartesian_x and cartesian_y to polar coordinates.

    // translate from cartesian to polar coordinates
    var projection = cartesianToPolarProjection;
            
    var path = function(pathData) {
        var src = pathData[0],
            mid = pathData[1],
            dst = pathData[2],
            radius = Math.sqrt(src[0]*src[0] + src[1]*src[1]),
            srcAngle = coordinateToAngle(src, radius),
            midAngle = coordinateToAngle(mid, radius),
            clockwise = Math.abs(midAngle - srcAngle) > Math.PI ? midAngle <= srcAngle : midAngle > srcAngle,
            rotation = 0,
            largeArc = 0,
            sweep = clockwise ? 0 : 1;
        var pathString = 'M' + src + ' ' +
          "A" + [radius,radius] + ' ' + rotation + ' ' + largeArc+','+sweep + ' ' + mid +
          'L' + dst;
        return pathString;
    }
            
    function diagonal(d) {
      var midpointX = (d.source.cartesian_x + d.target.cartesian_x) / 2,
          midpointY = (d.source.cartesian_y + d.target.cartesian_y) / 2,
          pathData = (descentAxis === 'x') ?
                    [
                        {x: d.source.cartesian_x, y: d.source.cartesian_y},
                        {x: d.source.cartesian_x, y: d.target.cartesian_y},
                        {x: d.target.cartesian_x, y: d.target.cartesian_y}
                    ] :
                    [
                        {x: d.source.cartesian_x, y: d.source.cartesian_y},
                        {x: d.target.cartesian_x, y: d.source.cartesian_y},
                        {x: d.target.cartesian_x, y: d.target.cartesian_y}
                    ];
      pathData = pathData.map(projection);
      return path(pathData)
    }
            
    return diagonal;
  }
  
    /* layout generators (position points in 1.0, 1.0 space) */
    var cartesianLayout = function(data) {
        // place all nodes for the radial layout (already done)

        // just nudge all points to put the root node at 0,0
        moveRootToOrigin(data);
    }

    var moveRootToOrigin = function (data) {
        // move all points to put the root node at origin (0.0)
        var rootNode = data.phyloNodes[0];  // I believe this is always true
        var nudgeRootToOrigin = {x: -(rootNode.x), y: -(rootNode.y)};
        var alignPointsToOrigin = function(point) {
            return displacePoint(point, nudgeRootToOrigin);
        };
        data.phyloNodes.map(alignPointsToOrigin);
    }

    var radialLayout = function(data) {
        // place all nodes for the radial layout
        // project points (nodes) to radiate out from center
        moveRootToOrigin(data);
        
        var preserveCartesianCoordinates = function(point) {
            point.cartesian_x = point.x;
            point.cartesian_y = point.y;
        }
        data.phyloNodes.map(preserveCartesianCoordinates);

        ///data.phyloNodes.map(rotatePointByY);
        data.phyloNodes.map(function(d) {
            pcoords = cartesianToPolarProjection(d, {returnType:'POLAR_COORDS'});
            d.radius  = pcoords.radius;
            d.theta  = pcoords.theta;
            d.angle  = pcoords.angle;
            d.align  = pcoords.align;
            d.x = pcoords.x;
            d.y = pcoords.y;
        });
    }
    var cladogramLayout = function(data) {
        // place all nodes for the "triangular" cladogram layout
        // TODO: support branch lengths?

        // project points (nodes) to radiate out from center
        moveRootToOrigin(data);
        
        /* Precalculate available leaf-node positions (based on number of
         * leaves, final width & height, and tip alignment). Then do
         * depth-first traversal from the root to assign the leaves to these
         * positions, placing all ancestors along the way.
         */
        var leafNodes = $.grep(data.phyloNodes, function(n) {
            return n['^ot:isLeaf'] === true;
        });

        var nLeaves = leafNodes.length;

        /* How far should we move on the descent axis for each step in depth?
         * NOTE that we'll normalize this to match the original width or height
         * later; for now, let's match the distance between leaf nodes.
         */
        var depthStep;

        var leafPositions = [ ];
        var startingLeafX, leafXstep,
            startingLeafY, leafYstep;
        switch(tipsAlignment) {
            case 'TOP':
                startingLeafX = -(width / 2.0);
                leafXstep = width / (nLeaves-1);
                startingLeafY = -height;
                leafYstep = 0;
                depthStep = -leafXstep;
                break;
            case 'RIGHT':
                startingLeafX = width;
                leafXstep = 0;
                startingLeafY = -(height / 2.0);
                leafYstep = height / (nLeaves-1);
                depthStep = leafYstep;
                break;
            case 'BOTTOM':
                startingLeafX = -(width / 2.0);
                leafXstep = width / (nLeaves-1);
                startingLeafY = height;
                leafYstep = 0;
                depthStep = leafXstep;
                break;
            case 'LEFT':
                startingLeafX = -width;
                leafXstep = 0;
                startingLeafY = -(height / 2.0);
                leafYstep = height / (nLeaves-1);
                depthStep = -leafYstep;
                break;
        }

        leafNodes.map(function(n, i) {
            leafPositions.push({
                'x': startingLeafX + (leafXstep * i),
                'y': startingLeafY + (leafYstep * i)
            });
        });

        var rootNode = data.phyloNodes[0];  // I believe this is always true
        var fullExtents = distributeChildrenAsCladogram(rootNode, leafPositions, depthStep);

        // realign root node to origin (it gets "pushed" far away by complex trees)
        moveRootToOrigin(data);

        // Scale the resulting layout to match the desired width (or height)
        switch(tipsAlignment) {
            case 'TOP':
            case 'BOTTOM':
                // width is already good; height should be squeezed (or stretched)
                var squeeze = height / (fullExtents.maxY - fullExtents.minY);
                var fitToHeight = function(point) {
                    point.y *= squeeze;
                    return point;
                }
                data.phyloNodes.map(fitToHeight);
                break;
            case 'RIGHT':
            case 'LEFT':
                // height is already good; width should be squeezed (or stretched)
                var squeeze = width / (fullExtents.maxX - fullExtents.minX);
                var fitToWidth = function(point) {
                    point.x *= squeeze;
                    return point;
                }
                data.phyloNodes.map(fitToWidth);
                break;
        }
    }
   
    var distributeChildrenAsCladogram = function(node, leafPositions, depthStep) {
        if (!node.children || node.children.length === 0) { return; }
        var extents = {
            minX:  Number.MAX_VALUE,
            maxX: -Number.MAX_VALUE,
            minY:  Number.MAX_VALUE,
            maxY: -Number.MAX_VALUE,
            descendantLeafCount: 0
        };
        node.children.map(function(n, i) {
            if (n['^ot:isLeaf'] === true) {
                // capture the next available leaf position
                var leafPos = leafPositions.shift();
                n.x = leafPos.x;
                n.y = leafPos.y;

                extents.minX = Math.min(n.x, extents.minX);
                extents.minY = Math.min(n.y, extents.minY);
                extents.maxX = Math.max(n.x, extents.maxX);
                extents.maxY = Math.max(n.y, extents.maxY);
                extents.descendantLeafCount += 1;
            } else {
                var childExtents = distributeChildrenAsCladogram(n, leafPositions, depthStep);
                extents.minX = Math.min(n.x, childExtents.minX, extents.minX);
                extents.minY = Math.min(n.y, childExtents.minY, extents.minY);
                extents.maxX = Math.max(n.x, childExtents.maxX, extents.maxX);
                extents.maxY = Math.max(n.y, childExtents.maxY, extents.maxY);
                extents.descendantLeafCount += childExtents.descendantLeafCount;
            }
        });

        /* Position this node based on its depth and children's positions.
         * Note that we need to place it on the descent axis so that it
         * maintains (if possible) the proper angled edges for the
         * cladogram layout. This sometimes means we need to force
         * longer edges between this node and its children.
         */
        switch(tipsAlignment) {
            case 'TOP':
                node.y = Math.max(
                    extents.maxY - depthStep,  // one step closer to root
                    extents.minY - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // x should be midpoint of all descendants' x
                node.x = (extents.maxX + extents.minX) / 2.0;
                break;
            case 'BOTTOM':
                node.y = Math.min(
                    extents.minY - depthStep,  // one step closer to root
                    extents.maxY - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // x should be midpoint of all descendants' x
                node.x = (extents.maxX + extents.minX) / 2.0;
                break;
            case 'RIGHT':
                node.x = Math.min(
                    extents.minX - depthStep,  // one step closer to root
                    extents.maxX - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // y should be midpoint of all descendants' y
                node.y = (extents.maxY + extents.minY) / 2.0;
                break;
            case 'LEFT':
                node.x = Math.max(
                    extents.maxX - depthStep,  // one step closer to root
                    extents.minX - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // y should be midpoint of all descendants' y
                node.y = (extents.maxY + extents.minY) / 2.0;
                break;
        }

        // update extents and return to parent
        extents.minX = Math.min(node.x, extents.minX);
        extents.minY = Math.min(node.y, extents.minY);
        extents.maxX = Math.max(node.x, extents.maxX);
        extents.maxY = Math.max(node.y, extents.maxY);

        return extents;
    }

    return phylogram(data);
}



/***** SCRAP AREA *****/

/*
  styleTreeNodes = function(vis) {

    vis.selectAll('g.node circle')
        .attr("r", 2.5);

    vis.selectAll('g.leaf.node circle')
        .attr("r", 4.5);
    
    vis.selectAll('g.root.node circle')
        .attr("r", 4.5);
  }
*/
  
  function scaleBranchLengths(nodes, w) {
    // Visit all nodes and adjust y pos width distance metric
    var visitPreOrder = function(root, callback) {
      callback(root)
      if (root.children) {
        for (var i = root.children.length - 1; i >= 0; i--){
          visitPreOrder(root.children[i], callback)
        };
      }
    }
    visitPreOrder(nodes[0], function(node) {
      // TODO: if we have mixed trees (some edges with lengths), consider 1
      // as default length versus 0?
      node.rootDist = (node.parent ? node.parent.rootDist : 0) + (node.length || 0)
    })
    var rootDists = nodes.map(function(n) { return n.rootDist; });
    var yscale = d3.scale.linear()
      .domain([0, d3.max(rootDists)])
      .range([0, w]);
    visitPreOrder(nodes[0], function(node) {
      node.y = yscale(node.rootDist)
    })
    return yscale
  }
  
  
  var buildCartesian = function(selector, nodes, options) {
    options = options || {}
    var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
        h = options.height || d3.select(selector).style('height') || d3.select(selector).attr('height'),
        w = parseInt(w),
        h = parseInt(h);
    var tree = options.tree || d3.layout.cluster()
      .size([h, w])
      .sort(function(node) { return node.children ? node.children.length : -1; })
    var diagonal = options.diagonal || rightAngleDiagonal();
    var vis = options.vis || d3.select(selector).append("svg:svg")
        .attr("width", w + 300)
        .attr("height", h + 30)
      .append("svg:g")
        .attr("transform", "translate(120, 20)");

    if (!options.vis) {
      // add any special filters (once only)
      d3.select(selector).selectAll('svg')
       .append('defs')
         .append("svg:filter")
           .attr("id", "highlight")
           .each(function(d) {
               // add multiple elements to this parent
               d3.select(this).append("svg:feFlood")
                 //.attr("flood-color", "#ffeedd")  // matches .help-box bg color!
                 .attr("flood-color", "#ffb265")    // darkened to allow tint
                 .attr("flood-opacity", "0.5")
                 .attr("result", "tint");
               d3.select(this).append("svg:feBlend")
                 .attr("mode", "multiply")
                 .attr("in", "SourceGraphic")
                 .attr("in2", "tint")
                 .attr("in3", "BackgroundImage");
               /* ALTERNATIVE SOLUTION, using feComposite
               d3.select(this).append("svg:feComposite")
                 .attr("in", "SourceGraphic");
                */
           });
    }

    var nodes = tree(nodes);
    
    if (options.skipBranchLengthScaling) {
      var yscale = d3.scale.linear()
        .domain([0, w])
        .range([0, w]);
    } else {
      var yscale = scaleBranchLengths(nodes, w)
    }
    
    if (!options.skipTicks) {
      var lines = vis.selectAll('line')
          .data(yscale.ticks(10));
      
      lines
        .enter().append('svg:line')
          .attr('y1', 0)
          .attr('y2', h)
          .attr('x1', yscale)
          .attr('x2', yscale)
          .attr("stroke", "#eee");

      lines
        .exit().remove();

      var text_rules = vis.selectAll("text.rule")
          .data(yscale.ticks(10));

      text_rules
        .enter().append("svg:text")
          .attr("class", "rule")
          .attr("x", yscale)
          .attr("y", 0)
          .attr("dy", -3)
          .attr("text-anchor", "middle")
          .attr('font-size', '8px')
          .attr('fill', '#ccc')
          .text(function(d) { return Math.round(d*100) / 100; });

      text_rules
        .exit().remove();
    }
        
    
    // DATA JOIN
    /* more interactions and styles on final marks
    var path_links = vis.selectAll("path.link")
        .data(tree.links(nodes), function(d) { return d.source['@id'] +'_'+ d.target['@id']; });

    var path_link_triggers = vis.selectAll("path.link-trigger")
        .data(tree.links(nodes), function(d) { return d.source['@id'] +'_'+ d.target['@id'] +'_trigger'; });

    var g_nodes = vis.selectAll("g.node")
        .data(nodes, function(d) { return d['@id']; });

    // UPDATE (only affects existing links)
    path_links
        .attr("stroke", "#aaa");
    
    path_link_triggers
        .attr("stroke", "orange");

    
    // ENTER (only affects new links; do one-time initialization here)
    path_links
      .enter()
          .append("svg:path")                   // styled (visible) edge
            .attr("class", "link")
            .attr("fill", "none")
            .attr("stroke", "#f33")
            .attr("stroke-width", "4px");
    
    path_link_triggers
      .enter()
          .append("svg:path")                   // "hit area" for clicking edge
            .attr("class", "link-trigger")
            .attr("fill", "none")
            .attr("stroke", "red")
            .attr("stroke-width", "4px")
            //.attr('pointer-events', 'all')

    g_nodes
      .enter()
        .append("svg:g")
          .append("svg:circle")
            .attr("r", 2.5)
            .attr('stroke', 'red')
            .attr('pointer-events', 'all')      // detect on invisible stuff
            .attr('stroke-opacity', '0.0')
            .attr('stroke-width', '8px');

    // ENTER + UPDATE (affects all new AND existing links)
    path_links
        .attr("d", diagonal)
        .attr("class", function(d) { return "link "+ (d.source.ingroup ? "ingroup" : "outgroup"); });
        
    path_link_triggers
        .attr("d", diagonal)
        .attr("class", function(d) { return "link-trigger "+ (d.source.ingroup ? "ingroup" : "outgroup"); });

    g_nodes
        .attr("class", function(n) {
          // N.B. These classes are overridden by study-editor.js!
          if (n.children) {
            if (n.depth == 0) {
              return "root node";
            } else {
              return "inner node";
            }
          } else {
            return "leaf node";
          }
        })
        .attr("id", function(d) { return ("nodebox-"+ d['@id']); })
        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

    // EXIT
    path_links
      .exit()
        .remove();

    path_link_triggers
      .exit()
        .remove();

    g_nodes
      .exit().remove();

    */
    // any dynamic readjustments of non-CSS attributes
    ///styleTreeNodes(vis);
    
    /* node labeling
    // TODO: why is this SUPER-SLOW with large trees? like MINUTES to run...
    // Is there a faster/cruder way to clear the decks?
    vis.selectAll('g.node text').remove();

    // provide an empty label as last resort, so we can see highlights
    var defaultNodeLabel = "unnamed";

    if (!options.skipLabels) {
      // refresh all labels based on tree position
      vis.selectAll('g.node')
        .append("svg:text")
          .attr('font-family', 'Helvetica Neue, Helvetica, sans-serif')
          .attr("dx", -6)
          .attr("dy", -6)
          .attr("text-anchor", 'end')
          .attr('font-size', '10px')
          .attr('fill', function(d) {
              switch(d.labelType) {
                  case ('mapped label'):
                      return '#000';
                  case ('node id'):
                      if (d.ambiguousLabel) {
                          return '#b94a48';  // show ambiguous labels, match red prompts
                      } else if (d.adjacentEdgeLabel) {
                          return '#888';
                      } else {
                          return '#888';
                      }
                  default:
                      return '#888';
              }
          })
          ///.text(function(d) { return d.length; });
          .attr('font-style', function(d) {
              return (d.labelType === 'mapped label' ? 'inherit' : 'italic');
          })
          .text(function(d) {
              // return (d.name + ' ('+d.length+')');
              var nodeLabel = '';
              if (d.labelType === 'node id') {
                  nodeLabel = '';  // hide these
              } else {
                  nodeLabel = d.name || defaultNodeLabel;
              }
              var supplementalLabel = d.ambiguousLabel || d.adjacentEdgeLabel;
              if (supplementalLabel) {
                  if (nodeLabel === '') {
                      nodeLabel = supplementalLabel;
                  } else {
                      nodeLabel = nodeLabel +" ["+ supplementalLabel +"]";
                  }
              }
              return nodeLabel;
          });

      vis.selectAll('g.root.node text')
          .attr("dx", -8)
          .attr("dy", 3);

      vis.selectAll('g.leaf.node text')
        .attr("dx", 8)
        .attr("dy", 3)
        .attr("text-anchor", "start");
    }
    
    */

    return {tree: tree, vis: vis}
  }
  
  var buildRadial = function(nodes, links, options) {
    options = options || {}
    /* set width, radius, space for edge labels
    var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
        r = w / 2,
        // NOTE the fudge factor here; longer labels will be clipped!
        labelWidth = options.skipLabels ? 10 : options.labelWidth || 120;
    */
    
    /* build SVG, set size and offet (center is 0,0)
    var vis = d3.select(selector).append("svg:svg")
        .attr("width", r * 2)
        .attr("height", r * 2)
      .append("svg:g")
        .attr("transform", "translate(" + r + "," + r + ")");
    */
        
    /* set space with x as polar coordinates (360 degrees), y = 1.0 */
    var tree = d3.layout.tree()  // TODO: use cluster here?
      .size([360, 500])   // WAS ([360, r - labelWidth])
      // sort populous to sparse branches
      .sort(function(node) { return node.children ? node.children.length : -1; })
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
    
    var phylogram = buildCartesian(selector, nodes, {
      vis: vis,
      tree: tree,
      skipBranchLengthScaling: true,
      skipTicks: true,
      skipLabels: options.skipLabels,
      diagonal: radialRightAngleDiagonal()
    })
    vis.selectAll('g.node')
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
    
    if (!options.skipLabels) {
      vis.selectAll('g.leaf.node text')
        .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
        .attr("dy", ".31em")
        .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
        .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
        .attr('font-family', 'Helvetica Neue, Helvetica, sans-serif')
        .attr('font-size', '10px')
        .attr('fill', 'black');

      vis.selectAll('g.inner.node text')
        .attr("dx", function(d) { return d.x < 180 ? -6 : 6; })
        .attr("text-anchor", function(d) { return d.x < 180 ? "end" : "start"; })
        .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; });
    }
    
    return {tree: tree, vis: vis}
  }

module.exports = Phylogram;

Phylogram.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Phylogram transform",
  "description": "Projects hierarchical data (presumably a tree) into one of several layouts "+
                 "and passes the results for downstream rendering.",
  "type": "object",
  "properties": {
    "type": {"enum": ["phylogram"]},
    "layout": {
      "description": "Should be 'radial', 'cladogram', or 'cartesian'.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "default": 'cartesian'
    },
    "width": {
      "description": "Width of overall phylogram, in chosen physical units", // TODO: CONFIRM
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 1.0
    },
    "height": {
      "description": "Height of overall phylogram, in chosen physical units", // TODO: CONFIRM
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 1.0
    },
    "radius": {
      "description": "Radius (from center to edge) of a radial layout, in arbitrary units.",
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 0.5
    },
    "radialArc": {
      "description": "Angles of arc [start, end] for a circular layout.",
      "oneOf": [
          {
            "type": "array",
            "items": {"type": "number"},
            "minItems": 2,
            "maxItems": 2
          },
          {"$ref": "#/refs/signal"}
      ],
      "default": [0, 360]
    },
    "radialSweep": {
      "description": "Direction of arc, CLOCKWISE or COUNTERCLOCKWISE.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["CLOCKWISE", "COUNTERCLOCKWISE"],
      "default": 'CLOCKWISE'
    },
    "tipsAlignment": {
      "description": "Which edge will show the labeled tips.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["TOP", "RIGHT", "BOTTOM", "LEFT"],
      "default": 'right'
    },
    "branchStyle": {
      "description": "Override the layout's style (rarely used).",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["rightAngleDiagonal", "radialRightAngleDiagonal",
               "straightLineDiagonal", "diagonal", "radial"],
      "default": ''
    },
    "branchLengths": {
      "description": "Map a data field to branch lengths (NOT YET IMPLEMENTED).",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],  // is this type "field"?
      "default": ''
    },
    "nodeLabelSource": {
      "description": "Look for tip labels in a data field.",
      "oneOf": [{"type": "XXXXXXXXXXX"}, {"$ref": "#/refs/signal"}],
      "enum": ["XXXXXXXXXXX", "XXXXXXXXXXX"],
      "default": ''
    },
    "showFallbackLabels": {
      "description": "If primary label is not found, show alternatives.",
      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
      "default": true
    },
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type"]  // TODO: review params!
};

},{"vega":89,"vega-logging":49,"vega/src/transforms/Transform":140}],151:[function(require,module,exports){
/* 
 * A simple transform to grab the named property from a JS object (not an
 * array). This makes it easier to deal with hierarchical data with 
 * multiple "inner" datasets (eg, nodes and edges) and complex upstream
 * transforms.
 *
 * EXAMPLE:
 *    "from": {
 *      "data": "phyloTree", 
 *      "transform": [
 *          {"type":"pluck", "field":"phyloNodes" }
 *      ] 
 *  },
 */
var vg  = require('vega'),
    log  = require('vega-logging'),
    assert = require('assert'),
    Transform = require('vega/src/transforms/Transform');

function Pluck(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      field: {type: 'field'}
  });
  // TODO: confirm that this is appropriate here
  return this.produces(true)
             .mutates(true);
}

var prototype = (Pluck.prototype = Object.create(Transform.prototype));
prototype.constructor = Pluck;

prototype.transform = function(input) {
  log.debug(input, ['plucking']);

  var g = this._graph,
      field = this.param('field');

  // For now, this transform ASSUMES just one incoming tuple, which will be
  // completely replaced by the plucked values.
  assert(input.add.length < 2, 
         "The pluck transform can only replace a single added datum.");
  var pluckedValues = field.accessor(input.add[0]); // returns plucked array
  // add _id properties? not clear if this is needed
  var nextAvailableID = 1000000;
  var assignUniqueID = function(obj) {
    if (!('_id' in obj)) {
      obj._id = ('_'+ ++nextAvailableID);
    }
  }
  pluckedValues.forEach(assignUniqueID);
  input.add = pluckedValues;    // replace the incoming tuple

  if (this.reevaluate(input)) {
    // Actually, we can also replace just one modified tuple, if found
    assert(input.mod.length < 2, 
           "The pluck transform can only replace a single modified datum.");
    pluckedValues = field.accessor(input.mod[0]);
    pluckedValues.forEach(assignUniqueID);
    input.mod = pluckedValues;
  }
  // return the modified ChangeSet
  return input;
};

module.exports = Pluck;

Pluck.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Pluck transform",
  "description": "Grabs a property (or deeper path) from a hierarchy.",
  "type": "object",
  "properties": {
    "type": {"enum": ["pluck"]},
    "field": {
      "description": "Which field of the data you want to select.",
      "oneOf": [{"type": "field"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    }
  },
  "additionalProperties": false,
  "required": ["type", "field"]
};

/*
vg.transforms.pluck = function() {

  var field = null;

  function pluck(data) {    
    var result = field(data);
    return result;
  }
  
  pluck.field = function(f) {
    field = vg.accessor(f);
    return pluck;
  };

  return pluck;
};
*/

},{"assert":1,"vega":89,"vega-logging":49,"vega/src/transforms/Transform":140}],152:[function(require,module,exports){
/* 
 * Store the incoming data (if it's not already found) in the specified object
 * using the specified key, then pass it along unchanged.
 *
 * This is a "do-nothing" data transform to allow caching of intermediate results
 * from within a Vega pipeline (a series of transforms). The intent is to
 * support a much faster pipeline for frequently modified visualizations, as
 * used in the Tree Illustrator project:
 *   https://github.com/OpenTreeOfLife/tree-illustrator
 * 
 * Note that this transform doesn't concern itself with the details of the caching 
 * mechanism; it's assumed to be an existing Javascript object (associative
 * array) that functions as a simple key/value store. Similarly, the host
 * application is responsible for defining idempotent keys for cached data.
 * 
 * Also, note that this doesn't *retrieve* cached data or speed things up on
 * its own! Instead, by feeding a cache it enables the host application to
 * construct a simpler pipeline by providing cached data instead of URLs,
 * omitting unneeded transforms, etc.
 */
var vg  = require('vega'),
    log  = require('vega-logging'),
    assert = require('assert'),
    dl = require('datalib'),
    Transform = require('vega/src/transforms/Transform');

function Stash(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      cachePath: {type: 'value'},
      key: {type: 'value'},
      flush: {type: 'value', default: false}
  });

  return this;
  // TODO: add calls to mutates(), router()?
}

var prototype = (Stash.prototype = Object.create(Transform.prototype));
prototype.constructor = Stash;

prototype.transform = function(input) {
  log.debug(input, ['stashing']);

  var cachePath = this.param('cachePath'),
      cache = eval(cachePath),
      key = this.param('key'),
      flush = this.param('flush');

  if (!cache || (typeof cache !== 'object')) {
    // if an invalid cache path is submitted, treat this as a no-op
    console.warn('stash transform: no cache found in eval('+ cachePath +')! skipping this data');
    return input;
  }

  // For now, this transform ASSUMES just one incoming tuple, which will be
  // completely replaced by the plucked values.
  assert((input.add.length < 2 &&
          input.mod.length === 0 &&
          input.rem.length === 0),
         "The stash transform only stores a single added datum.");

  /* Stash a single incoming datum. Note that we actually store a *copy* of
   * the data, since Vega always clones data in a spec (see comment above).
   */
  if (flush || !(key in cache)) {
    // be sure to cache the "raw" data as returned from source
    cache[ key ] = dl.duplicate(input.add[0]);
    // N.B. dl.duplicate cleans up any weird methods and circular references
  }

/* OR should we stash all data piecemeal, based on state??
  // move new (and possibly changed) data to the cache
  function set(x) {
    //move one datum (tuple?) into the cache
    console.log("setting '"+ x +"'...");
    //Tuple.set(x, field, expr(x, null, signals));
  }
  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
  }
*/
  return input;
};

module.exports = Stash;

Stash.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Stash transform",
  "description": "Stores the incoming data (if it's not already found) in the" +
    " specified object using the specified key, then passes it along unchanged.",
  "type": "object",
  "properties": {
    "type": {"enum": ["stash"]},
    "cachePath": {
      "description": "A field pointing to the cache object",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    },
    "key": {
      "description": "A unique key for this data in the stash",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
    },
    "flush": {
      "description": "If true, will replace any existing stashed data.",
      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
      "default": false
    }
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type", "key", "cachePath"]
};

},{"assert":1,"datalib":24,"vega":89,"vega-logging":49,"vega/src/transforms/Transform":140}]},{},[147])(147)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvZDMtZHN2L2J1aWxkL2Rzdi5qcyIsIm5vZGVfbW9kdWxlcy9kMy1mb3JtYXQvYnVpbGQvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L2J1aWxkL3RpbWVGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS9idWlsZC90aW1lLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZ2VuZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvZHN2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHJlZWpzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2xvYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3JlYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3JlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3R5cGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvcHJpbnQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0NoYW5nZVNldC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9Db2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvRGF0YVNvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9EZXBlbmRlbmNpZXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvR3JhcGguanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvSGVhcC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL1NpZ25hbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9UdXBsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWV4cHJlc3Npb24vc3JjL2NvZGVnZW4uanMiLCJub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWV4cHJlc3Npb24vc3JjL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxvZ2dpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3BhdGgvYXJjLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3BhdGgvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9wYXRoL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9IYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL1JlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9DYW52YXNIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL2FyYy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvYXJlYS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvZ3JvdXAuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL2ltYWdlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvbGluZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvcmVjdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvcnVsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3Mvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy90ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL3N2Zy9TVkdIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL3N2Zy9TVkdSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9zdmcvU1ZHU3RyaW5nUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvc3ZnL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL3N2Zy9tYXJrcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvQm91bmRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9Cb3VuZHNDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9HcmFkaWVudC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvSW1hZ2VMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL0l0ZW0uanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL2JvdW5kLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9jYW52YXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvc2NlbmUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL3N2Zy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL2NvcmUvSGVhZGxlc3NWaWV3LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL2NvcmUvTW9kZWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvY29yZS9WaWV3LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL2NvcmUvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL2NvcmUvc2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL2F4ZXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvYmFja2dyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9leHByLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL2xlZ2VuZHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9tYXJrcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9tb2RpZnkuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9wcmVkaWNhdGVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL3Byb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2Uvc2lnbmFscy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9zcGVjLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL3N0cmVhbXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvdHJhbnNmb3Jtcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS9Cb3VuZGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3NjZW5lL0J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvRW5jb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS9Hcm91cEJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvU2NhbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvVHJhbnNpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS9heGlzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3NjZW5lL2xlZ2VuZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS92aXNpdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvQmluLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvQ291bnRQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0ZhY2V0b3IuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9GaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9Gb2xkLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvRm9yY2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9Gb3JtdWxhLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvR2VvLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvR2VvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvTG9va3VwLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvUGllLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1Zvcm9ub2kuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9Xb3JkY2xvdWQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9pbmRleC5qcyIsInNyYy9UcmVlSWxsdXN0cmF0b3IuanMiLCJzcmMvanF1ZXJ5LTEuOC4zLmpzIiwic3JjL3N0eWxpc3QuanMiLCJzcmMvdGktdXRpbHMuanMiLCJzcmMvdmcuZGF0YS5uZXhzb24uanMiLCJzcmMvdmcuZGF0YS5waHlsb2dyYW0uanMiLCJzcmMvdmcuZGF0YS5wbHVjay5qcyIsInNyYy92Zy5kYXRhLnN0YXNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3R4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3poREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1bURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6dUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyB3aGVuIHVzZWQgaW4gbm9kZSwgdGhpcyB3aWxsIGFjdHVhbGx5IGxvYWQgdGhlIHV0aWwgbW9kdWxlIHdlIGRlcGVuZCBvblxuLy8gdmVyc3VzIGxvYWRpbmcgdGhlIGJ1aWx0aW4gdXRpbCBtb2R1bGUgYXMgaGFwcGVucyBvdGhlcndpc2Vcbi8vIHRoaXMgaXMgYSBidWcgaW4gbm9kZSBtb2R1bGUgbG9hZGluZyBhcyBmYXIgYXMgSSBhbSBjb25jZXJuZWRcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcblxudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBzdGFja1N0YXJ0RnVuY3Rpb24ubmFtZTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cbiAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpICYmICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB1dGlsLmlzUmVnRXhwKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodXRpbC5pc1N0cmluZyhzKSkge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuYWN0dWFsLCByZXBsYWNlciksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmV4cGVjdGVkLCByZXBsYWNlciksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYWN0dWFsKSAmJiB1dGlsLmlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9IGV4cGVjdGVkLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3R1YWxbaV0gIT09IGV4cGVjdGVkW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCF1dGlsLmlzT2JqZWN0KGFjdHVhbCkgJiYgIXV0aWwuaXNPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGEpIHx8IHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpLFxuICAgICAgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodXRpbC5pc1N0cmluZyhleHBlY3RlZCkpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYWN0dWFsID0gZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKCFzaG91bGRUaHJvdyAmJiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLG51bGwsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmRzdiA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZHN2ID0gZnVuY3Rpb24oZGVsaW1pdGVyKSB7XG4gICAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcbl1cIiksXG4gICAgICAgIGRlbGltaXRlckNvZGUgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICAgIHZhciBvO1xuICAgICAgcmV0dXJuIHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgaWYgKG8pIHJldHVybiBvKHJvdywgaSAtIDEpO1xuICAgICAgICB2YXIgYSA9IG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgcm93Lm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgICBvID0gZiA/IGZ1bmN0aW9uKHJvdywgaSkgeyByZXR1cm4gZihhKHJvdyksIGkpOyB9IDogYTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgICB2YXIgRU9MID0ge30sIC8vIHNlbnRpbmVsIHZhbHVlIGZvciBlbmQtb2YtbGluZVxuICAgICAgICAgIEVPRiA9IHt9LCAvLyBzZW50aW5lbCB2YWx1ZSBmb3IgZW5kLW9mLWZpbGVcbiAgICAgICAgICByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICAgIG4gPSAwLCAvLyB0aGUgY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICAgIHQsIC8vIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgZW9sOyAvLyBpcyB0aGUgY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgICBpZiAoSSA+PSBOKSByZXR1cm4gRU9GOyAvLyBzcGVjaWFsIGNhc2U6IGVuZCBvZiBmaWxlXG4gICAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MOyAvLyBzcGVjaWFsIGNhc2U6IGVuZCBvZiBsaW5lXG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBxdW90ZXNcbiAgICAgICAgdmFyIGogPSBJO1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSAzNCkge1xuICAgICAgICAgIHZhciBpID0gajtcbiAgICAgICAgICB3aGlsZSAoaSsrIDwgTikge1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMSkgIT09IDM0KSBicmVhaztcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBJID0gaSArIDI7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDIpID09PSAxMCkgKytJO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1vbiBjYXNlOiBmaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmVcbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSwgayA9IDE7XG4gICAgICAgICAgaWYgKGMgPT09IDEwKSBlb2wgPSB0cnVlOyAvLyBcXG5cbiAgICAgICAgICBlbHNlIGlmIChjID09PSAxMykgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSAxMCkgKytJLCArK2s7IH0gLy8gXFxyfFxcclxcblxuICAgICAgICAgIGVsc2UgaWYgKGMgIT09IGRlbGltaXRlckNvZGUpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIEkgLSBrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogbGFzdCB0b2tlbiBiZWZvcmUgRU9GXG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGopO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSB7XG4gICAgICAgICAgYS5wdXNoKHQpO1xuICAgICAgICAgIHQgPSB0b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmICYmIChhID0gZihhLCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgcm93cy5wdXNoKGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm93cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQocm93cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93c1swXSkpIHJldHVybiBmb3JtYXRSb3dzKHJvd3MpOyAvLyBkZXByZWNhdGVkOyB1c2UgZm9ybWF0Um93c1xuICAgICAgdmFyIGZpZWxkU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgZmllbGRzID0gW107XG5cbiAgICAgIC8vIENvbXB1dGUgdW5pcXVlIGZpZWxkcyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGZvciAodmFyIGZpZWxkIGluIHJvdykge1xuICAgICAgICAgIGlmICghKChmaWVsZCArPSBcIlwiKSBpbiBmaWVsZFNldCkpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkU2V0W2ZpZWxkXSA9IGZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gW2ZpZWxkcy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbZmllbGRdKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgICAgcmV0dXJuIHJlRm9ybWF0LnRlc3QodGV4dCkgPyBcIlxcXCJcIiArIHRleHQucmVwbGFjZSgvXFxcIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCIgOiB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJzZTogcGFyc2UsXG4gICAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgZm9ybWF0Um93czogZm9ybWF0Um93c1xuICAgIH07XG4gIH1cblxuICBleHBvcnRzLmNzdiA9IGRzdihcIixcIik7XG4gIGV4cG9ydHMudHN2ID0gZHN2KFwiXFx0XCIpO1xuXG4gIGV4cG9ydHMuZHN2ID0gZHN2O1xuXG59KSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwuZm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB6aENuID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiwqVcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgcnVSdSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNGA0YPQsS5cIl1cbiAgfTtcblxuICB2YXIgcHRCciA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlIkXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIHBsUGwgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJ6xYJcIl1cbiAgfTtcblxuICB2YXIgbmxObCA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCrFxceGEwXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIG1rTWsgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNC00LXQvS5cIl1cbiAgfTtcblxuICB2YXIgamFKcCA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIuWGhlwiXVxuICB9O1xuXG4gIHZhciBpdEl0ID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wi4oKsXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGhlSWwgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqpcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZnJGciA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGZyQ2EgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiJFwiXVxuICB9O1xuXG4gIHZhciBmaUZpID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGVzRXMgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBlblVzID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBlbkdiID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiwqNcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZW5DYSA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZGVEZSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGNhRXMgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG5cbiAgLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuICAvLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbiAgLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWwoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG4gIGZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICAgIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICAgIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gICAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgICByZXR1cm4gW1xuICAgICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAgICt4LnNsaWNlKGkgKyAxKVxuICAgIF07XG4gIH1cblxuICBmdW5jdGlvbiBleHBvbmVudCh4KSB7XG4gICAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG4gIH1cblxuICB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4QXV0byh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICAgIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIHAgKyBpIC0gMSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV07XG4gICAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHQoeCwgcCkge1xuICAgIHggPSB4LnRvUHJlY2lzaW9uKHApO1xuXG4gICAgb3V0OiBmb3IgKHZhciBuID0geC5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgICAgc3dpdGNoICh4W2ldKSB7XG4gICAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlXCI6IGJyZWFrIG91dDtcbiAgICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaTAgPiAwID8geC5zbGljZSgwLCBpMCkgKyB4LnNsaWNlKGkxICsgMSkgOiB4O1xuICB9XG5cbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgIFwiXCI6IGZvcm1hdERlZmF1bHQsXG4gICAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICAgIFwiYlwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpOyB9LFxuICAgIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gICAgXCJlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTsgfSxcbiAgICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICAgIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICAgIFwib1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpOyB9LFxuICAgIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICAgIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICAgIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICAgIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxuICB9O1xuXG5cbiAgLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxuICB2YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcblxuICAgIHZhciBtYXRjaCxcbiAgICAgICAgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLFxuICAgICAgICBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLFxuICAgICAgICBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsXG4gICAgICAgIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsXG4gICAgICAgIHplcm8gPSAhIW1hdGNoWzVdLFxuICAgICAgICB3aWR0aCA9IG1hdGNoWzZdICYmICttYXRjaFs2XSxcbiAgICAgICAgY29tbWEgPSAhIW1hdGNoWzddLFxuICAgICAgICBwcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgICAgIHR5cGUgPSBtYXRjaFs5XSB8fCBcIlwiO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gTWFwIGludmFsaWQgdHlwZXMgdG8gdGhlIGRlZmF1bHQgZm9ybWF0LlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgdHlwZSA9IFwiXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuc2lnbiA9IHNpZ247XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy56ZXJvID0gemVybztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb21tYSA9IGNvbW1hO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgICArIHRoaXMuYWxpZ25cbiAgICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMucHJlY2lzaW9uID09IG51bGwgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgICArIHRoaXMudHlwZTtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXRHcm91cChncm91cGluZywgdGhvdXNhbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgdCA9IFtdLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyAmJiBsb2NhbGUudGhvdXNhbmRzID8gZm9ybWF0R3JvdXAobG9jYWxlLmdyb3VwaW5nLCBsb2NhbGUudGhvdXNhbmRzKSA6IGlkZW50aXR5LFxuICAgICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcbiAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IFwiJVwiIDogXCJcIjtcblxuICAgICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgICAgbWF5YmVTdWZmaXggPSAhdHlwZSB8fCAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gKHR5cGUgPyA2IDogMTIpXG4gICAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZSwgYW5kIGNvbXB1dGUgdGhlIHByZWZpeC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gKHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwKSAmJiAodmFsdWUgKj0gLTEsIHRydWUpO1xuXG4gICAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICAgIHZhbHVlID0gZm9ybWF0VHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogXCItXCIpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoLCBjO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nO1xuICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgICAgdmFyIGYgPSBmb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25Sb3VuZChzdGVwLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQoTWF0aC5hYnMobWF4KSkgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgdmFyIGxvY2FsZURlZmluaXRpb25zID0ge1xuICAgIFwiY2EtRVNcIjogY2FFcyxcbiAgICBcImRlLURFXCI6IGRlRGUsXG4gICAgXCJlbi1DQVwiOiBlbkNhLFxuICAgIFwiZW4tR0JcIjogZW5HYixcbiAgICBcImVuLVVTXCI6IGVuVXMsXG4gICAgXCJlcy1FU1wiOiBlc0VzLFxuICAgIFwiZmktRklcIjogZmlGaSxcbiAgICBcImZyLUNBXCI6IGZyQ2EsXG4gICAgXCJmci1GUlwiOiBmckZyLFxuICAgIFwiaGUtSUxcIjogaGVJbCxcbiAgICBcIml0LUlUXCI6IGl0SXQsXG4gICAgXCJqYS1KUFwiOiBqYUpwLFxuICAgIFwibWstTUtcIjogbWtNayxcbiAgICBcIm5sLU5MXCI6IG5sTmwsXG4gICAgXCJwbC1QTFwiOiBwbFBsLFxuICAgIFwicHQtQlJcIjogcHRCcixcbiAgICBcInJ1LVJVXCI6IHJ1UnUsXG4gICAgXCJ6aC1DTlwiOiB6aENuXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGUoZW5Vcyk7XG4gIGV4cG9ydHMuZm9ybWF0ID0gZGVmYXVsdExvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0UHJlZml4ID0gZGVmYXVsdExvY2FsZS5mb3JtYXRQcmVmaXg7XG5cbiAgZnVuY3Rpb24gbG9jYWxlRm9ybWF0KGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghbG9jYWxlRGVmaW5pdGlvbnMuaGFzT3duUHJvcGVydHkoZGVmaW5pdGlvbikpIHJldHVybiBudWxsO1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlKGRlZmluaXRpb24pO1xuICB9XG4gIDtcblxuICBleHBvcnRzLmxvY2FsZUZvcm1hdCA9IGxvY2FsZUZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG4gIGV4cG9ydHMucHJlY2lzaW9uRml4ZWQgPSBwcmVjaXNpb25GaXhlZDtcbiAgZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG4gIGV4cG9ydHMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLnRpbWVGb3JtYXQgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHpoQ24gPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVZLyUtbS8lLWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wi5LiK5Y2IXCIsIFwi5LiL5Y2IXCJdLFxuICAgIGRheXM6IFtcIuaYn+acn+aXpVwiLCBcIuaYn+acn+S4gFwiLCBcIuaYn+acn+S6jFwiLCBcIuaYn+acn+S4iVwiLCBcIuaYn+acn+Wbm1wiLCBcIuaYn+acn+S6lFwiLCBcIuaYn+acn+WFrVwiXSxcbiAgICBzaG9ydERheXM6IFtcIuaYn+acn+aXpVwiLCBcIuaYn+acn+S4gFwiLCBcIuaYn+acn+S6jFwiLCBcIuaYn+acn+S4iVwiLCBcIuaYn+acn+Wbm1wiLCBcIuaYn+acn+S6lFwiLCBcIuaYn+acn+WFrVwiXSxcbiAgICBtb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi5LiA5pyIXCIsIFwi5LqM5pyIXCIsIFwi5LiJ5pyIXCIsIFwi5Zub5pyIXCIsIFwi5LqU5pyIXCIsIFwi5YWt5pyIXCIsIFwi5LiD5pyIXCIsIFwi5YWr5pyIXCIsIFwi5Lmd5pyIXCIsIFwi5Y2B5pyIXCIsIFwi5Y2B5LiA5pyIXCIsIFwi5Y2B5LqM5pyIXCJdXG4gIH07XG5cbiAgdmFyIHJ1UnUgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlICVCICVZINCzLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLQstC+0YHQutGA0LXRgdC10L3RjNC1XCIsIFwi0L/QvtC90LXQtNC10LvRjNC90LjQulwiLCBcItCy0YLQvtGA0L3QuNC6XCIsIFwi0YHRgNC10LTQsFwiLCBcItGH0LXRgtCy0LXRgNCzXCIsIFwi0L/Rj9GC0L3QuNGG0LBcIiwgXCLRgdGD0LHQsdC+0YLQsFwiXSxcbiAgICBzaG9ydERheXM6IFtcItCy0YFcIiwgXCLQv9C9XCIsIFwi0LLRglwiLCBcItGB0YBcIiwgXCLRh9GCXCIsIFwi0L/RglwiLCBcItGB0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRj9C90LLQsNGA0Y9cIiwgXCLRhNC10LLRgNCw0LvRj1wiLCBcItC80LDRgNGC0LBcIiwgXCLQsNC/0YDQtdC70Y9cIiwgXCLQvNCw0Y9cIiwgXCLQuNGO0L3Rj1wiLCBcItC40Y7Qu9GPXCIsIFwi0LDQstCz0YPRgdGC0LBcIiwgXCLRgdC10L3RgtGP0LHRgNGPXCIsIFwi0L7QutGC0Y/QsdGA0Y9cIiwgXCLQvdC+0Y/QsdGA0Y9cIiwgXCLQtNC10LrQsNCx0YDRj1wiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0Y/QvdCyXCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNC5XCIsIFwi0LjRjtC9XCIsIFwi0LjRjtC7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC9XCIsIFwi0L7QutGCXCIsIFwi0L3QvtGPXCIsIFwi0LTQtdC6XCJdXG4gIH07XG5cbiAgdmFyIHB0QnIgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJEb21pbmdvXCIsIFwiU2VndW5kYVwiLCBcIlRlcsOnYVwiLCBcIlF1YXJ0YVwiLCBcIlF1aW50YVwiLCBcIlNleHRhXCIsIFwiU8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIlNlZ1wiLCBcIlRlclwiLCBcIlF1YVwiLCBcIlF1aVwiLCBcIlNleFwiLCBcIlPDoWJcIl0sXG4gICAgbW9udGhzOiBbXCJKYW5laXJvXCIsIFwiRmV2ZXJlaXJvXCIsIFwiTWFyw6dvXCIsIFwiQWJyaWxcIiwgXCJNYWlvXCIsIFwiSnVuaG9cIiwgXCJKdWxob1wiLCBcIkFnb3N0b1wiLCBcIlNldGVtYnJvXCIsIFwiT3V0dWJyb1wiLCBcIk5vdmVtYnJvXCIsIFwiRGV6ZW1icm9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZldlwiLCBcIk1hclwiLCBcIkFiclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk91dFwiLCBcIk5vdlwiLCBcIkRlelwiXVxuICB9O1xuXG4gIHZhciBwbFBsID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcIk5pZWR6aWVsYVwiLCBcIlBvbmllZHppYcWCZWtcIiwgXCJXdG9yZWtcIiwgXCLFmnJvZGFcIiwgXCJDendhcnRla1wiLCBcIlBpxIV0ZWtcIiwgXCJTb2JvdGFcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJOaWVkei5cIiwgXCJQb24uXCIsIFwiV3QuXCIsIFwixZpyLlwiLCBcIkN6dy5cIiwgXCJQdC5cIiwgXCJTb2IuXCJdLFxuICAgIG1vbnRoczogW1wiU3R5Y3plxYRcIiwgXCJMdXR5XCIsIFwiTWFyemVjXCIsIFwiS3dpZWNpZcWEXCIsIFwiTWFqXCIsIFwiQ3plcndpZWNcIiwgXCJMaXBpZWNcIiwgXCJTaWVycGllxYRcIiwgXCJXcnplc2llxYRcIiwgXCJQYcW6ZHppZXJuaWtcIiwgXCJMaXN0b3BhZFwiLCBcIkdydWR6aWXFhFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiU3R5Y3ouXCIsIFwiTHV0eVwiLCBcIk1hcnouXCIsIFwiS3dpZS5cIiwgXCJNYWpcIiwgXCJDemVydy5cIiwgXCJMaXBjLlwiLCBcIlNpZXJwLlwiLCBcIldyei5cIiwgXCJQYcW6ZHouXCIsIFwiTGlzdG9wLlwiLCBcIkdydWR6LlwiXS8qIEluIFBvbGlzaCBsYW5ndWFnZSBhYmJyYXZpYXRlZCBtb250aHMgYXJlIG5vdCBjb21tb25seSB1c2VkIHNvIHRoZXJlIGlzIGEgZGlzcHV0ZSBhYm91dCB0aGUgcHJvcGVyIGFiYnJhdmlhdGlvbnMuICovXG4gIH07XG5cbiAgdmFyIG5sTmwgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJUIgJVkgJVRcIixcbiAgICBkYXRlOiBcIiVkLSVtLSVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcInpvbmRhZ1wiLCBcIm1hYW5kYWdcIiwgXCJkaW5zZGFnXCIsIFwid29lbnNkYWdcIiwgXCJkb25kZXJkYWdcIiwgXCJ2cmlqZGFnXCIsIFwiemF0ZXJkYWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJ6b1wiLCBcIm1hXCIsIFwiZGlcIiwgXCJ3b1wiLCBcImRvXCIsIFwidnJcIiwgXCJ6YVwiXSxcbiAgICBtb250aHM6IFtcImphbnVhcmlcIiwgXCJmZWJydWFyaVwiLCBcIm1hYXJ0XCIsIFwiYXByaWxcIiwgXCJtZWlcIiwgXCJqdW5pXCIsIFwianVsaVwiLCBcImF1Z3VzdHVzXCIsIFwic2VwdGVtYmVyXCIsIFwib2t0b2JlclwiLCBcIm5vdmVtYmVyXCIsIFwiZGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphblwiLCBcImZlYlwiLCBcIm1ydFwiLCBcImFwclwiLCBcIm1laVwiLCBcImp1blwiLCBcImp1bFwiLCBcImF1Z1wiLCBcInNlcFwiLCBcIm9rdFwiLCBcIm5vdlwiLCBcImRlY1wiXVxuICB9O1xuXG4gIHZhciBta01rID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi0L3QtdC00LXQu9CwXCIsIFwi0L/QvtC90LXQtNC10LvQvdC40LpcIiwgXCLQstGC0L7RgNC90LjQulwiLCBcItGB0YDQtdC00LBcIiwgXCLRh9C10YLQstGA0YLQvtC6XCIsIFwi0L/QtdGC0L7QulwiLCBcItGB0LDQsdC+0YLQsFwiXSxcbiAgICBzaG9ydERheXM6IFtcItC90LXQtFwiLCBcItC/0L7QvVwiLCBcItCy0YLQvlwiLCBcItGB0YDQtVwiLCBcItGH0LXRglwiLCBcItC/0LXRglwiLCBcItGB0LDQsVwiXSxcbiAgICBtb250aHM6IFtcItGY0LDQvdGD0LDRgNC4XCIsIFwi0YTQtdCy0YDRg9Cw0YDQuFwiLCBcItC80LDRgNGCXCIsIFwi0LDQv9GA0LjQu1wiLCBcItC80LDRmFwiLCBcItGY0YPQvdC4XCIsIFwi0ZjRg9C70LhcIiwgXCLQsNCy0LPRg9GB0YJcIiwgXCLRgdC10L/RgtC10LzQstGA0LhcIiwgXCLQvtC60YLQvtC80LLRgNC4XCIsIFwi0L3QvtC10LzQstGA0LhcIiwgXCLQtNC10LrQtdC80LLRgNC4XCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLRmNCw0L1cIiwgXCLRhNC10LJcIiwgXCLQvNCw0YBcIiwgXCLQsNC/0YBcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L1cIiwgXCLRmNGD0LtcIiwgXCLQsNCy0LNcIiwgXCLRgdC10L9cIiwgXCLQvtC60YJcIiwgXCLQvdC+0LVcIiwgXCLQtNC10LpcIl1cbiAgfTtcblxuICB2YXIgamFKcCA9IHtcbiAgICBkYXRlVGltZTogXCIlWSAlYiAlZSAlYSAlWFwiLFxuICAgIGRhdGU6IFwiJVkvJW0vJWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLml6Xmm5zml6VcIiwgXCLmnIjmm5zml6VcIiwgXCLngavmm5zml6VcIiwgXCLmsLTmm5zml6VcIiwgXCLmnKjmm5zml6VcIiwgXCLph5Hmm5zml6VcIiwgXCLlnJ/mm5zml6VcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLml6VcIiwgXCLmnIhcIiwgXCLngatcIiwgXCLmsLRcIiwgXCLmnKhcIiwgXCLph5FcIiwgXCLlnJ9cIl0sXG4gICAgbW9udGhzOiBbXCLnnabmnIhcIiwgXCLlpoLmnIhcIiwgXCLlvKXnlJ9cIiwgXCLlja/mnIhcIiwgXCLnmpDmnIhcIiwgXCLmsLTnhKHmnIhcIiwgXCLmlofmnIhcIiwgXCLokYnmnIhcIiwgXCLplbfmnIhcIiwgXCLnpZ7nhKHmnIhcIiwgXCLpnJzmnIhcIiwgXCLluKvotbBcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIjHmnIhcIiwgXCIy5pyIXCIsIFwiM+aciFwiLCBcIjTmnIhcIiwgXCI15pyIXCIsIFwiNuaciFwiLCBcIjfmnIhcIiwgXCI45pyIXCIsIFwiOeaciFwiLCBcIjEw5pyIXCIsIFwiMTHmnIhcIiwgXCIxMuaciFwiXVxuICB9O1xuXG4gIHZhciBpdEl0ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiRG9tZW5pY2FcIiwgXCJMdW5lZMOsXCIsIFwiTWFydGVkw6xcIiwgXCJNZXJjb2xlZMOsXCIsIFwiR2lvdmVkw6xcIiwgXCJWZW5lcmTDrFwiLCBcIlNhYmF0b1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIkx1blwiLCBcIk1hclwiLCBcIk1lclwiLCBcIkdpb1wiLCBcIlZlblwiLCBcIlNhYlwiXSxcbiAgICBtb250aHM6IFtcIkdlbm5haW9cIiwgXCJGZWJicmFpb1wiLCBcIk1hcnpvXCIsIFwiQXByaWxlXCIsIFwiTWFnZ2lvXCIsIFwiR2l1Z25vXCIsIFwiTHVnbGlvXCIsIFwiQWdvc3RvXCIsIFwiU2V0dGVtYnJlXCIsIFwiT3R0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRGljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkdlblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1hZ1wiLCBcIkdpdVwiLCBcIkx1Z1wiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk90dFwiLCBcIk5vdlwiLCBcIkRpY1wiXVxuICB9O1xuXG4gIHZhciBoZUlsID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSDXkSVCICVZICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIteo15DXqdeV159cIiwgXCLXqdeg15lcIiwgXCLXqdec15nXqdeZXCIsIFwi16jXkdeZ16LXmVwiLCBcIteX157Xmdep15lcIiwgXCLXqdeZ16nXmVwiLCBcItep15HXqlwiXSxcbiAgICBzaG9ydERheXM6IFtcIteQ17NcIiwgXCLXkdezXCIsIFwi15LXs1wiLCBcIteT17NcIiwgXCLXlNezXCIsIFwi15XXs1wiLCBcItep17NcIl0sXG4gICAgbW9udGhzOiBbXCLXmdeg15XXkNeoXCIsIFwi16TXkdeo15XXkNeoXCIsIFwi157XqNelXCIsIFwi15DXpNeo15nXnFwiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXldeh15hcIiwgXCLXodek15jXnteR16hcIiwgXCLXkNeV16fXmNeV15HXqFwiLCBcIteg15XXkdee15HXqFwiLCBcIteT16bXnteR16hcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIteZ16DXldezXCIsIFwi16TXkdeo17NcIiwgXCLXnteo16VcIiwgXCLXkNek16jXs1wiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXs1wiLCBcIteh16TXmNezXCIsIFwi15DXlden17NcIiwgXCLXoNeV15HXs1wiLCBcIteT16bXntezXCJdXG4gIH07XG5cbiAgdmFyIGZyRnIgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGxlICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltLlwiLCBcImx1bi5cIiwgXCJtYXIuXCIsIFwibWVyLlwiLCBcImpldS5cIiwgXCJ2ZW4uXCIsIFwic2FtLlwiXSxcbiAgICBtb250aHM6IFtcImphbnZpZXJcIiwgXCJmw6l2cmllclwiLCBcIm1hcnNcIiwgXCJhdnJpbFwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsbGV0XCIsIFwiYW/Du3RcIiwgXCJzZXB0ZW1icmVcIiwgXCJvY3RvYnJlXCIsIFwibm92ZW1icmVcIiwgXCJkw6ljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphbnYuXCIsIFwiZsOpdnIuXCIsIFwibWFyc1wiLCBcImF2ci5cIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbC5cIiwgXCJhb8O7dFwiLCBcInNlcHQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkw6ljLlwiXVxuICB9O1xuXG4gIHZhciBmckNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVZICVYXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJcIiwgXCJcIl0sXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWVyXCIsIFwiamV1XCIsIFwidmVuXCIsIFwic2FtXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFuXCIsIFwiZsOpdlwiLCBcIm1hclwiLCBcImF2clwiLCBcIm1haVwiLCBcImp1aVwiLCBcImp1bFwiLCBcImFvw7tcIiwgXCJzZXBcIiwgXCJvY3RcIiwgXCJub3ZcIiwgXCJkw6ljXCJdXG4gIH07XG5cbiAgdmFyIGZpRmkgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICUtZC4gJUJ0YSAlWSBrbG8gJVhcIixcbiAgICBkYXRlOiBcIiUtZC4lLW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiYS5tLlwiLCBcInAubS5cIl0sXG4gICAgZGF5czogW1wic3VubnVudGFpXCIsIFwibWFhbmFudGFpXCIsIFwidGlpc3RhaVwiLCBcImtlc2tpdmlpa2tvXCIsIFwidG9yc3RhaVwiLCBcInBlcmphbnRhaVwiLCBcImxhdWFudGFpXCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VcIiwgXCJNYVwiLCBcIlRpXCIsIFwiS2VcIiwgXCJUb1wiLCBcIlBlXCIsIFwiTGFcIl0sXG4gICAgbW9udGhzOiBbXCJ0YW1taWt1dVwiLCBcImhlbG1pa3V1XCIsIFwibWFhbGlza3V1XCIsIFwiaHVodGlrdXVcIiwgXCJ0b3Vrb2t1dVwiLCBcImtlc8Oka3V1XCIsIFwiaGVpbsOka3V1XCIsIFwiZWxva3V1XCIsIFwic3l5c2t1dVwiLCBcImxva2FrdXVcIiwgXCJtYXJyYXNrdXVcIiwgXCJqb3VsdWt1dVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiVGFtbWlcIiwgXCJIZWxtaVwiLCBcIk1hYWxpc1wiLCBcIkh1aHRpXCIsIFwiVG91a29cIiwgXCJLZXPDpFwiLCBcIkhlaW7DpFwiLCBcIkVsb1wiLCBcIlN5eXNcIiwgXCJMb2thXCIsIFwiTWFycmFzXCIsIFwiSm91bHVcIl1cbiAgfTtcblxuICB2YXIgZXNFcyA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRvbWluZ29cIiwgXCJsdW5lc1wiLCBcIm1hcnRlc1wiLCBcIm1pw6lyY29sZXNcIiwgXCJqdWV2ZXNcIiwgXCJ2aWVybmVzXCIsIFwic8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcImRvbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1pw6lcIiwgXCJqdWVcIiwgXCJ2aWVcIiwgXCJzw6FiXCJdLFxuICAgIG1vbnRoczogW1wiZW5lcm9cIiwgXCJmZWJyZXJvXCIsIFwibWFyem9cIiwgXCJhYnJpbFwiLCBcIm1heW9cIiwgXCJqdW5pb1wiLCBcImp1bGlvXCIsIFwiYWdvc3RvXCIsIFwic2VwdGllbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZpZW1icmVcIiwgXCJkaWNpZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImVuZVwiLCBcImZlYlwiLCBcIm1hclwiLCBcImFiclwiLCBcIm1heVwiLCBcImp1blwiLCBcImp1bFwiLCBcImFnb1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImRpY1wiXVxuICB9O1xuXG4gIHZhciBlblVzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkdiID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVYICVZXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBkZURlID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCBkZXIgJWUuICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiU29ubnRhZ1wiLCBcIk1vbnRhZ1wiLCBcIkRpZW5zdGFnXCIsIFwiTWl0dHdvY2hcIiwgXCJEb25uZXJzdGFnXCIsIFwiRnJlaXRhZ1wiLCBcIlNhbXN0YWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNw6RyelwiLCBcIkFwcmlsXCIsIFwiTWFpXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZXplbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTXJ6XCIsIFwiQXByXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGV6XCJdXG4gIH07XG5cbiAgdmFyIGNhRXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJkaXVtZW5nZVwiLCBcImRpbGx1bnNcIiwgXCJkaW1hcnRzXCIsIFwiZGltZWNyZXNcIiwgXCJkaWpvdXNcIiwgXCJkaXZlbmRyZXNcIiwgXCJkaXNzYWJ0ZVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRnLlwiLCBcImRsLlwiLCBcImR0LlwiLCBcImRjLlwiLCBcImRqLlwiLCBcImR2LlwiLCBcImRzLlwiXSxcbiAgICBtb250aHM6IFtcImdlbmVyXCIsIFwiZmVicmVyXCIsIFwibWFyw6dcIiwgXCJhYnJpbFwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsaW9sXCIsIFwiYWdvc3RcIiwgXCJzZXRlbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZlbWJyZVwiLCBcImRlc2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJnZW4uXCIsIFwiZmVici5cIiwgXCJtYXLDp1wiLCBcImFici5cIiwgXCJtYWlnXCIsIFwianVueVwiLCBcImp1bC5cIiwgXCJhZy5cIiwgXCJzZXQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkZXMuXCJdXG4gIH07XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG4gIHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIHZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbiAgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gICAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3WWVhcih5KSB7XG4gICAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgICBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLFxuICAgICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgICAgbG9jYWxlX3Nob3J0V2Vla2RheXMgPSBsb2NhbGUuc2hvcnREYXlzLFxuICAgICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gICAgdmFyIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICAgIHdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0TW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlcyA9IHtcbiAgICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gICAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBwYWQsXG4gICAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkID09IG51bGwgPyAoYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiKSA6IHBhZCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgICB2YXIgZGF5ID0gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgdmFyIGRheSA9IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcbiAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFyc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV90aW1lLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBwZXJpb2RMb29rdXBbc3RyaW5nLnNsaWNlKGksIGkgKz0gMikudG9Mb3dlckNhc2UoKV07XG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gLTEgOiAoZC5wID0gbiwgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0U2hvcnRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0U2hvcnRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJpb2QoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgbG9jYWxEYXRlKTtcbiAgICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sXG4gICAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICAgIGYucGFyc2UgPSBuZXdQYXJzZShzcGVjaWZpZXIsIHV0Y0RhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9O1xuICB2YXIgbnVtYmVyUmUgPSAvXlxccypcXGQrLztcbiAgdmFyIHBlcmNlbnRSZSA9IC9eJS87XG4gIHZhciByZXF1b3RlUmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG5cbiAgZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxuICAgICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXVvdGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UocmVxdW90ZVJlLCBcIlxcXFwkJlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAocmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gICAgdmFyIG1hcCA9IHt9LCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcFtuYW1lc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzpcXDo/KFxcZFxcZCkpPy8uZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDYpKTtcbiAgICBpZiAobikge1xuICAgICAgZC5aID0gblsxXSA/IDAgICAgICAgICAgICAgIC8vICdaJyBmb3IgVVRDXG4gICAgICAgICAgOiBuWzNdID8gLShuWzJdICsgblszXSkgLy8gc2lnbiBkaWZmZXJzIGZyb20gZ2V0VGltZXpvbmVPZmZzZXQhXG4gICAgICAgICAgICAgICAgIDogLW5bMl0gKiAxMDA7XG4gICAgICByZXR1cm4gaSArIG5bMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vbnRoTnVtYmVyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXlPZk1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGQubSA9IDAsIGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhvdXIyNChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWludXRlcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCgxICsgZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQoc3VuZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXIoZCkge1xuICAgIHJldHVybiBkLmdldERheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChtb25kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICAgICsgcGFkKHogJSA2MCwgXCIwXCIsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0RhdGUoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIHV0Y0RheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y1N1bmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQodXRjTW9uZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gICAgcmV0dXJuIFwiKzAwMDBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICAgIHJldHVybiBcIiVcIjtcbiAgfVxuXG4gIHZhciBpc29TcGVjaWZpZXIgPSBcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxuXG4gIGZvcm1hdElzb05hdGl2ZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbiAgfTtcblxuICBmb3JtYXRJc29OYXRpdmUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNvU3BlY2lmaWVyO1xuICB9O1xuXG4gIHZhciBmb3JtYXRJc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICAgID8gZm9ybWF0SXNvTmF0aXZlXG4gICAgICA6IGVuVXMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbiAgdmFyIGlzb0Zvcm1hdCA9IGZvcm1hdElzbztcblxuICB2YXIgbG9jYWxlRGVmaW5pdGlvbnMgPSB7XG4gICAgXCJjYS1FU1wiOiBjYUVzLFxuICAgIFwiZGUtREVcIjogZGVEZSxcbiAgICBcImVuLUNBXCI6IGVuQ2EsXG4gICAgXCJlbi1HQlwiOiBlbkdiLFxuICAgIFwiZW4tVVNcIjogZW5VcyxcbiAgICBcImVzLUVTXCI6IGVzRXMsXG4gICAgXCJmaS1GSVwiOiBmaUZpLFxuICAgIFwiZnItQ0FcIjogZnJDYSxcbiAgICBcImZyLUZSXCI6IGZyRnIsXG4gICAgXCJoZS1JTFwiOiBoZUlsLFxuICAgIFwiaXQtSVRcIjogaXRJdCxcbiAgICBcImphLUpQXCI6IGphSnAsXG4gICAgXCJtay1NS1wiOiBta01rLFxuICAgIFwibmwtTkxcIjogbmxObCxcbiAgICBcInBsLVBMXCI6IHBsUGwsXG4gICAgXCJwdC1CUlwiOiBwdEJyLFxuICAgIFwicnUtUlVcIjogcnVSdSxcbiAgICBcInpoLUNOXCI6IHpoQ25cbiAgfTtcblxuICB2YXIgZGVmYXVsdExvY2FsZSA9IGxvY2FsZShlblVzKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBkZWZhdWx0TG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBkZWZhdWx0TG9jYWxlLnV0Y0Zvcm1hdDtcblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQoZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFsb2NhbGVEZWZpbml0aW9ucy5oYXNPd25Qcm9wZXJ0eShkZWZpbml0aW9uKSkgcmV0dXJuIG51bGw7XG4gICAgICBkZWZpbml0aW9uID0gbG9jYWxlRGVmaW5pdGlvbnNbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGUoZGVmaW5pdGlvbik7XG4gIH1cbiAgO1xuXG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGlzb0Zvcm1hdDtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLnRpbWUgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbiAgdmFyIG1pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFNlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLm1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cbiAgdmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLmhvdXJzID0gaG91ci5yYW5nZTtcblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5kYXlzID0gZGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuc3VuZGF5ID0gd2Vla2RheSgwKTtcblxuICBleHBvcnRzLnN1bmRheXMgPSBleHBvcnRzLnN1bmRheS5yYW5nZTtcblxuICBleHBvcnRzLm1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgZXhwb3J0cy5tb25kYXlzID0gZXhwb3J0cy5tb25kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50dWVzZGF5ID0gd2Vla2RheSgyKTtcblxuICBleHBvcnRzLnR1ZXNkYXlzID0gZXhwb3J0cy50dWVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMud2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcblxuICBleHBvcnRzLndlZG5lc2RheXMgPSBleHBvcnRzLndlZG5lc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnRodXJzZGF5ID0gd2Vla2RheSg0KTtcblxuICBleHBvcnRzLnRodXJzZGF5cyA9IGV4cG9ydHMudGh1cnNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5mcmlkYXkgPSB3ZWVrZGF5KDUpO1xuXG4gIGV4cG9ydHMuZnJpZGF5cyA9IGV4cG9ydHMuZnJpZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXlzID0gZXhwb3J0cy5zYXR1cmRheS5yYW5nZTtcblxuICB2YXIgd2VlayA9IGV4cG9ydHMuc3VuZGF5O1xuXG4gIGV4cG9ydHMud2Vla3MgPSB3ZWVrLnJhbmdlO1xuXG4gIHZhciBtb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbiAgfSk7XG5cbiAgZXhwb3J0cy5tb250aHMgPSBtb250aC5yYW5nZTtcblxuICB2YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZXhwb3J0cy55ZWFycyA9IHllYXIucmFuZ2U7XG5cbiAgdmFyIHV0Y1NlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbGxpc2Vjb25kcygwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAxZTM7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjU2Vjb25kcyA9IHV0Y1NlY29uZC5yYW5nZTtcblxuICB2YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxuICB2YXIgdXRjSG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDM2ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy51dGNTdW5kYXlzID0gZXhwb3J0cy51dGNTdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5cyA9IGV4cG9ydHMudXRjTW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy51dGNUdWVzZGF5cyA9IGV4cG9ydHMudXRjVHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gZXhwb3J0cy51dGNXZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheXMgPSBleHBvcnRzLnV0Y1RodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheXMgPSBleHBvcnRzLnV0Y0ZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5cyA9IGV4cG9ydHMudXRjU2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHV0Y1dlZWsgPSBleHBvcnRzLnV0Y1N1bmRheTtcblxuICBleHBvcnRzLnV0Y1dlZWtzID0gdXRjV2Vlay5yYW5nZTtcblxuICB2YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG4gIGV4cG9ydHMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcbiAgZXhwb3J0cy5zZWNvbmQgPSBzZWNvbmQ7XG4gIGV4cG9ydHMubWludXRlID0gbWludXRlO1xuICBleHBvcnRzLmhvdXIgPSBob3VyO1xuICBleHBvcnRzLmRheSA9IGRheTtcbiAgZXhwb3J0cy53ZWVrID0gd2VlaztcbiAgZXhwb3J0cy5tb250aCA9IG1vbnRoO1xuICBleHBvcnRzLnllYXIgPSB5ZWFyO1xuICBleHBvcnRzLnV0Y1NlY29uZCA9IHV0Y1NlY29uZDtcbiAgZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG4gIGV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG4gIGV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuICBleHBvcnRzLnV0Y1dlZWsgPSB1dGNXZWVrO1xuICBleHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG4gIGV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5cbn0pKTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBNZWFzdXJlcyA9IHJlcXVpcmUoJy4vbWVhc3VyZXMnKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL2NvbGxlY3RvcicpO1xuXG5mdW5jdGlvbiBBZ2dyZWdhdG9yKCkge1xuICB0aGlzLl9jZWxscyA9IHt9O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHRoaXMuX3N0cmVhbSA9IGZhbHNlO1xufVxuXG52YXIgRmxhZ3MgPSBBZ2dyZWdhdG9yLkZsYWdzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDJcbn07XG5cbnZhciBwcm90byA9IEFnZ3JlZ2F0b3IucHJvdG90eXBlO1xuXG4vLyBQYXJhbWV0ZXJzXG5cbnByb3RvLnN0cmVhbSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0cmVhbTtcbiAgdGhpcy5fc3RyZWFtID0gISF2O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8ga2V5IGFjY2Vzc29yIHRvIHVzZSBmb3Igc3RyZWFtaW5nIHJlbW92ZXNcbnByb3RvLmtleSA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzLl9rZXk7XG4gIHRoaXMuX2tleSA9IHV0aWwuJChrZXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIElucHV0OiBhcnJheSBvZiBvYmplY3RzIG9mIHRoZSBmb3JtXG4vLyB7bmFtZTogc3RyaW5nLCBnZXQ6IGZ1bmN0aW9ufVxucHJvdG8uZ3JvdXBieSA9IGZ1bmN0aW9uKGRpbXMpIHtcbiAgdGhpcy5fZGltcyA9IHV0aWwuYXJyYXkoZGltcykubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICBkID0gdXRpbC5pc1N0cmluZyhkKSA/IHtuYW1lOiBkLCBnZXQ6IHV0aWwuJChkKX1cbiAgICAgIDogdXRpbC5pc0Z1bmN0aW9uKGQpID8ge25hbWU6IHV0aWwubmFtZShkKSB8fCBkLm5hbWUgfHwgKCdfJyArIGkpLCBnZXQ6IGR9XG4gICAgICA6IChkLm5hbWUgJiYgdXRpbC5pc0Z1bmN0aW9uKGQuZ2V0KSkgPyBkIDogbnVsbDtcbiAgICBpZiAoZCA9PSBudWxsKSB0aHJvdyAnSW52YWxpZCBncm91cGJ5IGFyZ3VtZW50OiAnICsgZDtcbiAgICByZXR1cm4gZDtcbiAgfSk7XG4gIHJldHVybiB0aGlzLmNsZWFyKCk7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgb3BzOiBbc3RyaW5nLCAuLi5dfVxucHJvdG8uc3VtbWFyaXplID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIGZpZWxkcyA9IHN1bW1hcml6ZV9hcmdzKGZpZWxkcyk7XG4gIHRoaXMuX2NvdW50ID0gdHJ1ZTtcbiAgdmFyIGFnZ3IgPSAodGhpcy5fYWdnciA9IFtdKSxcbiAgICAgIG0sIGYsIGksIGosIG9wLCBhcywgZ2V0O1xuXG4gIGZvciAoaT0wOyBpPGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIGZvciAoaj0wLCBtPVtdLCBmPWZpZWxkc1tpXTsgajxmLm9wcy5sZW5ndGg7ICsraikge1xuICAgICAgb3AgPSBmLm9wc1tqXTtcbiAgICAgIGlmIChvcCAhPT0gJ2NvdW50JykgdGhpcy5fY291bnQgPSBmYWxzZTtcbiAgICAgIGFzID0gKGYuYXMgJiYgZi5hc1tqXSkgfHwgKG9wICsgKGYubmFtZT09PScqJyA/ICcnIDogJ18nK2YubmFtZSkpO1xuICAgICAgbS5wdXNoKE1lYXN1cmVzW29wXShhcykpO1xuICAgIH1cbiAgICBnZXQgPSBmLmdldCAmJiB1dGlsLiQoZi5nZXQpIHx8XG4gICAgICAoZi5uYW1lID09PSAnKicgPyB1dGlsLmlkZW50aXR5IDogdXRpbC4kKGYubmFtZSkpO1xuICAgIGFnZ3IucHVzaCh7XG4gICAgICBuYW1lOiBmLm5hbWUsXG4gICAgICBtZWFzdXJlczogTWVhc3VyZXMuY3JlYXRlKFxuICAgICAgICBtLFxuICAgICAgICB0aGlzLl9zdHJlYW0sIC8vIHN0cmVhbWluZyByZW1vdmUgZmxhZ1xuICAgICAgICBnZXQsICAgICAgICAgIC8vIGlucHV0IHR1cGxlIGdldHRlclxuICAgICAgICB0aGlzLl9hc3NpZ24pIC8vIG91dHB1dCB0dXBsZSBzZXR0ZXJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHN1bW1hcml6ZSBieSBjb3VudFxucHJvdG8uY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3VtbWFyaXplKHsnKic6J2NvdW50J30pO1xufTtcblxuLy8gT3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gdHVwbGUgdmFsdWUgYXNzaWdubWVudFxucHJvdG8uX2Fzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgb2JqZWN0W25hbWVdID0gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBzdW1tYXJpemVfYXJncyhmaWVsZHMpIHtcbiAgaWYgKHV0aWwuaXNBcnJheShmaWVsZHMpKSB7IHJldHVybiBmaWVsZHM7IH1cbiAgaWYgKGZpZWxkcyA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuICB2YXIgYSA9IFtdLCBuYW1lLCBvcHM7XG4gIGZvciAobmFtZSBpbiBmaWVsZHMpIHtcbiAgICBvcHMgPSB1dGlsLmFycmF5KGZpZWxkc1tuYW1lXSk7XG4gICAgYS5wdXNoKHtuYW1lOiBuYW1lLCBvcHM6IG9wc30pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vLyBDZWxsIE1hbmFnZW1lbnRcblxucHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9jZWxscyA9IHt9LCB0aGlzKTtcbn07XG5cbnByb3RvLl9jZWxsa2V5ID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZCA9IHRoaXMuX2RpbXMsXG4gICAgICBuID0gZC5sZW5ndGgsIGksXG4gICAgICBrID0gU3RyaW5nKGRbMF0uZ2V0KHgpKTtcbiAgZm9yIChpPTE7IGk8bjsgKytpKSB7XG4gICAgayArPSAnfCcgKyBkW2ldLmdldCh4KTtcbiAgfVxuICByZXR1cm4gaztcbn07XG5cbnByb3RvLl9jZWxsID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5ID0gdGhpcy5fZGltcy5sZW5ndGggPyB0aGlzLl9jZWxsa2V5KHgpIDogJyc7XG4gIHJldHVybiB0aGlzLl9jZWxsc1trZXldIHx8ICh0aGlzLl9jZWxsc1trZXldID0gdGhpcy5fbmV3Y2VsbCh4LCBrZXkpKTtcbn07XG5cbnByb3RvLl9uZXdjZWxsID0gZnVuY3Rpb24oeCwga2V5KSB7XG4gIHZhciBjZWxsID0ge1xuICAgIG51bTogICAwLFxuICAgIHR1cGxlOiB0aGlzLl9uZXd0dXBsZSh4LCBrZXkpLFxuICAgIGZsYWc6ICBGbGFncy5BRERfQ0VMTCxcbiAgICBhZ2dzOiAge31cbiAgfTtcblxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXSA9IG5ldyBhZ2dyW2ldLm1lYXN1cmVzKGNlbGwsIGNlbGwudHVwbGUpO1xuICB9XG4gIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICBjZWxsLmRhdGEgPSBuZXcgQ29sbGVjdG9yKHRoaXMuX2tleSk7XG4gIH1cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fbmV3dHVwbGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgIHQgPSB7fSwgaSwgbjtcbiAgZm9yIChpPTAsIG49ZGltcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdFtkaW1zW2ldLm5hbWVdID0gZGltc1tpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2luZ2VzdCh0KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIGluZ2VzdGlvblxucHJvdG8uX2luZ2VzdCA9IHV0aWwuaWRlbnRpdHk7XG5cbi8vIFByb2Nlc3MgVHVwbGVzXG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtICs9IDE7XG4gIGlmICghdGhpcy5fY291bnQpIHsgLy8gc2tpcCBpZiBjb3VudC1vbmx5XG4gICAgaWYgKGNlbGwuY29sbGVjdCkgY2VsbC5kYXRhLmFkZCh4KTtcbiAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5hZGQoeCk7XG4gICAgfVxuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbiAgaWYgKHRoaXMuX29uX2FkZCkgdGhpcy5fb25fYWRkKHgsIGNlbGwpO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgY2VsbC5udW0gLT0gMTtcbiAgaWYgKCF0aGlzLl9jb3VudCkgeyAvLyBza2lwIGlmIGNvdW50LW9ubHlcbiAgICBpZiAoY2VsbC5jb2xsZWN0KSBjZWxsLmRhdGEucmVtKHgpO1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnJlbSh4KTtcbiAgICB9XG4gIH1cbiAgY2VsbC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBpZiAodGhpcy5fb25fcmVtKSB0aGlzLl9vbl9yZW0oeCwgY2VsbCk7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oY3VyciwgcHJldikge1xuICB2YXIgY2VsbDAgPSB0aGlzLl9jZWxsKHByZXYpLFxuICAgICAgY2VsbDEgPSB0aGlzLl9jZWxsKGN1cnIpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgaWYgKGNlbGwwICE9PSBjZWxsMSkge1xuICAgIGNlbGwwLm51bSAtPSAxO1xuICAgIGNlbGwxLm51bSArPSAxO1xuICAgIGlmIChjZWxsMC5jb2xsZWN0KSBjZWxsMC5kYXRhLnJlbShwcmV2KTtcbiAgICBpZiAoY2VsbDEuY29sbGVjdCkgY2VsbDEuZGF0YS5hZGQoY3Vycik7XG4gIH0gZWxzZSBpZiAoY2VsbDAuY29sbGVjdCAmJiAhdXRpbC5pc09iamVjdChjdXJyKSkge1xuICAgIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGNlbGwwLmRhdGEuYWRkKGN1cnIpO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgIGNlbGwwLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0ocHJldik7XG4gICAgY2VsbDEuYWdnc1thZ2dyW2ldLm5hbWVdLmFkZChjdXJyKTtcbiAgfVxuICBjZWxsMC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBjZWxsMS5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBpZiAodGhpcy5fb25fbW9kKSB0aGlzLl9vbl9tb2QoY3VyciwgcHJldiwgY2VsbDAsIGNlbGwxKTtcbn07XG5cbnByb3RvLnJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmIChjZWxsLm51bSA+IDApIHtcbiAgICAgIC8vIGNvbnNvbGlkYXRlIGNvbGxlY3RvciB2YWx1ZXNcbiAgICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHR1cGxlIHByb3BlcnRpZXNcbiAgICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgb3V0cHV0IHR1cGxlXG4gICAgICByZXN1bHQucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2NlbGxzW2tdO1xuICAgIH1cbiAgICBjZWxsLmZsYWcgPSAwO1xuICB9XG5cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxucHJvdG8uY2hhbmdlcyA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICB2YXIgY2hhbmdlcyA9IG91dHB1dCB8fCB7YWRkOltdLCByZW06W10sIG1vZDpbXX0sXG4gICAgICBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGZsYWcsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGZsYWcgPSBjZWxsLmZsYWc7XG5cbiAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgfVxuXG4gICAgLy8gb3JnYW5pemUgb3V0cHV0IHR1cGxlc1xuICAgIGlmIChjZWxsLm51bSA8PSAwKSB7XG4gICAgICBjaGFuZ2VzLnJlbS5wdXNoKGNlbGwudHVwbGUpOyAvLyBpZiAoZmxhZyA9PT0gRmxhZ3MuTU9EX0NFTEwpIHsgPz9cbiAgICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trXTtcbiAgICAgIGlmICh0aGlzLl9vbl9kcm9wKSB0aGlzLl9vbl9kcm9wKGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fb25fa2VlcCkgdGhpcy5fb25fa2VlcChjZWxsKTtcbiAgICAgIGlmIChmbGFnICYgRmxhZ3MuQUREX0NFTEwpIHtcbiAgICAgICAgY2hhbmdlcy5hZGQucHVzaChjZWxsLnR1cGxlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZyAmIEZsYWdzLk1PRF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMubW9kLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5wcm90by5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKS5pbnNlcnQoaW5wdXQpLnJlc3VsdCgpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdGhpcy5fY29uc29saWRhdGUoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fYWRkKGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmICghdGhpcy5fc3RyZWFtKSB7XG4gICAgdGhyb3cgJ0FnZ3JlZ2F0b3Igbm90IGNvbmZpZ3VyZWQgZm9yIHN0cmVhbWluZyByZW1vdmVzLicgK1xuICAgICAgJyBDYWxsIHN0cmVhbSh0cnVlKSBwcmlvciB0byBjYWxsaW5nIHN1bW1hcml6ZS4nO1xuICB9XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX3JlbShpbnB1dFtpXSk7XG4gIH1cbiAgdGhpcy5fcmVtcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gY29uc29saWRhdGUgcmVtb3ZhbHNcbnByb3RvLl9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbXMpIHJldHVybjtcbiAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgIGlmICh0aGlzLl9jZWxsc1trXS5jb2xsZWN0KSB7XG4gICAgICB0aGlzLl9jZWxsc1trXS5kYXRhLnZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgUkVNID0gJ19fZGxfcmVtX18nO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3Ioa2V5KSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fa2V5ID0ga2V5IHx8IG51bGw7XG4gIHRoaXMuX2xhc3QgPSBudWxsO1xufVxuXG52YXIgcHJvdG8gPSBDb2xsZWN0b3IucHJvdG90eXBlO1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2FkZDtcblxuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgeCA9IEFycmF5KGEubGVuZ3RoIC0gci5sZW5ndGgpLFxuICAgICAgaSwgaiwgbiwgbTtcblxuICBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzaW5nIHJhdyB2YWx1ZXNcbiAgICBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaykge1xuICAgIC8vIGhhcyB1bmlxdWUga2V5IGZpZWxkLCBzbyB1c2UgdGhhdFxuICAgIG0gPSB1dGlsLnRvTWFwKHIsIGspO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoayhhW2ldKSkpIHsgeFtqKytdID0gYVtpXTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyB1bmlxdWUga2V5LCBtYXJrIHR1cGxlcyBkaXJlY3RseVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgcltpXVtSRU1dID0gMTtcbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghYVtpXVtSRU1dKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZWxldGUgcltpXVtSRU1dO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0OyAgICBcbiAgfVxuICByZXR1cm4gdGhpcy5fZXh0O1xufTtcblxucHJvdG8uYXJnbWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzBdO1xufTtcblxucHJvdG8uYXJnbWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdO1xufTtcblxucHJvdG8ubWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiArSW5maW5pdHk7XG59O1xuXG5wcm90by5tYXggPSBmdW5jdGlvbihnZXQpIHtcbiAgdmFyIG0gPSB0aGlzLmV4dGVudChnZXQpWzFdO1xuICByZXR1cm4gbSA/IGdldChtKSA6IC1JbmZpbml0eTtcbn07XG5cbnByb3RvLnF1YXJ0aWxlID0gZnVuY3Rpb24oZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fcSkge1xuICAgIHRoaXMuX3EgPSBzdGF0cy5xdWFydGlsZSh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDsgICAgXG4gIH1cbiAgcmV0dXJuIHRoaXMuX3E7XG59O1xuXG5wcm90by5xMSA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzBdO1xufTtcblxucHJvdG8ucTIgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsxXTtcbn07XG5cbnByb3RvLnEzID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMl07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gZmxhdHRlbiBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheVxuICB2YXIgYXJncyA9IFtdLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgeCkge1xuICAgIHJldHVybiBhLmNvbmNhdCh1dGlsLmFycmF5KHgpKTtcbiAgfSwgW10pO1xuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhbiBhZ2dyZWdhdG9yXG4gIHJldHVybiBuZXcgQWdncmVnYXRvcigpXG4gICAgLmdyb3VwYnkoYXJncylcbiAgICAuc3VtbWFyaXplKHsnKic6J3ZhbHVlcyd9KTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIHR5cGVzID0ge1xuICAndmFsdWVzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgaW5pdDogJ2NlbGwuY29sbGVjdCA9IHRydWU7JyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnZhbHVlcygpJywgaWR4OiAtMVxuICB9KSxcbiAgJ2NvdW50JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2NvdW50JyxcbiAgICBzZXQ6ICAnY2VsbC5udW0nXG4gIH0pLFxuICAnbWlzc2luZyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaXNzaW5nJyxcbiAgICBzZXQ6ICAndGhpcy5taXNzaW5nJ1xuICB9KSxcbiAgJ3ZhbGlkJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbGlkJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCdcbiAgfSksXG4gICdzdW0nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3VtJyxcbiAgICBpbml0OiAndGhpcy5zdW0gPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuc3VtICs9IHY7JyxcbiAgICByZW06ICAndGhpcy5zdW0gLT0gdjsnLFxuICAgIHNldDogICd0aGlzLnN1bSdcbiAgfSksXG4gICdtZWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lYW4nLFxuICAgIGluaXQ6ICd0aGlzLm1lYW4gPSAwOycsXG4gICAgYWRkOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuICs9IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgcmVtOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuIC09IHRoaXMudmFsaWQgPyBkIC8gdGhpcy52YWxpZCA6IHRoaXMubWVhbjsnLFxuICAgIHNldDogICd0aGlzLm1lYW4nXG4gIH0pLFxuICAnYXZlcmFnZSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhdmVyYWdlJyxcbiAgICBzZXQ6ICAndGhpcy5tZWFuJyxcbiAgICByZXE6ICBbJ21lYW4nXSwgaWR4OiAxXG4gIH0pLFxuICAndmFyaWFuY2UnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFyaWFuY2UnLFxuICAgIGluaXQ6ICd0aGlzLmRldiA9IDA7JyxcbiAgICBhZGQ6ICAndGhpcy5kZXYgKz0gZCAqICh2IC0gdGhpcy5tZWFuKTsnLFxuICAgIHJlbTogICd0aGlzLmRldiAtPSBkICogKHYgLSB0aGlzLm1lYW4pOycsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQgPiAxID8gdGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSA6IDAnLFxuICAgIHJlcTogIFsnbWVhbiddLCBpZHg6IDFcbiAgfSksXG4gICd2YXJpYW5jZXAnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFyaWFuY2VwJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyB0aGlzLmRldiAvIHRoaXMudmFsaWQgOiAwJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ3N0ZGV2JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N0ZGV2JyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyBNYXRoLnNxcnQodGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSkgOiAwJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ3N0ZGV2cCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRldnAnLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IE1hdGguc3FydCh0aGlzLmRldiAvIHRoaXMudmFsaWQpIDogMCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdtZWRpYW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWVkaWFuJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnEyKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTEnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTEnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTEodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdxMyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdxMycsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMyh0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2Rpc3RpbmN0JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2Rpc3RpbmN0JyxcbiAgICBzZXQ6ICAndGhpcy5kaXN0aW5jdChjZWxsLmRhdGEudmFsdWVzKCksIHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnYXJnbWluJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2FyZ21pbicsXG4gICAgYWRkOiAgJ2lmICh2IDwgdGhpcy5taW4pIHRoaXMuYXJnbWluID0gdDsnLFxuICAgIHJlbTogICdpZiAodiA8PSB0aGlzLm1pbikgdGhpcy5hcmdtaW4gPSBudWxsOycsXG4gICAgc2V0OiAgJ3RoaXMuYXJnbWluID0gdGhpcy5hcmdtaW4gfHwgY2VsbC5kYXRhLmFyZ21pbih0aGlzLmdldCknLFxuICAgIHJlcTogIFsnbWluJ10sIHN0cjogWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnYXJnbWF4JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2FyZ21heCcsXG4gICAgYWRkOiAgJ2lmICh2ID4gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gdDsnLFxuICAgIHJlbTogICdpZiAodiA+PSB0aGlzLm1heCkgdGhpcy5hcmdtYXggPSBudWxsOycsXG4gICAgc2V0OiAgJ3RoaXMuYXJnbWF4ID0gdGhpcy5hcmdtYXggfHwgY2VsbC5kYXRhLmFyZ21heCh0aGlzLmdldCknLFxuICAgIHJlcTogIFsnbWF4J10sIHN0cjogWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnbWluJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21pbicsXG4gICAgaW5pdDogJ3RoaXMubWluID0gK0luZmluaXR5OycsXG4gICAgYWRkOiAgJ2lmICh2IDwgdGhpcy5taW4pIHRoaXMubWluID0gdjsnLFxuICAgIHJlbTogICdpZiAodiA8PSB0aGlzLm1pbikgdGhpcy5taW4gPSBOYU47JyxcbiAgICBzZXQ6ICAndGhpcy5taW4gPSAoaXNOYU4odGhpcy5taW4pID8gY2VsbC5kYXRhLm1pbih0aGlzLmdldCkgOiB0aGlzLm1pbiknLFxuICAgIHN0cjogIFsndmFsdWVzJ10sIGlkeDogNFxuICB9KSxcbiAgJ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtYXgnLFxuICAgIGluaXQ6ICd0aGlzLm1heCA9IC1JbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLm1heCA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMubWF4ID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWF4ID0gKGlzTmFOKHRoaXMubWF4KSA/IGNlbGwuZGF0YS5tYXgodGhpcy5nZXQpIDogdGhpcy5tYXgpJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtb2Rlc2tldyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtb2Rlc2tldycsXG4gICAgc2V0OiAgJ3RoaXMuZGV2PT09MCA/IDAgOiAodGhpcy5tZWFuIC0gY2VsbC5kYXRhLnEyKHRoaXMuZ2V0KSkgLyBNYXRoLnNxcnQodGhpcy5kZXYvKHRoaXMudmFsaWQtMSkpJyxcbiAgICByZXE6ICBbJ21lYW4nLCAnc3RkZXYnLCAnbWVkaWFuJ10sIGlkeDogNVxuICB9KVxufTtcblxuZnVuY3Rpb24gbWVhc3VyZShiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvdXQpIHtcbiAgICB2YXIgbSA9IHV0aWwuZXh0ZW5kKHtpbml0OicnLCBhZGQ6JycsIHJlbTonJywgaWR4OjB9LCBiYXNlKTtcbiAgICBtLm91dCA9IG91dCB8fCBiYXNlLm5hbWU7XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYWdnLCBzdHJlYW0pIHtcbiAgZnVuY3Rpb24gY29sbGVjdChtLCBhKSB7XG4gICAgZnVuY3Rpb24gaGVscGVyKHIpIHsgaWYgKCFtW3JdKSBjb2xsZWN0KG0sIG1bcl0gPSB0eXBlc1tyXSgpKTsgfVxuICAgIGlmIChhLnJlcSkgYS5yZXEuZm9yRWFjaChoZWxwZXIpO1xuICAgIGlmIChzdHJlYW0gJiYgYS5zdHIpIGEuc3RyLmZvckVhY2goaGVscGVyKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICB2YXIgbWFwID0gYWdnLnJlZHVjZShcbiAgICBjb2xsZWN0LFxuICAgIGFnZy5yZWR1Y2UoZnVuY3Rpb24obSwgYSkgeyByZXR1cm4gKG1bYS5uYW1lXSA9IGEsIG0pOyB9LCB7fSlcbiAgKTtcbiAgcmV0dXJuIHV0aWwudmFscyhtYXApLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShhZ2csIHN0cmVhbSwgYWNjZXNzb3IsIG11dGF0b3IpIHtcbiAgdmFyIGFsbCA9IHJlc29sdmUoYWdnLCBzdHJlYW0pLFxuICAgICAgY3RyID0gJ3RoaXMuY2VsbCA9IGNlbGw7IHRoaXMudHVwbGUgPSB0OyB0aGlzLnZhbGlkID0gMDsgdGhpcy5taXNzaW5nID0gMDsnLFxuICAgICAgYWRkID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmcrKzsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgKyt0aGlzLnZhbGlkOycsXG4gICAgICByZW0gPSAnaWYgKHY9PW51bGwpIHRoaXMubWlzc2luZy0tOyBpZiAoIXRoaXMuaXNWYWxpZCh2KSkgcmV0dXJuOyAtLXRoaXMudmFsaWQ7JyxcbiAgICAgIHNldCA9ICd2YXIgdCA9IHRoaXMudHVwbGU7IHZhciBjZWxsID0gdGhpcy5jZWxsOyc7XG5cbiAgYWxsLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIGlmIChhLmlkeCA8IDApIHtcbiAgICAgIGN0ciA9IGEuaW5pdCArIGN0cjtcbiAgICAgIGFkZCA9IGEuYWRkICsgYWRkO1xuICAgICAgcmVtID0gYS5yZW0gKyByZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0ciArPSBhLmluaXQ7XG4gICAgICBhZGQgKz0gYS5hZGQ7XG4gICAgICByZW0gKz0gYS5yZW07XG4gICAgfVxuICB9KTtcbiAgYWdnLnNsaWNlKClcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmlkeCAtIGIuaWR4OyB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHNldCArPSAndGhpcy5hc3NpZ24odCxcXCcnK2Eub3V0KydcXCcsJythLnNldCsnKTsnO1xuICAgIH0pO1xuICBzZXQgKz0gJ3JldHVybiB0Oyc7XG5cbiAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgY3RyID0gRnVuY3Rpb24oJ2NlbGwnLCAndCcsIGN0cik7XG4gIGN0ci5wcm90b3R5cGUuYXNzaWduID0gbXV0YXRvcjtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyBhZGQpO1xuICBjdHIucHJvdG90eXBlLnJlbSA9IEZ1bmN0aW9uKCd0JywgJ3ZhciB2ID0gdGhpcy5nZXQodCk7JyArIHJlbSk7XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gRnVuY3Rpb24oc2V0KTtcbiAgY3RyLnByb3RvdHlwZS5nZXQgPSBhY2Nlc3NvcjtcbiAgY3RyLnByb3RvdHlwZS5kaXN0aW5jdCA9IHJlcXVpcmUoJy4uL3N0YXRzJykuY291bnQuZGlzdGluY3Q7XG4gIGN0ci5wcm90b3R5cGUuaXNWYWxpZCA9IHV0aWwuaXNWYWxpZDtcbiAgY3RyLmZpZWxkcyA9IGFnZy5tYXAodXRpbC4kKCdvdXQnKSk7XG4gIHJldHVybiBjdHI7XG59XG5cbnR5cGVzLmNyZWF0ZSA9IGNyZWF0ZTtcbm1vZHVsZS5leHBvcnRzID0gdHlwZXM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4uL3RpbWUnKSxcbiAgICBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgZGF0ZSBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciB1bml0cyA9IG9wdC51dGMgPyB0aW1lLnV0YyA6IHRpbWUsXG4gICAgICBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBiaW5zID0gcmVxdWlyZSgnLi9iaW5zJyksXG4gICAgZ2VuICA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlJyksXG4gICAgdHlwZSA9IHJlcXVpcmUoJy4uL2ltcG9ydC90eXBlJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBzdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzJyk7XG5cbnZhciBxdHlwZSA9IHtcbiAgJ2ludGVnZXInOiAxLFxuICAnbnVtYmVyJzogMSxcbiAgJ2RhdGUnOiAxXG59O1xuXG5mdW5jdGlvbiAkYmluKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuICFiID8gKG9wdC5hY2Nlc3NvciB8fCB1dGlsLmlkZW50aXR5KSA6XG4gICAgdXRpbC4kZnVuYygnYmluJywgYi51bml0LnVuaXQgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZShiLnVuaXQudW5pdCh4KSk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZSh4KTsgfVxuICAgICkob3B0LmFjY2Vzc29yKTtcbn1cblxuZnVuY3Rpb24gaGlzdG9ncmFtKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuIGIgP1xuICAgIG51bWVyaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3NvciwgYikgOlxuICAgIGNhdGVnb3JpY2FsKHZhbHVlcywgb3B0LmFjY2Vzc29yLCBvcHQgJiYgb3B0LnNvcnQpO1xufVxuXG5mdW5jdGlvbiBzcGVjKG9wdCkge1xuICB2YXIgdCA9IG9wdC50eXBlLCBiID0gbnVsbDtcbiAgaWYgKHQgPT0gbnVsbCB8fCBxdHlwZVt0XSkge1xuICAgIGlmICh0ID09PSAnaW50ZWdlcicgJiYgb3B0Lm1pbnN0ZXAgPT0gbnVsbCkgb3B0Lm1pbnN0ZXAgPSAxO1xuICAgIGIgPSAodCA9PT0gJ2RhdGUnKSA/IGJpbnMuZGF0ZShvcHQpIDogYmlucyhvcHQpO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBvcHRpb25zKCkge1xuICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgIGkgPSAwLFxuICAgICAgdmFsdWVzID0gdXRpbC5pc0FycmF5KGFbaV0pID8gYVtpKytdIDogbnVsbCxcbiAgICAgIGYgPSB1dGlsLmlzRnVuY3Rpb24oYVtpXSkgfHwgdXRpbC5pc1N0cmluZyhhW2ldKSA/IHV0aWwuJChhW2krK10pIDogbnVsbCxcbiAgICAgIG9wdCA9IHV0aWwuZXh0ZW5kKHt9LCBhW2ldKTtcbiAgXG4gIGlmICh2YWx1ZXMpIHtcbiAgICBvcHQudHlwZSA9IG9wdC50eXBlIHx8IHR5cGUodmFsdWVzLCBmKTtcbiAgICBpZiAocXR5cGVbb3B0LnR5cGVdKSB7XG4gICAgICB2YXIgZXh0ID0gc3RhdHMuZXh0ZW50KHZhbHVlcywgZik7XG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7bWluOiBleHRbMF0sIG1heDogZXh0WzFdfSwgb3B0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGYpIHsgb3B0LmFjY2Vzc29yID0gZjsgfVxuICByZXR1cm4gb3B0O1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWwodmFsdWVzLCBmLCBiKSB7XG4gIHZhciBoID0gZ2VuLnJhbmdlKGIuc3RhcnQsIGIuc3RvcCArIGIuc3RlcC8yLCBiLnN0ZXApXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB7dmFsdWU6IGIudmFsdWUodiksIGNvdW50OiAwfTsgfSk7XG5cbiAgZm9yICh2YXIgaT0wLCB2LCBqOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGogPSBiLmluZGV4KHYpO1xuICAgICAgaWYgKGogPCAwIHx8IGogPj0gaC5sZW5ndGggfHwgIWlzRmluaXRlKGopKSBjb250aW51ZTtcbiAgICAgIGhbal0uY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgaC5iaW5zID0gYjtcbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGNhdGVnb3JpY2FsKHZhbHVlcywgZiwgc29ydCkge1xuICB2YXIgdSA9IHN0YXRzLnVuaXF1ZSh2YWx1ZXMsIGYpLFxuICAgICAgYyA9IHN0YXRzLmNvdW50Lm1hcCh2YWx1ZXMsIGYpO1xuICByZXR1cm4gdS5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4ge3ZhbHVlOiBrLCBjb3VudDogY1trXX07IH0pXG4gICAgLnNvcnQodXRpbC5jb21wYXJhdG9yKHNvcnQgPyAnLWNvdW50JyA6ICcrdmFsdWUnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAkYmluOiAkYmluLFxuICBoaXN0b2dyYW06IGhpc3RvZ3JhbVxufTsiLCJ2YXIgZDNfdGltZSA9IHJlcXVpcmUoJ2QzLXRpbWUnKSxcbiAgICBkM190aW1lRiA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JyksXG4gICAgZDNfbnVtYmVyRiA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpLFxuICAgIG51bWJlckYgPSBkM19udW1iZXJGLCAvLyBkZWZhdWx0cyB0byBFTi1VU1xuICAgIHRpbWVGID0gZDNfdGltZUY7ICAgICAvLyBkZWZhdWx0cyB0byBFTi1VU1xuXG5mdW5jdGlvbiBudW1iZXJMb2NhbGUobCkge1xuICB2YXIgZiA9IGQzX251bWJlckYubG9jYWxlRm9ybWF0KGwpO1xuICBpZiAoZiA9PSBudWxsKSB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIGxvY2FsZTogJyArIGwpO1xuICBudW1iZXJGID0gZjtcbn1cblxuZnVuY3Rpb24gdGltZUxvY2FsZShsKSB7XG4gIHZhciBmID0gZDNfdGltZUYubG9jYWxlRm9ybWF0KGwpO1xuICBpZiAoZiA9PSBudWxsKSB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIGxvY2FsZTogJyArIGwpO1xuICB0aW1lRiA9IGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBVcGRhdGUgbnVtYmVyIGZvcm1hdHRlciB0byB1c2UgcHJvdmlkZWQgbG9jYWxlIGNvbmZpZ3VyYXRpb24uXG4gIC8vIEZvciBtb3JlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZm9ybWF0XG4gIG51bWJlckxvY2FsZTogbnVtYmVyTG9jYWxlLFxuICBudW1iZXI6ICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIG51bWJlckYuZm9ybWF0KGYpOyB9LFxuICBudW1iZXJQcmVmaXg6IGZ1bmN0aW9uKGYsIHYpIHsgcmV0dXJuIG51bWJlckYuZm9ybWF0UHJlZml4KGYsIHYpOyB9LFxuXG4gIC8vIFVwZGF0ZSB0aW1lIGZvcm1hdHRlciB0byB1c2UgcHJvdmlkZWQgbG9jYWxlIGNvbmZpZ3VyYXRpb24uXG4gIC8vIEZvciBtb3JlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXRcbiAgdGltZUxvY2FsZTogICB0aW1lTG9jYWxlLFxuICB0aW1lOiAgICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHRpbWVGLmZvcm1hdChmKTsgfSwgIFxuICB1dGM6ICAgICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHRpbWVGLnV0Y0Zvcm1hdChmKTsgfSxcblxuICAvLyBTZXQgbnVtYmVyIGFuZCB0aW1lIGxvY2FsZSBzaW11bHRhbmVvdXNseS5cbiAgbG9jYWxlOiAgICAgICBmdW5jdGlvbihsKSB7IG51bWJlckxvY2FsZShsKTsgdGltZUxvY2FsZShsKTsgfSxcblxuICAvLyBhdXRvbWF0aWMgZm9ybWF0dGluZyBmdW5jdGlvbnNcbiAgYXV0bzoge1xuICAgIG51bWJlcjogICBudW1iZXJBdXRvRm9ybWF0LFxuICAgIHRpbWU6ICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVBdXRvRm9ybWF0KCk7IH0sXG4gICAgdXRjOiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXRjQXV0b0Zvcm1hdCgpOyB9XG4gIH1cbn07XG5cbnZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZnVuY3Rpb24gaW50ZXJ2YWxzKGRvbWFpbiwgY291bnQpIHtcbiAgaWYgKCFkb21haW4ubGVuZ3RoKSBkb21haW4gPSBbMF07XG4gIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzdG9wIDwgc3RhcnQpIHsgZXJyb3IgPSBzdG9wOyBzdG9wID0gc3RhcnQ7IHN0YXJ0ID0gZXJyb3I7IH1cblxuICB2YXIgc3BhbiA9IChzdG9wIC0gc3RhcnQpIHx8IChjb3VudCA9IDEsIHN0YXJ0IHx8IHN0b3AgfHwgMSksXG4gICAgICBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIGNvdW50KSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzcGFuIC8gY291bnQgLyBzdGVwO1xuXG4gIC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcCAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcCAqPSAyO1xuXG4gIC8vIFJvdW5kIHN0YXJ0IGFuZCBzdG9wIHZhbHVlcyB0byBzdGVwIGludGVydmFsLlxuICByZXR1cm4gW1xuICAgIE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCxcbiAgICBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXAgKyBzdGVwIC8gMiwgLy8gaW5jbHVzaXZlXG4gICAgc3RlcFxuICBdO1xufVxuXG5mdW5jdGlvbiBudW1iZXJBdXRvRm9ybWF0KGRvbWFpbiwgY291bnQsIGYpIHtcbiAgdmFyIHJhbmdlID0gaW50ZXJ2YWxzKGRvbWFpbiwgY291bnQpO1xuICBpZiAoZiA9PSBudWxsKSB7XG4gICAgZiA9ICcsLicgKyBkM19udW1iZXJGLnByZWNpc2lvbkZpeGVkKHJhbmdlWzJdKSArICdmJztcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGYgPSBkM19udW1iZXJGLmZvcm1hdFNwZWNpZmllcihmKSwgZi50eXBlKSB7XG4gICAgICBjYXNlICdzJzoge1xuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhyYW5nZVswXSksIE1hdGguYWJzKHJhbmdlWzFdKSk7XG4gICAgICAgIGlmIChmLnByZWNpc2lvbiA9PSBudWxsKSBmLnByZWNpc2lvbiA9IGQzX251bWJlckYucHJlY2lzaW9uUHJlZml4KHJhbmdlWzJdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBudW1iZXJGLmZvcm1hdFByZWZpeChmLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjYXNlICcnOlxuICAgICAgY2FzZSAnZSc6XG4gICAgICBjYXNlICdnJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAncic6IHtcbiAgICAgICAgaWYgKGYucHJlY2lzaW9uID09IG51bGwpIGYucHJlY2lzaW9uID0gZDNfbnVtYmVyRi5wcmVjaXNpb25Sb3VuZChyYW5nZVsyXSwgTWF0aC5tYXgoTWF0aC5hYnMocmFuZ2VbMF0pLCBNYXRoLmFicyhyYW5nZVsxXSkpKSAtIChmLnR5cGUgPT09ICdlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZic6XG4gICAgICBjYXNlICclJzoge1xuICAgICAgICBpZiAoZi5wcmVjaXNpb24gPT0gbnVsbCkgZi5wcmVjaXNpb24gPSBkM19udW1iZXJGLnByZWNpc2lvbkZpeGVkKHJhbmdlWzJdKSAtIChmLnR5cGUgPT09ICclJykgKiAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlckYuZm9ybWF0KGYpO1xufVxuXG5mdW5jdGlvbiB0aW1lQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi5mb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnNlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUubWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUuaG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLmRheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS5tb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLndlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnllYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXRjQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi51dGNGb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnV0Y1NlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjTWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjSG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLnV0Y0RheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS51dGNNb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLnV0Y1dlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnV0Y1llYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW4gPT09IHVuZGVmaW5lZCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBkM19kc3YgPSByZXF1aXJlKCdkMy1kc3YnKTtcblxuZnVuY3Rpb24gZHN2KGRhdGEsIGZvcm1hdCkge1xuICBpZiAoZGF0YSkge1xuICAgIHZhciBoID0gZm9ybWF0LmhlYWRlcjtcbiAgICBkYXRhID0gKGggPyBoLmpvaW4oZm9ybWF0LmRlbGltaXRlcikgKyAnXFxuJyA6ICcnKSArIGRhdGE7XG4gIH1cbiAgcmV0dXJuIGQzX2Rzdi5kc3YoZm9ybWF0LmRlbGltaXRlcikucGFyc2UoZGF0YSk7XG59XG5cbmRzdi5kZWxpbWl0ZXIgPSBmdW5jdGlvbihkZWxpbSkge1xuICB2YXIgZm10ID0ge2RlbGltaXRlcjogZGVsaW19O1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyB1dGlsLmV4dGVuZChmb3JtYXQsIGZtdCkgOiBmbXQpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkc3Y7IiwidmFyIGRzdiA9IHJlcXVpcmUoJy4vZHN2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKSxcbiAgZHN2OiBkc3YsXG4gIGNzdjogZHN2LmRlbGltaXRlcignLCcpLFxuICB0c3Y6IGRzdi5kZWxpbWl0ZXIoJ1xcdCcpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IHV0aWwuaXNPYmplY3QoZGF0YSkgJiYgIXV0aWwuaXNCdWZmZXIoZGF0YSkgP1xuICAgIGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5wcm9wZXJ0eSkge1xuICAgIGQgPSB1dGlsLmFjY2Vzc29yKGZvcm1hdC5wcm9wZXJ0eSkoZCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59O1xuIiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcblxudmFyIHJlYWRlciA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdG9wb2pzb24gPSByZWFkZXIudG9wb2pzb247XG4gIGlmICh0b3BvanNvbiA9PSBudWxsKSB7IHRocm93IEVycm9yKCdUb3BvSlNPTiBsaWJyYXJ5IG5vdCBsb2FkZWQuJyk7IH1cblxuICB2YXIgdCA9IGpzb24oZGF0YSwgZm9ybWF0KSwgb2JqO1xuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LmZlYXR1cmUpIHtcbiAgICBpZiAoKG9iaiA9IHQub2JqZWN0c1tmb3JtYXQuZmVhdHVyZV0pKSB7XG4gICAgICByZXR1cm4gdG9wb2pzb24uZmVhdHVyZSh0LCBvYmopLmZlYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6ICcgKyBmb3JtYXQuZmVhdHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCAmJiBmb3JtYXQubWVzaCkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSkpIHtcbiAgICAgIHJldHVybiBbdG9wb2pzb24ubWVzaCh0LCB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIGZvcm1hdC5tZXNoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxufTtcblxucmVhZGVyLnRvcG9qc29uID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3RvcG9qc29uJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd0b3BvanNvbiddIDogbnVsbCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRlcjsiLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdG9UYWJsZShkYXRhLCAoZm9ybWF0ICYmIGZvcm1hdC5jaGlsZHJlbikpO1xufTtcblxuZnVuY3Rpb24gdG9UYWJsZShyb290LCBjaGlsZHJlbkZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8ICdjaGlsZHJlbic7XG4gIHZhciB0YWJsZSA9IFtdO1xuICBcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufSIsIi8vIE1hdGNoZXMgYWJzb2x1dGUgVVJMcyB3aXRoIG9wdGlvbmFsIHByb3RvY29sXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cbnZhciBwcm90b2NvbF9yZSA9IC9eKFtBLVphLXpdKzopP1xcL1xcLy87XG5cbi8vIFNwZWNpYWwgdHJlYXRtZW50IGluIG5vZGUuanMgZm9yIHRoZSBmaWxlOiBwcm90b2NvbFxudmFyIGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcblxuLy8gVmFsaWRhdGUgYW5kIGNsZWFudXAgVVJMIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGFsbG93ZWQgdG8gYmUgYWNjZXNzZWRcbi8vIFJldHVybnMgY2xlYW5lZCB1cCBVUkwsIG9yIGZhbHNlIGlmIGFjY2VzcyBpcyBub3QgYWxsb3dlZFxuZnVuY3Rpb24gc2FuaXRpemVVcmwob3B0KSB7XG4gIHZhciB1cmwgPSBvcHQudXJsO1xuICBpZiAoIXVybCAmJiBvcHQuZmlsZSkgeyByZXR1cm4gZmlsZVByb3RvY29sICsgb3B0LmZpbGU7IH1cblxuICAvLyBJbiBjYXNlIHRoaXMgaXMgYSByZWxhdGl2ZSB1cmwgKGhhcyBubyBob3N0KSwgcHJlcGVuZCBvcHQuYmFzZVVSTFxuICBpZiAob3B0LmJhc2VVUkwgJiYgIXByb3RvY29sX3JlLnRlc3QodXJsKSkge1xuICAgIGlmICghc3RhcnRzV2l0aCh1cmwsICcvJykgJiYgb3B0LmJhc2VVUkxbb3B0LmJhc2VVUkwubGVuZ3RoLTFdICE9PSAnLycpIHtcbiAgICAgIHVybCA9ICcvJyArIHVybDsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgfVxuICAgIHVybCA9IG9wdC5iYXNlVVJMICsgdXJsO1xuICB9XG4gIC8vIHJlbGF0aXZlIHByb3RvY29sLCBzdGFydHMgd2l0aCAnLy8nXG4gIGlmICghbG9hZC51c2VYSFIgJiYgc3RhcnRzV2l0aCh1cmwsICcvLycpKSB7XG4gICAgdXJsID0gKG9wdC5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVybDtcbiAgfVxuICAvLyBJZiBvcHQuZG9tYWluV2hpdGVMaXN0IGlzIHNldCwgb25seSBhbGxvd3MgdXJsLCB3aG9zZSBob3N0bmFtZVxuICAvLyAqIElzIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW4gKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSlcbiAgLy8gKiBFcXVhbHMgb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICAvLyAqIElzIGEgcHJvcGVyIHN1YmRvbWFpbiBvZiBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIGlmIChvcHQuZG9tYWluV2hpdGVMaXN0KSB7XG4gICAgdmFyIGRvbWFpbiwgb3JpZ2luO1xuICAgIGlmIChsb2FkLnVzZVhIUikge1xuICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM2NTEzL2hvdy1kby1pLXBhcnNlLWEtdXJsLWludG8taG9zdG5hbWUtYW5kLXBhdGgtaW4tamF2YXNjcmlwdFxuICAgICAgLy8gSUUgZG9lc24ndCBwb3B1bGF0ZSBhbGwgbGluayBwcm9wZXJ0aWVzIHdoZW4gc2V0dGluZyAuaHJlZiB3aXRoIGEgcmVsYXRpdmUgVVJMLFxuICAgICAgLy8gaG93ZXZlciAuaHJlZiB3aWxsIHJldHVybiBhbiBhYnNvbHV0ZSBVUkwgd2hpY2ggdGhlbiBjYW4gYmUgdXNlZCBvbiBpdHNlbGZcbiAgICAgIC8vIHRvIHBvcHVsYXRlIHRoZXNlIGFkZGl0aW9uYWwgZmllbGRzLlxuICAgICAgaWYgKGEuaG9zdCA9PT0gJycpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWxhdGl2ZSBwcm90b2NvbCBpcyBicm9rZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtdXJsL2lzc3Vlcy81XG4gICAgICB2YXIgcGFydHMgPSByZXF1aXJlKCd1cmwnKS5wYXJzZSh1cmwpO1xuICAgICAgZG9tYWluID0gcGFydHMuaG9zdG5hbWU7XG4gICAgICBvcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGlkeCA9IGRvbWFpbi5sZW5ndGggLSBkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGQgPT09IGRvbWFpbiB8fFxuICAgICAgICAgIChpZHggPiAxICYmIGRvbWFpbltpZHgtMV0gPT09ICcuJyAmJiBkb21haW4ubGFzdEluZGV4T2YoZCkgPT09IGlkeCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghd2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgJ1VSTCBpcyBub3Qgd2hpdGVsaXN0ZWQ6ICcgKyB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGxvYWQob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH0sIHVybDtcblxuICB0cnkge1xuICAgIHVybCA9IGxvYWQuc2FuaXRpemVVcmwob3B0KTsgLy8gZW5hYmxlIG92ZXJyaWRlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBlcnJvcignSW52YWxpZCBVUkw6ICcgKyBvcHQudXJsKTtcbiAgfSBlbHNlIGlmIChsb2FkLnVzZVhIUikge1xuICAgIC8vIG9uIGNsaWVudCwgdXNlIHhoclxuICAgIHJldHVybiB4aHIodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh1cmwsIGZpbGVQcm90b2NvbCkpIHtcbiAgICAvLyBvbiBzZXJ2ZXIsIGlmIHVybCBzdGFydHMgd2l0aCAnZmlsZTovLycsIHN0cmlwIGl0IGFuZCBsb2FkIGZyb20gZmlsZVxuICAgIHJldHVybiBmaWxlKHVybC5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHVybC5pbmRleE9mKCc6Ly8nKSA8IDApIHsgLy8gVE9ETyBiZXR0ZXIgcHJvdG9jb2wgY2hlY2s/XG4gICAgLy8gb24gc2VydmVyLCBpZiBubyBwcm90b2NvbCBhc3N1bWUgZmlsZVxuICAgIHJldHVybiBmaWxlKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgb24gc2VydmVyXG4gICAgcmV0dXJuIGh0dHAodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24geGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSAndGV4dCcgP1xuICAgIHJlcXVlc3QucmVzcG9uc2UgOiAvLyBudWxsIG9uIGVycm9yXG4gICAgcmVxdWVzdC5yZXNwb25zZVRleHQ7IC8vICcnIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmXG4gICAgICAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgaWYgKCdvbmxvYWQnIGluIHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMpIHJlc3BvbmQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuICByZXF1ZXN0LnNlbmQoKTtcbiAgXG4gIGlmICghYXN5bmMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIH1cbiAgZnMucmVhZEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIFxuICB2YXIgb3B0aW9ucyA9IHt1cmw6IHVybCwgZW5jb2Rpbmc6IG51bGwsIGd6aXA6IHRydWV9O1xuICByZXF1aXJlKCdyZXF1ZXN0Jykob3B0aW9ucywgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IGVycm9yIHx8XG4gICAgICAgICdMb2FkIGZhaWxlZCB3aXRoIHJlc3BvbnNlIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnLic7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICByZXR1cm4gc3RyaW5nID09IG51bGwgPyBmYWxzZSA6IHN0cmluZy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIDApID09PSAwO1xufVxuXG5sb2FkLnNhbml0aXplVXJsID0gc2FuaXRpemVVcmw7XG5cbmxvYWQudXNlWEhSID0gKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5mdW5jdGlvbiByZWFkKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdHlwZSA9IChmb3JtYXQgJiYgZm9ybWF0LnR5cGUpIHx8ICdqc29uJztcbiAgZGF0YSA9IGZvcm1hdHNbdHlwZV0oZGF0YSwgZm9ybWF0KTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucGFyc2UpIHBhcnNlKGRhdGEsIGZvcm1hdC5wYXJzZSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcykge1xuICB2YXIgY29scywgcGFyc2VycywgZCwgaSwgaiwgY2xlbiwgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgdHlwZXMgPSAodHlwZXM9PT0nYXV0bycpID8gdHlwZS5pbmZlckFsbChkYXRhKSA6IHV0aWwuZHVwbGljYXRlKHR5cGVzKTtcbiAgY29scyA9IHV0aWwua2V5cyh0eXBlcyk7XG4gIHBhcnNlcnMgPSBjb2xzLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiB0eXBlLnBhcnNlcnNbdHlwZXNbY11dOyB9KTtcblxuICBmb3IgKGk9MCwgY2xlbj1jb2xzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wOyBqPGNsZW47ICsraikge1xuICAgICAgZFtjb2xzW2pdXSA9IHBhcnNlcnNbal0oZFtjb2xzW2pdXSk7XG4gICAgfVxuICB9XG4gIHR5cGUuYW5ub3RhdGlvbihkYXRhLCB0eXBlcyk7XG59XG5cbnJlYWQuZm9ybWF0cyA9IGZvcm1hdHM7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsb2FkID0gcmVxdWlyZSgnLi9sb2FkJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJy4vcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxcbiAgLmtleXMocmVhZC5mb3JtYXRzKVxuICAucmVkdWNlKGZ1bmN0aW9uKG91dCwgdHlwZSkge1xuICAgIG91dFt0eXBlXSA9IGZ1bmN0aW9uKG9wdCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgLy8gcHJvY2VzcyBhcmd1bWVudHNcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9wdCkpIHsgb3B0ID0ge3VybDogb3B0fTsgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIHsgY2FsbGJhY2soZXJyb3IsIG51bGwpOyByZXR1cm47IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChzeW5jKVxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgVFlQRVMgPSAnX190eXBlc19fJztcblxudmFyIFBBUlNFUlMgPSB7XG4gIGJvb2xlYW46IHV0aWwuYm9vbGVhbixcbiAgaW50ZWdlcjogdXRpbC5udW1iZXIsXG4gIG51bWJlcjogIHV0aWwubnVtYmVyLFxuICBkYXRlOiAgICB1dGlsLmRhdGUsXG4gIHN0cmluZzogIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0nJyA/IG51bGwgOiB4OyB9XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0ndHJ1ZScgfHwgeD09PSdmYWxzZScgfHwgdXRpbC5pc0Jvb2xlYW4oeCk7IH0sXG4gIGludGVnZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFRFU1RTLm51bWJlcih4KSAmJiAoeD0reCkgPT09IH5+eDsgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oK3gpICYmICF1dGlsLmlzRGF0ZSh4KTsgfSxcbiAgZGF0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UoeCkpOyB9XG59O1xuXG5mdW5jdGlvbiBhbm5vdGF0aW9uKGRhdGEsIHR5cGVzKSB7XG4gIGlmICghdHlwZXMpIHJldHVybiBkYXRhICYmIGRhdGFbVFlQRVNdIHx8IG51bGw7XG4gIGRhdGFbVFlQRVNdID0gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIHR5cGUodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICByZXR1cm4gKHR5cGVzW2ZdID0gdHlwZShkYXRhLCBmKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWQodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlckFsbChkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB0eXBlc1tmXSA9IGluZmVyKGRhdGEsIGYpO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG50eXBlLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xudHlwZS5hbGwgPSB0eXBlQWxsO1xudHlwZS5pbmZlciA9IGluZmVyO1xudHlwZS5pbmZlckFsbCA9IGluZmVyQWxsO1xudHlwZS5wYXJzZXJzID0gUEFSU0VSUztcbm1vZHVsZS5leHBvcnRzID0gdHlwZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgZGwgPSB7XG4gIHZlcnNpb246ICAgICcxLjQuNicsXG4gIGxvYWQ6ICAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWQnKSxcbiAgcmVhZDogICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpLFxuICB0eXBlOiAgICAgICByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyksXG4gIEFnZ3JlZ2F0b3I6IHJlcXVpcmUoJy4vYWdncmVnYXRlL2FnZ3JlZ2F0b3InKSxcbiAgZ3JvdXBieTogICAgcmVxdWlyZSgnLi9hZ2dyZWdhdGUvZ3JvdXBieScpLFxuICBiaW5zOiAgICAgICByZXF1aXJlKCcuL2JpbnMvYmlucycpLFxuICAkYmluOiAgICAgICByZXF1aXJlKCcuL2JpbnMvaGlzdG9ncmFtJykuJGJpbixcbiAgaGlzdG9ncmFtOiAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLmhpc3RvZ3JhbSxcbiAgZm9ybWF0OiAgICAgcmVxdWlyZSgnLi9mb3JtYXQnKSxcbiAgcHJpbnQ6ICAgICAgcmVxdWlyZSgnLi9wcmludCcpLFxuICB0ZW1wbGF0ZTogICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gIHRpbWU6ICAgICAgIHJlcXVpcmUoJy4vdGltZScpXG59O1xuXG51dGlsLmV4dGVuZChkbCwgdXRpbCk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9nZW5lcmF0ZScpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL3N0YXRzJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vaW1wb3J0L3JlYWRlcnMnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGw7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpO1xudmFyIHN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG52YXIgRk1UID0ge1xuICAnZGF0ZSc6ICAgICd8dGltZTpcIiVtLyVkLyVZICVIOiVNOiVTXCInLFxuICAnbnVtYmVyJzogICd8bnVtYmVyOlwiLjRmXCInLFxuICAnaW50ZWdlcic6ICd8bnVtYmVyOlwiZFwiJ1xufTtcblxudmFyIFBPUyA9IHtcbiAgJ251bWJlcic6ICAnbGVmdCcsXG4gICdpbnRlZ2VyJzogJ2xlZnQnXG59O1xuXG5tb2R1bGUuZXhwb3J0cy50YWJsZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdCkge1xuICBvcHQgPSB1dGlsLmV4dGVuZCh7c2VwYXJhdG9yOicgJywgbWlud2lkdGg6IDgsIG1heHdpZHRoOiAxNX0sIG9wdCk7XG4gIHZhciBmaWVsZHMgPSBvcHQuZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKSxcbiAgICAgIHR5cGVzID0gdHlwZS5hbGwoZGF0YSk7XG5cbiAgaWYgKG9wdC5zdGFydCB8fCBvcHQubGltaXQpIHtcbiAgICB2YXIgYSA9IG9wdC5zdGFydCB8fCAwLFxuICAgICAgICBiID0gb3B0LmxpbWl0ID8gYSArIG9wdC5saW1pdCA6IGRhdGEubGVuZ3RoO1xuICAgIGRhdGEgPSBkYXRhLnNsaWNlKGEsIGIpO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGNoYXIgd2lkdGggb2YgZmllbGRzXG4gIHZhciBsZW5zID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGZvcm1hdCA9IEZNVFt0eXBlc1tuYW1lXV0gfHwgJycsXG4gICAgICAgIHQgPSB0ZW1wbGF0ZSgne3snICsgbmFtZSArIGZvcm1hdCArICd9fScpLFxuICAgICAgICBsID0gc3RhdHMubWF4KGRhdGEsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHQoeCkubGVuZ3RoOyB9KTtcbiAgICBsID0gTWF0aC5tYXgoTWF0aC5taW4obmFtZS5sZW5ndGgsIG9wdC5taW53aWR0aCksIGwpO1xuICAgIHJldHVybiBvcHQubWF4d2lkdGggPiAwID8gTWF0aC5taW4obCwgb3B0Lm1heHdpZHRoKSA6IGw7XG4gIH0pO1xuXG4gIC8vIHByaW50IGhlYWRlciByb3dcbiAgdmFyIGhlYWQgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gdXRpbC50cnVuY2F0ZSh1dGlsLnBhZChuYW1lLCBsZW5zW2ldLCAnY2VudGVyJyksIGxlbnNbaV0pO1xuICB9KS5qb2luKG9wdC5zZXBhcmF0b3IpO1xuXG4gIC8vIGJ1aWxkIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciBlYWNoIHJvd1xuICB2YXIgdG1wbCA9IHRlbXBsYXRlKGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiAne3snICtcbiAgICAgIG5hbWUgK1xuICAgICAgKEZNVFt0eXBlc1tuYW1lXV0gfHwgJycpICtcbiAgICAgICgnfHBhZDonICsgbGVuc1tpXSArICcsJyArIChQT1NbdHlwZXNbbmFtZV1dIHx8ICdyaWdodCcpKSArXG4gICAgICAoJ3x0cnVuY2F0ZTonICsgbGVuc1tpXSkgK1xuICAgICd9fSc7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcikpO1xuXG4gIC8vIHByaW50IHRhYmxlXG4gIHJldHVybiBoZWFkICsgXCJcXG5cIiArIGRhdGEubWFwKHRtcGwpLmpvaW4oJ1xcbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3VtbWFyeSA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IHMgPyBzLl9fc3VtbWFyeV9fID8gcyA6IHN0YXRzLnN1bW1hcnkocykgOiB0aGlzO1xuICB2YXIgc3RyID0gW10sIGksIG47XG4gIGZvciAoaT0wLCBuPXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ci5wdXNoKCctLSAnICsgc1tpXS5maWVsZCArICcgLS0nKTtcbiAgICBpZiAoc1tpXS50eXBlID09PSAnc3RyaW5nJyB8fCBzW2ldLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHNbaV0pKTtcbiAgICB9XG4gICAgc3RyLnB1c2goJycpO1xuICB9XG4gIHJldHVybiBzdHIuam9pbignXFxuJyk7XG59O1xuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ21pbjogICAgICAnICsgcC5taW4sXG4gICAgJ21heDogICAgICAnICsgcC5tYXgsXG4gICAgJ21lZGlhbjogICAnICsgcC5tZWRpYW4sXG4gICAgJ21lYW46ICAgICAnICsgcC5tZWFuLFxuICAgICdzdGRldjogICAgJyArIHAuc3RkZXYsXG4gICAgJ21vZGVza2V3OiAnICsgcC5tb2Rlc2tld1xuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSB7XG4gIHZhciBsaXN0ID0gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ3RvcCB2YWx1ZXM6ICdcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnIFxcJycgKyB2ICsgJ1xcJyAoJyArIHVbdl0gKyAnKSc7IH0pO1xuICByZXR1cm4gbGlzdC5jb25jYXQodG9wKS5qb2luKCdcXG4nKTtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gZmlyc3Qtb2JzZXJ2ZWQgb3JkZXJcbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBmID0gdXRpbC4kKGYpO1xuICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICByZXN1bHRzLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgYXJyYXkuXG5zdGF0cy5jb3VudCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggfHwgMDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwsIG5vbi11bmRlZmluZWQsIG5vbi1OYU4gdmFsdWVzLlxuc3RhdHMuY291bnQudmFsaWQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIHZhbGlkID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB2YWxpZCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzLlxuc3RhdHMuY291bnQubWlzc2luZyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4vLyBOdWxsLCB1bmRlZmluZWQgYW5kIE5hTiBhcmUgZWFjaCBjb25zaWRlcmVkIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB1ID0ge30sIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGRpc3RpbmN0IHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLmNvdW50Lm1hcCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWFwID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgbWFwW3ZdID0gKHYgaW4gbWFwKSA/IG1hcFt2XSArIDEgOiAxO1xuICB9XG4gIHJldHVybiBtYXA7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHJldHVybiBzdGF0cy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgcXVhcnRpbGUgYm91bmRhcmllcyBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMucXVhcnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICB2YXIgcSA9IHN0YXRzLnF1YW50aWxlO1xuICByZXR1cm4gW3EodmFsdWVzLCAwLjI1KSwgcSh2YWx1ZXMsIDAuNTApLCBxKHZhbHVlcywgMC43NSldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgcXVhbnRpbGUgb2YgYSBzb3J0ZWQgYXJyYXkgb2YgbnVtYmVycy5cbi8vIEFkYXB0ZWQgZnJvbSB0aGUgRDMuanMgaW1wbGVtZW50YXRpb24uXG5zdGF0cy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcCkge1xuICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7IHAgPSBmOyBmID0gdXRpbC5pZGVudGl0eTsgfVxuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSxcbiAgICAgIGggPSBNYXRoLmZsb29yKEgpLFxuICAgICAgdiA9ICtmKHZhbHVlc1toIC0gMV0pLFxuICAgICAgZSA9IEggLSBoO1xuICByZXR1cm4gZSA/IHYgKyBlICogKGYodmFsdWVzW2hdKSAtIHYpIDogdjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3VtID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGZvciAodmFyIHN1bT0wLCBpPTAsIG49dmFsdWVzLmxlbmd0aCwgdjsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSBzdW0gKz0gdjtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgbiwgYywgdjtcbiAgZm9yIChpPTAsIGM9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlLFxuICBwYWQ6ICAgICAgICB1dGlsLnBhZFxufTtcblxuZnVuY3Rpb24gdGVtcGxhdGUodGV4dCkge1xuICB2YXIgc3JjID0gc291cmNlKHRleHQsICdkJyk7XG4gIHNyYyA9ICd2YXIgX190OyByZXR1cm4gJyArIHNyYyArICc7JztcblxuICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICByZXR1cm4gKG5ldyBGdW5jdGlvbignZCcsIHNyYykpLmJpbmQoY29udGV4dCk7XG59XG5cbnRlbXBsYXRlLnNvdXJjZSA9IHNvdXJjZTtcbnRlbXBsYXRlLmNvbnRleHQgPSBjb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuLy8gQ2xlYXIgY2FjaGUgb2YgZm9ybWF0IG9iamVjdHMuXG4vLyBUaGlzIGNhbiAqYnJlYWsqIHByaW9yIHRlbXBsYXRlIGZ1bmN0aW9ucywgc28gaW52b2tlIHdpdGggY2FyZSFcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuLy8gR2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzIGNvZGUgZm9yIHVzZSB3aXRoaW4gdGVtcGxhdGUgc291cmNlLlxuLy8gb2JqZWN0OiB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0ICh2YXJpYWJsZSkgY29udGFpbmluZyB0ZW1wbGF0ZSBkYXRhXG4vLyBwcm9wZXJ0eTogdGhlIHByb3BlcnR5IGFjY2VzcyBzdHJpbmcsIHZlcmJhdGltIGZyb20gdGVtcGxhdGUgdGFnXG50ZW1wbGF0ZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIHNyYyA9IHV0aWwuZmllbGQocHJvcGVydHkpLm1hcCh1dGlsLnN0cikuam9pbignXVsnKTtcbiAgcmV0dXJuIG9iamVjdCArICdbJyArIHNyYyArICddJztcbn07XG5cbi8vIEdlbmVyYXRlIHNvdXJjZSBjb2RlIGZvciBhIHRlbXBsYXRlIGZ1bmN0aW9uLlxuLy8gdGV4dDogdGhlIHRlbXBsYXRlIHRleHRcbi8vIHZhcmlhYmxlOiB0aGUgbmFtZSBvZiB0aGUgZGF0YSBvYmplY3QgdmFyaWFibGUgKCdvYmonIGJ5IGRlZmF1bHQpXG4vLyBwcm9wZXJ0aWVzOiBvcHRpb25hbCBoYXNoIGZvciBjb2xsZWN0aW5nIGFsbCBhY2Nlc3NlZCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBzb3VyY2UodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyaWFibGUgPSB2YXJpYWJsZSB8fCAnb2JqJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHNyYyA9ICdcXCcnO1xuICB2YXIgcmVnZXggPSB0ZW1wbGF0ZV9yZTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBpbnRlcnBvbGF0ZSwgb2Zmc2V0KSB7XG4gICAgc3JjICs9IHRleHRcbiAgICAgIC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UodGVtcGxhdGVfZXNjYXBlciwgdGVtcGxhdGVfZXNjYXBlQ2hhcik7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgIHNyYyArPSAnXFwnXFxuKygoX190PSgnICtcbiAgICAgICAgdGVtcGxhdGVfdmFyKGludGVycG9sYXRlLCB2YXJpYWJsZSwgcHJvcGVydGllcykgK1xuICAgICAgICAnKSk9PW51bGw/XFwnXFwnOl9fdCkrXFxuXFwnJztcbiAgICB9XG5cbiAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcbiAgcmV0dXJuIHNyYyArICdcXCcnO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZV92YXIodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGZpbHRlcnMgPSB0ZXh0Lm1hdGNoKGZpbHRlcl9yZSk7XG4gIHZhciBwcm9wID0gZmlsdGVycy5zaGlmdCgpLnRyaW0oKTtcbiAgdmFyIHN0cmluZ0Nhc3QgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8ICcnO1xuICAgIGlmIChzdHJpbmdDYXN0KSB7XG4gICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICBzcmMgPSAnU3RyaW5nKCcgKyBzcmMgKyAnKScgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG5cbiAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gJyh0eXBlb2YgJyArIHNyYyArICc9PT1cIm51bWJlclwiP25ldyBEYXRlKCcrc3JjKycpOicrc3JjKycpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG51bWJlcl9mb3JtYXQoZm10LCBrZXkpIHtcbiAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGtleSwgZm10KTtcbiAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytzcmMrJyknO1xuICB9XG4gIFxuICBmdW5jdGlvbiB0aW1lX2Zvcm1hdChmbXQsIGtleSkge1xuICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwga2V5LCBmbXQpO1xuICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK2RhdGUoKSsnKSc7XG4gIH1cblxuICBpZiAocHJvcGVydGllcykgcHJvcGVydGllc1twcm9wXSA9IDE7XG4gIHZhciBzcmMgPSB0ZW1wbGF0ZS5wcm9wZXJ0eSh2YXJpYWJsZSwgcHJvcCk7XG5cbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKVxuICAgICAgICAubWF0Y2goYXJnc19yZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfSk7XG4gICAgfVxuICAgIGYgPSBmLnRyaW0oKTtcblxuICAgIHN3aXRjaCAoZikge1xuICAgICAgY2FzZSAnbGVuZ3RoJzpcbiAgICAgICAgc3RyY2FsbCgnLmxlbmd0aCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b1VwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVVcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RyaW0nOlxuICAgICAgICBzdHJjYWxsKCcudHJpbSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKDAsJyArIGEgKyAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoLScgKyBhICsnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGEgKyB1dGlsLm51bWJlcihhcmdzWzFdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCsnK2ErJywnK2IrJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzbGljZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCcrIGEgK1xuICAgICAgICAgIChhcmdzLmxlbmd0aCA+IDEgPyAnLCcgKyB1dGlsLm51bWJlcihhcmdzWzFdKSA6ICcnKSArXG4gICAgICAgICAgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PSdsZWZ0JyAmJiBiIT09J21pZGRsZScgJiYgYiE9PSdjZW50ZXInKSA/ICdyaWdodCcgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy50cnVuY2F0ZSgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXFwnJyArIGIgKyAnXFwnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFkJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYXJnc1sxXTtcbiAgICAgICAgYiA9IChiIT09J2xlZnQnICYmIGIhPT0nbWlkZGxlJyAmJiBiIT09J2NlbnRlcicpID8gJ3JpZ2h0JyA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnBhZCgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXFwnJyArIGIgKyAnXFwnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgbnVtYmVyX2Zvcm1hdChmb3JtYXQubnVtYmVyLCAnbnVtYmVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIHRpbWVfZm9ybWF0KGZvcm1hdC50aW1lLCAndGltZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUtdXRjJzpcbiAgICAgICAgdGltZV9mb3JtYXQoZm9ybWF0LnV0YywgJ3RpbWUtdXRjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6ICcgKyBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG52YXIgdGVtcGxhdGVfcmUgPSAvXFx7XFx7KC4rPylcXH1cXH18JC9nLFxuICAgIGZpbHRlcl9yZSA9IC8oPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8W15cXHxcIl0rfFteXFx8XFwnXSspKy9nLFxuICAgIGFyZ3NfcmUgPSAvKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFteLFwiXSt8W14sXFwnXSspKy9nO1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgdGVtcGxhdGVfZXNjYXBlcyA9IHtcbiAgJ1xcJyc6ICAgICAnXFwnJyxcbiAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAnXFxyJzogICAgICdyJyxcbiAgJ1xcbic6ICAgICAnbicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG52YXIgdGVtcGxhdGVfZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuZnVuY3Rpb24gdGVtcGxhdGVfZXNjYXBlQ2hhcihtYXRjaCkge1xuICByZXR1cm4gJ1xcXFwnICsgdGVtcGxhdGVfZXNjYXBlc1ttYXRjaF07XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCBrZXksIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcXCcnKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gPT09ICdcIicgICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcIicpKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogJyArIHBhdHRlcm4pO1xuICB9XG4gIGtleSA9IGtleSArICc6JyArIHBhdHRlcm47XG4gIGlmICghY29udGV4dC5mb3JtYXRfbWFwW2tleV0pIHtcbiAgICB2YXIgZiA9IGZtdChwYXR0ZXJuKTtcbiAgICB2YXIgaSA9IGNvbnRleHQuZm9ybWF0cy5sZW5ndGg7XG4gICAgY29udGV4dC5mb3JtYXRzLnB1c2goZik7XG4gICAgY29udGV4dC5mb3JtYXRfbWFwW2tleV0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBba2V5XTtcbn1cbiIsInZhciBkM190aW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xuXG52YXIgdGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgIGJhc2VEYXRlID0gbmV3IERhdGUoMCwgMCwgMSkuc2V0RnVsbFllYXIoMCksIC8vIEphbiAxLCAwIEFEXG4gICAgdXRjQmFzZURhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygwLCAwLCAxKSkuc2V0VVRDRnVsbFllYXIoMCk7XG5cbmZ1bmN0aW9uIGRhdGUoZCkge1xuICByZXR1cm4gKHRlbXBEYXRlLnNldFRpbWUoK2QpLCB0ZW1wRGF0ZSk7XG59XG5cbi8vIGNyZWF0ZSBhIHRpbWUgdW5pdCBlbnRyeVxuZnVuY3Rpb24gZW50cnkodHlwZSwgZGF0ZSwgdW5pdCwgc3RlcCwgbWluLCBtYXgpIHtcbiAgdmFyIGUgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRlOiBkYXRlLFxuICAgIHVuaXQ6IHVuaXRcbiAgfTtcbiAgaWYgKHN0ZXApIHtcbiAgICBlLnN0ZXAgPSBzdGVwO1xuICB9IGVsc2Uge1xuICAgIGUubWluc3RlcCA9IDE7XG4gIH1cbiAgaWYgKG1pbiAhPSBudWxsKSBlLm1pbiA9IG1pbjtcbiAgaWYgKG1heCAhPSBudWxsKSBlLm1heCA9IG1heDtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCB1bml0LCBiYXNlLCBzdGVwLCBtaW4sIG1heCkge1xuICByZXR1cm4gZW50cnkodHlwZSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0Lm9mZnNldChiYXNlLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0LmNvdW50KGJhc2UsIGQpOyB9LFxuICAgIHN0ZXAsIG1pbiwgbWF4KTtcbn1cblxudmFyIGxvY2FsZSA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnNlY29uZCwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUubWludXRlLCBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS5ob3VyLCAgIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLmRheSwgICAgYmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS5tb250aCwgIGJhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUueWVhciwgICBiYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0U2Vjb25kcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdtaW51dGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldE1pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0SG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDQrZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXkoKTsgfSxcbiAgICBbMV0sIDAsIDZcbiAgKSxcbiAgZW50cnkoJ2RhdGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldERhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIGQgJSAxMiwgMSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIHV0YyA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnV0Y1NlY29uZCwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUudXRjTWludXRlLCB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS51dGNIb3VyLCAgIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLnV0Y0RheSwgICAgdXRjQmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS51dGNNb250aCwgIHV0Y0Jhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUudXRjWWVhciwgICB1dGNCYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ1NlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTWludXRlcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdob3VycycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDSG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQrZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF0ZSgpOyB9LFxuICAgIFsxXSwgMSwgMzFcbiAgKSxcbiAgZW50cnkoJ21vbnRocycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbmZ1bmN0aW9uIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIHN0ZXAgPSBTVEVQU1swXSwgaSwgbiwgYmlucztcblxuICBmb3IgKGk9MSwgbj1TVEVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tTVEVQU1tpLTFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pdHNbU1RFUFNbbi0xXVsxXV07XG59XG5cbmZ1bmN0aW9uIHRvVW5pdE1hcCh1bml0cykge1xuICB2YXIgbWFwID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPXVuaXRzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBtYXBbdW5pdHNbaV0udHlwZV0gPSB1bml0c1tpXTtcbiAgfVxuICBtYXAuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgICByZXR1cm4gZmluZCh1bml0cywgc3BhbiwgbWluYiwgbWF4Yik7XG4gIH07XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Vbml0TWFwKGxvY2FsZSk7XG5tb2R1bGUuZXhwb3J0cy51dGMgPSB0b1VuaXRNYXAodXRjKTtcbiIsInZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gICAgdXRjID0gdGltZS51dGM7XG5cbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmo7XG59O1xuXG51LmlzQnVmZmVyID0gKGJ1ZmZlci5CdWZmZXIgJiYgYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnZhciBmaWVsZF9yZSA9IC9cXFsoLio/KVxcXXxbXi5cXFtdKy9nO1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gU3RyaW5nKGYpLm1hdGNoKGZpZWxkX3JlKS5tYXAoZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkWzBdICE9PSAnWycgPyBkIDpcbiAgICAgIGRbMV0gIT09IFwiJ1wiICYmIGRbMV0gIT09ICdcIicgPyBkLnNsaWNlKDEsIC0xKSA6XG4gICAgICBkLnNsaWNlKDIsIC0yKS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCAnJDEnKTtcbiAgfSk7XG59O1xuXG51LmFjY2Vzc29yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIGY9PW51bGwgfHwgdS5pc0Z1bmN0aW9uKGYpID8gZiA6XG4gICAgdS5uYW1lZGZ1bmMoZiwgKHMgPSB1LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHMucmVkdWNlKGZ1bmN0aW9uKHgsZikgeyByZXR1cm4geFtmXTsgfSwgeCk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfVxuICAgICk7XG59O1xuXG4vLyBzaG9ydC1jdXQgZm9yIGFjY2Vzc29yXG51LiQgPSB1LmFjY2Vzc29yO1xuXG51Lm11dGF0b3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gdS5pc1N0cmluZyhmKSAmJiAocz11LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICBmdW5jdGlvbih4LCB2KSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGgtMTsgKytpKSB4ID0geFtzW2ldXTtcbiAgICAgIHhbc1tpXV0gPSB2O1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKHgsIHYpIHsgeFtmXSA9IHY7IH07XG59O1xuXG5cbnUuJGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgIGYgPSB1LiQoZikgfHwgdS5pZGVudGl0eTtcbiAgICB2YXIgbiA9IG5hbWUgKyAodS5uYW1lKGYpID8gJ18nK3UubmFtZShmKSA6ICcnKTtcbiAgICByZXR1cm4gdS5uYW1lZGZ1bmMobiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gb3AoZihkKSk7IH0pO1xuICB9O1xufTtcblxudS4kdmFsaWQgID0gdS4kZnVuYygndmFsaWQnLCB1LmlzVmFsaWQpO1xudS4kbGVuZ3RoID0gdS4kZnVuYygnbGVuZ3RoJywgdS5sZW5ndGgpO1xuXG51LiRpbiA9IGZ1bmN0aW9uKGYsIHZhbHVlcykge1xuICBmID0gdS4kKGYpO1xuICB2YXIgbWFwID0gdS5pc0FycmF5KHZhbHVlcykgPyB1LnRvTWFwKHZhbHVlcykgOiB2YWx1ZXM7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7IHJldHVybiAhIW1hcFtmKGQpXTsgfTtcbn07XG5cbnUuJHllYXIgICA9IHUuJGZ1bmMoJ3llYXInLCB0aW1lLnllYXIudW5pdCk7XG51LiRtb250aCAgPSB1LiRmdW5jKCdtb250aCcsIHRpbWUubW9udGhzLnVuaXQpO1xudS4kZGF0ZSAgID0gdS4kZnVuYygnZGF0ZScsIHRpbWUuZGF0ZXMudW5pdCk7XG51LiRkYXkgICAgPSB1LiRmdW5jKCdkYXknLCB0aW1lLndlZWtkYXlzLnVuaXQpO1xudS4kaG91ciAgID0gdS4kZnVuYygnaG91cicsIHRpbWUuaG91cnMudW5pdCk7XG51LiRtaW51dGUgPSB1LiRmdW5jKCdtaW51dGUnLCB0aW1lLm1pbnV0ZXMudW5pdCk7XG51LiRzZWNvbmQgPSB1LiRmdW5jKCdzZWNvbmQnLCB0aW1lLnNlY29uZHMudW5pdCk7XG5cbnUuJHV0Y1llYXIgICA9IHUuJGZ1bmMoJ3V0Y1llYXInLCB1dGMueWVhci51bml0KTtcbnUuJHV0Y01vbnRoICA9IHUuJGZ1bmMoJ3V0Y01vbnRoJywgdXRjLm1vbnRocy51bml0KTtcbnUuJHV0Y0RhdGUgICA9IHUuJGZ1bmMoJ3V0Y0RhdGUnLCB1dGMuZGF0ZXMudW5pdCk7XG51LiR1dGNEYXkgICAgPSB1LiRmdW5jKCd1dGNEYXknLCB1dGMud2Vla2RheXMudW5pdCk7XG51LiR1dGNIb3VyICAgPSB1LiRmdW5jKCd1dGNIb3VyJywgdXRjLmhvdXJzLnVuaXQpO1xudS4kdXRjTWludXRlID0gdS4kZnVuYygndXRjTWludXRlJywgdXRjLm1pbnV0ZXMudW5pdCk7XG51LiR1dGNTZWNvbmQgPSB1LiRmdW5jKCd1dGNTZWNvbmQnLCB1dGMuc2Vjb25kcy51bml0KTtcblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSAnLScpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09ICcrJykgeyBzID0gKzE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgc2lnbi5wdXNoKHMpO1xuICAgIHJldHVybiB1LmFjY2Vzc29yKGYpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBpLCBuLCBmLCB4LCB5O1xuICAgIGZvciAoaT0wLCBuPXNvcnQubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZiA9IHNvcnRbaV07IHggPSBmKGEpOyB5ID0gZihiKTtcbiAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xICogc2lnbltpXTtcbiAgICAgIGlmICh4ID4geSkgcmV0dXJuIHNpZ25baV07XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufTtcblxudS5jbXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGEgPj0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBOYU47XG59O1xuXG51Lm51bWNtcCA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG51LnN0YWJsZXNvcnQgPSBmdW5jdGlvbihhcnJheSwgc29ydEJ5LCBrZXlGbikge1xuICB2YXIgaW5kaWNlcyA9IGFycmF5LnJlZHVjZShmdW5jdGlvbihpZHgsIHYsIGkpIHtcbiAgICByZXR1cm4gKGlkeFtrZXlGbih2KV0gPSBpLCBpZHgpO1xuICB9LCB7fSk7XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHNhID0gc29ydEJ5KGEpLFxuICAgICAgICBzYiA9IHNvcnRCeShiKTtcbiAgICByZXR1cm4gc2EgPCBzYiA/IC0xIDogc2EgPiBzYiA/IDFcbiAgICAgICAgIDogKGluZGljZXNba2V5Rm4oYSldIC0gaW5kaWNlc1trZXlGbihiKV0pO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8vIHN0cmluZyBmdW5jdGlvbnNcblxudS5wYWQgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgcGFkY2hhcikge1xuICBwYWRjaGFyID0gcGFkY2hhciB8fCBcIiBcIjtcbiAgdmFyIGQgPSBsZW5ndGggLSBzLmxlbmd0aDtcbiAgaWYgKGQgPD0gMCkgcmV0dXJuIHM7XG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gc3RycmVwKGQsIHBhZGNoYXIpICsgcztcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4gc3RycmVwKE1hdGguZmxvb3IoZC8yKSwgcGFkY2hhcikgK1xuICAgICAgICAgcyArIHN0cnJlcChNYXRoLmNlaWwoZC8yKSwgcGFkY2hhcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzICsgc3RycmVwKGQsIHBhZGNoYXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJyZXAobiwgc3RyKSB7XG4gIHZhciBzID0gXCJcIiwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBzICs9IHN0cjtcbiAgcmV0dXJuIHM7XG59XG5cbnUudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbGxpcHNpcykgOiAnXFx1MjAyNic7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArXG4gICAgICAgIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oJycpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJ2YXIgREVQUyA9IHJlcXVpcmUoJy4vRGVwZW5kZW5jaWVzJykuQUxMO1xuXG5mdW5jdGlvbiBjcmVhdGUoY3MsIHJlZmxvdykge1xuICB2YXIgb3V0ID0ge307XG4gIGNvcHkoY3MsIG91dCk7XG5cbiAgb3V0LmFkZCA9IFtdO1xuICBvdXQubW9kID0gW107XG4gIG91dC5yZW0gPSBbXTtcblxuICBvdXQucmVmbG93ID0gcmVmbG93O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHkoYSwgYikge1xuICBiLnN0YW1wID0gYSA/IGEuc3RhbXAgOiAwO1xuICBiLnNvcnQgID0gYSA/IGEuc29ydCAgOiBudWxsO1xuICBiLmZhY2V0ID0gYSA/IGEuZmFjZXQgOiBudWxsO1xuICBiLnRyYW5zID0gYSA/IGEudHJhbnMgOiBudWxsO1xuICBiLmRpcnR5ID0gYSA/IGEuZGlydHkgOiBbXTtcbiAgYi5yZXF1ZXN0ID0gYSA/IGEucmVxdWVzdCA6IG51bGw7XG4gIGZvciAodmFyIGQsIGk9MCwgbj1ERVBTLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBiW2Q9REVQU1tpXV0gPSBhID8gYVtkXSA6IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY29weTogY29weVxufTsiLCJ2YXIgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCcuL1R1cGxlJyksXG4gICAgQmFzZSA9IHJlcXVpcmUoJy4vTm9kZScpLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGdyYXBoKSB7XG4gIEJhc2UuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLnJvdXRlcih0cnVlKS5jb2xsZWN0b3IodHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoQ29sbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdG9yO1xuXG5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YTtcbn07XG5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgW1wiY29sbGVjdGluZ1wiXSk7XG5cbiAgaWYgKGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICB0aGlzLl9kYXRhID0gVHVwbGUuaWRGaWx0ZXIodGhpcy5fZGF0YSwgaW5wdXQucmVtKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEubGVuZ3RoID8gdGhpcy5fZGF0YS5jb25jYXQoaW5wdXQuYWRkKSA6IGlucHV0LmFkZDtcbiAgfVxuXG4gIGlmIChpbnB1dC5zb3J0KSB7XG4gICAgdGhpcy5fZGF0YS5zb3J0KGlucHV0LnNvcnQpO1xuICB9XG5cbiAgaWYgKGlucHV0LnJlZmxvdykge1xuICAgIGlucHV0Lm1vZCA9IGlucHV0Lm1vZC5jb25jYXQoXG4gICAgICBUdXBsZS5pZEZpbHRlcih0aGlzLl9kYXRhLCBpbnB1dC5hZGQsIGlucHV0Lm1vZCwgaW5wdXQucmVtKSk7XG4gICAgaW5wdXQucmVmbG93ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjsiLCJ2YXIgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgQ2hhbmdlU2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSwgXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG5mdW5jdGlvbiBEYXRhU291cmNlKGdyYXBoLCBuYW1lLCBmYWNldCkge1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuICB0aGlzLl9mYWNldCAgPSBmYWNldDtcbiAgdGhpcy5faW5wdXQgID0gQ2hhbmdlU2V0LmNyZWF0ZSgpO1xuICB0aGlzLl9vdXRwdXQgPSBudWxsOyAvLyBPdXRwdXQgY2hhbmdlc2V0XG5cbiAgdGhpcy5faW5wdXROb2RlICA9IG51bGw7XG4gIHRoaXMuX291dHB1dE5vZGUgPSBudWxsO1xuICB0aGlzLl9waXBlbGluZSAgPSBudWxsOyAvLyBQaXBlbGluZSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gIHRoaXMuX2NvbGxlY3RvciA9IG51bGw7IC8vIENvbGxlY3RvciB0byBtYXRlcmlhbGl6ZSBvdXRwdXQgb2YgcGlwZWxpbmUuXG4gIHRoaXMuX211dGF0ZXMgPSBmYWxzZTsgIC8vIERvZXMgYW55IHBpcGVsaW5lIG9wZXJhdG9yIG11dGF0ZSB0dXBsZXM/XG59XG5cbnZhciBwcm90b3R5cGUgPSBEYXRhU291cmNlLnByb3RvdHlwZTtcblxucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX25hbWU7XG4gIHJldHVybiAodGhpcy5fbmFtZSA9IG5hbWUsIHRoaXMpO1xufTtcblxucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKHNyYykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIHJldHVybiAodGhpcy5fc291cmNlID0gdGhpcy5fZ3JhcGguZGF0YShzcmMpKTtcbn07XG5cbnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbih0dXBsZXMpIHtcbiAgdGhpcy5faW5wdXQuYWRkID0gdGhpcy5faW5wdXQuYWRkLmNvbmNhdCh0dXBsZXMubWFwKFR1cGxlLmluZ2VzdCkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbih3aGVyZSkge1xuICB2YXIgcmVtb3ZlID0gdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpO1xuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9pbnB1dC5yZW0uY29uY2F0KHJlbW92ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHdoZXJlLCBmaWVsZCwgZnVuYykge1xuICB2YXIgbW9kID0gdGhpcy5faW5wdXQubW9kLFxuICAgICAgaWRzID0gVHVwbGUuaWRNYXAobW9kKTtcblxuICB0aGlzLl9pbnB1dC5maWVsZHNbZmllbGRdID0gMTtcblxuICB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSkuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdmFyIHByZXYgPSB4W2ZpZWxkXSxcbiAgICAgICAgbmV4dCA9IGZ1bmMoeCk7XG4gICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgIFR1cGxlLnNldCh4LCBmaWVsZCwgbmV4dCk7XG4gICAgICBpZiAoaWRzW3guX2lkXSAhPT0gMSkge1xuICAgICAgICBtb2QucHVzaCh4KTtcbiAgICAgICAgaWRzW3guX2lkXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbGxlY3Rvci5kYXRhKCk7XG5cbiAgLy8gUmVwbGFjZSBiYWNraW5nIGRhdGFcbiAgdGhpcy5faW5wdXQucmVtID0gdGhpcy5fZGF0YS5zbGljZSgpO1xuICBpZiAoZGF0YSkgeyB0aGlzLmluc2VydChkYXRhKTsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tdXRhdGVzID0gZnVuY3Rpb24obSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tdXRhdGVzO1xuICB0aGlzLl9tdXRhdGVzID0gdGhpcy5fbXV0YXRlcyB8fCBtO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vdXRwdXQ7XG59O1xuXG5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmIChpbnB1dCkgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5fZ3JhcGgucHJvcGFnYXRlKHRoaXMuX2lucHV0LCB0aGlzLl9waXBlbGluZVswXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnBpcGVsaW5lID0gZnVuY3Rpb24ocGlwZWxpbmUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG5cbiAgdmFyIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBzdGF0dXM7XG5cbiAgcGlwZWxpbmUudW5zaGlmdCh0aGlzLl9pbnB1dE5vZGUgPSBEYXRhU291cmNlSW5wdXQodGhpcykpO1xuICBzdGF0dXMgPSBncmFwaC5wcmVwcm9jZXNzKHBpcGVsaW5lKTtcblxuICBpZiAoc3RhdHVzLnJvdXRlcikge1xuICAgIHBpcGVsaW5lLnB1c2goc3RhdHVzLmNvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpKTtcbiAgfVxuXG4gIHBpcGVsaW5lLnB1c2godGhpcy5fb3V0cHV0Tm9kZSA9IERhdGFTb3VyY2VPdXRwdXQodGhpcykpO1xuICB0aGlzLl9jb2xsZWN0b3IgPSBzdGF0dXMuY29sbGVjdG9yO1xuICB0aGlzLl9tdXRhdGVzID0gISFzdGF0dXMubXV0YXRlcztcbiAgZ3JhcGguY29ubmVjdCh0aGlzLl9waXBlbGluZSA9IHBpcGVsaW5lKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zeW5jaHJvbml6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ncmFwaC5zeW5jaHJvbml6ZSh0aGlzLl9waXBlbGluZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IFxuICByZXR1cm4gRGF0YVNvdXJjZUxpc3RlbmVyKHRoaXMpLmFkZExpc3RlbmVyKHRoaXMuX2lucHV0Tm9kZSk7XG59O1xuXG5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmIChsIGluc3RhbmNlb2YgRGF0YVNvdXJjZSkge1xuICAgIHRoaXMuX2NvbGxlY3Rvci5hZGRMaXN0ZW5lcihsLmxpc3RlbmVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX291dHB1dE5vZGUuYWRkTGlzdGVuZXIobCk7ICAgICAgXG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIHRoaXMuX291dHB1dE5vZGUucmVtb3ZlTGlzdGVuZXIobCk7XG59O1xuXG5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZHMpIHtcbiAgcmV0dXJuIChkcyA/IHRoaXMuX2NvbGxlY3RvciA6IHRoaXMuX291dHB1dE5vZGUpLmxpc3RlbmVycygpO1xufTtcblxuLy8gSW5wdXQgbm9kZSBhcHBsaWVzIHRoZSBkYXRhc291cmNlJ3MgZGVsdGEsIGFuZCBwcm9wYWdhdGVzIGl0IHRvIFxuLy8gdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lLiBJdCByZWNlaXZlcyB0b3VjaGVzIHRvIHJlZmxvdyBkYXRhLlxuZnVuY3Rpb24gRGF0YVNvdXJjZUlucHV0KGRzKSB7XG4gIHZhciBpbnB1dCA9IG5ldyBOb2RlKGRzLl9ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBpbnB1dC5kYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRzLl9kYXRhO1xuICB9O1xuXG4gIGlucHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBsb2cuZGVidWcoaW5wdXQsIFsnaW5wdXQnLCBkcy5fbmFtZV0pO1xuXG4gICAgdmFyIGRlbHRhID0gZHMuX2lucHV0LCBcbiAgICAgICAgb3V0ID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCksIGY7XG5cbiAgICAvLyBEZWx0YSBtaWdodCBjb250YWluIGZpZWxkcyB1cGRhdGVkIHRocm91Z2ggQVBJXG4gICAgZm9yIChmIGluIGRlbHRhLmZpZWxkcykge1xuICAgICAgb3V0LmZpZWxkc1tmXSA9IDE7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRhdGFcbiAgICBpZiAoZGVsdGEucmVtLmxlbmd0aCkge1xuICAgICAgZHMuX2RhdGEgPSBUdXBsZS5pZEZpbHRlcihkcy5fZGF0YSwgZGVsdGEucmVtKTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEuYWRkLmxlbmd0aCkge1xuICAgICAgZHMuX2RhdGEgPSBkcy5fZGF0YS5jb25jYXQoZGVsdGEuYWRkKTtcbiAgICB9XG5cbiAgICAvLyBpZiByZWZsb3dpbmcsIGFkZCBhbnkgb3RoZXIgdHVwbGVzIG5vdCBjdXJyZW50bHkgaW4gY2hhbmdlc2V0XG4gICAgaWYgKGlucHV0LnJlZmxvdykge1xuICAgICAgZGVsdGEubW9kID0gZGVsdGEubW9kLmNvbmNhdChcbiAgICAgICAgVHVwbGUuaWRGaWx0ZXIoZHMuX2RhdGEsIGRlbHRhLmFkZCwgZGVsdGEubW9kLCBkZWx0YS5yZW0pKTtcbiAgICB9XG5cbiAgICAvLyByZXNldCBjaGFuZ2UgbGlzdFxuICAgIGRzLl9pbnB1dCA9IENoYW5nZVNldC5jcmVhdGUoKTtcblxuICAgIG91dC5hZGQgPSBkZWx0YS5hZGQ7IFxuICAgIG91dC5tb2QgPSBkZWx0YS5tb2Q7XG4gICAgb3V0LnJlbSA9IGRlbHRhLnJlbTtcbiAgICBvdXQuZmFjZXQgPSBkcy5fZmFjZXQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8vIE91dHB1dCBub2RlIGNhcHR1cmVzIHRoZSBsYXN0IGNoYW5nZXNldCBzZWVuIGJ5IHRoaXMgZGF0YXNvdXJjZVxuLy8gKG5lZWRlZCBmb3Igam9pbnMgYW5kIGJ1aWxkcykgYW5kIG1hdGVyaWFsaXplcyBhbnkgbmVzdGVkIGRhdGEuXG4vLyBJZiB0aGlzIGRhdGFzb3VyY2UgaXMgZmFjZXRlZCwgbWF0ZXJpYWxpemVzIHRoZSB2YWx1ZXMgaW4gdGhlIGZhY2V0LlxuZnVuY3Rpb24gRGF0YVNvdXJjZU91dHB1dChkcykge1xuICB2YXIgb3V0cHV0ID0gbmV3IE5vZGUoZHMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAucmVmbG93cyh0cnVlKVxuICAgIC5jb2xsZWN0b3IodHJ1ZSk7XG5cbiAgb3V0cHV0LmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHMuX2NvbGxlY3RvciA/IGRzLl9jb2xsZWN0b3IuZGF0YSgpIDogZHMuX2RhdGE7XG4gIH07XG5cbiAgb3V0cHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBsb2cuZGVidWcoaW5wdXQsIFsnb3V0cHV0JywgZHMuX25hbWVdKTtcblxuICAgIHZhciBvdXQgPSBDaGFuZ2VTZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcblxuICAgIGlmIChkcy5fZmFjZXQpIHtcbiAgICAgIGRzLl9mYWNldC52YWx1ZXMgPSBkcy52YWx1ZXMoKTtcbiAgICAgIGlucHV0LmZhY2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkcy5fb3V0cHV0ID0gaW5wdXQ7XG4gICAgb3V0LmRhdGFbZHMuX25hbWVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIERhdGFTb3VyY2VMaXN0ZW5lcihkcykge1xuICB2YXIgbCA9IG5ldyBOb2RlKGRzLl9ncmFwaCkucm91dGVyKHRydWUpO1xuXG4gIGwuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIC8vIFR1cGxlIGRlcml2YXRpb24gY2FycmllcyBhIGNvc3QuIFNvIG9ubHkgZGVyaXZlIGlmIHRoZSBwaXBlbGluZSBoYXNcbiAgICAvLyBvcGVyYXRvcnMgdGhhdCBtdXRhdGUsIGFuZCB0aHVzIHdvdWxkIG92ZXJyaWRlIHRoZSBzb3VyY2UgZGF0YS5cbiAgICBpZiAoZHMubXV0YXRlcygpKSB7ICBcbiAgICAgIHZhciBtYXAgPSBkcy5fc3JjTWFwIHx8IChkcy5fc3JjTWFwID0ge30pLCAvLyB0byBwcm9wYWdhdGUgdHVwbGVzIGNvcnJlY3RseVxuICAgICAgICAgIG91dHB1dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgICBvdXRwdXQuYWRkID0gaW5wdXQuYWRkLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAobWFwW3QuX2lkXSA9IFR1cGxlLmRlcml2ZSh0KSk7XG4gICAgICB9KTtcblxuICAgICAgb3V0cHV0Lm1vZCA9IGlucHV0Lm1vZC5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gVHVwbGUucmVkZXJpdmUodCwgbWFwW3QuX2lkXSk7XG4gICAgICB9KTtcblxuICAgICAgb3V0cHV0LnJlbSA9IGlucHV0LnJlbS5tYXAoZnVuY3Rpb24odCkgeyBcbiAgICAgICAgdmFyIG8gPSBtYXBbdC5faWRdO1xuICAgICAgICByZXR1cm4gKG1hcFt0Ll9pZF0gPSBudWxsLCBvKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gKGRzLl9pbnB1dCA9IG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZHMuX2lucHV0ID0gaW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlO1xuIiwidmFyIGRlcHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUxMOiBbJ2RhdGEnLCAnZmllbGRzJywgJ3NjYWxlcycsICdzaWduYWxzJ11cbn07XG5kZXBzLkFMTC5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgZGVwc1trLnRvVXBwZXJDYXNlKCldID0gazsgfSk7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpLFxuICAgIENoYW5nZVNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlU2V0JyksXG4gICAgRGF0YVNvdXJjZSA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4vQ29sbGVjdG9yJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCcuL1R1cGxlJyksXG4gICAgU2lnbmFsID0gcmVxdWlyZSgnLi9TaWduYWwnKSxcbiAgICBEZXBzID0gcmVxdWlyZSgnLi9EZXBlbmRlbmNpZXMnKTtcblxuZnVuY3Rpb24gR3JhcGgoKSB7XG59XG5cbnZhciBwcm90b3R5cGUgPSBHcmFwaC5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YW1wID0gMDtcbiAgdGhpcy5fcmFuayAgPSAwO1xuXG4gIHRoaXMuX2RhdGEgPSB7fTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xuXG4gIHRoaXMuZG9Ob3RQcm9wYWdhdGUgPSB7fTtcbn07XG5cbnByb3RvdHlwZS5yYW5rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiArK3RoaXMuX3Jhbms7XG59O1xuXG5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24odHlwZSwgbmFtZXMsIGhhc2gpIHtcbiAgdmFyIGRhdGEgPSAodHlwZSA9PT0gRGVwcy5TSUdOQUxTID8gdGhpcy5fc2lnbmFscyA6IHRoaXMuX2RhdGEpLFxuICAgICAgbiA9IChuYW1lcyAhPT0gdW5kZWZpbmVkID8gbmFtZXMgOiBkbC5rZXlzKGRhdGEpKSxcbiAgICAgIHZhbHMsIGk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobikpIHtcbiAgICB2YWxzID0gaGFzaCB8fCB7fTtcbiAgICBmb3IgKGk9MDsgaTxuLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YWxzW25baV1dID0gZGF0YVtuW2ldXS52YWx1ZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGFbbl0udmFsdWVzKCk7XG4gIH1cbn07XG5cbi8vIFJldGFpbiBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbnByb3RvdHlwZS5kYXRhVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKERlcHMuREFUQSwgbmFtZXMpO1xufTtcblxuLy8gUmV0YWluIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxucHJvdG90eXBlLnNpZ25hbFZhbHVlcyA9IGZ1bmN0aW9uKG5hbWVzKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlcyhEZXBzLlNJR05BTFMsIG5hbWVzKTtcbn07XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24obmFtZSwgcGlwZWxpbmUsIGZhY2V0KSB7XG4gIHZhciBkYiA9IHRoaXMuX2RhdGE7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhciBhbGwgPSBbXSwga2V5O1xuICAgIGZvciAoa2V5IGluIGRiKSB7IGFsbC5wdXNoKGRiW2tleV0pOyB9XG4gICAgcmV0dXJuIGFsbDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRiW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZGJbbmFtZV0gPSBuZXcgRGF0YVNvdXJjZSh0aGlzLCBuYW1lLCBmYWNldCkucGlwZWxpbmUocGlwZWxpbmUpKTtcbiAgfVxufTtcblxucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGluaXQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobmFtZSkgP1xuICAgICAgbmFtZS5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbS5fc2lnbmFsc1tuXTsgfSkgOlxuICAgICAgdGhpcy5fc2lnbmFsc1tuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHRoaXMuX3NpZ25hbHNbbmFtZV0gPSBuZXcgU2lnbmFsKHRoaXMsIG5hbWUsIGluaXQpKTtcbiAgfVxufTtcblxucHJvdG90eXBlLnNpZ25hbFJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocmVmKSkge1xuICAgIHJlZiA9IGRsLmZpZWxkKHJlZik7XG4gIH1cblxuICB2YXIgdmFsdWUgPSB0aGlzLnNpZ25hbChyZWZbMF0pLnZhbHVlKCk7XG4gIGlmIChyZWYubGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGk9MSwgbj1yZWYubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtyZWZbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBTdGFtcCBzaG91bGQgYmUgc3BlY2lmaWVkIHdpdGggY2F1dGlvbi4gSXQgaXMgbmVjZXNzYXJ5IGZvciBpbmxpbmUgZGF0YXNvdXJjZXMsXG4vLyB3aGljaCBuZWVkIHRvIGJlIHBvcHVsYXRlZCBkdXJpbmcgdGhlIHNhbWUgY3ljbGUgZXZlbiB0aG91Z2ggcHJvcGFnYXRpb24gaGFzXG4vLyBwYXNzZWQgdGhhdCBwYXJ0IG9mIHRoZSBkYXRhZmxvdyBncmFwaC4gIFxucHJvdG90eXBlLnByb3BhZ2F0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlLCBzdGFtcCkge1xuICB2YXIgcHVsc2VzID0ge30sXG4gICAgICBsaXN0ZW5lcnMsIG5leHQsIG5wbHNlLCB0cGxzLCBudHBscywgaSwgbGVuO1xuXG4gIC8vIG5ldyBQUSB3aXRoIGVhY2ggcHJvcGFnYXRpb24gY3ljbGUgc28gdGhhdCB3ZSBjYW4gcHVsc2UgYnJhbmNoZXNcbiAgLy8gb2YgdGhlIGRhdGFmbG93IGdyYXBoIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuLCB3aGVuIGNyZWF0aW5nXG4gIC8vIGEgbmV3IGlubGluZSBkYXRhc291cmNlKS5cbiAgdmFyIHBxID0gbmV3IEhlYXAoZnVuY3Rpb24oYSwgYikge1xuICAgIC8vIFNvcnQgb24gcXJhbmsgKHF1ZXVlLXJhbmspLlxuICAgIC8vIFJhbmsgY2FuIGNoYW5nZSBkdXJpbmcgcHJvcGFnYXRpb24gZHVlIHRvIHJld2lyaW5nLlxuICAgIHJldHVybiBhLl9xcmFuayAtIGIuX3FyYW5rO1xuICB9KTtcblxuICBpZiAocHVsc2Uuc3RhbXApIHRocm93IEVycm9yKCdQdWxzZSBhbHJlYWR5IGhhcyBhIG5vbi16ZXJvIHN0YW1wLicpO1xuXG4gIHB1bHNlLnN0YW1wID0gc3RhbXAgfHwgKyt0aGlzLl9zdGFtcDtcbiAgcHVsc2VzW25vZGUuX2lkXSA9IHB1bHNlO1xuICBwcS5wdXNoKG5vZGUucXJhbmsodHJ1ZSkpO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgbm9kZSAgPSBwcS5wZWVrKCk7XG4gICAgcHVsc2UgPSBwdWxzZXNbbm9kZS5faWRdO1xuXG4gICAgaWYgKG5vZGUucmFuaygpICE9PSBub2RlLnFyYW5rKCkpIHtcbiAgICAgIC8vIEEgbm9kZSdzIHJhbmsgbWlnaHQgY2hhbmdlIGR1cmluZyBhIHByb3BhZ2F0aW9uLiBSZS1xdWV1ZSBpZiBzby5cbiAgICAgIHBxLnJlcGxhY2Uobm9kZS5xcmFuayh0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2YWx1YXRlIG5vZGUgYW5kIHByb3BhZ2F0ZSBwdWxzZS5cbiAgICAgIHBxLnBvcCgpO1xuICAgICAgcHVsc2VzW25vZGUuX2lkXSA9IG51bGw7XG4gICAgICBsaXN0ZW5lcnMgPSBub2RlLl9saXN0ZW5lcnM7XG4gICAgICBwdWxzZSA9IHRoaXMuZXZhbHVhdGUocHVsc2UsIG5vZGUpO1xuXG4gICAgICAvLyBQcm9wYWdhdGUgdGhlIHB1bHNlLiBcbiAgICAgIGlmIChwdWxzZSAhPT0gdGhpcy5kb05vdFByb3BhZ2F0ZSkge1xuICAgICAgICAvLyBFbnN1cmUgcmVmbG93IHB1bHNlcyBhbHdheXMgc2VuZCByZWZsb3cgcHVsc2VzIGV2ZW4gaWYgc2tpcHBlZC5cbiAgICAgICAgaWYgKCFwdWxzZS5yZWZsb3cgJiYgbm9kZS5yZWZsb3dzKCkpIHtcbiAgICAgICAgICBwdWxzZSA9IENoYW5nZVNldC5jcmVhdGUocHVsc2UsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpPTAsIGxlbj1saXN0ZW5lcnMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgbmV4dCA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgIGlmICgobnBsc2UgPSBwdWxzZXNbbmV4dC5faWRdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobnBsc2UgPT09IG51bGwpIHRocm93IEVycm9yKCdBbHJlYWR5IHByb3BhZ2F0ZWQgdG8gbm9kZS4nKTtcbiAgICAgICAgICAgIGlmIChucGxzZSA9PT0gcHVsc2UpIGNvbnRpbnVlOyAgLy8gUmUtcXVldWVpbmcgdGhlIHNhbWUgcHVsc2UuXG5cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcXVldWVkIHRoaXMgbm9kZS4gRW5zdXJlIHRoZXJlIHNob3VsZCBiZSBhdCBtb3N0IG9uZVxuICAgICAgICAgICAgLy8gcHVsc2Ugd2l0aCB0dXBsZXMgKGFkZC9tb2QvcmVtKSwgYW5kIHRoZSByZW1haW5kZXIgd2lsbCBiZSByZWZsb3dzLiBcbiAgICAgICAgICAgIHRwbHMgID0gcHVsc2UuYWRkLmxlbmd0aCB8fCBwdWxzZS5tb2QubGVuZ3RoIHx8IHB1bHNlLnJlbS5sZW5ndGg7XG4gICAgICAgICAgICBudHBscyA9IG5wbHNlLmFkZC5sZW5ndGggfHwgbnBsc2UubW9kLmxlbmd0aCB8fCBucGxzZS5yZW0ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodHBscyAmJiBudHBscykgdGhyb3cgRXJyb3IoJ011bHRpcGxlIGNoYW5nZXNldCBwdWxzZXMgdG8gc2FtZSBub2RlJyk7XG5cbiAgICAgICAgICAgIC8vIENvbWJpbmUgcmVmbG93IGFuZCB0dXBsZXMgaW50byBhIHNpbmdsZSBwdWxzZS4gXG4gICAgICAgICAgICBwdWxzZXNbbmV4dC5faWRdID0gdHBscyA/IHB1bHNlIDogbnBsc2U7XG4gICAgICAgICAgICBwdWxzZXNbbmV4dC5faWRdLnJlZmxvdyA9IHB1bHNlLnJlZmxvdyB8fCBucGxzZS5yZWZsb3c7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgd2UncmUgc2VlaW5nIHRoaXMgbm9kZSwgcXVldWUgaXQgZm9yIHByb3BhZ2F0aW9uLlxuICAgICAgICAgICAgcHEucHVzaChuZXh0LnFyYW5rKHRydWUpKTtcbiAgICAgICAgICAgIHB1bHNlc1tuZXh0Ll9pZF0gPSBwdWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIFByb2Nlc3MgYSBuZXcgYnJhbmNoIG9mIHRoZSBkYXRhZmxvdyBncmFwaCBwcmlvciB0byBjb25uZWN0aW9uOlxuLy8gKDEpIEluc2VydCBuZXcgQ29sbGVjdG9yIG5vZGVzIGFzIG5lZWRlZC4gXG4vLyAoMikgVHJhY2sgKyByZXR1cm4gbXV0YXRpb24vcm91dGluZyBzdGF0dXMgb2YgdGhlIGJyYW5jaC5cbnByb3RvdHlwZS5wcmVwcm9jZXNzID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIHZhciBncmFwaCA9IHRoaXMsXG4gICAgICBtdXRhdGVzID0gMCxcbiAgICAgIG5vZGUsIHJvdXRlciwgY29sbGVjdG9yLCBjb2xsZWN0cztcblxuICBmb3IgKHZhciBpPTA7IGk8YnJhbmNoLmxlbmd0aDsgKytpKSB7XG4gICAgbm9kZSA9IGJyYW5jaFtpXTtcblxuICAgIC8vIEJhdGNoIG5vZGVzIG5lZWQgYWNjZXNzIHRvIGEgbWF0ZXJpYWxpemVkIGRhdGFzZXQuIFxuICAgIGlmIChub2RlLmJhdGNoKCkgJiYgIW5vZGUuX2NvbGxlY3Rvcikge1xuICAgICAgaWYgKHJvdXRlciB8fCAhY29sbGVjdG9yKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgICAgICAgYnJhbmNoLnNwbGljZShpLCAwLCBub2RlKTtcbiAgICAgICAgcm91dGVyID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLl9jb2xsZWN0b3IgPSBjb2xsZWN0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChjb2xsZWN0cyA9IG5vZGUuY29sbGVjdG9yKCkpKSBjb2xsZWN0b3IgPSBub2RlO1xuICAgIHJvdXRlciAgPSByb3V0ZXIgIHx8IG5vZGUucm91dGVyKCkgJiYgIWNvbGxlY3RzO1xuICAgIG11dGF0ZXMgPSBtdXRhdGVzIHx8IG5vZGUubXV0YXRlcygpO1xuXG4gICAgLy8gQSBjb2xsZWN0b3IgbmVlZHMgdG8gYmUgaW5zZXJ0ZWQgYWZ0ZXIgdHVwbGUtcHJvZHVjaW5nXG4gICAgLy8gbm9kZXMgZm9yIGNvcnJlY3QgcHJldmlvdXMgdmFsdWUgdHJhY2tpbmcuXG4gICAgaWYgKG5vZGUucHJvZHVjZXMoKSkge1xuICAgICAgYnJhbmNoLnNwbGljZShpKzEsIDAsIG5ldyBDb2xsZWN0b3IoZ3JhcGgpKTtcbiAgICAgIHJvdXRlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7cm91dGVyOiByb3V0ZXIsIGNvbGxlY3RvcjogY29sbGVjdG9yLCBtdXRhdGVzOiBtdXRhdGVzfTtcbn07XG5cbnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIHZhciBjb2xsZWN0b3IsIG5vZGUsIGRhdGEsIHNpZ25hbHMsIGksIG4sIGosIG07XG5cbiAgLy8gY29ubmVjdCB0aGUgcGlwZWxpbmVcbiAgZm9yIChpPTAsIG49YnJhbmNoLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmIChub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuXG4gICAgZGF0YSA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLkRBVEEpO1xuICAgIGZvciAoaj0wLCBtPWRhdGEubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5kYXRhKGRhdGFbal0pLmFkZExpc3RlbmVyKGNvbGxlY3Rvcik7XG4gICAgfVxuXG4gICAgc2lnbmFscyA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMpO1xuICAgIGZvciAoaj0wLCBtPXNpZ25hbHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5zaWduYWwoc2lnbmFsc1tqXSkuYWRkTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoaSA+IDApIGJyYW5jaFtpLTFdLmFkZExpc3RlbmVyKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIHZhciBjb2xsZWN0b3IsIG5vZGUsIGRhdGEsIHNpZ25hbHMsIGksIG4sIGosIG07XG5cbiAgZm9yIChpPTAsIG49YnJhbmNoLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmIChub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuXG4gICAgZGF0YSA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLkRBVEEpO1xuICAgIGZvciAoaj0wLCBtPWRhdGEubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5kYXRhKGRhdGFbal0pLnJlbW92ZUxpc3RlbmVyKGNvbGxlY3Rvcik7XG4gICAgfVxuXG4gICAgc2lnbmFscyA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMpO1xuICAgIGZvciAoaj0wLCBtPXNpZ25hbHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5zaWduYWwoc2lnbmFsc1tqXSkucmVtb3ZlTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBub2RlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90b3R5cGUuc3luY2hyb25pemUgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGlkcyA9IHt9LFxuICAgICAgbm9kZSwgZGF0YSwgaSwgbiwgaiwgbSwgZCwgaWQ7XG5cbiAgZm9yIChpPTAsIG49YnJhbmNoLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmICghbm9kZS5jb2xsZWN0b3IoKSkgY29udGludWU7XG5cbiAgICBmb3IgKGo9MCwgZGF0YT1ub2RlLmRhdGEoKSwgbT1kYXRhLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlkID0gKGQgPSBkYXRhW2pdKS5faWQ7XG4gICAgICBpZiAoaWRzW2lkXSkgY29udGludWU7IFxuICAgICAgVHVwbGUucHJldl91cGRhdGUoZCk7XG4gICAgICBpZHNbaWRdID0gMTsgXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciByZWZsb3dlZCA9IHB1bHNlLnJlZmxvdyAmJiBub2RlLmxhc3QoKSA+PSBwdWxzZS5zdGFtcCxcbiAgICAgIHJ1biA9IG5vZGUucm91dGVyKCkgfHwgcHVsc2UuYWRkLmxlbmd0aCB8fCBwdWxzZS5yZW0ubGVuZ3RoO1xuXG4gIHJldHVybiBydW4gfHwgIXJlZmxvd2VkIHx8IG5vZGUucmVldmFsdWF0ZShwdWxzZSk7XG59O1xuXG5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICBpZiAoIXRoaXMucmVldmFsdWF0ZShwdWxzZSwgbm9kZSkpIHJldHVybiBwdWxzZTtcbiAgcHVsc2UgPSBub2RlLmV2YWx1YXRlKHB1bHNlKTtcbiAgbm9kZS5sYXN0KHB1bHNlLnN0YW1wKTtcbiAgcmV0dXJuIHB1bHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcbiIsImZ1bmN0aW9uIEhlYXAoY29tcGFyYXRvcikge1xuICB0aGlzLmNtcCA9IGNvbXBhcmF0b3I7XG4gIHRoaXMubm9kZXMgPSBbXTtcbn1cblxudmFyIHByb3RvdHlwZSA9IEhlYXAucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLm5vZGVzID0gW10sIHRoaXMpO1xufTtcblxucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG59O1xuXG5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcztcbiAgYXJyYXkucHVzaCh4KTtcbiAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoLTEsIHRoaXMuY21wKTtcbn07XG5cbnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcyxcbiAgICAgIGxhc3QgPSBhcnJheS5wb3AoKSxcbiAgICAgIGl0ZW07XG5cbiAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgIGl0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGxhc3Q7XG4gICAgX3NpZnR1cChhcnJheSwgMCwgdGhpcy5jbXApO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0gPSBsYXN0O1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHZhciBhcnJheSA9IHRoaXMubm9kZXMsXG4gICAgICByZXR2YWwgPSBhcnJheVswXTtcbiAgYXJyYXlbMF0gPSBpdGVtO1xuICBfc2lmdHVwKGFycmF5LCAwLCB0aGlzLmNtcCk7XG4gIHJldHVybiByZXR2YWw7XG59O1xuXG5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcywgcmVmID0gYXJyYXlbMF07XG4gIGlmIChhcnJheS5sZW5ndGggJiYgdGhpcy5jbXAocmVmLCBpdGVtKSA8IDApIHtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgaXRlbSA9IHJlZjtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCB0aGlzLmNtcCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCkge1xuICB2YXIgaXRlbSwgcGFyZW50LCBwaWR4O1xuXG4gIGl0ZW0gPSBhcnJheVtpZHhdO1xuICB3aGlsZSAoaWR4ID4gc3RhcnQpIHtcbiAgICBwaWR4ID0gKGlkeCAtIDEpID4+IDE7XG4gICAgcGFyZW50ID0gYXJyYXlbcGlkeF07XG4gICAgaWYgKGNtcChpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgYXJyYXlbaWR4XSA9IHBhcmVudDtcbiAgICAgIGlkeCA9IHBpZHg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIChhcnJheVtpZHhdID0gaXRlbSk7XG59XG5cbmZ1bmN0aW9uIF9zaWZ0dXAoYXJyYXksIGlkeCwgY21wKSB7XG4gIHZhciBzdGFydCA9IGlkeCxcbiAgICAgIGVuZCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGl0ZW0gPSBhcnJheVtpZHhdLFxuICAgICAgY2lkeCA9IDIgKiBpZHggKyAxLCByaWR4O1xuXG4gIHdoaWxlIChjaWR4IDwgZW5kKSB7XG4gICAgcmlkeCA9IGNpZHggKyAxO1xuICAgIGlmIChyaWR4IDwgZW5kICYmIGNtcChhcnJheVtjaWR4XSwgYXJyYXlbcmlkeF0pID49IDApIHtcbiAgICAgIGNpZHggPSByaWR4O1xuICAgIH1cbiAgICBhcnJheVtpZHhdID0gYXJyYXlbY2lkeF07XG4gICAgaWR4ID0gY2lkeDtcbiAgICBjaWR4ID0gMiAqIGlkeCArIDE7XG4gIH1cbiAgYXJyYXlbaWR4XSA9IGl0ZW07XG4gIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhcDtcbiIsInZhciBERVBTID0gcmVxdWlyZSgnLi9EZXBlbmRlbmNpZXMnKS5BTEwsXG4gICAgbm9kZUlEID0gMDtcblxuZnVuY3Rpb24gTm9kZShncmFwaCkge1xuICBpZiAoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG59XG5cbnZhciBGbGFncyA9IE5vZGUuRmxhZ3MgPSB7XG4gIFJvdXRlcjogICAgIDB4MDEsIC8vIFJlc3BvbnNpYmxlIGZvciBwcm9wYWdhdGluZyB0dXBsZXMsIGNhbm5vdCBiZSBza2lwcGVkLlxuICBDb2xsZWN0b3I6ICAweDAyLCAvLyBIb2xkcyBhIG1hdGVyaWFsaXplZCBkYXRhc2V0LCBwdWxzZSBub2RlIHRvIHJlZmxvdy5cbiAgUHJvZHVjZXM6ICAgMHgwNCwgLy8gUHJvZHVjZXMgbmV3IHR1cGxlcy4gXG4gIE11dGF0ZXM6ICAgIDB4MDgsIC8vIFNldHMgcHJvcGVydGllcyBvZiBpbmNvbWluZyB0dXBsZXMuXG4gIFJlZmxvd3M6ICAgIDB4MTAsIC8vIEZvcndhcmRzIGEgcmVmbG93IHB1bHNlLlxuICBCYXRjaDogICAgICAweDIwICAvLyBQZXJmb3JtcyBiYXRjaCBkYXRhIHByb2Nlc3NpbmcsIG5lZWRzIGNvbGxlY3Rvci5cbn07XG5cbnZhciBwcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9pZCA9ICsrbm9kZUlEO1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9yYW5rICA9IGdyYXBoLnJhbmsoKTsgLy8gVG9wb2xvZ2ljYWwgc29ydCBieSByYW5rXG4gIHRoaXMuX3FyYW5rID0gbnVsbDsgLy8gUmFuayB3aGVuIGVucXVldWVkIGZvciBwcm9wYWdhdGlvblxuICB0aGlzLl9zdGFtcCA9IDA7ICAgIC8vIExhc3Qgc3RhbXAgc2VlblxuXG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9saXN0ZW5lcnMuX2lkcyA9IHt9OyAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0ZSBsaXN0ZW5lcnNcblxuICAvLyBJbml0aWFsaXplIGRlcGVuZGVuY2llcy5cbiAgdGhpcy5fZGVwcyA9IHt9O1xuICBmb3IgKHZhciBpPTAsIG49REVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdGhpcy5fZGVwc1tERVBTW2ldXSA9IFtdO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBzdGF0dXMgZmxhZ3MuXG4gIHRoaXMuX2ZsYWdzID0gMDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yYW5rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yYW5rO1xufTtcblxucHJvdG90eXBlLnFyYW5rID0gZnVuY3Rpb24oLyogc2V0ICovKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3FyYW5rO1xuICByZXR1cm4gKHRoaXMuX3FyYW5rID0gdGhpcy5fcmFuaywgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKHN0YW1wKSB7IFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zdGFtcDtcbiAgcmV0dXJuICh0aGlzLl9zdGFtcCA9IHN0YW1wLCB0aGlzKTtcbn07XG5cbi8vIC0tIHN0YXR1cyBmbGFncyAtLS1cblxucHJvdG90eXBlLl9zZXRmID0gZnVuY3Rpb24odiwgYikge1xuICBpZiAoYikgeyB0aGlzLl9mbGFncyB8PSB2OyB9IGVsc2UgeyB0aGlzLl9mbGFncyAmPSB+djsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3V0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5Sb3V0ZXIpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5Sb3V0ZXIsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5jb2xsZWN0b3IgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5Db2xsZWN0b3IpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5Db2xsZWN0b3IsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5wcm9kdWNlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLlByb2R1Y2VzKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuUHJvZHVjZXMsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5tdXRhdGVzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuTXV0YXRlcyk7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLk11dGF0ZXMsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5yZWZsb3dzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuUmVmbG93cyk7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLlJlZmxvd3MsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLkJhdGNoKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuQmF0Y2gsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICB2YXIgZCA9IHRoaXMuX2RlcHNbdHlwZV0sXG4gICAgICBuID0gZC5fbmFtZXMgfHwgKGQuX25hbWVzID0ge30pOyAgLy8gVG8gcHJldmVudCBkdXBlIGRlcHNcblxuICAvLyBHZXQgZGVwZW5kZW5jaWVzIG9mIHRoZSBnaXZlbiB0eXBlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICBpZiAoZGVwcyA9PT0gbnVsbCkge1xuICAgIC8vIENsZWFyIGRlcGVuZGVuY2llcyBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGQuc3BsaWNlKDAsIGQubGVuZ3RoKTtcbiAgICBkLl9uYW1lcyA9IHt9O1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgLy8gU2VwYXJhdGUgdGhpcyBjYXNlIHRvIGF2b2lkIGNvc3Qgb2YgYXJyYXkgY3JlYXRpb25cbiAgICBpZiAobltkZXBzXSkgcmV0dXJuIHRoaXM7XG4gICAgZC5wdXNoKGRlcHMpO1xuICAgIG5bZGVwc10gPSAxO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoLCBkZXA7IGk8bGVuOyArK2kpIHtcbiAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICBpZiAobltkZXBdKSBjb250aW51ZTtcbiAgICAgIGQucHVzaChkZXApO1xuICAgICAgbltkZXBdID0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycztcbn07XG5cbnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKCEobCBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0xpc3RlbmVyIGlzIG5vdCBhIE5vZGUnKTtcbiAgfVxuICBpZiAodGhpcy5fbGlzdGVuZXJzLl9pZHNbbC5faWRdKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl9saXN0ZW5lcnMucHVzaChsKTtcbiAgdGhpcy5fbGlzdGVuZXJzLl9pZHNbbC5faWRdID0gMTtcbiAgaWYgKHRoaXMuX3JhbmsgPiBsLl9yYW5rKSB7XG4gICAgdmFyIHEgPSBbbF0sXG4gICAgICAgIGcgPSB0aGlzLl9ncmFwaCwgY3VyO1xuICAgIHdoaWxlIChxLmxlbmd0aCkge1xuICAgICAgY3VyID0gcS5zaGlmdCgpO1xuICAgICAgY3VyLl9yYW5rID0gZy5yYW5rKCk7XG4gICAgICBxLnVuc2hpZnQuYXBwbHkocSwgY3VyLmxpc3RlbmVycygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0pIHJldHVybiBmYWxzZTtcbiAgXG4gIHZhciBpZHggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsKSxcbiAgICAgIGIgPSBpZHggPj0gMDtcblxuICBpZiAoYikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0gPSBudWxsO1xuICB9XG4gIHJldHVybiBiO1xufTtcblxucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX2xpc3RlbmVycy5faWRzID0ge307XG59O1xuXG4vLyBFdmFsdWF0ZSB0aGlzIGRhdGFmbG93IG5vZGUgZm9yIHRoZSBjdXJyZW50IHB1bHNlLlxuLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gcHJvY2Vzc2luZy5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHJldHVybiBwdWxzZTtcbn07XG5cbi8vIFNob3VsZCB0aGlzIG5vZGUgYmUgcmUtZXZhbHVhdGVkIGZvciB0aGUgY3VycmVudCBwdWxzZT9cbi8vIFNlYXJjaGVzIHB1bHNlIHRvIHNlZSBpZiBhbnkgZGVwZW5kZW5jaWVzIGhhdmUgdXBkYXRlZC5cbnByb3RvdHlwZS5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHtcbiAgdmFyIHByb3AsIGRlcCwgaSwgbiwgaiwgbTtcblxuICBmb3IgKGk9MCwgbj1ERVBTLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gREVQU1tpXTtcbiAgICBkZXAgPSB0aGlzLl9kZXBzW3Byb3BdO1xuICAgIGZvciAoaj0wLCBtPWRlcC5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAocHVsc2VbcHJvcF1bZGVwW2pdXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuTm9kZS5yZXNldCA9IGZ1bmN0aW9uKCkgeyBub2RlSUQgPSAwOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG4iLCJ2YXIgQ2hhbmdlU2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIEJhc2UgPSBOb2RlLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gU2lnbmFsKGdyYXBoLCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9uYW1lICA9IG5hbWU7XG4gIHRoaXMuX3ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICB0aGlzLl92ZXJib3NlID0gZmFsc2U7IC8vIFZlcmJvc2Ugc2lnbmFscyByZS1wdWxzZSB0aGUgZ3JhcGggZXZlbiBpZiBwcmV2ID09PSB2YWwuXG4gIHRoaXMuX2hhbmRsZXJzID0gW107XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFNpZ25hbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpZ25hbDtcblxucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25hbWU7XG59O1xuXG5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIHJldHVybiAodGhpcy5fdmFsdWUgPSB2YWwsIHRoaXMpO1xufTtcblxuLy8gQWxpYXMgdG8gdmFsdWUsIGZvciBzaGFyZWQgQVBJIHdpdGggRGF0YVNvdXJjZVxucHJvdG90eXBlLnZhbHVlcyA9IHByb3RvdHlwZS52YWx1ZTtcblxucHJvdG90eXBlLnZlcmJvc2UgPSBmdW5jdGlvbih2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZlcmJvc2U7XG4gIHJldHVybiAodGhpcy5fdmVyYm9zZSA9ICEhdiwgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQuc2lnbmFsc1t0aGlzLl9uYW1lXSA/IGlucHV0IDogdGhpcy5fZ3JhcGguZG9Ob3RQcm9wYWdhdGU7XG59O1xuXG5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmICghY3MpIGNzID0gQ2hhbmdlU2V0LmNyZWF0ZShudWxsLCB0cnVlKTtcbiAgY3Muc2lnbmFsc1t0aGlzLl9uYW1lXSA9IDE7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShjcywgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciBzaWduYWwgPSB0aGlzLFxuICAgICAgbm9kZSA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcblxuICBub2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBoYW5kbGVyKHNpZ25hbC5uYW1lKCksIHNpZ25hbC52YWx1ZSgpKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlcnMucHVzaCh7XG4gICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICBub2RlOiBub2RlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKG5vZGUpO1xufTtcblxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIGggPSB0aGlzLl9oYW5kbGVycywgaSwgeDtcblxuICBmb3IgKGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICB4ID0gaC5zcGxpY2UoaSwgMSlbMF07XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHgubm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbDtcbiIsInZhciB0dXBsZUlEID0gMDtcblxuZnVuY3Rpb24gaW5nZXN0KGRhdHVtKSB7XG4gIGRhdHVtID0gKGRhdHVtID09PSBPYmplY3QoZGF0dW0pKSA/IGRhdHVtIDoge2RhdGE6IGRhdHVtfTtcbiAgZGF0dW0uX2lkID0gKyt0dXBsZUlEO1xuICBpZiAoZGF0dW0uX3ByZXYpIGRhdHVtLl9wcmV2ID0gbnVsbDtcbiAgcmV0dXJuIGRhdHVtO1xufVxuXG5mdW5jdGlvbiBpZE1hcChhLCBpZHMpIHtcbiAgaWRzID0gaWRzIHx8IHt9O1xuICBmb3IgKHZhciBpPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaWRzW2FbaV0uX2lkXSA9IDE7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cblxuZnVuY3Rpb24gY29weSh0LCBjKSB7XG4gIGMgPSBjIHx8IHt9O1xuICBmb3IgKHZhciBrIGluIHQpIHtcbiAgICBpZiAoayAhPT0gJ19wcmV2JyAmJiBrICE9PSAnX2lkJykgY1trXSA9IHRba107XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmdlc3Q6IGluZ2VzdCxcbiAgaWRNYXA6IGlkTWFwLFxuXG4gIGRlcml2ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBpbmdlc3QoY29weShkKSk7XG4gIH0sXG5cbiAgcmVkZXJpdmU6IGZ1bmN0aW9uKGQsIHQpIHtcbiAgICByZXR1cm4gY29weShkLCB0KTtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uKHQsIGssIHYpIHtcbiAgICByZXR1cm4gdFtrXSA9PT0gdiA/IDAgOiAodFtrXSA9IHYsIDEpO1xuICB9LFxuXG4gIHByZXY6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5fcHJldiB8fCB0O1xuICB9LFxuXG4gIHByZXZfaW5pdDogZnVuY3Rpb24odCkge1xuICAgIGlmICghdC5fcHJldikgeyB0Ll9wcmV2ID0ge19pZDogdC5faWR9OyB9XG4gIH0sXG5cbiAgcHJldl91cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgcCA9IHQuX3ByZXYsIGssIHY7XG4gICAgaWYgKHApIGZvciAoayBpbiB0KSB7XG4gICAgICBpZiAoayAhPT0gJ19wcmV2JyAmJiBrICE9PSAnX2lkJykge1xuICAgICAgICBwW2tdID0gKCh2PXRba10pIGluc3RhbmNlb2YgT2JqZWN0ICYmIHYuX3ByZXYpID8gdi5fcHJldiA6IHY7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHsgdHVwbGVJRCA9IDA7IH0sXG5cbiAgaWRGaWx0ZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgaWRzID0ge307XG4gICAgZm9yICh2YXIgaT1hcmd1bWVudHMubGVuZ3RoOyAtLWk+MDspIHtcbiAgICAgIGlkTWFwKGFyZ3VtZW50c1tpXSwgaWRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpZHNbeC5faWRdOyB9KTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBDaGFuZ2VTZXQ6ICAgIHJlcXVpcmUoJy4vQ2hhbmdlU2V0JyksXG4gIENvbGxlY3RvcjogICAgcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgRGF0YVNvdXJjZTogICByZXF1aXJlKCcuL0RhdGFTb3VyY2UnKSxcbiAgRGVwZW5kZW5jaWVzOiByZXF1aXJlKCcuL0RlcGVuZGVuY2llcycpLFxuICBHcmFwaDogICAgICAgIHJlcXVpcmUoJy4vR3JhcGgnKSxcbiAgTm9kZTogICAgICAgICByZXF1aXJlKCcuL05vZGUnKSxcbiAgU2lnbmFsOiAgICAgICByZXF1aXJlKCcuL1NpZ25hbCcpLFxuICBUdXBsZTogICAgICAgIHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgZGVidWc6ICAgICAgICByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKS5kZWJ1Z1xufTtcbiIsImZ1bmN0aW9uIHRvTWFwKGxpc3QpIHtcbiAgdmFyIG1hcCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj1saXN0Lmxlbmd0aDsgaTxuOyArK2kpIG1hcFtsaXN0W2ldXSA9IDE7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHZhciBsaXN0ID0gW10sIGs7XG4gIGZvciAoayBpbiBvYmplY3QpIGxpc3QucHVzaChrKTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgcmVxdWlyZSgnLi9jb25zdGFudHMnKSxcbiAgICAgIGZ1bmN0aW9ucyA9IChvcHQuZnVuY3Rpb25zIHx8IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykpKGNvZGVnZW4pLFxuICAgICAgaWRXaGl0ZUxpc3QgPSBvcHQuaWRXaGl0ZUxpc3QgPyB0b01hcChvcHQuaWRXaGl0ZUxpc3QpIDogbnVsbCxcbiAgICAgIGlkQmxhY2tMaXN0ID0gb3B0LmlkQmxhY2tMaXN0ID8gdG9NYXAob3B0LmlkQmxhY2tMaXN0KSA6IG51bGwsXG4gICAgICBtZW1iZXJEZXB0aCA9IDAsXG4gICAgICBGSUVMRF9WQVIgPSBvcHQuZmllbGRWYXIgfHwgJ2RhdHVtJyxcbiAgICAgIEdMT0JBTF9WQVIgPSBvcHQuZ2xvYmFsVmFyIHx8ICdzaWduYWxzJyxcbiAgICAgIGdsb2JhbHMgPSB7fSxcbiAgICAgIGZpZWxkcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW5fd3JhcChhc3QpIHsgICAgXG4gICAgdmFyIHJldHZhbCA9IHtcbiAgICAgIGNvZGU6IGNvZGVnZW4oYXN0KSxcbiAgICAgIGdsb2JhbHM6IGtleXMoZ2xvYmFscyksXG4gICAgICBmaWVsZHM6IGtleXMoZmllbGRzKVxuICAgIH07XG4gICAgZ2xvYmFscyA9IHt9O1xuICAgIGZpZWxkcyA9IHt9O1xuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBHbG9iYWwoaWQpIHtcbiAgICByZXR1cm4gR0xPQkFMX1ZBUiArICdbXCInICsgaWQgKyAnXCJdJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgaWYgKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSByZXR1cm4gYXN0O1xuICAgIHZhciBnZW5lcmF0b3IgPSBDT0RFR0VOX1RZUEVTW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIGFzdC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRvcihhc3QpO1xuICB9XG5cbiAgdmFyIENPREVHRU5fVFlQRVMgPSB7XG4gICAgJ0xpdGVyYWwnOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLnJhdztcbiAgICAgIH0sXG4gICAgJ0lkZW50aWZpZXInOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBpZCA9IG4ubmFtZTtcbiAgICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZFdoaXRlTGlzdCkge1xuICAgICAgICAgIGlmIChpZFdoaXRlTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsc1tpZF0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cEdsb2JhbChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZEJsYWNrTGlzdCAmJiBpZEJsYWNrTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaWRlbnRpZmllcjogJyArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9LFxuICAgICdQcm9ncmFtJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5ib2R5Lm1hcChjb2RlZ2VuKS5qb2luKCdcXG4nKTtcbiAgICAgIH0sXG4gICAgJ01lbWJlckV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBkID0gIW4uY29tcHV0ZWQ7XG4gICAgICAgIHZhciBvID0gY29kZWdlbihuLm9iamVjdCk7XG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgcCA9IGNvZGVnZW4obi5wcm9wZXJ0eSk7XG4gICAgICAgIGlmIChvID09PSBGSUVMRF9WQVIpIHsgZmllbGRzW3BdID0gMTsgfSAvLyBIQUNLaXNoLi4uXG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gbyArIChkID8gJy4nK3AgOiAnWycrcCsnXScpO1xuICAgICAgfSxcbiAgICAnQ2FsbEV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2FsbGVlIHR5cGU6ICcgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGVlID0gbi5jYWxsZWUubmFtZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb25zLmhhc093blByb3BlcnR5KGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICAgIGlmICghZm4pIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiAnICsgY2FsbGVlKTtcbiAgICAgICAgcmV0dXJuIGZuIGluc3RhbmNlb2YgRnVuY3Rpb24gP1xuICAgICAgICAgIGZuKGFyZ3MpIDpcbiAgICAgICAgICBmbiArICcoJyArIGFyZ3MubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0sXG4gICAgJ0FycmF5RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICdbJyArIG4uZWxlbWVudHMubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICddJztcbiAgICAgIH0sXG4gICAgJ0JpbmFyeUV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArICcpJztcbiAgICAgIH0sXG4gICAgJ1VuYXJ5RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICcoJyArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpICsgJyknO1xuICAgICAgfSxcbiAgICAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJygnICsgY29kZWdlbihuLnRlc3QpICtcbiAgICAgICAgICAnPycgKyBjb2RlZ2VuKG4uY29uc2VxdWVudCkgK1xuICAgICAgICAgICc6JyArIGNvZGVnZW4obi5hbHRlcm5hdGUpICtcbiAgICAgICAgICAnKSc7XG4gICAgICB9LFxuICAgICdMb2dpY2FsRXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICcoJyArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgJyknO1xuICAgICAgfSxcbiAgICAnT2JqZWN0RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICd7JyArIG4ucHJvcGVydGllcy5tYXAoY29kZWdlbikuam9pbignLCcpICsgJ30nO1xuICAgICAgfSxcbiAgICAnUHJvcGVydHknOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBrID0gY29kZWdlbihuLmtleSk7XG4gICAgICAgIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBrICsgJzonICsgY29kZWdlbihuLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuKG4uZXhwcmVzc2lvbik7XG4gICAgICB9XG4gIH07XG5cbiAgY29kZWdlbl93cmFwLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgY29kZWdlbl93cmFwLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgcmV0dXJuIGNvZGVnZW5fd3JhcDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ05hTic6ICAgICAnTmFOJyxcbiAgJ0UnOiAgICAgICAnTWF0aC5FJyxcbiAgJ0xOMic6ICAgICAnTWF0aC5MTjInLFxuICAnTE4xMCc6ICAgICdNYXRoLkxOMTAnLFxuICAnTE9HMkUnOiAgICdNYXRoLkxPRzJFJyxcbiAgJ0xPRzEwRSc6ICAnTWF0aC5MT0cxMEUnLFxuICAnUEknOiAgICAgICdNYXRoLlBJJyxcbiAgJ1NRUlQxXzInOiAnTWF0aC5TUVJUMV8yJyxcbiAgJ1NRUlQyJzogICAnTWF0aC5TUVJUMidcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2RlZ2VuKSB7XG5cbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICB2YXIgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArICcoJyArIG9iaiArICcpJztcbiAgICAgIGlmIChjYXN0Lmxhc3RJbmRleE9mKCduZXcgJywgMCkgPT09IDApIG9iaiA9ICcoJyArIG9iaiArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIG9iaiArICcuJyArIG5hbWUgKyAodHlwZSA8IDAgPyAnJyA6IHR5cGUgPT09IDAgP1xuICAgICAgJygpJyA6XG4gICAgICAnKCcgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4obmFtZSwgY2FzdCwgdHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpO1xuICAgIH07XG4gIH1cblxuICB2YXIgREFURSA9ICduZXcgRGF0ZScsXG4gICAgICBTVFJJTkcgPSAnU3RyaW5nJyxcbiAgICAgIFJFR0VYUCA9ICdSZWdFeHAnO1xuXG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICAnaXNOYU4nOiAgICAnaXNOYU4nLFxuICAgICdpc0Zpbml0ZSc6ICdpc0Zpbml0ZScsXG4gICAgJ2Ficyc6ICAgICAgJ01hdGguYWJzJyxcbiAgICAnYWNvcyc6ICAgICAnTWF0aC5hY29zJyxcbiAgICAnYXNpbic6ICAgICAnTWF0aC5hc2luJyxcbiAgICAnYXRhbic6ICAgICAnTWF0aC5hdGFuJyxcbiAgICAnYXRhbjInOiAgICAnTWF0aC5hdGFuMicsXG4gICAgJ2NlaWwnOiAgICAgJ01hdGguY2VpbCcsXG4gICAgJ2Nvcyc6ICAgICAgJ01hdGguY29zJyxcbiAgICAnZXhwJzogICAgICAnTWF0aC5leHAnLFxuICAgICdmbG9vcic6ICAgICdNYXRoLmZsb29yJyxcbiAgICAnbG9nJzogICAgICAnTWF0aC5sb2cnLFxuICAgICdtYXgnOiAgICAgICdNYXRoLm1heCcsXG4gICAgJ21pbic6ICAgICAgJ01hdGgubWluJyxcbiAgICAncG93JzogICAgICAnTWF0aC5wb3cnLFxuICAgICdyYW5kb20nOiAgICdNYXRoLnJhbmRvbScsXG4gICAgJ3JvdW5kJzogICAgJ01hdGgucm91bmQnLFxuICAgICdzaW4nOiAgICAgICdNYXRoLnNpbicsXG4gICAgJ3NxcnQnOiAgICAgJ01hdGguc3FydCcsXG4gICAgJ3Rhbic6ICAgICAgJ01hdGgudGFuJyxcblxuICAgICdjbGFtcCc6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICB2YXIgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgcmV0dXJuICdNYXRoLm1heCgnK2FbMV0rJywgTWF0aC5taW4oJythWzJdKycsJythWzBdKycpKSc7XG4gICAgfSxcblxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgJ25vdyc6ICAgICAgICAgICAgICdEYXRlLm5vdycsXG4gICAgJ2RhdGV0aW1lJzogICAgICAgIERBVEUsXG4gICAgJ2RhdGUnOiAgICAgICAgICAgIGZuKCdnZXREYXRlJywgREFURSwgMCksXG4gICAgJ2RheSc6ICAgICAgICAgICAgIGZuKCdnZXREYXknLCBEQVRFLCAwKSxcbiAgICAneWVhcic6ICAgICAgICAgICAgZm4oJ2dldEZ1bGxZZWFyJywgREFURSwgMCksXG4gICAgJ21vbnRoJzogICAgICAgICAgIGZuKCdnZXRNb250aCcsIERBVEUsIDApLFxuICAgICdob3Vycyc6ICAgICAgICAgICBmbignZ2V0SG91cnMnLCBEQVRFLCAwKSxcbiAgICAnbWludXRlcyc6ICAgICAgICAgZm4oJ2dldE1pbnV0ZXMnLCBEQVRFLCAwKSxcbiAgICAnc2Vjb25kcyc6ICAgICAgICAgZm4oJ2dldFNlY29uZHMnLCBEQVRFLCAwKSxcbiAgICAnbWlsbGlzZWNvbmRzJzogICAgZm4oJ2dldE1pbGxpc2Vjb25kcycsIERBVEUsIDApLFxuICAgICd0aW1lJzogICAgICAgICAgICBmbignZ2V0VGltZScsIERBVEUsIDApLFxuICAgICd0aW1lem9uZW9mZnNldCc6ICBmbignZ2V0VGltZXpvbmVPZmZzZXQnLCBEQVRFLCAwKSxcbiAgICAndXRjZGF0ZSc6ICAgICAgICAgZm4oJ2dldFVUQ0RhdGUnLCBEQVRFLCAwKSxcbiAgICAndXRjZGF5JzogICAgICAgICAgZm4oJ2dldFVUQ0RheScsIERBVEUsIDApLFxuICAgICd1dGN5ZWFyJzogICAgICAgICBmbignZ2V0VVRDRnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICAndXRjbW9udGgnOiAgICAgICAgZm4oJ2dldFVUQ01vbnRoJywgREFURSwgMCksXG4gICAgJ3V0Y2hvdXJzJzogICAgICAgIGZuKCdnZXRVVENIb3VycycsIERBVEUsIDApLFxuICAgICd1dGNtaW51dGVzJzogICAgICBmbignZ2V0VVRDTWludXRlcycsIERBVEUsIDApLFxuICAgICd1dGNzZWNvbmRzJzogICAgICBmbignZ2V0VVRDU2Vjb25kcycsIERBVEUsIDApLFxuICAgICd1dGNtaWxsaXNlY29uZHMnOiBmbignZ2V0VVRDTWlsbGlzZWNvbmRzJywgREFURSwgMCksXG5cbiAgICAvLyBzaGFyZWQgc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgJ2xlbmd0aCc6ICAgICAgZm4oJ2xlbmd0aCcsIG51bGwsIC0xKSxcbiAgICAnaW5kZXhvZic6ICAgICBmbignaW5kZXhPZicsIG51bGwpLFxuICAgICdsYXN0aW5kZXhvZic6IGZuKCdsYXN0SW5kZXhPZicsIG51bGwpLFxuXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgICdwYXJzZUZsb2F0JzogICdwYXJzZUZsb2F0JyxcbiAgICAncGFyc2VJbnQnOiAgICAncGFyc2VJbnQnLFxuICAgICd1cHBlcic6ICAgICAgIGZuKCd0b1VwcGVyQ2FzZScsIFNUUklORywgMCksXG4gICAgJ2xvd2VyJzogICAgICAgZm4oJ3RvTG93ZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICAnc2xpY2UnOiAgICAgICBmbignc2xpY2UnLCBTVFJJTkcpLFxuICAgICdzdWJzdHJpbmcnOiAgIGZuKCdzdWJzdHJpbmcnLCBTVFJJTkcpLFxuXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgICdyZWdleHAnOiAgUkVHRVhQLFxuICAgICd0ZXN0JzogICAgZm4oJ3Rlc3QnLCBSRUdFWFApLFxuXG4gICAgLy8gQ29udHJvbCBGbG93IGZ1bmN0aW9uc1xuICAgICdpZic6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi4nKTtcbiAgICAgICAgdmFyIGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgICAgcmV0dXJuIGFbMF0rJz8nK2FbMV0rJzonK2FbMl07XG4gICAgICB9XG4gIH07XG59OyIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpLFxuICAgIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbiAgICBcbnZhciBleHByID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgb3B0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCcoJytpbnB1dCsnKScsIG9wdCk7XG4gICAgfSxcbiAgY29kZTogZnVuY3Rpb24ob3B0KSB7XG4gICAgICByZXR1cm4gY29kZWdlbihvcHQpO1xuICAgIH0sXG4gIGNvbXBpbGVyOiBmdW5jdGlvbihhcmdzLCBvcHQpIHtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gY29kZWdlbihvcHQpLFxuICAgICAgICAgIGxlbiA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGNvbXBpbGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdlbmVyYXRvcihleHByLnBhcnNlKHN0cikpO1xuICAgICAgICAgICAgYXJnc1tsZW5dID0gJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyB2YWx1ZS5jb2RlICsgJyk7JztcbiAgICAgICAgICAgIHZhbHVlLmZuID0gRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgIGNvbXBpbGUuY29kZWdlbiA9IGdlbmVyYXRvcjtcbiAgICAgIHJldHVybiBjb21waWxlO1xuICAgIH0sXG4gIGZ1bmN0aW9uczogcmVxdWlyZSgnLi9mdW5jdGlvbnMnKSxcbiAgY29uc3RhbnRzOiByZXF1aXJlKCcuL2NvbnN0YW50cycpXG59O1xuIiwiLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVG9rZW4sXG4gICAgICBUb2tlbk5hbWUsXG4gICAgICBTeW50YXgsXG4gICAgICBQcm9wZXJ0eUtpbmQsXG4gICAgICBNZXNzYWdlcyxcbiAgICAgIFJlZ2V4LFxuICAgICAgc291cmNlLFxuICAgICAgc3RyaWN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsaW5lTnVtYmVyLFxuICAgICAgbGluZVN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgbG9va2FoZWFkLFxuICAgICAgc3RhdGUsXG4gICAgICBleHRyYTtcblxuICBUb2tlbiA9IHtcbiAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgRU9GOiAyLFxuICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgIEtleXdvcmQ6IDQsXG4gICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOVxuICB9O1xuXG4gIFRva2VuTmFtZSA9IHt9O1xuICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcblxuICBTeW50YXggPSB7XG4gICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJ1xuICB9O1xuXG4gIFByb3BlcnR5S2luZCA9IHtcbiAgICAgIERhdGE6IDEsXG4gICAgICBHZXQ6IDIsXG4gICAgICBTZXQ6IDRcbiAgfTtcblxuICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICBNZXNzYWdlcyA9IHtcbiAgICAgIFVuZXhwZWN0ZWRUb2tlbjogICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgIE5ld2xpbmVBZnRlclRocm93OiAgJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXG4gICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RNb2RlV2l0aDogICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbU5hbWU6ICAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIEFjY2Vzc29yRGF0YVByb3BlcnR5OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUG9zdGZpeDogICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gIH07XG5cbiAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgUmVnZXggPSB7XG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICB9XG5cbiAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gIH1cblxuICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgLy8gNy42LjEuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICBjYXNlICd5aWVsZCc6XG4gICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICAvLyA3LjYuMS4xIEtleXdvcmRzXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgLy8gJ3lpZWxkJyBhbmQgJ2xldCcgYXJlIGZvciBjb21wYXRpYmxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG5cbiAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICB2YXIgY2gsIHN0YXJ0O1xuXG4gICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgY29kZSA9IDA7XG5cbiAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVVEYtMTYgRW5jb2RpbmdcbiAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgfVxuICAgICAgY3UxID0gKChjb2RlIC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwO1xuICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIGNoLCBpZDtcblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZCA9IGNoO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXl3b3JkKGlkKSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLk51bGxMaXRlcmFsO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgY2gyLFxuICAgICAgICAgIGNoMyxcbiAgICAgICAgICBjaDQ7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuXG4gICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgIGNhc2UgMHgyRTogIC8vIC4gZG90XG4gICAgICBjYXNlIDB4Mjg6ICAvLyAoIG9wZW4gYnJhY2tldFxuICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICBjYXNlIDB4M0I6ICAvLyA7IHNlbWljb2xvblxuICAgICAgY2FzZSAweDJDOiAgLy8gLCBjb21tYVxuICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4N0Q6ICAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4NUI6ICAvLyBbXG4gICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICBjYXNlIDB4M0E6ICAvLyA6XG4gICAgICBjYXNlIDB4M0Y6ICAvLyA/XG4gICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDdCKSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgIC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDB4MkI6ICAvLyArXG4gICAgICAgICAgICAgIGNhc2UgMHgyRDogIC8vIC1cbiAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICBjYXNlIDB4M0M6ICAvLyA8XG4gICAgICAgICAgICAgIGNhc2UgMHgzRTogIC8vID5cbiAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICBjYXNlIDB4N0M6ICAvLyB8XG4gICAgICAgICAgICAgIGNhc2UgMHgyNTogIC8vICVcbiAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICBjYXNlIDB4MkE6ICAvLyAqXG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcbiAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuXG4gICAgICAgICAgICAgICAgICAvLyAhPT0gYW5kID09PVxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cblxuICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgIGlmIChjaDQgPT09ICc+Pj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoNCxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgICAgIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuICAgICAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDIsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICB9XG5cbiAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgIG51bWJlciA9ICcnO1xuICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG4gICAgICAgICAgICAgIGlmIChjaCAmJiBpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZSwgb2N0YWwgPSBmYWxzZSwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydExpbmVTdGFydDtcbiAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgIHZhciB0bXAgPSBwYXR0ZXJuLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgICAgICAgLy8gYC91YCBmbGFnLlxuICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csICd4Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgIC8vIHVzZXMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgc3RyID0gJyc7XG4gICAgICBmbGFncyA9ICcnO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZmxhZ3MsXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuXG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuXG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sIHdoaWNoIGlzIGxpa2VseSAnLycgb3IgJy89J1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0b2tlbi5yYW5nZVswXSA9PT0gcG9zICYmIHRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICByZWdleDogcmVnZXgucmVnZXgsXG4gICAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlU2xhc2goKSB7XG4gICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgIGNoZWNrVG9rZW47XG4gICAgICAvLyBVc2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICBwcmV2VG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFwcmV2VG9rZW4pIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2ZvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJiBwcmV2VG9rZW4udmFsdWUgIT09ICd0aGlzJykge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgIHZhciBjaDtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xuICAgICAgICAgIHJldHVybiBhZHZhbmNlU2xhc2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgIHZhciB0b2tlbjtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG5cbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgdGhpcy5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKSB7XG4gICAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgICAvLyBTa2lwIGNvbW1lbnQuXG4gICAgICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5zdGFydExpbmVTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5saW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW2luZGV4LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRUb2tlbi5zdGFydCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIFdyYXBwaW5nTm9kZS5wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZSA9IHtcblxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFuZ2VbMV0gPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MaXRlcmFsO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmF3ID09ICcvLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9ICcvKD86KS8nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9ncmFtO1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydCwgZm91bmQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIHRva2VuLmxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3JUb2xlcmFudCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBleHBlY3RUb2xlcmFudFxuICAgKiBAZGVzY3JpcHRpb24gUXVpZXRseSBleHBlY3QgdGhlIGdpdmVuIHRva2VuIHZhbHVlIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlc1xuICAgKiB0byA8Y29kZT5leHBlY3QodmFsdWUpPC9jb2RlPlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHdlIGFyZSBleHBlY3RpbmcgdGhlIGxvb2thaGVhZCB0b2tlbiB0byBoYXZlXG4gICAqIEBzaW5jZSAyLjBcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGVjdFRvbGVyYW50KHZhbHVlKSB7XG4gICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lU2VtaWNvbG9uKCkge1xuICAgICAgdmFyIGxpbmU7XG5cbiAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IGxpbmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GICYmICFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG4gIH1cblxuICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV4KCk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gIH1cblxuICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgdmFsdWUsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCBwcm9wZXJ0eSwgbmFtZSwga2V5LCBraW5kLCBtYXAgPSB7fSwgdG9TdHJpbmcgPSBTdHJpbmcsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICBrZXkgPSAnJCcgKyBuYW1lO1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXBba2V5XSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYga2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBba2V5XSAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXBba2V5XSB8PSBraW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgKytzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG5cbiAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgdmFyIGxlZ2FsS2V5d29yZHMgPSB7XCJpZlwiOjEsIFwidGhpc1wiOjF9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIG5vZGU7XG5cbiAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fCBsZWdhbEtleXdvcmRzW2xvb2thaGVhZC52YWx1ZV0pIHtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4udmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChjb2xsZWN0UmVnZXgoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChzY2FuUmVnRXhwKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWVrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCBtYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCBtYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPT0nOlxuICAgICAgY2FzZSAnIT0nOlxuICAgICAgY2FzZSAnPT09JzpcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6XG4gICAgICBjYXNlICc8PSc6XG4gICAgICBjYXNlICc+PSc6XG4gICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgIGNhc2UgJz4+JzpcbiAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnLyc6XG4gICAgICBjYXNlICclJzpcbiAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVjO1xuICB9XG5cbiAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcblxuICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgbGV4KCk7XG5cbiAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICBpIC09IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTIgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgc3RhcnRUb2tlbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBvbGRQYXJlbnRoZXNpc0NvdW50LCB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDEyIFN0YXRlbWVudHNcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgZXhwcixcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBibG9jayBzdGF0ZW1lbnRcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBlbXB0eSBzdGF0ZW1lbnRcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGtleXdvcmRcbiAgICAgIH1cblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDE0IFByb2dyYW1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcbiAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHBlZWsoKTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgc3RyaWN0ID0gdHJ1ZTsgLy8gYXNzdW1lIHN0cmljdFxuXG4gICAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChlbnRyeS5yZWdleCkge1xuICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogZW50cnkucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICB0b2tlbnM7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmaWVsZHMgYXJlIG5lY2Vzc2FyeSB0byBjb21wdXRlIHRoZSBSZWdleCB0b2tlbnMuXG4gICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IC0xO1xuICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2gobGV4RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIHBhcmVudGhlc2lzQ291bnQ6IDAsXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnNvdXJjZSA9IHRvU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplLFxuICAgIHBhcnNlOiBwYXJzZVxuICB9O1xuXG59KSgpOyIsInZhciB0cyA9IERhdGUubm93KCk7XG5cbmZ1bmN0aW9uIHdyaXRlKG1zZykge1xuICBtc2cgPSAnW1ZlZ2EgTG9nXSAnICsgbXNnO1xuICBjb25zb2xlLmxvZyhtc2cpO1xufVxuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgbXNnID0gJ1tWZWdhIEVycl0gJyArIG1zZztcbiAgY29uc29sZS5lcnJvcihtc2cpO1xufVxuXG5mdW5jdGlvbiBkZWJ1ZyhpbnB1dCwgYXJncykge1xuICBpZiAoIWRlYnVnLmVuYWJsZSkgcmV0dXJuO1xuICB2YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBwcmV2VGltZTogIERhdGUubm93KCkgLSB0cyxcbiAgICBzdGFtcDogaW5wdXQuc3RhbXBcbiAgfTtcblxuICBpZiAoaW5wdXQuYWRkKSB7XG4gICAgc3RhdGUuYWRkID0gaW5wdXQuYWRkLmxlbmd0aDtcbiAgICBzdGF0ZS5tb2QgPSBpbnB1dC5tb2QubGVuZ3RoO1xuICAgIHN0YXRlLnJlbSA9IGlucHV0LnJlbS5sZW5ndGg7XG4gICAgc3RhdGUucmVmbG93ID0gISFpbnB1dC5yZWZsb3c7XG4gIH1cblxuICBsb2cuYXBwbHkoY29uc29sZSwgKGFyZ3MucHVzaChKU09OLnN0cmluZ2lmeShzdGF0ZSkpLCBhcmdzKSk7XG4gIHRzID0gRGF0ZS5ub3coKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogICB3cml0ZSxcbiAgZXJyb3I6IGVycm9yLFxuICBkZWJ1ZzogKGRlYnVnLmVuYWJsZSA9IGZhbHNlLCBkZWJ1Zylcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aDogICAgICAgcmVxdWlyZSgnLi9wYXRoJyksXG4gIHJlbmRlcjogICAgIHJlcXVpcmUoJy4vcmVuZGVyJyksXG4gIEl0ZW06ICAgICAgIHJlcXVpcmUoJy4vdXRpbC9JdGVtJyksXG4gIGJvdW5kOiAgICAgIHJlcXVpcmUoJy4vdXRpbC9ib3VuZCcpLFxuICBCb3VuZHM6ICAgICByZXF1aXJlKCcuL3V0aWwvQm91bmRzJyksXG4gIGNhbnZhczogICAgIHJlcXVpcmUoJy4vdXRpbC9jYW52YXMnKSxcbiAgR3JhZGllbnQ6ICAgcmVxdWlyZSgnLi91dGlsL0dyYWRpZW50JyksXG4gIHRvSlNPTjogICAgIHJlcXVpcmUoJy4vdXRpbC9zY2VuZScpLnRvSlNPTixcbiAgZnJvbUpTT046ICAgcmVxdWlyZSgnLi91dGlsL3NjZW5lJykuZnJvbUpTT05cbn07IiwidmFyIHNlZ21lbnRDYWNoZSA9IHt9LFxuICAgIGJlemllckNhY2hlID0ge30sXG4gICAgam9pbiA9IFtdLmpvaW47XG5cbi8vIENvcGllZCBmcm9tIElua3NjYXBlIHN2Z3RvcGRmLCB0aGFua3MhXG5mdW5jdGlvbiBzZWdtZW50cyh4LCB5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCwgb3gsIG95KSB7XG4gIHZhciBrZXkgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKHNlZ21lbnRDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRoID0gcm90YXRlWCAqIChNYXRoLlBJLzE4MCk7XG4gIHZhciBzaW5fdGggPSBNYXRoLnNpbih0aCk7XG4gIHZhciBjb3NfdGggPSBNYXRoLmNvcyh0aCk7XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgdmFyIHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgdmFyIHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgdmFyIHBsID0gKHB4KnB4KSAvIChyeCpyeCkgKyAocHkqcHkpIC8gKHJ5KnJ5KTtcbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggLyByeDtcbiAgdmFyIGEwMSA9IHNpbl90aCAvIHJ4O1xuICB2YXIgYTEwID0gKC1zaW5fdGgpIC8gcnk7XG4gIHZhciBhMTEgPSAoY29zX3RoKSAvIHJ5O1xuICB2YXIgeDAgPSBhMDAgKiBveCArIGEwMSAqIG95O1xuICB2YXIgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICB2YXIgeDEgPSBhMDAgKiB4ICsgYTAxICogeTtcbiAgdmFyIHkxID0gYTEwICogeCArIGExMSAqIHk7XG5cbiAgdmFyIGQgPSAoeDEteDApICogKHgxLXgwKSArICh5MS15MCkgKiAoeTEteTApO1xuICB2YXIgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSBzZmFjdG9yX3NxID0gMDtcbiAgdmFyIHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PSBsYXJnZSkgc2ZhY3RvciA9IC1zZmFjdG9yO1xuICB2YXIgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxLXkwKTtcbiAgdmFyIHljID0gMC41ICogKHkwICsgeTEpICsgc2ZhY3RvciAqICh4MS14MCk7XG5cbiAgdmFyIHRoMCA9IE1hdGguYXRhbjIoeTAteWMsIHgwLXhjKTtcbiAgdmFyIHRoMSA9IE1hdGguYXRhbjIoeTEteWMsIHgxLXhjKTtcblxuICB2YXIgdGhfYXJjID0gdGgxLXRoMDtcbiAgaWYgKHRoX2FyYyA8IDAgJiYgc3dlZXAgPT09IDEpe1xuICAgIHRoX2FyYyArPSAyICogTWF0aC5QSTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09PSAwKSB7XG4gICAgdGhfYXJjIC09IDIgKiBNYXRoLlBJO1xuICB9XG5cbiAgdmFyIHNlZ3MgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKE1hdGguUEkgKiAwLjUgKyAwLjAwMSkpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpPTA7IGk8c2VnczsgKytpKSB7XG4gICAgdmFyIHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdzO1xuICAgIHZhciB0aDMgPSB0aDAgKyAoaSsxKSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG5cbiAgcmV0dXJuIChzZWdtZW50Q2FjaGVba2V5XSA9IHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGJlemllcihwYXJhbXMpIHtcbiAgdmFyIGtleSA9IGpvaW4uY2FsbChwYXJhbXMpO1xuICBpZiAoYmV6aWVyQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiBiZXppZXJDYWNoZVtrZXldO1xuICB9XG4gIFxuICB2YXIgY3ggPSBwYXJhbXNbMF0sXG4gICAgICBjeSA9IHBhcmFtc1sxXSxcbiAgICAgIHRoMCA9IHBhcmFtc1syXSxcbiAgICAgIHRoMSA9IHBhcmFtc1szXSxcbiAgICAgIHJ4ID0gcGFyYW1zWzRdLFxuICAgICAgcnkgPSBwYXJhbXNbNV0sXG4gICAgICBzaW5fdGggPSBwYXJhbXNbNl0sXG4gICAgICBjb3NfdGggPSBwYXJhbXNbN107XG5cbiAgdmFyIGEwMCA9IGNvc190aCAqIHJ4O1xuICB2YXIgYTAxID0gLXNpbl90aCAqIHJ5O1xuICB2YXIgYTEwID0gc2luX3RoICogcng7XG4gIHZhciBhMTEgPSBjb3NfdGggKiByeTtcblxuICB2YXIgY29zX3RoMCA9IE1hdGguY29zKHRoMCk7XG4gIHZhciBzaW5fdGgwID0gTWF0aC5zaW4odGgwKTtcbiAgdmFyIGNvc190aDEgPSBNYXRoLmNvcyh0aDEpO1xuICB2YXIgc2luX3RoMSA9IE1hdGguc2luKHRoMSk7XG5cbiAgdmFyIHRoX2hhbGYgPSAwLjUgKiAodGgxIC0gdGgwKTtcbiAgdmFyIHNpbl90aF9oMiA9IE1hdGguc2luKHRoX2hhbGYgKiAwLjUpO1xuICB2YXIgdCA9ICg4LzMpICogc2luX3RoX2gyICogc2luX3RoX2gyIC8gTWF0aC5zaW4odGhfaGFsZik7XG4gIHZhciB4MSA9IGN4ICsgY29zX3RoMCAtIHQgKiBzaW5fdGgwO1xuICB2YXIgeTEgPSBjeSArIHNpbl90aDAgKyB0ICogY29zX3RoMDtcbiAgdmFyIHgzID0gY3ggKyBjb3NfdGgxO1xuICB2YXIgeTMgPSBjeSArIHNpbl90aDE7XG4gIHZhciB4MiA9IHgzICsgdCAqIHNpbl90aDE7XG4gIHZhciB5MiA9IHkzIC0gdCAqIGNvc190aDE7XG5cbiAgcmV0dXJuIChiZXppZXJDYWNoZVtrZXldID0gW1xuICAgIGEwMCAqIHgxICsgYTAxICogeTEsICBhMTAgKiB4MSArIGExMSAqIHkxLFxuICAgIGEwMCAqIHgyICsgYTAxICogeTIsICBhMTAgKiB4MiArIGExMSAqIHkyLFxuICAgIGEwMCAqIHgzICsgYTAxICogeTMsICBhMTAgKiB4MyArIGExMSAqIHkzXG4gIF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICBiZXppZXI6IGJlemllcixcbiAgY2FjaGU6IHtcbiAgICBzZWdtZW50czogc2VnbWVudENhY2hlLFxuICAgIGJlemllcjogYmV6aWVyQ2FjaGVcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogIHJlcXVpcmUoJy4vcGFyc2UnKSxcbiAgcmVuZGVyOiByZXF1aXJlKCcuL3JlbmRlcicpXG59O1xuIiwiLy8gUGF0aCBwYXJzaW5nIGFuZCByZW5kZXJpbmcgY29kZSBhZGFwdGVkIGZyb20gZmFicmljLmpzIC0tIFRoYW5rcyFcbnZhciBjbWRsZW4gPSB7IG06MiwgbDoyLCBoOjEsIHY6MSwgYzo2LCBzOjQsIHE6NCwgdDoyLCBhOjcgfSxcbiAgICByZWdleHAgPSBbLyhbTUxIVkNTUVRBWm1saHZjc3F0YXpdKS9nLCAvIyMjLywgLyhcXGQpKFstK10pL2csIC9cXHN8LHwjIyMvXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXRoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBhdGgsXG4gICAgICBjdXJyLFxuICAgICAgY2h1bmtzLFxuICAgICAgcGFyc2VkLCBwYXJhbSxcbiAgICAgIGNtZCwgbGVuLCBpLCBqLCBuLCBtO1xuXG4gIC8vIEZpcnN0LCBicmVhayBwYXRoIGludG8gY29tbWFuZCBzZXF1ZW5jZVxuICBwYXRoID0gcGF0aHN0clxuICAgIC5zbGljZSgpXG4gICAgLnJlcGxhY2UocmVnZXhwWzBdLCAnIyMjJDEnKVxuICAgIC5zcGxpdChyZWdleHBbMV0pXG4gICAgLnNsaWNlKDEpO1xuXG4gIC8vIE5leHQsIHBhcnNlIGVhY2ggY29tbWFuZCBpbiB0dXJuXG4gIGZvciAoaT0wLCBuPXBhdGgubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGN1cnIgPSBwYXRoW2ldO1xuICAgIGNodW5rcyA9IGN1cnJcbiAgICAgIC5zbGljZSgxKVxuICAgICAgLnRyaW0oKVxuICAgICAgLnJlcGxhY2UocmVnZXhwWzJdLCckMSMjIyQyJylcbiAgICAgIC5zcGxpdChyZWdleHBbM10pO1xuICAgIGNtZCA9IGN1cnIuY2hhckF0KDApO1xuXG4gICAgcGFyc2VkID0gW2NtZF07XG4gICAgZm9yIChqPTAsIG09Y2h1bmtzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmICgocGFyYW0gPSArY2h1bmtzW2pdKSA9PT0gcGFyYW0pIHsgLy8gbm90IE5hTlxuICAgICAgICBwYXJzZWQucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gY21kbGVuW2NtZC50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aC0xID4gbGVuKSB7XG4gICAgICBmb3IgKGo9MSwgbT1wYXJzZWQubGVuZ3RoOyBqPG07IGorPWxlbikge1xuICAgICAgICByZXN1bHQucHVzaChbY21kXS5jb25jYXQocGFyc2VkLnNsaWNlKGosIGorbGVuKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihnLCBwYXRoLCBsLCB0KSB7XG4gIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZO1xuXG4gIGlmIChsID09IG51bGwpIGwgPSAwO1xuICBpZiAodCA9PSBudWxsKSB0ID0gMDtcblxuICBnLmJlZ2luUGF0aCgpO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsIC8vIHgxXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgIGNvbnRyb2xYICsgbCwgLy8geDJcbiAgICAgICAgICBjb250cm9sWSArIHQsIC8vIHkyXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICB5ICsgdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZVxuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBwb2ludC5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMip4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMip5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIHggKyBsLFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB5ICsgdFxuICAgICAgICBdKTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHRcbiAgICAgICAgXSk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRyYXdBcmMoZywgeCwgeSwgY29vcmRzKSB7XG4gIHZhciBzZWcgPSBhcmMuc2VnbWVudHMoXG4gICAgY29vcmRzWzVdLCAvLyBlbmQgeFxuICAgIGNvb3Jkc1s2XSwgLy8gZW5kIHlcbiAgICBjb29yZHNbMF0sIC8vIHJhZGl1cyB4XG4gICAgY29vcmRzWzFdLCAvLyByYWRpdXMgeVxuICAgIGNvb3Jkc1szXSwgLy8gbGFyZ2UgZmxhZ1xuICAgIGNvb3Jkc1s0XSwgLy8gc3dlZXAgZmxhZ1xuICAgIGNvb3Jkc1syXSwgLy8gcm90YXRpb25cbiAgICB4LCB5XG4gICk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWcubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYmV6ID0gYXJjLmJlemllcihzZWdbaV0pO1xuICAgIGcuYmV6aWVyQ3VydmVUby5hcHBseShnLCBiZXopO1xuICB9XG59XG4iLCJmdW5jdGlvbiBIYW5kbGVyKCkge1xuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xufVxuXG52YXIgcHJvdG90eXBlID0gSGFuZGxlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIHRoaXMuX2VsID0gZWw7XG4gIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICByZXR1cm4gdGhpcy5wYWRkaW5nKHBhZCk7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkIHx8IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnNjZW5lID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2NlbmU7XG4gIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbi8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbigvKnR5cGUsIGhhbmRsZXIqLykge307XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4vLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKC8qdHlwZSwgaGFuZGxlciovKSB7fTtcblxuLy8gcmV0dXJuIGFuIGFycmF5IHdpdGggYWxsIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnNcbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzLCBhID0gW10sIGs7XG4gIGZvciAoayBpbiBoKSB7IGEucHVzaC5hcHBseShhLCBoW2tdKTsgfVxuICByZXR1cm4gYTtcbn07XG5cbnByb3RvdHlwZS5ldmVudE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpID0gbmFtZS5pbmRleE9mKCcuJyk7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZXI7IiwiZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5fYmdjb2xvciA9IG51bGw7XG59XG5cbnZhciBwcm90b3R5cGUgPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xufTtcblxuLy8gUmV0dXJucyB0aGUgcGFyZW50IGNvbnRhaW5lciBlbGVtZW50IGZvciBhIHZpc3VhbGl6YXRpb25cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNjZW5lIGVsZW1lbnQgKGUuZy4sIGNhbnZhcyBvciBTVkcpIG9mIHRoZSB2aXN1YWxpemF0aW9uXG4vLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgaWYgdGhlIGZpcnN0IGNoaWxkIGlzIG5vdCB0aGUgc2NlbmUgZWxlbWVudFxucHJvdG90eXBlLnNjZW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbCAmJiB0aGlzLl9lbC5maXJzdENoaWxkO1xufTtcblxucHJvdG90eXBlLmJhY2tncm91bmQgPSBmdW5jdGlvbihiZ2NvbG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYmdjb2xvcjtcbiAgdGhpcy5fYmdjb2xvciA9IGJnY29sb3I7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZyB8fCB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigvKnNjZW5lLCBpdGVtcyovKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjsiLCJ2YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBIYW5kbGVyID0gcmVxdWlyZSgnLi4vSGFuZGxlcicpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBDYW52YXNIYW5kbGVyKCkge1xuICBIYW5kbGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX2Rvd24gPSBudWxsO1xuICB0aGlzLl90b3VjaCA9IG51bGw7XG4gIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbn1cblxudmFyIGJhc2UgPSBIYW5kbGVyLnByb3RvdHlwZTtcbnZhciBwcm90b3R5cGUgPSAoQ2FudmFzSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0hhbmRsZXI7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyA9IERPTS5maW5kKGVsLCAnY2FudmFzJyk7XG4gIGlmIChjYW52YXMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHByb3RvdHlwZVt0eXBlXSkge1xuICAgICAgICAgIHByb3RvdHlwZVt0eXBlXS5jYWxsKHRoYXQsIGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5maXJlKHR5cGUsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2UuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCBwYWQsIG9iaik7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG4vLyByZXRyaWV2ZSB0aGUgY3VycmVudCBjYW52YXMgY29udGV4dFxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xufTtcblxuLy8gc3VwcG9ydGVkIGV2ZW50c1xucHJvdG90eXBlLmV2ZW50cyA9IFtcbiAgJ2tleWRvd24nLFxuICAna2V5cHJlc3MnLFxuICAna2V5dXAnLFxuICAnbW91c2Vkb3duJyxcbiAgJ21vdXNldXAnLFxuICAnbW91c2Vtb3ZlJyxcbiAgJ21vdXNlb3V0JyxcbiAgJ21vdXNlb3ZlcicsXG4gICdjbGljaycsXG4gICdkYmxjbGljaycsXG4gICd3aGVlbCcsXG4gICdtb3VzZXdoZWVsJyxcbiAgJ3RvdWNoc3RhcnQnLFxuICAndG91Y2htb3ZlJyxcbiAgJ3RvdWNoZW5kJ1xuXTtcblxuLy8gdG8ga2VlcCBmaXJlZm94IGhhcHB5XG5wcm90b3R5cGUuRE9NTW91c2VTY3JvbGwgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKCdtb3VzZXdoZWVsJywgZXZ0KTtcbn07XG5cbnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgdmFyIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrRXZlbnQoZXZ0KTtcblxuICBpZiAocCA9PT0gYSkge1xuICAgIC8vIGFjdGl2ZSBpdGVtIGFuZCBwaWNrZWQgaXRlbSBhcmUgdGhlIHNhbWVcbiAgICB0aGlzLmZpcmUoJ21vdXNlbW92ZScsIGV2dCk7IC8vIGZpcmUgbW92ZVxuICB9IGVsc2Uge1xuICAgIC8vIGFjdGl2ZSBpdGVtIGFuZCBwaWNrZWQgaXRlbSBhcmUgZGlmZmVyZW50XG4gICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIGV2dCk7ICAvLyBmaXJlIG91dCBmb3IgcHJpb3IgYWN0aXZlIGl0ZW1cbiAgICB0aGlzLl9hY3RpdmUgPSBwOyAgICAgICAgICAgIC8vIHNldCBuZXcgYWN0aXZlIGl0ZW1cbiAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIGV2dCk7IC8vIGZpcmUgb3ZlciBmb3IgbmV3IGFjdGl2ZSBpdGVtXG4gICAgdGhpcy5maXJlKCdtb3VzZW1vdmUnLCBldnQpOyAvLyBmaXJlIG1vdmUgZm9yIG5ldyBhY3RpdmUgaXRlbVxuICB9XG59O1xuXG5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKCdtb3VzZW91dCcsIGV2dCk7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG59O1xuXG5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuX2Rvd24gPSB0aGlzLl9hY3RpdmU7XG4gIHRoaXMuZmlyZSgnbW91c2Vkb3duJywgZXZ0KTtcbn07XG5cbnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICBpZiAodGhpcy5fZG93biA9PT0gdGhpcy5fYWN0aXZlKSB7XG4gICAgdGhpcy5maXJlKCdjbGljaycsIGV2dCk7XG4gICAgdGhpcy5fZG93biA9IG51bGw7XG4gIH1cbn07XG5cbnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuX3RvdWNoID0gdGhpcy5waWNrRXZlbnQoZXZ0LmNoYW5nZWRUb3VjaGVzWzBdKTtcblxuICBpZiAodGhpcy5fZmlyc3QpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl90b3VjaDtcbiAgICB0aGlzLl9maXJzdCA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5maXJlKCd0b3VjaHN0YXJ0JywgZXZ0LCB0cnVlKTtcbn07XG5cbnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKCd0b3VjaG1vdmUnLCBldnQsIHRydWUpO1xufTtcblxucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZSgndG91Y2hlbmQnLCBldnQsIHRydWUpO1xuICB0aGlzLl90b3VjaCA9IG51bGw7XG59O1xuXG4vLyBmaXJlIGFuIGV2ZW50XG5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKHR5cGUsIGV2dCwgdG91Y2gpIHtcbiAgdmFyIGEgPSB0b3VjaCA/IHRoaXMuX3RvdWNoIDogdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdLCBpLCBsZW47XG4gIGlmIChoKSB7XG4gICAgZXZ0LnZlZ2FUeXBlID0gdHlwZTtcbiAgICBmb3IgKGk9MCwgbGVuPWgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICAoaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLCBpO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yIChpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYgKGhbaV0udHlwZSAhPT0gdHlwZSkgY29udGludWU7XG4gICAgaWYgKCFoYW5kbGVyIHx8IGhbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikgaC5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGlja0V2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHZhciByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZywgeCwgeTtcbiAgcmV0dXJuIHRoaXMucGljayh0aGlzLl9zY2VuZSxcbiAgICB4ID0gKGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0KSxcbiAgICB5ID0gKGV2dC5jbGllbnRZIC0gcmVjdC50b3ApLFxuICAgIHggLSBwYWQubGVmdCwgeSAtIHBhZC50b3ApO1xufTtcblxuLy8gZmluZCB0aGUgc2NlbmVncmFwaCBpdGVtIGF0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4vLyB4LCB5IC0tIHRoZSBhYnNvbHV0ZSB4LCB5IG1vdXNlIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMgZWxlbWVudFxuLy8gZ3gsIGd5IC0tIHRoZSByZWxhdGl2ZSBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24oc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgbWFyayA9IG1hcmtzW3NjZW5lLm1hcmt0eXBlXTtcbiAgcmV0dXJuIG1hcmsucGljay5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNIYW5kbGVyO1xuIiwidmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Cb3VuZHMnKSxcbiAgICBJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvSW1hZ2VMb2FkZXInKSxcbiAgICBDYW52YXMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NhbnZhcycpLFxuICAgIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIobG9hZENvbmZpZykge1xuICBSZW5kZXJlci5jYWxsKHRoaXMpO1xuICB0aGlzLl9sb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobG9hZENvbmZpZyk7XG59XG5cbkNhbnZhc1JlbmRlcmVyLlJFVElOQSA9IHRydWU7XG5cbnZhciBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChDYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1JlbmRlcmVyO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHRoaXMuX2NhbnZhcyA9IENhbnZhcy5pbnN0YW5jZSh3aWR0aCwgaGVpZ2h0KTtcbiAgaWYgKGVsKSB7XG4gICAgRE9NLmNsZWFyKGVsLCAwKS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21hcmtzJyk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGJhc2UucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gIENhbnZhcy5yZXNpemUodGhpcy5fY2FudmFzLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LFxuICAgIHRoaXMuX3BhZGRpbmcsIENhbnZhc1JlbmRlcmVyLlJFVElOQSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmNhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzO1xufTtcblxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcyA/IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcbn07XG5cbnByb3RvdHlwZS5wZW5kaW5nSW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIucGVuZGluZygpO1xufTtcblxuZnVuY3Rpb24gY2xpcFRvQm91bmRzKGcsIGl0ZW1zKSB7XG4gIGlmICghaXRlbXMpIHJldHVybiBudWxsO1xuXG4gIHZhciBiID0gbmV3IEJvdW5kcygpLCBpLCBuLCBpdGVtLCBtYXJrLCBncm91cDtcbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBtYXJrID0gaXRlbS5tYXJrO1xuICAgIGdyb3VwID0gbWFyay5ncm91cDtcbiAgICBpdGVtID0gbWFya3NbbWFyay5tYXJrdHlwZV0ubmVzdGVkID8gbWFyayA6IGl0ZW07XG4gICAgYi51bmlvbih0cmFuc2xhdGUoaXRlbS5ib3VuZHMsIGdyb3VwKSk7XG4gICAgaWYgKGl0ZW1bJ2JvdW5kczpwcmV2J10pIHtcbiAgICAgIGIudW5pb24odHJhbnNsYXRlKGl0ZW1bJ2JvdW5kczpwcmV2J10sIGdyb3VwKSk7XG4gICAgfVxuICB9XG4gIGIucm91bmQoKTtcblxuICBnLmJlZ2luUGF0aCgpO1xuICBnLnJlY3QoYi54MSwgYi55MSwgYi53aWR0aCgpLCBiLmhlaWdodCgpKTtcbiAgZy5jbGlwKCk7XG5cbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShib3VuZHMsIGdyb3VwKSB7XG4gIGlmIChncm91cCA9PSBudWxsKSByZXR1cm4gYm91bmRzO1xuICB2YXIgYiA9IGJvdW5kcy5jbG9uZSgpO1xuICBmb3IgKDsgZ3JvdXAgIT0gbnVsbDsgZ3JvdXAgPSBncm91cC5tYXJrLmdyb3VwKSB7XG4gICAgYi50cmFuc2xhdGUoZ3JvdXAueCB8fCAwLCBncm91cC55IHx8IDApO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIHZhciBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICBwID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHcgPSB0aGlzLl93aWR0aCArIHAubGVmdCArIHAucmlnaHQsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0ICsgcC50b3AgKyBwLmJvdHRvbSxcbiAgICAgIGI7XG5cbiAgLy8gc2V0dXBcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTsgLy8gY2FjaGUgc2NlbmUgZm9yIGFzeW5jIHJlZHJhd1xuICBnLnNhdmUoKTtcbiAgYiA9IGNsaXBUb0JvdW5kcyhnLCBpdGVtcyk7XG4gIHRoaXMuY2xlYXIoLXAubGVmdCwgLXAudG9wLCB3LCBoKTtcblxuICAvLyByZW5kZXJcbiAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiKTtcbiAgXG4gIC8vIHRha2Vkb3duXG4gIGcucmVzdG9yZSgpO1xuICB0aGlzLl9zY2VuZSA9IG51bGw7IC8vIGNsZWFyIHNjZW5lIGNhY2hlXG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgc2NlbmUsIGJvdW5kcykge1xuICB2YXIgbWFyayA9IG1hcmtzW3NjZW5lLm1hcmt0eXBlXTtcbiAgbWFyay5kcmF3LmNhbGwodGhpcywgY3R4LCBzY2VuZSwgYm91bmRzKTtcbn07XG5cbnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKTtcbiAgZy5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gIGlmICh0aGlzLl9iZ2NvbG9yICE9IG51bGwpIHtcbiAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2JnY29sb3I7XG4gICAgZy5maWxsUmVjdCh4LCB5LCB3LCBoKTsgXG4gIH1cbn07XG5cbnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZEltYWdlKHVyaSwgZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyQXN5bmMoc2NlbmUpO1xuICB9KTtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJBc3luYyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIC8vIFRPRE8gbWFrZSBzYWZlIGZvciBtdWx0aXBsZSBzY2VuZSByZW5kZXJpbmc/XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG4gIGlmIChyZW5kZXJlci5fYXN5bmNfaWQpIHtcbiAgICBjbGVhclRpbWVvdXQocmVuZGVyZXIuX2FzeW5jX2lkKTtcbiAgfVxuICByZW5kZXJlci5fYXN5bmNfaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSk7XG4gICAgZGVsZXRlIHJlbmRlcmVyLl9hc3luY19pZDtcbiAgfSwgMTApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9DYW52YXNIYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL0NhbnZhc1JlbmRlcmVyJylcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYWxmcGkgPSBNYXRoLlBJIC8gMjtcblxuZnVuY3Rpb24gcGF0aChnLCBvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBpciA9IG8uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gby5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgc2EgPSAoby5zdGFydEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgZWEgPSAoby5lbmRBbmdsZSB8fCAwKSAtIGhhbGZwaTtcbiAgZy5iZWdpblBhdGgoKTtcbiAgaWYgKGlyID09PSAwKSBnLm1vdmVUbyh4LCB5KTtcbiAgZWxzZSBnLmFyYyh4LCB5LCBpciwgc2EsIGVhLCAwKTtcbiAgZy5hcmMoeCwgeSwgb3IsIGVhLCBzYSwgMSk7XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdBbGwocGF0aCksXG4gIHBpY2s6IHV0aWwucGlja1BhdGgocGF0aClcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBwYXJzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhdGgvcGFyc2UnKSxcbiAgICByZW5kZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9wYXRoL3JlbmRlcicpLFxuICAgIGFyZWFQYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9zdmcnKS5wYXRoLmFyZWE7XG5cbmZ1bmN0aW9uIHBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShhcmVhUGF0aChpdGVtcykpKTtcbiAgcmVuZGVyKGcsIHApO1xufVxuXG5mdW5jdGlvbiBwaWNrKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBiID0gc2NlbmUuYm91bmRzO1xuXG4gIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCB8fCBiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChnLnBpeGVscmF0aW8gIT0gbnVsbCAmJiBnLnBpeGVscmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcucGl4ZWxyYXRpbztcbiAgICB5ICo9IGcucGl4ZWxyYXRpbztcbiAgfVxuICByZXR1cm4gaGl0KGcsIGl0ZW1zLCB4LCB5KSA/IGl0ZW1zWzBdIDogbnVsbDtcbn1cblxudmFyIGhpdCA9IHV0aWwudGVzdFBhdGgocGF0aCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdPbmUocGF0aCksXG4gIHBpY2s6IHBpY2ssXG4gIG5lc3RlZDogdHJ1ZVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgRU1QVFkgPSBbXTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBncm91cHMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIGdyb3VwLCBpdGVtcywgYXhlcywgbGVnZW5kcywgZ3gsIGd5LCB3LCBoLCBvcGFjLCBpLCBuLCBqLCBtO1xuXG4gIGZvciAoaT0wLCBuPWdyb3Vwcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgYXhlcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBFTVBUWTtcbiAgICBpdGVtcyA9IGdyb3VwLml0ZW1zIHx8IEVNUFRZO1xuICAgIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRJdGVtcyB8fCBFTVBUWTtcbiAgICBneCA9IGdyb3VwLnggfHwgMDtcbiAgICBneSA9IGdyb3VwLnkgfHwgMDtcbiAgICB3ID0gZ3JvdXAud2lkdGggfHwgMDtcbiAgICBoID0gZ3JvdXAuaGVpZ2h0IHx8IDA7XG5cbiAgICAvLyBkcmF3IGdyb3VwIGJhY2tncm91bmRcbiAgICBpZiAoZ3JvdXAuc3Ryb2tlIHx8IGdyb3VwLmZpbGwpIHtcbiAgICAgIG9wYWMgPSBncm91cC5vcGFjaXR5ID09IG51bGwgPyAxIDogZ3JvdXAub3BhY2l0eTtcbiAgICAgIGlmIChvcGFjID4gMCkge1xuICAgICAgICBpZiAoZ3JvdXAuZmlsbCAmJiB1dGlsLmZpbGwoZywgZ3JvdXAsIG9wYWMpKSB7XG4gICAgICAgICAgZy5maWxsUmVjdChneCwgZ3ksIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cC5zdHJva2UgJiYgdXRpbC5zdHJva2UoZywgZ3JvdXAsIG9wYWMpKSB7XG4gICAgICAgICAgZy5zdHJva2VSZWN0KGd4LCBneSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXR1cCBncmFwaGljcyBjb250ZXh0XG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBpZiAoZ3JvdXAuY2xpcCkge1xuICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgIGcucmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIGcuY2xpcCgpO1xuICAgIH1cbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKC1neCwgLWd5KTtcblxuICAgIC8vIGRyYXcgZ3JvdXAgY29udGVudHNcbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmxheWVyID09PSAnYmFjaycpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICByZW5kZXJlci5kcmF3KGcsIGl0ZW1zW2pdLCBib3VuZHMpO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgbGVnZW5kc1tqXSwgYm91bmRzKTtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGdyYXBoaWNzIGNvbnRleHRcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZy5yZXN0b3JlKCk7XG4gIH0gICAgXG59XG5cbmZ1bmN0aW9uIHBpY2soZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoc2NlbmUuYm91bmRzICYmICFzY2VuZS5ib3VuZHMuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGdyb3VwcyA9IHNjZW5lLml0ZW1zIHx8IEVNUFRZLCBzdWJzY2VuZSxcbiAgICAgIGdyb3VwLCBheGVzLCBpdGVtcywgbGVnZW5kcywgaGl0cywgZHgsIGR5LCBpLCBqLCBiO1xuXG4gIGZvciAoaT1ncm91cHMubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgZ3JvdXAgPSBncm91cHNbaV07XG5cbiAgICAvLyBmaXJzdCBoaXQgdGVzdCBhZ2FpbnN0IGJvdW5kaW5nIGJveFxuICAgIC8vIGlmIGEgZ3JvdXAgaXMgY2xpcHBlZCwgdGhhdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgYm91bmRzIGNoZWNrLlxuICAgIGIgPSBncm91cC5ib3VuZHM7XG4gICAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgY29udGludWU7XG5cbiAgICAvLyBwYXNzZWQgYm91bmRzIGNoZWNrLCBzbyB0ZXN0IHN1Yi1ncm91cHNcbiAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IEVNUFRZO1xuICAgIGl0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgRU1QVFk7XG4gICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IEVNUFRZO1xuICAgIGR4ID0gKGdyb3VwLnggfHwgMCk7XG4gICAgZHkgPSAoZ3JvdXAueSB8fCAwKTtcblxuICAgIGcuc2F2ZSgpO1xuICAgIGcudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgZHggPSBneCAtIGR4O1xuICAgIGR5ID0gZ3kgLSBkeTtcbiAgICBmb3IgKGo9bGVnZW5kcy5sZW5ndGg7IC0taj49MDspIHtcbiAgICAgIHN1YnNjZW5lID0gbGVnZW5kc1tqXTtcbiAgICAgIGlmIChzdWJzY2VuZS5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgaGl0cyA9IHRoaXMucGljayhzdWJzY2VuZSwgeCwgeSwgZHgsIGR5KTtcbiAgICAgICAgaWYgKGhpdHMpIHsgZy5yZXN0b3JlKCk7IHJldHVybiBoaXRzOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj1heGVzLmxlbmd0aDsgLS1qPj0wOykge1xuICAgICAgc3Vic2NlbmUgPSBheGVzW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZSAmJiBzdWJzY2VuZS5sYXllciAhPT0gJ2JhY2snKSB7XG4gICAgICAgIGhpdHMgPSB0aGlzLnBpY2soc3Vic2NlbmUsIHgsIHksIGR4LCBkeSk7XG4gICAgICAgIGlmIChoaXRzKSB7IGcucmVzdG9yZSgpOyByZXR1cm4gaGl0czsgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9aXRlbXMubGVuZ3RoOyAtLWo+PTA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGl0ZW1zW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICBoaXRzID0gdGhpcy5waWNrKHN1YnNjZW5lLCB4LCB5LCBkeCwgZHkpO1xuICAgICAgICBpZiAoaGl0cykgeyBnLnJlc3RvcmUoKTsgcmV0dXJuIGhpdHM7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPWF4ZXMubGVuZ3RoOyAtLWo+PTA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGF4ZXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhdGl2ZSAhPT0gZmFsc2UgJiYgc3Vic2NlbmUubGF5ZXIgPT09ICdiYWNrJykge1xuICAgICAgICBoaXRzID0gdGhpcy5waWNrKHN1YnNjZW5lLCB4LCB5LCBkeCwgZHkpO1xuICAgICAgICBpZiAoaGl0cykgeyBnLnJlc3RvcmUoKTsgcmV0dXJuIGhpdHM7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZy5yZXN0b3JlKCk7XG5cbiAgICBpZiAoc2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlICYmIChncm91cC5maWxsIHx8IGdyb3VwLnN0cm9rZSkgJiZcbiAgICAgICAgZHggPj0gMCAmJiBkeCA8PSBncm91cC53aWR0aCAmJiBkeSA+PSAwICYmIGR5IDw9IGdyb3VwLmhlaWdodCkge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhdyxcbiAgcGljazogcGlja1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIGRyYXcoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zIHx8ICFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcywgbztcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgaWYgKCEoby5pbWFnZSAmJiBvLmltYWdlLnVybCA9PT0gby51cmwpKSB7XG4gICAgICBvLmltYWdlID0gcmVuZGVyZXIubG9hZEltYWdlKG8udXJsKTtcbiAgICAgIG8uaW1hZ2UudXJsID0gby51cmw7XG4gICAgfVxuXG4gICAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgICB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwLFxuICAgICAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDAsXG4gICAgICAgIG9wYWM7XG4gICAgeCA9IHggLSAoby5hbGlnbj09PSdjZW50ZXInID8gdy8yIDogby5hbGlnbj09PSdyaWdodCcgPyB3IDogMCk7XG4gICAgeSA9IHkgLSAoby5iYXNlbGluZT09PSdtaWRkbGUnID8gaC8yIDogby5iYXNlbGluZT09PSdib3R0b20nID8gaCA6IDApO1xuXG4gICAgaWYgKG8uaW1hZ2UubG9hZGVkKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gKG9wYWMgPSBvLm9wYWNpdHkpICE9IG51bGwgPyBvcGFjIDogMTtcbiAgICAgIGcuZHJhd0ltYWdlKG8uaW1hZ2UsIHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhdyxcbiAgcGljazogdXRpbC5waWNrKClcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFyYzogICAgcmVxdWlyZSgnLi9hcmMnKSxcbiAgYXJlYTogICByZXF1aXJlKCcuL2FyZWEnKSxcbiAgZ3JvdXA6ICByZXF1aXJlKCcuL2dyb3VwJyksXG4gIGltYWdlOiAgcmVxdWlyZSgnLi9pbWFnZScpLFxuICBsaW5lOiAgIHJlcXVpcmUoJy4vbGluZScpLFxuICBwYXRoOiAgIHJlcXVpcmUoJy4vcGF0aCcpLFxuICByZWN0OiAgIHJlcXVpcmUoJy4vcmVjdCcpLFxuICBydWxlOiAgIHJlcXVpcmUoJy4vcnVsZScpLFxuICBzeW1ib2w6IHJlcXVpcmUoJy4vc3ltYm9sJyksXG4gIHRleHQ6ICAgcmVxdWlyZSgnLi90ZXh0Jylcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHBhcnNlID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9wYXJzZScpLFxuICAgIHJlbmRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhdGgvcmVuZGVyJyksXG4gICAgbGluZVBhdGggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3N2ZycpLnBhdGgubGluZTtcbiAgICBcbmZ1bmN0aW9uIHBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShsaW5lUGF0aChpdGVtcykpKTtcbiAgcmVuZGVyKGcsIHApO1xufVxuXG5mdW5jdGlvbiBwaWNrKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBiID0gc2NlbmUuYm91bmRzO1xuXG4gIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCB8fCBiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChnLnBpeGVscmF0aW8gIT0gbnVsbCAmJiBnLnBpeGVscmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcucGl4ZWxyYXRpbztcbiAgICB5ICo9IGcucGl4ZWxyYXRpbztcbiAgfVxuICByZXR1cm4gaGl0KGcsIGl0ZW1zLCB4LCB5KSA/IGl0ZW1zWzBdIDogbnVsbDtcbn1cblxudmFyIGhpdCA9IHV0aWwudGVzdFBhdGgocGF0aCwgZmFsc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogdXRpbC5kcmF3T25lKHBhdGgpLFxuICBwaWNrOiBwaWNrLFxuICBuZXN0ZWQ6IHRydWVcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHBhcnNlID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9wYXJzZScpLFxuICAgIHJlbmRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhdGgvcmVuZGVyJyk7XG5cbmZ1bmN0aW9uIHBhdGgoZywgbykge1xuICBpZiAoby5wYXRoID09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKG8ucGF0aCkpO1xuICByZW5kZXIoZywgcCwgby54LCBvLnkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogdXRpbC5kcmF3QWxsKHBhdGgpLFxuICBwaWNrOiB1dGlsLnBpY2tQYXRoKHBhdGgpXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgb3BhYywgeCwgeSwgdywgaDtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PT0gMCkgY29udGludWU7XG5cbiAgICB4ID0gby54IHx8IDA7XG4gICAgeSA9IG8ueSB8fCAwO1xuICAgIHcgPSBvLndpZHRoIHx8IDA7XG4gICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG5cbiAgICBpZiAoby5maWxsICYmIHV0aWwuZmlsbChnLCBvLCBvcGFjKSkge1xuICAgICAgZy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gICAgaWYgKG8uc3Ryb2tlICYmIHV0aWwuc3Ryb2tlKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLnN0cm9rZVJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiB1dGlsLnBpY2soKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBkcmF3KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcyB8fCAhc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBvcGFjLCB4MSwgeTEsIHgyLCB5MjtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PT0gMCkgY29udGludWU7XG4gICAgICBcbiAgICB4MSA9IG8ueCB8fCAwO1xuICAgIHkxID0gby55IHx8IDA7XG4gICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDE7XG4gICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTE7XG5cbiAgICBpZiAoby5zdHJva2UgJiYgdXRpbC5zdHJva2UoZywgbywgb3BhYykpIHtcbiAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICBnLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgZy5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cm9rZShnLCBvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMCxcbiAgICAgIHgyID0gby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTEsXG4gICAgICBsdyA9IG8uc3Ryb2tlV2lkdGgsXG4gICAgICBsYyA9IG8uc3Ryb2tlQ2FwO1xuXG4gIGcubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogMTtcbiAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiAnYnV0dCc7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcubW92ZVRvKHgxLCB5MSk7XG4gIGcubGluZVRvKHgyLCB5Mik7XG59XG5cbmZ1bmN0aW9uIGhpdChnLCBvLCB4LCB5KSB7XG4gIGlmICghZy5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgc3Ryb2tlKGcsIG8pO1xuICByZXR1cm4gZy5pc1BvaW50SW5TdHJva2UoeCwgeSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiB1dGlsLnBpY2soaGl0KVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCk7XG5cbmZ1bmN0aW9uIHBhdGgoZywgbykge1xuICB2YXIgc2l6ZSA9IG8uc2l6ZSAhPSBudWxsID8gby5zaXplIDogMTAwLFxuICAgICAgeCA9IG8ueCwgeSA9IG8ueSwgciwgdCwgcngsIHJ5O1xuXG4gIGcuYmVnaW5QYXRoKCk7XG5cbiAgaWYgKG8uc2hhcGUgPT0gbnVsbCB8fCBvLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIE1hdGguUEkpO1xuICAgIGcuYXJjKHgsIHksIHIsIDAsIDIqTWF0aC5QSSwgMCk7XG4gICAgZy5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICB0ID0gMypyO1xuICAgICAgZy5tb3ZlVG8oeC10LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeC10LCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIHRhbjMwKSk7XG4gICAgICByeCA9IHJ5ICogdGFuMzA7XG4gICAgICBnLm1vdmVUbyh4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHkpO1xuICAgICAgZy5saW5lVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBnLnJlY3QoeC1yLCB5LXIsIHQsIHQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0cmlhbmdsZS1kb3duJzpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHktcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0cmlhbmdsZS11cCc6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5K3J5KTtcbiAgfVxuICBnLmNsb3NlUGF0aCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogdXRpbC5kcmF3QWxsKHBhdGgpLFxuICBwaWNrOiB1dGlsLnBpY2tQYXRoKHBhdGgpXG59OyIsInZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL0JvdW5kcycpLFxuICAgIHRleHRCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2JvdW5kJykudGV4dCxcbiAgICB0ZXh0ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC90ZXh0JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cbmZ1bmN0aW9uIGRyYXcoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zIHx8ICFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIG9wYWMsIHgsIHksIHIsIHQsIHN0cjtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgc3RyID0gdGV4dC52YWx1ZShvLnRleHQpO1xuICAgIGlmICghc3RyKSBjb250aW51ZTtcbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09PSAwKSBjb250aW51ZTtcblxuICAgIGcuZm9udCA9IHRleHQuZm9udChvKTtcbiAgICBnLnRleHRBbGlnbiA9IG8uYWxpZ24gfHwgJ2xlZnQnO1xuXG4gICAgeCA9IChvLnggfHwgMCk7XG4gICAgeSA9IChvLnkgfHwgMCk7XG4gICAgaWYgKChyID0gby5yYWRpdXMpKSB7XG4gICAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICAgIH1cblxuICAgIGlmIChvLmFuZ2xlKSB7XG4gICAgICBnLnNhdmUoKTtcbiAgICAgIGcudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgZy5yb3RhdGUoby5hbmdsZSAqIE1hdGguUEkvMTgwKTtcbiAgICAgIHggPSB5ID0gMDsgLy8gcmVzZXQgeCwgeVxuICAgIH1cbiAgICB4ICs9IChvLmR4IHx8IDApO1xuICAgIHkgKz0gKG8uZHkgfHwgMCkgKyB0ZXh0Lm9mZnNldChvKTtcblxuICAgIGlmIChvLmZpbGwgJiYgdXRpbC5maWxsKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLmZpbGxUZXh0KHN0ciwgeCwgeSk7XG4gICAgfVxuICAgIGlmIChvLnN0cm9rZSAmJiB1dGlsLnN0cm9rZShnLCBvLCBvcGFjKSkge1xuICAgICAgZy5zdHJva2VUZXh0KHN0ciwgeCwgeSk7XG4gICAgfVxuICAgIGlmIChvLmFuZ2xlKSBnLnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoaXQoZywgbywgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChvLmZvbnRTaXplIDw9IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKCFvLmFuZ2xlKSByZXR1cm4gdHJ1ZTsgLy8gYm91bmRzIHN1ZmZpY2llbnQgaWYgbm8gcm90YXRpb25cblxuICAvLyBwcm9qZWN0IHBvaW50IGludG8gc3BhY2Ugb2YgdW5yb3RhdGVkIGJvdW5kc1xuICB2YXIgYiA9IHRleHRCb3VuZHMobywgdGVtcEJvdW5kcywgdHJ1ZSksXG4gICAgICBhID0gLW8uYW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgY29zID0gTWF0aC5jb3MoYSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhKSxcbiAgICAgIG94ID0gby54LFxuICAgICAgb3kgPSBvLnksXG4gICAgICBweCA9IGNvcypneCAtIHNpbipneSArIChveCAtIG94KmNvcyArIG95KnNpbiksXG4gICAgICBweSA9IHNpbipneCArIGNvcypneSArIChveSAtIG94KnNpbiAtIG95KmNvcyk7XG5cbiAgcmV0dXJuIGIuY29udGFpbnMocHgsIHB5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHV0aWwucGljayhoaXQpXG59O1xuIiwiZnVuY3Rpb24gZHJhd1BhdGhPbmUocGF0aCwgZywgbywgaXRlbXMpIHtcbiAgaWYgKHBhdGgoZywgaXRlbXMpKSByZXR1cm47XG5cbiAgdmFyIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gIGlmIChvcGFjPT09MCkgcmV0dXJuO1xuXG4gIGlmIChvLmZpbGwgJiYgZmlsbChnLCBvLCBvcGFjKSkgeyBnLmZpbGwoKTsgfVxuICBpZiAoby5zdHJva2UgJiYgc3Ryb2tlKGcsIG8sIG9wYWMpKSB7IGcuc3Ryb2tlKCk7IH1cbn1cblxuZnVuY3Rpb24gZHJhd1BhdGhBbGwocGF0aCwgZywgc2NlbmUsIGJvdW5kcykge1xuICB2YXIgaSwgbGVuLCBpdGVtO1xuICBmb3IgKGk9MCwgbGVuPXNjZW5lLml0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBzY2VuZS5pdGVtc1tpXTtcbiAgICBpZiAoIWJvdW5kcyB8fCBib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHtcbiAgICAgIGRyYXdQYXRoT25lKHBhdGgsIGcsIGl0ZW0sIGl0ZW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QWxsKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgZHJhd1BhdGhBbGwocGF0aEZ1bmMsIGcsIHNjZW5lLCBib3VuZHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3T25lKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoIWJvdW5kcyB8fCBib3VuZHMuaW50ZXJzZWN0cyhzY2VuZS5ib3VuZHMpKSB7XG4gICAgICBkcmF3UGF0aE9uZShwYXRoRnVuYywgZywgc2NlbmUuaXRlbXNbMF0sIHNjZW5lLml0ZW1zKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB0cnVlRnVuYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblxuZnVuY3Rpb24gcGljayh0ZXN0KSB7XG4gIGlmICghdGVzdCkgdGVzdCA9IHRydWVGdW5jO1xuXG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIG8sIGIsIGk7XG5cbiAgICBpZiAoZy5waXhlbHJhdGlvICE9IG51bGwgJiYgZy5waXhlbHJhdGlvICE9PSAxKSB7XG4gICAgICB4ICo9IGcucGl4ZWxyYXRpbztcbiAgICAgIHkgKj0gZy5waXhlbHJhdGlvO1xuICAgIH1cblxuICAgIGZvciAoaT1zY2VuZS5pdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgbyA9IHNjZW5lLml0ZW1zW2ldOyBiID0gby5ib3VuZHM7XG4gICAgICAvLyBmaXJzdCBoaXQgdGVzdCBhZ2FpbnN0IGJvdW5kaW5nIGJveFxuICAgICAgaWYgKChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHx8ICFiKSBjb250aW51ZTtcbiAgICAgIC8vIGlmIGluIGJvdW5kaW5nIGJveCwgcGVyZm9ybSBtb3JlIGNhcmVmdWwgdGVzdFxuICAgICAgaWYgKHRlc3QoZywgbywgeCwgeSwgZ3gsIGd5KSkgcmV0dXJuIG87XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXN0UGF0aChwYXRoLCBmaWxsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIG8sIHgsIHkpIHtcbiAgICB2YXIgaXRlbSA9IEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogbyxcbiAgICAgICAgZmlsbCA9IChmaWxsZWQgPT0gbnVsbCkgPyBpdGVtLmZpbGwgOiBmaWxsZWQsXG4gICAgICAgIHN0cm9rZSA9IGl0ZW0uc3Ryb2tlICYmIGcuaXNQb2ludEluU3Ryb2tlLCBsdywgbGM7XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBsdyA9IGl0ZW0uc3Ryb2tlV2lkdGg7XG4gICAgICBsYyA9IGl0ZW0uc3Ryb2tlQ2FwO1xuICAgICAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiAxO1xuICAgICAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiAnYnV0dCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGgoZywgbykgPyBmYWxzZSA6XG4gICAgICAoZmlsbCAmJiBnLmlzUG9pbnRJblBhdGgoeCwgeSkpIHx8XG4gICAgICAoc3Ryb2tlICYmIGcuaXNQb2ludEluU3Ryb2tlKHgsIHkpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGlja1BhdGgocGF0aCkge1xuICByZXR1cm4gcGljayh0ZXN0UGF0aChwYXRoKSk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoZywgbywgb3BhY2l0eSkge1xuICBvcGFjaXR5ICo9IChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICBnLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIG8uZmlsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cm9rZShnLCBvLCBvcGFjaXR5KSB7XG4gIHZhciBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IDEsIGxjO1xuICBpZiAobHcgPD0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIG9wYWNpdHkgKj0gKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICBnLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgby5zdHJva2UpO1xuICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbG9yKGcsIG8sIHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUuaWQpID9cbiAgICBncmFkaWVudChnLCB2YWx1ZSwgby5ib3VuZHMpIDpcbiAgICB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ3JhZGllbnQoZywgcCwgYikge1xuICB2YXIgdyA9IGIud2lkdGgoKSxcbiAgICAgIGggPSBiLmhlaWdodCgpLFxuICAgICAgeDEgPSBiLngxICsgcC54MSAqIHcsXG4gICAgICB5MSA9IGIueTEgKyBwLnkxICogaCxcbiAgICAgIHgyID0gYi54MSArIHAueDIgKiB3LFxuICAgICAgeTIgPSBiLnkxICsgcC55MiAqIGgsXG4gICAgICBncmFkID0gZy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MiksXG4gICAgICBzdG9wID0gcC5zdG9wcyxcbiAgICAgIGksIG47XG5cbiAgZm9yIChpPTAsIG49c3RvcC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JhZC5hZGRDb2xvclN0b3Aoc3RvcFtpXS5vZmZzZXQsIHN0b3BbaV0uY29sb3IpO1xuICB9XG4gIHJldHVybiBncmFkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhd09uZTogIGRyYXdPbmUsXG4gIGRyYXdBbGw6ICBkcmF3QWxsLFxuICBwaWNrOiAgICAgcGljayxcbiAgcGlja1BhdGg6IHBpY2tQYXRoLFxuICB0ZXN0UGF0aDogdGVzdFBhdGgsXG4gIHN0cm9rZTogICBzdHJva2UsXG4gIGZpbGw6ICAgICBmaWxsLFxuICBjb2xvcjogICAgY29sb3IsXG4gIGdyYWRpZW50OiBncmFkaWVudFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnY2FudmFzJzogcmVxdWlyZSgnLi9jYW52YXMnKSxcbiAgJ3N2Zyc6ICAgIHJlcXVpcmUoJy4vc3ZnJylcbn07XG4iLCJ2YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBIYW5kbGVyID0gcmVxdWlyZSgnLi4vSGFuZGxlcicpO1xuXG5mdW5jdGlvbiBTVkdIYW5kbGVyKCkge1xuICBIYW5kbGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBiYXNlID0gSGFuZGxlci5wcm90b3R5cGU7XG52YXIgcHJvdG90eXBlID0gKFNWR0hhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkdIYW5kbGVyO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCBwYWQsIG9iaikge1xuICB0aGlzLl9zdmcgPSBET00uZmluZChlbCwgJ3N2ZycpO1xuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHBhZCwgb2JqKTtcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N2Zztcbn07XG5cbi8vIHdyYXAgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBTVkcgRE9NXG5wcm90b3R5cGUubGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBpdGVtID0gdGFyZ2V0Ll9fZGF0YV9fO1xuICAgIGV2dC52ZWdhVHlwZSA9IGV2dC50eXBlO1xuICAgIGl0ZW0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbVswXSA6IGl0ZW07XG4gICAgaGFuZGxlci5jYWxsKHRoYXQuX29iaiwgZXZ0LCBpdGVtKTtcbiAgfTtcbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICB4ID0ge1xuICAgICAgICB0eXBlOiAgICAgdHlwZSxcbiAgICAgICAgaGFuZGxlcjogIGhhbmRsZXIsXG4gICAgICAgIGxpc3RlbmVyOiB0aGlzLmxpc3RlbmVyKGhhbmRsZXIpXG4gICAgICB9O1xuXG4gIChoW25hbWVdIHx8IChoW25hbWVdID0gW10pKS5wdXNoKHgpO1xuICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCB4Lmxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSwgaTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAoaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmIChoW2ldLnR5cGUgPT09IHR5cGUgJiYgIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoW2ldLmxpc3RlbmVyKTtcbiAgICAgIGguc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHSGFuZGxlcjtcbiIsInZhciBJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvSW1hZ2VMb2FkZXInKSxcbiAgICBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL1JlbmRlcmVyJyksXG4gICAgdGV4dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGV4dCcpLFxuICAgIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgU1ZHID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zdmcnKSxcbiAgICBucyA9IFNWRy5tZXRhZGF0YS54bWxucyxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxuZnVuY3Rpb24gU1ZHUmVuZGVyZXIobG9hZENvbmZpZykge1xuICBSZW5kZXJlci5jYWxsKHRoaXMpO1xuICB0aGlzLl9sb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobG9hZENvbmZpZyk7XG4gIHRoaXMuX2RpcnR5SUQgPSAwO1xufVxuXG52YXIgYmFzZSA9IFJlbmRlcmVyLnByb3RvdHlwZTtcbnZhciBwcm90b3R5cGUgPSAoU1ZHUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkdSZW5kZXJlcjtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBpZiAoZWwpIHtcbiAgICB0aGlzLl9zdmcgPSBET00uY2hpbGQoZWwsIDAsICdzdmcnLCBucywgJ21hcmtzJyk7XG4gICAgRE9NLmNsZWFyKGVsLCAxKTtcbiAgICAvLyBzZXQgdGhlIHN2ZyByb290IGdyb3VwXG4gICAgdGhpcy5fcm9vdCA9IERPTS5jaGlsZCh0aGlzLl9zdmcsIDAsICdnJywgbnMpO1xuICAgIERPTS5jbGVhcih0aGlzLl9zdmcsIDEpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHRoZSBzdmcgZGVmaW5pdGlvbnMgY2FjaGVcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBjbGlwX2lkOiAgMSxcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG5cbiAgLy8gc2V0IGJhY2tncm91bmQgY29sb3IgaWYgZGVmaW5lZFxuICB0aGlzLmJhY2tncm91bmQodGhpcy5fYmdjb2xvcik7XG5cbiAgcmV0dXJuIGJhc2UuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbn07XG5cbnByb3RvdHlwZS5iYWNrZ3JvdW5kID0gZnVuY3Rpb24oYmdjb2xvcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0aGlzLl9zdmcpIHtcbiAgICB0aGlzLl9zdmcuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBiZ2NvbG9yKTtcbiAgfVxuICByZXR1cm4gYmFzZS5iYWNrZ3JvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBiYXNlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICBcbiAgaWYgKHRoaXMuX3N2Zykge1xuICAgIHZhciB3ID0gdGhpcy5fd2lkdGgsXG4gICAgICAgIGggPSB0aGlzLl9oZWlnaHQsXG4gICAgICAgIHAgPSB0aGlzLl9wYWRkaW5nO1xuICBcbiAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHcgKyBwLmxlZnQgKyBwLnJpZ2h0KTtcbiAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoICsgcC50b3AgKyBwLmJvdHRvbSk7XG4gICAgXG4gICAgdGhpcy5fcm9vdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJytwLmxlZnQrJywnK3AudG9wKycpJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9zdmcpIHJldHVybiBudWxsO1xuXG4gIHZhciBhdHRyID0ge1xuICAgICdjbGFzcyc6ICAnbWFya3MnLFxuICAgICd3aWR0aCc6ICB0aGlzLl93aWR0aCArIHRoaXMuX3BhZGRpbmcubGVmdCArIHRoaXMuX3BhZGRpbmcucmlnaHQsXG4gICAgJ2hlaWdodCc6IHRoaXMuX2hlaWdodCArIHRoaXMuX3BhZGRpbmcudG9wICsgdGhpcy5fcGFkZGluZy5ib3R0b20sXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBTVkcubWV0YWRhdGEpIHtcbiAgICBhdHRyW2tleV0gPSBTVkcubWV0YWRhdGFba2V5XTtcbiAgfVxuXG4gIHJldHVybiBET00ub3BlblRhZygnc3ZnJywgYXR0cikgKyB0aGlzLl9zdmcuaW5uZXJIVE1MICsgRE9NLmNsb3NlVGFnKCdzdmcnKTtcbn07XG5cbnByb3RvdHlwZS5pbWFnZVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICByZXR1cm4gdGhpcy5fbG9hZGVyLmltYWdlVVJMKHVybCk7XG59O1xuXG5cbi8vIC0tIFJlbmRlciBlbnRyeSBwb2ludCAtLVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIGlmICh0aGlzLl9kaXJ0eUNoZWNrKGl0ZW1zKSkge1xuICAgIGlmICh0aGlzLl9kaXJ0eUFsbCkgdGhpcy5fcmVzZXREZWZzKCk7XG4gICAgdGhpcy5kcmF3KHRoaXMuX3Jvb3QsIHNjZW5lLCAtMSk7XG4gICAgRE9NLmNsZWFyKHRoaXMuX3Jvb3QsIDEpO1xuICB9XG4gIHRoaXMudXBkYXRlRGVmcygpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZWwsIHNjZW5lLCBpbmRleCkge1xuICB0aGlzLmRyYXdNYXJrKGVsLCBzY2VuZSwgaW5kZXgsIG1hcmtzW3NjZW5lLm1hcmt0eXBlXSk7XG59O1xuXG5cbi8vIC0tIE1hbmFnZSBTVkcgZGVmaW5pdGlvbnMgKCdkZWZzJykgYmxvY2sgLS1cblxucHJvdG90eXBlLnVwZGF0ZURlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGRlZnMgPSB0aGlzLl9kZWZzLFxuICAgICAgZWwgPSBkZWZzLmVsLFxuICAgICAgaW5kZXggPSAwLCBpZDtcblxuICBmb3IgKGlkIGluIGRlZnMuZ3JhZGllbnQpIHtcbiAgICBpZiAoIWVsKSBlbCA9IChkZWZzLmVsID0gRE9NLmNoaWxkKHN2ZywgMCwgJ2RlZnMnLCBucykpO1xuICAgIHVwZGF0ZUdyYWRpZW50KGVsLCBkZWZzLmdyYWRpZW50W2lkXSwgaW5kZXgrKyk7XG4gIH1cblxuICBmb3IgKGlkIGluIGRlZnMuY2xpcHBpbmcpIHtcbiAgICBpZiAoIWVsKSBlbCA9IChkZWZzLmVsID0gRE9NLmNoaWxkKHN2ZywgMCwgJ2RlZnMnLCBucykpO1xuICAgIHVwZGF0ZUNsaXBwaW5nKGVsLCBkZWZzLmNsaXBwaW5nW2lkXSwgaW5kZXgrKyk7XG4gIH1cblxuICAvLyBjbGVhbi11cFxuICBpZiAoZWwpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHN2Zy5yZW1vdmVDaGlsZChlbCk7XG4gICAgICBkZWZzLmVsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLmNsZWFyKGVsLCBpbmRleCk7ICAgICAgXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVHcmFkaWVudChlbCwgZ3JhZCwgaW5kZXgpIHtcbiAgdmFyIGksIG4sIHN0b3A7XG5cbiAgZWwgPSBET00uY2hpbGQoZWwsIGluZGV4LCAnbGluZWFyR3JhZGllbnQnLCBucyk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkLmlkKTtcbiAgZWwuc2V0QXR0cmlidXRlKCd4MScsIGdyYWQueDEpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3gyJywgZ3JhZC54Mik7XG4gIGVsLnNldEF0dHJpYnV0ZSgneTEnLCBncmFkLnkxKTtcbiAgZWwuc2V0QXR0cmlidXRlKCd5MicsIGdyYWQueTIpO1xuICBcbiAgZm9yIChpPTAsIG49Z3JhZC5zdG9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RvcCA9IERPTS5jaGlsZChlbCwgaSwgJ3N0b3AnLCBucyk7XG4gICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGdyYWQuc3RvcHNbaV0ub2Zmc2V0KTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsIGdyYWQuc3RvcHNbaV0uY29sb3IpO1xuICB9XG4gIERPTS5jbGVhcihlbCwgaSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsaXBwaW5nKGVsLCBjbGlwLCBpbmRleCkge1xuICB2YXIgcmVjdDtcblxuICBlbCA9IERPTS5jaGlsZChlbCwgaW5kZXgsICdjbGlwUGF0aCcsIG5zKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdpZCcsIGNsaXAuaWQpO1xuICByZWN0ID0gRE9NLmNoaWxkKGVsLCAwLCAncmVjdCcsIG5zKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgY2xpcC53aWR0aCk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBjbGlwLmhlaWdodCk7XG59XG5cbnByb3RvdHlwZS5fcmVzZXREZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWZzO1xuICBkZWYuY2xpcF9pZCA9IDE7XG4gIGRlZi5ncmFkaWVudCA9IHt9O1xuICBkZWYuY2xpcHBpbmcgPSB7fTtcbn07XG5cblxuLy8gLS0gTWFuYWdlIHJlbmRlcmluZyBvZiBpdGVtcyBtYXJrZWQgYXMgZGlydHkgLS1cblxucHJvdG90eXBlLmlzRGlydHkgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHJldHVybiB0aGlzLl9kaXJ0eUFsbCB8fCBpdGVtLmRpcnR5ID09PSB0aGlzLl9kaXJ0eUlEO1xufTtcblxucHJvdG90eXBlLl9kaXJ0eUNoZWNrID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdGhpcy5fZGlydHlBbGwgPSB0cnVlO1xuICBpZiAoIWl0ZW1zKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaWQgPSArK3RoaXMuX2RpcnR5SUQsXG4gICAgICBpdGVtLCBtYXJrLCB0eXBlLCBtZGVmLCBpLCBuLCBvO1xuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgbWFyayA9IGl0ZW0ubWFyaztcbiAgICBpZiAobWFyay5tYXJrdHlwZSAhPT0gdHlwZSkge1xuICAgICAgLy8gbWVtb2l6ZSBtYXJrIGluc3RhbmNlIGxvb2t1cFxuICAgICAgdHlwZSA9IG1hcmsubWFya3R5cGU7XG4gICAgICBtZGVmID0gbWFya3NbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uc3RhdHVzID09PSAnZXhpdCcpIHsgLy8gRVhJVFxuICAgICAgaWYgKGl0ZW0uX3N2Zykge1xuICAgICAgICBpZiAobWRlZi5uZXN0ICYmIGl0ZW0ubWFyay5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpZiBuZXN0ZWQgbWFyayB3aXRoIHJlbWFpbmluZyBwb2ludHMsIHVwZGF0ZSBpbnN0ZWFkXG4gICAgICAgICAgdGhpcy5fdXBkYXRlKG1kZWYsIGl0ZW0uX3N2ZywgaXRlbS5tYXJrLml0ZW1zWzBdKTtcbiAgICAgICAgICBvID0gaXRlbS5tYXJrLml0ZW1zWzBdO1xuICAgICAgICAgIG8uX3N2ZyA9IGl0ZW0uX3N2ZztcbiAgICAgICAgICBvLl91cGRhdGUgPSBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2UgcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgICAgRE9NLnJlbW92ZShpdGVtLl9zdmcpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uX3N2ZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpdGVtID0gKG1kZWYubmVzdCA/IG1hcmsuaXRlbXNbMF0gOiBpdGVtKTtcbiAgICBpZiAoaXRlbS5fdXBkYXRlID09PSBpZCkgeyAvLyBBbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChpdGVtLl9zdmcpIHsgLy8gVVBEQVRFXG4gICAgICB0aGlzLl91cGRhdGUobWRlZiwgaXRlbS5fc3ZnLCBpdGVtKTtcbiAgICB9IGVsc2UgeyAvLyBFTlRFUlxuICAgICAgdGhpcy5fZGlydHlBbGwgPSBmYWxzZTtcbiAgICAgIGRpcnR5UGFyZW50cyhpdGVtLCBpZCk7XG4gICAgfVxuICAgIGl0ZW0uX3VwZGF0ZSA9IGlkO1xuICB9XG4gIHJldHVybiAhdGhpcy5fZGlydHlBbGw7XG59O1xuXG5mdW5jdGlvbiBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpIHtcbiAgZm9yICg7IGl0ZW0gJiYgaXRlbS5kaXJ0eSAhPT0gaWQ7IGl0ZW09aXRlbS5tYXJrLmdyb3VwKSB7XG4gICAgaXRlbS5kaXJ0eSA9IGlkO1xuICAgIGlmIChpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLmRpcnR5ICE9PSBpZCkge1xuICAgICAgaXRlbS5tYXJrLmRpcnR5ID0gaWQ7XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxufVxuXG5cbi8vIC0tIENvbnN0cnVjdCAmIG1haW50YWluIHNjZW5lZ3JhcGggdG8gU1ZHIG1hcHBpbmcgLS0tXG5cbi8vIERyYXcgYSBtYXJrIGNvbnRhaW5lci5cbnByb3RvdHlwZS5kcmF3TWFyayA9IGZ1bmN0aW9uKGVsLCBzY2VuZSwgaW5kZXgsIG1kZWYpIHtcbiAgaWYgKCF0aGlzLmlzRGlydHkoc2NlbmUpKSByZXR1cm47XG5cbiAgdmFyIGl0ZW1zID0gbWRlZi5uZXN0ID9cbiAgICAgICAgKHNjZW5lLml0ZW1zICYmIHNjZW5lLml0ZW1zLmxlbmd0aCA/IFtzY2VuZS5pdGVtc1swXV0gOiBbXSkgOlxuICAgICAgICBzY2VuZS5pdGVtcyB8fCBbXSxcbiAgICAgIGV2ZW50cyA9IHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGwsXG4gICAgICBpc0dyb3VwID0gKG1kZWYudGFnID09PSAnZycpLFxuICAgICAgY2xhc3NOYW1lID0gRE9NLmNzc0NsYXNzKHNjZW5lKSxcbiAgICAgIHAsIGksIG4sIGMsIGQsIGluc2VydDtcblxuICBwID0gRE9NLmNoaWxkKGVsLCBpbmRleCsxLCAnZycsIG5zLCBjbGFzc05hbWUpO1xuICBwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuICBzY2VuZS5fc3ZnID0gcDtcbiAgaWYgKCFpc0dyb3VwICYmIGV2ZW50cykge1xuICAgIHAuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgZXZlbnRzKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpZiAodGhpcy5pc0RpcnR5KGQgPSBpdGVtc1tpXSkpIHtcbiAgICAgIGluc2VydCA9ICEodGhpcy5fZGlydHlBbGwgfHwgZC5fc3ZnKTtcbiAgICAgIGMgPSBiaW5kKHAsIG1kZWYsIGQsIGksIGluc2VydCk7XG4gICAgICB0aGlzLl91cGRhdGUobWRlZiwgYywgZCk7XG4gICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICBpZiAoaW5zZXJ0KSB0aGlzLl9kaXJ0eUFsbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2UoYywgZCk7XG4gICAgICAgIGlmIChpbnNlcnQpIHRoaXMuX2RpcnR5QWxsID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIERPTS5jbGVhcihwLCBpKTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vLyBSZWN1cnNpdmVseSBwcm9jZXNzIGdyb3VwIGNvbnRlbnRzLlxucHJvdG90eXBlLl9yZWN1cnNlID0gZnVuY3Rpb24oZWwsIGdyb3VwKSB7XG4gIHZhciBpdGVtcyA9IGdyb3VwLml0ZW1zIHx8IFtdLFxuICAgICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgYXhlcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGlkeCA9IDAsIGosIG07XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0ubGF5ZXIgPT09ICdiYWNrJykge1xuICAgICAgdGhpcy5kcmF3TWFyayhlbCwgYXhlc1tqXSwgaWR4KyssIG1hcmtzLmdyb3VwKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHRoaXMuZHJhdyhlbCwgaXRlbXNbal0sIGlkeCsrKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5sYXllciAhPT0gJ2JhY2snKSB7XG4gICAgICB0aGlzLmRyYXdNYXJrKGVsLCBheGVzW2pdLCBpZHgrKywgbWFya3MuZ3JvdXApO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICB0aGlzLmRyYXdNYXJrKGVsLCBsZWdlbmRzW2pdLCBpZHgrKywgbWFya3MuZ3JvdXApO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBleHRyYW5lb3VzIERPTSBlbGVtZW50c1xuICBET00uY2xlYXIoZWwsIDEgKyBpZHgpO1xufTtcblxuLy8gQmluZCBhIHNjZW5lZ3JhcGggaXRlbSB0byBhbiBTVkcgRE9NIGVsZW1lbnQuXG4vLyBDcmVhdGUgbmV3IFNWRyBlbGVtZW50cyBhcyBuZWVkZWQuXG5mdW5jdGlvbiBiaW5kKGVsLCBtZGVmLCBpdGVtLCBpbmRleCwgaW5zZXJ0KSB7XG4gIC8vIGNyZWF0ZSBzdmcgZWxlbWVudCwgYmluZCBpdGVtIGRhdGEgZm9yIEQzIGNvbXBhdGliaWxpdHlcbiAgdmFyIG5vZGUgPSBET00uY2hpbGQoZWwsIGluZGV4LCBtZGVmLnRhZywgbnMsIG51bGwsIGluc2VydCk7XG4gIG5vZGUuX19kYXRhX18gPSBpdGVtO1xuICBub2RlLl9fdmFsdWVzX18gPSB7ZmlsbDogJ2RlZmF1bHQnfTtcblxuICAvLyBjcmVhdGUgYmFja2dyb3VuZCByZWN0XG4gIGlmIChtZGVmLnRhZyA9PT0gJ2cnKSB7XG4gICAgdmFyIGJnID0gRE9NLmNoaWxkKG5vZGUsIDAsICdyZWN0JywgbnMsICdiYWNrZ3JvdW5kJyk7XG4gICAgYmcuX19kYXRhX18gPSBpdGVtO1xuICB9XG5cbiAgLy8gYWRkIHBvaW50ZXIgZnJvbSBzY2VuZWdyYXBoIGl0ZW0gdG8gc3ZnIGVsZW1lbnRcbiAgcmV0dXJuIChpdGVtLl9zdmcgPSBub2RlKTtcbn1cblxuXG4vLyAtLSBTZXQgYXR0cmlidXRlcyAmIHN0eWxlcyBvbiBTVkcgZWxlbWVudHMgLS0tXG5cbnZhciBocmVmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAnJyksXG4gICAgZWxlbWVudCA9IG51bGwsIC8vIHRlbXAgdmFyIGZvciBjdXJyZW50IFNWRyBlbGVtZW50XG4gICAgdmFsdWVzID0gbnVsbDsgIC8vIHRlbXAgdmFyIGZvciBjdXJyZW50IHZhbHVlcyBoYXNoXG5cbi8vIEV4dHJhIGNvbmZpZ3VyYXRpb24gZm9yIGNlcnRhaW4gbWFyayB0eXBlc1xudmFyIG1hcmtfZXh0cmFzID0ge1xuICBncm91cDogZnVuY3Rpb24obWRlZiwgZWwsIGl0ZW0pIHtcbiAgICBlbGVtZW50ID0gZWwuY2hpbGROb2Rlc1swXTtcbiAgICB2YWx1ZXMgPSBlbC5fX3ZhbHVlc19fOyAvLyB1c2UgcGFyZW50J3MgdmFsdWVzIGhhc2hcbiAgICBtZGVmLmJhY2tncm91bmQoZW1pdCwgaXRlbSwgdGhpcyk7XG5cbiAgICB2YXIgdmFsdWUgPSBpdGVtLm1hcmsuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbDtcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlcy5ldmVudHMpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgdmFsdWUpO1xuICAgICAgdmFsdWVzLmV2ZW50cyA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgdGV4dDogZnVuY3Rpb24obWRlZiwgZWwsIGl0ZW0pIHtcbiAgICB2YXIgc3RyID0gdGV4dC52YWx1ZShpdGVtLnRleHQpO1xuICAgIGlmIChzdHIgIT09IHZhbHVlcy50ZXh0KSB7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IHN0cjtcbiAgICAgIHZhbHVlcy50ZXh0ID0gc3RyO1xuICAgIH1cbiAgICBzdHIgPSB0ZXh0LmZvbnQoaXRlbSk7XG4gICAgaWYgKHN0ciAhPT0gdmFsdWVzLmZvbnQpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KCdmb250Jywgc3RyKTtcbiAgICAgIHZhbHVlcy5mb250ID0gc3RyO1xuICAgIH1cbiAgfVxufTtcblxucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihtZGVmLCBlbCwgaXRlbSkge1xuICAvLyBzZXQgZG9tIGVsZW1lbnQgYW5kIHZhbHVlcyBjYWNoZVxuICAvLyBwcm92aWRlcyBhY2Nlc3MgdG8gZW1pdCBtZXRob2RcbiAgZWxlbWVudCA9IGVsO1xuICB2YWx1ZXMgPSBlbC5fX3ZhbHVlc19fO1xuXG4gIC8vIGFwcGx5IHN2ZyBhdHRyaWJ1dGVzXG4gIG1kZWYuYXR0cihlbWl0LCBpdGVtLCB0aGlzKTtcblxuICAvLyBzb21lIG1hcmtzIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgdmFyIGV4dHJhID0gbWFya19leHRyYXNbbWRlZi50eXBlXTtcbiAgaWYgKGV4dHJhKSBleHRyYShtZGVmLCBlbCwgaXRlbSk7XG5cbiAgLy8gYXBwbHkgc3ZnIGNzcyBzdHlsZXNcbiAgLy8gbm90ZTogZWxlbWVudCBtYXkgYmUgbW9kaWZpZWQgYnkgJ2V4dHJhJyBtZXRob2RcbiAgdGhpcy5zdHlsZShlbGVtZW50LCBpdGVtKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXQobmFtZSwgdmFsdWUsIG5zKSB7XG4gIC8vIGVhcmx5IGV4aXQgaWYgdmFsdWUgaXMgdW5jaGFuZ2VkXG4gIGlmICh2YWx1ZSA9PT0gdmFsdWVzW25hbWVdKSByZXR1cm47XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBpZiB2YWx1ZSBpcyBwcm92aWRlZCwgdXBkYXRlIERPTSBhdHRyaWJ1dGVcbiAgICBpZiAobnMpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnMsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHJlbW92ZSBET00gYXR0cmlidXRlXG4gICAgaWYgKG5zKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbm90ZSBjdXJyZW50IHZhbHVlIGZvciBmdXR1cmUgY29tcGFyaXNvblxuICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbn1cblxucHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24oZWwsIG8pIHtcbiAgaWYgKG8gPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWU7XG5cbiAgZm9yIChpPTAsIG49U1ZHLnN0eWxlUHJvcGVydGllcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IFNWRy5zdHlsZVByb3BlcnRpZXNbaV07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuICAgIGlmICh2YWx1ZSA9PT0gdmFsdWVzW3Byb3BdKSBjb250aW51ZTtcblxuICAgIG5hbWUgPSBTVkcuc3R5bGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobmFtZSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsICdub25lJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgIC8vIGVuc3VyZSBkZWZpbml0aW9uIGlzIGluY2x1ZGVkXG4gICAgICAgIHRoaXMuX2RlZnMuZ3JhZGllbnRbdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gJ3VybCgnICsgaHJlZiArICcjJyArIHZhbHVlLmlkICsgJyknO1xuICAgICAgfVxuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUrJycpO1xuICAgIH1cblxuICAgIHZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1JlbmRlcmVyO1xuIiwidmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKSxcbiAgICBJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvSW1hZ2VMb2FkZXInKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIHRleHQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RleHQnKSxcbiAgICBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIG9wZW5UYWcgPSBET00ub3BlblRhZyxcbiAgICBjbG9zZVRhZyA9IERPTS5jbG9zZVRhZyxcbiAgICBNQVJLUyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxuZnVuY3Rpb24gU1ZHU3RyaW5nUmVuZGVyZXIobG9hZENvbmZpZykge1xuICBSZW5kZXJlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcblxuICB0aGlzLl90ZXh0ID0ge1xuICAgIGhlYWQ6ICcnLFxuICAgIHJvb3Q6ICcnLFxuICAgIGZvb3Q6ICcnLFxuICAgIGRlZnM6ICcnLFxuICAgIGJvZHk6ICcnXG4gIH07XG5cbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBjbGlwX2lkOiAgMSxcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59XG5cbnZhciBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChTVkdTdHJpbmdSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR1N0cmluZ1JlbmRlcmVyO1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBiYXNlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICB2YXIgcCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICB0ID0gdGhpcy5fdGV4dDtcblxuICB2YXIgYXR0ciA9IHtcbiAgICAnY2xhc3MnOiAgJ21hcmtzJyxcbiAgICAnd2lkdGgnOiAgdGhpcy5fd2lkdGggKyBwLmxlZnQgKyBwLnJpZ2h0LFxuICAgICdoZWlnaHQnOiB0aGlzLl9oZWlnaHQgKyBwLnRvcCArIHAuYm90dG9tLFxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gU1ZHLm1ldGFkYXRhKSB7XG4gICAgYXR0cltrZXldID0gU1ZHLm1ldGFkYXRhW2tleV07XG4gIH1cblxuICB0LmhlYWQgPSBvcGVuVGFnKCdzdmcnLCBhdHRyKTtcbiAgdC5yb290ID0gb3BlblRhZygnZycsIHtcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHAubGVmdCArICcsJyArIHAudG9wICsgJyknXG4gIH0pO1xuICB0LmZvb3QgPSBjbG9zZVRhZygnZycpICsgY2xvc2VUYWcoJ3N2ZycpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG4gIHJldHVybiB0LmhlYWQgKyB0LmRlZnMgKyB0LnJvb3QgKyB0LmJvZHkgKyB0LmZvb3Q7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdGhpcy5fdGV4dC5ib2R5ID0gdGhpcy5tYXJrKHNjZW5lKTtcbiAgdGhpcy5fdGV4dC5kZWZzID0gdGhpcy5idWlsZERlZnMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZGVmcy5jbGlwX2lkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYnVpbGREZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGVmcyA9ICcnLFxuICAgICAgaSwgaWQsIGRlZiwgc3RvcHM7XG5cbiAgZm9yIChpZCBpbiBhbGwuZ3JhZGllbnQpIHtcbiAgICBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdO1xuICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuXG4gICAgZGVmcyArPSBvcGVuVGFnKCdsaW5lYXJHcmFkaWVudCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHgxOiBkZWYueDEsXG4gICAgICB4MjogZGVmLngyLFxuICAgICAgeTE6IGRlZi55MSxcbiAgICAgIHkyOiBkZWYueTJcbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGk9MDsgaTxzdG9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgZGVmcyArPSBvcGVuVGFnKCdzdG9wJywge1xuICAgICAgICBvZmZzZXQ6IHN0b3BzW2ldLm9mZnNldCxcbiAgICAgICAgJ3N0b3AtY29sb3InOiBzdG9wc1tpXS5jb2xvclxuICAgICAgfSkgKyBjbG9zZVRhZygnc3RvcCcpO1xuICAgIH1cbiAgICBcbiAgICBkZWZzICs9IGNsb3NlVGFnKCdsaW5lYXJHcmFkaWVudCcpO1xuICB9XG4gIFxuICBmb3IgKGlkIGluIGFsbC5jbGlwcGluZykge1xuICAgIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF07XG5cbiAgICBkZWZzICs9IG9wZW5UYWcoJ2NsaXBQYXRoJywge2lkOiBpZH0pO1xuXG4gICAgZGVmcyArPSBvcGVuVGFnKCdyZWN0Jywge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZGVmLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgfSkgKyBjbG9zZVRhZygncmVjdCcpO1xuXG4gICAgZGVmcyArPSBjbG9zZVRhZygnY2xpcFBhdGgnKTtcbiAgfVxuICBcbiAgcmV0dXJuIChkZWZzLmxlbmd0aCA+IDApID8gb3BlblRhZygnZGVmcycpICsgZGVmcyArIGNsb3NlVGFnKCdkZWZzJykgOiAnJztcbn07XG5cbnByb3RvdHlwZS5pbWFnZVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICByZXR1cm4gdGhpcy5fbG9hZGVyLmltYWdlVVJMKHVybCk7XG59O1xuXG52YXIgb2JqZWN0O1xuXG5mdW5jdGlvbiBlbWl0KG5hbWUsIHZhbHVlLCBucywgcHJlZml4ZWQpIHtcbiAgb2JqZWN0W3ByZWZpeGVkIHx8IG5hbWVdID0gdmFsdWU7XG59XG5cbnByb3RvdHlwZS5hdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0ciwgaXRlbSkge1xuICBvYmplY3QgPSB7fTtcbiAgYXR0cihlbWl0LCBpdGVtLCB0aGlzKTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIG1kZWYgPSBNQVJLU1tzY2VuZS5tYXJrdHlwZV0sXG4gICAgICB0YWcgID0gbWRlZi50YWcsXG4gICAgICBhdHRyID0gbWRlZi5hdHRyLFxuICAgICAgbmVzdCA9IG1kZWYubmVzdCB8fCBmYWxzZSxcbiAgICAgIGRhdGEgPSBuZXN0ID9cbiAgICAgICAgICAoc2NlbmUuaXRlbXMgJiYgc2NlbmUuaXRlbXMubGVuZ3RoID8gW3NjZW5lLml0ZW1zWzBdXSA6IFtdKSA6XG4gICAgICAgICAgKHNjZW5lLml0ZW1zIHx8IFtdKSxcbiAgICAgIGRlZnMgPSB0aGlzLl9kZWZzLFxuICAgICAgc3RyID0gJycsXG4gICAgICBzdHlsZSwgaSwgaXRlbTtcblxuICBpZiAodGFnICE9PSAnZycgJiYgc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgc3R5bGUgPSAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIic7XG4gIH1cblxuICAvLyByZW5kZXIgb3BlbmluZyBncm91cCB0YWdcbiAgc3RyICs9IG9wZW5UYWcoJ2cnLCB7XG4gICAgJ2NsYXNzJzogRE9NLmNzc0NsYXNzKHNjZW5lKVxuICB9LCBzdHlsZSk7XG5cbiAgLy8gcmVuZGVyIGNvbnRhaW5lZCBlbGVtZW50c1xuICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgaXRlbSA9IGRhdGFbaV07XG4gICAgc3R5bGUgPSAodGFnICE9PSAnZycpID8gc3R5bGVzKGl0ZW0sIHNjZW5lLCB0YWcsIGRlZnMpIDogbnVsbDtcbiAgICBzdHIgKz0gb3BlblRhZyh0YWcsIHRoaXMuYXR0cmlidXRlcyhhdHRyLCBpdGVtKSwgc3R5bGUpO1xuICAgIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgICAgc3RyICs9IGVzY2FwZV90ZXh0KHRleHQudmFsdWUoaXRlbS50ZXh0KSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdnJykge1xuICAgICAgc3RyICs9IG9wZW5UYWcoJ3JlY3QnLFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMobWRlZi5iYWNrZ3JvdW5kLCBpdGVtKSxcbiAgICAgICAgc3R5bGVzKGl0ZW0sIHNjZW5lLCAnYmdyZWN0JywgZGVmcykpICsgY2xvc2VUYWcoJ3JlY3QnKTtcbiAgICAgIHN0ciArPSB0aGlzLm1hcmtHcm91cChpdGVtKTtcbiAgICB9XG4gICAgc3RyICs9IGNsb3NlVGFnKHRhZyk7XG4gIH1cblxuICAvLyByZW5kZXIgY2xvc2luZyBncm91cCB0YWdcbiAgcmV0dXJuIHN0ciArIGNsb3NlVGFnKCdnJyk7XG59O1xuXG5wcm90b3R5cGUubWFya0dyb3VwID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIHN0ciA9ICcnLFxuICAgICAgYXhlcyA9IHNjZW5lLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gc2NlbmUubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBqLCBtO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmxheWVyID09PSAnYmFjaycpIHtcbiAgICAgIHN0ciArPSB0aGlzLm1hcmsoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdHIgKz0gdGhpcy5tYXJrKGl0ZW1zW2pdKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5sYXllciAhPT0gJ2JhY2snKSB7XG4gICAgICBzdHIgKz0gdGhpcy5tYXJrKGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdHIgKz0gdGhpcy5tYXJrKGxlZ2VuZHNbal0pO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbmZ1bmN0aW9uIHN0eWxlcyhvLCBtYXJrLCB0YWcsIGRlZnMpIHtcbiAgaWYgKG8gPT0gbnVsbCkgcmV0dXJuICcnO1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsIHMgPSAnJztcblxuICBpZiAodGFnID09PSAnYmdyZWN0JyAmJiBtYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSkge1xuICAgIHMgKz0gJ3BvaW50ZXItZXZlbnRzOiBub25lOyc7XG4gIH1cblxuICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICBzICs9ICdmb250OiAnICsgdGV4dC5mb250KG8pICsgJzsnO1xuICB9XG5cbiAgZm9yIChpPTAsIG49U1ZHLnN0eWxlUHJvcGVydGllcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IFNWRy5zdHlsZVByb3BlcnRpZXNbaV07XG4gICAgbmFtZSA9IFNWRy5zdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSAnZmlsbCcpIHtcbiAgICAgICAgcyArPSAocy5sZW5ndGggPyAnICcgOiAnJykgKyAnZmlsbDogbm9uZTsnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAndXJsKCMnICsgdmFsdWUuaWQgKyAnKSc7XG4gICAgICB9XG4gICAgICBzICs9IChzLmxlbmd0aCA/ICcgJyA6ICcnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnOyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHMgPyAnc3R5bGU9XCInICsgcyArICdcIicgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVfdGV4dChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTVkdTdHJpbmdSZW5kZXJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9TVkdIYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1NWR1JlbmRlcmVyJyksXG4gIHN0cmluZzoge1xuICAgIFJlbmRlcmVyIDogcmVxdWlyZSgnLi9TVkdTdHJpbmdSZW5kZXJlcicpXG4gIH1cbn07IiwidmFyIHRleHQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RleHQnKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIHRleHRBbGlnbiA9IFNWRy50ZXh0QWxpZ24sXG4gICAgcGF0aCA9IFNWRy5wYXRoO1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVJdGVtKG8pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShvLnggfHwgMCwgby55IHx8IDApO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcmM6IHtcbiAgICB0YWc6ICAncGF0aCcsXG4gICAgdHlwZTogJ2FyYycsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBlbWl0KCdkJywgcGF0aC5hcmMobykpO1xuICAgIH1cbiAgfSxcbiAgYXJlYToge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAnYXJlYScsXG4gICAgbmVzdDogdHJ1ZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXM7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSBlbWl0KCdkJywgcGF0aC5hcmVhKGl0ZW1zKSk7XG4gICAgfVxuICB9LFxuICBncm91cDoge1xuICAgIHRhZzogICdnJyxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8sIHJlbmRlcmVyKSB7XG4gICAgICB2YXIgaWQgPSBudWxsLCBkZWZzLCBjO1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBpZiAoby5jbGlwKSB7XG4gICAgICAgIGRlZnMgPSByZW5kZXJlci5fZGVmcztcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9ICdjbGlwJyArIGRlZnMuY2xpcF9pZCsrKTtcbiAgICAgICAgYyA9IGRlZnMuY2xpcHBpbmdbaWRdIHx8IChkZWZzLmNsaXBwaW5nW2lkXSA9IHtpZDogaWR9KTtcbiAgICAgICAgYy53aWR0aCA9IG8ud2lkdGggfHwgMDtcbiAgICAgICAgYy5oZWlnaHQgPSBvLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgICAgZW1pdCgnY2xpcC1wYXRoJywgaWQgPyAoJ3VybCgjJyArIGlkICsgJyknKSA6IG51bGwpO1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgnY2xhc3MnLCAnYmFja2dyb3VuZCcpO1xuICAgICAgZW1pdCgnd2lkdGgnLCBvLndpZHRoIHx8IDApO1xuICAgICAgZW1pdCgnaGVpZ2h0Jywgby5oZWlnaHQgfHwgMCk7XG4gICAgfVxuICB9LFxuICBpbWFnZToge1xuICAgIHRhZzogICdpbWFnZScsXG4gICAgdHlwZTogJ2ltYWdlJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvLCByZW5kZXJlcikge1xuICAgICAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgICAgICB5ID0gby55IHx8IDAsXG4gICAgICAgICAgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgICAgICBoID0gby5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB1cmwgPSByZW5kZXJlci5pbWFnZVVSTChvLnVybCk7XG5cbiAgICAgIHggPSB4IC0gKG8uYWxpZ24gPT09ICdjZW50ZXInID8gdy8yIDogby5hbGlnbiA9PT0gJ3JpZ2h0JyA/IHcgOiAwKTtcbiAgICAgIHkgPSB5IC0gKG8uYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gaC8yIDogby5iYXNlbGluZSA9PT0gJ2JvdHRvbScgPyBoIDogMCk7XG5cbiAgICAgIGVtaXQoJ2hyZWYnLCB1cmwsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ3hsaW5rOmhyZWYnKTtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSh4LCB5KSk7XG4gICAgICBlbWl0KCd3aWR0aCcsIHcpO1xuICAgICAgZW1pdCgnaGVpZ2h0JywgaCk7XG4gICAgfVxuICB9LFxuICBsaW5lOiB7XG4gICAgdGFnOiAgJ3BhdGgnLFxuICAgIHR5cGU6ICdsaW5lJyxcbiAgICBuZXN0OiB0cnVlLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcztcbiAgICAgIGlmIChpdGVtcy5sZW5ndGgpIGVtaXQoJ2QnLCBwYXRoLmxpbmUoaXRlbXMpKTtcbiAgICB9XG4gIH0sXG4gIHBhdGg6IHtcbiAgICB0YWc6ICAncGF0aCcsXG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0obykpO1xuICAgICAgZW1pdCgnZCcsIG8ucGF0aCk7XG4gICAgfVxuICB9LFxuICByZWN0OiB7XG4gICAgdGFnOiAgJ3JlY3QnLFxuICAgIHR5cGU6ICdyZWN0JyxcbiAgICBuZXN0OiBmYWxzZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ3dpZHRoJywgby53aWR0aCB8fCAwKTtcbiAgICAgIGVtaXQoJ2hlaWdodCcsIG8uaGVpZ2h0IHx8IDApO1xuICAgIH1cbiAgfSxcbiAgcnVsZToge1xuICAgIHRhZzogICdsaW5lJyxcbiAgICB0eXBlOiAncnVsZScsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBlbWl0KCd4MicsIG8ueDIgIT0gbnVsbCA/IG8ueDIgLSAoby54fHwwKSA6IDApO1xuICAgICAgZW1pdCgneTInLCBvLnkyICE9IG51bGwgPyBvLnkyIC0gKG8ueXx8MCkgOiAwKTtcbiAgICB9XG4gIH0sXG4gIHN5bWJvbDoge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAnc3ltYm9sJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ2QnLCBwYXRoLnN5bWJvbChvKSk7XG4gICAgfVxuICB9LFxuICB0ZXh0OiB7XG4gICAgdGFnOiAgJ3RleHQnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBuZXN0OiBmYWxzZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICB2YXIgZHggPSAoby5keCB8fCAwKSxcbiAgICAgICAgICBkeSA9IChvLmR5IHx8IDApICsgdGV4dC5vZmZzZXQobyksXG4gICAgICAgICAgeCA9IChvLnggfHwgMCksXG4gICAgICAgICAgeSA9IChvLnkgfHwgMCksXG4gICAgICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgICAgICByID0gby5yYWRpdXMgfHwgMCwgdDtcblxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgICAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgICB9XG5cbiAgICAgIGVtaXQoJ3RleHQtYW5jaG9yJywgdGV4dEFsaWduW28uYWxpZ25dIHx8ICdzdGFydCcpO1xuICAgICAgXG4gICAgICBpZiAoYSkge1xuICAgICAgICB0ID0gdHJhbnNsYXRlKHgsIHkpICsgJyByb3RhdGUoJythKycpJztcbiAgICAgICAgaWYgKGR4IHx8IGR5KSB0ICs9ICcgJyArIHRyYW5zbGF0ZShkeCwgZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHRyYW5zbGF0ZSh4K2R4LCB5K2R5KTtcbiAgICAgIH1cbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHQpO1xuICAgIH1cbiAgfVxufTtcbiIsImZ1bmN0aW9uIEJvdW5kcyhiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59XG5cbnZhciBwcm90b3R5cGUgPSBCb3VuZHMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZHModGhpcyk7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnkxID0gK051bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbiAgdGhpcy54MiA9IHgyO1xuICB0aGlzLnkyID0geTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcbiAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgaWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcbiAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZCkge1xuICB0aGlzLngxIC09IGQ7XG4gIHRoaXMueTEgLT0gZDtcbiAgdGhpcy54MiArPSBkO1xuICB0aGlzLnkyICs9IGQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSBNYXRoLmZsb29yKHRoaXMueDEpO1xuICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgdGhpcy54MiA9IE1hdGguY2VpbCh0aGlzLngyKTtcbiAgdGhpcy55MiA9IE1hdGguY2VpbCh0aGlzLnkyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gIHRoaXMueDEgKz0gZHg7XG4gIHRoaXMueDIgKz0gZHg7XG4gIHRoaXMueTEgKz0gZHk7XG4gIHRoaXMueTIgKz0gZHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5KSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICBjeCA9IHggLSB4KmNvcyArIHkqc2luLFxuICAgICAgY3kgPSB5IC0geCpzaW4gLSB5KmNvcyxcbiAgICAgIHgxID0gdGhpcy54MSwgeDIgPSB0aGlzLngyLFxuICAgICAgeTEgPSB0aGlzLnkxLCB5MiA9IHRoaXMueTI7XG5cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIC5hZGQoY29zKngxIC0gc2luKnkxICsgY3gsICBzaW4qeDEgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MiArIGN4LCAgc2luKngxICsgY29zKnkyICsgY3kpXG4gICAgLmFkZChjb3MqeDIgLSBzaW4qeTEgKyBjeCwgIHNpbip4MiArIGNvcyp5MSArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkyICsgY3gsICBzaW4qeDIgKyBjb3MqeTIgKyBjeSk7XG59O1xuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgIShcbiAgICB0aGlzLngyIDwgYi54MSB8fFxuICAgIHRoaXMueDEgPiBiLngyIHx8XG4gICAgdGhpcy55MiA8IGIueTEgfHxcbiAgICB0aGlzLnkxID4gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gIShcbiAgICB4IDwgdGhpcy54MSB8fFxuICAgIHggPiB0aGlzLngyIHx8XG4gICAgeSA8IHRoaXMueTEgfHxcbiAgICB5ID4gdGhpcy55MlxuICApO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICBmdW5jdGlvbiBhZGQoeCx5KSB7IGIuYWRkKHgsIHkpOyB9XG5cbiAgcmV0dXJuIHtcbiAgICBib3VuZHM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGI7XG4gICAgICByZXR1cm4gKGIgPSBfLCB0aGlzKTtcbiAgICB9LFxuICAgIGJlZ2luUGF0aDogbm9vcCxcbiAgICBjbG9zZVBhdGg6IG5vb3AsXG4gICAgbW92ZVRvOiBhZGQsXG4gICAgbGluZVRvOiBhZGQsXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGIuYWRkKHgxLCB5MSk7XG4gICAgICBiLmFkZCh4MiwgeTIpO1xuICAgIH0sXG4gICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgYi5hZGQoeDEsIHkxKTtcbiAgICAgIGIuYWRkKHgyLCB5Mik7XG4gICAgICBiLmFkZCh4MywgeTMpO1xuICAgIH1cbiAgfTtcbn07XG4iLCJ2YXIgZ3JhZGllbnRfaWQgPSAwO1xuXG5mdW5jdGlvbiBHcmFkaWVudCh0eXBlKSB7XG4gIHRoaXMuaWQgPSAnZ3JhZGllbnRfJyArIChncmFkaWVudF9pZCsrKTtcbiAgdGhpcy50eXBlID0gdHlwZSB8fCAnbGluZWFyJztcbiAgdGhpcy5zdG9wcyA9IFtdO1xuICB0aGlzLngxID0gMDtcbiAgdGhpcy54MiA9IDE7XG4gIHRoaXMueTEgPSAwO1xuICB0aGlzLnkyID0gMDtcbn1cblxudmFyIHByb3RvdHlwZSA9IEdyYWRpZW50LnByb3RvdHlwZTtcblxucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbihvZmZzZXQsIGNvbG9yKSB7XG4gIHRoaXMuc3RvcHMucHVzaCh7XG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgY29sb3I6IGNvbG9yXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7IiwidmFyIGxvYWQgPSByZXF1aXJlKCdkYXRhbGliL3NyYy9pbXBvcnQvbG9hZCcpO1xuXG5mdW5jdGlvbiBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKSB7XG4gIHRoaXMuX3BlbmRpbmcgPSAwO1xuICB0aGlzLl9jb25maWcgPSBsb2FkQ29uZmlnIHx8IEltYWdlTG9hZGVyLkNvbmZpZzsgXG59XG5cbi8vIE92ZXJyaWRhYmxlIGdsb2JhbCBkZWZhdWx0IGxvYWQgY29uZmlndXJhdGlvblxuSW1hZ2VMb2FkZXIuQ29uZmlnID0gbnVsbDtcblxudmFyIHByb3RvdHlwZSA9IEltYWdlTG9hZGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLnBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BlbmRpbmc7XG59O1xuXG5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciBwID0ge3VybDogdXJpfSwgaztcbiAgZm9yIChrIGluIHRoaXMuX2NvbmZpZykgeyBwW2tdID0gdGhpcy5fY29uZmlnW2tdOyB9XG4gIHJldHVybiBwO1xufTtcblxucHJvdG90eXBlLmltYWdlVVJMID0gZnVuY3Rpb24odXJpKSB7XG4gIHJldHVybiBsb2FkLnNhbml0aXplVXJsKHRoaXMucGFyYW1zKHVyaSkpO1xufTtcblxuZnVuY3Rpb24gYnJvd3Nlcih1cmksIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBsb2FkLnNhbml0aXplVXJsKHRoaXMucGFyYW1zKHVyaSkpO1xuICBpZiAoIXVybCkgeyAvLyBlcnJvclxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sodXJpLCBudWxsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsb2FkZXIgPSB0aGlzLFxuICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICBsb2FkZXIuX3BlbmRpbmcgKz0gMTtcblxuICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBsb2FkZXIuX3BlbmRpbmcgLT0gMTtcbiAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgaW1hZ2UpO1xuICB9O1xuICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXIodXJpLCBjYWxsYmFjaykge1xuICB2YXIgbG9hZGVyID0gdGhpcyxcbiAgICAgIGltYWdlID0gbmV3ICgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snY2FudmFzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydjYW52YXMnXSA6IG51bGwpLkltYWdlKSgpO1xuXG4gIGxvYWRlci5fcGVuZGluZyArPSAxO1xuXG4gIGxvYWQodGhpcy5wYXJhbXModXJpKSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgbG9hZGVyLl9wZW5kaW5nIC09IDE7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGRhdGE7XG4gICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIGltYWdlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJpLCBjYWxsYmFjaykge1xuICByZXR1cm4gbG9hZC51c2VYSFIgP1xuICAgIGJyb3dzZXIuY2FsbCh0aGlzLCB1cmksIGNhbGxiYWNrKSA6XG4gICAgc2VydmVyLmNhbGwodGhpcywgdXJpLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlTG9hZGVyO1xuIiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkge1xuICAgIGlmIChpPT09bGlzdC5sZW5ndGgtMSkge1xuICAgICAgbGlzdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhdGhDYWNoZSkgdGhpcy5wYXRoQ2FjaGUgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtOyIsInZhciBCb3VuZHNDb250ZXh0ID0gcmVxdWlyZSgnLi9Cb3VuZHNDb250ZXh0JyksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi9Cb3VuZHMnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuL2NhbnZhcycpLFxuICAgIHN2ZyA9IHJlcXVpcmUoJy4vc3ZnJyksXG4gICAgdGV4dCA9IHJlcXVpcmUoJy4vdGV4dCcpLFxuICAgIHBhdGhzID0gcmVxdWlyZSgnLi4vcGF0aCcpLFxuICAgIHBhcnNlID0gcGF0aHMucGFyc2UsXG4gICAgZHJhd1BhdGggPSBwYXRocy5yZW5kZXIsXG4gICAgYXJlYVBhdGggPSBzdmcucGF0aC5hcmVhLFxuICAgIGxpbmVQYXRoID0gc3ZnLnBhdGgubGluZSxcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgZzJEID0gbnVsbCxcbiAgICBiYyA9IEJvdW5kc0NvbnRleHQoKTtcblxuZnVuY3Rpb24gY29udGV4dCgpIHtcbiAgcmV0dXJuIGcyRCB8fCAoZzJEID0gY2FudmFzLmluc3RhbmNlKDEsMSkuZ2V0Q29udGV4dCgnMmQnKSk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMpIHtcbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0b2tlT3BhY2l0eSAhPT0gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCAhPSBudWxsID8gby5zdHJva2VXaWR0aCA6IDEpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHBhdGhCb3VuZHMobywgcGF0aCwgYm91bmRzLCB4LCB5KSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGRyYXdQYXRoKGJjLmJvdW5kcyhib3VuZHMpLCBwYXRoLCB4LCB5KTtcbiAgICBzdHJva2VCb3VuZHMobywgYm91bmRzKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBwYXRoKG8sIGJvdW5kcykge1xuICB2YXIgcCA9IG8ucGF0aCA/IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKG8ucGF0aCkpIDogbnVsbDtcbiAgcmV0dXJuIHBhdGhCb3VuZHMobywgcCwgYm91bmRzLCBvLngsIG8ueSk7XG59XG5cbmZ1bmN0aW9uIGFyZWEobWFyaywgYm91bmRzKSB7XG4gIGlmIChtYXJrLml0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJvdW5kcztcbiAgdmFyIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGl0ZW0gPSBpdGVtc1swXSxcbiAgICAgIHAgPSBpdGVtLnBhdGhDYWNoZSB8fCAoaXRlbS5wYXRoQ2FjaGUgPSBwYXJzZShhcmVhUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbSwgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gbGluZShtYXJrLCBib3VuZHMpIHtcbiAgaWYgKG1hcmsuaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gYm91bmRzO1xuICB2YXIgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaXRlbSA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IGl0ZW0ucGF0aENhY2hlIHx8IChpdGVtLnBhdGhDYWNoZSA9IHBhcnNlKGxpbmVQYXRoKGl0ZW1zKSkpO1xuICByZXR1cm4gcGF0aEJvdW5kcyhpdGVtLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiByZWN0KG8sIGJvdW5kcykge1xuICB2YXIgeCwgeTtcbiAgcmV0dXJuIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMuc2V0KFxuICAgIHggPSBvLnggfHwgMCxcbiAgICB5ID0gby55IHx8IDAsXG4gICAgKHggKyBvLndpZHRoKSB8fCAwLFxuICAgICh5ICsgby5oZWlnaHQpIHx8IDBcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8sIGJvdW5kcykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwO1xuICB4ID0geCAtIChvLmFsaWduID09PSAnY2VudGVyJyA/IHcvMiA6IChvLmFsaWduID09PSAncmlnaHQnID8gdyA6IDApKTtcbiAgeSA9IHkgLSAoby5iYXNlbGluZSA9PT0gJ21pZGRsZScgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gJ2JvdHRvbScgPyBoIDogMCkpO1xuICByZXR1cm4gYm91bmRzLnNldCh4LCB5LCB4K3csIHkraCk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobywgYm91bmRzKSB7XG4gIHZhciB4MSwgeTE7XG4gIHJldHVybiBzdHJva2VCb3VuZHMobywgYm91bmRzLnNldChcbiAgICB4MSA9IG8ueCB8fCAwLFxuICAgIHkxID0gby55IHx8IDAsXG4gICAgby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgIG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MVxuICApKTtcbn1cblxuZnVuY3Rpb24gYXJjKG8sIGJvdW5kcykge1xuICB2YXIgY3ggPSBvLnggfHwgMCxcbiAgICAgIGN5ID0gby55IHx8IDAsXG4gICAgICBpciA9IG8uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gby5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgc2EgPSAoby5zdGFydEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgZWEgPSAoby5lbmRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIHhtaW4gPSBJbmZpbml0eSwgeG1heCA9IC1JbmZpbml0eSxcbiAgICAgIHltaW4gPSBJbmZpbml0eSwgeW1heCA9IC1JbmZpbml0eSxcbiAgICAgIGEsIGksIG4sIHgsIHksIGl4LCBpeSwgb3gsIG95O1xuXG4gIHZhciBhbmdsZXMgPSBbc2EsIGVhXSxcbiAgICAgIHMgPSBzYSAtIChzYSAlIGhhbGZwaSk7XG4gIGZvciAoaT0wOyBpPDQgJiYgczxlYTsgKytpLCBzKz1oYWxmcGkpIHtcbiAgICBhbmdsZXMucHVzaChzKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPWFuZ2xlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgYSA9IGFuZ2xlc1tpXTtcbiAgICB4ID0gTWF0aC5jb3MoYSk7IGl4ID0gaXIqeDsgb3ggPSBvcip4O1xuICAgIHkgPSBNYXRoLnNpbihhKTsgaXkgPSBpcip5OyBveSA9IG9yKnk7XG4gICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIGl4LCBveCk7XG4gICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIGl4LCBveCk7XG4gICAgeW1pbiA9IE1hdGgubWluKHltaW4sIGl5LCBveSk7XG4gICAgeW1heCA9IE1hdGgubWF4KHltYXgsIGl5LCBveSk7XG4gIH1cblxuICByZXR1cm4gc3Ryb2tlQm91bmRzKG8sIGJvdW5kcy5zZXQoXG4gICAgY3ggKyB4bWluLFxuICAgIGN5ICsgeW1pbixcbiAgICBjeCArIHhtYXgsXG4gICAgY3kgKyB5bWF4XG4gICkpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobywgYm91bmRzKSB7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICByLCB0LCByeCwgcnk7XG5cbiAgc3dpdGNoIChvLnNoYXBlKSB7XG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgdCA9IDMgKiBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC10LCB5LXQsIHgrdCwgeSt0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGlhbW9uZCc6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLWRvd24nOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0cmlhbmdsZS11cCc6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gIH1cblxuICByZXR1cm4gc3Ryb2tlQm91bmRzKG8sIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIHRleHRNYXJrKG8sIGJvdW5kcywgbm9Sb3RhdGUpIHtcbiAgdmFyIGcgPSBjb250ZXh0KCksXG4gICAgICBoID0gdGV4dC5zaXplKG8pLFxuICAgICAgYSA9IG8uYWxpZ24sXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIHggPSAoby54IHx8IDApLFxuICAgICAgeSA9IChvLnkgfHwgMCksXG4gICAgICBkeCA9IChvLmR4IHx8IDApLFxuICAgICAgZHkgPSAoby5keSB8fCAwKSArIHRleHQub2Zmc2V0KG8pIC0gTWF0aC5yb3VuZCgwLjgqaCksIC8vIHVzZSA0LzUgb2Zmc2V0XG4gICAgICB3LCB0O1xuXG4gIGlmIChyKSB7XG4gICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgLy8gaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgZy5mb250ID0gdGV4dC5mb250KG8pO1xuICB3ID0gZy5tZWFzdXJlVGV4dCh0ZXh0LnZhbHVlKG8udGV4dCkpLndpZHRoO1xuICBpZiAoYSA9PT0gJ2NlbnRlcicpIHtcbiAgICBkeCAtPSAodyAvIDIpO1xuICB9IGVsc2UgaWYgKGEgPT09ICdyaWdodCcpIHtcbiAgICBkeCAtPSB3O1xuICB9IGVsc2Uge1xuICAgIC8vIGxlZnQgYnkgZGVmYXVsdCwgZG8gbm90aGluZ1xuICB9XG5cbiAgYm91bmRzLnNldChkeCs9eCwgZHkrPXksIGR4K3csIGR5K2gpO1xuICBpZiAoby5hbmdsZSAmJiAhbm9Sb3RhdGUpIHtcbiAgICBib3VuZHMucm90YXRlKG8uYW5nbGUqTWF0aC5QSS8xODAsIHgsIHkpO1xuICB9XG4gIHJldHVybiBib3VuZHMuZXhwYW5kKG5vUm90YXRlID8gMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBncm91cChnLCBib3VuZHMsIGluY2x1ZGVMZWdlbmRzKSB7XG4gIHZhciBheGVzID0gZy5heGlzSXRlbXMgfHwgW10sXG4gICAgICBpdGVtcyA9IGcuaXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gZy5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgIGosIG07XG5cbiAgaWYgKCFnLmNsaXApIHtcbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGJvdW5kcy51bmlvbihheGVzW2pdLmJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtc1tqXS5ib3VuZHMpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZUxlZ2VuZHMpIHtcbiAgICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgICBib3VuZHMudW5pb24obGVnZW5kc1tqXS5ib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZy5jbGlwIHx8IGcud2lkdGggfHwgZy5oZWlnaHQpIHtcbiAgICBzdHJva2VCb3VuZHMoZywgYm91bmRzXG4gICAgICAuYWRkKDAsIDApXG4gICAgICAuYWRkKGcud2lkdGggfHwgMCwgZy5oZWlnaHQgfHwgMCkpO1xuICB9XG4gIHJldHVybiBib3VuZHMudHJhbnNsYXRlKGcueCB8fCAwLCBnLnkgfHwgMCk7XG59XG5cbnZhciBtZXRob2RzID0ge1xuICBncm91cDogIGdyb3VwLFxuICBzeW1ib2w6IHN5bWJvbCxcbiAgaW1hZ2U6ICBpbWFnZSxcbiAgcmVjdDogICByZWN0LFxuICBydWxlOiAgIHJ1bGUsXG4gIGFyYzogICAgYXJjLFxuICB0ZXh0OiAgIHRleHRNYXJrLFxuICBwYXRoOiAgIHBhdGgsXG4gIGFyZWE6ICAgYXJlYSxcbiAgbGluZTogICBsaW5lXG59O1xubWV0aG9kcy5hcmVhLm5lc3QgPSB0cnVlO1xubWV0aG9kcy5saW5lLm5lc3QgPSB0cnVlO1xuXG5mdW5jdGlvbiBpdGVtQm91bmRzKGl0ZW0sIGZ1bmMsIG9wdCkge1xuICB2YXIgdHlwZSA9IGl0ZW0ubWFyay5tYXJrdHlwZTtcbiAgZnVuYyA9IGZ1bmMgfHwgbWV0aG9kc1t0eXBlXTtcbiAgaWYgKGZ1bmMubmVzdCkgaXRlbSA9IGl0ZW0ubWFyaztcblxuICB2YXIgY3VyciA9IGl0ZW0uYm91bmRzLFxuICAgICAgcHJldiA9IGl0ZW1bJ2JvdW5kczpwcmV2J10gfHwgKGl0ZW1bJ2JvdW5kczpwcmV2J10gPSBuZXcgQm91bmRzKCkpO1xuXG4gIGlmIChjdXJyKSB7XG4gICAgcHJldi5jbGVhcigpLnVuaW9uKGN1cnIpO1xuICAgIGN1cnIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtLmJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgfVxuICBmdW5jKGl0ZW0sIGl0ZW0uYm91bmRzLCBvcHQpO1xuICBpZiAoIWN1cnIpIHByZXYuY2xlYXIoKS51bmlvbihpdGVtLmJvdW5kcyk7XG4gIHJldHVybiBpdGVtLmJvdW5kcztcbn1cblxudmFyIERVTU1ZX0lURU0gPSB7bWFyazogbnVsbH07XG5cbmZ1bmN0aW9uIG1hcmtCb3VuZHMobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgdmFyIHR5cGUgID0gbWFyay5tYXJrdHlwZSxcbiAgICAgIGZ1bmMgID0gbWV0aG9kc1t0eXBlXSxcbiAgICAgIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGhhc2kgID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuICAgICAgaSwgbiwgbywgYjtcblxuICBpZiAoZnVuYy5uZXN0KSB7XG4gICAgbyA9IGhhc2kgPyBpdGVtc1swXVxuICAgICAgOiAoRFVNTVlfSVRFTS5tYXJrID0gbWFyaywgRFVNTVlfSVRFTSk7IC8vIG5vIGl0ZW1zLCBzbyBmYWtlIGl0XG4gICAgYiA9IGl0ZW1Cb3VuZHMobywgZnVuYywgb3B0KTtcbiAgICBib3VuZHMgPSBib3VuZHMgJiYgYm91bmRzLnVuaW9uKGIpIHx8IGI7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGJvdW5kcyA9IGJvdW5kcyB8fCBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jbGVhcigpIHx8IG5ldyBCb3VuZHMoKTtcbiAgaWYgKGhhc2kpIHsgIFxuICAgIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtQm91bmRzKGl0ZW1zW2ldLCBmdW5jLCBvcHQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChtYXJrLmJvdW5kcyA9IGJvdW5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXJrOiAgbWFya0JvdW5kcyxcbiAgaXRlbTogIGl0ZW1Cb3VuZHMsXG4gIHRleHQ6ICB0ZXh0TWFyayxcbiAgZ3JvdXA6IGdyb3VwXG59O1xuIiwiZnVuY3Rpb24gaW5zdGFuY2UodywgaCkge1xuICB3ID0gdyB8fCAxO1xuICBoID0gaCB8fCAxO1xuICB2YXIgY2FudmFzO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB9IGVsc2Uge1xuICAgIHZhciBDYW52YXMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snY2FudmFzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydjYW52YXMnXSA6IG51bGwpO1xuICAgIGlmICghQ2FudmFzLnByb3RvdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgY2FudmFzID0gbmV3IENhbnZhcyh3LCBoKTtcbiAgfVxuICByZXR1cm4gbGluZURhc2goY2FudmFzKTtcbn1cblxuZnVuY3Rpb24gcmVzaXplKGNhbnZhcywgdywgaCwgcCwgcmV0aW5hKSB7XG4gIHZhciBnID0gdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksIFxuICAgICAgcyA9IDE7XG5cbiAgY2FudmFzLndpZHRoID0gdyArIHAubGVmdCArIHAucmlnaHQ7XG4gIGNhbnZhcy5oZWlnaHQgPSBoICsgcC50b3AgKyBwLmJvdHRvbTtcblxuICAvLyBpZiBicm93c2VyIGNhbnZhcywgYXR0ZW1wdCB0byBtb2RpZnkgZm9yIHJldGluYSBkaXNwbGF5XG4gIGlmIChyZXRpbmEgJiYgdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgY2FudmFzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXG4gIHtcbiAgICBnLnBpeGVscmF0aW8gPSAocyA9IHBpeGVsUmF0aW8oY2FudmFzKSB8fCAxKTtcbiAgfVxuXG4gIGcuc2V0VHJhbnNmb3JtKHMsIDAsIDAsIHMsIHMqcC5sZWZ0LCBzKnAudG9wKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gcGl4ZWxSYXRpbyhjYW52YXMpIHtcbiAgdmFyIGcgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBnZXQgY2FudmFzIHBpeGVsIGRhdGFcbiAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gKFxuICAgICAgICBnLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgZy5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGcubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGcub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgZy5iYWNraW5nU3RvcmVQaXhlbFJhdGlvKSB8fCAxLFxuICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cbiAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IGJhY2tpbmdTdG9yZVJhdGlvKSB7XG4gICAgLy8gc2V0IGFjdHVhbCBhbmQgdmlzaWJsZSBjYW52YXMgc2l6ZVxuICAgIHZhciB3ID0gY2FudmFzLndpZHRoLFxuICAgICAgICBoID0gY2FudmFzLmhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSB3ICogcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGggKiByYXRpbztcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gIH1cblxuICByZXR1cm4gcmF0aW87XG59XG5cbmZ1bmN0aW9uIGxpbmVEYXNoKGNhbnZhcykge1xuICB2YXIgZyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoZy52Z0xpbmVEYXNoKSByZXR1cm47IC8vIGFscmVhZHkgaW5pdGlhbGl6ZWQhXG5cbiAgdmFyIE5PT1AgPSBmdW5jdGlvbigpIHt9LFxuICAgICAgTk9EQVNIID0gW107XG4gIFxuICBpZiAoZy5zZXRMaW5lRGFzaCkge1xuICAgIGcudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5zZXRMaW5lRGFzaChkYXNoIHx8IE5PREFTSCk7IH07XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24ob2ZmKSB7IHRoaXMubGluZURhc2hPZmZzZXQgPSBvZmY7IH07XG4gIH0gZWxzZSBpZiAoZy53ZWJraXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0Zy52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLndlYmtpdExpbmVEYXNoID0gZGFzaCB8fCBOT0RBU0g7IH07XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24ob2ZmKSB7IHRoaXMud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmY7IH07XG4gIH0gZWxzZSBpZiAoZy5tb3pEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBnLnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMubW96RGFzaCA9IGRhc2g7IH07XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0ID0gTk9PUDtcbiAgfSBlbHNlIHtcbiAgICBnLnZnTGluZURhc2ggPSBOT09QO1xuICAgIGcudmdMaW5lRGFzaE9mZnNldCA9IE5PT1A7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc3RhbmNlOiAgIGluc3RhbmNlLFxuICByZXNpemU6ICAgICByZXNpemUsXG4gIGxpbmVEYXNoOiAgIGxpbmVEYXNoXG59O1xuIiwiLy8gY3JlYXRlIGEgbmV3IERPTSBlbGVtZW50XG5mdW5jdGlvbiBjcmVhdGUoZG9jLCB0YWcsIG5zKSB7XG4gIHJldHVybiBucyA/IGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xufVxuXG4vLyByZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuLy8gcmVjdXJzaXZlbHkgcmVtb3ZlIHBhcmVudCBlbGVtZW50cyBpZiBlbXB0eVxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgdmFyIHAgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAocCkge1xuICAgIHAucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIGlmICghcC5jaGlsZE5vZGVzIHx8ICFwLmNoaWxkTm9kZXMubGVuZ3RoKSByZW1vdmUocCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpbmQgZmlyc3QgY2hpbGQgZWxlbWVudCB3aXRoIG1hdGNoaW5nIHRhZ1xuICBmaW5kOiBmdW5jdGlvbihlbCwgdGFnKSB7XG4gICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yICh2YXIgaT0wLCBuPWVsLmNoaWxkTm9kZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKGVsLmNoaWxkTm9kZXNbaV0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNoaWxkTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyByZXRyaWV2ZSBjaGlsZCBlbGVtZW50IGF0IGdpdmVuIGluZGV4XG4gIC8vIGNyZWF0ZSAmIGluc2VydCBpZiBkb2Vzbid0IGV4aXN0IG9yIGlmIHRhZy9jbGFzc05hbWUgZG8gbm90IG1hdGNoXG4gIGNoaWxkOiBmdW5jdGlvbihlbCwgaW5kZXgsIHRhZywgbnMsIGNsYXNzTmFtZSwgaW5zZXJ0KSB7XG4gICAgdmFyIGEsIGI7XG4gICAgYSA9IGIgPSBlbC5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICBpZiAoIWEgfHwgaW5zZXJ0IHx8XG4gICAgICAgIGEudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0YWcudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICBjbGFzc05hbWUgJiYgYS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgIT0gY2xhc3NOYW1lKSB7XG4gICAgICBhID0gY3JlYXRlKGVsLm93bmVyRG9jdW1lbnQsIHRhZywgbnMpO1xuICAgICAgZWwuaW5zZXJ0QmVmb3JlKGEsIGIpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkgYS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIC8vIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgYXQgb3IgYWJvdmUgdGhlIGdpdmVuIGluZGV4XG4gIGNsZWFyOiBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgICB2YXIgY3VyciA9IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHdoaWxlIChjdXJyID4gaW5kZXgpIHtcbiAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmNoaWxkTm9kZXNbLS1jdXJyXSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIC8vIGdlbmVyYXRlIGNzcyBjbGFzcyBuYW1lIGZvciBtYXJrXG4gIGNzc0NsYXNzOiBmdW5jdGlvbihtYXJrKSB7XG4gICAgcmV0dXJuICdtYXJrLScgKyBtYXJrLm1hcmt0eXBlICsgKG1hcmsubmFtZSA/ICcgJyttYXJrLm5hbWUgOiAnJyk7XG4gIH0sXG4gIC8vIGdlbmVyYXRlIHN0cmluZyBmb3IgYW4gb3BlbmluZyB4bWwgdGFnXG4gIC8vIHRhZzogdGhlIG5hbWUgb2YgdGhlIHhtbCB0YWdcbiAgLy8gYXR0cjogaGFzaCBvZiBhdHRyaWJ1dGUgbmFtZS12YWx1ZSBwYWlycyB0byBpbmNsdWRlXG4gIC8vIHJhdzogYWRkaXRpb25hbCByYXcgc3RyaW5nIHRvIGluY2x1ZGUgaW4gdGFnIG1hcmt1cFxuICBvcGVuVGFnOiBmdW5jdGlvbih0YWcsIGF0dHIsIHJhdykge1xuICAgIHZhciBzID0gJzwnICsgdGFnLCBrZXksIHZhbDtcbiAgICBpZiAoYXR0cikge1xuICAgICAgZm9yIChrZXkgaW4gYXR0cikge1xuICAgICAgICB2YWwgPSBhdHRyW2tleV07XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgIHMgKz0gJyAnICsga2V5ICsgJz1cIicgKyB2YWwgKyAnXCInO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyYXcpIHMgKz0gJyAnICsgcmF3O1xuICAgIHJldHVybiBzICsgJz4nO1xuICB9LFxuICAvLyBnZW5lcmF0ZSBzdHJpbmcgZm9yIGNsb3NpbmcgeG1sIHRhZ1xuICAvLyB0YWc6IHRoZSBuYW1lIG9mIHRoZSB4bWwgdGFnXG4gIGNsb3NlVGFnOiBmdW5jdGlvbih0YWcpIHtcbiAgICByZXR1cm4gJzwvJyArIHRhZyArICc+JztcbiAgfVxufTtcbiIsInZhciBib3VuZCA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmQnKTtcblxudmFyIHNldHMgPSBbXG4gICdpdGVtcycsXG4gICdheGlzSXRlbXMnLFxuICAnbGVnZW5kSXRlbXMnXG5dO1xuXG52YXIga2V5cyA9IFtcbiAgJ21hcmt0eXBlJywgJ25hbWUnLCAnaW50ZXJhY3RpdmUnLCAnY2xpcCcsXG4gICdpdGVtcycsICdheGlzSXRlbXMnLCAnbGVnZW5kSXRlbXMnLCAnbGF5ZXInLFxuICAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdhbGlnbicsICdiYXNlbGluZScsICAgICAgICAgICAgIC8vIGxheW91dFxuICAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdvcGFjaXR5JywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbGxcbiAgJ3N0cm9rZScsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZUNhcCcsICAgICAgICAvLyBzdHJva2VcbiAgJ3N0cm9rZURhc2gnLCAnc3Ryb2tlRGFzaE9mZnNldCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJva2UgZGFzaFxuICAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICAgICAgIC8vIGFyY1xuICAnaW50ZXJwb2xhdGUnLCAndGVuc2lvbicsICdvcmllbnQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZWEsIGxpbmVcbiAgJ3VybCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZVxuICAncGF0aCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhdGhcbiAgJ3gyJywgJ3kyJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydWxlXG4gICdzaXplJywgJ3NoYXBlJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICd0ZXh0JywgJ2FuZ2xlJywgJ3RoZXRhJywgJ3JhZGl1cycsICdkeCcsICdkeScsICAgICAgICAgICAgICAgLy8gdGV4dFxuICAnZm9udCcsICdmb250U2l6ZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTdHlsZScsICdmb250VmFyaWFudCcgIC8vIGZvbnRcbl07XG5cbmZ1bmN0aW9uIHRvSlNPTihzY2VuZSwgaW5kZW50KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzY2VuZSwga2V5cywgaW5kZW50KTtcbn1cblxuZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICB2YXIgc2NlbmUgPSAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24pO1xuICByZXR1cm4gaW5pdGlhbGl6ZShzY2VuZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoc2NlbmUpIHtcbiAgdmFyIHR5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIGksIG4sIHMsIG0sIGl0ZW1zO1xuXG4gIGZvciAocz0wLCBtPXNldHMubGVuZ3RoOyBzPG07ICsrcykge1xuICAgIGlmICgoaXRlbXMgPSBzY2VuZVtzZXRzW3NdXSkpIHtcbiAgICAgIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgICAgaXRlbXNbaV1bdHlwZSA/ICdtYXJrJyA6ICdncm91cCddID0gc2NlbmU7XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZShpdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSkgYm91bmQubWFyayhzY2VuZSk7XG4gIHJldHVybiBzY2VuZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvSlNPTjogICB0b0pTT04sXG4gIGZyb21KU09OOiBmcm9tSlNPTlxufTsiLCJ2YXIgZDNfc3ZnID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCkuc3ZnO1xuXG5mdW5jdGlvbiB4KG8pICAgICB7IHJldHVybiBvLnggfHwgMDsgfVxuZnVuY3Rpb24geShvKSAgICAgeyByZXR1cm4gby55IHx8IDA7IH1cbmZ1bmN0aW9uIHh3KG8pICAgIHsgcmV0dXJuIChvLnggfHwgMCkgKyAoby53aWR0aCB8fCAwKTsgfVxuZnVuY3Rpb24geWgobykgICAgeyByZXR1cm4gKG8ueSB8fCAwKSArIChvLmhlaWdodCB8fCAwKTsgfVxuZnVuY3Rpb24gc2l6ZShvKSAgeyByZXR1cm4gby5zaXplID09IG51bGwgPyAxMDAgOiBvLnNpemU7IH1cbmZ1bmN0aW9uIHNoYXBlKG8pIHsgcmV0dXJuIG8uc2hhcGUgfHwgJ2NpcmNsZSc7IH1cblxudmFyIGFyZWF2ID0gZDNfc3ZnLmFyZWEoKS54KHgpLnkxKHkpLnkwKHloKSxcbiAgICBhcmVhaCA9IGQzX3N2Zy5hcmVhKCkueSh5KS54MSh4KS54MCh4dyksXG4gICAgbGluZSAgPSBkM19zdmcubGluZSgpLngoeCkueSh5KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ldGFkYXRhOiB7XG4gICAgJ3ZlcnNpb24nOiAnMS4xJyxcbiAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuICB9LFxuICBwYXRoOiB7XG4gICAgYXJjOiBkM19zdmcuYXJjKCksXG4gICAgc3ltYm9sOiBkM19zdmcuc3ltYm9sKCkudHlwZShzaGFwZSkuc2l6ZShzaXplKSxcbiAgICBhcmVhOiBmdW5jdGlvbihpdGVtcykge1xuICAgICAgdmFyIG8gPSBpdGVtc1swXTtcbiAgICAgIHJldHVybiAoby5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/IGFyZWFoIDogYXJlYXYpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8ICdsaW5lYXInKVxuICAgICAgICAudGVuc2lvbihvLnRlbnNpb24gfHwgMC43KVxuICAgICAgICAoaXRlbXMpO1xuICAgIH0sXG4gICAgbGluZTogZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgIHZhciBvID0gaXRlbXNbMF07XG4gICAgICByZXR1cm4gbGluZVxuICAgICAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJylcbiAgICAgICAgLnRlbnNpb24oby50ZW5zaW9uIHx8IDAuNylcbiAgICAgICAgKGl0ZW1zKTtcbiAgICB9XG4gIH0sXG4gIHRleHRBbGlnbjoge1xuICAgICdsZWZ0JzogICAnc3RhcnQnLFxuICAgICdjZW50ZXInOiAnbWlkZGxlJyxcbiAgICAncmlnaHQnOiAgJ2VuZCdcbiAgfSxcbiAgdGV4dEJhc2VsaW5lOiB7XG4gICAgJ3RvcCc6ICAgICdiZWZvcmUtZWRnZScsXG4gICAgJ2JvdHRvbSc6ICdhZnRlci1lZGdlJyxcbiAgICAnbWlkZGxlJzogJ2NlbnRyYWwnXG4gIH0sXG4gIHN0eWxlczoge1xuICAgICdmaWxsJzogICAgICAgICAgICAgJ2ZpbGwnLFxuICAgICdmaWxsT3BhY2l0eSc6ICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgJ3N0cm9rZSc6ICAgICAgICAgICAnc3Ryb2tlJyxcbiAgICAnc3Ryb2tlV2lkdGgnOiAgICAgICdzdHJva2Utd2lkdGgnLFxuICAgICdzdHJva2VPcGFjaXR5JzogICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAnc3Ryb2tlQ2FwJzogICAgICAgICdzdHJva2UtbGluZWNhcCcsXG4gICAgJ3N0cm9rZURhc2gnOiAgICAgICAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgJ3N0cm9rZURhc2hPZmZzZXQnOiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAgICdvcGFjaXR5JzogICAgICAgICAgJ29wYWNpdHknXG4gIH0sXG4gIHN0eWxlUHJvcGVydGllczogW1xuICAgICdmaWxsJyxcbiAgICAnZmlsbE9wYWNpdHknLFxuICAgICdzdHJva2UnLFxuICAgICdzdHJva2VXaWR0aCcsXG4gICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICdzdHJva2VDYXAnLFxuICAgICdzdHJva2VEYXNoJyxcbiAgICAnc3Ryb2tlRGFzaE9mZnNldCcsXG4gICAgJ29wYWNpdHknXG4gIF1cbn07XG4iLCJmdW5jdGlvbiBzaXplKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uZm9udFNpemUgIT0gbnVsbCA/IGl0ZW0uZm9udFNpemUgOiAxMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpemU6IHNpemUsXG4gIHZhbHVlOiBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMgIT0gbnVsbCA/IFN0cmluZyhzKSA6ICcnO1xuICB9LFxuICBmb250OiBmdW5jdGlvbihpdGVtLCBxdW90ZSkge1xuICAgIHZhciBmb250ID0gaXRlbS5mb250O1xuICAgIGlmIChxdW90ZSAmJiBmb250KSB7XG4gICAgICBmb250ID0gU3RyaW5nKGZvbnQpLnJlcGxhY2UoL1xcXCIvZywgJ1xcJycpO1xuICAgIH1cbiAgICByZXR1cm4gJycgK1xuICAgICAgKGl0ZW0uZm9udFN0eWxlID8gaXRlbS5mb250U3R5bGUgKyAnICcgOiAnJykgK1xuICAgICAgKGl0ZW0uZm9udFZhcmlhbnQgPyBpdGVtLmZvbnRWYXJpYW50ICsgJyAnIDogJycpICtcbiAgICAgIChpdGVtLmZvbnRXZWlnaHQgPyBpdGVtLmZvbnRXZWlnaHQgKyAnICcgOiAnJykgK1xuICAgICAgc2l6ZShpdGVtKSArICdweCAnICtcbiAgICAgIChmb250IHx8ICdzYW5zLXNlcmlmJyk7XG4gIH0sXG4gIG9mZnNldDogZnVuY3Rpb24oaXRlbSkge1xuICAgIC8vIHBlcmZvcm0gb3VyIG93biBmb250IGJhc2VsaW5lIGNhbGN1bGF0aW9uXG4gICAgLy8gd2h5PyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgU1ZHIDEuMSAnYWxpZ25tZW50LWJhc2VsaW5lJyA6KFxuICAgIHZhciBiYXNlbGluZSA9IGl0ZW0uYmFzZWxpbmUsXG4gICAgICAgIGggPSBzaXplKGl0ZW0pO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKFxuICAgICAgYmFzZWxpbmUgPT09ICd0b3AnICAgID8gIDAuOTMqaCA6XG4gICAgICBiYXNlbGluZSA9PT0gJ21pZGRsZScgPyAgMC4zMCpoIDpcbiAgICAgIGJhc2VsaW5lID09PSAnYm90dG9tJyA/IC0wLjIxKmggOiAwXG4gICAgKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uOiAnMi4yLjYnLFxuICBkYXRhZmxvdzogcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICBwYXJzZTogcmVxdWlyZSgnLi9zcmMvcGFyc2UvJyksXG4gIHNjZW5lOiB7XG4gICAgQm91bmRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvQm91bmRlcicpLFxuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0J1aWxkZXInKSxcbiAgICBFbmNvZGVyOiByZXF1aXJlKCcuL3NyYy9zY2VuZS9FbmNvZGVyJyksXG4gICAgR3JvdXBCdWlsZGVyOiByZXF1aXJlKCcuL3NyYy9zY2VuZS9Hcm91cEJ1aWxkZXInKSxcbiAgfSxcbiAgdHJhbnNmb3JtczogcmVxdWlyZSgnLi9zcmMvdHJhbnNmb3JtcycpLFxuICBzY2hlbWE6IHJlcXVpcmUoJy4vc3JjL2NvcmUvc2NoZW1hJyksXG4gIGNvbmZpZzogcmVxdWlyZSgnLi9zcmMvY29yZS9jb25maWcnKSxcbiAgdXRpbDogIHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgZGVidWc6IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLmRlYnVnXG59OyIsInZhciBzZyA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLnJlbmRlcixcbiAgICBjYW52YXMgPSBzZy5jYW52YXMsXG4gICAgc3ZnID0gc2cuc3ZnLnN0cmluZyxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG5cbmZ1bmN0aW9uIEhlYWRsZXNzVmlldyh3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICBWaWV3LmNhbGwobnVsbCwgd2lkdGgsIGhlaWdodCwgbW9kZWwpO1xuICB0aGlzLl90eXBlID0gJ2NhbnZhcyc7XG4gIHRoaXMuX3JlbmRlcmVycyA9IHtjYW52YXM6IGNhbnZhcywgc3ZnOiBzdmd9O1xufVxuXG52YXIgcHJvdG90eXBlID0gKEhlYWRsZXNzVmlldy5wcm90b3R5cGUgPSBuZXcgVmlldygpKTtcblxucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZih0eXBlKSB0aGlzLl90eXBlID0gdHlwZTtcbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fdHlwZSA9PT0gJ2NhbnZhcycpID8gdGhpcy5fcmVuZGVyZXIuY2FudmFzKCkgOiBudWxsO1xufTtcblxucHJvdG90eXBlLmNhbnZhc0FzeW5jID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHIgPSB0aGlzLl9yZW5kZXJlciwgdmlldyA9IHRoaXM7XG4gIFxuICBmdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmIChyLnBlbmRpbmdJbWFnZXMoKSA9PT0gMCkge1xuICAgICAgdmlldy5yZW5kZXIoKTsgLy8gcmUtcmVuZGVyIHdpdGggYWxsIGltYWdlc1xuICAgICAgY2FsbGJhY2sodmlldy5jYW52YXMoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQod2FpdCwgMTApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGltYWdlcyBsb2FkaW5nLCBwb2xsIHVudGlsIHJlYWR5XG4gIGlmICh0aGlzLl90eXBlICE9PSAnY2FudmFzJykgcmV0dXJuIG51bGw7XG4gIGlmIChyLnBlbmRpbmdJbWFnZXMoKSA+IDApIHsgd2FpdCgpOyB9IGVsc2UgeyBjYWxsYmFjayh0aGlzLmNhbnZhcygpKTsgfVxufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX3R5cGUgPT09ICdzdmcnKSA/IHRoaXMuX3JlbmRlcmVyLnN2ZygpIDogbnVsbDtcbn07XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7ICAgIFxuICB2YXIgdyA9IHRoaXMuX3dpZHRoLFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCxcbiAgICAgIGJnICA9IHRoaXMuX2JnY29sb3IsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgY29uZmlnID0gdGhpcy5tb2RlbCgpLmNvbmZpZygpO1xuXG4gIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgIHcgPSB0aGlzLl92aWV3cG9ydFswXSAtIChwYWQgPyBwYWQubGVmdCArIHBhZC5yaWdodCA6IDApO1xuICAgIGggPSB0aGlzLl92aWV3cG9ydFsxXSAtIChwYWQgPyBwYWQudG9wICsgcGFkLmJvdHRvbSA6IDApO1xuICB9XG5cbiAgdGhpcy5fcmVuZGVyZXIgPSAodGhpcy5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKGNvbmZpZy5sb2FkKSlcbiAgICAuaW5pdGlhbGl6ZShudWxsLCB3LCBoLCBwYWQpXG4gICAgLmJhY2tncm91bmQoYmcpO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRsZXNzVmlldzsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgQ2hhbmdlU2V0ID0gZGYuQ2hhbmdlU2V0LFxuICAgIEJhc2UgPSBkZi5HcmFwaC5wcm90b3R5cGUsXG4gICAgTm9kZSAgPSBkZi5Ob2RlLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBHcm91cEJ1aWxkZXIgPSByZXF1aXJlKCcuLi9zY2VuZS9Hcm91cEJ1aWxkZXInKSxcbiAgICB2aXNpdCA9IHJlcXVpcmUoJy4uL3NjZW5lL3Zpc2l0JyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuZnVuY3Rpb24gTW9kZWwoY2ZnKSB7XG4gIHRoaXMuX2RlZnMgPSB7fTtcbiAgdGhpcy5fcHJlZGljYXRlcyA9IHt9O1xuICB0aGlzLl9zY2VuZSA9IG51bGw7XG5cbiAgdGhpcy5fbm9kZSA9IG51bGw7XG4gIHRoaXMuX2J1aWxkZXIgPSBudWxsOyAvLyBUb3AtbGV2ZWwgc2NlbmVncmFwaCBidWlsZGVyXG5cbiAgdGhpcy5fcmVzZXQgPSB7YXhlczogZmFsc2UsIGxlZ2VuZHM6IGZhbHNlfTtcblxuICB0aGlzLmNvbmZpZyhjZmcpO1xuICBCYXNlLmluaXQuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChNb2RlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZGVsO1xuXG5wcm90b3R5cGUuZGVmcyA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGVmcztcbiAgdGhpcy5fZGVmcyA9IGRlZnM7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uKGNmZykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb25maWc7XG4gIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5jcmVhdGUoY29uZmlnKTtcbiAgZm9yICh2YXIgbmFtZSBpbiBjZmcpIHtcbiAgICB2YXIgeCA9IGNmZ1tuYW1lXSwgeSA9IHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgICBpZiAoZGwuaXNPYmplY3QoeCkgJiYgZGwuaXNPYmplY3QoeSkpIHtcbiAgICAgIGRsLmV4dGVuZCh5LCB4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29uZmlnW25hbWVdID0geDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICh0aGlzLl9kZWZzKSB0aGlzLl9kZWZzLndpZHRoID0gd2lkdGg7XG4gIGlmICh0aGlzLl9kZWZzICYmIHRoaXMuX2RlZnMubWFya3MpIHRoaXMuX2RlZnMubWFya3Mud2lkdGggPSB3aWR0aDtcbiAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgdGhpcy5fc2NlbmUuaXRlbXNbMF0ud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9zY2VuZS5pdGVtc1swXS5fZGlydHkgPSB0cnVlO1xuICB9XG4gIHRoaXMuX3Jlc2V0LmF4ZXMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgaWYgKHRoaXMuX2RlZnMpIHRoaXMuX2RlZnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBpZiAodGhpcy5fZGVmcyAmJiB0aGlzLl9kZWZzLm1hcmtzKSB0aGlzLl9kZWZzLm1hcmtzLmhlaWdodCA9IGhlaWdodDtcbiAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgdGhpcy5fc2NlbmUuaXRlbXNbMF0uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3NjZW5lLml0ZW1zWzBdLl9kaXJ0eSA9IHRydWU7XG4gIH1cbiAgdGhpcy5fcmVzZXQuYXhlcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGUgfHwgKHRoaXMuX25vZGUgPSBuZXcgTm9kZSh0aGlzKSk7XG59O1xuXG5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IEJhc2UuZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgIC8vIG5ldyBEYXRhc291cmNlXG4gICAgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIoZGF0YS5waXBlbGluZSgpWzBdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5cbmZ1bmN0aW9uIHByZWRpY2F0ZXMobmFtZSkge1xuICB2YXIgbSA9IHRoaXMsIHByZWQgPSB7fTtcbiAgaWYgKCFkbC5pc0FycmF5KG5hbWUpKSByZXR1cm4gdGhpcy5fcHJlZGljYXRlc1tuYW1lXTtcbiAgbmFtZS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgcHJlZFtuXSA9IG0uX3ByZWRpY2F0ZXNbbl07IH0pO1xuICByZXR1cm4gcHJlZDtcbn1cblxucHJvdG90eXBlLnByZWRpY2F0ZSA9IGZ1bmN0aW9uKG5hbWUsIHByZWRpY2F0ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHByZWRpY2F0ZXMuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9wcmVkaWNhdGVzW25hbWVdID0gcHJlZGljYXRlKTtcbn07XG5cbnByb3RvdHlwZS5wcmVkaWNhdGVzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcmVkaWNhdGVzOyB9O1xuXG5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgaWYgKHRoaXMuX2J1aWxkZXIpIHRoaXMubm9kZSgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2J1aWxkZXIuZGlzY29ubmVjdCgpKTtcbiAgdGhpcy5fYnVpbGRlciA9IG5ldyBHcm91cEJ1aWxkZXIodGhpcywgdGhpcy5fZGVmcy5tYXJrcywgdGhpcy5fc2NlbmU9e30pO1xuICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcih0aGlzLl9idWlsZGVyLmNvbm5lY3QoKSk7XG4gIHZhciBwID0gdGhpcy5fYnVpbGRlci5waXBlbGluZSgpO1xuICBwW3AubGVuZ3RoLTFdLmFkZExpc3RlbmVyKHJlbmRlcmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3NjZW5lICYmIHRoaXMuX3Jlc2V0LmF4ZXMpIHtcbiAgICB2aXNpdCh0aGlzLl9zY2VuZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uYXhlcykgaXRlbS5heGVzLmZvckVhY2goZnVuY3Rpb24oYXhpcykgeyBheGlzLnJlc2V0KCk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc2V0LmF4ZXMgPSBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fc2NlbmUgJiYgdGhpcy5fcmVzZXQubGVnZW5kcykge1xuICAgIHZpc2l0KHRoaXMuX3NjZW5lLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5sZWdlbmRzKSBpdGVtLmxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbihsKSB7IGwucmVzZXQoKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzZXQubGVnZW5kcyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIobCk7IFxufTtcblxucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZiAoIWNzKSBjcyA9IENoYW5nZVNldC5jcmVhdGUoKTtcbiAgdGhpcy5wcm9wYWdhdGUoY3MsIHRoaXMubm9kZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgc2cgPSByZXF1aXJlKCd2ZWdhLXNjZW5lZ3JhcGgnKS5yZW5kZXIsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBwYXJzZVN0cmVhbXMgPSByZXF1aXJlKCcuLi9wYXJzZS9zdHJlYW1zJyksXG4gICAgRW5jb2RlciA9IHJlcXVpcmUoJy4uL3NjZW5lL0VuY29kZXInKSxcbiAgICBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vc2NlbmUvVHJhbnNpdGlvbicpO1xuXG5mdW5jdGlvbiBWaWV3KGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMuX2VsICAgID0gbnVsbDtcbiAgdGhpcy5fbW9kZWwgPSBudWxsO1xuICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoIHx8IDUwMDtcbiAgdGhpcy5faGVpZ2h0ICA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQgfHwgMzAwO1xuICB0aGlzLl9iZ2NvbG9yID0gbnVsbDtcbiAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIHRoaXMuX3BhZGRpbmcgPSB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlciAgPSBudWxsO1xuICB0aGlzLl9zdHJlYW1lciA9IG51bGw7IC8vIFRhcmdldGVkIHVwZGF0ZSBmb3Igc3RyZWFtaW5nIGNoYW5nZXNcbiAgdGhpcy5fY2hhbmdlc2V0ID0gbnVsbDtcbiAgdGhpcy5fcmVwYWludCA9IHRydWU7IC8vIEZ1bGwgcmUtcmVuZGVyIG9uIGV2ZXJ5IHJlLWluaXRcbiAgdGhpcy5fcmVuZGVyZXJzID0gc2c7XG4gIHRoaXMuX2lvICA9IG51bGw7XG4gIHRoaXMuX2FwaSA9IHt9OyAvLyBTdGFzaCBzdHJlYW1pbmcgZGF0YSBBUEkgc2FuZGJveGVzLlxufVxuXG52YXIgcHJvdG90eXBlID0gVmlldy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICBpZiAodGhpcy5fbW9kZWwgIT09IG1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLl9zdHJlYW1lciA9IG5ldyBkZi5Ob2RlKG1vZGVsKTtcbiAgICB0aGlzLl9zdHJlYW1lci5fcmFuayA9IC0xOyAgLy8gSEFDSzogVG8gcmVkdWNlIHJlLXJhbmtpbmcgY2h1cm4uXG4gICAgdGhpcy5fY2hhbmdlc2V0ID0gZGYuQ2hhbmdlU2V0LmNyZWF0ZSgpO1xuICAgIGlmICh0aGlzLl9oYW5kbGVyKSB0aGlzLl9oYW5kbGVyLm1vZGVsKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNhbmRib3hlZCBzdHJlYW1pbmcgZGF0YSBBUElcbmZ1bmN0aW9uIHN0cmVhbWluZyhzcmMpIHtcbiAgdmFyIHZpZXcgPSB0aGlzLFxuICAgICAgZHMgPSB0aGlzLl9tb2RlbC5kYXRhKHNyYyksXG4gICAgICBuYW1lID0gZHMubmFtZSgpLFxuICAgICAgbGlzdGVuZXIgPSBkcy5waXBlbGluZSgpWzBdLFxuICAgICAgc3RyZWFtZXIgPSB0aGlzLl9zdHJlYW1lcixcbiAgICAgIGFwaSA9IHt9O1xuXG4gIC8vIElmIHdlIGhhdmUgaXQgc3Rhc2hlZCwgZG9uJ3QgY3JlYXRlIGEgbmV3IGNsb3N1cmUuIFxuICBpZiAodGhpcy5fYXBpW3NyY10pIHJldHVybiB0aGlzLl9hcGlbc3JjXTtcblxuICBhcGkuaW5zZXJ0ID0gZnVuY3Rpb24odmFscykge1xuICAgIGRzLmluc2VydChkbC5kdXBsaWNhdGUodmFscykpOyAgLy8gRG9uJ3QgcG9sbHV0ZSB0aGUgZW52aXJvbm1lbnRcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgdmlldy5fY2hhbmdlc2V0LmRhdGFbbmFtZV0gPSAxO1xuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgYXBpLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB2aWV3Ll9jaGFuZ2VzZXQuZGF0YVtuYW1lXSA9IDE7XG4gICAgcmV0dXJuIChkcy51cGRhdGUuYXBwbHkoZHMsIGFyZ3VtZW50cyksIGFwaSk7XG4gIH07XG5cbiAgYXBpLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB2aWV3Ll9jaGFuZ2VzZXQuZGF0YVtuYW1lXSA9IDE7XG4gICAgcmV0dXJuIChkcy5yZW1vdmUuYXBwbHkoZHMsIGFyZ3VtZW50cyksIGFwaSk7XG4gIH07XG5cbiAgYXBpLnZhbHVlcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZHMudmFsdWVzKCk7IH07ICAgIFxuXG4gIHJldHVybiAodGhpcy5fYXBpW3NyY10gPSBhcGkpO1xufVxuXG5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2Ll9tb2RlbC52YWx1ZXMoKTtcbiAgZWxzZSBpZiAoZGwuaXNTdHJpbmcoZGF0YSkpIHJldHVybiBzdHJlYW1pbmcuY2FsbCh2LCBkYXRhKTtcbiAgZWxzZSBpZiAoZGwuaXNPYmplY3QoZGF0YSkpIHtcbiAgICBkbC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGFwaSA9IHN0cmVhbWluZy5jYWxsKHYsIGspO1xuICAgICAgZGF0YVtrXShhcGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBtICA9IHRoaXMuX21vZGVsLFxuICAgICAgY3MgPSB0aGlzLl9jaGFuZ2VzZXQsXG4gICAgICBzdHJlYW1lciA9IHRoaXMuX3N0cmVhbWVyLFxuICAgICAgc2V0dGVyID0gbmFtZTsgXG5cbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG0udmFsdWVzKERlcHMuU0lHTkFMUyk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGRsLmlzU3RyaW5nKG5hbWUpKSB7XG4gICAgcmV0dXJuIG0udmFsdWVzKERlcHMuU0lHTkFMUywgbmFtZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgc2V0dGVyID0ge307XG4gICAgc2V0dGVyW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICBkbC5rZXlzKHNldHRlcikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobS5zaWduYWwoaykudmFsdWUoc2V0dGVyW2tdKSk7XG4gICAgY3Muc2lnbmFsc1trXSA9IDE7XG4gICAgY3MucmVmbG93ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9fd2lkdGg7XG4gIGlmICh0aGlzLl9fd2lkdGggIT09IHdpZHRoKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLm1vZGVsKCkud2lkdGgod2lkdGgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLl9zdHJpY3QpIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9faGVpZ2h0O1xuICBpZiAodGhpcy5fX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm1vZGVsKCkuaGVpZ2h0KGhlaWdodCk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKGJnY29sb3IpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fYmdjb2xvcjtcbiAgaWYgKHRoaXMuX2JnY29sb3IgIT09IGJnY29sb3IpIHtcbiAgICB0aGlzLl9iZ2NvbG9yID0gYmdjb2xvcjtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWQpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcocGFkKSkge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gICAgICB0aGlzLl9wYWRkaW5nID0ge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgICAgIHRoaXMuX3N0cmljdCA9IChwYWQgPT09ICdzdHJpY3QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgICAgdGhpcy5fc3RyaWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZW5kZXJlcikgdGhpcy5fcmVuZGVyZXIucmVzaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHBhZCk7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpICB0aGlzLl9oYW5kbGVyLnBhZGRpbmcocGFkKTtcbiAgfVxuICByZXR1cm4gKHRoaXMuX3JlcGFpbnQgPSB0cnVlLCB0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5hdXRvcGFkID0gZnVuY3Rpb24ob3B0KSB7XG4gIGlmICh0aGlzLl9hdXRvcGFkIDwgMSkgcmV0dXJuIHRoaXM7XG4gIGVsc2UgdGhpcy5fYXV0b3BhZCA9IDA7XG5cbiAgdmFyIGIgPSB0aGlzLm1vZGVsKCkuc2NlbmUoKS5ib3VuZHMsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgY29uZmlnID0gdGhpcy5tb2RlbCgpLmNvbmZpZygpLFxuICAgICAgaW5zZXQgPSBjb25maWcuYXV0b3BhZEluc2V0LFxuICAgICAgbCA9IGIueDEgPCAwID8gTWF0aC5jZWlsKC1iLngxKSArIGluc2V0IDogMCxcbiAgICAgIHQgPSBiLnkxIDwgMCA/IE1hdGguY2VpbCgtYi55MSkgKyBpbnNldCA6IDAsXG4gICAgICByID0gYi54MiA+IHRoaXMuX3dpZHRoICA/IE1hdGguY2VpbCgrYi54MiAtIHRoaXMuX3dpZHRoKSArIGluc2V0IDogMDtcbiAgYiA9IGIueTIgPiB0aGlzLl9oZWlnaHQgPyBNYXRoLmNlaWwoK2IueTIgLSB0aGlzLl9oZWlnaHQpICsgaW5zZXQgOiAwO1xuICBwYWQgPSB7bGVmdDpsLCB0b3A6dCwgcmlnaHQ6ciwgYm90dG9tOmJ9O1xuXG4gIGlmICh0aGlzLl9zdHJpY3QpIHtcbiAgICB0aGlzLl9hdXRvcGFkID0gMDtcbiAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgIHRoaXMuX3dpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fX3dpZHRoIC0gKGwrcikpO1xuICAgIHRoaXMuX2hlaWdodCA9IE1hdGgubWF4KDAsIHRoaXMuX19oZWlnaHQgLSAodCtiKSk7XG5cbiAgICB0aGlzLl9tb2RlbC53aWR0aCh0aGlzLl93aWR0aClcbiAgICAgIC5oZWlnaHQodGhpcy5faGVpZ2h0KS5yZXNldCgpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKClcbiAgICAgIC51cGRhdGUoe3Byb3BzOidlbnRlcid9KS51cGRhdGUoe3Byb3BzOid1cGRhdGUnfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYWRkaW5nKHBhZCkudXBkYXRlKG9wdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudmlld3BvcnQgPSBmdW5jdGlvbihzaXplKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICBpZiAodGhpcy5fdmlld3BvcnQgIT09IHNpemUpIHtcbiAgICB0aGlzLl92aWV3cG9ydCA9IHNpemU7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICBpZiAodGhpcy5fcmVuZGVyZXJzW3R5cGVdKSB0eXBlID0gdGhpcy5fcmVuZGVyZXJzW3R5cGVdO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJlbmRlcmVyOiAnICsgdHlwZSk7XG4gIGVsc2UgaWYgKCF0eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlbmRlcmVyIHNwZWNpZmllZCcpO1xuXG4gIGlmICh0aGlzLl9pbyAhPT0gdHlwZSkge1xuICAgIHRoaXMuX2lvID0gdHlwZTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX2J1aWxkKSB0aGlzLnJlbmRlcigpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCkge1xuICB2YXIgdiA9IHRoaXMsIHByZXZIYW5kbGVyLFxuICAgICAgdyA9IHYuX3dpZHRoLCBoID0gdi5faGVpZ2h0LCBwYWQgPSB2Ll9wYWRkaW5nLCBiZyA9IHYuX2JnY29sb3IsXG4gICAgICBjb25maWcgPSB0aGlzLm1vZGVsKCkuY29uZmlnKCk7XG5cbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IGVsID09PSBudWxsKSB7XG4gICAgZWwgPSB0aGlzLl9lbCA/IHRoaXMuX2VsLnBhcmVudE5vZGUgOiBudWxsO1xuICAgIGlmICghZWwpIHJldHVybiB0aGlzOyAgLy8gVGhpcyBWaWV3IGNhbm5vdCBpbml0IHcvbyBhblxuICB9XG5cbiAgLy8gY2xlYXIgcHJlLWV4aXN0aW5nIGNvbnRhaW5lclxuICBkMy5zZWxlY3QoZWwpLnNlbGVjdCgnZGl2LnZlZ2EnKS5yZW1vdmUoKTtcbiAgXG4gIC8vIGFkZCBkaXYgY29udGFpbmVyXG4gIHRoaXMuX2VsID0gZWwgPSBkMy5zZWxlY3QoZWwpXG4gICAgLmFwcGVuZCgnZGl2JylcbiAgICAuYXR0cignY2xhc3MnLCAndmVnYScpXG4gICAgLnN0eWxlKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpXG4gICAgLm5vZGUoKTtcbiAgaWYgKHYuX3ZpZXdwb3J0KSB7XG4gICAgZDMuc2VsZWN0KGVsKVxuICAgICAgLnN0eWxlKCd3aWR0aCcsICAodi5fdmlld3BvcnRbMF0gfHwgdykrJ3B4JylcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywgKHYuX3ZpZXdwb3J0WzFdIHx8IGgpKydweCcpXG4gICAgICAuc3R5bGUoJ292ZXJmbG93JywgJ2F1dG8nKTtcbiAgfVxuXG4gIC8vIHJlbmRlcmVyXG4gIHNnLmNhbnZhcy5SZW5kZXJlci5SRVRJTkEgPSBjb25maWcucmVuZGVyLnJldGluYTtcbiAgdi5fcmVuZGVyZXIgPSAodi5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKGNvbmZpZy5sb2FkKSlcbiAgICAuaW5pdGlhbGl6ZShlbCwgdywgaCwgcGFkKVxuICAgIC5iYWNrZ3JvdW5kKGJnKTtcbiAgXG4gIC8vIGlucHV0IGhhbmRsZXJcbiAgcHJldkhhbmRsZXIgPSB2Ll9oYW5kbGVyO1xuICB2Ll9oYW5kbGVyID0gbmV3IHRoaXMuX2lvLkhhbmRsZXIoKVxuICAgIC5pbml0aWFsaXplKGVsLCBwYWQsIHYpO1xuXG4gIGlmIChwcmV2SGFuZGxlcikge1xuICAgIHByZXZIYW5kbGVyLmhhbmRsZXJzKCkuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICB2Ll9oYW5kbGVyLm9uKGgudHlwZSwgaC5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZm9yIHNpZ25hbCBzdHJlYW0gZGVmaW5pdGlvbnMuXG4gICAgdi5fZGV0YWNoID0gcGFyc2VTdHJlYW1zKHRoaXMpO1xuICB9XG4gIFxuICByZXR1cm4gKHRoaXMuX3JlcGFpbnQgPSB0cnVlLCB0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9kZXRhY2gpIHRoaXMuX2RldGFjaCgpO1xufTtcblxuZnVuY3Rpb24gYnVpbGQoKSB7XG4gIHZhciB2ID0gdGhpcztcbiAgdi5fcmVuZGVyTm9kZSA9IG5ldyBkZi5Ob2RlKHYuX21vZGVsKVxuICAgIC5yb3V0ZXIodHJ1ZSk7XG5cbiAgdi5fcmVuZGVyTm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgbG9nLmRlYnVnKGlucHV0LCBbJ3JlbmRlcmluZyddKTtcblxuICAgIHZhciBzID0gdi5fbW9kZWwuc2NlbmUoKSxcbiAgICAgICAgaCA9IHYuX2hhbmRsZXI7XG5cbiAgICBpZiAoaCAmJiBoLnNjZW5lKSBoLnNjZW5lKHMpO1xuXG4gICAgaWYgKGlucHV0LnRyYW5zKSB7XG4gICAgICBpbnB1dC50cmFucy5zdGFydChmdW5jdGlvbihpdGVtcykgeyB2Ll9yZW5kZXJlci5yZW5kZXIocywgaXRlbXMpOyB9KTtcbiAgICB9IGVsc2UgaWYgKHYuX3JlcGFpbnQpIHtcbiAgICAgIHYuX3JlbmRlcmVyLnJlbmRlcihzKTtcbiAgICAgIHYuX3JlcGFpbnQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmRpcnR5Lmxlbmd0aCkge1xuICAgICAgdi5fcmVuZGVyZXIucmVuZGVyKHMsIGlucHV0LmRpcnR5KTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuZGlydHkubGVuZ3RoKSB7XG4gICAgICBpbnB1dC5kaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgaS5fZGlydHkgPSBmYWxzZTsgfSk7XG4gICAgICBzLml0ZW1zWzBdLl9kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZvciBhbGwgdXBkYXRlZCBkYXRhc291cmNlcywgY2xlYXIgdGhlaXIgcHJldmlvdXMgdmFsdWVzLlxuICAgIGZvciAodmFyIGQgaW4gaW5wdXQuZGF0YSkgeyB2Ll9tb2RlbC5kYXRhKGQpLnN5bmNocm9uaXplKCk7IH1cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgcmV0dXJuICh2Ll9tb2RlbC5zY2VuZSh2Ll9yZW5kZXJOb2RlKSwgdHJ1ZSk7ICBcbn1cblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciB2ID0gdGhpcyxcbiAgICAgIHRyYW5zID0gb3B0LmR1cmF0aW9uID8gbmV3IFRyYW5zaXRpb24ob3B0LmR1cmF0aW9uLCBvcHQuZWFzZSkgOiBudWxsO1xuXG4gIHZhciBjcyA9IHYuX2NoYW5nZXNldDtcbiAgaWYgKHRyYW5zKSBjcy50cmFucyA9IHRyYW5zO1xuICBpZiAob3B0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGwua2V5cyhjcy5kYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ05ldyBkYXRhIHZhbHVlcyBhcmUgbm90IHJlZmxlY3RlZCBpbiB0aGUgdmlzdWFsaXphdGlvbi4nICtcbiAgICAgICAgJyBQbGVhc2UgY2FsbCB2aWV3LnVwZGF0ZSgpIGJlZm9yZSB1cGRhdGluZyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBzZXQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjcy5yZWZsb3cgID0gdHJ1ZTtcbiAgICBjcy5yZXF1ZXN0ID0gb3B0LnByb3BzO1xuICB9XG5cbiAgdmFyIGJ1aWx0ID0gdi5fYnVpbGQ7XG4gIHYuX2J1aWxkID0gdi5fYnVpbGQgfHwgYnVpbGQuY2FsbCh0aGlzKTtcblxuICAvLyBJZiBzcGVjaWZpYyBpdGVtcyBhcmUgc3BlY2lmaWVkLCBzaG9ydC1jaXJjdWl0IGRhdGFmbG93IGdyYXBoLlxuICAvLyBFbHNlLUlmIHRoZXJlIGFyZSBzdHJlYW1pbmcgdXBkYXRlcywgcGVyZm9ybSBhIHRhcmdldGVkIHByb3BhZ2F0aW9uLlxuICAvLyBPdGhlcndpc2UsIHJlZXZhbHVhdGUgdGhlIGVudGlyZSBtb2RlbCAoZGF0YXNvdXJjZXMgKyBzY2VuZSkuXG4gIGlmIChvcHQuaXRlbXMgJiYgYnVpbHQpIHsgXG4gICAgRW5jb2Rlci51cGRhdGUodGhpcy5fbW9kZWwsIG9wdC50cmFucywgb3B0LnByb3BzLCBvcHQuaXRlbXMsIGNzLmRpcnR5KTtcbiAgICB2Ll9yZW5kZXJOb2RlLmV2YWx1YXRlKGNzKTtcbiAgfSBlbHNlIGlmICh2Ll9zdHJlYW1lci5saXN0ZW5lcnMoKS5sZW5ndGggJiYgYnVpbHQpIHtcbiAgICB2Ll9tb2RlbC5wcm9wYWdhdGUoY3MsIHYuX3N0cmVhbWVyKTtcbiAgICB2Ll9zdHJlYW1lci5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdi5fbW9kZWwuZmlyZShjcyk7XG4gIH1cblxuICB2Ll9jaGFuZ2VzZXQgPSBkZi5DaGFuZ2VTZXQuY3JlYXRlKCk7XG5cbiAgcmV0dXJuIHYuYXV0b3BhZChvcHQpO1xufTtcblxucHJvdG90eXBlLnRvSW1hZ2VVUkwgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciB2ID0gdGhpcywgUmVuZGVyZXI7XG5cbiAgLy8gbG9va3VwIGFwcHJvcHJpYXRlIHJlbmRlcmVyXG4gIHN3aXRjaCAodHlwZSB8fCAncG5nJykge1xuICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgY2FzZSAncG5nJzpcbiAgICAgIFJlbmRlcmVyID0gc2cuY2FudmFzLlJlbmRlcmVyOyBicmVhaztcbiAgICBjYXNlICdzdmcnOlxuICAgICAgUmVuZGVyZXIgPSBzZy5zdmcuc3RyaW5nLlJlbmRlcmVyOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcbiAgfVxuXG4gIHZhciByZXRpbmEgPSBzZy5jYW52YXMuUmVuZGVyZXIuUkVUSU5BO1xuICBzZy5jYW52YXMuUmVuZGVyZXIuUkVUSU5BID0gZmFsc2U7IC8vIGlnbm9yZSByZXRpbmEgc2NyZWVuXG5cbiAgLy8gcmVuZGVyIHRoZSBzY2VuZWdyYXBoXG4gIHZhciByZW4gPSBuZXcgUmVuZGVyZXIodi5fbW9kZWwuY29uZmlnLmxvYWQpXG4gICAgLmluaXRpYWxpemUobnVsbCwgdi5fd2lkdGgsIHYuX2hlaWdodCwgdi5fcGFkZGluZylcbiAgICAucmVuZGVyKHYuX21vZGVsLnNjZW5lKCkpO1xuXG4gIHNnLmNhbnZhcy5SZW5kZXJlci5SRVRJTkEgPSByZXRpbmE7IC8vIHJlc3RvcmUgcmV0aW5hIHNldHRpbmdzXG5cbiAgLy8gcmV0dXJuIGRhdGEgdXJsXG4gIGlmICh0eXBlID09PSAnc3ZnJykge1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3Jlbi5zdmcoKV0sIHt0eXBlOiAnaW1hZ2Uvc3ZnK3htbCd9KTtcbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlbi5jYW52YXMoKS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICB9XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX21vZGVsLnNjZW5lKCksIGl0ZW1zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vbi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vblNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5fbW9kZWwuc2lnbmFsKG5hbWUpLm9uKGhhbmRsZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vZmYuYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub2ZmU2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICB0aGlzLl9tb2RlbC5zaWduYWwobmFtZSkub2ZmKGhhbmRsZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZpZXcuZmFjdG9yeSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIHZhciBIZWFkbGVzc1ZpZXcgPSByZXF1aXJlKCcuL0hlYWRsZXNzVmlldycpO1xuICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciBkZWZzID0gbW9kZWwuZGVmcygpO1xuICAgIHZhciB2ID0gKG9wdC5lbCA/IG5ldyBWaWV3KCkgOiBuZXcgSGVhZGxlc3NWaWV3KCkpXG4gICAgICAubW9kZWwobW9kZWwpXG4gICAgICAucmVuZGVyZXIob3B0LnJlbmRlcmVyIHx8ICdjYW52YXMnKVxuICAgICAgLndpZHRoKGRlZnMud2lkdGgpXG4gICAgICAuaGVpZ2h0KGRlZnMuaGVpZ2h0KVxuICAgICAgLmJhY2tncm91bmQoZGVmcy5iYWNrZ3JvdW5kKVxuICAgICAgLnBhZGRpbmcoZGVmcy5wYWRkaW5nKVxuICAgICAgLnZpZXdwb3J0KGRlZnMudmlld3BvcnQpXG4gICAgICAuaW5pdGlhbGl6ZShvcHQuZWwpO1xuXG4gICAgaWYgKG9wdC5kYXRhKSB2LmRhdGEob3B0LmRhdGEpO1xuXG4gICAgaWYgKG9wdC5ob3ZlciAhPT0gZmFsc2UgJiYgb3B0LmVsKSB7XG4gICAgICB2Lm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5oYXNQcm9wZXJ0eVNldCgnaG92ZXInKSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKHtwcm9wczonaG92ZXInLCBpdGVtczppdGVtfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZXZ0LCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0uaGFzUHJvcGVydHlTZXQoJ2hvdmVyJykpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSh7cHJvcHM6J3VwZGF0ZScsIGl0ZW1zOml0ZW19KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdjtcbiAgfTsgICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgY29uZmlnID0ge307XG5cbmNvbmZpZy5sb2FkID0ge1xuICAvLyBiYXNlIHVybCBmb3IgbG9hZGluZyBleHRlcm5hbCBkYXRhIGZpbGVzXG4gIC8vIHVzZWQgb25seSBmb3Igc2VydmVyLXNpZGUgb3BlcmF0aW9uXG4gIGJhc2VVUkw6ICcnLFxuICAvLyBBbGxvd3MgZG9tYWluIHJlc3RyaWN0aW9uIHdoZW4gdXNpbmcgZGF0YSBsb2FkaW5nIHZpYSBYSFIuXG4gIC8vIFRvIGVuYWJsZSwgc2V0IGl0IHRvIGEgbGlzdCBvZiBhbGxvd2VkIGRvbWFpbnNcbiAgLy8gZS5nLiwgWyd3aWtpcGVkaWEub3JnJywgJ2VmZi5vcmcnXVxuICBkb21haW5XaGl0ZUxpc3Q6IGZhbHNlXG59O1xuXG4vLyBpbnNldCBwYWRkaW5nIGZvciBhdXRvbWF0aWMgcGFkZGluZyBjYWxjdWxhdGlvblxuY29uZmlnLmF1dG9wYWRJbnNldCA9IDU7XG5cbi8vIGV4dGVuc2libGUgc2NhbGUgbG9va3VwIHRhYmxlXG4vLyBhbGwgZDMuc2NhbGUuKiBpbnN0YW5jZXMgYWxzbyBzdXBwb3J0ZWRcbmNvbmZpZy5zY2FsZSA9IHtcbiAgdGltZTogZDMudGltZS5zY2FsZSxcbiAgdXRjOiAgZDMudGltZS5zY2FsZS51dGNcbn07XG5cbi8vIGRlZmF1bHQgcmVuZGVyaW5nIHNldHRpbmdzXG5jb25maWcucmVuZGVyID0ge1xuICByZXRpbmE6IHRydWVcbn07XG5cbi8vIGRlZmF1bHQgYXhpcyBwcm9wZXJ0aWVzXG5jb25maWcuYXhpcyA9IHtcbiAgb3JpZW50OiAnYm90dG9tJyxcbiAgdGlja3M6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBheGlzQ29sb3I6ICcjMDAwJyxcbiAgZ3JpZENvbG9yOiAnIzAwMCcsXG4gIGdyaWRPcGFjaXR5OiAwLjE1LFxuICB0aWNrQ29sb3I6ICcjMDAwJyxcbiAgdGlja0xhYmVsQ29sb3I6ICcjMDAwJyxcbiAgYXhpc1dpZHRoOiAxLFxuICB0aWNrV2lkdGg6IDEsXG4gIHRpY2tTaXplOiA2LFxuICB0aWNrTGFiZWxGb250U2l6ZTogMTEsXG4gIHRpY2tMYWJlbEZvbnQ6ICdzYW5zLXNlcmlmJyxcbiAgdGl0bGVDb2xvcjogJyMwMDAnLFxuICB0aXRsZUZvbnQ6ICdzYW5zLXNlcmlmJyxcbiAgdGl0bGVGb250U2l6ZTogMTEsXG4gIHRpdGxlRm9udFdlaWdodDogJ2JvbGQnLFxuICB0aXRsZU9mZnNldDogMzVcbn07XG5cbi8vIGRlZmF1bHQgbGVnZW5kIHByb3BlcnRpZXNcbmNvbmZpZy5sZWdlbmQgPSB7XG4gIG9yaWVudDogJ3JpZ2h0JyxcbiAgb2Zmc2V0OiAyMCxcbiAgcGFkZGluZzogMyxcbiAgZ3JhZGllbnRTdHJva2VDb2xvcjogJyM4ODgnLFxuICBncmFkaWVudFN0cm9rZVdpZHRoOiAxLFxuICBncmFkaWVudEhlaWdodDogMTYsXG4gIGdyYWRpZW50V2lkdGg6IDEwMCxcbiAgbGFiZWxDb2xvcjogJyMwMDAnLFxuICBsYWJlbEZvbnRTaXplOiAxMCxcbiAgbGFiZWxGb250OiAnc2Fucy1zZXJpZicsXG4gIGxhYmVsQWxpZ246ICdsZWZ0JyxcbiAgbGFiZWxCYXNlbGluZTogJ21pZGRsZScsXG4gIGxhYmVsT2Zmc2V0OiA4LFxuICBzeW1ib2xTaGFwZTogJ2NpcmNsZScsXG4gIHN5bWJvbFNpemU6IDUwLFxuICBzeW1ib2xDb2xvcjogJyM4ODgnLFxuICBzeW1ib2xTdHJva2VXaWR0aDogMSxcbiAgdGl0bGVDb2xvcjogJyMwMDAnLFxuICB0aXRsZUZvbnQ6ICdzYW5zLXNlcmlmJyxcbiAgdGl0bGVGb250U2l6ZTogMTEsXG4gIHRpdGxlRm9udFdlaWdodDogJ2JvbGQnXG59O1xuXG4vLyBkZWZhdWx0IGNvbG9yIHZhbHVlc1xuY29uZmlnLmNvbG9yID0ge1xuICByZ2I6IFsxMjgsIDEyOCwgMTI4XSxcbiAgbGFiOiBbNTAsIDAsIDBdLFxuICBoY2w6IFswLCAwLCA1MF0sXG4gIGhzbDogWzAsIDAsIDAuNV1cbn07XG5cbi8vIGRlZmF1bHQgc2NhbGUgcmFuZ2VzXG5jb25maWcucmFuZ2UgPSB7XG4gIGNhdGVnb3J5MTA6ICBkMy5zY2FsZS5jYXRlZ29yeTEwKCkucmFuZ2UoKSxcbiAgY2F0ZWdvcnkyMDogIGQzLnNjYWxlLmNhdGVnb3J5MjAoKS5yYW5nZSgpLFxuICBjYXRlZ29yeTIwYjogZDMuc2NhbGUuY2F0ZWdvcnkyMGIoKS5yYW5nZSgpLFxuICBjYXRlZ29yeTIwYzogZDMuc2NhbGUuY2F0ZWdvcnkyMGMoKS5yYW5nZSgpLFxuICBzaGFwZXM6IFtcbiAgICAnY2lyY2xlJyxcbiAgICAnY3Jvc3MnLFxuICAgICdkaWFtb25kJyxcbiAgICAnc3F1YXJlJyxcbiAgICAndHJpYW5nbGUtZG93bicsXG4gICAgJ3RyaWFuZ2xlLXVwJ1xuICBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpLFxuICAgIFNjYWxlID0gcmVxdWlyZSgnLi4vc2NlbmUvU2NhbGUnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5mdW5jdGlvbiBjb21waWxlKG1vZHVsZSwgb3B0LCBzY2hlbWEpIHtcbiAgdmFyIHMgPSBtb2R1bGUuc2NoZW1hO1xuICBpZiAoIXMpIHJldHVybjtcbiAgaWYgKHMucmVmcykgZGwuZXh0ZW5kKHNjaGVtYS5yZWZzLCBzLnJlZnMpO1xuICBpZiAocy5kZWZzKSBkbC5leHRlbmQoc2NoZW1hLmRlZnMsIHMuZGVmcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIHZhciBzY2hlbWEgPSBudWxsO1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gQ29tcGlsZSBpZiB3ZSdyZSBub3QgbG9hZGluZyB0aGUgc2NoZW1hIGZyb20gYSBVUkwuIFxuICAvLyBMb2FkIGZyb20gYSBVUkwgdG8gZXh0ZW5kIHRoZSBleGlzdGluZyBiYXNlIHNjaGVtYS5cbiAgaWYgKG9wdC51cmwpIHtcbiAgICBzY2hlbWEgPSBkbC5qc29uKGRsLmV4dGVuZCh7dXJsOiBvcHQudXJsfSwgY29uZmlnLmxvYWQpKTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlbWEgPSB7XG4gICAgICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgICAgIFwidGl0bGVcIjogXCJWZWdhIFZpc3VhbGl6YXRpb24gU3BlY2lmaWNhdGlvbiBMYW5ndWFnZVwiLFxuICAgICAgXCJkZWZzXCI6IHt9LCBcbiAgICAgIFwicmVmc1wiOiB7fSwgXG4gICAgICBcIiRyZWZcIjogXCIjL2RlZnMvc3BlY1wiXG4gICAgfTtcblxuICAgIGRsLmtleXMocGFyc2UpLmZvckVhY2goZnVuY3Rpb24oaykgeyBjb21waWxlKHBhcnNlW2tdLCBvcHQsIHNjaGVtYSk7IH0pO1xuXG4gICAgLy8gU2NhbGVzIGFyZW4ndCBpbiB0aGUgcGFyc2VyLCBhZGQgc2NoZW1hIG1hbnVhbGx5XG4gICAgY29tcGlsZShTY2FsZSwgb3B0LCBzY2hlbWEpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIHNjaGVtYSB0byBzdXBwb3J0IGN1c3RvbSBtYXJrIHByb3BlcnRpZXMgb3IgcHJvcGVydHkgc2V0cy5cbiAgaWYgKG9wdC5wcm9wZXJ0aWVzKSBkbC5rZXlzKG9wdC5wcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBzY2hlbWEuZGVmcy5wcm9wc2V0LnByb3BlcnRpZXNba10gPSB7XCIkcmVmXCI6IFwiIy9yZWZzL1wiK29wdC5wcm9wZXJ0aWVzW2tdK1wiVmFsdWVcIn07XG4gIH0pO1xuXG4gIGlmIChvcHQucHJvcGVydHlTZXRzKSBkbC5rZXlzKG9wdC5wcm9wZXJ0eVNldHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHNjaGVtYS5kZWZzLm1hcmsucHJvcGVydGllcy5wcm9wZXJ0aWVzLnByb3BlcnRpZXNba10gPSB7XCIkcmVmXCI6IFwiIy9kZWZzL3Byb3BzZXRcIn07XG4gIH0pO1xuXG4gIHJldHVybiBzY2hlbWE7XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBheHMgPSByZXF1aXJlKCcuLi9zY2VuZS9heGlzJyk7XG5cbnZhciBPUklFTlQgPSB7XG4gIFwieFwiOiAgICAgIFwiYm90dG9tXCIsXG4gIFwieVwiOiAgICAgIFwibGVmdFwiLFxuICBcInRvcFwiOiAgICBcInRvcFwiLFxuICBcImJvdHRvbVwiOiBcImJvdHRvbVwiLFxuICBcImxlZnRcIjogICBcImxlZnRcIixcbiAgXCJyaWdodFwiOiAgXCJyaWdodFwiXG59O1xuXG5mdW5jdGlvbiBwYXJzZUF4ZXMobW9kZWwsIHNwZWMsIGF4ZXMsIGdyb3VwKSB7XG4gIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcoKTtcbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgIGF4ZXNbaW5kZXhdID0gYXhlc1tpbmRleF0gfHwgYXhzKG1vZGVsKTtcbiAgICBwYXJzZUF4aXMoY29uZmlnLCBkZWYsIGluZGV4LCBheGVzW2luZGV4XSwgZ3JvdXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBeGlzKGNvbmZpZywgZGVmLCBpbmRleCwgYXhpcywgZ3JvdXApIHtcbiAgLy8gYXhpcyBzY2FsZVxuICBpZiAoZGVmLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBheGlzLnNjYWxlKGdyb3VwLnNjYWxlKGRlZi5zY2FsZSkpO1xuICB9XG5cbiAgLy8gYXhpcyBvcmllbnRhdGlvblxuICBheGlzLm9yaWVudChkZWYub3JpZW50IHx8IE9SSUVOVFtkZWYudHlwZV0pO1xuICAvLyBheGlzIG9mZnNldFxuICBheGlzLm9mZnNldChkZWYub2Zmc2V0IHx8IDApO1xuICAvLyBheGlzIGxheWVyXG4gIGF4aXMubGF5ZXIoZGVmLmxheWVyIHx8IFwiZnJvbnRcIik7XG4gIC8vIGF4aXMgZ3JpZCBsaW5lc1xuICBheGlzLmdyaWQoZGVmLmdyaWQgfHwgZmFsc2UpO1xuICAvLyBheGlzIHRpdGxlXG4gIGF4aXMudGl0bGUoZGVmLnRpdGxlIHx8IG51bGwpO1xuICAvLyBheGlzIHRpdGxlIG9mZnNldFxuICBheGlzLnRpdGxlT2Zmc2V0KGRlZi50aXRsZU9mZnNldCAhPSBudWxsID9cbiAgICBkZWYudGl0bGVPZmZzZXQgOiBjb25maWcuYXhpcy50aXRsZU9mZnNldCk7XG4gIC8vIGF4aXMgdmFsdWVzXG4gIGF4aXMudGlja1ZhbHVlcyhkZWYudmFsdWVzIHx8IG51bGwpO1xuICAvLyBheGlzIGxhYmVsIGZvcm1hdHRpbmdcbiAgYXhpcy50aWNrRm9ybWF0KGRlZi5mb3JtYXQgfHwgbnVsbCk7XG4gIGF4aXMudGlja0Zvcm1hdFR5cGUoZGVmLmZvcm1hdFR5cGUgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGljayBzdWJkaXZpc2lvblxuICBheGlzLnRpY2tTdWJkaXZpZGUoZGVmLnN1YmRpdmlkZSB8fCAwKTtcbiAgLy8gYXhpcyB0aWNrIHBhZGRpbmdcbiAgYXhpcy50aWNrUGFkZGluZyhkZWYudGlja1BhZGRpbmcgfHwgY29uZmlnLmF4aXMucGFkZGluZyk7XG5cbiAgLy8gYXhpcyB0aWNrIHNpemUocylcbiAgdmFyIHNpemUgPSBbXTtcbiAgaWYgKGRlZi50aWNrU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPDM7ICsraSkgc2l6ZS5wdXNoKGRlZi50aWNrU2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRzID0gY29uZmlnLmF4aXMudGlja1NpemU7XG4gICAgc2l6ZSA9IFt0cywgdHMsIHRzXTtcbiAgfVxuICBpZiAoZGVmLnRpY2tTaXplTWFqb3IgIT0gbnVsbCkgc2l6ZVswXSA9IGRlZi50aWNrU2l6ZU1ham9yO1xuICBpZiAoZGVmLnRpY2tTaXplTWlub3IgIT0gbnVsbCkgc2l6ZVsxXSA9IGRlZi50aWNrU2l6ZU1pbm9yO1xuICBpZiAoZGVmLnRpY2tTaXplRW5kICAgIT0gbnVsbCkgc2l6ZVsyXSA9IGRlZi50aWNrU2l6ZUVuZDtcbiAgaWYgKHNpemUubGVuZ3RoKSB7XG4gICAgYXhpcy50aWNrU2l6ZS5hcHBseShheGlzLCBzaXplKTtcbiAgfVxuXG4gIC8vIGF4aXMgdGljayBjb3VudFxuICBheGlzLnRpY2tDb3VudChkZWYudGlja3MgfHwgY29uZmlnLmF4aXMudGlja3MpO1xuXG4gIC8vIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHAgPSBkZWYucHJvcGVydGllcztcbiAgaWYgKHAgJiYgcC50aWNrcykge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwLm1ham9yVGlja3MgP1xuICAgICAgZGwuZXh0ZW5kKHt9LCBwLnRpY2tzLCBwLm1ham9yVGlja3MpIDogcC50aWNrcyk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAubWlub3JUaWNrcyA/XG4gICAgICBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWlub3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMocCAmJiBwLm1ham9yVGlja3MgfHwge30pO1xuICAgIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyhwICYmIHAubWlub3JUaWNrcyB8fCB7fSk7XG4gIH1cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzKHAgJiYgcC5sYWJlbHMgfHwge30pO1xuICBheGlzLnRpdGxlUHJvcGVydGllcyhwICYmIHAudGl0bGUgfHwge30pO1xuICBheGlzLmdyaWRMaW5lUHJvcGVydGllcyhwICYmIHAuZ3JpZCB8fCB7fSk7XG4gIGF4aXMuZG9tYWluUHJvcGVydGllcyhwICYmIHAuYXhpcyB8fCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VBeGVzOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpO1xuXG5mdW5jdGlvbiBwYXJzZUJnKGJnKSB7XG4gIC8vIHJldHVybiBudWxsIGlmIGlucHV0IGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gIGlmIChiZyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgLy8gcnVuIHRocm91Z2ggZDMgcmdiIHRvIHNhbml0eSBjaGVja1xuICByZXR1cm4gZDMucmdiKGJnKSArIFwiXCI7ICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUJnOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBwYXJzZVRyYW5zZm9ybXMgPSByZXF1aXJlKCcuL3RyYW5zZm9ybXMnKSxcbiAgICBwYXJzZU1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YShtb2RlbCwgc3BlYywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZygpLFxuICAgICAgY291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGxvYWRlZChkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbG9nLmVycm9yKCdMT0FESU5HIEZBSUxFRDogJyArIGQudXJsICsgJyAnICsgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuZGF0YShkLm5hbWUpLnZhbHVlcyhkbC5yZWFkKGRhdGEsIGQuZm9ybWF0KSk7XG4gICAgICB9XG4gICAgICBpZiAoLS1jb3VudCA9PT0gMCkgY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gcHJvY2VzcyBlYWNoIGRhdGEgc2V0IGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGlmIChkLnVybCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IGQudXJsfSwgY29uZmlnLmxvYWQpLCBsb2FkZWQoZCkpO1xuICAgIH1cbiAgICBwYXJzZURhdGEuZGF0YXNvdXJjZShtb2RlbCwgZCk7XG4gIH0pO1xuXG4gIGlmIChjb3VudCA9PT0gMCkgc2V0VGltZW91dChjYWxsYmFjaywgMSk7XG4gIHJldHVybiBzcGVjO1xufVxuXG5wYXJzZURhdGEuZGF0YXNvdXJjZSA9IGZ1bmN0aW9uKG1vZGVsLCBkKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSAoZC50cmFuc2Zvcm0gfHwgW10pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIHQpOyBcbiAgICAgIH0pLFxuICAgICAgbW9kID0gKGQubW9kaWZ5IHx8IFtdKS5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gcGFyc2VNb2RpZnkobW9kZWwsIG0sIGQpO1xuICAgICAgfSksXG4gICAgICBkcyA9IG1vZGVsLmRhdGEoZC5uYW1lLCBtb2QuY29uY2F0KHRyYW5zZm9ybSkpO1xuXG4gIGlmIChkLnZhbHVlcykge1xuICAgIGRzLnZhbHVlcyhkbC5yZWFkKGQudmFsdWVzLCBkLmZvcm1hdCkpO1xuICB9IGVsc2UgaWYgKGQuc291cmNlKSB7XG4gICAgLy8gRGVyaXZlZCBkcyB3aWxsIGJlIHB1bHNlZCBieSBpdHMgc3JjIHJhdGhlciB0aGFuIHRoZSBtb2RlbC5cbiAgICBkcy5zb3VyY2UoZC5zb3VyY2UpLmFkZExpc3RlbmVyKGRzKTsgIFxuICAgIG1vZGVsLnJlbW92ZUxpc3RlbmVyKGRzLnBpcGVsaW5lKClbMF0pOyBcbiAgfVxuXG4gIHJldHVybiBkczsgICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlRGF0YTsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgLypcbiAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC5cbiAgICpcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICAgKi9cblxuICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICAgIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XG4gICAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xuXG4gICAgdGhpcy5uYW1lICAgICA9IFwiU3ludGF4RXJyb3JcIjtcbiAgfVxuXG4gIHBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXG4gICAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBzdGFydDogcGVnJHBhcnNlc3RhcnQgfSxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXN0YXJ0LFxuXG4gICAgICAgIHBlZyRjMCA9IHBlZyRGQUlMRUQsXG4gICAgICAgIHBlZyRjMSA9IFwiLFwiLFxuICAgICAgICBwZWckYzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMyA9IGZ1bmN0aW9uKG8sIG0pIHsgcmV0dXJuIFtvXS5jb25jYXQobSk7IH0sXG4gICAgICAgIHBlZyRjNCA9IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFtvXTsgfSxcbiAgICAgICAgcGVnJGM1ID0gXCJbXCIsXG4gICAgICAgIHBlZyRjNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3ID0gXCJdXCIsXG4gICAgICAgIHBlZyRjOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM5ID0gXCI+XCIsXG4gICAgICAgIHBlZyRjMTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTEgPSBmdW5jdGlvbihmMSwgZjIsIG8pIHsgcmV0dXJuIHtzdGFydDogZjEsIGVuZDogZjIsIG1pZGRsZTogb307IH0sXG4gICAgICAgIHBlZyRjMTIgPSBbXSxcbiAgICAgICAgcGVnJGMxMyA9IGZ1bmN0aW9uKHMsIGYpIHsgcmV0dXJuIChzLmZpbHRlcnMgPSBmLCBzKTsgfSxcbiAgICAgICAgcGVnJGMxNCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHM7IH0sXG4gICAgICAgIHBlZyRjMTUgPSBcIihcIixcbiAgICAgICAgcGVnJGMxNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxNyA9IFwiKVwiLFxuICAgICAgICBwZWckYzE4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKVxcXCJcIiB9LFxuICAgICAgICBwZWckYzE5ID0gZnVuY3Rpb24obSkgeyByZXR1cm4ge3N0cmVhbTogbX07IH0sXG4gICAgICAgIHBlZyRjMjAgPSBcIkBcIixcbiAgICAgICAgcGVnJGMyMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkBcIiwgZGVzY3JpcHRpb246IFwiXFxcIkBcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyMiA9IFwiOlwiLFxuICAgICAgICBwZWckYzIzID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgICBwZWckYzI0ID0gZnVuY3Rpb24obiwgZSkgeyByZXR1cm4ge2V2ZW50OiBlLCBuYW1lOiBufTsgfSxcbiAgICAgICAgcGVnJGMyNSA9IGZ1bmN0aW9uKG0sIGUpIHsgcmV0dXJuIHtldmVudDogZSwgbWFyazogbX07IH0sXG4gICAgICAgIHBlZyRjMjYgPSBmdW5jdGlvbih0LCBlKSB7IHJldHVybiB7ZXZlbnQ6IGUsIHRhcmdldDogdH07IH0sXG4gICAgICAgIHBlZyRjMjcgPSBmdW5jdGlvbihlKSB7IHJldHVybiB7ZXZlbnQ6IGV9OyB9LFxuICAgICAgICBwZWckYzI4ID0gZnVuY3Rpb24ocykgeyByZXR1cm4ge3NpZ25hbDogc307IH0sXG4gICAgICAgIHBlZyRjMjkgPSBcInJlY3RcIixcbiAgICAgICAgcGVnJGMzMCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJlY3RcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlY3RcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzMSA9IFwic3ltYm9sXCIsXG4gICAgICAgIHBlZyRjMzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzeW1ib2xcIiwgZGVzY3JpcHRpb246IFwiXFxcInN5bWJvbFxcXCJcIiB9LFxuICAgICAgICBwZWckYzMzID0gXCJwYXRoXCIsXG4gICAgICAgIHBlZyRjMzQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwYXRoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwYXRoXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMzUgPSBcImFyY1wiLFxuICAgICAgICBwZWckYzM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXJjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhcmNcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzNyA9IFwiYXJlYVwiLFxuICAgICAgICBwZWckYzM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXJlYVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXJlYVxcXCJcIiB9LFxuICAgICAgICBwZWckYzM5ID0gXCJsaW5lXCIsXG4gICAgICAgIHBlZyRjNDAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJsaW5lXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJsaW5lXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDEgPSBcInJ1bGVcIixcbiAgICAgICAgcGVnJGM0MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJ1bGVcIiwgZGVzY3JpcHRpb246IFwiXFxcInJ1bGVcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0MyA9IFwiaW1hZ2VcIixcbiAgICAgICAgcGVnJGM0NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImltYWdlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpbWFnZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzQ1ID0gXCJ0ZXh0XCIsXG4gICAgICAgIHBlZyRjNDYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0ZXh0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0ZXh0XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDcgPSBcImdyb3VwXCIsXG4gICAgICAgIHBlZyRjNDggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJncm91cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZ3JvdXBcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0OSA9IFwibW91c2Vkb3duXCIsXG4gICAgICAgIHBlZyRjNTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlZG93blxcXCJcIiB9LFxuICAgICAgICBwZWckYzUxID0gXCJtb3VzZXVwXCIsXG4gICAgICAgIHBlZyRjNTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZXVwXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTMgPSBcImNsaWNrXCIsXG4gICAgICAgIHBlZyRjNTQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJjbGlja1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiY2xpY2tcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1NSA9IFwiZGJsY2xpY2tcIixcbiAgICAgICAgcGVnJGM1NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRibGNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkYmxjbGlja1xcXCJcIiB9LFxuICAgICAgICBwZWckYzU3ID0gXCJ3aGVlbFwiLFxuICAgICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwid2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIndoZWVsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTkgPSBcImtleWRvd25cIixcbiAgICAgICAgcGVnJGM2MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcImtleWRvd25cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2MSA9IFwia2V5cHJlc3NcIixcbiAgICAgICAgcGVnJGM2MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleXByZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXlwcmVzc1xcXCJcIiB9LFxuICAgICAgICBwZWckYzYzID0gXCJrZXl1cFwiLFxuICAgICAgICBwZWckYzY0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5dXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXVwXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNjUgPSBcIm1vdXNld2hlZWxcIixcbiAgICAgICAgcGVnJGM2NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNld2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNld2hlZWxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2NyA9IFwibW91c2Vtb3ZlXCIsXG4gICAgICAgIHBlZyRjNjggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlbW92ZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzY5ID0gXCJtb3VzZW91dFwiLFxuICAgICAgICBwZWckYzcwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdXRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3V0XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNzEgPSBcIm1vdXNlb3ZlclwiLFxuICAgICAgICBwZWckYzcyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdmVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW92ZXJcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3MyA9IFwibW91c2VlbnRlclwiLFxuICAgICAgICBwZWckYzc0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VlbnRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VlbnRlclxcXCJcIiB9LFxuICAgICAgICBwZWckYzc1ID0gXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIHBlZyRjNzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaHN0YXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaHN0YXJ0XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNzcgPSBcInRvdWNobW92ZVwiLFxuICAgICAgICBwZWckYzc4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2htb3ZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaG1vdmVcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3OSA9IFwidG91Y2hlbmRcIixcbiAgICAgICAgcGVnJGM4MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoZW5kXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaGVuZFxcXCJcIiB9LFxuICAgICAgICBwZWckYzgxID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSxcbiAgICAgICAgcGVnJGM4MiA9IC9eW2EtekEtWjAtOV9cXC1dLyxcbiAgICAgICAgcGVnJGM4MyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05X1xcXFwtXVwiIH0sXG4gICAgICAgIHBlZyRjODQgPSBmdW5jdGlvbihuKSB7IHJldHVybiBuLmpvaW4oXCJcIik7IH0sXG4gICAgICAgIHBlZyRjODUgPSAvXlthLXpBLVowLTlcXC1fICAjLj4rfltcXF09fFxcXiQqXS8sXG4gICAgICAgIHBlZyRjODYgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOVxcXFwtXyAgIy4+K35bXFxcXF09fFxcXFxeJCpdXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTlcXFxcLV8gICMuPit+W1xcXFxdPXxcXFxcXiQqXVwiIH0sXG4gICAgICAgIHBlZyRjODcgPSBmdW5jdGlvbihjKSB7IHJldHVybiBjLmpvaW4oXCJcIik7IH0sXG4gICAgICAgIHBlZyRjODggPSAvXlsnXCJhLXpBLVowLTlfKCkuPjw9ISBcXHQtJnx+XS8sXG4gICAgICAgIHBlZyRjODkgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWydcXFwiYS16QS1aMC05XygpLj48PSEgXFxcXHQtJnx+XVwiLCBkZXNjcmlwdGlvbjogXCJbJ1xcXCJhLXpBLVowLTlfKCkuPjw9ISBcXFxcdC0mfH5dXCIgfSxcbiAgICAgICAgcGVnJGM5MCA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuam9pbihcIlwiKTsgfSxcbiAgICAgICAgcGVnJGM5MSA9IC9eWyBcXHRcXHJcXG5dLyxcbiAgICAgICAgcGVnJGM5MiA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiwgZGVzY3JpcHRpb246IFwiWyBcXFxcdFxcXFxyXFxcXG5dXCIgfSxcblxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0YXJ0KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBzMCA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWVyZ2VkKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzMoczEsIHM1KTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNChzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW9yZGVyZWQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMCwgczExLCBzMTIsIHMxMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgICAgczEgPSBwZWckYzU7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJGMxO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckYzc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTEoczMsIHM3LCBzMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyZWQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXN0cmVhbSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTMoczEsIHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxNChzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmVhbSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgIHMxID0gcGVnJGMxNTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMxNztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMxOShzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIxKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlbmFtZSgpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRjMjI7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWV2ZW50VHlwZSgpO1xuICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjQoczIsIHM0KTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZW1hcmtUeXBlKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJGMyMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlZXZlbnRUeXBlKCk7XG4gICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNShzMSwgczMpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vjc3MoKTtcbiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckYzIyO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZWV2ZW50VHlwZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjYoczEsIHMzKTtcbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VldmVudFR5cGUoKTtcbiAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzI3KHMxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjgoczEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtYXJrVHlwZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMjkpIHtcbiAgICAgICAgczAgPSBwZWckYzI5O1xuICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMzEpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjMzE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzMzKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMzM7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzQpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjMzUpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzM1O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzYpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMzcpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMzc7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM4KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzM5KSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMzk7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDApOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjNDEpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQxO1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDIpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDM7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ0KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VldmVudFR5cGUoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzQ5KSB7XG4gICAgICAgIHMwID0gcGVnJGM0OTtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUwKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzUxKSB7XG4gICAgICAgICAgczAgPSBwZWckYzUxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM1Mykge1xuICAgICAgICAgICAgczAgPSBwZWckYzUzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU0KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzU1KSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGM1NTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzU3KSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzU3O1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGM1OSkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU5O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYwKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzYxKSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2MTtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYyKTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYzO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjYpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjgpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzcxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzIpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzczKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM3MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNzU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3Nik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM3Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzc3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzc4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzc5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM3OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICBzMSA9IHBlZyRjNTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VleHByKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGM3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjODEoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5hbWUoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBpZiAocGVnJGM4Mi50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgzKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIGlmIChwZWckYzgyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Myk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjODQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNzcygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzg1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjODUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM4NyhzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZXhwcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzg4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODkpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjODgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg5KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM5MChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2VwKCkge1xuICAgICAgdmFyIHMwLCBzMTtcblxuICAgICAgczAgPSBbXTtcbiAgICAgIGlmIChwZWckYzkxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOTIpOyB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAucHVzaChzMSk7XG4gICAgICAgIGlmIChwZWckYzkxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkyKTsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgICBwYXJzZTogICAgICAgcGFyc2VcbiAgfTtcbn0pKCk7IiwidmFyIGV4cHIgPSByZXF1aXJlKCd2ZWdhLWV4cHJlc3Npb24nKSxcbiAgICBhcmdzID0gWydkYXR1bScsICdldmVudCcsICdzaWduYWxzJ107XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwci5jb21waWxlcihhcmdzLCB7XG4gIGlkV2hpdGVMaXN0OiBhcmdzLFxuICBmaWVsZFZhcjogICAgYXJnc1swXSxcbiAgZ2xvYmFsVmFyOiAgIGFyZ3NbMl0sXG4gIGZ1bmN0aW9uczogICBmdW5jdGlvbihjb2RlZ2VuKSB7XG4gICAgdmFyIGZuID0gZXhwci5mdW5jdGlvbnMoY29kZWdlbik7XG4gICAgZm4uZXZlbnRJdGVtID0gZnVuY3Rpb24oKSB7IHJldHVybiAnZXZlbnQudmcuaXRlbSc7IH07XG4gICAgZm4uZXZlbnRHcm91cCA9ICdldmVudC52Zy5nZXRHcm91cCc7XG4gICAgZm4uZXZlbnRYID0gJ2V2ZW50LnZnLmdldFgnO1xuICAgIGZuLmV2ZW50WSA9ICdldmVudC52Zy5nZXRZJztcbiAgICBmbi5vcGVuID0gJ3dpbmRvdy5vcGVuJztcbiAgICByZXR1cm4gZm47XG4gIH1cbn0pOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBheGVzOiByZXF1aXJlKCcuL2F4ZXMnKSxcbiAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi9iYWNrZ3JvdW5kJyksXG4gIGRhdGE6IHJlcXVpcmUoJy4vZGF0YScpLFxuICBldmVudHM6IHJlcXVpcmUoJy4vZXZlbnRzJyksXG4gIGV4cHI6IHJlcXVpcmUoJy4vZXhwcicpLFxuICBsZWdlbmRzOiByZXF1aXJlKCcuL2xlZ2VuZHMnKSxcbiAgbWFyazogcmVxdWlyZSgnLi9tYXJrJyksXG4gIG1hcmtzOiByZXF1aXJlKCcuL21hcmtzJyksXG4gIG1vZGlmeTogcmVxdWlyZSgnLi9tb2RpZnknKSxcbiAgcGFkZGluZzogcmVxdWlyZSgnLi9wYWRkaW5nJyksXG4gIHByZWRpY2F0ZXM6IHJlcXVpcmUoJy4vcHJlZGljYXRlcycpLFxuICBwcm9wZXJ0aWVzOiByZXF1aXJlKCcuL3Byb3BlcnRpZXMnKSxcbiAgc2lnbmFsczogcmVxdWlyZSgnLi9zaWduYWxzJyksXG4gIHNwZWM6IHJlcXVpcmUoJy4vc3BlYycpLFxuICBzdHJlYW1zOiByZXF1aXJlKCcuL3N0cmVhbXMnKSxcbiAgdHJhbnNmb3JtczogcmVxdWlyZSgnLi90cmFuc2Zvcm1zJylcbn07IiwidmFyIGxnbmQgPSByZXF1aXJlKCcuLi9zY2VuZS9sZWdlbmQnKTtcblxuZnVuY3Rpb24gcGFyc2VMZWdlbmRzKG1vZGVsLCBzcGVjLCBsZWdlbmRzLCBncm91cCkge1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgbGVnZW5kc1tpbmRleF0gPSBsZWdlbmRzW2luZGV4XSB8fCBsZ25kKG1vZGVsKTtcbiAgICBwYXJzZUxlZ2VuZChkZWYsIGluZGV4LCBsZWdlbmRzW2luZGV4XSwgZ3JvdXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMZWdlbmQoZGVmLCBpbmRleCwgbGVnZW5kLCBncm91cCkge1xuICAvLyBsZWdlbmQgc2NhbGVzXG4gIGxlZ2VuZC5zaXplICAoZGVmLnNpemUgICA/IGdyb3VwLnNjYWxlKGRlZi5zaXplKSAgIDogbnVsbCk7XG4gIGxlZ2VuZC5zaGFwZSAoZGVmLnNoYXBlICA/IGdyb3VwLnNjYWxlKGRlZi5zaGFwZSkgIDogbnVsbCk7XG4gIGxlZ2VuZC5maWxsICAoZGVmLmZpbGwgICA/IGdyb3VwLnNjYWxlKGRlZi5maWxsKSAgIDogbnVsbCk7XG4gIGxlZ2VuZC5zdHJva2UoZGVmLnN0cm9rZSA/IGdyb3VwLnNjYWxlKGRlZi5zdHJva2UpIDogbnVsbCk7XG5cbiAgLy8gbGVnZW5kIG9yaWVudGF0aW9uXG4gIGlmIChkZWYub3JpZW50KSBsZWdlbmQub3JpZW50KGRlZi5vcmllbnQpO1xuXG4gIC8vIGxlZ2VuZCBvZmZzZXRcbiAgaWYgKGRlZi5vZmZzZXQgIT0gbnVsbCkgbGVnZW5kLm9mZnNldChkZWYub2Zmc2V0KTtcblxuICAvLyBsZWdlbmQgdGl0bGVcbiAgbGVnZW5kLnRpdGxlKGRlZi50aXRsZSB8fCBudWxsKTtcblxuICAvLyBsZWdlbmQgdmFsdWVzXG4gIGxlZ2VuZC52YWx1ZXMoZGVmLnZhbHVlcyB8fCBudWxsKTtcblxuICAvLyBsZWdlbmQgbGFiZWwgZm9ybWF0dGluZ1xuICBsZWdlbmQuZm9ybWF0KGRlZi5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IGRlZi5mb3JtYXQgOiBudWxsKTtcblxuICAvLyBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciBwID0gZGVmLnByb3BlcnRpZXM7XG4gIGxlZ2VuZC50aXRsZVByb3BlcnRpZXMocCAmJiBwLnRpdGxlIHx8IHt9KTtcbiAgbGVnZW5kLmxhYmVsUHJvcGVydGllcyhwICYmIHAubGFiZWxzIHx8IHt9KTtcbiAgbGVnZW5kLmxlZ2VuZFByb3BlcnRpZXMocCAmJiBwLmxlZ2VuZCB8fCB7fSk7XG4gIGxlZ2VuZC5zeW1ib2xQcm9wZXJ0aWVzKHAgJiYgcC5zeW1ib2xzIHx8IHt9KTtcbiAgbGVnZW5kLmdyYWRpZW50UHJvcGVydGllcyhwICYmIHAuZ3JhZGllbnQgfHwge30pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlTGVnZW5kczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzJyk7XG5cbmZ1bmN0aW9uIHBhcnNlTWFyayhtb2RlbCwgbWFyaykge1xuICB2YXIgcHJvcHMgPSBtYXJrLnByb3BlcnRpZXMsXG4gICAgICBncm91cCA9IG1hcmsubWFya3M7XG5cbiAgLy8gcGFyc2UgbWFyayBwcm9wZXJ0eSBkZWZpbml0aW9uc1xuICBkbC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBwcm9wc1trXSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCBwcm9wc1trXSk7XG4gIH0pO1xuXG4gIC8vIHBhcnNlIGRlbGF5IGZ1bmN0aW9uXG4gIGlmIChtYXJrLmRlbGF5KSB7XG4gICAgbWFyay5kZWxheSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCB7ZGVsYXk6IG1hcmsuZGVsYXl9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2UgaWYgZ3JvdXAgdHlwZVxuICBpZiAoZ3JvdXApIHtcbiAgICBtYXJrLm1hcmtzID0gZ3JvdXAubWFwKGZ1bmN0aW9uKGcpIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgZyk7IH0pO1xuICB9XG4gICAgXG4gIHJldHVybiBtYXJrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlTWFyazsiLCJ2YXIgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi9tYXJrJyk7XG5cbmZ1bmN0aW9uIHBhcnNlUm9vdE1hcmsobW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHNjYWxlczogc3BlYy5zY2FsZXMgfHwgW10sXG4gICAgYXhlczogc3BlYy5heGVzIHx8IFtdLFxuICAgIGxlZ2VuZHM6IHNwZWMubGVnZW5kcyB8fCBbXSxcbiAgICBtYXJrczogKHNwZWMubWFya3MgfHwgW10pLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlUm9vdE1hcms7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIE5vZGUgPSBkZi5Ob2RlLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXM7XG5cbnZhciBUeXBlcyA9IHtcbiAgSU5TRVJUOiBcImluc2VydFwiLFxuICBSRU1PVkU6IFwicmVtb3ZlXCIsXG4gIFRPR0dMRTogXCJ0b2dnbGVcIixcbiAgQ0xFQVI6ICBcImNsZWFyXCJcbn07XG5cbnZhciBFTVBUWSA9IFtdO1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBzcmMsIGRlc3QpIHtcbiAgZm9yKHZhciBpID0gc3JjLmxlbmd0aC0xOyBpID49IDA7IC0taSkge1xuICAgIGlmIChzcmNbaV1bZmllbGRdID09IHZhbHVlKVxuICAgICAgZGVzdC5wdXNoLmFwcGx5KGRlc3QsIHNyYy5zcGxpY2UoaSwgMSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmeShtb2RlbCwgZGVmLCBkcykge1xuICB2YXIgc2lnbmFsID0gZGVmLnNpZ25hbCA/IGRsLmZpZWxkKGRlZi5zaWduYWwpIDogbnVsbCwgXG4gICAgICBzaWduYWxOYW1lID0gc2lnbmFsID8gc2lnbmFsWzBdIDogbnVsbCxcbiAgICAgIHByZWRpY2F0ZSA9IGRlZi5wcmVkaWNhdGUgPyBtb2RlbC5wcmVkaWNhdGUoZGVmLnByZWRpY2F0ZS5uYW1lIHx8IGRlZi5wcmVkaWNhdGUpIDogbnVsbCxcbiAgICAgIHJlZXZhbCA9IChwcmVkaWNhdGUgPT09IG51bGwpLFxuICAgICAgbm9kZSA9IG5ldyBOb2RlKG1vZGVsKS5yb3V0ZXIoZGVmLnR5cGUgPT09IFR5cGVzLkNMRUFSKTtcblxuICBub2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAocHJlZGljYXRlICE9PSBudWxsKSB7ICAvLyBUT0RPOiBwcmVkaWNhdGUgYXJnc1xuICAgICAgdmFyIGRiID0gbW9kZWwudmFsdWVzKERlcHMuREFUQSwgcHJlZGljYXRlLmRhdGEgfHwgRU1QVFkpLFxuICAgICAgICAgIHNnID0gbW9kZWwudmFsdWVzKERlcHMuU0lHTkFMUywgcHJlZGljYXRlLnNpZ25hbHMgfHwgRU1QVFkpO1xuICAgICAgcmVldmFsID0gcHJlZGljYXRlLmNhbGwocHJlZGljYXRlLCB7fSwgZGIsIHNnLCBtb2RlbC5fcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgbG9nLmRlYnVnKGlucHV0LCBbZGVmLnR5cGUrXCJpbmdcIiwgcmVldmFsXSk7XG4gICAgaWYgKCFyZWV2YWwpIHJldHVybiBpbnB1dDtcblxuICAgIHZhciBkYXR1bSA9IHt9LCBcbiAgICAgICAgdmFsdWUgPSBzaWduYWwgPyBtb2RlbC5zaWduYWxSZWYoZGVmLnNpZ25hbCkgOiBudWxsLFxuICAgICAgICBkID0gbW9kZWwuZGF0YShkcy5uYW1lKSxcbiAgICAgICAgdCA9IG51bGw7XG5cbiAgICBkYXR1bVtkZWYuZmllbGRdID0gdmFsdWU7XG5cbiAgICAvLyBXZSBoYXZlIHRvIG1vZGlmeSBkcy5fZGF0YSBzbyB0aGF0IHN1YnNlcXVlbnQgcHVsc2VzIGNvbnRhaW5cbiAgICAvLyBvdXIgZHluYW1pYyBkYXRhLiBXL28gbW9kaWZ5aW5nIGRzLl9kYXRhLCBvbmx5IHRoZSBvdXRwdXRcbiAgICAvLyBjb2xsZWN0b3Igd2lsbCBjb250YWluIGR5bmFtaWMgdHVwbGVzLiBcbiAgICBpZiAoZGVmLnR5cGUgPT09IFR5cGVzLklOU0VSVCkge1xuICAgICAgdCA9IFR1cGxlLmluZ2VzdChkYXR1bSk7XG4gICAgICBpbnB1dC5hZGQucHVzaCh0KTtcbiAgICAgIGQuX2RhdGEucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYgKGRlZi50eXBlID09PSBUeXBlcy5SRU1PVkUpIHtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIGlucHV0LnJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCBpbnB1dC5yZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZGVmLmZpZWxkXSAhPT0gdmFsdWU7IH0pO1xuICAgIH0gZWxzZSBpZiAoZGVmLnR5cGUgPT09IFR5cGVzLlRPR0dMRSkge1xuICAgICAgdmFyIGFkZCA9IFtdLCByZW0gPSBbXTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5yZW0sIGFkZCk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQuYWRkLCByZW0pO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0Lm1vZCwgcmVtKTtcbiAgICAgIGlmICghKGFkZC5sZW5ndGggfHwgcmVtLmxlbmd0aCkpIGFkZC5wdXNoKFR1cGxlLmluZ2VzdChkYXR1bSkpO1xuXG4gICAgICBpbnB1dC5hZGQucHVzaC5hcHBseShpbnB1dC5hZGQsIGFkZCk7XG4gICAgICBkLl9kYXRhLnB1c2guYXBwbHkoZC5fZGF0YSwgYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgcmVtKTtcbiAgICAgIGQuX2RhdGEgPSBkLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW0uaW5kZXhPZih4KSA9PT0gLTE7IH0pO1xuICAgIH0gZWxzZSBpZiAoZGVmLnR5cGUgPT09IFR5cGVzLkNMRUFSKSB7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0LmFkZCk7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0Lm1vZCk7XG4gICAgICBpbnB1dC5hZGQgPSBbXTtcbiAgICAgIGlucHV0Lm1vZCA9IFtdO1xuICAgICAgZC5fZGF0YSAgPSBbXTtcbiAgICB9IFxuXG4gICAgaW5wdXQuZmllbGRzW2RlZi5maWVsZF0gPSAxO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICBpZiAoc2lnbmFsTmFtZSkgbm9kZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgc2lnbmFsTmFtZSk7XG4gIFxuICBpZiAocHJlZGljYXRlKSB7XG4gICAgbm9kZS5kZXBlbmRlbmN5KERlcHMuREFUQSwgcHJlZGljYXRlLmRhdGEpO1xuICAgIG5vZGUuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMsIHByZWRpY2F0ZS5zaWduYWxzKTtcbiAgfVxuICBcbiAgcmV0dXJuIG5vZGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VNb2RpZnk7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcocGFkKSB7XG4gIGlmIChwYWQgPT0gbnVsbCkgcmV0dXJuIFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyhwYWQpKSByZXR1cm4gcGFkPT09XCJzdHJpY3RcIiA/IFwic3RyaWN0XCIgOiBcImF1dG9cIjtcbiAgZWxzZSBpZiAoZGwuaXNPYmplY3QocGFkKSkgcmV0dXJuIHBhZDtcbiAgdmFyIHAgPSBkbC5pc051bWJlcihwYWQpID8gcGFkIDogMjA7XG4gIHJldHVybiB7dG9wOnAsIGxlZnQ6cCwgcmlnaHQ6cCwgYm90dG9tOnB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlUGFkZGluZzsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbnZhciB0eXBlcyA9IHtcbiAgJz0nOiAgIHBhcnNlQ29tcGFyYXRvcixcbiAgJz09JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgJyE9JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgJz4nOiAgIHBhcnNlQ29tcGFyYXRvcixcbiAgJz49JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgJzwnOiAgIHBhcnNlQ29tcGFyYXRvcixcbiAgJzw9JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgJ2FuZCc6IHBhcnNlTG9naWNhbCxcbiAgJyYmJzogIHBhcnNlTG9naWNhbCxcbiAgJ29yJzogIHBhcnNlTG9naWNhbCxcbiAgJ3x8JzogIHBhcnNlTG9naWNhbCxcbiAgJ2luJzogIHBhcnNlSW5cbn07XG5cbnZhciBudWxsU2NhbGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5udWxsU2NhbGUuaW52ZXJ0ID0gbnVsbFNjYWxlO1xuXG5mdW5jdGlvbiBwYXJzZVByZWRpY2F0ZXMobW9kZWwsIHNwZWMpIHtcbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBwYXJzZSA9IHR5cGVzW3MudHlwZV0obW9kZWwsIHMpO1xuICAgIFxuICAgIC8qIGpzaGludCBldmlsOnRydWUgKi9cbiAgICB2YXIgcHJlZCAgPSBGdW5jdGlvbihcImFyZ3NcIiwgXCJkYlwiLCBcInNpZ25hbHNcIiwgXCJwcmVkaWNhdGVzXCIsIHBhcnNlLmNvZGUpO1xuICAgIHByZWQucm9vdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kZWwuc2NlbmUoKS5pdGVtc1swXTsgfTsgLy8gRm9yIGdsb2JhbCBzY2FsZXNcbiAgICBwcmVkLm51bGxTY2FsZSA9IG51bGxTY2FsZTtcbiAgICBwcmVkLmlzRnVuY3Rpb24gPSBkbC5pc0Z1bmN0aW9uO1xuICAgIHByZWQuc2lnbmFscyA9IHBhcnNlLnNpZ25hbHM7XG4gICAgcHJlZC5kYXRhID0gcGFyc2UuZGF0YTtcblxuICAgIG1vZGVsLnByZWRpY2F0ZShzLm5hbWUsIHByZWQpO1xuICB9KTtcblxuICByZXR1cm4gc3BlYztcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduYWwoc2lnbmFsLCBzaWduYWxzKSB7XG4gIHZhciBzID0gZGwuZmllbGQoc2lnbmFsKSxcbiAgICAgIGNvZGUgPSBcInNpZ25hbHNbXCIrcy5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCI7XG4gIHNpZ25hbHNbc1swXV0gPSAxO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VPcGVyYW5kcyhtb2RlbCwgb3BlcmFuZHMpIHtcbiAgdmFyIGRlY2wgPSBbXSwgZGVmcyA9IFtdLFxuICAgICAgc2lnbmFscyA9IHt9LCBkYiA9IHt9O1xuXG4gIGZ1bmN0aW9uIHNldFNpZ25hbChzKSB7IHNpZ25hbHNbc10gPSAxOyB9XG4gIGZ1bmN0aW9uIHNldERhdGEoZCkgeyBkYltkXSA9IDE7IH1cblxuICBkbC5hcnJheShvcGVyYW5kcykuZm9yRWFjaChmdW5jdGlvbihvLCBpKSB7XG4gICAgdmFyIG5hbWUgPSBcIm9cIiArIGksXG4gICAgICAgIGRlZiA9IFwiXCI7XG5cbiAgICBpZiAoby52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWYgPSBkbC5zdHIoby52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChvLmFyZykge1xuICAgICAgZGVmID0gXCJhcmdzW1wiK2RsLnN0cihvLmFyZykrXCJdXCI7XG4gICAgfSBlbHNlIGlmIChvLnNpZ25hbCkge1xuICAgICAgZGVmID0gcGFyc2VTaWduYWwoby5zaWduYWwsIHNpZ25hbHMpO1xuICAgIH0gZWxzZSBpZiAoby5wcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZWYgPSBvLnByZWRpY2F0ZSxcbiAgICAgICAgICBwcmVkTmFtZSA9IHJlZiAmJiAocmVmLm5hbWUgfHwgcmVmKSxcbiAgICAgICAgICBwcmVkID0gbW9kZWwucHJlZGljYXRlKHByZWROYW1lKSxcbiAgICAgICAgICBwID0gXCJwcmVkaWNhdGVzW1wiK2RsLnN0cihwcmVkTmFtZSkrXCJdXCI7XG5cbiAgICAgIHByZWQuc2lnbmFscy5mb3JFYWNoKHNldFNpZ25hbCk7XG4gICAgICBwcmVkLmRhdGEuZm9yRWFjaChzZXREYXRhKTtcblxuICAgICAgaWYgKGRsLmlzT2JqZWN0KHJlZikpIHtcbiAgICAgICAgZGwua2V5cyhyZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgIGlmIChrID09PSBcIm5hbWVcIikgcmV0dXJuO1xuICAgICAgICAgIHZhciBpID0gcmVmW2tdO1xuICAgICAgICAgIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGspK1wiXSA9IFwiO1xuICAgICAgICAgIGlmIChpLnNpZ25hbCkge1xuICAgICAgICAgICAgZGVmICs9IHBhcnNlU2lnbmFsKGkuc2lnbmFsLCBzaWduYWxzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkuYXJnKSB7XG4gICAgICAgICAgICBkZWYgKz0gXCJhcmdzW1wiK2RsLnN0cihpLmFyZykrXCJdXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZiArPSBcIiwgXCI7XG4gICAgICAgIH0pOyAgXG4gICAgICB9IFxuXG4gICAgICBkZWYgKz0gcCtcIi5jYWxsKFwiK3ArXCIsIGFyZ3MsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKVwiO1xuICAgIH1cblxuICAgIGRlY2wucHVzaChuYW1lKTtcbiAgICBkZWZzLnB1c2gobmFtZStcIj0oXCIrZGVmK1wiKVwiKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBcInZhciBcIiArIGRlY2wuam9pbihcIiwgXCIpICsgXCI7XFxuXCIgKyBkZWZzLmpvaW4oXCI7XFxuXCIpICsgXCI7XFxuXCIsXG4gICAgc2lnbmFsczogZGwua2V5cyhzaWduYWxzKSxcbiAgICBkYXRhOiBkbC5rZXlzKGRiKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IobW9kZWwsIHNwZWMpIHtcbiAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMobW9kZWwsIHNwZWMub3BlcmFuZHMpO1xuICBpZiAoc3BlYy50eXBlID09PSAnPScpIHNwZWMudHlwZSA9ICc9PSc7XG5cbiAgb3BzLmNvZGUgKz0gXCJvMCA9IG8wIGluc3RhbmNlb2YgRGF0ZSA/IG8wLmdldFRpbWUoKSA6IG8wO1xcblwiICtcbiAgICBcIm8xID0gbzEgaW5zdGFuY2VvZiBEYXRlID8gbzEuZ2V0VGltZSgpIDogbzE7XFxuXCI7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBvcHMuY29kZSArIFwicmV0dXJuIFwiICsgW1wibzBcIiwgXCJvMVwiXS5qb2luKHNwZWMudHlwZSkgKyBcIjtcIixcbiAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICBkYXRhOiBvcHMuZGF0YVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxvZ2ljYWwobW9kZWwsIHNwZWMpIHtcbiAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMobW9kZWwsIHNwZWMub3BlcmFuZHMpLFxuICAgICAgbyA9IFtdLCBpID0gMCwgbGVuID0gc3BlYy5vcGVyYW5kcy5sZW5ndGg7XG5cbiAgd2hpbGUgKG8ucHVzaChcIm9cIitpKyspIDwgbGVuKTtcbiAgaWYgKHNwZWMudHlwZSA9PT0gJ2FuZCcpIHNwZWMudHlwZSA9ICcmJic7XG4gIGVsc2UgaWYgKHNwZWMudHlwZSA9PT0gJ29yJykgc3BlYy50eXBlID0gJ3x8JztcblxuICByZXR1cm4ge1xuICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBvLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLFxuICAgIGRhdGE6IG9wcy5kYXRhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW4obW9kZWwsIHNwZWMpIHtcbiAgdmFyIG8gPSBbc3BlYy5pdGVtXSwgY29kZSA9IFwiXCI7XG4gIGlmIChzcGVjLnJhbmdlKSBvLnB1c2guYXBwbHkobywgc3BlYy5yYW5nZSk7XG4gIGlmIChzcGVjLnNjYWxlKSB7XG4gICAgY29kZSA9IHBhcnNlU2NhbGUoc3BlYy5zY2FsZSwgbyk7XG4gIH1cblxuICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhtb2RlbCwgbyk7XG4gIGNvZGUgPSBvcHMuY29kZSArIGNvZGUgKyBcIlxcbiAgdmFyIG9yZFNldCA9IG51bGw7XFxuXCI7XG5cbiAgaWYgKHNwZWMuZGF0YSkge1xuICAgIHZhciBmaWVsZCA9IGRsLmZpZWxkKHNwZWMuZmllbGQpLm1hcChkbC5zdHIpO1xuICAgIGNvZGUgKz0gXCJ2YXIgd2hlcmUgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkW1wiK2ZpZWxkLmpvaW4oXCJdW1wiKStcIl0gPT0gbzAgfTtcXG5cIjtcbiAgICBjb2RlICs9IFwicmV0dXJuIGRiW1wiK2RsLnN0cihzcGVjLmRhdGEpK1wiXS5maWx0ZXIod2hlcmUpLmxlbmd0aCA+IDA7XCI7XG4gIH0gZWxzZSBpZiAoc3BlYy5yYW5nZSkge1xuICAgIC8vIFRPRE86IGluY2x1c2l2ZS9leGNsdXNpdmUgcmFuZ2U/XG4gICAgaWYgKHNwZWMuc2NhbGUpIHtcbiAgICAgIGNvZGUgKz0gXCJpZiAoc2NhbGUubGVuZ3RoID09IDIpIHtcXG5cIiArIC8vIGludmVydGluZyBvcmRpbmFsIHNjYWxlc1xuICAgICAgICBcIiAgb3JkU2V0ID0gc2NhbGUobzEsIG8yKTtcXG5cIiArXG4gICAgICAgIFwifSBlbHNlIHtcXG5cIiArXG4gICAgICAgIFwiICBvMSA9IHNjYWxlKG8xKTtcXG5vMiA9IHNjYWxlKG8yKTtcXG5cIiArXG4gICAgICAgIFwifVwiO1xuICAgIH1cblxuICAgIGNvZGUgKz0gXCJyZXR1cm4gb3JkU2V0ICE9PSBudWxsID8gb3JkU2V0LmluZGV4T2YobzApICE9PSAtMSA6XFxuXCIgKyBcbiAgICAgIFwiICBvMSA8IG8yID8gbzEgPD0gbzAgJiYgbzAgPD0gbzIgOiBvMiA8PSBvMCAmJiBvMCA8PSBvMTtcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZTogY29kZSwgXG4gICAgc2lnbmFsczogb3BzLnNpZ25hbHMsIFxuICAgIGRhdGE6IG9wcy5kYXRhLmNvbmNhdChzcGVjLmRhdGEgPyBbc3BlYy5kYXRhXSA6IFtdKVxuICB9O1xufVxuXG4vLyBQb3B1bGF0ZSBvcHMgc3VjaCB0aGF0IHVsdGltYXRlIHNjYWxlL2ludmVyc2lvbiBmdW5jdGlvbiB3aWxsIGJlIGluIGBzY2FsZWAgdmFyLiBcbmZ1bmN0aW9uIHBhcnNlU2NhbGUoc3BlYywgb3BzKSB7XG4gIHZhciBjb2RlID0gXCJ2YXIgc2NhbGUgPSBcIiwgXG4gICAgICBpZHggID0gb3BzLmxlbmd0aDtcblxuICBpZiAoZGwuaXNTdHJpbmcoc3BlYykpIHtcbiAgICBvcHMucHVzaCh7IHZhbHVlOiBzcGVjIH0pO1xuICAgIGNvZGUgKz0gXCJ0aGlzLnJvb3QoKS5zY2FsZShvXCIraWR4K1wiKVwiO1xuICB9IGVsc2UgaWYgKHNwZWMuYXJnKSB7ICAvLyBTY2FsZSBmdW5jdGlvbiBpcyBiZWluZyBwYXNzZWQgYXMgYW4gYXJnXG4gICAgb3BzLnB1c2goc3BlYyk7XG4gICAgY29kZSArPSBcIm9cIitpZHg7XG4gIH0gZWxzZSBpZiAoc3BlYy5uYW1lKSB7IC8vIEZ1bGwgc2NhbGUgcGFyYW1ldGVyIHtuYW1lOiAuLn1cbiAgICBvcHMucHVzaChkbC5pc1N0cmluZyhzcGVjLm5hbWUpID8ge3ZhbHVlOiBzcGVjLm5hbWV9IDogc3BlYy5uYW1lKTtcbiAgICBjb2RlICs9IFwiKHRoaXMuaXNGdW5jdGlvbihvXCIraWR4K1wiKSA/IG9cIitpZHgrXCIgOiBcIjtcbiAgICBpZiAoc3BlYy5zY29wZSkge1xuICAgICAgb3BzLnB1c2goc3BlYy5zY29wZSk7XG4gICAgICBjb2RlICs9IFwiKChvXCIrKGlkeCsxKStcIi5zY2FsZSB8fCB0aGlzLnJvb3QoKS5zY2FsZSkob1wiK2lkeCtcIikgfHwgdGhpcy5udWxsU2NhbGUpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJ0aGlzLnJvb3QoKS5zY2FsZShvXCIraWR4K1wiKVwiO1xuICAgIH1cbiAgICBjb2RlICs9IFwiKVwiO1xuICB9XG5cbiAgaWYgKHNwZWMuaW52ZXJ0ID09PSB0cnVlKSB7ICAvLyBBbGxvdyBzcGVjLmludmVydC5hcmc/XG4gICAgY29kZSArPSBcIi5pbnZlcnRcIjtcbiAgfVxuXG4gIHJldHVybiBjb2RlK1wiO1xcblwiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlUHJlZGljYXRlczsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZTtcblxudmFyIERFUFMgPSBbXCJzaWduYWxzXCIsIFwic2NhbGVzXCIsIFwiZGF0YVwiLCBcImZpZWxkc1wiXTtcblxuZnVuY3Rpb24gcHJvcGVydGllcyhtb2RlbCwgbWFyaywgc3BlYykge1xuICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnKCksXG4gICAgICBjb2RlID0gXCJcIixcbiAgICAgIG5hbWVzID0gZGwua2V5cyhzcGVjKSxcbiAgICAgIGksIGxlbiwgbmFtZSwgcmVmLCB2YXJzID0ge30sIFxuICAgICAgZGVwcyA9IHtcbiAgICAgICAgc2lnbmFsczoge30sXG4gICAgICAgIHNjYWxlczogIHt9LFxuICAgICAgICBkYXRhOiAgICB7fSxcbiAgICAgICAgZmllbGRzOiAge30sXG4gICAgICAgIG5lc3RlZDogIFtdLFxuICAgICAgICBfblJlZnM6ICB7fSwgIC8vIFRlbXAgc3Rhc2ggdG8gZGUtZHVwZSBuZXN0ZWQgcmVmcy5cbiAgICAgICAgcmVmbG93OiAgZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgY29kZSArPSBcInZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sIGQ9MCwgc2V0PXRoaXMudHBsLnNldCwgdG1wbD1zaWduYWxzfHx7fSwgdDtcXG5cIiArXG4gICAgICAgICAgLy8gU3Rhc2ggZm9yIGRsLnRlbXBsYXRlXG4gICAgICAgICAgXCJ0bXBsLmRhdHVtICA9IGl0ZW0uZGF0dW07XFxuXCIgKyBcbiAgICAgICAgICBcInRtcGwuZ3JvdXAgID0gZ3JvdXA7XFxuXCIgKyBcbiAgICAgICAgICBcInRtcGwucGFyZW50ID0gZ3JvdXAuZGF0dW07XFxuXCI7XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGVwKHApIHtcbiAgICBpZiAocmVmW3BdID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgayA9IGRsLmFycmF5KHJlZltwXSksIGksIG47XG4gICAgZm9yIChpPTAsIG49ay5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZXBzW3BdW2tbaV1dID0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXN0ZWRSZWZzKHIpIHtcbiAgICB2YXIgayA9IChyLnBhcmVudCA/IFwicGFyZW50X1wiIDogXCJncm91cF9cIikrci5sZXZlbDtcbiAgICBkZXBzLl9uUmVmc1trXSA9IHI7XG4gIH1cblxuICBmb3IgKGk9MCwgbGVuPW5hbWVzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHJlZiA9IHNwZWNbbmFtZSA9IG5hbWVzW2ldXTtcbiAgICBjb2RlICs9IChpID4gMCkgPyBcIlxcbiAgXCIgOiBcIiAgXCI7XG4gICAgaWYgKHJlZi5ydWxlKSB7XG4gICAgICByZWYgPSBydWxlKG1vZGVsLCBuYW1lLCByZWYucnVsZSk7XG4gICAgICBjb2RlICs9IFwiXFxuICBcIiArIHJlZi5jb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB2YWx1ZVJlZihjb25maWcsIG5hbWUsIHJlZik7XG4gICAgICBjb2RlICs9IFwiZCArPSBzZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcIjtcbiAgICB9XG5cbiAgICB2YXJzW25hbWVdID0gdHJ1ZTtcbiAgICBERVBTLmZvckVhY2goaGFuZGxlRGVwKTtcbiAgICBkZXBzLnJlZmxvdyA9IGRlcHMucmVmbG93IHx8IHJlZi5yZWZsb3c7XG4gICAgaWYgKHJlZi5uZXN0ZWQubGVuZ3RoKSByZWYubmVzdGVkLmZvckVhY2goaGFuZGxlTmVzdGVkUmVmcyk7XG4gIH1cblxuICAvLyBJZiBuZXN0ZWQgcmVmZXJlbmNlcyBhcmUgcHJlc2VudCwgc29ydCB0aGVtIGJhc2VkIG9uIHRoZWlyIGxldmVsXG4gIC8vIHRvIHNwZWVkIHVwIGRldGVybWluYXRpb24gb2Ygd2hldGhlciBlbmNvZGVycyBzaG91bGQgYmUgcmVldmFsJ2QuXG4gIGRsLmtleXMoZGVwcy5fblJlZnMpLmZvckVhY2goZnVuY3Rpb24oaykgeyBkZXBzLm5lc3RlZC5wdXNoKGRlcHMuX25SZWZzW2tdKTsgfSk7XG4gIGRlcHMubmVzdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikgeyBcbiAgICBhID0gYS5sZXZlbDtcbiAgICBiID0gYi5sZXZlbDtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47IFxuICB9KTtcblxuICBpZiAodmFycy54Mikge1xuICAgIGlmICh2YXJzLngpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGlmIChvLnggPiBvLngyKSB7IFwiICtcbiAgICAgICAgICAgICAgXCJcXG4gICAgdCA9IG8ueDtcIiArXG4gICAgICAgICAgICAgIFwiXFxuICAgIGQgKz0gc2V0KG8sICd4Jywgby54Mik7XCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgICBkICs9IHNldChvLCAneDInLCB0KTsgXCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgfTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd3aWR0aCcsIChvLngyIC0gby54KSk7XCI7XG4gICAgfSBlbHNlIGlmICh2YXJzLndpZHRoKSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAneCcsIChvLngyIC0gby53aWR0aCkpO1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAneCcsIG8ueDIpO1wiO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YXJzLnhjKSB7XG4gICAgaWYgKHZhcnMud2lkdGgpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd4JywgKG8ueGMgLSBvLndpZHRoLzIpKTtcIiA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd4Jywgby54Yyk7XCIgO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YXJzLnkyKSB7XG4gICAgaWYgKHZhcnMueSkge1xuICAgICAgY29kZSArPSBcIlxcbiAgaWYgKG8ueSA+IG8ueTIpIHsgXCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgICB0ID0gby55O1wiICtcbiAgICAgICAgICAgICAgXCJcXG4gICAgZCArPSBzZXQobywgJ3knLCBvLnkyKTtcIiArXG4gICAgICAgICAgICAgIFwiXFxuICAgIGQgKz0gc2V0KG8sICd5MicsIHQpO1wiICtcbiAgICAgICAgICAgICAgXCJcXG4gIH07XCI7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAnaGVpZ2h0JywgKG8ueTIgLSBvLnkpKTtcIjtcbiAgICB9IGVsc2UgaWYgKHZhcnMuaGVpZ2h0KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAneScsIChvLnkyIC0gby5oZWlnaHQpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3knLCBvLnkyKTtcIjtcbiAgICB9XG4gIH1cblxuICBpZiAodmFycy55Yykge1xuICAgIGlmICh2YXJzLmhlaWdodCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3knLCAoby55YyAtIG8uaGVpZ2h0LzIpKTtcIiA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd5Jywgby55Yyk7XCIgO1xuICAgIH1cbiAgfVxuICBcbiAgaWYgKGhhc1BhdGgobWFyaywgdmFycykpIGNvZGUgKz0gXCJcXG4gIGQgKz0gKGl0ZW0udG91Y2goKSwgMSk7XCI7XG4gIGNvZGUgKz0gXCJcXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XCI7XG4gIGNvZGUgKz0gXCJcXG4gIHJldHVybiBkID4gMDtcIjtcblxuICB0cnkge1xuICAgIC8qIGpzaGludCBldmlsOnRydWUgKi9cbiAgICB2YXIgZW5jb2RlciA9IEZ1bmN0aW9uKCdpdGVtJywgJ2dyb3VwJywgJ3RyYW5zJywgJ2RiJywgXG4gICAgICAnc2lnbmFscycsICdwcmVkaWNhdGVzJywgY29kZSk7XG4gICAgZW5jb2Rlci50cGwgID0gVHVwbGU7XG4gICAgZW5jb2Rlci51dGlsID0gZGw7XG4gICAgZW5jb2Rlci5kMyAgID0gZDM7IC8vIEZvciBjb2xvciBzcGFjZXNcbiAgICBkbC5leHRlbmQoZW5jb2RlciwgZGwudGVtcGxhdGUuY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogIGVuY29kZXIsXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKGRlcHMuc2lnbmFscyksXG4gICAgICBzY2FsZXM6ICBkbC5rZXlzKGRlcHMuc2NhbGVzKSxcbiAgICAgIGRhdGE6ICAgIGRsLmtleXMoZGVwcy5kYXRhKSxcbiAgICAgIGZpZWxkczogIGRsLmtleXMoZGVwcy5maWVsZHMpLFxuICAgICAgbmVzdGVkOiAgZGVwcy5uZXN0ZWQsXG4gICAgICByZWZsb3c6ICBkZXBzLnJlZmxvd1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoZSk7XG4gICAgbG9nLmxvZyhjb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXBlbmRlbmNpZXMoYSwgYikge1xuICBpZiAoIWRsLmlzT2JqZWN0KGEpKSB7XG4gICAgYSA9IHtyZWZsb3c6IGZhbHNlLCBuZXN0ZWQ6IFtdfTtcbiAgICBERVBTLmZvckVhY2goZnVuY3Rpb24oZCkgeyBhW2RdID0gW107IH0pO1xuICB9XG5cbiAgaWYgKGRsLmlzT2JqZWN0KGIpKSB7XG4gICAgYS5yZWZsb3cgPSBhLnJlZmxvdyB8fCBiLnJlZmxvdztcbiAgICBhLm5lc3RlZC5wdXNoLmFwcGx5KGEubmVzdGVkLCBiLm5lc3RlZCk7XG4gICAgREVQUy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgYVtkXS5wdXNoLmFwcGx5KGFbZF0sIGJbZF0pOyB9KTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBoYXNQYXRoKG1hcmssIHZhcnMpIHtcbiAgcmV0dXJuIHZhcnMucGF0aCB8fFxuICAgICgobWFyaz09PSdhcmVhJyB8fCBtYXJrPT09J2xpbmUnKSAmJlxuICAgICAgKHZhcnMueCB8fCB2YXJzLngyIHx8IHZhcnMud2lkdGggfHxcbiAgICAgICB2YXJzLnkgfHwgdmFycy55MiB8fCB2YXJzLmhlaWdodCB8fFxuICAgICAgIHZhcnMudGVuc2lvbiB8fCB2YXJzLmludGVycG9sYXRlKSk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobW9kZWwsIG5hbWUsIHJ1bGVzKSB7XG4gIHZhciBjb25maWcgID0gbW9kZWwuY29uZmlnKCksXG4gICAgICBkZXBzID0gZGVwZW5kZW5jaWVzKCksXG4gICAgICBpbnB1dHMgID0gW10sIGNvZGUgPSAnJztcblxuICAocnVsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICB2YXIgZGVmID0gci5wcmVkaWNhdGUsXG4gICAgICAgIHByZWROYW1lID0gZGVmICYmIChkZWYubmFtZSB8fCBkZWYpLFxuICAgICAgICBwcmVkID0gbW9kZWwucHJlZGljYXRlKHByZWROYW1lKSxcbiAgICAgICAgcCA9ICdwcmVkaWNhdGVzWycrZGwuc3RyKHByZWROYW1lKSsnXScsXG4gICAgICAgIGlucHV0ID0gW10sIGFyZ3MgPSBuYW1lKydfYXJnJytpLFxuICAgICAgICByZWY7XG5cbiAgICBpZiAoZGwuaXNPYmplY3QoZGVmKSkge1xuICAgICAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayA9PT0gJ25hbWUnKSByZXR1cm47XG4gICAgICAgIHZhciByZWYgPSB2YWx1ZVJlZihjb25maWcsIGksIGRlZltrXSk7XG4gICAgICAgIGlucHV0LnB1c2goZGwuc3RyKGspKyc6ICcrcmVmLnZhbCk7XG4gICAgICAgIGRlcGVuZGVuY2llcyhkZXBzLCByZWYpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVmID0gdmFsdWVSZWYoY29uZmlnLCBuYW1lLCByKTtcbiAgICBkZXBlbmRlbmNpZXMoZGVwcywgcmVmKTtcblxuICAgIGlmIChwcmVkTmFtZSkge1xuICAgICAgZGVwcy5zaWduYWxzLnB1c2guYXBwbHkoZGVwcy5zaWduYWxzLCBwcmVkLnNpZ25hbHMpO1xuICAgICAgZGVwcy5kYXRhLnB1c2guYXBwbHkoZGVwcy5kYXRhLCBwcmVkLmRhdGEpO1xuICAgICAgaW5wdXRzLnB1c2goYXJncytcIiA9IHtcXG4gICAgXCIraW5wdXQuam9pbihcIixcXG4gICAgXCIpK1wiXFxuICB9XCIpO1xuICAgICAgY29kZSArPSBcImlmIChcIitwK1wiLmNhbGwoXCIrcCtcIixcIithcmdzK1wiLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykpIHtcIiArXG4gICAgICAgIFwiXFxuICAgIGQgKz0gc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XCI7XG4gICAgICBjb2RlICs9IHJ1bGVzW2krMV0gPyBcIlxcbiAgfSBlbHNlIFwiIDogXCIgIH1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIntcIiArIFxuICAgICAgICBcIlxcbiAgICBkICs9IHNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1wiK1xuICAgICAgICBcIlxcbiAgfVxcblwiO1xuICAgIH1cbiAgfSk7XG5cbiAgY29kZSA9IFwidmFyIFwiICsgaW5wdXRzLmpvaW4oXCIsXFxuICAgICAgXCIpICsgXCI7XFxuICBcIiArIGNvZGU7XG4gIHJldHVybiAoZGVwcy5jb2RlID0gY29kZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlUmVmKGNvbmZpZywgbmFtZSwgcmVmKSB7XG4gIGlmIChyZWYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgaWYgKG5hbWU9PT0nZmlsbCcgfHwgbmFtZT09PSdzdHJva2UnKSB7XG4gICAgaWYgKHJlZi5jKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoY29uZmlnLCAnaGNsJywgcmVmLmgsIHJlZi5jLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYuaCB8fCByZWYucykge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKGNvbmZpZywgJ2hzbCcsIHJlZi5oLCByZWYucywgcmVmLmwpO1xuICAgIH0gZWxzZSBpZiAocmVmLmwgfHwgcmVmLmEpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihjb25maWcsICdsYWInLCByZWYubCwgcmVmLmEsIHJlZi5iKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5yIHx8IHJlZi5nIHx8IHJlZi5iKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoY29uZmlnLCAncmdiJywgcmVmLnIsIHJlZi5nLCByZWYuYik7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB2YWx1ZVxuICB2YXIgdmFsID0gbnVsbCwgc2NhbGUgPSBudWxsLCBcbiAgICAgIGRlcHMgPSBkZXBlbmRlbmNpZXMoKSxcbiAgICAgIHNnUmVmID0gbnVsbCwgZlJlZiA9IG51bGwsIHNSZWYgPSBudWxsLCB0bXBsID0ge307XG5cbiAgaWYgKHJlZi50ZW1wbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gZGwudGVtcGxhdGUuc291cmNlKHJlZi50ZW1wbGF0ZSwgJ3RtcGwnLCB0bXBsKTtcbiAgICBkbC5rZXlzKHRtcGwpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGYgPSBkbC5maWVsZChrKSxcbiAgICAgICAgICBhID0gZi5zaGlmdCgpO1xuICAgICAgaWYgKGEgPT09ICdwYXJlbnQnIHx8IGEgPT09ICdncm91cCcpIHtcbiAgICAgICAgZGVwcy5uZXN0ZWQucHVzaCh7IFxuICAgICAgICAgIHBhcmVudDogYSA9PT0gJ3BhcmVudCcsXG4gICAgICAgICAgZ3JvdXA6ICBhID09PSAnZ3JvdXAnLCBcbiAgICAgICAgICBsZXZlbDogIDFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGEgPT09ICdkYXR1bScpIHtcbiAgICAgICAgZGVwcy5maWVsZHMucHVzaChmWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHMuc2lnbmFscy5wdXNoKGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlZi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gZGwuc3RyKHJlZi52YWx1ZSk7XG4gIH1cblxuICBpZiAocmVmLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2dSZWYgPSBkbC5maWVsZChyZWYuc2lnbmFsKTtcbiAgICB2YWwgPSAnc2lnbmFsc1snK3NnUmVmLm1hcChkbC5zdHIpLmpvaW4oJ11bJykrJ10nOyBcbiAgICBkZXBzLnNpZ25hbHMucHVzaChzZ1JlZi5zaGlmdCgpKTtcbiAgfVxuXG4gIGlmIChyZWYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlZi5maWVsZCA9IGRsLmlzU3RyaW5nKHJlZi5maWVsZCkgPyB7ZGF0dW06IHJlZi5maWVsZH0gOiByZWYuZmllbGQ7XG4gICAgZlJlZiA9IGZpZWxkUmVmKHJlZi5maWVsZCk7XG4gICAgdmFsICA9IGZSZWYudmFsO1xuICAgIGRlcGVuZGVuY2llcyhkZXBzLCBmUmVmKTtcbiAgfVxuXG4gIGlmIChyZWYuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHNSZWYgID0gc2NhbGVSZWYocmVmLnNjYWxlKTtcbiAgICBzY2FsZSA9IHNSZWYudmFsO1xuICAgIGRlcGVuZGVuY2llcyhkZXBzLCBzUmVmKTtcbiAgICBkZXBzLnNjYWxlcy5wdXNoKHJlZi5zY2FsZS5uYW1lIHx8IHJlZi5zY2FsZSk7XG5cbiAgICAvLyBydW4gdGhyb3VnaCBzY2FsZSBmdW5jdGlvbiBpZiB2YWwgc3BlY2lmaWVkLlxuICAgIC8vIGlmIG5vIHZhbCwgc2NhbGUgZnVuY3Rpb24gaXMgcHJlZGljYXRlIGFyZy5cbiAgICBpZiAodmFsICE9PSBudWxsIHx8IHJlZi5iYW5kIHx8IHJlZi5tdWx0IHx8IHJlZi5vZmZzZXQpIHtcbiAgICAgIHZhbCA9IHNjYWxlICsgKHJlZi5iYW5kID8gJy5yYW5nZUJhbmQoKScgOiBcbiAgICAgICAgJygnKyh2YWwgIT09IG51bGwgPyB2YWwgOiAnaXRlbS5kYXR1bS5kYXRhJykrJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gc2NhbGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBtdWx0aXBseSwgb2Zmc2V0LCByZXR1cm4gdmFsdWVcbiAgdmFsID0gJygnICsgKHJlZi5tdWx0PyhkbC5udW1iZXIocmVmLm11bHQpKycgKiAnKTonJykgKyB2YWwgKyAnKScgK1xuICAgICAgICAocmVmLm9mZnNldCA/ICcgKyAnICsgZGwubnVtYmVyKHJlZi5vZmZzZXQpIDogJycpO1xuXG4gIC8vIENvbGxhdGUgZGVwZW5kZW5jaWVzXG4gIHJldHVybiAoZGVwcy52YWwgPSB2YWwsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBjb2xvclJlZihjb25maWcsIHR5cGUsIHgsIHksIHopIHtcbiAgdmFyIHh4ID0geCA/IHZhbHVlUmVmKGNvbmZpZywgJycsIHgpIDogY29uZmlnLmNvbG9yW3R5cGVdWzBdLFxuICAgICAgeXkgPSB5ID8gdmFsdWVSZWYoY29uZmlnLCAnJywgeSkgOiBjb25maWcuY29sb3JbdHlwZV1bMV0sXG4gICAgICB6eiA9IHogPyB2YWx1ZVJlZihjb25maWcsICcnLCB6KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsyXSxcbiAgICAgIGRlcHMgPSBkZXBlbmRlbmNpZXMoKTtcblxuICBbeHgsIHl5LCB6el0uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYgKGRsLmlzQXJyYXkpIHJldHVybjtcbiAgICBkZXBlbmRlbmNpZXMoZGVwcywgdik7XG4gIH0pO1xuXG4gIHZhciB2YWwgPSAnKHRoaXMuZDMuJyArIHR5cGUgKyAnKCcgKyBbeHgudmFsLCB5eS52YWwsIHp6LnZhbF0uam9pbignLCcpICsgJykgKyBcIlwiKSc7XG4gIHJldHVybiAoZGVwcy52YWwgPSB2YWwsIGRlcHMpO1xufVxuXG4vLyB7ZmllbGQ6IHtkYXR1bTogXCJmb29cIn0gfSAgLT4gaXRlbS5kYXR1bS5mb29cbi8vIHtmaWVsZDoge2dyb3VwOiBcImZvb1wifSB9ICAtPiBncm91cC5mb29cbi8vIHtmaWVsZDoge3BhcmVudDogXCJmb29cIn0gfSAtPiBncm91cC5kYXR1bS5mb29cbmZ1bmN0aW9uIGZpZWxkUmVmKHJlZikge1xuICBpZiAoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHJldHVybiB7dmFsOiBkbC5maWVsZChyZWYpLm1hcChkbC5zdHIpLmpvaW4oJ11bJyl9O1xuICB9IFxuXG4gIC8vIFJlc29sdmUgbmVzdGluZy9wYXJlbnQgbG9va3Vwc1xuICB2YXIgbCA9IHJlZi5sZXZlbCB8fCAxLFxuICAgICAgbmVzdGVkID0gKHJlZi5ncm91cCB8fCByZWYucGFyZW50KSAmJiBsLFxuICAgICAgc2NvcGUgPSBuZXN0ZWQgPyBBcnJheShsKS5qb2luKCdncm91cC5tYXJrLicpIDogJycsXG4gICAgICByID0gZmllbGRSZWYocmVmLmRhdHVtIHx8IHJlZi5ncm91cCB8fCByZWYucGFyZW50IHx8IHJlZi5zaWduYWwpLFxuICAgICAgdmFsID0gci52YWwsXG4gICAgICBkZXBzID0gZGVwZW5kZW5jaWVzKG51bGwsIHIpO1xuXG4gIGlmIChyZWYuZGF0dW0pIHtcbiAgICB2YWwgPSAnaXRlbS5kYXR1bVsnK3ZhbCsnXSc7XG4gICAgZGVwcy5maWVsZHMucHVzaChyZWYuZGF0dW0pO1xuICB9IGVsc2UgaWYgKHJlZi5ncm91cCkge1xuICAgIHZhbCA9IHNjb3BlKydncm91cFsnK3ZhbCsnXSc7XG4gICAgZGVwcy5uZXN0ZWQucHVzaCh7IGxldmVsOiBsLCBncm91cDogdHJ1ZSB9KTtcbiAgfSBlbHNlIGlmIChyZWYucGFyZW50KSB7XG4gICAgdmFsID0gc2NvcGUrJ2dyb3VwLmRhdHVtWycrdmFsKyddJztcbiAgICBkZXBzLm5lc3RlZC5wdXNoKHsgbGV2ZWw6IGwsIHBhcmVudDogdHJ1ZSB9KTtcbiAgfSBlbHNlIGlmIChyZWYuc2lnbmFsKSB7XG4gICAgdmFsID0gJ3NpZ25hbHNbJyt2YWwrJ10nO1xuICAgIGRlcHMuc2lnbmFscy5wdXNoKGRsLmZpZWxkKHJlZi5zaWduYWwpWzBdKTtcbiAgICBkZXBzLnJlZmxvdyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gKGRlcHMudmFsID0gdmFsLCBkZXBzKTtcbn1cblxuLy8ge3NjYWxlOiBcInhcIn1cbi8vIHtzY2FsZToge25hbWU6IFwieFwifX0sXG4vLyB7c2NhbGU6IGZpZWxkUmVmfVxuZnVuY3Rpb24gc2NhbGVSZWYocmVmKSB7XG4gIHZhciBzY2FsZSA9IG51bGwsXG4gICAgICBmciA9IG51bGwsXG4gICAgICBkZXBzID0gZGVwZW5kZW5jaWVzKCk7XG5cbiAgaWYgKGRsLmlzU3RyaW5nKHJlZikpIHtcbiAgICBzY2FsZSA9IGRsLnN0cihyZWYpO1xuICB9IGVsc2UgaWYgKHJlZi5uYW1lKSB7XG4gICAgc2NhbGUgPSBkbC5pc1N0cmluZyhyZWYubmFtZSkgPyBkbC5zdHIocmVmLm5hbWUpIDogKGZyID0gZmllbGRSZWYocmVmLm5hbWUpKS52YWw7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGUgPSAoZnIgPSBmaWVsZFJlZihyZWYpKS52YWw7XG4gIH1cblxuICBzY2FsZSA9ICcoaXRlbS5tYXJrLl9zY2FsZVJlZnNbJytzY2FsZSsnXSA9IDEsIGdyb3VwLnNjYWxlKCcrc2NhbGUrJykpJztcbiAgaWYgKHJlZi5pbnZlcnQpIHNjYWxlICs9ICcuaW52ZXJ0JztcblxuICAvLyBNYXJrIHNjYWxlIHJlZnMgYXMgdGhleSdyZSBkZWFsdCB3aXRoIHNlcGFyYXRlbHkgaW4gbWFyay5fc2NhbGVSZWZzLlxuICBpZiAoZnIpIGZyLm5lc3RlZC5mb3JFYWNoKGZ1bmN0aW9uKGcpIHsgZy5zY2FsZSA9IHRydWU7IH0pO1xuICByZXR1cm4gZnIgPyAoZnIudmFsID0gc2NhbGUsIGZyKSA6IChkZXBzLnZhbCA9IHNjYWxlLCBkZXBzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0aWVzOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBTSUdOQUxTID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLkRlcGVuZGVuY2llcy5TSUdOQUxTLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuL2V4cHInKTtcblxudmFyIFJFU0VSVkVEID0gWydkYXR1bScsICdldmVudCcsICdzaWduYWxzJ11cbiAgLmNvbmNhdChkbC5rZXlzKGV4cHIuY29kZWdlbi5mdW5jdGlvbnMpKTtcblxuZnVuY3Rpb24gcGFyc2VTaWduYWxzKG1vZGVsLCBzcGVjKSB7XG4gIC8vIHByb2Nlc3MgZWFjaCBzaWduYWwgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgaWYgKFJFU0VSVkVELmluZGV4T2Yocy5uYW1lKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdTaWduYWwgbmFtZSBcIicrcy5uYW1lKydcIiBpcyBhICcrXG4gICAgICAgICdyZXNlcnZlZCBrZXl3b3JkICgnK1JFU0VSVkVELmpvaW4oJywgJykrJykuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNpZ25hbCA9IG1vZGVsLnNpZ25hbChzLm5hbWUsIHMuaW5pdClcbiAgICAgIC52ZXJib3NlKHMudmVyYm9zZSk7XG5cbiAgICBpZiAocy5pbml0ICYmIHMuaW5pdC5leHByKSB7XG4gICAgICBzLmluaXQuZXhwciA9IGV4cHIocy5pbml0LmV4cHIpO1xuICAgICAgc2lnbmFsLnZhbHVlKGV4cHJWYWwobW9kZWwsIHMuaW5pdCkpO1xuICAgIH1cblxuICAgIGlmIChzLmV4cHIpIHtcbiAgICAgIHMuZXhwciA9IGV4cHIocy5leHByKTtcbiAgICAgIHNpZ25hbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWwgPSBleHByVmFsKG1vZGVsLCBzKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gc2lnbmFsLnZhbHVlKCkgfHwgc2lnbmFsLnZlcmJvc2UoKSkge1xuICAgICAgICAgIHNpZ25hbC52YWx1ZSh2YWwpO1xuICAgICAgICAgIGlucHV0LnNpZ25hbHNbcy5uYW1lXSA9IDE7XG4gICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTsgICAgICAgIFxuICAgICAgfTtcbiAgICAgIHNpZ25hbC5kZXBlbmRlbmN5KFNJR05BTFMsIHMuZXhwci5nbG9iYWxzKTtcbiAgICAgIHMuZXhwci5nbG9iYWxzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XG4gICAgICAgIG1vZGVsLnNpZ25hbChkZXApLmFkZExpc3RlbmVyKHNpZ25hbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBleHByVmFsKG1vZGVsLCBzcGVjKSB7XG4gIHZhciBlID0gc3BlYy5leHByLFxuICAgICAgdmFsID0gZS5mbihudWxsLCBudWxsLCBtb2RlbC52YWx1ZXMoU0lHTkFMUywgZS5nbG9iYWxzKSk7XG4gIHJldHVybiBzcGVjLnNjYWxlID8gcGFyc2VTaWduYWxzLnNjYWxlKG1vZGVsLCBzcGVjLCB2YWwpIDogdmFsO1xufVxuXG5wYXJzZVNpZ25hbHMuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShtb2RlbCwgc3BlYywgdmFsdWUsIGRhdHVtLCBldnQpIHtcbiAgdmFyIGRlZiA9IHNwZWMuc2NhbGUsXG4gICAgICBuYW1lICA9IGRlZi5uYW1lIHx8IGRlZi5zaWduYWwgfHwgZGVmLFxuICAgICAgc2NvcGUgPSBkZWYuc2NvcGUsIGU7XG5cbiAgaWYgKHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlLnNpZ25hbCkge1xuICAgICAgc2NvcGUgPSBtb2RlbC5zaWduYWxSZWYoc2NvcGUuc2lnbmFsKTtcbiAgICB9IGVsc2UgaWYgKGRsLmlzU3RyaW5nKHNjb3BlKSkgeyAvLyBTY29wZSBpcyBhbiBleHByZXNzaW9uXG4gICAgICBlID0gZGVmLl9leHByID0gKGRlZi5fZXhwciB8fCBleHByKHNjb3BlKSk7XG4gICAgICBzY29wZSA9IGUuZm4oZGF0dW0sIGV2dCwgbW9kZWwudmFsdWVzKFNJR05BTFMsIGUuZ2xvYmFscykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2NvcGUgfHwgIXNjb3BlLnNjYWxlKSB7XG4gICAgc2NvcGUgPSAoc2NvcGUgJiYgc2NvcGUubWFyaykgPyBzY29wZS5tYXJrLmdyb3VwIDogbW9kZWwuc2NlbmUoKS5pdGVtc1swXTtcbiAgfVxuXG4gIHZhciBzID0gc2NvcGUuc2NhbGUobmFtZSk7XG4gIHJldHVybiAhcyA/IHZhbHVlIDogKGRlZi5pbnZlcnQgPyBzLmludmVydCh2YWx1ZSkgOiBzKHZhbHVlKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlU2lnbmFsczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuLi9jb3JlL01vZGVsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJy4uL2NvcmUvVmlldycpO1xuXG5mdW5jdGlvbiBwYXJzZVNwZWMoc3BlYywgY2FsbGJhY2spIHtcbiAgdmFyIHZmID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0sXG4gICAgICB2aWV3RmFjdG9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGRsLmlzRnVuY3Rpb24odmYpID8gdmYgOiBWaWV3LmZhY3RvcnksXG4gICAgICBjb25maWcgPSBhcmd1bWVudHNbMl0gIT09IHZpZXdGYWN0b3J5ID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBtb2RlbCA9IG5ldyBNb2RlbChjb25maWcpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHNwZWMpIHtcbiAgICAvLyBwcm90ZWN0IGFnYWluc3Qgc3Vic2VxdWVudCBzcGVjIG1vZGlmaWNhdGlvblxuICAgIHNwZWMgPSBkbC5kdXBsaWNhdGUoc3BlYyk7XG5cbiAgICB2YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vJyksXG4gICAgICAgIHdpZHRoID0gc3BlYy53aWR0aCB8fCA1MDAsXG4gICAgICAgIGhlaWdodCA9IHNwZWMuaGVpZ2h0IHx8IDUwMCxcbiAgICAgICAgdmlld3BvcnQgPSBzcGVjLnZpZXdwb3J0IHx8IG51bGw7XG5cbiAgICBtb2RlbC5kZWZzKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgYmFja2dyb3VuZDogcGFyc2Vycy5iYWNrZ3JvdW5kKHNwZWMuYmFja2dyb3VuZCksXG4gICAgICBwYWRkaW5nOiBwYXJzZXJzLnBhZGRpbmcoc3BlYy5wYWRkaW5nKSxcbiAgICAgIHNpZ25hbHM6IHBhcnNlcnMuc2lnbmFscyhtb2RlbCwgc3BlYy5zaWduYWxzKSxcbiAgICAgIHByZWRpY2F0ZXM6IHBhcnNlcnMucHJlZGljYXRlcyhtb2RlbCwgc3BlYy5wcmVkaWNhdGVzKSxcbiAgICAgIG1hcmtzOiBwYXJzZXJzLm1hcmtzKG1vZGVsLCBzcGVjLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgIGRhdGE6IHBhcnNlcnMuZGF0YShtb2RlbCwgc3BlYy5kYXRhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sodmlld0ZhY3RvcnkobW9kZWwpKTtcbiAgICAgIH0pXG4gICAgfSk7ICAgIFxuICB9XG5cbiAgaWYgKGRsLmlzT2JqZWN0KHNwZWMpKSB7XG4gICAgcGFyc2Uoc3BlYyk7XG4gIH0gZWxzZSBpZiAoZGwuaXNTdHJpbmcoc3BlYykpIHtcbiAgICB2YXIgb3B0cyA9IGRsLmV4dGVuZCh7dXJsOiBzcGVjfSwgbW9kZWwuY29uZmlnKCkubG9hZCk7XG4gICAgZGwubG9hZChvcHRzLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKCdMT0FESU5HIFNQRUNJRklDQVRJT04gRkFJTEVEOiAnICsgZXJyLnN0YXR1c1RleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHsgXG4gICAgICAgICAgcGFyc2UoSlNPTi5wYXJzZShkYXRhKSk7IFxuICAgICAgICB9IGNhdGNoIChlKSB7IFxuICAgICAgICAgIGxvZy5lcnJvcignSU5WQUxJRCBTUEVDSUZJQ0FUSU9OOiBNdXN0IGJlIGEgdmFsaWQgSlNPTiBvYmplY3QuICcrZSk7IFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmVycm9yKCdJTlZBTElEIFNQRUNJRklDQVRJT046IE11c3QgYmUgYSB2YWxpZCBKU09OIG9iamVjdCBvciBVUkwuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVNwZWM7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgU0lHTkFMUyA9IGRmLkRlcGVuZGVuY2llcy5TSUdOQUxTLFxuICAgIHBhcnNlU2lnbmFscyA9IHJlcXVpcmUoJy4vc2lnbmFscycpLFxuICAgIHNlbGVjdG9yID0gcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi9leHByJyk7XG5cbnZhciBHQVRFS0VFUEVSID0gJ192Z0dBVEVLRUVQRVInO1xuXG52YXIgdmdFdmVudCA9IHtcbiAgZ2V0R3JvdXA6IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWUgPyB0aGlzLm5hbWVbbmFtZV0gOiB0aGlzLmdyb3VwOyB9LFxuICBnZXRYWTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIHAgPSB7eDogdGhpcy54LCB5OiB0aGlzLnl9O1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICBpdGVtID0gdGhpcy5uYW1lW2l0ZW1dO1xuICAgICAgfVxuICAgICAgZm9yICg7IGl0ZW07IGl0ZW0gPSBpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLmdyb3VwKSB7XG4gICAgICAgIHAueCAtPSBpdGVtLnggfHwgMDtcbiAgICAgICAgcC55IC09IGl0ZW0ueSB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgZ2V0WDogZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gdGhpcy5nZXRYWShpdGVtKS54OyB9LFxuICBnZXRZOiBmdW5jdGlvbihpdGVtKSB7IHJldHVybiB0aGlzLmdldFhZKGl0ZW0pLnk7IH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtcyh2aWV3KSB7XG4gIHZhciBtb2RlbCA9IHZpZXcubW9kZWwoKSxcbiAgICAgIHNwZWMgID0gbW9kZWwuZGVmcygpLnNpZ25hbHMsXG4gICAgICByZWdpc3RyeSA9IHtoYW5kbGVyczoge30sIG5vZGVzOiB7fX0sXG4gICAgICBpbnRlcm5hbCA9IGRsLmR1cGxpY2F0ZShyZWdpc3RyeSksICAvLyBJbnRlcm5hbCBldmVudCBwcm9jZXNzaW5nXG4gICAgICBleHRlcm5hbCA9IGRsLmR1cGxpY2F0ZShyZWdpc3RyeSk7ICAvLyBFeHRlcm5hbCBldmVudCBwcm9jZXNzaW5nXG5cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZ25hbCA9IG1vZGVsLnNpZ25hbChzaWcubmFtZSk7XG4gICAgaWYgKHNpZy5leHByKSByZXR1cm47ICAvLyBDYW5ub3QgaGF2ZSBhbiBleHByIGFuZCBzdHJlYW0gZGVmaW5pdGlvbi5cblxuICAgIChzaWcuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBzZWwgPSBzZWxlY3Rvci5wYXJzZShzdHJlYW0udHlwZSksXG4gICAgICAgICAgZXhwID0gZXhwcihzdHJlYW0uZXhwcik7XG4gICAgICBtZXJnZWRTdHJlYW0oc2lnbmFsLCBzZWwsIGV4cCwgc3RyZWFtKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgcmVnaXN0ZXIgdGhlIGV2ZW50IGxpc3RlbmVycyBhbGwgdG9nZXRoZXIgc28gdGhhdCBpZiBtdWx0aXBsZVxuICAvLyBzaWduYWxzIGFyZSByZWdpc3RlcmVkIG9uIHRoZSBzYW1lIGV2ZW50LCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGVcbiAgLy8gbmV3IHZhbHVlIG9uIHRoZSBzYW1lIHB1bHNlLiBcbiAgZGwua2V5cyhpbnRlcm5hbC5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgdmlldy5vbih0eXBlLCBmdW5jdGlvbihldnQsIGl0ZW0pIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBzdG9wIHRleHQgc2VsZWN0aW9uXG4gICAgICBleHRlbmRFdmVudChldnQsIGl0ZW0pO1xuICAgICAgZmlyZShpbnRlcm5hbCwgdHlwZSwgKGl0ZW0gJiYgaXRlbS5kYXR1bSkgfHwge30sIGV2dCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBleHRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgZGwua2V5cyhleHRlcm5hbC5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47IC8vIE5vIGV4dGVybmFsIHN1cHBvcnRcblxuICAgIHZhciBoID0gZXh0ZXJuYWwuaGFuZGxlcnNbdHlwZV0sXG4gICAgICAgIHQgPSB0eXBlLnNwbGl0KCc6JyksIC8vIC0tPiBubyBlbGVtZW50IHBzZXVkby1zZWxlY3RvcnNcbiAgICAgICAgZWx0ID0gKHRbMF0gPT09ICd3aW5kb3cnKSA/IFt3aW5kb3ddIDpcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodFswXSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2dCkge1xuICAgICAgZXh0ZW5kRXZlbnQoZXZ0KTtcbiAgICAgIGZpcmUoZXh0ZXJuYWwsIHR5cGUsIGQzLnNlbGVjdCh0aGlzKS5kYXR1bSgpLCBldnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGk9MDsgaTxlbHQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVsdFtpXS5hZGRFdmVudExpc3RlbmVyKHRbMV0sIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGguZWxlbWVudHMgPSBlbHQ7XG4gICAgaC5saXN0ZW5lciA9IGhhbmRsZXI7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBleHRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgZXh0ZXJuYWwuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgZGwua2V5cyhleHRlcm5hbC5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgaCA9IGV4dGVybmFsLmhhbmRsZXJzW3R5cGVdLFxuICAgICAgICAgIHQgPSB0eXBlLnNwbGl0KCc6JyksXG4gICAgICAgICAgZWx0ID0gaC5lbGVtZW50cyB8fCBbXTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGVsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBlbHRbaV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0WzFdLCBoLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBleHBvcnQgZGV0YWNoIG1ldGhvZFxuICByZXR1cm4gZXh0ZXJuYWwuZGV0YWNoO1xuXG4gIC8vIC0tIGhlbHBlciBmdW5jdGlvbnMgLS0tLS1cblxuICBmdW5jdGlvbiBleHRlbmRFdmVudChldnQsIGl0ZW0pIHtcbiAgICB2YXIgbW91c2UgPSBkMy5tb3VzZSgoZDMuZXZlbnQ9ZXZ0LCB2aWV3LnJlbmRlcmVyKCkuc2NlbmUoKSkpLFxuICAgICAgICBwYWQgPSB2aWV3LnBhZGRpbmcoKSxcbiAgICAgICAgbmFtZXMgPSB7fSwgbWFyaywgZ3JvdXAsIGk7XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgbWFyayA9IGl0ZW0ubWFyaztcbiAgICAgIGdyb3VwID0gbWFyay5tYXJrdHlwZSA9PT0gJ2dyb3VwJyA/IGl0ZW0gOiBtYXJrLmdyb3VwO1xuICAgICAgZm9yIChpPWl0ZW07IGkhPW51bGw7IGk9aS5tYXJrLmdyb3VwKSB7XG4gICAgICAgIGlmIChpLm1hcmsuZGVmLm5hbWUpIHtcbiAgICAgICAgICBuYW1lc1tpLm1hcmsuZGVmLm5hbWVdID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuYW1lcy5yb290ID0gdmlldy5tb2RlbCgpLnNjZW5lKCkuaXRlbXNbMF07XG5cbiAgICBldnQudmcgPSBPYmplY3QuY3JlYXRlKHZnRXZlbnQpO1xuICAgIGV2dC52Zy5ncm91cCA9IGdyb3VwO1xuICAgIGV2dC52Zy5pdGVtID0gaXRlbSB8fCB7fTtcbiAgICBldnQudmcubmFtZSA9IG5hbWVzO1xuICAgIGV2dC52Zy54ID0gbW91c2VbMF0gLSBwYWQubGVmdDtcbiAgICBldnQudmcueSA9IG1vdXNlWzFdIC0gcGFkLnRvcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmUocmVnaXN0cnksIHR5cGUsIGRhdHVtLCBldnQpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSByZWdpc3RyeS5oYW5kbGVyc1t0eXBlXSxcbiAgICAgICAgbm9kZSA9IHJlZ2lzdHJ5Lm5vZGVzW3R5cGVdLFxuICAgICAgICBjcyA9IGRmLkNoYW5nZVNldC5jcmVhdGUobnVsbCwgdHJ1ZSksXG4gICAgICAgIGZpbHRlcmVkID0gZmFsc2UsXG4gICAgICAgIHZhbCwgaSwgbiwgaDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShmKSB7XG4gICAgICByZXR1cm4gIWYuZm4oZGF0dW0sIGV2dCwgbW9kZWwudmFsdWVzKFNJR05BTFMsIGYuZ2xvYmFscykpO1xuICAgIH1cblxuICAgIGZvciAoaT0wLCBuPWhhbmRsZXJzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGggPSBoYW5kbGVyc1tpXTtcbiAgICAgIGZpbHRlcmVkID0gaC5maWx0ZXJzLnNvbWUoaW52b2tlKTtcbiAgICAgIGlmIChmaWx0ZXJlZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIHZhbCA9IGguZXhwLmZuKGRhdHVtLCBldnQsIG1vZGVsLnZhbHVlcyhTSUdOQUxTLCBoLmV4cC5nbG9iYWxzKSk7XG4gICAgICBpZiAoaC5zcGVjLnNjYWxlKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlU2lnbmFscy5zY2FsZShtb2RlbCwgaC5zcGVjLCB2YWwsIGRhdHVtLCBldnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsICE9PSBoLnNpZ25hbC52YWx1ZSgpIHx8IGguc2lnbmFsLnZlcmJvc2UoKSkge1xuICAgICAgICBoLnNpZ25hbC52YWx1ZSh2YWwpO1xuICAgICAgICBjcy5zaWduYWxzW2guc2lnbmFsLm5hbWUoKV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLnByb3BhZ2F0ZShjcywgbm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZWRTdHJlYW0oc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgc2VsZWN0b3IuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICBpZiAocy5ldmVudCkgICAgICAgZG9tRXZlbnQoc2lnLCBzLCBleHAsIHNwZWMpO1xuICAgICAgZWxzZSBpZiAocy5zaWduYWwpIHNpZ25hbChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmIChzLnN0YXJ0KSAgb3JkZXJlZFN0cmVhbShzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmIChzLnN0cmVhbSkgbWVyZ2VkU3RyZWFtKHNpZywgcy5zdHJlYW0sIGV4cCwgc3BlYyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb21FdmVudChzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgZXZ0ID0gc2VsZWN0b3IuZXZlbnQsXG4gICAgICAgIG5hbWUgPSBzZWxlY3Rvci5uYW1lLFxuICAgICAgICBtYXJrID0gc2VsZWN0b3IubWFyayxcbiAgICAgICAgdGFyZ2V0ICAgPSBzZWxlY3Rvci50YXJnZXQsXG4gICAgICAgIGZpbHRlcnMgID0gc2VsZWN0b3IuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgcmVnaXN0cnkgPSB0YXJnZXQgPyBleHRlcm5hbCA6IGludGVybmFsLFxuICAgICAgICB0eXBlID0gdGFyZ2V0ID8gdGFyZ2V0Kyc6JytldnQgOiBldnQsXG4gICAgICAgIG5vZGUgPSByZWdpc3RyeS5ub2Rlc1t0eXBlXSB8fCAocmVnaXN0cnkubm9kZXNbdHlwZV0gPSBuZXcgZGYuTm9kZShtb2RlbCkpLFxuICAgICAgICBoYW5kbGVycyA9IHJlZ2lzdHJ5LmhhbmRsZXJzW3R5cGVdIHx8IChyZWdpc3RyeS5oYW5kbGVyc1t0eXBlXSA9IFtdKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goJyEhZXZlbnQudmcubmFtZVtcIicgKyBuYW1lICsgJ1wiXScpOyAvLyBNaW1pYyBldmVudCBidWJibGluZ1xuICAgIH0gZWxzZSBpZiAobWFyaykge1xuICAgICAgZmlsdGVycy5wdXNoKCdldmVudC52Zy5pdGVtLm1hcmsgJiYgZXZlbnQudmcuaXRlbS5tYXJrLm1hcmt0eXBlPT09JytkbC5zdHIobWFyaykpO1xuICAgIH1cblxuICAgIGhhbmRsZXJzLnB1c2goe1xuICAgICAgc2lnbmFsOiBzaWcsXG4gICAgICBleHA6IGV4cCxcbiAgICAgIHNwZWM6IHNwZWMsXG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBleHByKGYpOyB9KVxuICAgIH0pO1xuXG4gICAgbm9kZS5hZGRMaXN0ZW5lcihzaWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuID0gbmV3IGRmLk5vZGUobW9kZWwpO1xuICAgIG4uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dC5zaWduYWxzW3NlbGVjdG9yLnNpZ25hbF0pIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcbiAgICAgIHZhciB2YWwgPSBleHAuZm4obnVsbCwgbnVsbCwgbW9kZWwudmFsdWVzKFNJR05BTFMsIGV4cC5nbG9iYWxzKSk7XG4gICAgICBpZiAoc3BlYy5zY2FsZSkge1xuICAgICAgICB2YWwgPSBwYXJzZVNpZ25hbHMuc2NhbGUobW9kZWwsIHNwZWMsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgIT09IHNpZy52YWx1ZSgpIHx8IHNpZy52ZXJib3NlKCkpIHtcbiAgICAgICAgc2lnLnZhbHVlKHZhbCk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbc2lnLm5hbWUoKV0gPSAxO1xuICAgICAgICBpbnB1dC5yZWZsb3cgPSB0cnVlOyAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnB1dDsgIFxuICAgIH07XG4gICAgbi5kZXBlbmRlbmN5KGRmLkRlcGVuZGVuY2llcy5TSUdOQUxTLCBzZWxlY3Rvci5zaWduYWwpO1xuICAgIG4uYWRkTGlzdGVuZXIoc2lnKTtcbiAgICBtb2RlbC5zaWduYWwoc2VsZWN0b3Iuc2lnbmFsKS5hZGRMaXN0ZW5lcihuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9yZGVyZWRTdHJlYW0oc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIG5hbWUgPSBzaWcubmFtZSgpLCBcbiAgICAgICAgZ2sgPSBuYW1lICsgR0FURUtFRVBFUiwgXG4gICAgICAgIHRydWVGbiAgPSBleHByKCd0cnVlJyksIFxuICAgICAgICBmYWxzZUZuID0gZXhwcignZmFsc2UnKSxcbiAgICAgICAgbWlkZGxlICA9IHNlbGVjdG9yLm1pZGRsZSxcbiAgICAgICAgZmlsdGVycyA9IG1pZGRsZS5maWx0ZXJzIHx8IChtaWRkbGUuZmlsdGVycyA9IFtdKSxcbiAgICAgICAgZ2F0ZWtlZXBlciA9IG1vZGVsLnNpZ25hbChnaykgfHwgbW9kZWwuc2lnbmFsKGdrLCBmYWxzZSk7XG5cbiAgICAvLyBSZWdpc3RlciBhbiBhbm9ueW1vdXMgc2lnbmFsIHRvIGFjdCBhcyBhIGdhdGVrZWVwZXIuIEl0cyB2YWx1ZSBpc1xuICAgIC8vIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHN0YXJ0IG9yIGVuZCBzdHJlYW1zIG9jY3VyLiBcbiAgICAvLyBUaGUgbWlkZGxlIHNpZ25hbCB0aGVuIHNpbXBseSBmaWx0ZXJzIGZvciB0aGUgZ2F0ZWtlZXBlcidzIHZhbHVlLiBcbiAgICBtZXJnZWRTdHJlYW0oZ2F0ZWtlZXBlciwgW3NlbGVjdG9yLnN0YXJ0XSwgdHJ1ZUZuLCB7fSk7XG4gICAgbWVyZ2VkU3RyZWFtKGdhdGVrZWVwZXIsIFtzZWxlY3Rvci5lbmRdLCBmYWxzZUZuLCB7fSk7XG5cbiAgICBmaWx0ZXJzLnB1c2goZ2F0ZWtlZXBlci5uYW1lKCkpO1xuICAgIG1lcmdlZFN0cmVhbShzaWcsIFtzZWxlY3Rvci5taWRkbGVdLCBleHAsIHNwZWMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VTdHJlYW1zOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICB0cmFuc2Zvcm1zID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9pbmRleCcpO1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIGRlZikge1xuICB2YXIgdHggPSBuZXcgdHJhbnNmb3Jtc1tkZWYudHlwZV0obW9kZWwpO1xuICBcbiAgLy8gV2Ugd2FudCB0byByZW5hbWUgb3V0cHV0IGZpZWxkcyBiZWZvcmUgc2V0dGluZyBhbnkgb3RoZXIgcHJvcGVydGllcyxcbiAgLy8gYXMgc3Vic2VxdWVudCBwcm9wZXJ0aWVzIG1heSByZXF1aXJlIG91dHB1dCB0byBiZSBzZXQgKGUuZy4gZ3JvdXAgYnkpLlxuICBpZihkZWYub3V0cHV0KSB0eC5vdXRwdXQoZGVmLm91dHB1dCk7XG5cbiAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmKGsgPT09ICd0eXBlJyB8fCBrID09PSAnb3V0cHV0JykgcmV0dXJuO1xuICAgIHR4LnBhcmFtKGssIGRlZltrXSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRyYW5zZm9ybXM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIE5vZGUgPSBkZi5Ob2RlLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBib3VuZCA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLmJvdW5kLFxuICAgIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXInKTtcblxuZnVuY3Rpb24gQm91bmRlcihncmFwaCwgbWFyaykge1xuICB0aGlzLl9tYXJrID0gbWFyaztcbiAgcmV0dXJuIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLnJlZmxvd3ModHJ1ZSlcbiAgICAubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKEJvdW5kZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2JvdW5kcycsIHRoaXMuX21hcmsubWFya3R5cGVdKTtcblxuICB2YXIgdHlwZSAgPSB0aGlzLl9tYXJrLm1hcmt0eXBlLFxuICAgICAgaXNHcnAgPSB0eXBlID09PSAnZ3JvdXAnLFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgaGFzTGVnZW5kcyA9IGRsLmFycmF5KHRoaXMuX21hcmsuZGVmLmxlZ2VuZHMpLmxlbmd0aCA+IDAsXG4gICAgICBpLCBpbGVuLCBqLCBqbGVuLCBncm91cCwgbGVnZW5kO1xuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGggfHwgIWl0ZW1zLmxlbmd0aCB8fCBcbiAgICAgIGlucHV0Lm1vZC5sZW5ndGggPT09IGl0ZW1zLmxlbmd0aCB8fFxuICAgICAgdHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdsaW5lJykge1xuICAgIGJvdW5kLm1hcmsodGhpcy5fbWFyaywgbnVsbCwgaXNHcnAgJiYgIWhhc0xlZ2VuZHMpO1xuICB9IGVsc2Uge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHsgYm91bmQuaXRlbShpdGVtKTsgfSk7XG4gIH1cblxuICBpZiAoaXNHcnAgJiYgaGFzTGVnZW5kcykge1xuICAgIGZvciAoaT0wLCBpbGVuPWl0ZW1zLmxlbmd0aDsgaTxpbGVuOyArK2kpIHtcbiAgICAgIGdyb3VwID0gaXRlbXNbaV07XG4gICAgICBncm91cC5fbGVnZW5kUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGZvciAoaj0wLCBqbGVuPWdyb3VwLmxlZ2VuZEl0ZW1zLmxlbmd0aDsgajxqbGVuOyArK2opIHtcbiAgICAgICAgbGVnZW5kID0gZ3JvdXAubGVnZW5kSXRlbXNbal07XG4gICAgICAgIEVuY29kZXIudXBkYXRlKHRoaXMuX2dyYXBoLCBpbnB1dC50cmFucywgJ3ZnX2xlZ2VuZFBvc2l0aW9uJywgbGVnZW5kLml0ZW1zLCBpbnB1dC5kaXJ0eSk7XG4gICAgICAgIGJvdW5kLm1hcmsobGVnZW5kLCBudWxsLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYm91bmQubWFyayh0aGlzLl9tYXJrLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBkZi5DaGFuZ2VTZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgSXRlbSA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLkl0ZW0sXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgTm9kZSA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXMsXG4gICAgVHVwbGUgPSBkZi5UdXBsZSxcbiAgICBDaGFuZ2VTZXQgPSBkZi5DaGFuZ2VTZXQsXG4gICAgU2VudGluZWwgPSB7fSxcbiAgICBFbmNvZGVyICA9IHJlcXVpcmUoJy4vRW5jb2RlcicpLFxuICAgIEJvdW5kZXIgID0gcmVxdWlyZSgnLi9Cb3VuZGVyJyksXG4gICAgcGFyc2VEYXRhID0gcmVxdWlyZSgnLi4vcGFyc2UvZGF0YScpO1xuXG5mdW5jdGlvbiBCdWlsZGVyKCkgeyAgICBcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBTdGF0dXMgPSBCdWlsZGVyLlNUQVRVUyA9IHtcbiAgRU5URVI6ICAnZW50ZXInLFxuICBVUERBVEU6ICd1cGRhdGUnLFxuICBFWElUOiAgICdleGl0J1xufTtcblxudmFyIENPTk5FQ1RFRCA9IDEsIERJU0NPTk5FQ1RFRCA9IDI7XG5cbnZhciBwcm90byA9IChCdWlsZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgsIGRlZiwgbWFyaywgcGFyZW50LCBwYXJlbnRfaWQsIGluaGVyaXRGcm9tKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICB0aGlzLl9kZWYgICA9IGRlZjtcbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuICB0aGlzLl9mcm9tICA9IChkZWYuZnJvbSA/IGRlZi5mcm9tLmRhdGEgOiBudWxsKSB8fCBpbmhlcml0RnJvbTtcbiAgdGhpcy5fZHMgICAgPSBkbC5pc1N0cmluZyh0aGlzLl9mcm9tKSA/IGdyYXBoLmRhdGEodGhpcy5fZnJvbSkgOiBudWxsO1xuICB0aGlzLl9tYXAgICA9IHt9O1xuICB0aGlzLl9zdGF0dXMgPSBudWxsOyAvLyBDb25uZWN0ZWQgb3IgZGlzY29ubmVjdGVkP1xuXG4gIG1hcmsuZGVmID0gZGVmO1xuICBtYXJrLm1hcmt0eXBlID0gZGVmLnR5cGU7XG4gIG1hcmsuaW50ZXJhY3RpdmUgPSAoZGVmLmludGVyYWN0aXZlICE9PSBmYWxzZSk7XG4gIG1hcmsuaXRlbXMgPSBbXTtcbiAgaWYgKGRsLmlzVmFsaWQoZGVmLm5hbWUpKSBtYXJrLm5hbWUgPSBkZWYubmFtZTtcblxuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX3BhcmVudF9pZCA9IHBhcmVudF9pZDtcblxuICBpZiAoZGVmLmZyb20gJiYgKGRlZi5mcm9tLm1hcmsgfHwgZGVmLmZyb20udHJhbnNmb3JtIHx8IGRlZi5mcm9tLm1vZGlmeSkpIHtcbiAgICBpbmxpbmVEcy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTm9uLWdyb3VwIG1hcmsgYnVpbGRlcnMgYXJlIHN1cGVyIG5vZGVzLiBFbmNvZGVyIGFuZCBCb3VuZGVyIHJlbWFpbiBcbiAgLy8gc2VwYXJhdGUgb3BlcmF0b3JzIGJ1dCBhcmUgZW1iZWRkZWQgYW5kIGNhbGxlZCBieSBCdWlsZGVyLmV2YWx1YXRlLlxuICB0aGlzLl9pc1N1cGVyID0gKHRoaXMuX2RlZi50eXBlICE9PSAnZ3JvdXAnKTsgXG4gIHRoaXMuX2VuY29kZXIgPSBuZXcgRW5jb2Rlcih0aGlzLl9ncmFwaCwgdGhpcy5fbWFyaywgdGhpcyk7XG4gIHRoaXMuX2JvdW5kZXIgPSBuZXcgQm91bmRlcih0aGlzLl9ncmFwaCwgdGhpcy5fbWFyayk7XG4gIHRoaXMuX291dHB1dCAgPSBudWxsOyAvLyBPdXRwdXQgY2hhbmdlc2V0IGZvciByZWFjdGl2ZSBnZW9tIGFzIEJvdW5kZXIgcmVmbG93c1xuXG4gIGlmICh0aGlzLl9kcykgeyB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koRGVwcy5EQVRBLCB0aGlzLl9mcm9tKTsgfVxuXG4gIC8vIFNpbmNlIEJ1aWxkZXJzIGFyZSBzdXBlciBub2RlcywgY29weSBvdmVyIGVuY29kZXIgZGVwZW5kZW5jaWVzXG4gIC8vIChib3VuZGVyIGhhcyBubyByZWdpc3RlcmVkIGRlcGVuZGVuY2llcykuXG4gIHRoaXMuZGVwZW5kZW5jeShEZXBzLkRBVEEsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShEZXBzLkRBVEEpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KERlcHMuU0NBTEVTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUmVhY3RpdmUgZ2VvbWV0cnkgYW5kIG1hcmstbGV2ZWwgdHJhbnNmb3JtYXRpb25zIGFyZSBoYW5kbGVkIGhlcmUgXG4vLyBiZWNhdXNlIHRoZXkgbmVlZCB0aGVpciBncm91cCdzIGRhdGEtam9pbmVkIGNvbnRleHQuIFxuZnVuY3Rpb24gaW5saW5lRHMoKSB7XG4gIHZhciBmcm9tID0gdGhpcy5fZGVmLmZyb20sXG4gICAgICBnZW9tID0gZnJvbS5tYXJrLFxuICAgICAgc3JjLCBuYW1lLCBzcGVjLCBzaWJsaW5nLCBvdXRwdXQsIGlucHV0O1xuXG4gIGlmIChnZW9tKSB7XG4gICAgbmFtZSA9IFsndmcnLCB0aGlzLl9wYXJlbnRfaWQsIGdlb21dLmpvaW4oJ18nKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sIFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3JjID0gdGhpcy5fZ3JhcGguZGF0YSh0aGlzLl9mcm9tKTtcbiAgICBuYW1lID0gWyd2ZycsIHRoaXMuX2Zyb20sIHRoaXMuX2RlZi50eXBlLCBzcmMubGlzdGVuZXJzKHRydWUpLmxlbmd0aF0uam9pbignXycpO1xuICAgIHNwZWMgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc291cmNlOiB0aGlzLl9mcm9tLFxuICAgICAgdHJhbnNmb3JtOiBmcm9tLnRyYW5zZm9ybSxcbiAgICAgIG1vZGlmeTogZnJvbS5tb2RpZnlcbiAgICB9O1xuICB9XG5cbiAgdGhpcy5fZnJvbSA9IG5hbWU7XG4gIHRoaXMuX2RzID0gcGFyc2VEYXRhLmRhdGFzb3VyY2UodGhpcy5fZ3JhcGgsIHNwZWMpO1xuICB2YXIgbm9kZTtcblxuICBpZiAoZ2VvbSkge1xuICAgIHNpYmxpbmcgPSB0aGlzLnNpYmxpbmcoZ2VvbSk7XG5cbiAgICAvLyBCb3VuZGVyIHJlZmxvd3MsIHNvIHdlIG5lZWQgYW4gaW50ZXJtZWRpYXJ5IG5vZGUgdG8gcHJvcGFnYXRlXG4gICAgLy8gdGhlIG91dHB1dCBjb25zdHJ1Y3RlZCBieSB0aGUgQnVpbGRlci5cbiAgICBub2RlID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpLmFkZExpc3RlbmVyKHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICAgIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNpYmxpbmcuX291dHB1dDsgfTtcblxuICAgIGlmIChzaWJsaW5nLl9pc1N1cGVyKSB7XG4gICAgICBzaWJsaW5nLmFkZExpc3RlbmVyKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWJsaW5nLl9ib3VuZGVyLmFkZExpc3RlbmVyKG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGEgbmV3IGRhdGFzb3VyY2UgYnV0IGl0IGlzIGVtcHR5IGFzXG4gICAgLy8gdGhlIHByb3BhZ2F0aW9uIGN5Y2xlIGhhcyBhbHJlYWR5IGNyb3NzZWQgdGhlIGRhdGFzb3VyY2VzLiBcbiAgICAvLyBTbywgd2UgcmVwdWxzZSBqdXN0IHRoaXMgZGF0YXNvdXJjZS4gVGhpcyBzaG91bGQgYmUgc2FmZVxuICAgIC8vIGFzIHRoZSBkcyBpc24ndCBjb25uZWN0ZWQgdG8gdGhlIHNjZW5lZ3JhcGggeWV0LlxuICAgIG91dHB1dCA9IHRoaXMuX2RzLnNvdXJjZSgpLmxhc3QoKTtcbiAgICBpbnB1dCAgPSBDaGFuZ2VTZXQuY3JlYXRlKG91dHB1dCk7XG5cbiAgICBpbnB1dC5hZGQgPSBvdXRwdXQuYWRkO1xuICAgIGlucHV0Lm1vZCA9IG91dHB1dC5tb2Q7XG4gICAgaW5wdXQucmVtID0gb3V0cHV0LnJlbTtcbiAgICBpbnB1dC5zdGFtcCA9IG51bGw7XG4gICAgdGhpcy5fZ3JhcGgucHJvcGFnYXRlKGlucHV0LCB0aGlzLl9kcy5saXN0ZW5lcigpLCBvdXRwdXQuc3RhbXApO1xuICB9XG59XG5cbnByb3RvLmRzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kczsgfTtcbnByb3RvLnBhcmVudCAgID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH07XG5wcm90by5lbmNvZGVyICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZW5jb2RlcjsgfTtcbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7IHJldHVybiBbdGhpc107IH07XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgdGhpcy5fZW5jb2Rlci5fc2NhbGVzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIGlmICghKHMgPSBidWlsZGVyLl9wYXJlbnQuc2NhbGUocykpKSByZXR1cm47XG4gICAgcy5hZGRMaXN0ZW5lcihidWlsZGVyKTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgIGlmICh0aGlzLl9pc1N1cGVyKSB0aGlzLmFkZExpc3RlbmVyKHRoaXMuX3BhcmVudC5fY29sbGVjdG9yKTtcbiAgICBlbHNlIHRoaXMuX2JvdW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICB9XG5cbiAgcmV0dXJuICh0aGlzLl9zdGF0dXMgPSBDT05ORUNURUQsIHRoaXMpO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVpbGRlciA9IHRoaXM7XG4gIGlmICghdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgZnVuY3Rpb24gZGlzY29ubmVjdFNjYWxlcyhzY2FsZXMpIHtcbiAgICBmb3IodmFyIGk9MCwgbGVuPXNjYWxlcy5sZW5ndGgsIHM7IGk8bGVuOyArK2kpIHtcbiAgICAgIGlmICghKHMgPSBidWlsZGVyLl9wYXJlbnQuc2NhbGUoc2NhbGVzW2ldKSkpIGNvbnRpbnVlO1xuICAgICAgcy5yZW1vdmVMaXN0ZW5lcihidWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBOb2RlLnByb3RvdHlwZS5kaXNjb25uZWN0LmNhbGwodGhpcyk7XG4gIHRoaXMuX2dyYXBoLmRpc2Nvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgZGlzY29ubmVjdFNjYWxlcyh0aGlzLl9lbmNvZGVyLl9zY2FsZXMpO1xuICBkaXNjb25uZWN0U2NhbGVzKGRsLmtleXModGhpcy5fbWFyay5fc2NhbGVSZWZzKSk7XG4gIFxuICByZXR1cm4gKHRoaXMuX3N0YXR1cyA9IERJU0NPTk5FQ1RFRCwgdGhpcyk7XG59O1xuXG5wcm90by5zaWJsaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmNoaWxkKG5hbWUsIHRoaXMuX3BhcmVudF9pZCk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydidWlsZGluZycsICh0aGlzLl9mcm9tIHx8IHRoaXMuX2RlZi5mcm9tKSwgdGhpcy5fZGVmLnR5cGVdKTtcblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBkZWYgPSB0aGlzLl9tYXJrLmRlZixcbiAgICAgIHByb3BzICA9IGRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlICAgfHwge30sXG4gICAgICBvdXRwdXQsIGZ1bGxVcGRhdGUsIGZjcywgZGF0YSwgbmFtZTtcblxuICBpZiAodGhpcy5fZHMpIHtcbiAgICBvdXRwdXQgPSBDaGFuZ2VTZXQuY3JlYXRlKGlucHV0KTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGFueSBlbmNvZGVyIGRlcGVuZGVuY2llcyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAvLyBIb3dldmVyLCB0aGUgZW5jb2RlcidzIGRhdGEgc291cmNlIHdpbGwgbGlrZWx5IGJlIHVwZGF0ZWQsIGFuZCBzaG91bGRuJ3RcbiAgICAvLyB0cmlnZ2VyIGFsbCBpdGVtcyB0byBtb2QuXG4gICAgZGF0YSA9IG91dHB1dC5kYXRhWyhuYW1lPXRoaXMuX2RzLm5hbWUoKSldO1xuICAgIGRlbGV0ZSBvdXRwdXQuZGF0YVtuYW1lXTtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LmRhdGFbbmFtZV0gPSBkYXRhO1xuXG4gICAgLy8gSWYgYSBzY2FsZSBvciBzaWduYWwgaW4gdGhlIHVwZGF0ZSBwcm9wc2V0IGhhcyBiZWVuIHVwZGF0ZWQsIFxuICAgIC8vIHNlbmQgZm9yd2FyZCBhbGwgaXRlbXMgZm9yIHJlZW5jb2RpbmcgaWYgd2UgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgIGlmIChmdWxsVXBkYXRlKSBvdXRwdXQubW9kID0gdGhpcy5fbWFyay5pdGVtcy5zbGljZSgpO1xuXG4gICAgZmNzID0gdGhpcy5fZHMubGFzdCgpO1xuICAgIGlmICghZmNzKSB0aHJvdyBFcnJvcignQnVpbGRlciBldmFsdWF0ZWQgYmVmb3JlIGJhY2tpbmcgRGF0YVNvdXJjZS4nKTtcbiAgICBpZiAoZmNzLnN0YW1wID4gdGhpcy5fc3RhbXApIHtcbiAgICAgIG91dHB1dCA9IGpvaW4uY2FsbCh0aGlzLCBmY3MsIHRoaXMuX2RzLnZhbHVlcygpLCB0cnVlLCBmdWxsVXBkYXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IGRsLmlzRnVuY3Rpb24odGhpcy5fZGVmLmZyb20pID8gdGhpcy5fZGVmLmZyb20oKSA6IFtTZW50aW5lbF07XG4gICAgb3V0cHV0ID0gam9pbi5jYWxsKHRoaXMsIGlucHV0LCBkYXRhKTtcbiAgfVxuXG4gIC8vIFN0YXNoIG91dHB1dCBiZWZvcmUgQm91bmRlciBmb3IgZG93bnN0cmVhbSByZWFjdGl2ZSBnZW9tZXRyeS5cbiAgdGhpcy5fb3V0cHV0ID0gb3V0cHV0ID0gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9lbmNvZGVyKTtcblxuICAvLyBBZGQgYW55IG5ldyBzY2FsZSByZWZlcmVuY2VzIHRvIHRoZSBkZXBlbmRlbmN5IGxpc3QsIGFuZCBlbnN1cmVcbiAgLy8gdGhleSdyZSBjb25uZWN0ZWQuXG4gIGlmICh1cGRhdGUubmVzdGVkICYmIHVwZGF0ZS5uZXN0ZWQubGVuZ3RoICYmIHRoaXMuX3N0YXR1cyA9PT0gQ09OTkVDVEVEKSB7XG4gICAgZGwua2V5cyh0aGlzLl9tYXJrLl9zY2FsZVJlZnMpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgdmFyIHNjYWxlID0gc2VsZi5fcGFyZW50LnNjYWxlKHMpO1xuICAgICAgaWYgKCFzY2FsZSkgcmV0dXJuO1xuXG4gICAgICBzY2FsZS5hZGRMaXN0ZW5lcihzZWxmKTtcbiAgICAgIHNlbGYuZGVwZW5kZW5jeShEZXBzLlNDQUxFUywgcyk7XG4gICAgICBzZWxmLl9lbmNvZGVyLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMsIHMpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gU3VwZXJub2RlcyBjYWxjdWxhdGUgYm91bmRzIHRvbywgYnV0IG9ubHkgb24gaXRlbXMgbWFya2VkIGRpcnR5LlxuICBpZiAodGhpcy5faXNTdXBlcikge1xuICAgIG91dHB1dC5tb2QgPSBvdXRwdXQubW9kLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4Ll9kaXJ0eTsgfSk7XG4gICAgb3V0cHV0ID0gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9ib3VuZGVyKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5mdW5jdGlvbiBuZXdJdGVtKCkge1xuICB2YXIgaXRlbSA9IFR1cGxlLmluZ2VzdChuZXcgSXRlbSh0aGlzLl9tYXJrKSk7XG5cbiAgLy8gRm9yIHRoZSByb290IG5vZGUncyBpdGVtXG4gIGlmICh0aGlzLl9kZWYud2lkdGgpICBUdXBsZS5zZXQoaXRlbSwgJ3dpZHRoJywgIHRoaXMuX2RlZi53aWR0aCk7XG4gIGlmICh0aGlzLl9kZWYuaGVpZ2h0KSBUdXBsZS5zZXQoaXRlbSwgJ2hlaWdodCcsIHRoaXMuX2RlZi5oZWlnaHQpO1xuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gam9pbihpbnB1dCwgZGF0YSwgZHMsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkgfHwgKGRzID8gJ19pZCcgOiBudWxsKSksXG4gICAgICBwcmV2ID0gdGhpcy5fbWFyay5pdGVtcyB8fCBbXSxcbiAgICAgIHJlbSAgPSBkcyA/IGlucHV0LnJlbSA6IHByZXYsXG4gICAgICBtb2QgID0gVHVwbGUuaWRNYXAoKCFkcyB8fCBmdWxsVXBkYXRlKSA/IGRhdGEgOiBpbnB1dC5tb2QpLFxuICAgICAgbmV4dCA9IFtdLFxuICAgICAgaSwga2V5LCBsZW4sIGl0ZW0sIGRhdHVtLCBlbnRlciwgZGlmZjtcblxuICAvLyBPbmx5IG1hcmsgcmVtcyBhcyBleGl0aW5nLiBEdWUgdG8ga2V5ZiwgdGhlcmUgbWF5IGJlIGFuIGFkZC9tb2QgXG4gIC8vIHR1cGxlIHRoYXQgcmVwbGFjZXMgaXQuXG4gIGZvciAoaT0wLCBsZW49cmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSAocmVtW2ldID09PSBwcmV2W2ldKSA/IHByZXZbaV0gOlxuICAgICAga2V5ZiA/IHRoaXMuX21hcFtrZXlmKHJlbVtpXSldIDogcmVtW2ldO1xuICAgIGl0ZW0uc3RhdHVzID0gU3RhdHVzLkVYSVQ7XG4gIH1cblxuICBmb3IoaT0wLCBsZW49ZGF0YS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkYXR1bSA9IGRhdGFbaV07XG4gICAgaXRlbSAgPSBrZXlmID8gdGhpcy5fbWFwW2tleSA9IGtleWYoZGF0dW0pXSA6IHByZXZbaV07XG4gICAgZW50ZXIgPSBpdGVtID8gZmFsc2UgOiAoaXRlbSA9IG5ld0l0ZW0uY2FsbCh0aGlzKSwgdHJ1ZSk7XG4gICAgaXRlbS5zdGF0dXMgPSBlbnRlciA/IFN0YXR1cy5FTlRFUiA6IFN0YXR1cy5VUERBVEU7XG4gICAgZGlmZiA9ICFlbnRlciAmJiBpdGVtLmRhdHVtICE9PSBkYXR1bTtcbiAgICBpdGVtLmRhdHVtID0gZGF0dW07XG5cbiAgICBpZiAoa2V5Zikge1xuICAgICAgVHVwbGUuc2V0KGl0ZW0sICdrZXknLCBrZXkpO1xuICAgICAgdGhpcy5fbWFwW2tleV0gPSBpdGVtO1xuICAgIH1cblxuICAgIGlmIChlbnRlcikge1xuICAgICAgb3V0cHV0LmFkZC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoZGlmZiB8fCBtb2RbZGF0dW0uX2lkXSkge1xuICAgICAgb3V0cHV0Lm1vZC5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIG5leHQucHVzaChpdGVtKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBsZW49cmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSAocmVtW2ldID09PSBwcmV2W2ldKSA/IHByZXZbaV0gOlxuICAgICAga2V5ZiA/IHRoaXMuX21hcFtrZXkgPSBrZXlmKHJlbVtpXSldIDogcmVtW2ldO1xuICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gU3RhdHVzLkVYSVQpIHtcbiAgICAgIGl0ZW0uX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIGlucHV0LmRpcnR5LnB1c2goaXRlbSk7XG4gICAgICBuZXh0LnB1c2goaXRlbSk7XG4gICAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgICBpZiAoa2V5ZikgdGhpcy5fbWFwW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAodGhpcy5fbWFyay5pdGVtcyA9IG5leHQsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGtleUZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgZiA9IGRsLmFycmF5KGtleSkubWFwKGRsLmFjY2Vzc29yKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICBmb3IgKHZhciBzPScnLCBpPTAsIG49Zi5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoaT4wKSBzICs9ICd8JztcbiAgICAgIHMgKz0gU3RyaW5nKGZbaV0oZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBOb2RlID0gZGYuTm9kZSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBib3VuZCA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLmJvdW5kO1xuXG52YXIgRU1QVFkgPSB7fTtcblxuZnVuY3Rpb24gRW5jb2RlcihncmFwaCwgbWFyaywgYnVpbGRlcikge1xuICB2YXIgcHJvcHMgID0gbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGVudGVyICA9IHByb3BzLmVudGVyLFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlLFxuICAgICAgZXhpdCAgID0gcHJvcHMuZXhpdDtcblxuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuXG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICB0aGlzLl9idWlsZGVyID0gYnVpbGRlcjtcbiAgdmFyIHMgPSB0aGlzLl9zY2FsZXMgPSBbXTtcblxuICAvLyBPbmx5IHNjYWxlcyB1c2VkIGluIHRoZSAndXBkYXRlJyBwcm9wZXJ0eSBzZXQgYXJlIHNldCBhc1xuICAvLyBlbmNvZGVyIGRlcGVkZW5jaWVzIHRvIGhhdmUgdGFyZ2V0ZWQgcmVldmFsdWF0aW9ucy4gSG93ZXZlcixcbiAgLy8gd2Ugc3RpbGwgd2FudCBzY2FsZXMgaW4gJ2VudGVyJyBhbmQgJ2V4aXQnIHRvIGJlIGV2YWx1YXRlZFxuICAvLyBiZWZvcmUgdGhlIGVuY29kZXIuIFxuICBpZiAoZW50ZXIpIHMucHVzaC5hcHBseShzLCBlbnRlci5zY2FsZXMpO1xuXG4gIGlmICh1cGRhdGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3koRGVwcy5EQVRBLCB1cGRhdGUuZGF0YSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgdXBkYXRlLnNpZ25hbHMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShEZXBzLkZJRUxEUywgdXBkYXRlLmZpZWxkcyk7XG4gICAgdGhpcy5kZXBlbmRlbmN5KERlcHMuU0NBTEVTLCB1cGRhdGUuc2NhbGVzKTtcbiAgICBzLnB1c2guYXBwbHkocywgdXBkYXRlLnNjYWxlcyk7XG4gIH1cblxuICBpZiAoZXhpdCkgcy5wdXNoLmFwcGx5KHMsIGV4aXQuc2NhbGVzKTtcblxuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoRW5jb2Rlci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnZW5jb2RpbmcnLCB0aGlzLl9tYXJrLmRlZi50eXBlXSk7XG4gIHZhciBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0LFxuICAgICAgZGlydHkgID0gaW5wdXQuZGlydHksXG4gICAgICBwcmVkcyAgPSBncmFwaC5wcmVkaWNhdGVzKCksXG4gICAgICByZXEgPSBpbnB1dC5yZXF1ZXN0LFxuICAgICAgZ3JvdXAgPSB0aGlzLl9tYXJrLmdyb3VwLFxuICAgICAgZ3VpZGUgPSBncm91cCAmJiAoZ3JvdXAubWFyay5heGlzIHx8IGdyb3VwLm1hcmsubGVnZW5kKSxcbiAgICAgIGRiID0gRU1QVFksIHNnID0gRU1QVFksIGksIGxlbiwgaXRlbSwgcHJvcDtcblxuICBpZiAocmVxICYmICFndWlkZSkge1xuICAgIGlmICgocHJvcCA9IHByb3BzW3JlcV0pICYmIGlucHV0Lm1vZC5sZW5ndGgpIHtcbiAgICAgIGRiID0gcHJvcC5kYXRhID8gZ3JhcGgudmFsdWVzKERlcHMuREFUQSwgcHJvcC5kYXRhKSA6IG51bGw7XG4gICAgICBzZyA9IHByb3Auc2lnbmFscyA/IGdyYXBoLnZhbHVlcyhEZXBzLlNJR05BTFMsIHByb3Auc2lnbmFscykgOiBudWxsO1xuXG4gICAgICBmb3IgKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGlucHV0Lm1vZFtpXTtcbiAgICAgICAgZW5jb2RlLmNhbGwodGhpcywgcHJvcCwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMsIGRpcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7IC8vIGV4aXQgZWFybHkgaWYgZ2l2ZW4gcmVxdWVzdFxuICB9XG5cbiAgZGIgPSB2YWx1ZXMoRGVwcy5EQVRBLCBncmFwaCwgaW5wdXQsIHByb3BzKTtcbiAgc2cgPSB2YWx1ZXMoRGVwcy5TSUdOQUxTLCBncmFwaCwgaW5wdXQsIHByb3BzKTtcblxuICAvLyBJdGVtcyBtYXJrZWQgZm9yIHJlbW92YWwgYXJlIGF0IHRoZSB0YWlsIG9mIGl0ZW1zLiBQcm9jZXNzIHRoZW0gZmlyc3QuXG4gIGZvciAoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5yZW1baV07XG4gICAgaWYgKGV4aXQpIGVuY29kZS5jYWxsKHRoaXMsIGV4aXQsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzLCBkaXJ0eSk7IFxuICAgIGlmIChpbnB1dC50cmFucyAmJiAhZXhpdCkgaW5wdXQudHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgRU1QVFkpO1xuICAgIGVsc2UgaWYgKCFpbnB1dC50cmFucykgaXRlbXMucG9wKCk7XG4gIH1cblxuICB2YXIgdXBkYXRlX3N0YXR1cyA9IHJlcXVpcmUoJy4vQnVpbGRlcicpLlNUQVRVUy5VUERBVEU7XG4gIGZvciAoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5hZGRbaV07XG4gICAgaWYgKGVudGVyKSAgZW5jb2RlLmNhbGwodGhpcywgZW50ZXIsICBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpO1xuICAgIGlmICh1cGRhdGUpIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMsIGRpcnR5KTtcbiAgICBpdGVtLnN0YXR1cyA9IHVwZGF0ZV9zdGF0dXM7XG4gIH1cblxuICBpZiAodXBkYXRlKSB7XG4gICAgZm9yIChpPTAsIGxlbj1pbnB1dC5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaW5wdXQubW9kW2ldO1xuICAgICAgZW5jb2RlLmNhbGwodGhpcywgdXBkYXRlLCBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbi8vIE9ubHkgbWFyc2hhbCBuZWNlc3NhcnkgZGF0YSBhbmQgc2lnbmFsIHZhbHVlc1xuZnVuY3Rpb24gdmFsdWVzKHR5cGUsIGdyYXBoLCBpbnB1dCwgcHJvcHMpIHtcbiAgdmFyIHAsIHgsIG8sIGFkZCA9IGlucHV0LmFkZC5sZW5ndGg7XG4gIGlmICgocD1wcm9wcy5lbnRlcikgJiYgKHg9cFt0eXBlXSkubGVuZ3RoICYmIGFkZCkge1xuICAgIG8gPSBncmFwaC52YWx1ZXModHlwZSwgeCwgKG89b3x8e30pKTtcbiAgfVxuICBpZiAoKHA9cHJvcHMuZXhpdCkgJiYgKHg9cFt0eXBlXSkubGVuZ3RoICYmIGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICBvID0gZ3JhcGgudmFsdWVzKHR5cGUsIHgsIChvPW98fHt9KSk7IFxuICB9XG4gIGlmICgocD1wcm9wcy51cGRhdGUpICYmICh4PXBbdHlwZV0pLmxlbmd0aCAmJiAoYWRkIHx8IGlucHV0Lm1vZC5sZW5ndGgpKSB7XG4gICAgbyA9IGdyYXBoLnZhbHVlcyh0eXBlLCB4LCAobz1vfHx7fSkpO1xuICB9XG4gIHJldHVybiBvIHx8IEVNUFRZO1xufVxuXG5mdW5jdGlvbiBlbmNvZGUocHJvcCwgaXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMsIGRpcnR5KSB7XG4gIHZhciBlbmMgPSBwcm9wLmVuY29kZSxcbiAgICAgIHdhc0RpcnR5ID0gaXRlbS5fZGlydHksXG4gICAgICBpc0RpcnR5ICA9IGVuYy5jYWxsKGVuYywgaXRlbSwgaXRlbS5tYXJrLmdyb3VwfHxpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcyk7XG5cbiAgaXRlbS5fZGlydHkgPSBpc0RpcnR5IHx8IHdhc0RpcnR5O1xuICBpZiAoaXNEaXJ0eSAmJiAhd2FzRGlydHkpIGRpcnR5LnB1c2goaXRlbSk7XG59XG5cbi8vIElmIGEgc3BlY2lmaWVkIHByb3BlcnR5IHNldCBjYWxsZWQsIG9yIHVwZGF0ZSBwcm9wZXJ0eSBzZXQgXG4vLyB1c2VzIG5lc3RlZCBmaWVsZHJlZnMsIHJlZXZhbHVhdGUgYWxsIGl0ZW1zLlxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9tYXJrLmRlZixcbiAgICAgIHByb3BzID0gZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICByZWV2YWwgPSBkbC5pc0Z1bmN0aW9uKGRlZi5mcm9tKSB8fCBkZWYub3JpZW50IHx8IHB1bHNlLnJlcXVlc3QgfHwgXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnJlZXZhbHVhdGUuY2FsbCh0aGlzLCBwdWxzZSk7XG5cbiAgcmV0dXJuIHJlZXZhbCB8fCAocHJvcHMudXBkYXRlID8gbmVzdGVkUmVmcy5jYWxsKHRoaXMpIDogZmFsc2UpO1xufTtcblxuLy8gVGVzdCBpZiBhbnkgbmVzdGVkIHJlZnMgdHJpZ2dlciBhIHJlZmxvdyBvZiBtYXJrIGl0ZW1zLlxuZnVuY3Rpb24gbmVzdGVkUmVmcygpIHtcbiAgdmFyIHJlZnMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzLnVwZGF0ZS5uZXN0ZWQsXG4gICAgICBwYXJlbnQgPSB0aGlzLl9idWlsZGVyLFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgaSA9IDAsIGxlbiA9IHJlZnMubGVuZ3RoLFxuICAgICAgcmVmLCBkcywgc3RhbXA7XG5cbiAgZm9yICg7IGk8bGVuOyArK2kpIHtcbiAgICByZWYgPSByZWZzW2ldO1xuXG4gICAgLy8gU2NhbGUgcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQgdmlhIHRoaXMuX21hcmsuX3NjYWxlUmVmcyB3aGljaCBhcmVcbiAgICAvLyBhZGRlZCB0byBkZXBlbmRlbmN5IGxpc3RzICsgY29ubmVjdGVkIGluIEJ1aWxkZXIuZXZhbHVhdGUuXG4gICAgaWYgKHJlZi5zY2FsZSkgY29udGludWU7XG5cbiAgICBmb3IgKDsgbGV2ZWw8cmVmLmxldmVsOyArK2xldmVsKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KCk7XG4gICAgICBkcyA9IHBhcmVudC5kcygpO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgc3RhbXBzIHRvIGRldGVybWluZSBpZiBhIGNoYW5nZSBpbiBhIGdyb3VwJ3MgcHJvcGVydGllc1xuICAgIC8vIG9yIGRhdGEgc2hvdWxkIHRyaWdnZXIgYSByZWV2YWwuIFdlIGNhbm5vdCBjaGVjayBhbnl0aGluZyBmYW5jaWVyXG4gICAgLy8gKGUuZy4sIHB1bHNlLmZpZWxkcykgYXMgdGhlIHJlZiBtYXkgdXNlIGl0ZW0uZGF0dW0uXG4gICAgc3RhbXAgPSAocmVmLmdyb3VwID8gcGFyZW50LmVuY29kZXIoKSA6IGRzLmxhc3QoKSkuX3N0YW1wO1xuICAgIGlmIChzdGFtcCA+IHRoaXMuX3N0YW1wKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2hvcnQtY2lyY3VpdCBlbmNvZGVyIGlmIHVzZXIgc3BlY2lmaWVzIGl0ZW1zXG5FbmNvZGVyLnVwZGF0ZSA9IGZ1bmN0aW9uKGdyYXBoLCB0cmFucywgcmVxdWVzdCwgaXRlbXMsIGRpcnR5KSB7XG4gIGl0ZW1zID0gZGwuYXJyYXkoaXRlbXMpO1xuICB2YXIgcHJlZHMgPSBncmFwaC5wcmVkaWNhdGVzKCksIFxuICAgICAgZGIgPSBncmFwaC52YWx1ZXMoRGVwcy5EQVRBKSxcbiAgICAgIHNnID0gZ3JhcGgudmFsdWVzKERlcHMuU0lHTkFMUyksXG4gICAgICBpLCBsZW4sIGl0ZW0sIHByb3BzLCBwcm9wO1xuXG4gIGZvciAoaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIHByb3BzID0gaXRlbS5tYXJrLmRlZi5wcm9wZXJ0aWVzO1xuICAgIHByb3AgPSBwcm9wcyAmJiBwcm9wc1tyZXF1ZXN0XTtcbiAgICBpZiAocHJvcCkge1xuICAgICAgZW5jb2RlLmNhbGwobnVsbCwgcHJvcCwgaXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMsIGRpcnR5KTtcbiAgICAgIGJvdW5kLml0ZW0oaXRlbSk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW5jb2RlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgTm9kZSA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXMsXG4gICAgQ29sbGVjdG9yID0gZGYuQ29sbGVjdG9yLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgcGFyc2VMZWdlbmRzID0gcmVxdWlyZSgnLi4vcGFyc2UvbGVnZW5kcycpO1xuXG5mdW5jdGlvbiBHcm91cEJ1aWxkZXIoKSB7XG4gIHRoaXMuX2NoaWxkcmVuID0ge307XG4gIHRoaXMuX3NjYWxlciA9IG51bGw7XG4gIHRoaXMuX3JlY3Vyc29yID0gbnVsbDtcblxuICB0aGlzLl9zY2FsZXMgPSB7fTtcbiAgdGhpcy5zY2FsZSA9IHNjYWxlLmJpbmQodGhpcyk7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xufVxuXG52YXIgVHlwZXMgPSBHcm91cEJ1aWxkZXIuVFlQRVMgPSB7XG4gIEdST1VQOiAgXCJncm91cFwiLFxuICBNQVJLOiAgIFwibWFya1wiLFxuICBBWElTOiAgIFwiYXhpc1wiLFxuICBMRUdFTkQ6IFwibGVnZW5kXCJcbn07XG5cbnZhciBwcm90byA9IChHcm91cEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IEJ1aWxkZXIoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcywgbmFtZTtcblxuICB0aGlzLl9zY2FsZXIgPSBuZXcgTm9kZShncmFwaCk7XG5cbiAgKGRlZi5zY2FsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBzID0gYnVpbGRlci5zY2FsZSgobmFtZT1zLm5hbWUpLCBuZXcgU2NhbGUoZ3JhcGgsIHMsIGJ1aWxkZXIpKTtcbiAgICBidWlsZGVyLnNjYWxlKG5hbWUrXCI6cHJldlwiLCBzKTtcbiAgICBidWlsZGVyLl9zY2FsZXIuYWRkTGlzdGVuZXIocyk7ICAvLyBTY2FsZXMgc2hvdWxkIGJlIGNvbXB1dGVkIGFmdGVyIGdyb3VwIGlzIGVuY29kZWRcbiAgfSk7XG5cbiAgdGhpcy5fcmVjdXJzb3IgPSBuZXcgTm9kZShncmFwaCk7XG4gIHRoaXMuX3JlY3Vyc29yLmV2YWx1YXRlID0gcmVjdXJzZS5iaW5kKHRoaXMpO1xuXG4gIHZhciBzY2FsZXMgPSAoZGVmLmF4ZXN8fFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIChhY2NbeC5zY2FsZV0gPSAxLCBhY2MpO1xuICB9LCB7fSk7XG5cbiAgc2NhbGVzID0gKGRlZi5sZWdlbmRzfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiAoYWNjW3guc2l6ZSB8fCB4LnNoYXBlIHx8IHguZmlsbCB8fCB4LnN0cm9rZV0sIGFjYyk7XG4gIH0sIHNjYWxlcyk7XG5cbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShEZXBzLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXRwdXQgPSBCdWlsZGVyLnByb3RvdHlwZS5ldmFsdWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgYnVpbGRlciA9IHRoaXM7XG5cbiAgb3V0cHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7IGJ1aWxkR3JvdXAuY2FsbChidWlsZGVyLCBvdXRwdXQsIGdyb3VwKTsgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3RoaXMsIHRoaXMuX3NjYWxlciwgdGhpcy5fcmVjdXJzb3IsIHRoaXMuX2NvbGxlY3RvciwgdGhpcy5fYm91bmRlcl07XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcbiAgZGwua2V5cyhidWlsZGVyLl9jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihncm91cF9pZCkge1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGJ1aWxkZXIuX3JlY3Vyc29yLnJlbW92ZUxpc3RlbmVyKGMuYnVpbGRlcik7XG4gICAgICBjLmJ1aWxkZXIuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsZGVyLl9jaGlsZHJlbiA9IHt9O1xuICByZXR1cm4gQnVpbGRlci5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xufTtcblxucHJvdG8uY2hpbGQgPSBmdW5jdGlvbihuYW1lLCBncm91cF9pZCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbltncm91cF9pZF0sXG4gICAgICBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgY2hpbGQ7XG5cbiAgZm9yICg7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC50eXBlID09IFR5cGVzLk1BUksgJiYgY2hpbGQuYnVpbGRlci5fZGVmLm5hbWUgPT0gbmFtZSkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gY2hpbGQuYnVpbGRlcjtcbn07XG5cbmZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzLFxuICAgICAgaGFzTWFya3MgPSBkbC5hcnJheSh0aGlzLl9kZWYubWFya3MpLmxlbmd0aCA+IDAsXG4gICAgICBoYXNBeGVzID0gZGwuYXJyYXkodGhpcy5fZGVmLmF4ZXMpLmxlbmd0aCA+IDAsXG4gICAgICBoYXNMZWdlbmRzID0gZGwuYXJyYXkodGhpcy5fZGVmLmxlZ2VuZHMpLmxlbmd0aCA+IDAsXG4gICAgICBpLCBqLCBjLCBsZW4sIGdyb3VwLCBwaXBlbGluZSwgZGVmLCBpbmxpbmUgPSBmYWxzZTtcblxuICBmb3IgKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LmFkZFtpXTtcbiAgICBpZiAoaGFzTWFya3MpIGJ1aWxkTWFya3MuY2FsbCh0aGlzLCBpbnB1dCwgZ3JvdXApO1xuICAgIGlmIChoYXNBeGVzKSAgYnVpbGRBeGVzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgICBpZiAoaGFzTGVnZW5kcykgYnVpbGRMZWdlbmRzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBUeXBlcy5HUk9VUCk7XG4gICAgICBpbmxpbmUgPSBpbmxpbmUgJiYgKHRoaXMuX2dyYXBoLmRhdGEoYy5mcm9tKSAhPT0gdW5kZWZpbmVkKTsgXG4gICAgICBpbmxpbmUgPSBpbmxpbmUgJiYgKHBpcGVsaW5lW3BpcGVsaW5lLmxlbmd0aC0xXS5saXN0ZW5lcnMoKS5sZW5ndGggPT09IDEpOyAvLyBSZWFjdGl2ZSBnZW9tIHNvdXJjZVxuICAgICAgaW5saW5lID0gaW5saW5lICYmIChkZWYuZnJvbSAmJiAhZGVmLmZyb20ubWFyayk7IC8vIFJlYWN0aXZlIGdlb20gdGFyZ2V0XG4gICAgICBjLmlubGluZSA9IGlubGluZTtcblxuICAgICAgaWYgKGlubGluZSkgdGhpcy5fZ3JhcGguZXZhbHVhdGUoaW5wdXQsIGMuYnVpbGRlcik7XG4gICAgICBlbHNlIHRoaXMuX3JlY3Vyc29yLmFkZExpc3RlbmVyKGMuYnVpbGRlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVGVtcChjKSB7XG4gICAgaWYgKGMudHlwZSA9PSBUeXBlcy5NQVJLICYmICFjLmlubGluZSAmJlxuICAgICAgICBidWlsZGVyLl9ncmFwaC5kYXRhKGMuZnJvbSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVBeGlzKGEpIHsgXG4gICAgdmFyIHNjYWxlID0gYS5zY2FsZSgpO1xuICAgIGlmICghaW5wdXQuc2NhbGVzW3NjYWxlLnNjYWxlTmFtZV0pIHJldHVybjtcbiAgICBhLnJlc2V0KCkuZGVmKCk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHVwZGF0ZUxlZ2VuZChsKSB7IFxuICAgIHZhciBzY2FsZSA9IGwuc2l6ZSgpIHx8IGwuc2hhcGUoKSB8fCBsLmZpbGwoKSB8fCBsLnN0cm9rZSgpO1xuICAgIGlmICghaW5wdXQuc2NhbGVzW3NjYWxlLnNjYWxlTmFtZV0pIHJldHVybjtcbiAgICBsLnJlc2V0KCkuZGVmKCk7XG4gIH1cblxuICBmb3IgKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0Lm1vZFtpXTtcblxuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZiAoaGFzTWFya3MpIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0uZm9yRWFjaChyZW1vdmVUZW1wKTtcblxuICAgIC8vIFVwZGF0ZSBheGlzIGRhdGEgZGVmc1xuICAgIGlmIChoYXNBeGVzKSBncm91cC5heGVzLmZvckVhY2godXBkYXRlQXhpcyk7XG5cbiAgICAvLyBVcGRhdGUgbGVnZW5kIGRhdGEgZGVmc1xuICAgIGlmIChoYXNMZWdlbmRzKSBncm91cC5sZWdlbmRzLmZvckVhY2godXBkYXRlTGVnZW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2Nvbm5lY3RDaGlsZHJlbihjKSB7IFxuICAgIGJ1aWxkZXIuX3JlY3Vyc29yLnJlbW92ZUxpc3RlbmVyKGMuYnVpbGRlcik7XG4gICAgYy5idWlsZGVyLmRpc2Nvbm5lY3QoKTsgXG4gIH1cblxuICBmb3IgKGk9MCwgbGVuPWlucHV0LnJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LnJlbVtpXTtcbiAgICAvLyBGb3IgZGVsZXRlZCBncm91cHMsIGRpc2Nvbm5lY3QgdGhlaXIgY2hpbGRyZW5cbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLmZvckVhY2goZGlzY29ubmVjdENoaWxkcmVuKTtcbiAgICBkZWxldGUgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gc2NhbGUobmFtZSwgeCkge1xuICB2YXIgZ3JvdXAgPSB0aGlzLCBzID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiAoZ3JvdXAuX3NjYWxlc1tuYW1lXSA9IHgsIHgpO1xuICB3aGlsZSAocyA9PSBudWxsKSB7XG4gICAgcyA9IGdyb3VwLl9zY2FsZXNbbmFtZV07XG4gICAgZ3JvdXAgPSBncm91cC5tYXJrID8gZ3JvdXAubWFyay5ncm91cCA6IGdyb3VwLl9wYXJlbnQ7XG4gICAgaWYgKCFncm91cCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkR3JvdXAoaW5wdXQsIGdyb3VwKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmcgZ3JvdXBcIiwgZ3JvdXAuX2lkXSk7XG5cbiAgZ3JvdXAuX3NjYWxlcyA9IGdyb3VwLl9zY2FsZXMgfHwge307ICAgIFxuICBncm91cC5zY2FsZSA9IHNjYWxlLmJpbmQoZ3JvdXApO1xuXG4gIGdyb3VwLml0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgW107XG4gIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdIHx8IFtdO1xuXG4gIGdyb3VwLmF4ZXMgPSBncm91cC5heGVzIHx8IFtdO1xuICBncm91cC5heGlzSXRlbXMgPSBncm91cC5heGlzSXRlbXMgfHwgW107XG5cbiAgZ3JvdXAubGVnZW5kcyA9IGdyb3VwLmxlZ2VuZHMgfHwgW107XG4gIGdyb3VwLmxlZ2VuZEl0ZW1zID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW107XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWFya3MoaW5wdXQsIGdyb3VwKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmcgY2hpbGRyZW4gbWFya3MgI1wiK2dyb3VwLl9pZF0pO1xuICB2YXIgbWFya3MgPSB0aGlzLl9kZWYubWFya3MsXG4gICAgICBtYXJrLCBmcm9tLCBpbmhlcml0LCBpLCBsZW4sIGI7XG5cbiAgZm9yIChpPTAsIGxlbj1tYXJrcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBtYXJrID0gbWFya3NbaV07XG4gICAgZnJvbSA9IG1hcmsuZnJvbSB8fCB7fTtcbiAgICBpbmhlcml0ID0gZ3JvdXAuZGF0dW0uX2ZhY2V0SUQ7XG4gICAgZ3JvdXAuaXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwLCBfc2NhbGVSZWZzOiB7fX07XG4gICAgYiA9IChtYXJrLnR5cGUgPT09IFR5cGVzLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KHRoaXMuX2dyYXBoLCBtYXJrLCBncm91cC5pdGVtc1tpXSwgdGhpcywgZ3JvdXAuX2lkLCBpbmhlcml0KTtcbiAgICB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBcbiAgICAgIGJ1aWxkZXI6IGIsIFxuICAgICAgZnJvbTogZnJvbS5kYXRhIHx8IChmcm9tLm1hcmsgPyAoXCJ2Z19cIiArIGdyb3VwLl9pZCArIFwiX1wiICsgZnJvbS5tYXJrKSA6IGluaGVyaXQpLCBcbiAgICAgIHR5cGU6IFR5cGVzLk1BUksgXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRBeGVzKGlucHV0LCBncm91cCkge1xuICB2YXIgYXhlcyA9IGdyb3VwLmF4ZXMsXG4gICAgICBheGlzSXRlbXMgPSBncm91cC5heGlzSXRlbXMsXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBwYXJzZUF4ZXModGhpcy5fZ3JhcGgsIHRoaXMuX2RlZi5heGVzLCBheGVzLCBncm91cCk7XG4gIGF4ZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpKSB7XG4gICAgdmFyIHNjYWxlID0gYnVpbGRlci5fZGVmLmF4ZXNbaV0uc2NhbGUsXG4gICAgICAgIGRlZiA9IGEuZGVmKCksXG4gICAgICAgIGIgPSBudWxsO1xuXG4gICAgYXhpc0l0ZW1zW2ldID0ge2dyb3VwOiBncm91cCwgYXhpczogdHJ1ZSwgbGF5ZXI6IGRlZi5sYXllcn07XG4gICAgYiA9IChkZWYudHlwZSA9PT0gVHlwZXMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQoYnVpbGRlci5fZ3JhcGgsIGRlZiwgYXhpc0l0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBUeXBlcy5BWElTLCBzY2FsZTogc2NhbGUgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZExlZ2VuZHMoaW5wdXQsIGdyb3VwKSB7XG4gIHZhciBsZWdlbmRzID0gZ3JvdXAubGVnZW5kcyxcbiAgICAgIGxlZ2VuZEl0ZW1zID0gZ3JvdXAubGVnZW5kSXRlbXMsXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBwYXJzZUxlZ2VuZHModGhpcy5fZ3JhcGgsIHRoaXMuX2RlZi5sZWdlbmRzLCBsZWdlbmRzLCBncm91cCk7XG4gIGxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbihsLCBpKSB7XG4gICAgdmFyIHNjYWxlID0gbC5zaXplKCkgfHwgbC5zaGFwZSgpIHx8IGwuZmlsbCgpIHx8IGwuc3Ryb2tlKCksXG4gICAgICAgIGRlZiA9IGwuZGVmKCksXG4gICAgICAgIGIgPSBudWxsO1xuXG4gICAgbGVnZW5kSXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwLCBsZWdlbmQ6IHRydWV9O1xuICAgIGIgPSAoZGVmLnR5cGUgPT09IFR5cGVzLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KGJ1aWxkZXIuX2dyYXBoLCBkZWYsIGxlZ2VuZEl0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBUeXBlcy5MRUdFTkQsIHNjYWxlOiBzY2FsZSB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBCdWlsZGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIE5vZGUgPSBkZi5Ob2RlLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBEZXBzID0gZGYuRGVwZW5kZW5jaWVzLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyk7XG5cbnZhciBQcm9wZXJ0aWVzID0ge1xuICB3aWR0aDogMSxcbiAgaGVpZ2h0OiAxXG59O1xuXG52YXIgVHlwZXMgPSB7XG4gIExJTkVBUjogJ2xpbmVhcicsXG4gIE9SRElOQUw6ICdvcmRpbmFsJyxcbiAgTE9HOiAnbG9nJyxcbiAgUE9XRVI6ICdwb3cnLFxuICBTUVJUOiAnc3FydCcsXG4gIFRJTUU6ICd0aW1lJyxcbiAgVElNRV9VVEM6ICd1dGMnLFxuICBRVUFOVElMRTogJ3F1YW50aWxlJyxcbiAgUVVBTlRJWkU6ICdxdWFudGl6ZScsXG4gIFRIUkVTSE9MRDogJ3RocmVzaG9sZCdcbn07XG5cbnZhciBEYXRhUmVmID0ge1xuICBET01BSU46ICdkb21haW4nLFxuICBSQU5HRTogJ3JhbmdlJyxcblxuICBDT1VOVDogJ2NvdW50JyxcbiAgR1JPVVBCWTogJ2dyb3VwYnknLFxuICBNSU46ICdtaW4nLFxuICBNQVg6ICdtYXgnLFxuICBWQUxVRTogJ3ZhbHVlJyxcblxuICBBU0M6ICdhc2MnLFxuICBERVNDOiAnZGVzYydcbn07XG5cbmZ1bmN0aW9uIFNjYWxlKGdyYXBoLCBkZWYsIHBhcmVudCkge1xuICB0aGlzLl9kZWYgICAgID0gZGVmO1xuICB0aGlzLl9wYXJlbnQgID0gcGFyZW50O1xuICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpLnJlZmxvd3ModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChTY2FsZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBmbiA9IGZ1bmN0aW9uKGdyb3VwKSB7IHNjYWxlLmNhbGwoc2VsZiwgZ3JvdXApOyB9O1xuXG4gIHRoaXMuX3VwZGF0ZWQgPSBmYWxzZTtcbiAgaW5wdXQuYWRkLmZvckVhY2goZm4pO1xuICBpbnB1dC5tb2QuZm9yRWFjaChmbik7XG5cbiAgLy8gU2NhbGVzIGFyZSBhdCB0aGUgZW5kIG9mIGFuIGVuY29kaW5nIHBpcGVsaW5lLCBzbyB0aGV5IHNob3VsZCBmb3J3YXJkIGFcbiAgLy8gcmVmbG93IHB1bHNlLiBUaHVzLCBpZiBtdWx0aXBsZSBzY2FsZXMgdXBkYXRlIGluIHRoZSBwYXJlbnQgZ3JvdXAsIHdlIGRvbid0XG4gIC8vIHJlZXZhbHVhdGUgY2hpbGQgbWFya3MgbXVsdGlwbGUgdGltZXMuIFxuICBpZiAodGhpcy5fdXBkYXRlZCkge1xuICAgIGlucHV0LnNjYWxlc1t0aGlzLl9kZWYubmFtZV0gPSAxO1xuICAgIGxvZy5kZWJ1ZyhpbnB1dCwgW1wic2NhbGVcIiwgdGhpcy5fZGVmLm5hbWVdKTsgIFxuICB9IFxuICByZXR1cm4gZGYuQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCwgdHJ1ZSk7XG59O1xuXG4vLyBBbGwgb2YgYSBzY2FsZSdzIGRlcGVuZGVuY2llcyBhcmUgcmVnaXN0ZXJlZCBkdXJpbmcgcHJvcGFnYXRpb24gYXMgd2UgcGFyc2Vcbi8vIGRhdGFSZWZzLiBTbyBhIHNjYWxlIG11c3QgYmUgcmVzcG9uc2libGUgZm9yIGNvbm5lY3RpbmcgaXRzZWxmIHRvIGRlcGVuZGVudHMuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgdmFyIG1ldGhvZCA9ICh0eXBlID09PSBEZXBzLkRBVEEgPyAnZGF0YScgOiAnc2lnbmFsJyk7XG4gICAgZGVwcyA9IGRsLmFycmF5KGRlcHMpO1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9ncmFwaFttZXRob2RdKGRlcHNbaV0pLmFkZExpc3RlbmVyKHRoaXMuX3BhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE5vZGUucHJvdG90eXBlLmRlcGVuZGVuY3kuY2FsbCh0aGlzLCB0eXBlLCBkZXBzKTtcbn07XG5cbmZ1bmN0aW9uIHNjYWxlKGdyb3VwKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fZGVmLm5hbWUsXG4gICAgICBwcmV2ID0gbmFtZSArICc6cHJldicsXG4gICAgICBzID0gaW5zdGFuY2UuY2FsbCh0aGlzLCBncm91cC5zY2FsZShuYW1lKSksXG4gICAgICBtID0gcy50eXBlPT09VHlwZXMuT1JESU5BTCA/IG9yZGluYWwgOiBxdWFudGl0YXRpdmUsXG4gICAgICBybmcgPSByYW5nZS5jYWxsKHRoaXMsIGdyb3VwKTtcblxuICBtLmNhbGwodGhpcywgcywgcm5nLCBncm91cCk7XG5cbiAgZ3JvdXAuc2NhbGUobmFtZSwgcyk7XG4gIGdyb3VwLnNjYWxlKHByZXYsIGdyb3VwLnNjYWxlKHByZXYpIHx8IHMpO1xuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZShzY2FsZSkge1xuICB2YXIgY29uZmlnID0gdGhpcy5fZ3JhcGguY29uZmlnKCksXG4gICAgICB0eXBlID0gdGhpcy5fZGVmLnR5cGUgfHwgVHlwZXMuTElORUFSO1xuICBpZiAoIXNjYWxlIHx8IHR5cGUgIT09IHNjYWxlLnR5cGUpIHtcbiAgICB2YXIgY3RvciA9IGNvbmZpZy5zY2FsZVt0eXBlXSB8fCBkMy5zY2FsZVt0eXBlXTtcbiAgICBpZiAoIWN0b3IpIHRocm93IEVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgdHlwZTogJyArIHR5cGUpO1xuICAgIChzY2FsZSA9IGN0b3IoKSkudHlwZSA9IHNjYWxlLnR5cGUgfHwgdHlwZTtcbiAgICBzY2FsZS5zY2FsZU5hbWUgPSB0aGlzLl9kZWYubmFtZTtcbiAgICBzY2FsZS5fcHJldiA9IHt9O1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gb3JkaW5hbChzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgZGF0YURyaXZlblJhbmdlID0gZmFsc2UsXG4gICAgICBwYWQgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYucGFkZGluZykgfHwgMCxcbiAgICAgIG91dGVyID0gZGVmLm91dGVyUGFkZGluZyA9PSBudWxsID8gcGFkIDogc2lnbmFsLmNhbGwodGhpcywgZGVmLm91dGVyUGFkZGluZyksXG4gICAgICBwb2ludHMgPSBkZWYucG9pbnRzICYmIHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5wb2ludHMpLFxuICAgICAgcm91bmQgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYucm91bmQpIHx8IGRlZi5yb3VuZCA9PSBudWxsLFxuICAgICAgZG9tYWluLCBzdHI7XG4gIFxuICAvLyByYW5nZSBwcmUtcHJvY2Vzc2luZyBmb3IgZGF0YS1kcml2ZW4gcmFuZ2VzXG4gIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpICYmICFkbC5pc0FycmF5KGRlZi5yYW5nZSkpIHtcbiAgICBkYXRhRHJpdmVuUmFuZ2UgPSB0cnVlO1xuICAgIHJuZyA9IGRhdGFSZWYuY2FsbCh0aGlzLCBEYXRhUmVmLlJBTkdFLCBkZWYucmFuZ2UsIHNjYWxlLCBncm91cCk7XG4gIH1cbiAgXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSBkYXRhUmVmLmNhbGwodGhpcywgRGF0YVJlZi5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcblxuICAvLyB3aWR0aC1kZWZpbmVkIHJhbmdlXG4gIGlmIChkZWYuYmFuZFdpZHRoKSB7XG4gICAgdmFyIGJ3ID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmJhbmRXaWR0aCksXG4gICAgICAgIGxlbiA9IGRvbWFpbi5sZW5ndGgsXG4gICAgICAgIHNwYWNlID0gZGVmLnBvaW50cyA/IChwYWQqYncpIDogKHBhZCpidyoobGVuLTEpICsgMipvdXRlciksXG4gICAgICAgIHN0YXJ0O1xuICAgIGlmIChybmdbMF0gPiBybmdbMV0pIHtcbiAgICAgIHN0YXJ0ID0gcm5nWzFdIHx8IDA7XG4gICAgICBybmcgPSBbc3RhcnQgKyAoYncgKiBsZW4gKyBzcGFjZSksIHN0YXJ0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBybmdbMF0gfHwgMDtcbiAgICAgIHJuZyA9IFtzdGFydCwgc3RhcnQgKyAoYncgKiBsZW4gKyBzcGFjZSldO1xuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHR5cGVvZiBybmdbMF0gPT09ICdzdHJpbmcnO1xuICBpZiAoc3RyIHx8IHJuZy5sZW5ndGggPiAyIHx8IHJuZy5sZW5ndGg9PT0xIHx8IGRhdGFEcml2ZW5SYW5nZSkge1xuICAgIHNjYWxlLnJhbmdlKHJuZyk7IC8vIGNvbG9yIG9yIHNoYXBlIHZhbHVlc1xuICB9IGVsc2UgaWYgKHBvaW50cyAmJiByb3VuZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRQb2ludHMocm5nLCBwYWQpO1xuICB9IGVsc2UgaWYgKHBvaW50cykge1xuICAgIHNjYWxlLnJhbmdlUG9pbnRzKHJuZywgcGFkKTtcbiAgfSBlbHNlIGlmIChyb3VuZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyhybmcsIHBhZCwgb3V0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlLnJhbmdlQmFuZHMocm5nLCBwYWQsIG91dGVyKTtcbiAgfVxuXG4gIGlmICghc2NhbGUuaW52ZXJ0KSB7XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbigpW2QzLmJpc2VjdChzY2FsZS5yYW5nZSgpLCB4KSAtIDFdO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7ICAvLyBJbnZlcnQgZXh0ZW50c1xuICAgICAgICBpZiAoIWRsLmlzTnVtYmVyKHgpIHx8ICFkbC5pc051bWJlcih5KSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdFeHRlbnRzIHRvIG9yZGluYWwgaW52ZXJ0IGFyZSBub3QgbnVtYmVycyAoJyt4KycsICcreSsnKS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgIHJuZyA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgICAgICBpID0gMCwgbGVuID0gcm5nLmxlbmd0aCwgcjtcblxuICAgICAgICBmb3IoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgciA9IHJuZ1tpXTtcbiAgICAgICAgICBpZiAoeCA8IHkgPyB4IDw9IHIgJiYgciA8PSB5IDogeSA8PSByICYmIHIgPD0geCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoZnVuY3Rpb24ocCkgeyByZXR1cm4gc2NhbGUuaW52ZXJ0KHApOyB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXRhdGl2ZShzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgcm91bmQgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYucm91bmQpLFxuICAgICAgZXhwb25lbnQgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYuZXhwb25lbnQpLFxuICAgICAgY2xhbXAgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYuY2xhbXApLFxuICAgICAgbmljZSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5uaWNlKSxcbiAgICAgIGRvbWFpbiwgaW50ZXJ2YWw7XG5cbiAgLy8gZG9tYWluXG4gIGRvbWFpbiA9IChkZWYudHlwZSA9PT0gVHlwZXMuUVVBTlRJTEUpID9cbiAgICBkYXRhUmVmLmNhbGwodGhpcywgRGF0YVJlZi5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCkgOlxuICAgIGRvbWFpbk1pbk1heC5jYWxsKHRoaXMsIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgLy8gdmVydGljYWwgc2NhbGVzIHNob3VsZCBmbGlwIGJ5IGRlZmF1bHQsIHNvIHVzZSBYT1IgaGVyZVxuICBpZiAoc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlKSA9PT0gJ2hlaWdodCcpIHJuZyA9IHJuZy5yZXZlcnNlKCk7XG4gIGlmIChkbC5lcXVhbChwcmV2LnJhbmdlLCBybmcpKSByZXR1cm47XG4gIHNjYWxlW3JvdW5kICYmIHNjYWxlLnJhbmdlUm91bmQgPyAncmFuZ2VSb3VuZCcgOiAncmFuZ2UnXShybmcpO1xuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcblxuICAvLyBUT0RPOiBTdXBwb3J0IHNpZ25hbHMgZm9yIHRoZXNlIHByb3BlcnRpZXMuIFVudGlsIHRoZW4sIG9ubHkgZXZhbFxuICAvLyB0aGVtIG9uY2UuXG4gIGlmICh0aGlzLl9zdGFtcCA+IDApIHJldHVybjtcbiAgaWYgKGV4cG9uZW50ICYmIGRlZi50eXBlPT09VHlwZXMuUE9XRVIpIHNjYWxlLmV4cG9uZW50KGV4cG9uZW50KTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKG5pY2UpIHtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFR5cGVzLlRJTUUpIHtcbiAgICAgIGludGVydmFsID0gZDMudGltZVtuaWNlXTtcbiAgICAgIGlmICghaW50ZXJ2YWwpIGxvZy5lcnJvcignVW5yZWNvZ25pemVkIGludGVydmFsOiAnICsgaW50ZXJ2YWwpO1xuICAgICAgc2NhbGUubmljZShpbnRlcnZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlLm5pY2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmlxdWVzKHNjYWxlKSB7IFxuICByZXR1cm4gc2NhbGUudHlwZSA9PT0gVHlwZXMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBUeXBlcy5RVUFOVElMRTsgXG59XG5cbmZ1bmN0aW9uIGdldFJlZnMoZGVmKSB7IFxuICByZXR1cm4gZGVmLmZpZWxkcyB8fCBkbC5hcnJheShkZWYpO1xufVxuXG5mdW5jdGlvbiBpbmhlcml0cyhyZWZzKSB7XG4gIHJldHVybiByZWZzLnNvbWUoZnVuY3Rpb24ocikge1xuICAgIGlmICghci5kYXRhKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gci5kYXRhICYmIGRsLmFycmF5KHIuZmllbGQpLnNvbWUoZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGYucGFyZW50O1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RmllbGRzKHJlZiwgZ3JvdXApIHtcbiAgcmV0dXJuIGRsLmFycmF5KHJlZi5maWVsZCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZi5wYXJlbnQgP1xuICAgICAgZGwuYWNjZXNzb3IoZi5wYXJlbnQpKGdyb3VwLmRhdHVtKSA6XG4gICAgICBmOyAvLyBTdHJpbmcgb3IgeydzaWduYWwnfVxuICB9KTtcbn1cblxuLy8gU2NhbGUgZGF0YXJlZnMgY2FuIGJlIGNvbXB1dGVkIG92ZXIgbXVsdGlwbGUgc2NoZW1hIHR5cGVzLiBcbi8vIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiBhZ2dyZWdhdG9yIGNyZWF0ZWQsIGFuZFxuLy8gd2hhdCBkYXRhIGlzIHNlbnQgdG8gaXQ6IHZhbHVlcywgdHVwbGVzLCBvciBtdWx0aS10dXBsZXMgdGhhdCBtdXN0XG4vLyBiZSBzdGFuZGFyZGl6ZWQgaW50byBhIGNvbnNpc3RlbnQgc2NoZW1hLiBcbmZ1bmN0aW9uIGFnZ3JUeXBlKGRlZiwgc2NhbGUpIHtcbiAgdmFyIHJlZnMgPSBnZXRSZWZzKGRlZik7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIG92ZXIgb25seSBhIHNpbmdsZSBkb21haW4sIHNlbmQgZnVsbCB0dXBsZXNcbiAgLy8gdGhyb3VnaCBmb3IgZWZmaWNpZW5jeSAoZmV3ZXIgYWNjZXNzb3IgY3JlYXRpb25zL2NhbGxzKVxuICBpZiAocmVmcy5sZW5ndGggPT0gMSAmJiBkbC5hcnJheShyZWZzWzBdLmZpZWxkKS5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBBZ2dyZWdhdGUuVFlQRVMuVFVQTEU7XG4gIH1cblxuICAvLyBXaXRoIHF1YW50aXRhdGl2ZSBzY2FsZXMsIHdlIG9ubHkgY2FyZSBhYm91dCBtaW4vbWF4LlxuICBpZiAoIWlzVW5pcXVlcyhzY2FsZSkpIHJldHVybiBBZ2dyZWdhdGUuVFlQRVMuVkFMVUU7XG5cbiAgLy8gSWYgd2UgZG9uJ3Qgc29ydCwgdGhlbiB3ZSBjYW4gc2VuZCB2YWx1ZXMgZGlyZWN0bHkgdG8gYWdncnMgYXMgd2VsbFxuICBpZiAoIWRsLmlzT2JqZWN0KGRlZi5zb3J0KSkgcmV0dXJuIEFnZ3JlZ2F0ZS5UWVBFUy5WQUxVRTtcblxuICByZXR1cm4gQWdncmVnYXRlLlRZUEVTLk1VTFRJO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZSh3aGljaCwgZGVmLCBzY2FsZSwgZ3JvdXApIHtcbiAgdmFyIHJlZnMgPSBnZXRSZWZzKGRlZiksXG4gICAgICBpbmhlcml0ID0gaW5oZXJpdHMocmVmcyksXG4gICAgICBhdHlwZSA9IGFnZ3JUeXBlKGRlZiwgc2NhbGUpLFxuICAgICAgdW5pcXVlcyA9IGlzVW5pcXVlcyhzY2FsZSksXG4gICAgICBzb3J0ID0gZGVmLnNvcnQsXG4gICAgICBjayA9ICdfJyt3aGljaCxcbiAgICAgIGZpZWxkcyA9IGdldEZpZWxkcyhyZWZzWzBdLCBncm91cCk7XG5cbiAgaWYgKHNjYWxlW2NrXSB8fCB0aGlzW2NrXSkgcmV0dXJuIHNjYWxlW2NrXSB8fCB0aGlzW2NrXTtcblxuICB2YXIgY2FjaGUgPSBuZXcgQWdncmVnYXRlKHRoaXMuX2dyYXBoKS50eXBlKGF0eXBlKSxcbiAgICAgIGdyb3VwYnksIHN1bW1hcml6ZTtcblxuICAvLyBJZiBhIHNjYWxlJ3MgZGF0YXJlZiBkb2Vzbid0IGluaGVyaXQgZGF0YSBmcm9tIHRoZSBncm91cCwgd2UgY2FuXG4gIC8vIHN0b3JlIHRoZSBkYXRhcmVmIGFnZ3JlZ2F0b3IgYXQgdGhlIFNjYWxlIChkYXRhZmxvdyBub2RlKSBsZXZlbC4gXG4gIGlmIChpbmhlcml0KSB7XG4gICAgc2NhbGVbY2tdID0gY2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgdGhpc1tja10gID0gY2FjaGU7XG4gIH1cblxuICBpZiAodW5pcXVlcykge1xuICAgIGlmIChhdHlwZSA9PT0gQWdncmVnYXRlLlRZUEVTLlZBTFVFKSB7XG4gICAgICBncm91cGJ5ID0gW3sgbmFtZTogRGF0YVJlZi5HUk9VUEJZLCBnZXQ6IGRsLmlkZW50aXR5IH1dO1xuICAgICAgc3VtbWFyaXplID0geycqJzogRGF0YVJlZi5DT1VOVH07XG4gICAgfSBlbHNlIGlmIChhdHlwZSA9PT0gQWdncmVnYXRlLlRZUEVTLlRVUExFKSB7XG4gICAgICBncm91cGJ5ID0gW3sgbmFtZTogRGF0YVJlZi5HUk9VUEJZLCBnZXQ6IGRsLiQoZmllbGRzWzBdKSB9XTtcbiAgICAgIHN1bW1hcml6ZSA9IGRsLmlzT2JqZWN0KHNvcnQpID8gW3tcbiAgICAgICAgZmllbGQ6IERhdGFSZWYuVkFMVUUsXG4gICAgICAgIGdldDogIGRsLiQoc29ydC5maWVsZCksXG4gICAgICAgIG9wczogW3NvcnQub3BdXG4gICAgICB9XSA6IHsnKic6IERhdGFSZWYuQ09VTlR9O1xuICAgIH0gZWxzZSB7ICAvLyBhdHlwZSA9PT0gQWdncmVnYXRlLlRZUEVTLk1VTFRJXG4gICAgICBncm91cGJ5ICAgPSBEYXRhUmVmLkdST1VQQlk7XG4gICAgICBzdW1tYXJpemUgPSBbeyBmaWVsZDogRGF0YVJlZi5WQUxVRSwgb3BzOiBbc29ydC5vcF0gfV07IFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBncm91cGJ5ID0gW107XG4gICAgc3VtbWFyaXplID0gW3tcbiAgICAgIGZpZWxkOiBEYXRhUmVmLlZBTFVFLFxuICAgICAgZ2V0OiAoYXR5cGUgPT0gQWdncmVnYXRlLlRZUEVTLlRVUExFKSA/IGRsLiQoZmllbGRzWzBdKSA6IGRsLmlkZW50aXR5LFxuICAgICAgb3BzOiBbRGF0YVJlZi5NSU4sIERhdGFSZWYuTUFYXSxcbiAgICAgIGFzOiAgW0RhdGFSZWYuTUlOLCBEYXRhUmVmLk1BWF1cbiAgICB9XTtcbiAgfVxuXG4gIGNhY2hlLnBhcmFtKCdncm91cGJ5JywgZ3JvdXBieSlcbiAgICAucGFyYW0oJ3N1bW1hcml6ZScsIHN1bW1hcml6ZSk7XG5cbiAgcmV0dXJuIChjYWNoZS5fbGFzdFVwZGF0ZSA9IC0xLCBjYWNoZSk7XG59XG5cbmZ1bmN0aW9uIGRhdGFSZWYod2hpY2gsIGRlZiwgc2NhbGUsIGdyb3VwKSB7XG4gIGlmIChkZWYgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgaWYgKGRsLmlzQXJyYXkoZGVmKSkgcmV0dXJuIGRlZi5tYXAoc2lnbmFsLmJpbmQodGhpcykpO1xuXG4gIHZhciBzZWxmID0gdGhpcywgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHJlZnMgPSBnZXRSZWZzKGRlZiksXG4gICAgICBpbmhlcml0ID0gaW5oZXJpdHMocmVmcyksXG4gICAgICBhdHlwZSA9IGFnZ3JUeXBlKGRlZiwgc2NhbGUpLFxuICAgICAgY2FjaGUgPSBnZXRDYWNoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgc29ydCAgPSBkZWYuc29ydCxcbiAgICAgIHVuaXF1ZXMgPSBpc1VuaXF1ZXMoc2NhbGUpLFxuICAgICAgaSwgcmxlbiwgaiwgZmxlbiwgcmVmLCBmaWVsZHMsIGZpZWxkLCBkYXRhLCBmcm9tLCBzbywgY21wO1xuXG4gIGZ1bmN0aW9uIGFkZERlcChzKSB7XG4gICAgc2VsZi5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgcyk7XG4gIH1cblxuICBpZiAoaW5oZXJpdCB8fCAoIWluaGVyaXQgJiYgY2FjaGUuX2xhc3RVcGRhdGUgPCB0aGlzLl9zdGFtcCkpIHtcbiAgICBmb3IgKGk9MCwgcmxlbj1yZWZzLmxlbmd0aDsgaTxybGVuOyArK2kpIHtcbiAgICAgIHJlZiA9IHJlZnNbaV07XG4gICAgICBmcm9tID0gcmVmLmRhdGEgfHwgZ3JvdXAuZGF0dW0uX2ZhY2V0SUQ7XG4gICAgICBkYXRhID0gZ3JhcGguZGF0YShmcm9tKS5sYXN0KCk7XG5cbiAgICAgIGlmIChkYXRhLnN0YW1wIDw9IHRoaXMuX3N0YW1wKSBjb250aW51ZTtcblxuICAgICAgZmllbGRzID0gZ2V0RmllbGRzKHJlZiwgZ3JvdXApO1xuICAgICAgZm9yIChqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbal07XG5cbiAgICAgICAgaWYgKGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuVkFMVUUpIHtcbiAgICAgICAgICBjYWNoZS5hY2Nlc3NvcnMobnVsbCwgZmllbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuTVVMVEkpIHtcbiAgICAgICAgICBjYWNoZS5hY2Nlc3NvcnMoZmllbGQsIHJlZi5zb3J0IHx8IHNvcnQuZmllbGQpO1xuICAgICAgICB9IC8vIEVsc2UgKFR1cGxlLWNhc2UpIGlzIGhhbmRsZWQgYnkgdGhlIGFnZ3JlZ2F0b3IgYWNjZXNzb3JzIGJ5IGRlZmF1bHRcblxuICAgICAgICBjYWNoZS5ldmFsdWF0ZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZXBlbmRlbmN5KERlcHMuREFUQSwgZnJvbSk7XG4gICAgICBjYWNoZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUykuZm9yRWFjaChhZGREZXApO1xuICAgIH1cblxuICAgIGNhY2hlLl9sYXN0VXBkYXRlID0gdGhpcy5fc3RhbXA7XG5cbiAgICBkYXRhID0gY2FjaGUuYWdncigpLnJlc3VsdCgpO1xuICAgIGlmICh1bmlxdWVzKSB7XG4gICAgICBpZiAoZGwuaXNPYmplY3Qoc29ydCkpIHtcbiAgICAgICAgY21wID0gKHNvID0gc29ydC5vcmRlcikgJiYgc28uc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKHNvLnNpZ25hbCkgOiBzbztcbiAgICAgICAgY21wID0gKGNtcCA9PSBEYXRhUmVmLkRFU0MgPyAnLScgOiAnKycpICsgc29ydC5vcCArICdfJyArIERhdGFSZWYuVkFMVUU7XG4gICAgICAgIGNtcCA9IGRsLmNvbXBhcmF0b3IoY21wKTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydCA9PT0gdHJ1ZSkge1xuICAgICAgICBjbXAgPSBkbC5jb21wYXJhdG9yKERhdGFSZWYuR1JPVVBCWSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbXApIGRhdGEgPSBkYXRhLnNvcnQoY21wKTtcbiAgICAgIGNhY2hlLl92YWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkW0RhdGFSZWYuR1JPVVBCWV07IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gZGF0YVswXTtcbiAgICAgIGNhY2hlLl92YWx1ZXMgPSAhZGwuaXNWYWxpZChkYXRhKSA/IFtdIDogW2RhdGFbRGF0YVJlZi5NSU5dLCBkYXRhW0RhdGFSZWYuTUFYXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhY2hlLl92YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHNpZ25hbCh2KSB7XG4gIGlmICghdiB8fCAhdi5zaWduYWwpIHJldHVybiB2O1xuICB2YXIgcyA9IHYuc2lnbmFsLCByZWY7XG4gIHRoaXMuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMsIChyZWYgPSBkbC5maWVsZChzKSlbMF0pO1xuICByZXR1cm4gdGhpcy5fZ3JhcGguc2lnbmFsUmVmKHJlZik7XG59XG5cbmZ1bmN0aW9uIGRvbWFpbk1pbk1heChzY2FsZSwgZ3JvdXApIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZixcbiAgICAgIGRvbWFpbiA9IFtudWxsLCBudWxsXSwgcywgejtcblxuICBpZiAoZGVmLmRvbWFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tYWluID0gKCFkbC5pc09iamVjdChkZWYuZG9tYWluKSkgPyBkb21haW4gOlxuICAgICAgZGF0YVJlZi5jYWxsKHRoaXMsIERhdGFSZWYuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApO1xuICB9XG5cbiAgeiA9IGRvbWFpbi5sZW5ndGggLSAxO1xuICBpZiAoZGVmLmRvbWFpbk1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NaW4pKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1pbi5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGwuaXNWYWxpZChzPXNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pKSA/IHMgOiBkb21haW5bMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bMF0gPSBkYXRhUmVmLmNhbGwodGhpcywgRGF0YVJlZi5ET01BSU4rRGF0YVJlZi5NSU4sIGRlZi5kb21haW5NaW4sIHNjYWxlLCBncm91cClbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblswXSA9IGRlZi5kb21haW5NaW47XG4gICAgfVxuICB9XG4gIGlmIChkZWYuZG9tYWluTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGwuaXNPYmplY3QoZGVmLmRvbWFpbk1heCkpIHtcbiAgICAgIGlmIChkZWYuZG9tYWluTWF4LnNpZ25hbCkge1xuICAgICAgICBkb21haW5bel0gPSBkbC5pc1ZhbGlkKHM9c2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCkpID8gcyA6IGRvbWFpblt6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbWFpblt6XSA9IGRhdGFSZWYuY2FsbCh0aGlzLCBEYXRhUmVmLkRPTUFJTitEYXRhUmVmLk1BWCwgZGVmLmRvbWFpbk1heCwgc2NhbGUsIGdyb3VwKVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZG9tYWluW3pdID0gZGVmLmRvbWFpbk1heDtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi50eXBlICE9PSBUeXBlcy5MT0cgJiYgZGVmLnR5cGUgIT09IFR5cGVzLlRJTUUgJiYgKGRlZi56ZXJvIHx8IGRlZi56ZXJvPT09dW5kZWZpbmVkKSkge1xuICAgIGRvbWFpblswXSA9IE1hdGgubWluKDAsIGRvbWFpblswXSk7XG4gICAgZG9tYWluW3pdID0gTWF0aC5tYXgoMCwgZG9tYWluW3pdKTtcbiAgfVxuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiByYW5nZShncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgY29uZmlnID0gdGhpcy5fZ3JhcGguY29uZmlnKCksXG4gICAgICByYW5nZVZhbCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZSksXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKHJhbmdlVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJhbmdlVmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFByb3BlcnRpZXNbcmFuZ2VWYWxdKSB7XG4gICAgICAgIHJuZyA9IFswLCBncm91cFtyYW5nZVZhbF1dO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcucmFuZ2VbcmFuZ2VWYWxdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtyYW5nZVZhbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3IoJ1VucmVjb2dpemVkIHJhbmdlOiAnICsgcmFuZ2VWYWwpO1xuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGwuaXNBcnJheShyYW5nZVZhbCkpIHtcbiAgICAgIHJuZyA9IGRsLmR1cGxpY2F0ZShyYW5nZVZhbCkubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2UgaWYgKGRsLmlzT2JqZWN0KHJhbmdlVmFsKSkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIGVhcmx5IGV4aXRcbiAgICB9IGVsc2Uge1xuICAgICAgcm5nID0gWzAsIHJhbmdlVmFsXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/XG4gICAgICBzaWduYWwuY2FsbCh0aGlzLCBkZWYucmFuZ2VNaW4pIDpcbiAgICAgIGRlZi5yYW5nZU1pbjtcbiAgfVxuICBpZiAoZGVmLnJhbmdlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBybmdbcm5nLmxlbmd0aC0xXSA9IGRlZi5yYW5nZU1heC5zaWduYWwgP1xuICAgICAgc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6XG4gICAgICBkZWYucmFuZ2VNYXg7XG4gIH1cbiAgXG4gIGlmIChkZWYucmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJldiA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yZXZlcnNlKTtcbiAgICBpZiAoZGwuaXNPYmplY3QocmV2KSkge1xuICAgICAgcmV2ID0gZGwuYWNjZXNzb3IocmV2LmZpZWxkKShncm91cC5kYXR1bSk7XG4gICAgfVxuICAgIGlmIChyZXYpIHJuZyA9IHJuZy5yZXZlcnNlKCk7XG4gIH1cbiAgXG4gIHJldHVybiBybmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgYm91bmQgPSByZXF1aXJlKCd2ZWdhLXNjZW5lZ3JhcGgnKS5ib3VuZCxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBTdGF0dXMgPSByZXF1aXJlKCcuL0J1aWxkZXInKS5TVEFUVVM7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZHVyYXRpb24sIGVhc2UpIHtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDUwMDtcbiAgdGhpcy5lYXNlID0gZWFzZSAmJiBkMy5lYXNlKGVhc2UpIHx8IGQzLmVhc2UoJ2N1YmljLWluLW91dCcpO1xuICB0aGlzLnVwZGF0ZXMgPSB7bmV4dDogbnVsbH07XG59XG5cbnZhciBwcm90b3R5cGUgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxudmFyIHNraXAgPSB7XG4gICd0ZXh0JzogMSxcbiAgJ3VybCc6ICAxXG59O1xuXG5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZXMpIHtcbiAgdmFyIGtleSwgY3VyciwgbmV4dCwgaW50ZXJwLCBsaXN0ID0gbnVsbDtcblxuICBmb3IgKGtleSBpbiB2YWx1ZXMpIHtcbiAgICBjdXJyID0gaXRlbVtrZXldO1xuICAgIG5leHQgPSB2YWx1ZXNba2V5XTsgICAgICBcbiAgICBpZiAoY3VyciAhPT0gbmV4dCkge1xuICAgICAgaWYgKHNraXBba2V5XSB8fCBjdXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2tpcCBpbnRlcnBvbGF0aW9uIGZvciBzcGVjaWZpYyBrZXlzIG9yIHVuZGVmaW5lZCBzdGFydCB2YWx1ZXNcbiAgICAgICAgVHVwbGUuc2V0KGl0ZW0sIGtleSwgbmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUoY3VycikpIHtcbiAgICAgICAgLy8gZm9yIE5hTiBvciBpbmZpbml0ZSBudW1lcmljIHZhbHVlcywgc2tpcCB0byBmaW5hbCB2YWx1ZVxuICAgICAgICBUdXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBsb29rdXAgaW50ZXJwb2xhdG9yXG4gICAgICAgIGludGVycCA9IGQzLmludGVycG9sYXRlKGN1cnIsIG5leHQpO1xuICAgICAgICBpbnRlcnAucHJvcGVydHkgPSBrZXk7XG4gICAgICAgIChsaXN0IHx8IChsaXN0PVtdKSkucHVzaChpbnRlcnApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0ID09PSBudWxsICYmIGl0ZW0uc3RhdHVzID09PSBTdGF0dXMuRVhJVCkge1xuICAgIGxpc3QgPSBbXTsgLy8gZW5zdXJlIGV4aXRpbmcgaXRlbXMgYXJlIGluY2x1ZGVkXG4gIH1cblxuICBpZiAobGlzdCAhPSBudWxsKSB7XG4gICAgbGlzdC5pdGVtID0gaXRlbTtcbiAgICBsaXN0LmVhc2UgPSBpdGVtLm1hcmsuZWFzZSB8fCB0aGlzLmVhc2U7XG4gICAgbGlzdC5uZXh0ID0gdGhpcy51cGRhdGVzLm5leHQ7XG4gICAgdGhpcy51cGRhdGVzLm5leHQgPSBsaXN0O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHQgPSB0aGlzLCBwcmV2ID0gdC51cGRhdGVzLCBjdXJyID0gcHJldi5uZXh0O1xuICBmb3IgKDsgY3VyciE9bnVsbDsgcHJldj1jdXJyLCBjdXJyPXByZXYubmV4dCkge1xuICAgIGlmIChjdXJyLml0ZW0uc3RhdHVzID09PSBTdGF0dXMuRVhJVCkge1xuICAgICAgLy8gT25seSBtYXJrIGl0ZW0gYXMgZXhpdGVkIHdoZW4gaXQgaXMgcmVtb3ZlZC5cbiAgICAgIGN1cnIuaXRlbS5zdGF0dXMgPSBTdGF0dXMuVVBEQVRFO1xuICAgICAgY3Vyci5yZW1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0LmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIGQzLnRpbWVyKGZ1bmN0aW9uKGVsYXBzZWQpIHsgcmV0dXJuIHN0ZXAuY2FsbCh0LCBlbGFwc2VkKTsgfSk7XG59O1xuXG5mdW5jdGlvbiBzdGVwKGVsYXBzZWQpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLnVwZGF0ZXMsIHByZXYgPSBsaXN0LCBjdXJyID0gcHJldi5uZXh0LFxuICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgaXRlbSwgZGVsYXksIGYsIGUsIGksIG4sIHN0b3AgPSB0cnVlO1xuXG4gIGZvciAoOyBjdXJyIT1udWxsOyBwcmV2PWN1cnIsIGN1cnI9cHJldi5uZXh0KSB7XG4gICAgaXRlbSA9IGN1cnIuaXRlbTtcbiAgICBkZWxheSA9IGl0ZW0uZGVsYXkgfHwgMDtcblxuICAgIGYgPSAoZWxhcHNlZCAtIGRlbGF5KSAvIGR1cmF0aW9uO1xuICAgIGlmIChmIDwgMCkgeyBzdG9wID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGYgPiAxKSBmID0gMTtcbiAgICBlID0gY3Vyci5lYXNlKGYpO1xuXG4gICAgZm9yIChpPTAsIG49Y3Vyci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpdGVtW2N1cnJbaV0ucHJvcGVydHldID0gY3VycltpXShlKTtcbiAgICB9XG4gICAgaXRlbS50b3VjaCgpO1xuICAgIGJvdW5kLml0ZW0oaXRlbSk7XG5cbiAgICBpZiAoZiA9PT0gMSkge1xuICAgICAgaWYgKGN1cnIucmVtb3ZlKSB7XG4gICAgICAgIGl0ZW0uc3RhdHVzID0gU3RhdHVzLkVYSVQ7XG4gICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG4gICAgICBjdXJyID0gcHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FsbGJhY2soKTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi4vcGFyc2UvbWFyaycpO1xuXG52YXIgVElNRSAgICA9ICd0aW1lJyxcbiAgICBVVEMgICAgID0gJ3V0YycsXG4gICAgU1RSSU5HICA9ICdzdHJpbmcnLFxuICAgIE9SRElOQUwgPSAnb3JkaW5hbCcsXG4gICAgTlVNQkVSICA9ICdudW1iZXInO1xuXG5mdW5jdGlvbiBheHMobW9kZWwpIHtcbiAgdmFyIHNjYWxlLFxuICAgICAgY29uZmlnID0gbW9kZWwuY29uZmlnKCksXG4gICAgICBvcmllbnQgPSBjb25maWcuYXhpcy5vcmllbnQsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgdGl0bGVPZmZzZXQgPSBjb25maWcuYXhpcy50aXRsZU9mZnNldCxcbiAgICAgIGF4aXNEZWYgPSB7fSxcbiAgICAgIGxheWVyID0gJ2Zyb250JyxcbiAgICAgIGdyaWQgPSBmYWxzZSxcbiAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgIHRpY2tNYWpvclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tNaW5vclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tFbmRTaXplID0gY29uZmlnLmF4aXMudGlja1NpemUsXG4gICAgICB0aWNrUGFkZGluZyA9IGNvbmZpZy5heGlzLnBhZGRpbmcsXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXRTdHJpbmcgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdFR5cGUgPSBudWxsLFxuICAgICAgdGlja1N1YmRpdmlkZSA9IDAsXG4gICAgICB0aWNrQ291bnQgPSBjb25maWcuYXhpcy50aWNrcyxcbiAgICAgIGdyaWRMaW5lU3R5bGUgPSB7fSxcbiAgICAgIHRpY2tMYWJlbFN0eWxlID0ge30sXG4gICAgICBtYWpvclRpY2tTdHlsZSA9IHt9LFxuICAgICAgbWlub3JUaWNrU3R5bGUgPSB7fSxcbiAgICAgIHRpdGxlU3R5bGUgPSB7fSxcbiAgICAgIGRvbWFpblN0eWxlID0ge30sXG4gICAgICBtID0geyAvLyBBeGlzIG1hcmtzIGFzIHJlZmVyZW5jZXMgZm9yIHVwZGF0ZXNcbiAgICAgICAgZ3JpZExpbmVzOiAge30sXG4gICAgICAgIG1ham9yVGlja3M6IHt9LFxuICAgICAgICBtaW5vclRpY2tzOiB7fSxcbiAgICAgICAgdGlja0xhYmVsczoge30sXG4gICAgICAgIGRvbWFpbjoge30sXG4gICAgICAgIHRpdGxlOiAge31cbiAgICAgIH07XG5cbiAgdmFyIGF4aXMgPSB7fTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBheGlzRGVmLnR5cGUgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5nZXN0KGQpIHtcbiAgICByZXR1cm4ge2RhdGE6IGR9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGlja0Zvcm1hdCgpIHtcbiAgICB2YXIgZm9ybWF0VHlwZSA9IHRpY2tGb3JtYXRUeXBlIHx8IGluZmVyRm9ybWF0VHlwZSgpO1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZXIoZm9ybWF0VHlwZSwgdGlja0Zvcm1hdFN0cmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmZlckZvcm1hdFR5cGUoKSB7XG4gICAgc3dpdGNoIChzY2FsZS50eXBlKSB7XG4gICAgICBjYXNlIFRJTUU6ICAgIHJldHVybiBUSU1FO1xuICAgICAgY2FzZSBVVEM6ICAgICByZXR1cm4gVVRDO1xuICAgICAgY2FzZSBPUkRJTkFMOiByZXR1cm4gU1RSSU5HO1xuICAgICAgZGVmYXVsdDogICAgICByZXR1cm4gTlVNQkVSO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkYXB0ZWQgZnJvbSBkMyBsb2cgc2NhbGVcbiAgLy8gVE9ETyBjdXN0b21pemU/IHJlcGxhY2Ugd2l0aCByYW5nZS1zaXplLWF3YXJlIGZpbHRlcmluZz9cbiAgZnVuY3Rpb24gbG9nRmlsdGVyKGRvbWFpbiwgY291bnQsIGYpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgcmV0dXJuIGY7XG4gICAgdmFyIGJhc2UgPSBzY2FsZS5iYXNlKCksXG4gICAgICAgIGsgPSBNYXRoLm1pbihiYXNlLCBzY2FsZS50aWNrcygpLmxlbmd0aCAvIGNvdW50KSxcbiAgICAgICAgdiA9IGRvbWFpblswXSA+IDAgPyAoZSA9IDFlLTEyLCBNYXRoLmNlaWwpIDogKGUgPSAtMWUtMTIsIE1hdGguZmxvb3IpLFxuICAgICAgICBlO1xuICAgIGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICByZXR1cm4gKGRvbWFpblswXSA8IDAgP1xuICAgICAgICAtTWF0aC5sb2coeCA+IDAgPyAwIDogLXgpIDpcbiAgICAgICAgTWF0aC5sb2coeCA8IDAgPyAwIDogeCkpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvdyh4KSB7XG4gICAgICByZXR1cm4gZG9tYWluWzBdIDwgMCA/IC1NYXRoLnBvdyhiYXNlLCAteCkgOiBNYXRoLnBvdyhiYXNlLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBwb3codihsb2coZCkgKyBlKSkgLyBkID49IGsgPyBmKGQpIDogJyc7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlcihmb3JtYXRUeXBlLCBzdHIpIHtcbiAgICB2YXIgZm10ID0gZGwuZm9ybWF0LFxuICAgICAgICBsb2cgPSBzY2FsZS50eXBlID09PSAnbG9nJyxcbiAgICAgICAgZG9tYWluLCBmO1xuXG4gICAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgICBjYXNlIE5VTUJFUjpcbiAgICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICAgICAgICAgZiA9IGZtdC5hdXRvLm51bWJlcihkb21haW4sIHRpY2tDb3VudCwgc3RyIHx8IChsb2cgPyAnLjFyJyA6IG51bGwpKTtcbiAgICAgICAgIHJldHVybiBsb2cgPyBsb2dGaWx0ZXIoZG9tYWluLCB0aWNrQ291bnQsIGYpIDogZjtcbiAgICAgIGNhc2UgVElNRTogcmV0dXJuIChzdHIgPyBmbXQgOiBmbXQuYXV0bykudGltZShzdHIpO1xuICAgICAgY2FzZSBVVEM6ICByZXR1cm4gKHN0ciA/IGZtdCA6IGZtdC5hdXRvKS51dGMoc3RyKTtcbiAgICAgIGRlZmF1bHQ6ICAgcmV0dXJuIFN0cmluZztcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldFRpY2tzKGZvcm1hdCkge1xuICAgIHZhciBtYWpvciA9IHRpY2tWYWx1ZXMgfHwgKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3ModGlja0NvdW50KSA6IHNjYWxlLmRvbWFpbigpKSxcbiAgICAgICAgbWlub3IgPSBheGlzU3ViZGl2aWRlKHNjYWxlLCBtYWpvciwgdGlja1N1YmRpdmlkZSkubWFwKGluZ2VzdCk7XG4gICAgbWFqb3IgPSBtYWpvci5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gKGQgPSBpbmdlc3QoZCksIGQubGFiZWwgPSBmb3JtYXQoZC5kYXRhKSwgZCk7IH0pO1xuICAgIHJldHVybiBbbWFqb3IsIG1pbm9yXTtcbiAgfVxuXG4gIGF4aXMuZGVmID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFheGlzRGVmLnR5cGUpIGF4aXNfZGVmKHNjYWxlKTtcblxuICAgIHZhciB0aWNrcyA9IGdldFRpY2tzKGdldFRpY2tGb3JtYXQoKSk7XG4gICAgdmFyIHRkYXRhID0gdGl0bGUgPyBbdGl0bGVdLm1hcChpbmdlc3QpIDogW107XG5cbiAgICBheGlzRGVmLm1hcmtzWzBdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGdyaWQgPyB0aWNrc1swXSA6IFtdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGlja3NbMF07IH07XG4gICAgYXhpc0RlZi5tYXJrc1syXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aWNrc1sxXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzNdLmZyb20gPSBheGlzRGVmLm1hcmtzWzFdLmZyb207XG4gICAgYXhpc0RlZi5tYXJrc1s0XS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBbMV07IH07XG4gICAgYXhpc0RlZi5tYXJrc1s1XS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiB0ZGF0YTsgfTtcbiAgICBheGlzRGVmLm9mZnNldCA9IG9mZnNldDtcbiAgICBheGlzRGVmLm9yaWVudCA9IG9yaWVudDtcbiAgICBheGlzRGVmLmxheWVyID0gbGF5ZXI7XG5cbiAgICByZXR1cm4gYXhpc0RlZjtcbiAgfTtcblxuICBmdW5jdGlvbiBheGlzX2RlZihzY2FsZSkge1xuICAgIC8vIHNldHVwIHNjYWxlIG1hcHBpbmdcbiAgICB2YXIgbmV3U2NhbGUsIG9sZFNjYWxlLCByYW5nZTtcbiAgICBpZiAoc2NhbGUudHlwZSA9PT0gT1JESU5BTCkge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrJzpwcmV2Jywgb2Zmc2V0OiAwLjV9O1xuICAgIH1cbiAgICByYW5nZSA9IGF4aXNTY2FsZVJhbmdlKHNjYWxlKTtcblxuICAgIC8vIHNldHVwIGF4aXMgbWFya3NcbiAgICBkbC5leHRlbmQobS5ncmlkTGluZXMsIGF4aXNUaWNrcyhjb25maWcpKTtcbiAgICBkbC5leHRlbmQobS5tYWpvclRpY2tzLCBheGlzVGlja3MoY29uZmlnKSk7XG4gICAgZGwuZXh0ZW5kKG0ubWlub3JUaWNrcywgYXhpc1RpY2tzKGNvbmZpZykpO1xuICAgIGRsLmV4dGVuZChtLnRpY2tMYWJlbHMsIGF4aXNUaWNrTGFiZWxzKGNvbmZpZykpO1xuICAgIGRsLmV4dGVuZChtLmRvbWFpbiwgYXhpc0RvbWFpbihjb25maWcpKTtcbiAgICBkbC5leHRlbmQobS50aXRsZSwgYXhpc1RpdGxlKGNvbmZpZykpO1xuICAgIG0uZ3JpZExpbmVzLnByb3BlcnRpZXMuZW50ZXIuc3Ryb2tlID0ge3ZhbHVlOiBjb25maWcuYXhpcy5ncmlkQ29sb3J9O1xuICAgIG0uZ3JpZExpbmVzLnByb3BlcnRpZXMuZW50ZXIuc3Ryb2tlT3BhY2l0eSA9IHt2YWx1ZTogY29uZmlnLmF4aXMuZ3JpZE9wYWNpdHl9O1xuXG4gICAgLy8gZXh0ZW5kIGF4aXMgbWFya3MgYmFzZWQgb24gYXhpcyBvcmllbnRhdGlvblxuICAgIGF4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0uZ3JpZExpbmVzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIEluZmluaXR5KTtcbiAgICBheGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1ham9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01ham9yU2l6ZSk7XG4gICAgYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5taW5vclRpY2tzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNaW5vclNpemUpO1xuICAgIGF4aXNMYWJlbEV4dGVuZChvcmllbnQsIG0udGlja0xhYmVscywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplLCB0aWNrUGFkZGluZyk7XG5cbiAgICBheGlzRG9tYWluRXh0ZW5kKG9yaWVudCwgbS5kb21haW4sIHJhbmdlLCB0aWNrRW5kU2l6ZSk7XG4gICAgYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgbS50aXRsZSwgcmFuZ2UsIHRpdGxlT2Zmc2V0KTsgLy8gVE9ETyBnZXQgb2Zmc2V0XG4gICAgXG4gICAgLy8gYWRkIC8gb3ZlcnJpZGUgY3VzdG9tIHN0eWxlIHByb3BlcnRpZXNcbiAgICBkbC5leHRlbmQobS5ncmlkTGluZXMucHJvcGVydGllcy51cGRhdGUsIGdyaWRMaW5lU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1ham9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1ham9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS5taW5vclRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCBtaW5vclRpY2tTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGlja0xhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwgdGlja0xhYmVsU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLmRvbWFpbi5wcm9wZXJ0aWVzLnVwZGF0ZSwgZG9tYWluU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLnRpdGxlLnByb3BlcnRpZXMudXBkYXRlLCB0aXRsZVN0eWxlKTtcblxuICAgIHZhciBtYXJrcyA9IFttLmdyaWRMaW5lcywgbS5tYWpvclRpY2tzLCBtLm1pbm9yVGlja3MsIG0udGlja0xhYmVscywgbS5kb21haW4sIG0udGl0bGVdO1xuICAgIGRsLmV4dGVuZChheGlzRGVmLCB7XG4gICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczogeyBcbiAgICAgICAgZW50ZXI6IHtcbiAgICAgICAgICBlbmNvZGU6IGF4aXNVcGRhdGUsXG4gICAgICAgICAgc2NhbGVzOiBbc2NhbGUuc2NhbGVOYW1lXSxcbiAgICAgICAgICBzaWduYWxzOiBbXSwgZGF0YTogW11cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgZW5jb2RlOiBheGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGF4aXNEZWYubWFya3MgPSBtYXJrcy5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgIGlmIChzY2FsZSAhPT0geCkgeyBzY2FsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm9yaWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgaWYgKG9yaWVudCAhPT0geCkge1xuICAgICAgb3JpZW50ID0geCBpbiBheGlzT3JpZW50cyA/IHggKyAnJyA6IGNvbmZpZy5heGlzLm9yaWVudDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGl0bGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgaWYgKHRpdGxlICE9PSB4KSB7IHRpdGxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0NvdW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tDb3VudDtcbiAgICB0aWNrQ291bnQgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdFR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0Zvcm1hdFR5cGU7XG4gICAgaWYgKHRpY2tGb3JtYXRUeXBlICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0VHlwZSA9IHg7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tNYWpvclNpemU7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgbWFqb3IgPSAreCxcbiAgICAgICAgbWlub3IgPSBuID4gMSA/ICt5IDogdGlja01ham9yU2l6ZSxcbiAgICAgICAgZW5kICAgPSBuID4gMCA/ICthcmd1bWVudHNbbl0gOiB0aWNrTWFqb3JTaXplO1xuXG4gICAgaWYgKHRpY2tNYWpvclNpemUgIT09IG1ham9yIHx8XG4gICAgICAgIHRpY2tNaW5vclNpemUgIT09IG1pbm9yIHx8XG4gICAgICAgIHRpY2tFbmRTaXplICE9PSBlbmQpIHtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuXG4gICAgdGlja01ham9yU2l6ZSA9IG1ham9yO1xuICAgIHRpY2tNaW5vclNpemUgPSBtaW5vcjtcbiAgICB0aWNrRW5kU2l6ZSA9IGVuZDtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tTdWJkaXZpZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1N1YmRpdmlkZTtcbiAgICB0aWNrU3ViZGl2aWRlID0gK3g7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIFxuICBheGlzLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gZGwuaXNPYmplY3QoeCkgPyB4IDogK3g7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrUGFkZGluZztcbiAgICBpZiAodGlja1BhZGRpbmcgIT09ICt4KSB7IHRpY2tQYWRkaW5nID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlT2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlT2Zmc2V0O1xuICAgIGlmICh0aXRsZU9mZnNldCAhPT0gK3gpIHsgdGl0bGVPZmZzZXQgPSAreDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubGF5ZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGF5ZXI7XG4gICAgaWYgKGxheWVyICE9PSB4KSB7IGxheWVyID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmlkO1xuICAgIGlmIChncmlkICE9PSB4KSB7IGdyaWQgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5ncmlkTGluZVByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZExpbmVTdHlsZTtcbiAgICBpZiAoZ3JpZExpbmVTdHlsZSAhPT0geCkgeyBncmlkTGluZVN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYWpvclRpY2tTdHlsZTtcbiAgICBpZiAobWFqb3JUaWNrU3R5bGUgIT09IHgpIHsgbWFqb3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1pbm9yVGlja1N0eWxlO1xuICAgIGlmIChtaW5vclRpY2tTdHlsZSAhPT0geCkgeyBtaW5vclRpY2tTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tMYWJlbFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0xhYmVsU3R5bGU7XG4gICAgaWYgKHRpY2tMYWJlbFN0eWxlICE9PSB4KSB7IHRpY2tMYWJlbFN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGl0bGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlU3R5bGU7XG4gICAgaWYgKHRpdGxlU3R5bGUgIT09IHgpIHsgdGl0bGVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmRvbWFpblByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluU3R5bGU7XG4gICAgaWYgKGRvbWFpblN0eWxlICE9PSB4KSB7IGRvbWFpblN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5yZXNldCA9IGZ1bmN0aW9uKCkgeyBcbiAgICByZXNldCgpOyBcbiAgICByZXR1cm4gYXhpczsgXG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbnZhciBheGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiBheGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICB2YXIgc3VidGlja3MgPSBbXTtcbiAgaWYgKG0gJiYgdGlja3MubGVuZ3RoID4gMSkge1xuICAgIHZhciBleHRlbnQgPSBheGlzU2NhbGVFeHRlbnQoc2NhbGUuZG9tYWluKCkpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIGF4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudCA/XG4gICAgc2NhbGUucmFuZ2VFeHRlbnQoKSA6XG4gICAgYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgYXhpc0FsaWduID0ge1xuICBib3R0b206ICdjZW50ZXInLFxuICB0b3A6ICdjZW50ZXInLFxuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG52YXIgYXhpc0Jhc2VsaW5lID0ge1xuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nLFxuICBsZWZ0OiAnbWlkZGxlJyxcbiAgcmlnaHQ6ICdtaWRkbGUnXG59O1xuXG5mdW5jdGlvbiBheGlzTGFiZWxFeHRlbmQob3JpZW50LCBsYWJlbHMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgc2l6ZSwgcGFkKSB7XG4gIHNpemUgPSBNYXRoLm1heChzaXplLCAwKSArIHBhZDtcbiAgaWYgKG9yaWVudCA9PT0gJ2xlZnQnIHx8IG9yaWVudCA9PT0gJ3RvcCcpIHtcbiAgICBzaXplICo9IC0xO1xuICB9ICBcbiAgaWYgKG9yaWVudCA9PT0gJ3RvcCcgfHwgb3JpZW50ID09PSAnYm90dG9tJykge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6ICdjZW50ZXInfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IGF4aXNCYXNlbGluZVtvcmllbnRdfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG9sZFNjYWxlLFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IHt2YWx1ZTogc2l6ZX0sXG4gICAgICB5OiBuZXdTY2FsZSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IGF4aXNBbGlnbltvcmllbnRdfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF4aXNUaWNrc0V4dGVuZChvcmllbnQsIHRpY2tzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUpIHtcbiAgdmFyIHNpZ24gPSAob3JpZW50ID09PSAnbGVmdCcgfHwgb3JpZW50ID09PSAndG9wJykgPyAtMSA6IDE7XG4gIGlmIChzaXplID09PSBJbmZpbml0eSkge1xuICAgIHNpemUgPSAob3JpZW50ID09PSAndG9wJyB8fCBvcmllbnQgPT09ICdib3R0b20nKSA/XG4gICAgICB7ZmllbGQ6IHtncm91cDogJ2hlaWdodCcsIGxldmVsOiAyfSwgbXVsdDogLXNpZ259IDpcbiAgICAgIHtmaWVsZDoge2dyb3VwOiAnd2lkdGgnLCAgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn07XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHt2YWx1ZTogc2lnbiAqIHNpemV9O1xuICB9XG4gIGlmIChvcmllbnQgPT09ICd0b3AnIHx8IG9yaWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogIG9sZFNjYWxlLFxuICAgICAgeTogIHt2YWx1ZTogMH0sXG4gICAgICB5Mjogc2l6ZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgICAgeTogIHt2YWx1ZTogMH0sXG4gICAgICB5Mjogc2l6ZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmV4aXQsIHtcbiAgICAgIHg6ICBuZXdTY2FsZSxcbiAgICB9KTsgICAgICAgIFxuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiBzaXplLFxuICAgICAgeTogIG9sZFNjYWxlXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiBzaXplLFxuICAgICAgeTogIG5ld1NjYWxlXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeTogIG5ld1NjYWxlLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZUV4dGVuZChvcmllbnQsIHRpdGxlLCByYW5nZSwgb2Zmc2V0KSB7XG4gIHZhciBtaWQgPSB+figocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyKSxcbiAgICAgIHNpZ24gPSAob3JpZW50ID09PSAndG9wJyB8fCBvcmllbnQgPT09ICdsZWZ0JykgPyAtMSA6IDE7XG4gIFxuICBpZiAob3JpZW50ID09PSAnYm90dG9tJyB8fCBvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgZGwuZXh0ZW5kKHRpdGxlLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiB7dmFsdWU6IG1pZH0sXG4gICAgICB5OiB7dmFsdWU6IHNpZ24qb2Zmc2V0fSxcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpdGxlLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpZ24qb2Zmc2V0fSxcbiAgICAgIHk6IHt2YWx1ZTogbWlkfSxcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IG9yaWVudCA9PT0gJ2xlZnQnID8gLTkwIDogOTB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIGRvbWFpbiwgcmFuZ2UsIHNpemUpIHtcbiAgdmFyIHBhdGg7XG4gIGlmIChvcmllbnQgPT09ICd0b3AnIHx8IG9yaWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgc2l6ZSA9IC0xICogc2l6ZTtcbiAgfVxuICBpZiAob3JpZW50ID09PSAnYm90dG9tJyB8fCBvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgcGF0aCA9ICdNJyArIHJhbmdlWzBdICsgJywnICsgc2l6ZSArICdWMEgnICsgcmFuZ2VbMV0gKyAnVicgKyBzaXplO1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSAnTScgKyBzaXplICsgJywnICsgcmFuZ2VbMF0gKyAnSDBWJyArIHJhbmdlWzFdICsgJ0gnICsgc2l6ZTtcbiAgfVxuICBkb21haW4ucHJvcGVydGllcy51cGRhdGUucGF0aCA9IHt2YWx1ZTogcGF0aH07XG59XG5cbmZ1bmN0aW9uIGF4aXNVcGRhdGUoaXRlbSwgZ3JvdXAsIHRyYW5zKSB7XG4gIHZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sXG4gICAgICBvZmZzZXQgPSBpdGVtLm1hcmsuZGVmLm9mZnNldCxcbiAgICAgIG9yaWVudCA9IGl0ZW0ubWFyay5kZWYub3JpZW50LFxuICAgICAgd2lkdGggID0gZ3JvdXAud2lkdGgsXG4gICAgICBoZWlnaHQgPSBncm91cC5oZWlnaHQ7IC8vIFRPRE8gZmFsbGJhY2sgdG8gZ2xvYmFsIHcsaD9cblxuICBpZiAoZGwuaXNBcnJheShvZmZzZXQpKSB7XG4gICAgdmFyIG9meCA9IG9mZnNldFswXSxcbiAgICAgICAgb2Z5ID0gb2Zmc2V0WzFdO1xuXG4gICAgc3dpdGNoIChvcmllbnQpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOiAgIHsgVHVwbGUuc2V0KG8sICd4JywgLW9meCk7IFR1cGxlLnNldChvLCAneScsIG9meSk7IGJyZWFrOyB9XG4gICAgICBjYXNlICdyaWdodCc6ICB7IFR1cGxlLnNldChvLCAneCcsIHdpZHRoICsgb2Z4KTsgVHVwbGUuc2V0KG8sICd5Jywgb2Z5KTsgYnJlYWs7IH1cbiAgICAgIGNhc2UgJ2JvdHRvbSc6IHsgVHVwbGUuc2V0KG8sICd4Jywgb2Z4KTsgVHVwbGUuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Z5KTsgYnJlYWs7IH1cbiAgICAgIGNhc2UgJ3RvcCc6ICAgIHsgVHVwbGUuc2V0KG8sICd4Jywgb2Z4KTsgVHVwbGUuc2V0KG8sICd5JywgLW9meSk7IGJyZWFrOyB9XG4gICAgICBkZWZhdWx0OiAgICAgICB7IFR1cGxlLnNldChvLCAneCcsIG9meCk7IFR1cGxlLnNldChvLCAneScsIG9meSk7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCA9IC1ncm91cC5zY2FsZShvZmZzZXQuc2NhbGUpKG9mZnNldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcmllbnQpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOiAgIHsgVHVwbGUuc2V0KG8sICd4JywgLW9mZnNldCk7IFR1cGxlLnNldChvLCAneScsIDApOyBicmVhazsgfVxuICAgICAgY2FzZSAncmlnaHQnOiAgeyBUdXBsZS5zZXQobywgJ3gnLCB3aWR0aCArIG9mZnNldCk7IFR1cGxlLnNldChvLCAneScsIDApOyBicmVhazsgfVxuICAgICAgY2FzZSAnYm90dG9tJzogeyBUdXBsZS5zZXQobywgJ3gnLCAwKTsgVHVwbGUuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICAgIGNhc2UgJ3RvcCc6ICAgIHsgVHVwbGUuc2V0KG8sICd4JywgMCk7IFR1cGxlLnNldChvLCAneScsIC1vZmZzZXQpOyBicmVhazsgfVxuICAgICAgZGVmYXVsdDogICAgICAgeyBUdXBsZS5zZXQobywgJ3gnLCAwKTsgVHVwbGUuc2V0KG8sICd5JywgMCk7IH1cbiAgICB9XG4gIH1cblxuICBpZiAodHJhbnMpIHRyYW5zLmludGVycG9sYXRlKGl0ZW0sIG8pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXhpc1RpY2tzKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdydWxlJyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiAnZGF0YScsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tXaWR0aH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZTogeyBvcGFjaXR5OiB7dmFsdWU6IDF9IH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF4aXNUaWNrTGFiZWxzKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBmaWxsOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsRm9udFNpemV9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6ICdsYWJlbCd9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBheGlzVGl0bGUoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUNvbG9yfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogJ2NlbnRlcid9LFxuICAgICAgICBiYXNlbGluZToge3ZhbHVlOiAnbWlkZGxlJ30sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogJ2RhdGEnfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF4aXNEb21haW4oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7dmFsdWU6IDAuNX0sXG4gICAgICAgIHk6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNvbmZpZy5heGlzLmF4aXNDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNvbmZpZy5heGlzLmF4aXNXaWR0aH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF4czsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBHcmFkaWVudCA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLkdyYWRpZW50LFxuICAgIHBhcnNlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3Byb3BlcnRpZXMnKSxcbiAgICBwYXJzZU1hcmsgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrJyk7XG5cbmZ1bmN0aW9uIGxnbmQobW9kZWwpIHtcbiAgdmFyIHNpemUgPSBudWxsLFxuICAgICAgc2hhcGUgPSBudWxsLFxuICAgICAgZmlsbCA9IG51bGwsXG4gICAgICBzdHJva2UgPSBudWxsLFxuICAgICAgc3BhY2luZyA9IG51bGwsXG4gICAgICB2YWx1ZXMgPSBudWxsLFxuICAgICAgZm9ybWF0ID0gbnVsbCxcbiAgICAgIGZvcm1hdFN0cmluZyA9IG51bGwsXG4gICAgICBjb25maWcgPSBtb2RlbC5jb25maWcoKSxcbiAgICAgIHRpdGxlLFxuICAgICAgb3JpZW50ID0gJ3JpZ2h0JyxcbiAgICAgIG9mZnNldCA9IGNvbmZpZy5sZWdlbmQub2Zmc2V0LFxuICAgICAgcGFkZGluZyA9IGNvbmZpZy5sZWdlbmQucGFkZGluZyxcbiAgICAgIHRpY2tBcmd1bWVudHMgPSBbNV0sXG4gICAgICBsZWdlbmRTdHlsZSA9IHt9LFxuICAgICAgc3ltYm9sU3R5bGUgPSB7fSxcbiAgICAgIGdyYWRpZW50U3R5bGUgPSB7fSxcbiAgICAgIHRpdGxlU3R5bGUgPSB7fSxcbiAgICAgIGxhYmVsU3R5bGUgPSB7fSxcbiAgICAgIG0gPSB7IC8vIExlZ2VuZCBtYXJrcyBhcyByZWZlcmVuY2VzIGZvciB1cGRhdGVzXG4gICAgICAgIHRpdGxlczogIHt9LFxuICAgICAgICBzeW1ib2xzOiB7fSxcbiAgICAgICAgbGFiZWxzOiAge30sXG4gICAgICAgIGdyYWRpZW50OiB7fVxuICAgICAgfTtcblxuICB2YXIgbGVnZW5kID0ge30sXG4gICAgICBsZWdlbmREZWYgPSB7fTtcblxuICBmdW5jdGlvbiByZXNldCgpIHsgbGVnZW5kRGVmLnR5cGUgPSBudWxsOyB9XG4gIGZ1bmN0aW9uIGluZ2VzdChkLCBpKSB7IHJldHVybiB7ZGF0YTogZCwgaW5kZXg6IGl9OyB9XG5cbiAgbGVnZW5kLmRlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IHNpemUgfHwgc2hhcGUgfHwgZmlsbCB8fCBzdHJva2U7XG4gICAgXG4gICAgZm9ybWF0ID0gIWZvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJykgP1xuICAgICAgZGwuZm9ybWF0LnRpbWUoZm9ybWF0U3RyaW5nKSA6IGRsLmZvcm1hdC5udW1iZXIoZm9ybWF0U3RyaW5nKSk7XG4gICAgXG4gICAgaWYgKCFsZWdlbmREZWYudHlwZSkge1xuICAgICAgbGVnZW5kRGVmID0gKHNjYWxlPT09ZmlsbCB8fCBzY2FsZT09PXN0cm9rZSkgJiYgIWRpc2NyZXRlKHNjYWxlLnR5cGUpID9cbiAgICAgICAgcXVhbnREZWYoc2NhbGUpIDogb3JkaW5hbERlZihzY2FsZSk7ICAgICAgXG4gICAgfVxuICAgIGxlZ2VuZERlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgbGVnZW5kRGVmLm9mZnNldCA9IG9mZnNldDtcbiAgICBsZWdlbmREZWYucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgcmV0dXJuIGxlZ2VuZERlZjtcbiAgfTtcblxuICBmdW5jdGlvbiBkaXNjcmV0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGU9PT0nb3JkaW5hbCcgfHwgdHlwZT09PSdxdWFudGl6ZScgfHxcbiAgICAgICAgICAgdHlwZT09PSdxdWFudGlsZScgfHwgdHlwZT09PSd0aHJlc2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gb3JkaW5hbERlZihzY2FsZSkge1xuICAgIHZhciBkZWYgPSBvX2xlZ2VuZF9kZWYoc2l6ZSwgc2hhcGUsIGZpbGwsIHN0cm9rZSk7XG5cbiAgICAvLyBnZW5lcmF0ZSBkYXRhXG4gICAgdmFyIGRhdGEgPSAodmFsdWVzID09IG51bGwgP1xuICAgICAgKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDpcbiAgICAgIHZhbHVlcykubWFwKGluZ2VzdCk7XG4gICAgdmFyIGZtdCA9IGZvcm1hdD09bnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBTdHJpbmcpIDogZm9ybWF0O1xuICAgIFxuICAgIC8vIGRldGVybWluZSBzcGFjaW5nIGJldHdlZW4gbGVnZW5kIGVudHJpZXNcbiAgICB2YXIgZnMsIHJhbmdlLCBvZmZzZXQsIHBhZD01LCBkb21haW4gPSBkMy5yYW5nZShkYXRhLmxlbmd0aCk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIHJhbmdlID0gZGF0YS5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5zcXJ0KHNpemUoeC5kYXRhKSk7IH0pO1xuICAgICAgb2Zmc2V0ID0gZDMubWF4KHJhbmdlKTtcbiAgICAgIHJhbmdlID0gcmFuZ2UucmVkdWNlKGZ1bmN0aW9uKGEsYixpLHopIHtcbiAgICAgICAgICBpZiAoaSA+IDApIGFbaV0gPSBhW2ktMV0gKyB6W2ktMV0vMiArIHBhZDtcbiAgICAgICAgICByZXR1cm4gKGFbaV0gKz0gYi8yLCBhKTsgfSwgWzBdKS5tYXAoTWF0aC5yb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KGNvbmZpZy5sZWdlbmQuc3ltYm9sU2l6ZSkpO1xuICAgICAgcmFuZ2UgPSBzcGFjaW5nIHx8XG4gICAgICAgIChmcyA9IGxhYmVsU3R5bGUuZm9udFNpemUpICYmIChmcy52YWx1ZSArIHBhZCkgfHxcbiAgICAgICAgKGNvbmZpZy5sZWdlbmQubGFiZWxGb250U2l6ZSArIHBhZCk7XG4gICAgICByYW5nZSA9IGRvbWFpbi5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG9mZnNldC8yICsgaSpyYW5nZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhY2NvdW50IGZvciBwYWRkaW5nIGFuZCB0aXRsZSBzaXplXG4gICAgdmFyIHN6ID0gcGFkZGluZywgdHM7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICB0cyA9IHRpdGxlU3R5bGUuZm9udFNpemU7XG4gICAgICBzeiArPSA1ICsgKCh0cyAmJiB0cy52YWx1ZSkgfHwgY29uZmlnLmxlZ2VuZC50aXRsZUZvbnRTaXplKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaT0wLCBuPXJhbmdlLmxlbmd0aDsgaTxuOyArK2kpIHJhbmdlW2ldICs9IHN6O1xuICAgIFxuICAgIC8vIGJ1aWxkIHNjYWxlIGZvciBsYWJlbCBsYXlvdXRcbiAgICB2YXIgc2NhbGVTcGVjID0ge1xuICAgICAgbmFtZTogJ2xlZ2VuZCcsXG4gICAgICB0eXBlOiAnb3JkaW5hbCcsXG4gICAgICBwb2ludHM6IHRydWUsXG4gICAgICBkb21haW46IGRvbWFpbixcbiAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG4gICAgXG4gICAgLy8gdXBkYXRlIGxlZ2VuZCBkZWZcbiAgICB2YXIgdGRhdGEgPSAodGl0bGUgPyBbdGl0bGVdIDogW10pLm1hcChpbmdlc3QpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICBkLmxhYmVsID0gZm10KGQuZGF0YSk7XG4gICAgICBkLm9mZnNldCA9IG9mZnNldDtcbiAgICB9KTtcbiAgICBkZWYuc2NhbGVzID0gWyBzY2FsZVNwZWMgXTtcbiAgICBkZWYubWFya3NbMF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgZGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGE7IH07XG4gICAgZGVmLm1hcmtzWzJdLmZyb20gPSBkZWYubWFya3NbMV0uZnJvbTtcblxuICAgIHJldHVybiBkZWY7XG4gIH1cblxuICBmdW5jdGlvbiBvX2xlZ2VuZF9kZWYoc2l6ZSwgc2hhcGUsIGZpbGwsIHN0cm9rZSkge1xuICAgIC8vIHNldHVwIGxlZ2VuZCBtYXJrc1xuICAgIHZhciB0aXRsZXMgID0gZGwuZXh0ZW5kKG0udGl0bGVzLCB2Z19sZWdlbmRUaXRsZShjb25maWcpKSxcbiAgICAgICAgc3ltYm9scyA9IGRsLmV4dGVuZChtLnN5bWJvbHMsIHZnX2xlZ2VuZFN5bWJvbHMoY29uZmlnKSksXG4gICAgICAgIGxhYmVscyAgPSBkbC5leHRlbmQobS5sYWJlbHMsIHZnX3ZMZWdlbmRMYWJlbHMoY29uZmlnKSk7XG5cbiAgICAvLyBleHRlbmQgbGVnZW5kIG1hcmtzXG4gICAgdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKHN5bWJvbHMsIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpO1xuICAgIFxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKHRpdGxlcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIHRpdGxlU3R5bGUpO1xuICAgIGRsLmV4dGVuZChzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLCBzeW1ib2xTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIGxhYmVsU3R5bGUpO1xuXG4gICAgLy8gcGFkZGluZyBmcm9tIGxlZ2VuZCBib3JkZXJcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLngub2Zmc2V0ICs9IHBhZGRpbmcgKyAxO1xuICAgIHN5bWJvbHMucHJvcGVydGllcy5lbnRlci54Lm9mZnNldCA9IHBhZGRpbmcgKyAxO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS54Lm9mZnNldCArPSBwYWRkaW5nICsgMTtcbiAgICBzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLngub2Zmc2V0ID0gcGFkZGluZyArIDE7XG5cbiAgICBkbC5leHRlbmQobGVnZW5kRGVmLCB7XG4gICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBlbnRlcjogcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCAnZ3JvdXAnLCBsZWdlbmRTdHlsZSksXG4gICAgICAgIHZnX2xlZ2VuZFBvc2l0aW9uOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19sZWdlbmRQb3NpdGlvbixcbiAgICAgICAgICBzaWduYWxzOiBbXSwgc2NhbGVzOltdLCBkYXRhOiBbXSwgZmllbGRzOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZWdlbmREZWYubWFya3MgPSBbdGl0bGVzLCBzeW1ib2xzLCBsYWJlbHNdLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KTtcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnREZWYoc2NhbGUpIHtcbiAgICB2YXIgZGVmID0gcV9sZWdlbmRfZGVmKHNjYWxlKSxcbiAgICAgICAgZG9tID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIGRhdGEgPSAodmFsdWVzID09IG51bGwgP1xuICAgICAgICAgIChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKSA6XG4gICAgICAgICAgdmFsdWVzKS5tYXAoaW5nZXN0KSxcbiAgICAgICAgd2lkdGggPSAoZ3JhZGllbnRTdHlsZS53aWR0aCAmJiBncmFkaWVudFN0eWxlLndpZHRoLnZhbHVlKSB8fCBjb25maWcubGVnZW5kLmdyYWRpZW50V2lkdGgsXG4gICAgICAgIGZtdCA9IGZvcm1hdD09bnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBTdHJpbmcpIDogZm9ybWF0O1xuXG4gICAgLy8gYnVpbGQgc2NhbGUgZm9yIGxhYmVsIGxheW91dFxuICAgIHZhciBsYXlvdXRTcGVjID0ge1xuICAgICAgbmFtZTogJ2xlZ2VuZCcsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlLFxuICAgICAgcm91bmQ6IHRydWUsXG4gICAgICB6ZXJvOiBmYWxzZSxcbiAgICAgIGRvbWFpbjogW2RvbVswXSwgZG9tW2RvbS5sZW5ndGgtMV1dLFxuICAgICAgcmFuZ2U6IFtwYWRkaW5nLCB3aWR0aCtwYWRkaW5nXVxuICAgIH07XG4gICAgaWYgKHNjYWxlLnR5cGU9PT0ncG93JykgbGF5b3V0U3BlYy5leHBvbmVudCA9IHNjYWxlLmV4cG9uZW50KCk7XG4gICAgXG4gICAgLy8gdXBkYXRlIGxlZ2VuZCBkZWZcbiAgICB2YXIgdGRhdGEgPSAodGl0bGUgPyBbdGl0bGVdIDogW10pLm1hcChpbmdlc3QpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgIGQubGFiZWwgPSBmbXQoZC5kYXRhKTtcbiAgICAgIGQuYWxpZ24gPSBpPT0oZGF0YS5sZW5ndGgtMSkgPyAncmlnaHQnIDogaT09PTAgPyAnbGVmdCcgOiAnY2VudGVyJztcbiAgICB9KTtcbiAgICBkZWYuc2NhbGVzID0gWyBsYXlvdXRTcGVjIF07XG4gICAgZGVmLm1hcmtzWzBdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRkYXRhOyB9O1xuICAgIGRlZi5tYXJrc1sxXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBbMV07IH07XG4gICAgZGVmLm1hcmtzWzJdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGE7IH07XG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcV9sZWdlbmRfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgbGVnZW5kIG1hcmtzXG4gICAgdmFyIHRpdGxlcyA9IGRsLmV4dGVuZChtLnRpdGxlcywgdmdfbGVnZW5kVGl0bGUoY29uZmlnKSksXG4gICAgICAgIGdyYWRpZW50ID0gZGwuZXh0ZW5kKG0uZ3JhZGllbnQsIHZnX2xlZ2VuZEdyYWRpZW50KGNvbmZpZykpLFxuICAgICAgICBsYWJlbHMgPSBkbC5leHRlbmQobS5sYWJlbHMsIHZnX2hMZWdlbmRMYWJlbHMoY29uZmlnKSksXG4gICAgICAgIGdyYWQgPSBuZXcgR3JhZGllbnQoKTtcblxuICAgIC8vIHNldHVwIGNvbG9yIGdyYWRpZW50XG4gICAgdmFyIGRvbSA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICBtaW4gPSBkb21bMF0sXG4gICAgICAgIG1heCA9IGRvbVtkb20ubGVuZ3RoLTFdLFxuICAgICAgICBmID0gc2NhbGUuY29weSgpLmRvbWFpbihbbWluLCBtYXhdKS5yYW5nZShbMCwxXSk7XG4gICAgICAgIFxuICAgIHZhciBzdG9wcyA9IChzY2FsZS50eXBlICE9PSAnbGluZWFyJyAmJiBzY2FsZS50aWNrcykgP1xuICAgICAgc2NhbGUudGlja3MuY2FsbChzY2FsZSwgMTUpIDogZG9tO1xuICAgIGlmIChtaW4gIT09IHN0b3BzWzBdKSBzdG9wcy51bnNoaWZ0KG1pbik7XG4gICAgaWYgKG1heCAhPT0gc3RvcHNbc3RvcHMubGVuZ3RoLTFdKSBzdG9wcy5wdXNoKG1heCk7XG5cbiAgICBmb3IgKHZhciBpPTAsIG49c3RvcHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZ3JhZC5zdG9wKGYoc3RvcHNbaV0pLCBzY2FsZShzdG9wc1tpXSkpO1xuICAgIH1cbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLmVudGVyLmZpbGwgPSB7dmFsdWU6IGdyYWR9O1xuXG4gICAgLy8gYWRkIC8gb3ZlcnJpZGUgY3VzdG9tIHN0eWxlIHByb3BlcnRpZXNcbiAgICBkbC5leHRlbmQodGl0bGVzLnByb3BlcnRpZXMudXBkYXRlLCB0aXRsZVN0eWxlKTtcbiAgICBkbC5leHRlbmQoZ3JhZGllbnQucHJvcGVydGllcy51cGRhdGUsIGdyYWRpZW50U3R5bGUpO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIGxhYmVsU3R5bGUpO1xuXG4gICAgLy8gYWNjb3VudCBmb3IgZ3JhZGllbnQgc2l6ZVxuICAgIHZhciBncCA9IGdyYWRpZW50LnByb3BlcnRpZXMsIGdoID0gZ3JhZGllbnRTdHlsZS5oZWlnaHQsXG4gICAgICAgIGhoID0gKGdoICYmIGdoLnZhbHVlKSB8fCBncC5lbnRlci5oZWlnaHQudmFsdWU7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSA9IGhoO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlID0gaGg7XG5cbiAgICAvLyBhY2NvdW50IGZvciB0aXRsZSBzaXplIGFzIG5lZWRlZFxuICAgIGlmICh0aXRsZSkge1xuICAgICAgdmFyIHRwID0gdGl0bGVzLnByb3BlcnRpZXMsIGZzID0gdGl0bGVTdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBzeiA9IDQgKyAoKGZzICYmIGZzLnZhbHVlKSB8fCB0cC5lbnRlci5mb250U2l6ZS52YWx1ZSk7XG4gICAgICBncmFkaWVudC5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gc3o7XG4gICAgICBsYWJlbHMucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHN6O1xuICAgICAgZ3JhZGllbnQucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBzejtcbiAgICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlICs9IHN6O1xuICAgIH1cbiAgICBcbiAgICAvLyBwYWRkaW5nIGZyb20gbGVnZW5kIGJvcmRlclxuICAgIHRpdGxlcy5wcm9wZXJ0aWVzLmVudGVyLngudmFsdWUgKz0gcGFkZGluZztcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLngudmFsdWUgKz0gcGFkZGluZztcbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgKz0gcGFkZGluZztcblxuICAgIGRsLmV4dGVuZChsZWdlbmREZWYsIHtcbiAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsICdncm91cCcsIGxlZ2VuZFN0eWxlKSxcbiAgICAgICAgdmdfbGVnZW5kUG9zaXRpb246IHtcbiAgICAgICAgICBlbmNvZGU6IHZnX2xlZ2VuZFBvc2l0aW9uLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBzY2FsZXM6IFtdLCBkYXRhOiBbXSwgZmllbGRzOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZWdlbmREZWYubWFya3MgPSBbdGl0bGVzLCBncmFkaWVudCwgbGFiZWxzXS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSk7XG4gICAgcmV0dXJuIGxlZ2VuZERlZjtcbiAgfVxuXG4gIGxlZ2VuZC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgaWYgKHNpemUgIT09IHgpIHsgc2l6ZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZTtcbiAgICBpZiAoc2hhcGUgIT09IHgpIHsgc2hhcGUgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuZmlsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmaWxsO1xuICAgIGlmIChmaWxsICE9PSB4KSB7IGZpbGwgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcbiAgXG4gIGxlZ2VuZC5zdHJva2UgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3Ryb2tlO1xuICAgIGlmIChzdHJva2UgIT09IHgpIHsgc3Ryb2tlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5mb3JtYXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9ybWF0U3RyaW5nO1xuICAgIGlmIChmb3JtYXRTdHJpbmcgIT09IHgpIHtcbiAgICAgIGZvcm1hdFN0cmluZyA9IHg7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zcGFjaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNwYWNpbmc7XG4gICAgaWYgKHNwYWNpbmcgIT09ICt4KSB7IHNwYWNpbmcgPSAreDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9yaWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgb3JpZW50ID0geCBpbiB2Z19sZWdlbmRPcmllbnRzID8geCArICcnIDogY29uZmlnLmxlZ2VuZC5vcmllbnQ7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICBvZmZzZXQgPSAreDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC52YWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVzO1xuICAgIHZhbHVlcyA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGVnZW5kUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsZWdlbmRTdHlsZTtcbiAgICBsZWdlbmRTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc3ltYm9sUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzeW1ib2xTdHlsZTtcbiAgICBzeW1ib2xTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuZ3JhZGllbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYWRpZW50U3R5bGU7XG4gICAgZ3JhZGllbnRTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsU3R5bGU7XG4gICAgbGFiZWxTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcbiAgXG4gIGxlZ2VuZC50aXRsZVByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGVTdHlsZTtcbiAgICB0aXRsZVN0eWxlID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5yZXNldCA9IGZ1bmN0aW9uKCkgeyBcbiAgICByZXNldCgpOyBcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbnZhciB2Z19sZWdlbmRPcmllbnRzID0ge3JpZ2h0OiAxLCBsZWZ0OiAxfTtcblxuZnVuY3Rpb24gdmdfbGVnZW5kUG9zaXRpb24oaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykge1xuICB2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtLCBneCxcbiAgICAgIG9mZnNldCA9IGl0ZW0ubWFyay5kZWYub2Zmc2V0LFxuICAgICAgb3JpZW50ID0gaXRlbS5tYXJrLmRlZi5vcmllbnQsXG4gICAgICBwYWQgICAgPSBpdGVtLm1hcmsuZGVmLnBhZGRpbmcgKiAyLFxuICAgICAgbHcgICAgID0gfn5pdGVtLmJvdW5kcy53aWR0aCgpICsgKGl0ZW0ud2lkdGggPyAwIDogcGFkKSxcbiAgICAgIGxoICAgICA9IH5+aXRlbS5ib3VuZHMuaGVpZ2h0KCkgKyAoaXRlbS5oZWlnaHQgPyAwIDogcGFkKSxcbiAgICAgIHBvcyA9IGdyb3VwLl9sZWdlbmRQb3NpdGlvbnMgfHwgXG4gICAgICAgIChncm91cC5fbGVnZW5kUG9zaXRpb25zID0ge3JpZ2h0OiAwLjUsIGxlZnQ6IDAuNX0pO1xuXG4gIG8ueCA9IDAuNTtcbiAgby53aWR0aCA9IGx3O1xuICBvLnkgPSBwb3Nbb3JpZW50XTtcbiAgcG9zW29yaWVudF0gKz0gKG8uaGVpZ2h0ID0gbGgpO1xuXG4gIC8vIEhBQ0s6IHVzZSB0byBlc3RpbWF0ZSBncm91cCBib3VuZHMgZHVyaW5nIGFuaW1hdGVkIHRyYW5zaXRpb25cbiAgaWYgKCF0cmFucyAmJiBncm91cC5ib3VuZHMpIHtcbiAgICBncm91cC5ib3VuZHMuZGVsdGEgPSBncm91cC5ib3VuZHMueDIgLSBncm91cC53aWR0aDtcbiAgfVxuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSAnbGVmdCc6ICB7XG4gICAgICBneCA9IGdyb3VwLmJvdW5kcyA/IGdyb3VwLmJvdW5kcy54MSA6IDA7XG4gICAgICBvLnggKz0gZ3ggLSBvZmZzZXQgLSBsdztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdyaWdodCc6IHtcbiAgICAgIGd4ID0gZ3JvdXAud2lkdGggKyAoZ3JvdXAuYm91bmRzICYmIHRyYW5zID8gZ3JvdXAuYm91bmRzLmRlbHRhIDogMCk7XG4gICAgICBvLnggKz0gZ3ggKyBvZmZzZXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XG4gIHZhciBlbmMgPSBpdGVtLm1hcmsuZGVmLnByb3BlcnRpZXMuZW50ZXIuZW5jb2RlO1xuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGdyb3VwLCB0cmFucywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKG1hcmssIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgdmFyIGUgPSBtYXJrLnByb3BlcnRpZXMuZW50ZXIsXG4gICAgICB1ID0gbWFyay5wcm9wZXJ0aWVzLnVwZGF0ZTtcbiAgaWYgKHNpemUpICAgZS5zaXplICAgPSB1LnNpemUgICA9IHtzY2FsZTogc2l6ZS5zY2FsZU5hbWUsICAgZmllbGQ6ICdkYXRhJ307XG4gIGlmIChzaGFwZSkgIGUuc2hhcGUgID0gdS5zaGFwZSAgPSB7c2NhbGU6IHNoYXBlLnNjYWxlTmFtZSwgIGZpZWxkOiAnZGF0YSd9O1xuICBpZiAoZmlsbCkgICBlLmZpbGwgICA9IHUuZmlsbCAgID0ge3NjYWxlOiBmaWxsLnNjYWxlTmFtZSwgICBmaWVsZDogJ2RhdGEnfTtcbiAgaWYgKHN0cm9rZSkgZS5zdHJva2UgPSB1LnN0cm9rZSA9IHtzY2FsZTogc3Ryb2tlLnNjYWxlTmFtZSwgZmllbGQ6ICdkYXRhJ307XG59XG5cbmZ1bmN0aW9uIHZnX2xlZ2VuZFRpdGxlKGNvbmZpZykge1xuICB2YXIgY2ZnID0gY29uZmlnLmxlZ2VuZDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIGtleTogJ2RhdGEnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY2ZnLnRpdGxlQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNmZy50aXRsZUZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjZmcudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY2ZnLnRpdGxlRm9udFdlaWdodH0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICd0b3AnfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiAnZGF0YSd9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19sZWdlbmRTeW1ib2xzKGNvbmZpZykge1xuICB2YXIgY2ZnID0gY29uZmlnLmxlZ2VuZDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnc3ltYm9sJyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiAnZGF0YScsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge2ZpZWxkOiAnb2Zmc2V0JywgbXVsdDogMC41fSxcbiAgICAgICAgeToge3NjYWxlOiAnbGVnZW5kJywgZmllbGQ6ICdpbmRleCd9LFxuICAgICAgICBzaGFwZToge3ZhbHVlOiBjZmcuc3ltYm9sU2hhcGV9LFxuICAgICAgICBzaXplOiB7dmFsdWU6IGNmZy5zeW1ib2xTaXplfSxcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNmZy5zeW1ib2xDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNmZy5zeW1ib2xTdHJva2VXaWR0aH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB4OiB7ZmllbGQ6ICdvZmZzZXQnLCBtdWx0OiAwLjV9LFxuICAgICAgICB5OiB7c2NhbGU6ICdsZWdlbmQnLCBmaWVsZDogJ2luZGV4J30sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX3ZMZWdlbmRMYWJlbHMoY29uZmlnKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiAnZGF0YScsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge2ZpZWxkOiAnb2Zmc2V0Jywgb2Zmc2V0OiA1fSxcbiAgICAgICAgeToge3NjYWxlOiAnbGVnZW5kJywgZmllbGQ6ICdpbmRleCd9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNmZy5sYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjZmcubGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udFNpemV9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiBjZmcubGFiZWxBbGlnbn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IGNmZy5sYWJlbEJhc2VsaW5lfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiAnbGFiZWwnfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICAgIHg6IHtmaWVsZDogJ29mZnNldCcsIG9mZnNldDogNX0sXG4gICAgICAgIHk6IHtzY2FsZTogJ2xlZ2VuZCcsIGZpZWxkOiAnaW5kZXgnfSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2xlZ2VuZEdyYWRpZW50KGNvbmZpZykge1xuICB2YXIgY2ZnID0gY29uZmlnLmxlZ2VuZDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAncmVjdCcsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIHdpZHRoOiB7dmFsdWU6IGNmZy5ncmFkaWVudFdpZHRofSxcbiAgICAgICAgaGVpZ2h0OiB7dmFsdWU6IGNmZy5ncmFkaWVudEhlaWdodH0sXG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjZmcuZ3JhZGllbnRTdHJva2VDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNmZy5ncmFkaWVudFN0cm9rZVdpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2hMZWdlbmRMYWJlbHMoY29uZmlnKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiAnZGF0YScsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge3NjYWxlOiAnbGVnZW5kJywgZmllbGQ6ICdkYXRhJ30sXG4gICAgICAgIHk6IHt2YWx1ZTogMjB9LFxuICAgICAgICBkeToge3ZhbHVlOiAyfSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjZmcubGFiZWxDb2xvcn0sXG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNmZy5sYWJlbEZvbnRTaXplfSxcbiAgICAgICAgYWxpZ246IHtmaWVsZDogJ2FsaWduJ30sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICd0b3AnfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiAnbGFiZWwnfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtzY2FsZTogJ2xlZ2VuZCcsIGZpZWxkOiAnZGF0YSd9LFxuICAgICAgICB5OiB7dmFsdWU6IDIwfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsZ25kOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmlzaXQobm9kZSwgZnVuYykge1xuICB2YXIgaSwgbiwgcywgbSwgaXRlbXM7XG4gIGlmIChmdW5jKG5vZGUpKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgc2V0cyA9IFsnaXRlbXMnLCAnYXhpc0l0ZW1zJywgJ2xlZ2VuZEl0ZW1zJ107XG4gIGZvciAocz0wLCBtPXNldHMubGVuZ3RoOyBzPG07ICsrcykge1xuICAgIGlmICgoaXRlbXMgPSBub2RlW3NldHNbc11dKSkge1xuICAgICAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgICBpZiAodmlzaXQoaXRlbXNbaV0sIGZ1bmMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIENoYW5nZVNldCA9IGRmLkNoYW5nZVNldCxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXMsXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBGYWNldG9yID0gcmVxdWlyZSgnLi9GYWNldG9yJyk7XG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0ZShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG5cbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGdyb3VwYnk6IHt0eXBlOiAnYXJyYXk8ZmllbGQ+J30sXG4gICAgc3VtbWFyaXplOiB7XG4gICAgICB0eXBlOiAnY3VzdG9tJywgXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHN1bW1hcml6ZSkge1xuICAgICAgICB2YXIgc2lnbmFsRGVwcyA9IHt9LFxuICAgICAgICAgICAgdHggPSB0aGlzLl90cmFuc2Zvcm0sXG4gICAgICAgICAgICBpLCBsZW4sIGYsIGZpZWxkcywgbmFtZSwgb3BzO1xuXG4gICAgICAgIGlmICghZGwuaXNBcnJheShmaWVsZHMgPSBzdW1tYXJpemUpKSB7IC8vIE9iamVjdCBzeW50YXggZnJvbSBkbFxuICAgICAgICAgIGZpZWxkcyA9IFtdO1xuICAgICAgICAgIGZvciAobmFtZSBpbiBzdW1tYXJpemUpIHtcbiAgICAgICAgICAgIG9wcyA9IGRsLmFycmF5KHN1bW1hcml6ZVtuYW1lXSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaCh7ZmllbGQ6IG5hbWUsIG9wczogb3BzfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2coeCkgeyBpZiAoeC5zaWduYWwpIHNpZ25hbERlcHNbeC5zaWduYWxdID0gMTsgfVxuXG4gICAgICAgIGZvciAoaT0wLCBsZW49ZmllbGRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICAgIGYgPSBmaWVsZHNbaV07XG4gICAgICAgICAgaWYgKGYuZmllbGQuc2lnbmFsKSB7IHNpZ25hbERlcHNbZi5maWVsZC5zaWduYWxdID0gMTsgfVxuICAgICAgICAgIGRsLmFycmF5KGYub3BzKS5mb3JFYWNoKHNnKTtcbiAgICAgICAgICBkbC5hcnJheShmLmFzKS5mb3JFYWNoKHNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR4Ll9maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHR4Ll9hZ2dyID0gbnVsbDtcbiAgICAgICAgdHguZGVwZW5kZW5jeShEZXBzLlNJR05BTFMsIGRsLmtleXMoc2lnbmFsRGVwcykpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB0aGlzLl9hZ2dyICA9IG51bGw7IC8vIGRsLkFnZ3JlZ2F0b3JcbiAgdGhpcy5faW5wdXQgPSBudWxsOyAvLyBVc2VkIGJ5IEZhY2V0b3IuX29uX2tlZXAuXG4gIHRoaXMuX2FyZ3MgID0gbnVsbDsgLy8gVG8gY3VsbCByZS1jb21wdXRhdGlvbi5cbiAgdGhpcy5fZmllbGRzID0gW107XG4gIHRoaXMuX291dCA9IFtdO1xuXG4gIHRoaXMuX3R5cGUgPSBUWVBFUy5UVVBMRTsgXG4gIHRoaXMuX2FjYyA9IHtncm91cGJ5OiBkbC50cnVlLCB2YWx1ZTogZGwudHJ1ZX07XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpLnByb2R1Y2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEFnZ3JlZ2F0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFnZ3JlZ2F0ZTtcblxudmFyIFRZUEVTID0gQWdncmVnYXRlLlRZUEVTID0ge1xuICBWQUxVRTogMSwgXG4gIFRVUExFOiAyLCBcbiAgTVVMVEk6IDNcbn07XG5cbkFnZ3JlZ2F0ZS5WQUxJRF9PUFMgPSBbXG4gICd2YWx1ZXMnLCAnY291bnQnLCAndmFsaWQnLCAnbWlzc2luZycsICdkaXN0aW5jdCcsIFxuICAnc3VtJywgJ21lYW4nLCAnYXZlcmFnZScsICd2YXJpYW5jZScsICd2YXJpYW5jZXAnLCAnc3RkZXYnLCBcbiAgJ3N0ZGV2cCcsICdtZWRpYW4nLCAncTEnLCAncTMnLCAnbW9kZXNrZXcnLCAnbWluJywgJ21heCcsIFxuICAnYXJnbWluJywgJ2FyZ21heCdcbl07XG5cbnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSkgeyBcbiAgcmV0dXJuICh0aGlzLl90eXBlID0gdHlwZSwgdGhpcyk7IFxufTtcblxucHJvdG90eXBlLmFjY2Vzc29ycyA9IGZ1bmN0aW9uKGdyb3VwYnksIHZhbHVlKSB7XG4gIHZhciBhY2MgPSB0aGlzLl9hY2M7XG4gIGFjYy5ncm91cGJ5ID0gZGwuJChncm91cGJ5KSB8fCBkbC50cnVlO1xuICBhY2MudmFsdWUgPSBkbC4kKHZhbHVlKSB8fCBkbC50cnVlO1xufTtcblxucHJvdG90eXBlLmFnZ3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2FnZ3IpIHJldHVybiB0aGlzLl9hZ2dyO1xuXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBoYXNHZXR0ZXIgPSBmYWxzZSxcbiAgICAgIGFyZ3MgPSBbXSxcbiAgICAgIGdyb3VwYnkgPSB0aGlzLnBhcmFtKCdncm91cGJ5JykuZmllbGQsXG4gICAgICB2YWx1ZSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHguc2lnbmFsID8gZy5zaWduYWxSZWYoeC5zaWduYWwpIDogeDsgfTtcblxuICAvLyBQcmVwYXJlIHN1bW1hcml6ZSBmaWVsZHMuXG4gIHZhciBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgZmllbGQgPSB7XG4gICAgICBuYW1lOiB2YWx1ZShmLmZpZWxkKSxcbiAgICAgIGFzOiAgIGRsLmFycmF5KGYuYXMpLFxuICAgICAgb3BzOiAgZGwuYXJyYXkodmFsdWUoZi5vcHMpKS5tYXAodmFsdWUpLFxuICAgICAgZ2V0OiAgZi5nZXRcbiAgICB9O1xuICAgIGhhc0dldHRlciA9IGhhc0dldHRlciB8fCBmaWVsZC5nZXQgIT0gbnVsbDtcbiAgICBhcmdzLnB1c2goZmllbGQubmFtZSk7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9KTtcblxuICAvLyBJZiB0aGVyZSBpcyBhbiBhcmJpdHJhcnkgZ2V0dGVyLCBhbGwgYmV0cyBhcmUgb2ZmLlxuICAvLyBPdGhlcndpc2UsIHdlIGNhbiBjaGVjayBhcmd1bWVudCBmaWVsZHMgdG8gY3VsbCByZS1jb21wdXRhdGlvbi5cbiAgZ3JvdXBieS5mb3JFYWNoKGZ1bmN0aW9uKGcpIHtcbiAgICBpZiAoZy5nZXQpIGhhc0dldHRlciA9IHRydWU7XG4gICAgYXJncy5wdXNoKGcubmFtZSB8fCBnKTtcbiAgfSk7XG4gIHRoaXMuX2FyZ3MgPSBoYXNHZXR0ZXIgfHwgIWZpZWxkcy5sZW5ndGggPyBudWxsIDogYXJncztcblxuICBpZiAoIWZpZWxkcy5sZW5ndGgpIGZpZWxkcyA9IHsnKic6ICd2YWx1ZXMnfTtcblxuICAvLyBJbnN0YXRpYXRlIG91ciBhZ2dyZWdhdG9yIGluc3RhbmNlLlxuICAvLyBGYWNldG9yIGlzIGEgc3BlY2lhbCBzdWJjbGFzcyB0aGF0IGNhbiBmYWNldCBpbnRvIGRhdGEgcGlwZWxpbmVzLlxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IgPSBuZXcgRmFjZXRvcigpXG4gICAgLmdyb3VwYnkoZ3JvdXBieSlcbiAgICAuc3RyZWFtKHRydWUpXG4gICAgLnN1bW1hcml6ZShmaWVsZHMpO1xuXG4gIC8vIENvbGxlY3Qgb3V0cHV0IGZpZWxkcyBzZXRzIGJ5IHRoaXMgYWdncmVnYXRlLlxuICB0aGlzLl9vdXQgPSBnZXRGaWVsZHMoYWdncik7XG5cbiAgLy8gSWYgd2UgYXJlIHByb2Nlc3NpbmcgdHVwbGVzLCBrZXkgdGhlbSBieSAnX2lkJy5cbiAgaWYgKHRoaXMuX3R5cGUgIT09IFRZUEVTLlZBTFVFKSB7IGFnZ3Iua2V5KCdfaWQnKTsgfVxuXG4gIHJldHVybiBhZ2dyO1xufTtcblxuZnVuY3Rpb24gZ2V0RmllbGRzKGFnZ3IpIHtcbiAgLy8gQ29sbGVjdCB0aGUgb3V0cHV0IGZpZWxkcyBzZXQgYnkgdGhpcyBhZ2dyZWdhdGUuXG4gIHZhciBmID0gW10sIGksIG4sIGosIG0sIGRpbXMsIHZhbHMsIG1lYXM7XG5cbiAgZGltcyA9IGFnZ3IuX2RpbXM7XG4gIGZvciAoaT0wLCBuPWRpbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGYucHVzaChkaW1zW2ldLm5hbWUpO1xuICB9XG5cbiAgdmFscyA9IGFnZ3IuX2FnZ3I7XG4gIGZvciAoaT0wLCBuPXZhbHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG1lYXMgPSB2YWxzW2ldLm1lYXN1cmVzLmZpZWxkcztcbiAgICBmb3IgKGo9MCwgbT1tZWFzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGYucHVzaChtZWFzW2pdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZjtcbn1cblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnYWdncmVnYXRlJ10pO1xuICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBVc2VkIGJ5IEZhY2V0b3IuX29uX2tlZXAuXG5cbiAgdmFyIG91dHB1dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgYWdnciA9IHRoaXMuYWdncigpLFxuICAgICAgb3V0ID0gdGhpcy5fb3V0LFxuICAgICAgYXJncyA9IHRoaXMuX2FyZ3MsXG4gICAgICByZWV2YWwgPSB0cnVlLFxuICAgICAgcCA9IFR1cGxlLnByZXYsXG4gICAgICBhZGQsIHJlbSwgbW9kLCBpO1xuXG4gIC8vIFVwb24gcmVzZXQsIHJldHJhY3QgcHJpb3IgdHVwbGVzIGFuZCByZS1pbml0aWFsaXplLlxuICBpZiAocmVzZXQpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgYWdnci5yZXN1bHQoKSk7XG4gICAgYWdnci5jbGVhcigpO1xuICAgIHRoaXMuX2FnZ3IgPSBudWxsO1xuICAgIGFnZ3IgPSB0aGlzLmFnZ3IoKTtcbiAgfVxuXG4gIC8vIEdldCB1cGRhdGUgbWV0aG9kcyBhY2NvcmRpbmcgdG8gaW5wdXQgdHlwZS5cbiAgaWYgKHRoaXMuX3R5cGUgPT09IFRZUEVTLlRVUExFKSB7XG4gICAgYWRkID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9hZGQoeCk7IFR1cGxlLnByZXZfaW5pdCh4KTsgfTtcbiAgICByZW0gPSBmdW5jdGlvbih4KSB7IGFnZ3IuX3JlbShwKHgpKTsgfTtcbiAgICBtb2QgPSBmdW5jdGlvbih4KSB7IGFnZ3IuX21vZCh4LCBwKHgpKTsgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2J5ID0gdGhpcy5fYWNjLmdyb3VwYnksXG4gICAgICAgIHZhbCA9IHRoaXMuX2FjYy52YWx1ZSxcbiAgICAgICAgZ2V0ID0gdGhpcy5fdHlwZSA9PT0gVFlQRVMuVkFMVUUgPyB2YWwgOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgX2lkOiB4Ll9pZCwgZ3JvdXBieTogZ2J5KHgpLCB2YWx1ZTogdmFsKHgpIH07XG4gICAgICAgIH07XG4gICAgYWRkID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9hZGQoZ2V0KHgpKTsgVHVwbGUucHJldl9pbml0KHgpOyB9O1xuICAgIHJlbSA9IGZ1bmN0aW9uKHgpIHsgYWdnci5fcmVtKGdldChwKHgpKSk7IH07XG4gICAgbW9kID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9tb2QoZ2V0KHgpLCBnZXQocCh4KSkpOyB9O1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goYWRkKTtcbiAgaWYgKHJlc2V0KSB7XG4gICAgLy8gQSBzaWduYWwgY2hhbmdlIHRyaWdnZXJlZCByZWZsb3cuIEFkZCBldmVyeXRoaW5nLlxuICAgIC8vIE5vIG5lZWQgZm9yIHJlbSwgd2UgY2xlYXJlZCB0aGUgYWdncmVnYXRvci5cbiAgICBpbnB1dC5tb2QuZm9yRWFjaChhZGQpO1xuICB9IGVsc2Uge1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHJlbSk7XG5cbiAgICAvLyBJZiBwb3NzaWJsZSwgY2hlY2sgYXJndW1lbnQgZmllbGRzIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlLXByb2Nlc3MgbW9kcy5cbiAgICBpZiAoYXJncykgZm9yIChpPTAsIHJlZXZhbD1mYWxzZTsgaTxhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaW5wdXQuZmllbGRzW2FyZ3NbaV1dKSB7IHJlZXZhbCA9IHRydWU7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChyZWV2YWwpIGlucHV0Lm1vZC5mb3JFYWNoKG1vZCk7XG4gIH1cblxuICAvLyBJbmRpY2F0ZSBvdXRwdXQgZmllbGRzIGFuZCByZXR1cm4gYWdncmVnYXRlIHR1cGxlcy5cbiAgZm9yIChpPTA7IGk8b3V0Lmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0LmZpZWxkc1tvdXRbaV1dID0gMTtcbiAgfVxuICByZXR1cm4gYWdnci5jaGFuZ2VzKG91dHB1dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTsiLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJykucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBCYXRjaFRyYW5zZm9ybSgpIHtcbiAgLy8gTmVhcmVzdCBhcHByb3ByaWF0ZSBjb2xsZWN0b3IuIFxuICAvLyBTZXQgYnkgdGhlIGRhdGFmbG93IEdyYXBoIGR1cmluZyBjb25uZWN0aW9uLlxuICB0aGlzLl9jb2xsZWN0b3IgPSBudWxsOyBcbn1cblxudmFyIHByb3RvdHlwZSA9IChCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhdGNoVHJhbnNmb3JtO1xuXG5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIEJhc2UuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgcmV0dXJuIHRoaXMuYmF0Y2godHJ1ZSk7XG59O1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuYmF0Y2hUcmFuc2Zvcm0oaW5wdXQsIHRoaXMuX2NvbGxlY3Rvci5kYXRhKCkpO1xufTtcblxucHJvdG90eXBlLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oLyogaW5wdXQsIGRhdGEgKi8pIHtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmF0Y2hUcmFuc2Zvcm07IiwidmFyIGJpbnMgPSByZXF1aXJlKCdkYXRhbGliJykuYmlucyxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBCaW4oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiAnZmllbGQnfSxcbiAgICBtaW46IHt0eXBlOiAndmFsdWUnfSxcbiAgICBtYXg6IHt0eXBlOiAndmFsdWUnfSxcbiAgICBiYXNlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMTB9LFxuICAgIG1heGJpbnM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAyMH0sXG4gICAgc3RlcDoge3R5cGU6ICd2YWx1ZSd9LFxuICAgIHN0ZXBzOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgbWluc3RlcDoge3R5cGU6ICd2YWx1ZSd9LFxuICAgIGRpdjoge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbNSwgMl19XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtiaW46ICdiaW4nfTtcbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChCaW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaW47XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnYmlubmluZyddKTtcblxuICB2YXIgb3V0cHV0ICA9IHRoaXMuX291dHB1dC5iaW4sXG4gICAgICBzdGVwICAgID0gdGhpcy5wYXJhbSgnc3RlcCcpLFxuICAgICAgc3RlcHMgICA9IHRoaXMucGFyYW0oJ3N0ZXBzJyksXG4gICAgICBtaW5zdGVwID0gdGhpcy5wYXJhbSgnbWluc3RlcCcpLFxuICAgICAgZ2V0ICAgICA9IHRoaXMucGFyYW0oJ2ZpZWxkJykuYWNjZXNzb3IsXG4gICAgICBvcHQgPSB7XG4gICAgICAgIG1pbjogdGhpcy5wYXJhbSgnbWluJyksXG4gICAgICAgIG1heDogdGhpcy5wYXJhbSgnbWF4JyksXG4gICAgICAgIGJhc2U6IHRoaXMucGFyYW0oJ2Jhc2UnKSxcbiAgICAgICAgbWF4YmluczogdGhpcy5wYXJhbSgnbWF4YmlucycpLFxuICAgICAgICBkaXY6IHRoaXMucGFyYW0oJ2RpdicpXG4gICAgICB9O1xuXG4gIGlmIChzdGVwKSBvcHQuc3RlcCA9IHN0ZXA7XG4gIGlmIChzdGVwcykgb3B0LnN0ZXBzID0gc3RlcHM7XG4gIGlmIChtaW5zdGVwKSBvcHQubWluc3RlcCA9IG1pbnN0ZXA7XG4gIHZhciBiID0gYmlucyhvcHQpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShkKSB7XG4gICAgdmFyIHYgPSBnZXQoZCk7XG4gICAgdiA9IHYgPT0gbnVsbCA/IG51bGxcbiAgICAgIDogYi5zdGFydCArIGIuc3RlcCAqIH5+KCh2IC0gYi5zdGFydCkgLyBiLnN0ZXApO1xuICAgIFR1cGxlLnNldChkLCBvdXRwdXQsIHYpO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpbjsiLCJ2YXIgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgVHVwbGUgPSBkZi5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBDb3VudFBhdHRlcm4oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6ICAgICB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ2RhdGEnfSxcbiAgICBwYXR0ZXJuOiAgIHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnW1xcXFx3XFwnXSsnfSxcbiAgICBjYXNlOiAgICAgIHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnbG93ZXInfSxcbiAgICBzdG9wd29yZHM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnJ31cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge3RleHQ6ICd0ZXh0JywgY291bnQ6ICdjb3VudCd9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5wcm9kdWNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChDb3VudFBhdHRlcm4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb3VudFBhdHRlcm47XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2NvdW50cGF0dGVybiddKTtcblxuICB2YXIgZ2V0ID0gdGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvcixcbiAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcmFtKCdwYXR0ZXJuJyksXG4gICAgICBzdG9wID0gdGhpcy5wYXJhbSgnc3RvcHdvcmRzJyksXG4gICAgICByZW0gPSBmYWxzZTtcblxuICAvLyB1cGRhdGUgcGFyYW1ldGVyc1xuICBpZiAodGhpcy5fc3RvcCAhPT0gc3RvcCkge1xuICAgIHRoaXMuX3N0b3AgPSBzdG9wO1xuICAgIHRoaXMuX3N0b3BfcmUgPSBuZXcgUmVnRXhwKCdeJyArIHN0b3AgKyAnJCcsICdpJyk7XG4gICAgcmVzZXQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3BhdHRlcm4gIT09IHBhdHRlcm4pIHtcbiAgICB0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLl9tYXRjaCA9IG5ldyBSZWdFeHAodGhpcy5fcGF0dGVybiwgJ2cnKTtcbiAgICByZXNldCA9IHRydWU7XG4gIH1cblxuICBpZiAocmVzZXQpIHRoaXMuX2NvdW50cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGN1cnIodCkgeyByZXR1cm4gKFR1cGxlLnByZXZfaW5pdCh0KSwgZ2V0KHQpKTsgfVxuICBmdW5jdGlvbiBwcmV2KHQpIHsgcmV0dXJuIGdldChUdXBsZS5wcmV2KHQpKTsgfVxuXG4gIHRoaXMuX2FkZChpbnB1dC5hZGQsIGN1cnIpO1xuICBpZiAoIXJlc2V0KSB0aGlzLl9yZW0oaW5wdXQucmVtLCBwcmV2KTtcbiAgaWYgKHJlc2V0IHx8IChyZW0gPSBpbnB1dC5maWVsZHNbZ2V0LmZpZWxkXSkpIHtcbiAgICBpZiAocmVtKSB0aGlzLl9yZW0oaW5wdXQubW9kLCBwcmV2KTtcbiAgICB0aGlzLl9hZGQoaW5wdXQubW9kLCBjdXJyKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIG91dHB1dCB0dXBsZXNcbiAgcmV0dXJuIHRoaXMuX2NoYW5nZXNldChpbnB1dCk7XG59O1xuXG5wcm90b3R5cGUuX2NoYW5nZXNldCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBjb3VudHMgPSB0aGlzLl9jb3VudHMsXG4gICAgICB0dXBsZXMgPSB0aGlzLl90dXBsZXMgfHwgKHRoaXMuX3R1cGxlcyA9IHt9KSxcbiAgICAgIGNoYW5nZSA9IGRmLkNoYW5nZVNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgb3V0ID0gdGhpcy5fb3V0cHV0LCB3LCB0LCBjO1xuXG4gIGZvciAodyBpbiBjb3VudHMpIHtcbiAgICB0ID0gdHVwbGVzW3ddO1xuICAgIGMgPSBjb3VudHNbd10gfHwgMDtcbiAgICBpZiAoIXQgJiYgYykge1xuICAgICAgdHVwbGVzW3ddID0gKHQgPSBUdXBsZS5pbmdlc3Qoe30pKTtcbiAgICAgIHRbb3V0LnRleHRdID0gdztcbiAgICAgIHRbb3V0LmNvdW50XSA9IGM7XG4gICAgICBjaGFuZ2UuYWRkLnB1c2godCk7XG4gICAgfSBlbHNlIGlmIChjID09PSAwKSB7XG4gICAgICBpZiAodCkgY2hhbmdlLnJlbS5wdXNoKHQpO1xuICAgICAgZGVsZXRlIGNvdW50c1t3XTtcbiAgICAgIGRlbGV0ZSB0dXBsZXNbd107XG4gICAgfSBlbHNlIGlmICh0W291dC5jb3VudF0gIT09IGMpIHtcbiAgICAgIFR1cGxlLnNldCh0LCBvdXQuY291bnQsIGMpO1xuICAgICAgY2hhbmdlLm1vZC5wdXNoKHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlO1xufTtcblxucHJvdG90eXBlLl90b2tlbml6ZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgc3dpdGNoICh0aGlzLnBhcmFtKCdjYXNlJykpIHtcbiAgICBjYXNlICd1cHBlcic6IHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuICAgIGNhc2UgJ2xvd2VyJzogdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRleHQubWF0Y2godGhpcy5fbWF0Y2gpO1xufTtcblxucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbih0dXBsZXMsIGdldCkge1xuICB2YXIgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgc3RvcCA9IHRoaXMuX3N0b3BfcmUsXG4gICAgICB0b2ssIGksIGosIHQ7XG5cbiAgZm9yIChqPTA7IGo8dHVwbGVzLmxlbmd0aDsgKytqKSB7XG4gICAgdG9rID0gdGhpcy5fdG9rZW5pemUoZ2V0KHR1cGxlc1tqXSkpO1xuICAgIGZvciAoaT0wOyBpPHRvay5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFzdG9wLnRlc3QodD10b2tbaV0pKSB7XG4gICAgICAgIGNvdW50c1t0XSA9IDEgKyAoY291bnRzW3RdIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxucHJvdG90eXBlLl9yZW0gPSBmdW5jdGlvbih0dXBsZXMsIGdldCkge1xuICB2YXIgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgc3RvcCA9IHRoaXMuX3N0b3BfcmUsXG4gICAgICB0b2ssIGksIGosIHQ7XG5cbiAgZm9yIChqPTA7IGo8dHVwbGVzLmxlbmd0aDsgKytqKSB7XG4gICAgdG9rID0gdGhpcy5fdG9rZW5pemUoZ2V0KHR1cGxlc1tqXSkpO1xuICAgIGZvciAoaT0wOyBpPHRvay5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFzdG9wLnRlc3QodD10b2tbaV0pKSB7XG4gICAgICAgIGNvdW50c1t0XSAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3VudFBhdHRlcm47IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIENoYW5nZVNldCA9IGRmLkNoYW5nZVNldCxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIFNJR05BTFMgPSBkZi5EZXBlbmRlbmNpZXMuU0lHTkFMUyxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBDcm9zcyhncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiAnZGF0YSd9LFxuICAgIGRpYWdvbmFsOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ3RydWUnfSxcbiAgICBmaWx0ZXI6IHt0eXBlOiAnZXhwcid9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHsnbGVmdCc6ICdhJywgJ3JpZ2h0JzogJ2InfTtcbiAgdGhpcy5fbGFzdFJlbSAgPSBudWxsOyAvLyBNb3N0IHJlY2VudCBzdGFtcCB0aGF0IHJlbSBvY2N1cmVkLiBcbiAgdGhpcy5fbGFzdFdpdGggPSBudWxsOyAvLyBMYXN0IHRpbWUgd2UgY3Jvc3NlZCB3L3dpdGhkcy5cbiAgdGhpcy5faWRzICAgPSB7fTtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcblxuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSkucHJvZHVjZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoQ3Jvc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENyb3NzO1xuXG4vLyBFYWNoIGNhY2hlZCBpbmNvbWluZyB0dXBsZSBhbHNvIGhhcyBhIHN0YW1wIHRvIHRyYWNrIGlmIHdlIG5lZWQgdG8gZG9cbi8vIGxhenkgZmlsdGVyaW5nIG9mIHJlbW92ZWQgdHVwbGVzLlxuZnVuY3Rpb24gY2FjaGUoeCwgdCkge1xuICB2YXIgYyA9IHRoaXMuX2NhY2hlW3guX2lkXSA9IHRoaXMuX2NhY2hlW3guX2lkXSB8fCB7YzogW10sIHM6IHRoaXMuX3N0YW1wfTtcbiAgYy5jLnB1c2godCk7XG59XG5cbmZ1bmN0aW9uIGFkZChvdXRwdXQsIGxlZnQsIGRhdGEsIGRpYWcsIHRlc3QsIHgpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aCwgdCA9IHt9LCB5LCBpZDtcblxuICBmb3IgKDsgaTxsZW47ICsraSkge1xuICAgIHkgPSBkYXRhW2ldO1xuICAgIGlkID0gbGVmdCA/IHguX2lkKydfJyt5Ll9pZCA6IHkuX2lkKydfJyt4Ll9pZDtcbiAgICBpZiAodGhpcy5faWRzW2lkXSkgY29udGludWU7XG4gICAgaWYgKHguX2lkID09IHkuX2lkICYmICFkaWFnKSBjb250aW51ZTtcblxuICAgIHRbdGhpcy5fb3V0cHV0LmxlZnRdICA9IGxlZnQgPyB4IDogeTtcbiAgICB0W3RoaXMuX291dHB1dC5yaWdodF0gPSBsZWZ0ID8geSA6IHg7XG5cbiAgICAvLyBPbmx5IGluZ2VzdCBhIHR1cGxlIGlmIHdlIGtlZXAgaXQgYXJvdW5kLlxuICAgIGlmICghdGVzdCB8fCB0ZXN0KHQpKSB7XG4gICAgICBvdXRwdXQuYWRkLnB1c2godD1UdXBsZS5pbmdlc3QodCkpO1xuICAgICAgY2FjaGUuY2FsbCh0aGlzLCB4LCB0KTtcbiAgICAgIGNhY2hlLmNhbGwodGhpcywgeSwgdCk7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gMTtcbiAgICAgIHQgPSB7fTtcbiAgICB9ICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIG1vZChvdXRwdXQsIGxlZnQsIHgpIHtcbiAgdmFyIGNyb3NzID0gdGhpcyxcbiAgICAgIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF07XG5cbiAgaWYgKHRoaXMuX2xhc3RSZW0gPiBjLnMpIHsgIC8vIFJlbW92ZWQgdHVwbGVzIGhhdmVuJ3QgYmVlbiBmaWx0ZXJlZCB5ZXRcbiAgICBjLmMgPSBjLmMuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciB0ID0geVtjcm9zcy5fb3V0cHV0W2xlZnQgPyAncmlnaHQnIDogJ2xlZnQnXV07XG4gICAgICByZXR1cm4gY3Jvc3MuX2NhY2hlW3QuX2lkXSAhPT0gbnVsbDtcbiAgICB9KTtcbiAgICBjLnMgPSB0aGlzLl9sYXN0UmVtO1xuICB9XG5cbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGMuYyk7XG59XG5cbmZ1bmN0aW9uIHJlbShvdXRwdXQsIHgpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW3guX2lkXS5jKTtcbiAgdGhpcy5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgdGhpcy5fbGFzdFJlbSA9IHRoaXMuX3N0YW1wO1xufVxuXG5mdW5jdGlvbiB1cEZpZWxkcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5sZWZ0XSAgPSAxOyBcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5yaWdodF0gPSAxO1xuICB9XG59XG5cbnByb3RvdHlwZS5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydjcm9zc2luZyddKTtcblxuICB2YXIgdyA9IHRoaXMucGFyYW0oJ3dpdGgnKSxcbiAgICAgIGYgPSB0aGlzLnBhcmFtKCdmaWx0ZXInKSxcbiAgICAgIGRpYWcgPSB0aGlzLnBhcmFtKCdkaWFnb25hbCcpLFxuICAgICAgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHNpZ25hbHMgPSBncmFwaC52YWx1ZXMoU0lHTkFMUywgdGhpcy5kZXBlbmRlbmN5KFNJR05BTFMpKSxcbiAgICAgIHRlc3QgPSBmID8gZnVuY3Rpb24oeCkge3JldHVybiBmKHgsIG51bGwsIHNpZ25hbHMpOyB9IDogbnVsbCxcbiAgICAgIHNlbGZDcm9zcyA9ICghdy5uYW1lKSxcbiAgICAgIHdvdXRwdXQgPSBzZWxmQ3Jvc3MgPyBpbnB1dCA6IHcuc291cmNlLmxhc3QoKSxcbiAgICAgIHdkYXRhICAgPSBzZWxmQ3Jvc3MgPyBkYXRhIDogdy5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvdXRwdXQgID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICByID0gcmVtLmJpbmQodGhpcywgb3V0cHV0KTtcblxuICBpbnB1dC5yZW0uZm9yRWFjaChyKTtcbiAgaW5wdXQuYWRkLmZvckVhY2goYWRkLmJpbmQodGhpcywgb3V0cHV0LCB0cnVlLCB3ZGF0YSwgZGlhZywgdGVzdCkpO1xuXG4gIGlmICghc2VsZkNyb3NzICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0V2l0aCkge1xuICAgIHdvdXRwdXQucmVtLmZvckVhY2gocik7XG4gICAgd291dHB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlLCBkYXRhLCBkaWFnLCB0ZXN0KSk7XG4gICAgd291dHB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlKSk7XG4gICAgdXBGaWVsZHMuY2FsbCh0aGlzLCB3b3V0cHV0LCBvdXRwdXQpO1xuICAgIHRoaXMuX2xhc3RXaXRoID0gd291dHB1dC5zdGFtcDtcbiAgfVxuXG4gIC8vIE1vZHMgbmVlZCB0byBjb21lIGFmdGVyIGFsbCByZW1vdmFscyBoYXZlIGJlZW4gcnVuLlxuICBpbnB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUpKTtcbiAgdXBGaWVsZHMuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcm9zczsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBBZ2dyZWdhdGUgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0ZScpO1xuXG5mdW5jdGlvbiBGYWNldChncmFwaCkge1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgc2V0OiBmdW5jdGlvbihwaXBlbGluZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3RyYW5zZm9ybS5fcGlwZWxpbmUgPSBwaXBlbGluZSwgdGhpcy5fdHJhbnNmb3JtKTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZS90cmFuc2Zvcm1zJyksXG4gICAgICAgICAgICBmYWNldCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICAgICAgcmV0dXJuIGZhY2V0Ll9waXBlbGluZS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZShmYWNldC5fZ3JhcGgsIHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gICAgICBcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuX3BpcGVsaW5lID0gW107XG4gIHJldHVybiBBZ2dyZWdhdGUuY2FsbCh0aGlzLCBncmFwaCk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoRmFjZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBZ2dyZWdhdGUucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGYWNldDtcblxucHJvdG90eXBlLmFnZ3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWdnci5jYWxsKHRoaXMpLmZhY2V0KHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQWdncmVnYXRvciA9IGRsLkFnZ3JlZ2F0b3IsXG4gICAgQmFzZSA9IEFnZ3JlZ2F0b3IucHJvdG90eXBlLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgZmFjZXRJRCA9IDA7XG5cbmZ1bmN0aW9uIEZhY2V0b3IoKSB7XG4gIEFnZ3JlZ2F0b3IuY2FsbCh0aGlzKTtcbiAgdGhpcy5fZmFjZXQgPSBudWxsO1xuICB0aGlzLl9mYWNldElEID0gKytmYWNldElEO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEZhY2V0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGYWNldG9yO1xuXG5wcm90b3R5cGUuZmFjZXQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX2ZhY2V0ID0gZiwgdGhpcykgOiB0aGlzLl9mYWNldDtcbn07XG5cbnByb3RvdHlwZS5faW5nZXN0ID0gZnVuY3Rpb24odCkgeyBcbiAgcmV0dXJuIFR1cGxlLmluZ2VzdCh0LCBudWxsKTtcbn07XG5cbnByb3RvdHlwZS5fYXNzaWduID0gVHVwbGUuc2V0O1xuXG5mdW5jdGlvbiBkaXNjb25uZWN0X2NlbGwoZmFjZXQpIHtcbiAgbG9nLmRlYnVnKHt9LCBbJ2Rpc2Nvbm5lY3RpbmcgY2VsbCcsIHRoaXMudHVwbGUuX2lkXSk7XG4gIHZhciBwaXBlbGluZSA9IHRoaXMuZHMucGlwZWxpbmUoKTtcbiAgZmFjZXQucmVtb3ZlTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuICBmYWNldC5fZ3JhcGgucmVtb3ZlTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuICBmYWNldC5fZ3JhcGguZGlzY29ubmVjdChwaXBlbGluZSk7XG59XG5cbnByb3RvdHlwZS5fbmV3Y2VsbCA9IGZ1bmN0aW9uKHgsIGtleSkge1xuICB2YXIgY2VsbCAgPSBCYXNlLl9uZXdjZWxsLmNhbGwodGhpcywgeCwga2V5KSxcbiAgICAgIGZhY2V0ID0gdGhpcy5fZmFjZXQ7XG5cbiAgaWYgKGZhY2V0KSB7XG4gICAgdmFyIGdyYXBoID0gZmFjZXQuX2dyYXBoLFxuICAgICAgICB0dXBsZSA9IGNlbGwudHVwbGUsXG4gICAgICAgIHBpcGVsaW5lID0gZmFjZXQucGFyYW0oJ3RyYW5zZm9ybScpO1xuICAgIGNlbGwuZHMgPSBncmFwaC5kYXRhKHR1cGxlLl9mYWNldElELCBwaXBlbGluZSwgdHVwbGUpO1xuICAgIGNlbGwuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3RfY2VsbDtcbiAgICBmYWNldC5hZGRMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gIH1cblxuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvdHlwZS5fbmV3dHVwbGUgPSBmdW5jdGlvbih4LCBrZXkpIHtcbiAgdmFyIHQgPSBCYXNlLl9uZXd0dXBsZS5jYWxsKHRoaXMsIHgpO1xuICBpZiAodGhpcy5fZmFjZXQpIHtcbiAgICBUdXBsZS5zZXQodCwgJ2tleScsIGtleSk7XG4gICAgVHVwbGUuc2V0KHQsICdfZmFjZXRJRCcsIHRoaXMuX2ZhY2V0SUQgKyAnXycgKyBrZXkpO1xuICB9XG4gIHJldHVybiB0O1xufTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYWNldCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICAgIHRoaXMuX2NlbGxzW2tdLmRpc2Nvbm5lY3QodGhpcy5fZmFjZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQmFzZS5jbGVhci5jYWxsKHRoaXMpO1xufTtcblxucHJvdG90eXBlLl9vbl9hZGQgPSBmdW5jdGlvbih4LCBjZWxsKSB7XG4gIGlmICh0aGlzLl9mYWNldCkgY2VsbC5kcy5faW5wdXQuYWRkLnB1c2goeCk7XG59O1xuXG5wcm90b3R5cGUuX29uX3JlbSA9IGZ1bmN0aW9uKHgsIGNlbGwpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSBjZWxsLmRzLl9pbnB1dC5yZW0ucHVzaCh4KTtcbn07XG5cbnByb3RvdHlwZS5fb25fbW9kID0gZnVuY3Rpb24oeCwgcHJldiwgY2VsbDAsIGNlbGwxKSB7XG4gIGlmICh0aGlzLl9mYWNldCkgeyAvLyBQcm9wYWdhdGUgdHVwbGVzXG4gICAgaWYgKGNlbGwwID09PSBjZWxsMSkge1xuICAgICAgY2VsbDAuZHMuX2lucHV0Lm1vZC5wdXNoKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsMC5kcy5faW5wdXQucmVtLnB1c2goeCk7XG4gICAgICBjZWxsMS5kcy5faW5wdXQuYWRkLnB1c2goeCk7XG4gICAgfVxuICB9XG59O1xuXG5wcm90b3R5cGUuX29uX2Ryb3AgPSBmdW5jdGlvbihjZWxsKSB7XG4gIGlmICh0aGlzLl9mYWNldCkgY2VsbC5kaXNjb25uZWN0KHRoaXMuX2ZhY2V0KTtcbn07XG5cbnByb3RvdHlwZS5fb25fa2VlcCA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgLy8gcHJvcGFnYXRlIHNvcnQsIHNpZ25hbHMsIGZpZWxkcywgZXRjLlxuICBpZiAodGhpcy5fZmFjZXQpIGRmLkNoYW5nZVNldC5jb3B5KHRoaXMuX2lucHV0LCBjZWxsLmRzLl9pbnB1dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0b3I7IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIFNJR05BTFMgPSBkZi5EZXBlbmRlbmNpZXMuU0lHTkFMUyxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBGaWx0ZXIoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7dGVzdDoge3R5cGU6ICdleHByJ319KTtcblxuICB0aGlzLl9za2lwID0ge307XG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWx0ZXI7XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnZmlsdGVyaW5nJ10pO1xuXG4gIHZhciBvdXRwdXQgPSBkZi5DaGFuZ2VTZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBza2lwID0gdGhpcy5fc2tpcCxcbiAgICAgIHRlc3QgPSB0aGlzLnBhcmFtKCd0ZXN0JyksXG4gICAgICBzaWduYWxzID0gZ3JhcGgudmFsdWVzKFNJR05BTFMsIHRoaXMuZGVwZW5kZW5jeShTSUdOQUxTKSk7XG5cbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmIChza2lwW3guX2lkXSAhPT0gMSkgb3V0cHV0LnJlbS5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAwO1xuICB9KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYgKHRlc3QoeCwgbnVsbCwgc2lnbmFscykpIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMTtcbiAgfSk7XG5cbiAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBiID0gdGVzdCh4LCBudWxsLCBzaWduYWxzKSxcbiAgICAgICAgcyA9IChza2lwW3guX2lkXSA9PT0gMSk7XG4gICAgaWYgKGIgJiYgcykge1xuICAgICAgc2tpcFt4Ll9pZF0gPSAwO1xuICAgICAgb3V0cHV0LmFkZC5wdXNoKHgpO1xuICAgIH0gZWxzZSBpZiAoYiAmJiAhcykge1xuICAgICAgb3V0cHV0Lm1vZC5wdXNoKHgpO1xuICAgIH0gZWxzZSBpZiAoIWIgJiYgcykge1xuICAgICAgLy8gZG8gbm90aGluZywga2VlcCBza2lwIHRydWVcbiAgICB9IGVsc2UgeyAvLyAhYiAmJiAhc1xuICAgICAgb3V0cHV0LnJlbS5wdXNoKHgpO1xuICAgICAgc2tpcFt4Ll9pZF0gPSAxO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyOyIsInZhciBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEZvbGQoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGRzOiB7dHlwZTogJ2FycmF5PGZpZWxkPid9IFxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7a2V5OiAna2V5JywgdmFsdWU6ICd2YWx1ZSd9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5wcm9kdWNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChGb2xkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9sZDtcblxucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHsgXG4gIGZvciAodmFyIGlkIGluIHRoaXMuX2NhY2hlKSB7XG4gICAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW2lkXSk7XG4gIH1cbiAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG5cbnByb3RvdHlwZS5fdHVwbGUgPSBmdW5jdGlvbih4LCBpLCBsZW4pIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwgKHRoaXMuX2NhY2hlW3guX2lkXSA9IEFycmF5KGxlbikpO1xuICByZXR1cm4gbGlzdFtpXSA/IFR1cGxlLnJlZGVyaXZlKHgsIGxpc3RbaV0pIDogKGxpc3RbaV0gPSBUdXBsZS5kZXJpdmUoeCkpO1xufTtcblxucHJvdG90eXBlLl9mbiA9IGZ1bmN0aW9uKGRhdGEsIG9uLCBvdXQpIHtcbiAgdmFyIGksIGosIG4sIG0sIGQsIHQ7XG4gIGZvciAoaT0wLCBuPWRhdGEubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wLCBtPW9uLmZpZWxkLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHQgPSB0aGlzLl90dXBsZShkLCBqLCBtKTsgIFxuICAgICAgVHVwbGUuc2V0KHQsIHRoaXMuX291dHB1dC5rZXksIG9uLmZpZWxkW2pdKTtcbiAgICAgIFR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQudmFsdWUsIG9uLmFjY2Vzc29yW2pdKGQpKTtcbiAgICAgIG91dC5wdXNoKHQpO1xuICAgIH0gICAgICBcbiAgfVxufTtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnZm9sZGluZyddKTtcblxuICB2YXIgZm9sZCA9IHRoaXMsXG4gICAgICBvbiA9IHRoaXMucGFyYW0oJ2ZpZWxkcycpLFxuICAgICAgb3V0cHV0ID0gZGYuQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgaWYgKHJlc2V0KSB0aGlzLl9yZXNldChpbnB1dCwgb3V0cHV0KTtcblxuICB0aGlzLl9mbihpbnB1dC5hZGQsIG9uLCBvdXRwdXQuYWRkKTtcbiAgdGhpcy5fZm4oaW5wdXQubW9kLCBvbiwgcmVzZXQgPyBvdXRwdXQuYWRkIDogb3V0cHV0Lm1vZCk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgZm9sZC5fY2FjaGVbeC5faWRdKTtcbiAgICBmb2xkLl9jYWNoZVt4Ll9pZF0gPSBudWxsO1xuICB9KTtcblxuICAvLyBJZiB3ZSdyZSBvbmx5IHByb3BhZ2F0aW5nIHZhbHVlcywgZG9uJ3QgbWFyayBrZXkvdmFsdWUgYXMgdXBkYXRlZC5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCB8fCBcbiAgICAgIG9uLmZpZWxkLnNvbWUoZnVuY3Rpb24oZikgeyByZXR1cm4gISFpbnB1dC5maWVsZHNbZl07IH0pKSB7XG4gICAgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQua2V5XSA9IDE7XG4gICAgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQudmFsdWVdID0gMTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb2xkOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgQ2hhbmdlU2V0ID0gZGYuQ2hhbmdlU2V0LFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEZvcmNlKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcblxuICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgdGhpcy5faW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fc2V0dXAgPSB0cnVlO1xuICB0aGlzLl9ub2RlcyAgPSBbXTtcbiAgdGhpcy5fbGlua3MgPSBbXTtcbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LmZvcmNlKCk7XG5cbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHNpemU6IHt0eXBlOiAnYXJyYXk8dmFsdWU+JywgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgYm91bmQ6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiB0cnVlfSxcbiAgICBsaW5rczoge3R5cGU6ICdkYXRhJ30sXG5cbiAgICAvLyBUT0RPOiBmb3Igbm93IGZvcmNlIHRoZXNlIHRvIGJlIHZhbHVlIHBhcmFtcyBvbmx5IChwdW4taW50ZW5kZWQpXG4gICAgLy8gQ2FuIHVwZGF0ZSB0byBpbmNsdWRlIGZpZWxkcyBhZnRlciBQYXJhbWV0ZXIgcmVmYWN0b3JpbmcuXG4gICAgbGlua1N0cmVuZ3RoOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMX0sXG4gICAgbGlua0Rpc3RhbmNlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMjB9LFxuICAgIGNoYXJnZToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IC0zMH0sXG5cbiAgICBjaGFyZ2VEaXN0YW5jZToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IEluZmluaXR5fSxcbiAgICBmcmljdGlvbjoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDAuOX0sXG4gICAgdGhldGE6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwLjh9LFxuICAgIGdyYXZpdHk6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwLjF9LFxuICAgIGFscGhhOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMC4xfSxcbiAgICBpdGVyYXRpb25zOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogNTAwfSxcblxuICAgIGludGVyYWN0aXZlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogdGhpcy5faW50ZXJhY3RpdmV9LCAgICBcbiAgICBhY3RpdmU6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiB0aGlzLl9wcmV2fSxcbiAgICBmaXhlZDoge3R5cGU6ICdkYXRhJ31cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgICd4JzogJ2xheW91dF94JyxcbiAgICAneSc6ICdsYXlvdXRfeSdcbiAgfTtcblxuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEZvcmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9yY2U7XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlSW5wdXQsIHJlc2V0KSB7XG4gIGxvZy5kZWJ1Zyhub2RlSW5wdXQsIFsnZm9yY2UnXSk7XG4gIHJlc2V0ID0gcmVzZXQgLSAobm9kZUlucHV0LnNpZ25hbHMuYWN0aXZlID8gMSA6IDApO1xuXG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGludGVyYWN0aXZlID0gdGhpcy5wYXJhbSgnaW50ZXJhY3RpdmUnKSxcbiAgICAgIGxpbmtTb3VyY2UgPSB0aGlzLnBhcmFtKCdsaW5rcycpLnNvdXJjZSxcbiAgICAgIGxpbmtJbnB1dCA9IGxpbmtTb3VyY2UubGFzdCgpLFxuICAgICAgYWN0aXZlID0gdGhpcy5wYXJhbSgnYWN0aXZlJyksXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBsYXlvdXQgPSB0aGlzLl9sYXlvdXQsXG4gICAgICBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgbGlua3MgPSB0aGlzLl9saW5rcztcblxuICAvLyBjb25maWd1cmUgbm9kZXMsIGxpbmtzIGFuZCBsYXlvdXRcbiAgaWYgKGxpbmtJbnB1dC5zdGFtcCA8IG5vZGVJbnB1dC5zdGFtcCkgbGlua0lucHV0ID0gbnVsbDtcbiAgdGhpcy5jb25maWd1cmUobm9kZUlucHV0LCBsaW5rSW5wdXQsIGludGVyYWN0aXZlLCByZXNldCk7XG4gIFxuICAvLyBydW4gYmF0Y2ggbGF5b3V0XG4gIGlmICghaW50ZXJhY3RpdmUpIHtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IHRoaXMucGFyYW0oJ2l0ZXJhdGlvbnMnKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aXRlcmF0aW9uczsgKytpKSBsYXlvdXQudGljaygpO1xuICAgIGxheW91dC5zdG9wKCk7XG4gIH1cblxuICAvLyB1cGRhdGUgbm9kZSBwb3NpdGlvbnNcbiAgdGhpcy51cGRhdGUoYWN0aXZlKTtcblxuICAvLyByZS11cCBhbHBoYSBvbiBwYXJhbWV0ZXIgY2hhbmdlXG4gIGlmIChyZXNldCB8fCBhY3RpdmUgIT09IHRoaXMuX3ByZXYgJiYgYWN0aXZlICYmIGFjdGl2ZS51cGRhdGUpIHtcbiAgICBsYXlvdXQuYWxwaGEodGhpcy5wYXJhbSgnYWxwaGEnKSk7IC8vIHJlLXN0YXJ0IGxheW91dFxuICB9XG5cbiAgLy8gdXBkYXRlIGFjdGl2ZSBub2RlIHN0YXR1cywgXG4gIGlmIChhY3RpdmUgIT09IHRoaXMuX3ByZXYpIHtcbiAgICB0aGlzLl9wcmV2ID0gYWN0aXZlO1xuICB9XG5cbiAgLy8gcHJvY2VzcyByZW1vdmVkIG5vZGVzIG9yIGVkZ2VzXG4gIGlmIChub2RlSW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGxheW91dC5ub2Rlcyh0aGlzLl9ub2RlcyA9IFR1cGxlLmlkRmlsdGVyKG5vZGVzLCBub2RlSW5wdXQucmVtKSk7XG4gIH1cbiAgaWYgKGxpbmtJbnB1dCAmJiBsaW5rSW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGxheW91dC5saW5rcyh0aGlzLl9saW5rcyA9IFR1cGxlLmlkRmlsdGVyKGxpbmtzLCBsaW5rSW5wdXQucmVtKSk7XG4gIH1cblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIG5vZGVJbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICByZXR1cm4gbm9kZUlucHV0O1xufTtcblxucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG5vZGVJbnB1dCwgbGlua0lucHV0LCBpbnRlcmFjdGl2ZSwgcmVzZXQpIHtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBydW4gY29uZmlndXJhdGlvblxuICB2YXIgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgdXBkYXRlID0gdGhpcy5fc2V0dXAgfHwgbm9kZUlucHV0LmFkZC5sZW5ndGggfHxcbiAgICAgICAgICAgIGxpbmtJbnB1dCAmJiBsaW5rSW5wdXQuYWRkLmxlbmd0aCB8fFxuICAgICAgICAgICAgaW50ZXJhY3RpdmUgIT09IHRoaXMuX2ludGVyYWN0aXZlIHx8XG4gICAgICAgICAgICB0aGlzLnBhcmFtKCdjaGFyZ2UnKSAhPT0gbGF5b3V0LmNoYXJnZSgpIHx8XG4gICAgICAgICAgICB0aGlzLnBhcmFtKCdsaW5rU3RyZW5ndGgnKSAhPT0gbGF5b3V0LmxpbmtTdHJlbmd0aCgpIHx8XG4gICAgICAgICAgICB0aGlzLnBhcmFtKCdsaW5rRGlzdGFuY2UnKSAhPT0gbGF5b3V0LmxpbmtEaXN0YW5jZSgpO1xuXG4gIGlmICh1cGRhdGUgfHwgcmVzZXQpIHtcbiAgICAvLyBhIHBhcmFtZXRlciBjaGFuZ2VkLCBzbyB1cGRhdGUgdGljay1vbmx5IHBhcmFtZXRlcnNcbiAgICBsYXlvdXRcbiAgICAgIC5zaXplKHRoaXMucGFyYW0oJ3NpemUnKSlcbiAgICAgIC5jaGFyZ2VEaXN0YW5jZSh0aGlzLnBhcmFtKCdjaGFyZ2VEaXN0YW5jZScpKVxuICAgICAgLnRoZXRhKHRoaXMucGFyYW0oJ3RoZXRhJykpXG4gICAgICAuZ3Jhdml0eSh0aGlzLnBhcmFtKCdncmF2aXR5JykpXG4gICAgICAuZnJpY3Rpb24odGhpcy5wYXJhbSgnZnJpY3Rpb24nKSk7XG4gIH1cblxuICBpZiAoIXVwZGF0ZSkgcmV0dXJuOyAvLyBpZiBubyBtb3JlIHVwZGF0ZXMgbmVlZGVkLCByZXR1cm4gbm93XG5cbiAgdGhpcy5fc2V0dXAgPSBmYWxzZTtcbiAgdGhpcy5faW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICB2YXIgZm9yY2UgPSB0aGlzLFxuICAgICAgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsaW5rcyA9IHRoaXMuX2xpbmtzLCBhLCBpO1xuXG4gIC8vIHByb2Nlc3MgYWRkZWQgbm9kZXNcbiAgZm9yIChhPW5vZGVJbnB1dC5hZGQsIGk9MDsgaTxhLmxlbmd0aDsgKytpKSB7XG4gICAgbm9kZXMucHVzaCh7dHVwbGU6IGFbaV19KTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYWRkZWQgZWRnZXNcbiAgaWYgKGxpbmtJbnB1dCkgZm9yIChhPWxpbmtJbnB1dC5hZGQsIGk9MDsgaTxhLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gVE9ETyBhZGQgY29uZmlndXJhYmxlIHNvdXJjZS90YXJnZXQgYWNjZXNzb3JzXG4gICAgLy8gVE9ETyBzdXBwb3J0IGxvb2t1cCBieSBub2RlIGlkXG4gICAgLy8gVE9ETyBwcm9jZXNzICdtb2QnIG9mIGVkZ2Ugc291cmNlIG9yIHRhcmdldD9cbiAgICBsaW5rcy5wdXNoKHtcbiAgICAgIHR1cGxlOiAgYVtpXSxcbiAgICAgIHNvdXJjZTogbm9kZXNbYVtpXS5zb3VyY2VdLFxuICAgICAgdGFyZ2V0OiBub2Rlc1thW2ldLnRhcmdldF1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHNldHVwIGhhbmRsZXIgZm9yIGZvcmNlIGxheW91dCB0aWNrIGV2ZW50c1xuICB2YXIgdGlja0hhbmRsZXIgPSAhaW50ZXJhY3RpdmUgPyBudWxsIDogZnVuY3Rpb24oKSB7XG4gICAgLy8gcmUtc2NoZWR1bGUgdGhlIHRyYW5zZm9ybSwgZm9yY2UgcmVmbG93XG4gICAgZ3JhcGgucHJvcGFnYXRlKENoYW5nZVNldC5jcmVhdGUobnVsbCwgdHJ1ZSksIGZvcmNlKTtcbiAgfTtcblxuICAvLyBjb25maWd1cmUgdGhlIHJlc3Qgb2YgdGhlIGxheW91dFxuICBsYXlvdXRcbiAgICAubGlua1N0cmVuZ3RoKHRoaXMucGFyYW0oJ2xpbmtTdHJlbmd0aCcpKVxuICAgIC5saW5rRGlzdGFuY2UodGhpcy5wYXJhbSgnbGlua0Rpc3RhbmNlJykpXG4gICAgLmNoYXJnZSh0aGlzLnBhcmFtKCdjaGFyZ2UnKSlcbiAgICAubm9kZXMobm9kZXMpXG4gICAgLmxpbmtzKGxpbmtzKVxuICAgIC5vbigndGljaycsIHRpY2tIYW5kbGVyKVxuICAgIC5zdGFydCgpLmFscGhhKHRoaXMucGFyYW0oJ2FscGhhJykpO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGFjdGl2ZSkge1xuICB2YXIgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgYm91bmQgPSB0aGlzLnBhcmFtKCdib3VuZCcpLFxuICAgICAgZml4ZWQgPSB0aGlzLnBhcmFtKCdmaXhlZCcpLFxuICAgICAgc2l6ZSA9IHRoaXMucGFyYW0oJ3NpemUnKSxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsdXQgPSB7fSwgaWQsIGksIG4sIHQsIHgsIHk7XG5cbiAgaWYgKGZpeGVkICYmIGZpeGVkLnNvdXJjZSkge1xuICAgIC8vIFRPRE86IGNvdWxkIGNhY2hlIGFuZCB1cGRhdGUgYXMgbmVlZGVkP1xuICAgIGZpeGVkID0gZml4ZWQuc291cmNlLnZhbHVlcygpO1xuICAgIGZvciAoaT0wLCBuPWZpeGVkLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGx1dFtmaXhlZFtpXS5pZF0gPSAxO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaT0wOyBpPG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbiA9IG5vZGVzW2ldO1xuICAgIHQgPSBuLnR1cGxlO1xuICAgIGlkID0gdC5faWQ7XG5cbiAgICBpZiAoYWN0aXZlICYmIGFjdGl2ZS5pZCA9PT0gaWQpIHtcbiAgICAgIG4uZml4ZWQgPSAxO1xuICAgICAgaWYgKGFjdGl2ZS51cGRhdGUpIHtcbiAgICAgICAgbi54ID0gbi5weCA9IGFjdGl2ZS54O1xuICAgICAgICBuLnkgPSBuLnB5ID0gYWN0aXZlLnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4uZml4ZWQgPSBsdXRbaWRdIHx8IDA7XG4gICAgfVxuXG4gICAgeCA9IGJvdW5kID8gTWF0aC5tYXgoMCwgTWF0aC5taW4obi54LCBzaXplWzBdKSkgOiBuLng7XG4gICAgeSA9IGJvdW5kID8gTWF0aC5tYXgoMCwgTWF0aC5taW4obi55LCBzaXplWzFdKSkgOiBuLnk7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC54LCB4KTtcbiAgICBUdXBsZS5zZXQodCwgb3V0cHV0LnksIHkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlOyIsInZhciBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIFNJR05BTFMgPSBkZi5EZXBlbmRlbmNpZXMuU0lHTkFMUyxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBGb3JtdWxhKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgZXhwcjogIHt0eXBlOiAnZXhwcid9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoRm9ybXVsYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZvcm11bGE7XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnZm9ybXVsYXRpbmcnXSk7XG5cbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGZpZWxkID0gdGhpcy5wYXJhbSgnZmllbGQnKSxcbiAgICAgIGV4cHIgPSB0aGlzLnBhcmFtKCdleHByJyksXG4gICAgICBzaWduYWxzID0gZy52YWx1ZXMoU0lHTkFMUywgdGhpcy5kZXBlbmRlbmN5KFNJR05BTFMpKTtcblxuICBmdW5jdGlvbiBzZXQoeCkge1xuICAgIFR1cGxlLnNldCh4LCBmaWVsZCwgZXhwcih4LCBudWxsLCBzaWduYWxzKSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybXVsYTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBHZW8oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCBHZW8uUGFyYW1ldGVycyk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBsb246IHt0eXBlOiAnZmllbGQnfSxcbiAgICBsYXQ6IHt0eXBlOiAnZmllbGQnfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgJ3gnOiAnbGF5b3V0X3gnLFxuICAgICd5JzogJ2xheW91dF95J1xuICB9O1xuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG5HZW8uUGFyYW1ldGVycyA9IHtcbiAgcHJvamVjdGlvbjoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdtZXJjYXRvcid9LFxuICBjZW50ZXI6ICAgICB7dHlwZTogJ2FycmF5PHZhbHVlPid9LFxuICB0cmFuc2xhdGU6ICB7dHlwZTogJ2FycmF5PHZhbHVlPid9LFxuICByb3RhdGU6ICAgICB7dHlwZTogJ2FycmF5PHZhbHVlPid9LFxuICBzY2FsZTogICAgICB7dHlwZTogJ3ZhbHVlJ30sXG4gIHByZWNpc2lvbjogIHt0eXBlOiAndmFsdWUnfSxcbiAgY2xpcEFuZ2xlOiAge3R5cGU6ICd2YWx1ZSd9LFxuICBjbGlwRXh0ZW50OiB7dHlwZTogJ3ZhbHVlJ31cbn07XG5cbkdlby5kM1Byb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHAgPSB0aGlzLnBhcmFtKCdwcm9qZWN0aW9uJyksXG4gICAgICBwYXJhbSA9IEdlby5QYXJhbWV0ZXJzLFxuICAgICAgcHJvaiwgbmFtZSwgdmFsdWU7XG5cbiAgaWYgKHAgIT09IHRoaXMuX21vZGUpIHtcbiAgICB0aGlzLl9tb2RlID0gcDtcbiAgICB0aGlzLl9wcm9qZWN0aW9uID0gZDMuZ2VvW3BdKCk7XG4gIH1cbiAgcHJvaiA9IHRoaXMuX3Byb2plY3Rpb247XG5cbiAgZm9yIChuYW1lIGluIHBhcmFtKSB7XG4gICAgaWYgKG5hbWUgPT09ICdwcm9qZWN0aW9uJyB8fCAhcHJvaltuYW1lXSkgY29udGludWU7XG4gICAgdmFsdWUgPSB0aGlzLnBhcmFtKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IChkbC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBwcm9qW25hbWVdKCkpIHtcbiAgICAgIHByb2pbbmFtZV0odmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9qO1xufTtcblxudmFyIHByb3RvdHlwZSA9IChHZW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW87XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnZ2VvJ10pO1xuXG4gIHZhciBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBsb24gPSB0aGlzLnBhcmFtKCdsb24nKS5hY2Nlc3NvcixcbiAgICAgIGxhdCA9IHRoaXMucGFyYW0oJ2xhdCcpLmFjY2Vzc29yLFxuICAgICAgcHJvaiA9IEdlby5kM1Byb2plY3Rpb24uY2FsbCh0aGlzKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBsbCA9IFtsb24odCksIGxhdCh0KV07XG4gICAgdmFyIHh5ID0gcHJvaihsbCkgfHwgW251bGwsIG51bGxdO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQueCwgeHlbMF0pO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQueSwgeHlbMV0pO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIEdlbyA9IHJlcXVpcmUoJy4vR2VvJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gR2VvUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogbnVsbH0sXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICAncGF0aCc6ICdsYXlvdXRfcGF0aCdcbiAgfTtcbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChHZW9QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvUGF0aDtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydnZW9wYXRoJ10pO1xuXG4gIHZhciBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBnZW9qc29uID0gdGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvciB8fCBkbC5pZGVudGl0eSxcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyksXG4gICAgICBwYXRoID0gZDMuZ2VvLnBhdGgoKS5wcm9qZWN0aW9uKHByb2opO1xuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKGdlb2pzb24odCkpKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5wYXRoXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvUGF0aDsiLCJ2YXIgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gTGlua1BhdGgoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc291cmNlWDogIHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnX3NvdXJjZS5sYXlvdXRfeCd9LFxuICAgIHNvdXJjZVk6ICB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ19zb3VyY2UubGF5b3V0X3knfSxcbiAgICB0YXJnZXRYOiAge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdfdGFyZ2V0LmxheW91dF94J30sXG4gICAgdGFyZ2V0WTogIHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnX3RhcmdldC5sYXlvdXRfeSd9LFxuICAgIHRlbnNpb246ICB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMC4yfSxcbiAgICBzaGFwZTogICAge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdsaW5lJ31cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0geydwYXRoJzogJ2xheW91dF9wYXRoJ307XG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoTGlua1BhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5rUGF0aDtcblxuZnVuY3Rpb24gbGluZShzeCwgc3ksIHR4LCB0eSkge1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArXG4gICAgICAgICAnTCcgKyB0eCArICcsJyArIHR5O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZShzeCwgc3ksIHR4LCB0eSwgdGVuc2lvbikge1xuICB2YXIgZHggPSB0eCAtIHN4LFxuICAgICAgZHkgPSB0eSAtIHN5LFxuICAgICAgaXggPSB0ZW5zaW9uICogKGR4ICsgZHkpLFxuICAgICAgaXkgPSB0ZW5zaW9uICogKGR5IC0gZHgpO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArXG4gICAgICAgICAnQycgKyAoc3graXgpICsgJywnICsgKHN5K2l5KSArXG4gICAgICAgICAnICcgKyAodHgraXkpICsgJywnICsgKHR5LWl4KSArXG4gICAgICAgICAnICcgKyB0eCArICcsJyArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFgoc3gsIHN5LCB0eCwgdHkpIHtcbiAgdmFyIG0gPSAoc3ggKyB0eCkgLyAyO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArXG4gICAgICAgICAnQycgKyBtICArICcsJyArIHN5ICtcbiAgICAgICAgICcgJyArIG0gICsgJywnICsgdHkgK1xuICAgICAgICAgJyAnICsgdHggKyAnLCcgKyB0eTtcbn1cblxuZnVuY3Rpb24gZGlhZ29uYWxZKHN4LCBzeSwgdHgsIHR5KSB7XG4gIHZhciBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgK1xuICAgICAgICAgJ0MnICsgc3ggKyAnLCcgKyBtICtcbiAgICAgICAgICcgJyArIHR4ICsgJywnICsgbSArXG4gICAgICAgICAnICcgKyB0eCArICcsJyArIHR5O1xufVxuXG52YXIgc2hhcGVzID0ge1xuICBsaW5lOiAgICAgIGxpbmUsXG4gIGN1cnZlOiAgICAgY3VydmUsXG4gIGRpYWdvbmFsOiAgZGlhZ29uYWxYLFxuICBkaWFnb25hbFg6IGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxZOiBkaWFnb25hbFlcbn07XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnbGlua3BhdGgnXSk7XG5cbiAgdmFyIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIHNoYXBlID0gc2hhcGVzW3RoaXMucGFyYW0oJ3NoYXBlJyldIHx8IHNoYXBlcy5saW5lLFxuICAgICAgc291cmNlWCA9IHRoaXMucGFyYW0oJ3NvdXJjZVgnKS5hY2Nlc3NvcixcbiAgICAgIHNvdXJjZVkgPSB0aGlzLnBhcmFtKCdzb3VyY2VZJykuYWNjZXNzb3IsXG4gICAgICB0YXJnZXRYID0gdGhpcy5wYXJhbSgndGFyZ2V0WCcpLmFjY2Vzc29yLFxuICAgICAgdGFyZ2V0WSA9IHRoaXMucGFyYW0oJ3RhcmdldFknKS5hY2Nlc3NvcixcbiAgICAgIHRlbnNpb24gPSB0aGlzLnBhcmFtKCd0ZW5zaW9uJyk7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgcGF0aCA9IHNoYXBlKHNvdXJjZVgodCksIHNvdXJjZVkodCksIHRhcmdldFgodCksIHRhcmdldFkodCksIHRlbnNpb24pO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtQYXRoOyIsInZhciBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBMb29rdXAoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgb246ICAgICAge3R5cGU6ICdkYXRhJ30sXG4gICAgb25LZXk6ICAge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6IG51bGx9LFxuICAgIGFzOiAgICAgIHt0eXBlOiAnYXJyYXk8dmFsdWU+J30sXG4gICAga2V5czogICAge3R5cGU6ICdhcnJheTxmaWVsZD4nLCBkZWZhdWx0OiBbJ2RhdGEnXX0sXG4gICAgZGVmYXVsdDoge3R5cGU6ICd2YWx1ZSd9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoTG9va3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9va3VwO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydsb29rdXAnXSk7XG5cbiAgdmFyIG9uID0gdGhpcy5wYXJhbSgnb24nKSxcbiAgICAgIG9uTGFzdCA9IG9uLnNvdXJjZS5sYXN0KCksXG4gICAgICBvbkRhdGEgPSBvbi5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvbktleSA9IHRoaXMucGFyYW0oJ29uS2V5JyksXG4gICAgICBvbkYgPSBvbktleS5maWVsZCxcbiAgICAgIGtleXMgPSB0aGlzLnBhcmFtKCdrZXlzJyksXG4gICAgICBnZXQgPSBrZXlzLmFjY2Vzc29yLFxuICAgICAgYXMgPSB0aGlzLnBhcmFtKCdhcycpLFxuICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5wYXJhbSgnZGVmYXVsdCcpLFxuICAgICAgbHV0ID0gdGhpcy5fbHV0LFxuICAgICAgaSwgdjtcblxuICAvLyBidWlsZCBsb29rdXAgdGFibGUgb24gaW5pdCwgd2l0aEtleSBtb2RpZmllZCwgb3IgdHVwbGUgYWRkL3JlbVxuICBpZiAobHV0ID09IG51bGwgfHwgdGhpcy5fb24gIT09IG9uRiB8fCBvbkYgJiYgb25MYXN0LmZpZWxkc1tvbkZdIHx8XG4gICAgICBvbkxhc3QuYWRkLmxlbmd0aCB8fCBvbkxhc3QucmVtLmxlbmd0aClcbiAge1xuICAgIGlmIChvbkYpIHsgLy8gYnVpbGQgaGFzaCBmcm9tIHdpdGhLZXkgZmllbGRcbiAgICAgIG9uS2V5ID0gb25LZXkuYWNjZXNzb3I7XG4gICAgICBmb3IgKGx1dD17fSwgaT0wOyBpPG9uRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBsdXRbb25LZXkodiA9IG9uRGF0YVtpXSldID0gdjtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIHVzZSBpbmRleC1iYXNlZCBsb29rdXBcbiAgICAgIGx1dCA9IG9uRGF0YTtcbiAgICB9XG4gICAgdGhpcy5fbHV0ID0gbHV0O1xuICAgIHRoaXMuX29uID0gb25GO1xuICAgIHJlc2V0ID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPGdldC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHYgPSBsdXRbZ2V0W2ldKHQpXSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICBUdXBsZS5zZXQodCwgYXNbaV0sIHYpO1xuICAgIH1cbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIHZhciBydW4gPSBrZXlzLmZpZWxkLnNvbWUoZnVuY3Rpb24oZikgeyByZXR1cm4gaW5wdXQuZmllbGRzW2ZdOyB9KTtcbiAgaWYgKHJ1biB8fCByZXNldCkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTsgXG4gIH1cblxuICBhcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgaW5wdXQuZmllbGRzW2tdID0gMTsgfSk7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9va3VwOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBEZXBzID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLkRlcGVuZGVuY2llcyxcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpO1xuXG52YXIgYXJyYXlUeXBlID0gL2FycmF5L2ksXG4gICAgZGF0YVR5cGUgID0gL2RhdGEvaSxcbiAgICBmaWVsZFR5cGUgPSAvZmllbGQvaSxcbiAgICBleHByVHlwZSAgPSAvZXhwci9pLFxuICAgIHZhbFR5cGUgICA9IC92YWx1ZS9pO1xuXG5mdW5jdGlvbiBQYXJhbWV0ZXIobmFtZSwgdHlwZSwgdHJhbnNmb3JtKSB7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl90eXBlID0gdHlwZTtcbiAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXG4gIC8vIElmIHBhcmFtZXRlciBpcyBkZWZpbmVkIHcvc2lnbmFscywgaXQgbXVzdCBiZSByZXNvbHZlZFxuICAvLyBvbiBldmVyeSBwdWxzZS5cbiAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gIHRoaXMuX3Jlc29sdXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xufVxuXG52YXIgcHJvdG90eXBlID0gUGFyYW1ldGVyLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gZ2V0KCkge1xuICB2YXIgaXNBcnJheSA9IGFycmF5VHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgdmFyIHZhbCA9IGlzQXJyYXkgPyB0aGlzLl92YWx1ZSA6IHRoaXMuX3ZhbHVlWzBdLFxuICAgICAgYWNjID0gaXNBcnJheSA/IHRoaXMuX2FjY2Vzc29ycyA6IHRoaXMuX2FjY2Vzc29yc1swXTtcblxuICBpZiAoIWRsLmlzVmFsaWQoYWNjKSAmJiB2YWxUeXBlLnRlc3QodGhpcy5fdHlwZSkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc0RhdGEgPyB7IG5hbWU6IHZhbCwgc291cmNlOiBhY2MgfSA6XG4gICAgaXNGaWVsZCA/IHsgZmllbGQ6IHZhbCwgYWNjZXNzb3I6IGFjYyB9IDogdmFsO1xuICB9XG59XG5cbnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoID0gdGhpcy5fdHJhbnNmb3JtLl9ncmFwaCwgXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIHMsIGlkeCwgdmFsO1xuXG4gIC8vIElmIHdlIGRvbid0IHJlcXVpcmUgcmVzb2x1dGlvbiwgcmV0dXJuIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgaWYgKCF0aGlzLl9yZXNvbHV0aW9uKSByZXR1cm4gZ2V0LmNhbGwodGhpcyk7XG5cbiAgaWYgKGlzRGF0YSkge1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IHRoaXMuX3ZhbHVlLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBncmFwaC5kYXRhKHYpOyB9KTtcbiAgICByZXR1cm4gZ2V0LmNhbGwodGhpcyk7IC8vIFRPRE86IHN1cHBvcnQgc2lnbmFsIGFzIGRhdGFUeXBlc1xuICB9XG5cbiAgZm9yIChzIGluIHRoaXMuX3NpZ25hbHMpIHtcbiAgICBpZHggPSB0aGlzLl9zaWduYWxzW3NdO1xuICAgIHZhbCA9IGdyYXBoLnNpZ25hbFJlZihzKTtcblxuICAgIGlmIChpc0ZpZWxkKSB7XG4gICAgICB0aGlzLl9hY2Nlc3NvcnNbaWR4XSA9IHRoaXMuX3ZhbHVlW2lkeF0gIT0gdmFsID8gXG4gICAgICAgIGRsLmFjY2Vzc29yKHZhbCkgOiB0aGlzLl9hY2Nlc3NvcnNbaWR4XTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZVtpZHhdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xufTtcblxucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBwID0gdGhpcyxcbiAgICAgIGlzRXhwciA9IGV4cHJUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICB0aGlzLl92YWx1ZSA9IGRsLmFycmF5KHZhbHVlKS5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgIGlmIChkbC5pc1N0cmluZyh2KSkge1xuICAgICAgaWYgKGlzRXhwcikge1xuICAgICAgICB2YXIgZSA9IGV4cHIodik7XG4gICAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuRklFTERTLCAgZS5maWVsZHMpO1xuICAgICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLlNJR05BTFMsIGUuZ2xvYmFscyk7XG4gICAgICAgIHJldHVybiBlLmZuO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7ICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBwLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2KTtcbiAgICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5GSUVMRFMsIGRsLmZpZWxkKHYpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRhKSB7XG4gICAgICAgIHAuX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLkRBVEEsIHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIGlmICh2LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodi5maWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2LmZpZWxkKTtcbiAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuRklFTERTLCBkbC5maWVsZCh2LmZpZWxkKSk7XG4gICAgICByZXR1cm4gdi5maWVsZDtcbiAgICB9IGVsc2UgaWYgKHYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAuX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgcC5fc2lnbmFsc1t2LnNpZ25hbF0gPSBpO1xuICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCB2LnNpZ25hbCk7XG4gICAgICByZXR1cm4gdi5zaWduYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0pO1xuXG4gIHJldHVybiBwLl90cmFuc2Zvcm07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFtZXRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gUGllKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6ICAgICAge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6IG51bGx9LFxuICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwfSxcbiAgICBlbmRBbmdsZTogICB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMiAqIE1hdGguUEl9LFxuICAgIHNvcnQ6ICAgICAgIHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiBmYWxzZX1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgICdzdGFydCc6ICdsYXlvdXRfc3RhcnQnLFxuICAgICdlbmQnOiAgICdsYXlvdXRfZW5kJyxcbiAgICAnbWlkJzogICAnbGF5b3V0X21pZCdcbiAgfTtcblxuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFBpZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGllO1xuXG5mdW5jdGlvbiBvbmVzKCkgeyByZXR1cm4gMTsgfVxuXG5wcm90b3R5cGUuYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsncGllJ10pO1xuXG4gIHZhciBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBmaWVsZCA9IHRoaXMucGFyYW0oJ2ZpZWxkJykuYWNjZXNzb3IgfHwgb25lcyxcbiAgICAgIHN0YXJ0ID0gdGhpcy5wYXJhbSgnc3RhcnRBbmdsZScpLFxuICAgICAgc3RvcCA9IHRoaXMucGFyYW0oJ2VuZEFuZ2xlJyksXG4gICAgICBzb3J0ID0gdGhpcy5wYXJhbSgnc29ydCcpO1xuXG4gIHZhciB2YWx1ZXMgPSBkYXRhLm1hcChmaWVsZCksXG4gICAgICBhID0gc3RhcnQsXG4gICAgICBrID0gKHN0b3AgLSBzdGFydCkgLyBkbC5zdW0odmFsdWVzKSxcbiAgICAgIGluZGV4ID0gZGwucmFuZ2UoZGF0YS5sZW5ndGgpLFxuICAgICAgaSwgdCwgdjtcblxuICBpZiAoc29ydCkge1xuICAgIGluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHZhbHVlc1thXSAtIHZhbHVlc1tiXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPGluZGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgdCA9IGRhdGFbaW5kZXhbaV1dO1xuICAgIHYgPSB2YWx1ZXNbaW5kZXhbaV1dO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQubWlkLCAoYSArIDAuNSAqIHYgKiBrKSk7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC5lbmQsIChhICs9IHYgKiBrKSk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0YXJ0XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuZW5kXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGllOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gU29ydChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtieToge3R5cGU6ICdhcnJheTxmaWVsZD4nfSB9KTtcbiAgdGhpcy5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoU29ydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvcnQ7XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnc29ydGluZyddKTtcblxuICBpZiAoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5tb2QubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICBpbnB1dC5zb3J0ID0gZGwuY29tcGFyYXRvcih0aGlzLnBhcmFtKCdieScpLmZpZWxkKTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvcnQ7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIFN0YWNrKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZ3JvdXBieToge3R5cGU6ICdhcnJheTxmaWVsZD4nfSxcbiAgICBzb3J0Ynk6IHt0eXBlOiAnYXJyYXk8ZmllbGQ+J30sXG4gICAgZmllbGQ6IHt0eXBlOiAnZmllbGQnfSxcbiAgICBvZmZzZXQ6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnemVybyd9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICAnc3RhcnQnOiAnbGF5b3V0X3N0YXJ0JyxcbiAgICAnZW5kJzogICAnbGF5b3V0X2VuZCcsXG4gICAgJ21pZCc6ICAgJ2xheW91dF9taWQnXG4gIH07XG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoU3RhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YWNrO1xuXG5wcm90b3R5cGUuYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnc3RhY2tpbmcnXSk7XG5cbiAgdmFyIGdyb3VwYnkgPSB0aGlzLnBhcmFtKCdncm91cGJ5JykuYWNjZXNzb3IsXG4gICAgICBzb3J0YnkgPSBkbC5jb21wYXJhdG9yKHRoaXMucGFyYW0oJ3NvcnRieScpLmZpZWxkKSxcbiAgICAgIGZpZWxkID0gdGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvcixcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyYW0oJ29mZnNldCcpLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0O1xuXG4gIC8vIHBhcnRpdGlvbiwgc3VtLCBhbmQgc29ydCB0aGUgc3RhY2sgZ3JvdXBzXG4gIHZhciBncm91cHMgPSBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCBmaWVsZCk7XG5cbiAgLy8gY29tcHV0ZSBzdGFjayBsYXlvdXRzIHBlciBncm91cFxuICBmb3IgKHZhciBpPTAsIG1heD1ncm91cHMubWF4OyBpPGdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXSxcbiAgICAgICAgc3VtID0gZ3JvdXAuc3VtLFxuICAgICAgICBvZmYgPSBvZmZzZXQ9PT0nY2VudGVyJyA/IChtYXggLSBzdW0pLzIgOiAwLFxuICAgICAgICBzY2FsZSA9IG9mZnNldD09PSdub3JtYWxpemUnID8gKDEvc3VtKSA6IDEsXG4gICAgICAgIGosIHgsIGEsIGIgPSBvZmYsIHYgPSAwO1xuXG4gICAgLy8gc2V0IHN0YWNrIGNvb3JkaW5hdGVzIGZvciBlYWNoIGRhdHVtIGluIGdyb3VwXG4gICAgZm9yIChqPTA7IGo8Z3JvdXAubGVuZ3RoOyArK2opIHtcbiAgICAgIHggPSBncm91cFtqXTtcbiAgICAgIGEgPSBiOyAvLyB1c2UgcHJldmlvdXMgdmFsdWUgZm9yIHN0YXJ0IHBvaW50XG4gICAgICB2ICs9IGZpZWxkKHgpO1xuICAgICAgYiA9IHNjYWxlICogdiArIG9mZjsgLy8gY29tcHV0ZSBlbmQgcG9pbnRcbiAgICAgIFR1cGxlLnNldCh4LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgICAgVHVwbGUuc2V0KHgsIG91dHB1dC5lbmQsIGIpO1xuICAgICAgVHVwbGUuc2V0KHgsIG91dHB1dC5taWQsIDAuNSAqIChhICsgYikpO1xuICAgIH1cbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5lbmRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5taWRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnRieSwgZmllbGQpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgZ2V0ID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZih4KTsgfSxcbiAgICAgIG1hcCwgaSwgeCwgaywgZywgcywgbWF4O1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5zbGljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcD17fSwgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgayA9IGdyb3VwYnkubWFwKGdldCk7XG4gICAgICBnID0gbWFwW2tdIHx8IChncm91cHMucHVzaChtYXBba10gPSBbXSksIG1hcFtrXSk7XG4gICAgICBnLnB1c2goeCk7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBzdW1zIG9mIGdyb3Vwcywgc29ydCBncm91cHMgYXMgbmVlZGVkXG4gIGZvciAoaz0wLCBtYXg9MDsgazxncm91cHMubGVuZ3RoOyArK2spIHtcbiAgICBnID0gZ3JvdXBzW2tdO1xuICAgIGZvciAoaT0wLCBzPTA7IGk8Zy5sZW5ndGg7ICsraSkge1xuICAgICAgcyArPSBmaWVsZChnW2ldKTtcbiAgICB9XG4gICAgZy5zdW0gPSBzO1xuICAgIGlmIChzID4gbWF4KSBtYXggPSBzO1xuICAgIGlmIChzb3J0YnkgIT0gbnVsbCkgZy5zb3J0KHNvcnRieSk7XG4gIH1cbiAgZ3JvdXBzLm1heCA9IG1heDtcblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrOyIsInZhciBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBCYXNlID0gZGYuTm9kZS5wcm90b3R5cGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXMsXG4gICAgUGFyYW1ldGVyID0gcmVxdWlyZSgnLi9QYXJhbWV0ZXInKTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtKGdyYXBoKSB7XG4gIGlmIChncmFwaCkgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xufVxuXG5UcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHByb3RvLCBwYXJhbXMpIHtcbiAgcHJvdG8uX3BhcmFtZXRlcnMgPSBwcm90by5fcGFyYW1ldGVycyB8fCB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICB2YXIgcCA9IHBhcmFtc1tuYW1lXSxcbiAgICAgICAgcGFyYW0gPSBuZXcgUGFyYW1ldGVyKG5hbWUsIHAudHlwZSwgcHJvdG8pO1xuXG4gICAgcHJvdG8uX3BhcmFtZXRlcnNbbmFtZV0gPSBwYXJhbTtcblxuICAgIGlmIChwLnR5cGUgPT09ICdjdXN0b20nKSB7XG4gICAgICBpZiAocC5zZXQpIHBhcmFtLnNldCA9IHAuc2V0LmJpbmQocGFyYW0pO1xuICAgICAgaWYgKHAuZ2V0KSBwYXJhbS5nZXQgPSBwLmdldC5iaW5kKHBhcmFtKTtcbiAgICB9XG5cbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSBwYXJhbS5zZXQocC5kZWZhdWx0KTtcbiAgfVxufTtcblxudmFyIHByb3RvdHlwZSA9IChUcmFuc2Zvcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm07XG5cbnByb3RvdHlwZS5wYXJhbSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwYXJhbSA9IHRoaXMuX3BhcmFtZXRlcnNbbmFtZV07XG4gIHJldHVybiAocGFyYW0gPT09IHVuZGVmaW5lZCkgPyB0aGlzIDpcbiAgICAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgPyBwYXJhbS5nZXQoKSA6IHBhcmFtLnNldCh2YWx1ZSk7XG59O1xuXG4vLyBQZXJmb3JtIHRyYW5zZm9ybWF0aW9uLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZS5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dC8qLCByZXNldCAqLykge1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYW55IHRyYW5zZm9ybXMgc3RvcmUgY2FjaGVzIHRoYXQgbXVzdCBiZSBpbnZhbGlkYXRlZCBpZlxuICAvLyBhIHNpZ25hbCB2YWx1ZSBoYXMgY2hhbmdlZC4gXG4gIHZhciByZXNldCA9IHRoaXMuX3N0YW1wIDwgaW5wdXQuc3RhbXAgJiZcbiAgICB0aGlzLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTKS5yZWR1Y2UoZnVuY3Rpb24oYywgcykge1xuICAgICAgcmV0dXJuIGMgKz0gaW5wdXQuc2lnbmFsc1tzXSA/IDEgOiAwO1xuICAgIH0sIDApO1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oaW5wdXQsIHJlc2V0KTtcbn07XG5cbnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihtYXApIHtcbiAgZm9yICh2YXIga2V5IGluIHRoaXMuX291dHB1dCkge1xuICAgIGlmIChtYXBba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9vdXRwdXRba2V5XSA9IG1hcFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyk7XG5cbnZhciBkZWZhdWx0UmF0aW8gPSAwLjUgKiAoMSArIE1hdGguc3FydCg1KSk7XG5cbmZ1bmN0aW9uIFRyZWVtYXAoZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICAvLyBoaWVyYXJjaHkgcGFyYW1ldGVyc1xuICAgIHNvcnQ6IHt0eXBlOiAnYXJyYXk8ZmllbGQ+JywgZGVmYXVsdDogWyctdmFsdWUnXX0sXG4gICAgY2hpbGRyZW46IHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnY2hpbGRyZW4nfSxcbiAgICBmaWVsZDoge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICd2YWx1ZSd9LFxuICAgIC8vIHRyZWVtYXAgcGFyYW1ldGVyc1xuICAgIHNpemU6IHt0eXBlOiAnYXJyYXk8dmFsdWU+JywgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgcm91bmQ6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiB0cnVlfSxcbiAgICBzdGlja3k6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgcmF0aW86IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiBkZWZhdWx0UmF0aW99LFxuICAgIHBhZGRpbmc6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiBudWxsfSxcbiAgICBtb2RlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ3NxdWFyaWZ5J31cbiAgfSk7XG5cbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LnRyZWVtYXAoKTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgJ3gnOiAgICAgICdsYXlvdXRfeCcsXG4gICAgJ3knOiAgICAgICdsYXlvdXRfeScsXG4gICAgJ3dpZHRoJzogICdsYXlvdXRfd2lkdGgnLFxuICAgICdoZWlnaHQnOiAnbGF5b3V0X2hlaWdodCcsXG4gICAgJ2RlcHRoJzogICdsYXlvdXRfZGVwdGgnLFxuICB9O1xuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFRyZWVtYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyZWVtYXA7XG5cbnByb3RvdHlwZS5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWyd0cmVlbWFwJ10pO1xuXG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zb3J0KGRsLmNvbXBhcmF0b3IodGhpcy5wYXJhbSgnc29ydCcpLmZpZWxkKSlcbiAgICAuY2hpbGRyZW4odGhpcy5wYXJhbSgnY2hpbGRyZW4nKS5hY2Nlc3NvcilcbiAgICAudmFsdWUodGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvcilcbiAgICAuc2l6ZSh0aGlzLnBhcmFtKCdzaXplJykpXG4gICAgLnJvdW5kKHRoaXMucGFyYW0oJ3JvdW5kJykpXG4gICAgLnN0aWNreSh0aGlzLnBhcmFtKCdzdGlja3knKSlcbiAgICAucmF0aW8odGhpcy5wYXJhbSgncmF0aW8nKSlcbiAgICAucGFkZGluZyh0aGlzLnBhcmFtKCdwYWRkaW5nJykpXG4gICAgLm1vZGUodGhpcy5wYXJhbSgnbW9kZScpKVxuICAgIC5ub2RlcyhkYXRhWzBdKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBUdXBsZS5zZXQobiwgb3V0cHV0LngsIG4ueCk7XG4gICAgVHVwbGUuc2V0KG4sIG91dHB1dC55LCBuLnkpO1xuICAgIFR1cGxlLnNldChuLCBvdXRwdXQud2lkdGgsIG4uZHgpO1xuICAgIFR1cGxlLnNldChuLCBvdXRwdXQuaGVpZ2h0LCBuLmR5KTtcbiAgICBUdXBsZS5zZXQobiwgb3V0cHV0LmRlcHRoLCBuLmRlcHRoKTtcbiAgfSk7XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQud2lkdGhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5oZWlnaHRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlbWFwOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdy9zcmMvVHVwbGUnKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBWb3Jvbm9pKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgY2xpcEV4dGVudDoge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbWy0xZTUsLTFlNV0sWzFlNSwxZTVdXX0sXG4gICAgeDoge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdsYXlvdXRfeCd9LFxuICAgIHk6IHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnbGF5b3V0X3knfVxuICB9KTtcblxuICB0aGlzLl9sYXlvdXQgPSBkMy5nZW9tLnZvcm9ub2koKTtcbiAgdGhpcy5fb3V0cHV0ID0geydwYXRoJzogJ2xheW91dF9wYXRoJ307XG5cbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChWb3Jvbm9pLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWb3Jvbm9pO1xuXG5wcm90b3R5cGUuYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsndm9yb25vaSddKTtcblxuICAvLyBnZXQgdmFyaWFibGVzXG4gIHZhciBwYXRobmFtZSA9IHRoaXMuX291dHB1dC5wYXRoO1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgdmFyIHBvbHlnb25zID0gdGhpcy5fbGF5b3V0XG4gICAgLmNsaXBFeHRlbnQodGhpcy5wYXJhbSgnY2xpcEV4dGVudCcpKVxuICAgIC54KHRoaXMucGFyYW0oJ3gnKS5hY2Nlc3NvcilcbiAgICAueSh0aGlzLnBhcmFtKCd5JykuYWNjZXNzb3IpXG4gICAgKGRhdGEpO1xuXG4gIC8vIGJ1aWxkIGFuZCBhc3NpZ24gcGF0aCBzdHJpbmdzXG4gIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgVHVwbGUuc2V0KGRhdGFbaV0sIHBhdGhuYW1lLCAnTScgKyBwb2x5Z29uc1tpXS5qb2luKCdMJykgKyAnWicpO1xuICB9XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBpbnB1dC5maWVsZHNbcGF0aG5hbWVdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWb3Jvbm9pOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGQzX2Nsb3VkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ11bJ2xheW91dCddWydjbG91ZCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXVsnbGF5b3V0J11bJ2Nsb3VkJ10gOiBudWxsKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cvc3JjL1R1cGxlJyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gV29yZGNsb3VkKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc2l6ZToge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbOTAwLCA1MDBdfSxcbiAgICB0ZXh0OiB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ2RhdGEnfSxcbiAgICByb3RhdGU6IHt0eXBlOiAnZmllbGR8dmFsdWUnLCBkZWZhdWx0OiAwfSxcbiAgICBmb250OiB7dHlwZTogJ2ZpZWxkfHZhbHVlJywgZGVmYXVsdDoge3ZhbHVlOiAnc2Fucy1zZXJpZid9fSxcbiAgICBmb250U2l6ZToge3R5cGU6ICdmaWVsZHx2YWx1ZScsIGRlZmF1bHQ6IDE0fSxcbiAgICBmb250U3R5bGU6IHt0eXBlOiAnZmllbGR8dmFsdWUnLCBkZWZhdWx0OiB7dmFsdWU6ICdub3JtYWwnfX0sXG4gICAgZm9udFdlaWdodDoge3R5cGU6ICdmaWVsZHx2YWx1ZScsIGRlZmF1bHQ6IHt2YWx1ZTogJ25vcm1hbCd9fSxcbiAgICBmb250U2NhbGU6IHt0eXBlOiAnYXJyYXk8dmFsdWU+JywgZGVmYXVsdDogWzEwLCA1MF19LFxuICAgIHBhZGRpbmc6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAxfSxcbiAgICBzcGlyYWw6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnYXJjaGltZWRlYW4nfVxuICB9KTtcblxuICB0aGlzLl9sYXlvdXQgPSBkM19jbG91ZCgpO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICAneCc6ICAgICAgICAgICdsYXlvdXRfeCcsXG4gICAgJ3knOiAgICAgICAgICAnbGF5b3V0X3knLFxuICAgICdmb250JzogICAgICAgJ2xheW91dF9mb250JyxcbiAgICAnZm9udFNpemUnOiAgICdsYXlvdXRfZm9udFNpemUnLFxuICAgICdmb250U3R5bGUnOiAgJ2xheW91dF9mb250U3R5bGUnLFxuICAgICdmb250V2VpZ2h0JzogJ2xheW91dF9mb250V2VpZ2h0JyxcbiAgICAncm90YXRlJzogICAgICdsYXlvdXRfcm90YXRlJyxcbiAgfTtcblxuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFdvcmRjbG91ZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV29yZGNsb3VkO1xuXG5mdW5jdGlvbiBnZXQocCkge1xuICByZXR1cm4gKHAgJiYgcC5hY2Nlc3NvcikgfHwgcDtcbn1cblxuZnVuY3Rpb24gd3JhcCh0dXBsZSkge1xuICB2YXIgeCA9IE9iamVjdC5jcmVhdGUodHVwbGUpO1xuICB4Ll90dXBsZSA9IHR1cGxlO1xuICByZXR1cm4geDtcbn1cblxucHJvdG90eXBlLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ3dvcmRjbG91ZCddKTtcblxuICAvLyBnZXQgdmFyaWFibGVzXG4gIHZhciBsYXlvdXQgPSB0aGlzLl9sYXlvdXQsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBmb250U2l6ZSA9IHRoaXMucGFyYW0oJ2ZvbnRTaXplJyksXG4gICAgICByYW5nZSA9IGZvbnRTaXplLmFjY2Vzc29yICYmIHRoaXMucGFyYW0oJ2ZvbnRTY2FsZScpLFxuICAgICAgc2l6ZSwgc2NhbGU7XG4gIGZvbnRTaXplID0gZm9udFNpemUuYWNjZXNzb3IgfHwgZDMuZnVuY3Rvcihmb250U2l6ZSk7XG4gIFxuICAvLyBjcmVhdGUgZm9udCBzaXplIHNjYWxpbmcgZnVuY3Rpb24gYXMgbmVlZGVkXG4gIGlmIChyYW5nZS5sZW5ndGgpIHtcbiAgICBzY2FsZSA9IGQzLnNjYWxlLnNxcnQoKVxuICAgICAgLmRvbWFpbihkbC5leHRlbnQoZGF0YSwgc2l6ZT1mb250U2l6ZSkpXG4gICAgICAucmFuZ2UocmFuZ2UpO1xuICAgIGZvbnRTaXplID0gZnVuY3Rpb24oeCkgeyByZXR1cm4gc2NhbGUoc2l6ZSh4KSk7IH07XG4gIH1cblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zaXplKHRoaXMucGFyYW0oJ3NpemUnKSlcbiAgICAudGV4dChnZXQodGhpcy5wYXJhbSgndGV4dCcpKSlcbiAgICAucGFkZGluZyh0aGlzLnBhcmFtKCdwYWRkaW5nJykpXG4gICAgLnNwaXJhbCh0aGlzLnBhcmFtKCdzcGlyYWwnKSlcbiAgICAucm90YXRlKGdldCh0aGlzLnBhcmFtKCdyb3RhdGUnKSkpXG4gICAgLmZvbnQoZ2V0KHRoaXMucGFyYW0oJ2ZvbnQnKSkpXG4gICAgLmZvbnRTdHlsZShnZXQodGhpcy5wYXJhbSgnZm9udFN0eWxlJykpKVxuICAgIC5mb250V2VpZ2h0KGdldCh0aGlzLnBhcmFtKCdmb250V2VpZ2h0JykpKVxuICAgIC5mb250U2l6ZShmb250U2l6ZSlcbiAgICAud29yZHMoZGF0YS5tYXAod3JhcCkpIC8vIHdyYXAgdG8gYXZvaWQgdHVwbGUgd3JpdGVzXG4gICAgLm9uKCdlbmQnLCBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgdmFyIHNpemUgPSBsYXlvdXQuc2l6ZSgpLFxuICAgICAgICAgIGR4ID0gc2l6ZVswXSA+PiAxLFxuICAgICAgICAgIGR5ID0gc2l6ZVsxXSA+PiAxLFxuICAgICAgICAgIHcsIHQsIGksIGxlbjtcblxuICAgICAgZm9yIChpPTAsIGxlbj13b3Jkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgdyA9IHdvcmRzW2ldO1xuICAgICAgICB0ID0gdy5fdHVwbGU7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQueCwgdy54ICsgZHgpO1xuICAgICAgICBUdXBsZS5zZXQodCwgb3V0cHV0LnksIHcueSArIGR5KTtcbiAgICAgICAgVHVwbGUuc2V0KHQsIG91dHB1dC5mb250LCB3LmZvbnQpO1xuICAgICAgICBUdXBsZS5zZXQodCwgb3V0cHV0LmZvbnRTaXplLCB3LnNpemUpO1xuICAgICAgICBUdXBsZS5zZXQodCwgb3V0cHV0LmZvbnRTdHlsZSwgdy5zdHlsZSk7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQuZm9udFdlaWdodCwgdy53ZWlnaHQpO1xuICAgICAgICBUdXBsZS5zZXQodCwgb3V0cHV0LnJvdGF0ZSwgdy5yb3RhdGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLnN0YXJ0KCk7XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBmb3IgKHZhciBrZXkgaW4gb3V0cHV0KSBpbnB1dC5maWVsZHNbb3V0cHV0W2tleV1dID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JkY2xvdWQ7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFnZ3JlZ2F0ZTogICAgcmVxdWlyZSgnLi9BZ2dyZWdhdGUnKSxcbiAgYmluOiAgICAgICAgICByZXF1aXJlKCcuL0JpbicpLFxuICBjcm9zczogICAgICAgIHJlcXVpcmUoJy4vQ3Jvc3MnKSxcbiAgY291bnRwYXR0ZXJuOiByZXF1aXJlKCcuL0NvdW50UGF0dGVybicpLFxuICBsaW5rcGF0aDogICAgIHJlcXVpcmUoJy4vTGlua1BhdGgnKSxcbiAgZmFjZXQ6ICAgICAgICByZXF1aXJlKCcuL0ZhY2V0JyksXG4gIGZpbHRlcjogICAgICAgcmVxdWlyZSgnLi9GaWx0ZXInKSxcbiAgZm9sZDogICAgICAgICByZXF1aXJlKCcuL0ZvbGQnKSxcbiAgZm9yY2U6ICAgICAgICByZXF1aXJlKCcuL0ZvcmNlJyksXG4gIGZvcm11bGE6ICAgICAgcmVxdWlyZSgnLi9Gb3JtdWxhJyksXG4gIGdlbzogICAgICAgICAgcmVxdWlyZSgnLi9HZW8nKSxcbiAgZ2VvcGF0aDogICAgICByZXF1aXJlKCcuL0dlb1BhdGgnKSxcbiAgbG9va3VwOiAgICAgICByZXF1aXJlKCcuL0xvb2t1cCcpLFxuICBwaWU6ICAgICAgICAgIHJlcXVpcmUoJy4vUGllJyksXG4gIHNvcnQ6ICAgICAgICAgcmVxdWlyZSgnLi9Tb3J0JyksXG4gIHN0YWNrOiAgICAgICAgcmVxdWlyZSgnLi9TdGFjaycpLFxuICB0cmVlbWFwOiAgICAgIHJlcXVpcmUoJy4vVHJlZW1hcCcpLFxuICB2b3Jvbm9pOiAgICAgIHJlcXVpcmUoJy4vVm9yb25vaScpLFxuICB3b3JkY2xvdWQ6ICAgIHJlcXVpcmUoJy4vV29yZGNsb3VkJylcbn07IiwiLyogVGhpcyBtb2R1bGUgZGVmaW5lcyBhbmQgZXhwb3NlcyBKUyBwc2V1ZG8tY2xhc3NlcyB0byBzdXBwb3J0IGEgY29tcGxleCB2aWV3XG4gKiBtb2RlbCBmb3IgZWRpdGluZyBpbGx1c3RyYXRpb25zLlxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdGktdXRpbHMuanMnKSxcbiAgICBzdHlsaXN0ID0gcmVxdWlyZSgnLi9zdHlsaXN0LmpzJyk7XG5cbi8vZ2xvYmFsLnN0eWxpc3QgPSBzdHlsaXN0O1xuXG52YXIgVHJlZUlsbHVzdHJhdG9yID0gZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgJCwga28sIHN0eWxpc3QpIHtcblxuICAgIC8vIEV4cGxpY2l0bHkgY2hlY2sgZm9yIGRlcGVuZGVuY2llcyBieSBwYXNzaW5nIHRoZW0gYXMgYXJncyB0byB0aGUgbW9kdWxlXG4gICAgaWYgKHR5cGVvZigkKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbGVydChcIlRyZWVJbGx1c3RyYXRvciBtb2R1bGUgY2FuY2VsbGVkLCBuZWVkcyBqUXVlcnkgKGFzICckJylcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWtvIHx8IHR5cGVvZihrbykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFsZXJ0KFwiVHJlZUlsbHVzdHJhdG9yIG1vZHVsZSBjYW5jZWxsZWQsIG5lZWRzIEtub2Nrb3V0SlMgKGFzICdrbycpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFzdHlsaXN0IHx8IHR5cGVvZihzdHlsaXN0KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWxlcnQoXCJUcmVlSWxsdXN0cmF0b3IgbW9kdWxlIGNhbmNlbGxlZCwgbmVlZHMgJ3N0eWxpc3QnIG1vZHVsZSAoYXMgJ3N0eWxpc3QnKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHNvbWUgc2ltcGxlIGVudW1lcmF0aW9ucyAoZm9yIGxlZ2liaWxpdHksIGFuZCB0byBhdm9pZCB0eXBvcylcbiAgICB2YXIgdW5pdHMgPSB7XG4gICAgICAgIElOQ0hFUzogJ0lOQ0hFUycsXG4gICAgICAgIENFTlRJTUVURVJTOiAnQ0VOVElNRVRFUlMnXG4gICAgfTtcbiAgICB2YXIgY29sb3JEZXB0aHMgPSB7XG4gICAgICAgIEZVTExfQ09MT1I6ICdGVUxMX0NPTE9SJyxcbiAgICAgICAgR1JBWVNDQUxFOiAnR1JBWVNDQUxFJyxcbiAgICAgICAgQkxBQ0tfQU5EX1dISVRFOiAnQkxBQ0tfQU5EX1dISVRFJ1xuICAgIH07XG4gICAgdmFyIHRyZWVMYXlvdXRzID0ge1xuICAgICAgICBSRUNUQU5HTEU6ICdSRUNUQU5HTEUnLFxuICAgICAgICBDSVJDTEU6ICdDSVJDTEUnLFxuICAgICAgICBUUklBTkdMRTogJ1RSSUFOR0xFJ1xuICAgIH07XG4gICAgdmFyIGFsaWdubWVudHMgPSB7XG4gICAgICAgIFRPUDogJ1RPUCcsXG4gICAgICAgIFJJR0hUOiAnUklHSFQnLFxuICAgICAgICBCT1RUT006ICdCT1RUT00nLFxuICAgICAgICBMRUZUOiAnTEVGVCcsXG4gICAgICAgIENFTlRFUjogJ0NFTlRFUidcbiAgICB9O1xuICAgIHZhciBkYXRhU291cmNlVHlwZXMgPSB7XG4gICAgICAgIEJVSUxUX0lOOiAnQlVJTFRfSU4nLFxuICAgICAgICBVUkw6ICdVUkwnLFxuICAgICAgICBVUExPQUQ6ICdVUExPQUQnXG4gICAgfTtcbiAgICB2YXIgdmVyc2lvblR5cGVzID0ge1xuICAgICAgICBDSEVDS1NVTTogJ0NIRUNLU1VNJywgICAvLyBlLmcuLCBhIGdpdCBTSEFcbiAgICAgICAgVElNRVNUQU1QOiAnVElNRVNUQU1QJywgLy8gZS5nLiwgYSBtb2RpZmljYXRpb24gZGF0ZVxuICAgICAgICBTRU1BTlRJQzogJ1NFTUFOVElDJyAgICAvLyBhIGNvbnZlbnRpb25hbCB2ZXJzaW9uIG51bWJlciwgZS5nLiwgXCIzLjIuMGFcIlxuICAgIH07XG4gICAgdmFyIGhvc3RBcHBsaWNhdGlvbnMgPSB7XG4gICAgICAgIEpVUFlURVJfTk9URUJPT0s6ICdKVVBZVEVSX05PVEVCT09LJywgICAgLy8gYS5rLmEuIElQeXRob24gbm90ZWJvb2tcbiAgICAgICAgLy9UT0RPOiBBUkJPUl9XT1JLRkxPVzogJ0FSQk9SX1dPUktGTE9XJyBcbiAgICAgICAgLy9UT0RPOiBPUEVOVFJFRV9UT09MUzogJ09QRU5UUkVFX1RPT0xTJ1xuICAgICAgICBTVEFOREFMT05FOiAnU1RBTkRBTE9ORScgICAgICAgICAgICAgICAgIC8vIFwibmFrZWRcIiBzdHlsaXN0LCBwZXJoYXBzIGZyb20gYSBzdGF0aWMgZmlsZVxuICAgIH07XG5cbiAgICAvKiBIZXJlIHdlIGNhbiBzaGFyZSBpbmZvcm1hdGlvbiBhbW9uZyBhbGwgY2xhc3NlcyBhbmQgaW5zdGFuY2VzICovXG5cbiAgICAvKiBDYWNoZSBkYXRhIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb3IgcmVkdWNlIG5ldHdvcmsgdHJhZmZpYzogXG4gICAgICogICAtIHRyZWUgc291cmNlIGxvYWRlZCB2aWEgQUpBWFxuICAgICAqICAgLSBpbnRlcm1lZGlhdGUgdHJlZSBkYXRhIChhZnRlciBvbmUgb3IgbW9yZSB0cmFuc2Zvcm1zKVxuICAgICAqICAgLSBzdXBwb3J0aW5nIGRhdGFzZXRzXG4gICAgICogICAtIGV0Yy5cbiAgICAgKiBOb3RlIHRoYXQgaW5pdGlhbCB1c2UgaXMgYnkgdGhlICdzdGFzaCcgdHJhbnNmb3JtIGJlbG93LlxuICAgICAqL1xuICAgIHZhciBjYWNoZSA9IHsgfTtcbiAgICB2YXIgc2V0Q2FjaGVkRGF0YSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gYWRkIChvciB1cGRhdGUpIHRoZSBjYWNoZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZ2V0Q2FjaGVkRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyByZXRyaWV2ZSB0aGlzIGtleSdzIGNhY2hlIGZyb20gdGhlIGNhY2hlIChvciByZXR1cm4gbnVsbClcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpID8gY2FjaGVba2V5XSA6IG51bGw7XG4gICAgfVxuICAgIHZhciBjbGVhckNhY2hlZERhdGEgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gYWRkIChvciB1cGRhdGUpIHRoZSBjYWNoZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgfVxuXG4gICAgLyogUmV0dXJuIHRoZSBkYXRhIG1vZGVsIGZvciBhIG5ldyBpbGx1c3RyYXRpb24gKG91ciBKU09OIHJlcHJlc2VudGF0aW9uKSAqL1xuICAgIHZhciBnZXROZXdJbGx1c3RyYXRpb25Nb2RlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7XG4gICAgICAgICAgICAgICAgJ25hbWUnOiBcIlVudGl0bGVkIGlsbHVzdHJhdGlvblwiLFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IFwiXCIsXG4gICAgICAgICAgICAgICAgJ2F1dGhvcnMnOiBbIF0sICAgLy8gYXNzaWduIGltbWVkaWF0ZWx5IHRvIHRoaXMgdXNlcj9cbiAgICAgICAgICAgICAgICAndGFncyc6IFsgXSxcbiAgICAgICAgICAgICAgICAnZG9pcyc6IFsgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdHlsZUd1aWRlJzoge1xuICAgICAgICAgICAgICAgIC8vIG1heWJlIHRoZSBkZWZhdWx0cyBoZXJlIGFyZSBcImFueXRoaW5nIGdvZXNcIiAoYWxsIG9wdGlvbnMgZW5hYmxlZCk/XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXhwbGljaXRseSBsaXN0IGFsbCBvcHRpb25zIHNvbWV3aGVyZSBlbHNlPyBcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaWx0ZXIgc3R5bGVzIGlmIHRoZXkgZmFsbCBvdXQgb2YgY29uZm9ybWFuY2U/XG4gICAgICAgICAgICAgICAgJ25hbWUnOiBcIkRlZmF1bHQgc3R5bGVzXCIsXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzogXCJTdHlsZSBndWlkZXMgYXJlIHVzZWQgdG8gc3VnZ2VzdCBhbmQgY29uc3RyYWluIHRoZSBvdmVyYWxsIGxvb2sgb2YgeW91ciBpbGx1c3RyYXRpb24gZm9yIGEgcGFydGljdWxhciBwdWJsaWNhdGlvbiBvciBjb250ZXh0LiBZb3UgY2FuIHRyeSBkaWZmZXJlbnQgc3R5bGVzIHVzaW5nIHRoZSA8c3Ryb25nPkxvYWQgc3R5bGVzLi4uPC9zdHJvbmc+IGJ1dHRvbi5cIiwgLy8gY2FwdHVyZWQgd2hlbiBhc3NpZ25lZFxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB7J3R5cGUnOiBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU4sICd2YWx1ZSc6IFwiREVGQVVMVFwifSxcbiAgICAgICAgICAgICAgICAndmVyc2lvbic6IHsndHlwZSc6IHZlcnNpb25UeXBlcy5TRU1BTlRJQywgJ3ZhbHVlJzogXCIwLjFcIn0sXG4gICAgICAgICAgICAgICAgJ2NvbnN0cmFpbnRzJzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IGNvbnN0cmFpbmVkIGxhYmVscyBhbmQgdmFsdWVzLCBpZiBhbnkgKGl0ZW1zIG5vdCBsaXN0ZWQgYXJlIHVuY29uc3RyYWluZWQpXG4gICAgICAgICAgICAgICAgICAgICdwcmludFNpemVzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJMZXR0ZXIgc2l6ZSAocG9ydHJhaXQpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogOC41LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogMTEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bml0cyc6IHVuaXRzLklOQ0hFUyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkxldHRlciBzaXplIChsYW5kc2NhcGUpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogMTEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiA4LjUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bml0cyc6IHVuaXRzLklOQ0hFUyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIlF1YXJ0ZXItcGFnZSAocG9ydHJhaXQpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogNC4yNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IDUuNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXRzJzogdW5pdHMuSU5DSEVTIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiUXVhcnRlci1wYWdlIChsYW5kc2NhcGUpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogNS41LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogNC4yNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXRzJzogdW5pdHMuSU5DSEVTIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiQ3VzdG9tIHNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZm9udEZhbWlsaWVzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJUaW1lcyBOZXcgUm9tYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBcIlRpbWVzIE5ldyBSb21hbiwgVGltZXMsIHNlcmlmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkhlbHZldGljYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IFwiSGVsdmV0aWNhLCBBcmlhbCwgc2Fuc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJBcmlhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IFwiQXJpYWwsIHNhbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiU29tZXRoaW5nIGVsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnY29sb3JEZXB0aHMnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkZ1bGwgY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5GVUxMX0NPTE9SXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJHcmF5c2NhbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5HUkFZU0NBTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkJsYWNrIGFuZCB3aGl0ZSAobm8gZ3JheSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5CTEFDS19BTkRfV0hJVEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW1UZXh0U2l6ZSc6IDEyLCAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gcHQsIGJ1dCBlY2hvZWQgdXNpbmcgcGh5c2ljYWwgdW5pdHMgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW1MaW5lVGhpY2tuZXNzJzogMiwgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIHB0LCBidXQgZWNob2VkIHVzaW5nIHBoeXNpY2FsIHVuaXRzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBcIiNmZGRcIixcbiAgICAgICAgICAgICAgICAgICAgJ2JvcmRlcic6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZGVmYXVsdCBsaW5lIGNvbG9yLCB0aGlja25lc3MsIG5vZGUgc2hhcGUvc2l6ZSwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJzogXCIjNzc3XCIsXG4gICAgICAgICAgICAgICAgICAgICdlZGdlVGhpY2tuZXNzJzogMC44LFxuICAgICAgICAgICAgICAgICAgICAnbm9kZUNvbG9yJzogXCIjMzM5XCIsXG4gICAgICAgICAgICAgICAgICAgICdub2RlU2hhcGUnOiAnY2lyY2xlJyAgLy8gVE9ETzogc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICAvLyBjaG9pY2VzIGFuZCBvdmVycmlkZXMgZnJvbSB0aGUgc3R5bGUgZ3VpZGUgYWJvdmVcbiAgICAgICAgICAgICAgICAncHJpbnRTaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAndW5pdHMnOiB1bml0cy5JTkNIRVMsICAvLyBPUiB1bml0cy5DRU5USU1FVEVSU1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiA4LjUsICAvLyBpbiBwaHlzaWNhbCB1bml0c1xuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogMTEsICAgLy8gaW4gcGh5c2ljYWwgdW5pdHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb250RmFtaWx5JzogXCJUaW1lcyBOZXcgUm9tYW4sIFRpbWVzLCBzZXJpZlwiLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBcIiNmZGRcIixcbiAgICAgICAgICAgICAgICAnYm9yZGVyJzogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgLy8gYWRkIGRlZmF1bHQgbGluZSBjb2xvciwgdGhpY2tuZXNzLCBub2RlIHNoYXBlL3NpemUsIGV0Yy5cbiAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJzogXCIjNzc3XCIsXG4gICAgICAgICAgICAgICAgJ2VkZ2VUaGlja25lc3MnOiAwLjgsXG4gICAgICAgICAgICAgICAgJ25vZGVDb2xvcic6IFwiIzMzOVwiLFxuICAgICAgICAgICAgICAgICdub2RlU2hhcGUnOiAnY2lyY2xlJyAgLy8gVE9ETzogc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgIHZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2VsZW1lbnRzJzogW1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICd2ZWdhU3BlYyc6IHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiA4MDAsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IDkwMCxcbiAgICAgICAgICAgICAgICAncGFkZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdyaWdodCc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkYXRhJzogWyBdLFxuICAgICAgICAgICAgICAgICdzdHlsZSc6IHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBUT0RPOiBBcHBseSBvcHRpb25hbCBtb2RpZmljYXRpb25zP1xuICAgICAgICBpZiAob3B0aW9ucy5CTEFIKSB7XG4gICAgICAgICAgICBvYmoubWV0YWRhdGEuRk9PID0gJ0JBUic7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyogUmV0dXJuIHRoZSBkYXRhIG1vZGVsIGZvciBhIG5ldyB0cmVlIChvdXIgSlNPTiByZXByZXNlbnRhdGlvbikgKi9cbiAgICB2YXIgZ2V0TmV3SWxsdXN0cmF0ZWRUcmVlTW9kZWwgPSBmdW5jdGlvbihpbGx1c3RyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBuZXdJRCA9IGlsbHVzdHJhdGlvbi5nZXROZXh0QXZhaWxhYmxlSUQoJ3RyZWUnKTsgXG4gICAgICAgIHZhciBsYW5kbWFya3MgPSBzdHlsaXN0LmdldFByaW50QXJlYUxhbmRtYXJrcygpO1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgJ2lkJzogbmV3SUQsXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnSWxsdXN0cmF0ZWRUcmVlJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVW50aXRsZWQgKFwiKyBuZXdJRCArXCIpXCIsXG4gICAgICAgICAgICAgICAgJ3NvdXJjZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU4sIFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiAnLi9wbGFjZWhvbGRlci10cmVlLmpzb24nLFxuICAgICAgICAgICAgICAgICAgICAncGh5bGVzeXN0ZW1TdHVkeUlEJzogJycsXG4gICAgICAgICAgICAgICAgICAgICdwaHlsZXN5c3RlbVRyZWVJRCc6ICcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiBcIlwiLFxuICAgICAgICAgICAgICAgICdkb2lzJzogWyBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RhdGEnOiB7IH0sXG4gICAgICAgICAgICAnbGF5b3V0JzogdHJlZUxheW91dHMuQ0lSQ0xFLFxuICAgICAgICAgICAgLyogT3ZlcmxvYWQgdGhlIG1vZGVsIHdpdGggYWxsIGxheW91dCBwcm9wZXJ0aWVzLiBXZSdsbCB1c2UgdGhlXG4gICAgICAgICAgICAgKiBvbmVzIHRoYXQgY3VycmVudCBhcHBseSAqYW5kKiByZXRhaW4gbGFzdC1rbm93biB2YWx1ZXMgZm9yXG4gICAgICAgICAgICAgKiBvdGhlcnMsIGluIGNhc2UgdGhlIHVzZXIgc3dpdGNoZXMgYmFjayB0byBhIHByaW9yIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnd2lkdGgnOiBsYW5kbWFya3Mud2lkdGggKiAwLjQsXG4gICAgICAgICAgICAnaGVpZ2h0JzogbGFuZG1hcmtzLmhlaWdodCAqIDAuNCxcbiAgICAgICAgICAgICdyYWRpdXMnOiBNYXRoLm1pbihsYW5kbWFya3MuaGVpZ2h0LCBsYW5kbWFya3Mud2lkdGgpICogMC4zLFxuICAgICAgICAgICAgJ3RpcHNBbGlnbm1lbnQnOiBhbGlnbm1lbnRzLlJJR0hULFxuICAgICAgICAgICAgJ3Jvb3RYJzogbGFuZG1hcmtzLmNlbnRlclggKyB1dGlscy5qaWdnbGUoNSksICAgLy8gVE9ETzogdXNlIGEgYm91bmRpbmcgYm94IGluc3RlYWQ/XG4gICAgICAgICAgICAncm9vdFknOiBsYW5kbWFya3MuY2VudGVyWSArIHV0aWxzLmppZ2dsZSg1KSxcbiAgICAgICAgICAgICdub2RlTGFiZWxGaWVsZCc6ICdvdHRUYXhvbk5hbWUnLCAgICAgICAgIC8vIG1hdGNoZXMgdGhlIHBsYWNlaG9sZGVyIHRyZWVcbiAgICAgICAgICAgICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsLiBvbmx5IGRldmlhdGlvbnMgZnJvbSB0aGUgc3R5bGUgZ3VpZGUgYWJvdmU/XG4vKlxuICAgICAgICAgICAgICAgICdlZGdlVGhpY2tuZXNzJzogMS4wLCAgXG4gICAgICAgICAgICAgICAgJ2VkZ2VDb2xvcic6ICcjOTk5JyxcbiAgICAgICAgICAgICAgICAnbGFiZWxUZXh0SGVpZ2h0JzogaWxsdXN0cmF0aW9uLnN0eWxlR3VpZGUuY29uc3RyYWludHMubWluaW11bVRleHRTaXplKClcbiovXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvKiBUT0RPOiBBcHBseSBvcHRpb25hbCBtb2RpZmljYXRpb25zP1xuICAgICAgICBpZiAob3B0aW9ucy5CTEFIKSB7XG4gICAgICAgICAgICBvYmoubWV0YWRhdGEuRk9PID0gJ0JBUic7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyogUmV0dXJuIHRoZSBkYXRhIG1vZGVsIGZvciBhIG5ldyBkYXRhc2V0IChvdXIgSlNPTiByZXByZXNlbnRhdGlvbikgKi9cbiAgICB2YXIgZ2V0TmV3U3VwcG9ydGluZ0RhdGFzZXRNb2RlbCA9IGZ1bmN0aW9uKGlsbHVzdHJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG5ld0lEID0gaWxsdXN0cmF0aW9uLmdldE5leHRBdmFpbGFibGVJRCgnZGF0YXNldCcpOyBcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICdpZCc6IG5ld0lELFxuICAgICAgICAgICAgJ21ldGFkYXRhJzoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ1N1cHBvcnRpbmdEYXRhc2V0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVW50aXRsZWQgKFwiKyBuZXdJRCArXCIpXCIsXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzogXCJcIixcbiAgICAgICAgICAgICAgICAnZG9pcyc6IFsgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkYXRhJzogeyB9LFxuICAgICAgICAgICAgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgIC8vIGluY2wuIG9ubHkgZGV2aWF0aW9ucyBmcm9tIHRoZSBzdHlsZSBndWlkZSBhYm92ZT9cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8qIFRPRE86IEFwcGx5IG9wdGlvbmFsIG1vZGlmaWNhdGlvbnM/XG4gICAgICAgIGlmIChvcHRpb25zLkJMQUgpIHtcbiAgICAgICAgICAgIG9iai5tZXRhZGF0YS5GT08gPSAnQkFSJztcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKiBSZXR1cm4gdGhlIGRhdGEgbW9kZWwgZm9yIGEgbmV3IG9ybmFtZW50IChvdXIgSlNPTiByZXByZXNlbnRhdGlvbikgKi9cbiAgICB2YXIgZ2V0TmV3T3JuYW1lbnRNb2RlbCA9IGZ1bmN0aW9uKGlsbHVzdHJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG5ld0lEID0gaWxsdXN0cmF0aW9uLmdldE5leHRBdmFpbGFibGVJRCgnb3JuYW1lbnQnKTsgXG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAnaWQnOiBuZXdJRCxcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdPcm5hbWVudCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiBcIlVudGl0bGVkIChcIisgbmV3SUQgK1wiKVwiLFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGF0YSc6IHsgfSxcbiAgICAgICAgICAgICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsLiBvbmx5IGRldmlhdGlvbnMgZnJvbSB0aGUgc3R5bGUgZ3VpZGUgYWJvdmU/XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvKiBUT0RPOiBBcHBseSBvcHRpb25hbCBtb2RpZmljYXRpb25zP1xuICAgICAgICBpZiAob3B0aW9ucy5CTEFIKSB7XG4gICAgICAgICAgICBvYmoubWV0YWRhdGEuRk9PID0gJ0JBUic7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyogT3VyIHByaW5jaXBsZSB2aWV3IG1vZGVsIFsxXSBpcyBhIHNpbmdsZSBpbGx1c3RyYXRpb24uIFRoaXMgdXNlcyBiYXNpY1xuICAgICAqIEtub2Nrb3V0IG9ic2VydmFibGVzIGFzIG1lbWJlcnMsIGJ1dCBhZGRzIGN1c3RvbSBiZWhhdmlvci4gV2UnbGwgdXNlIGFcbiAgICAgKiBmYW1pbHkgb2YgcHNldWRvLWNsYXNzZXMgdG8gZGVmaW5lIHRoZSBtYWluIGlsbHVzdHJhdGlvbiBhbmQgc2VsZWN0ZWQgcGFydHMuXG4gICAgICpcbiAgICAgKiBbMV0gaHR0cDovL2tub2Nrb3V0anMuY29tL2RvY3VtZW50YXRpb24vb2JzZXJ2YWJsZXMuaHRtbFxuICAgICAqL1xuICAgIHZhciBJbGx1c3RyYXRpb24gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgSWxsdXN0cmF0aW9uKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElsbHVzdHJhdGlvbihkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YoZGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBsb2FkIHRoZSBcImVtcHR5XCIgaWxsdXN0cmF0aW9uIG9iamVjdCBhYm92ZVxuICAgICAgICAgICAgZGF0YSA9IGdldE5ld0lsbHVzdHJhdGlvbk1vZGVsKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLyogZGVmaW5lIFBSSVZBVEUgbWVtYmVycyAodmFyaWFibGVzIGFuZCBtZXRob2RzKWZ1bmN0aW9ucyBhbmQgd2l0aCAndmFyJyAqL1xuXG4gICAgICAgIC8qIFdlJ2xsIG5lZWQgdG8gbWludCBhIHVuaXF1ZSwgc2VyaWFsIElEIGZvciBlYWNoIG5ldyBpbGx1c3RyYXRpb25cbiAgICAgICAgICogZWxlbWVudC4gU2luY2Ugd2UgaGF2ZSBhIHJlYXNvbmFibGUgbnVtYmVyIG9mIGVsZW1lbnRzLCB3ZSBjYW5cbiAgICAgICAgICogc2V0IHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgYW4gaWxsdXN0cmF0aW9uIGFzIGl0IGxvYWRzLCBieSBzY2FubmluZ1xuICAgICAgICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudHMgb2YgZWFjaCB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG5leHRBdmFpbGFibGVJRCA9IHtcbiAgICAgICAgICAgICd0cmVlJzogMCxcbiAgICAgICAgICAgICdkYXRhc2V0JzogMCxcbiAgICAgICAgICAgICdvcm5hbWVudCc6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRWFjaCBlbGVtZW50IG5pY2tuYW1lIGFib3ZlIGlzIHVzZWQgaW4gSURzLCBlZy4gJ3RyZWUtMzInXG4gICAgICAgIHZhciBpbml0U2VyaWFsRWxlbWVudElEcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYVR5cGUgaW4gbmV4dEF2YWlsYWJsZUlEKSB7XG4gICAgICAgICAgICAgICAgbmV4dEF2YWlsYWJsZUlEWyBhVHlwZSBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaWdoZXN0VHJlZUlERm91bmQgPSAwO1xuICAgICAgICAgICAgdmFyIGhpZ2hlc3REYXRhc2V0SURGb3VuZCA9IDA7XG4gICAgICAgICAgICB2YXIgaGlnaGVzdE9ybmFtZW50SURGb3VuZCA9IDA7XG5cbiAgICAgICAgICAgICQuZWFjaChzZWxmLmVsZW1lbnRzKCksIGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZWwuaWQoKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpdHNTZXJpYWxJRCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgbmV4dEF2YWlsYWJsZUlEWyBlbGVtZW50VHlwZSBdID0gTWF0aC5tYXgoIFxuICAgICAgICAgICAgICAgICAgICBpdHNTZXJpYWxJRCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dEF2YWlsYWJsZUlEWyBlbGVtZW50VHlwZSBdIFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyogZGVmaW5lIFBVQkxJQyB2YXJpYWJsZXMgKGFuZCBwcml2aWxlZ2VkIG1ldGhvZHMpIHdpdGggJ3NlbGYnICovXG5cbiAgICAgICAgc2VsZi5nZXROZXh0QXZhaWxhYmxlSUQgPSBmdW5jdGlvbiggZWxlbWVudFR5cGUgKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIGEgc2VyaWFsIElEIGxpa2UgJ2RhdGFzZXQtNCcgb3IgJ3RyZWUtMTInXG4gICAgICAgICAgICB2YXIgcmVhZHlJRCA9IG5leHRBdmFpbGFibGVJRFsgZWxlbWVudFR5cGUgXTtcbiAgICAgICAgICAgIG5leHRBdmFpbGFibGVJRFsgZWxlbWVudFR5cGUgXSA9IHJlYWR5SUQgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50VHlwZSArJy0nKyBuZXh0QXZhaWxhYmxlSURbIGVsZW1lbnRUeXBlIF0pO1xuICAgICAgICB9IFxuXG4gICAgICAgIC8vIFJFTUlOREVSOiBjb21wdXRlZCBvYnNlcnZhYmxlcyBzaG91bGQgdXNlICdkZWZlckV2YWx1YXRpb24nIGluXG4gICAgICAgIC8vIGNhc2UgdGhlaXIgZGVwZW5kZW5jaWVzIHdpbGwgYXBwZWFyIGR1cmluZyBrby5tYXBwaW5nXG4gICAgICAgIHNlbGYuc3R5bGVHdWlkZVNvdXJjZUhUTUwgPSBrby5jb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2goc2VsZi5zdHlsZUd1aWRlLnNvdXJjZS50eXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGRhdGFTb3VyY2VUeXBlcy5VUkw6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdHNVUkwgPSBzZWxmLnN0eWxlR3VpZGUuc291cmNlLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj0nKyBpdHNVUkwgKycgdGFyZ2V0PVwiX2JsYW5rXCI+JysgaXRzVVJMICsnPC9hPic7XG4gICAgICAgICAgICAgICAgY2FzZSBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJ1aWx0LWluXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJVbmRlZmluZWRcIjsgXG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYudXNlQ2hvc2VuUHJpbnRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZU5hbWUgPSAkKCcjc3R5bGUtZG9jc2l6ZS1jaG9vc2VyJykudmFsKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRTaXplID0gZ2V0UHJpbnRTaXplQnlOYW1lKCBzaXplTmFtZSApO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzZUNob3NlblByaW50U2l6ZSgpOiBubyBtYXRjaGluZyBzaXplIGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFNpemUudW5pdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gc2l6ZSBzaG91bGQgcmV0YWluIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLnByaW50U2l6ZS53aWR0aCggc2VsZWN0ZWRTaXplLndpZHRoKCkgKTtcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoIHNlbGVjdGVkU2l6ZS5oZWlnaHQoKSApO1xuICAgICAgICAgICAgICAgIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCBzZWxlY3RlZFNpemUudW5pdHMoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlzaWJsZSBjYW52YXMgYW5kIGQzIHZpelxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYudXBkYXRlUHJpbnRTaXplQ2hvb3NlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gKGRlKXNlbGVjdCBtYXRjaGluZyBzaXplIGFmdGVyIG1hbnVhbCBhZGp1c3RtZW50c1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nU2l6ZSA9ICQuZ3JlcChcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMucHJpbnRTaXplcygpLCBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCd1bml0cycgaW4gbykpIHJldHVybiBmYWxzZTsgLy8gJ0N1c3RvbSBzaXplJyBuZXZlciBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdXNlIG9mICE9IGluc3RlYWQgb2YgIT09IGJlbG93LCBiZWNhdXNlIFwiMTFcIiA9PSAxMVxuICAgICAgICAgICAgICAgICAgICBpZiAoby51bml0cygpICE9IHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ud2lkdGgoKSAhPSBzZWxmLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLmhlaWdodCgpICE9IHNlbGYuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClbMF07XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdTaXplTmFtZSA9ICdDdXN0b20gc2l6ZSc7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTaXplTmFtZSA9IG1hdGNoaW5nU2l6ZS5uYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCcjc3R5bGUtZG9jc2l6ZS1jaG9vc2VyJykudmFsKG1hdGNoaW5nU2l6ZU5hbWUpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlzaWJsZSBjYW52YXMgYW5kIGQzIHZpelxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRQcmludFNpemVCeU5hbWUgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ1NpemUgPSAkLmdyZXAoXG4gICAgICAgICAgICAgICAgc2VsZi5zdHlsZUd1aWRlLmNvbnN0cmFpbnRzLnByaW50U2l6ZXMoKSwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5uYW1lKCkgPT09IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hpbmdTaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2V0UHJpbnRTaXplQnluYW1lKCk6IG5vIHN1Y2ggc2l6ZSBhcyBcIicrIG5hbWUgKydcIiEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi51bml0c0Z1bGxOYW1lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2goIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5JTkNIRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluY2hlc1wiXG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5DRU5USU1FVEVSUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY2VudGltZXRlcnNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VsZiwge2RlZmVyRXZhbHVhdGlvbjp0cnVlfSk7XG4gICAgICAgIHNlbGYudW5pdHNEaXNwbGF5QWJicmV2aWF0aW9uID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2goIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5JTkNIRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluLlwiXG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5DRU5USU1FVEVSUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VsZiwge2RlZmVyRXZhbHVhdGlvbjp0cnVlfSk7XG4gICAgICAgIHNlbGYudW5pdHNDc3NTdWZmaXggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCggc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSApIHtcbiAgICAgICAgICAgICAgICBjYXNlIHVuaXRzLklOQ0hFUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5cIlxuICAgICAgICAgICAgICAgIGNhc2UgdW5pdHMuQ0VOVElNRVRFUlM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNtXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYudXNlQ2hvc2VuRm9udEZhbWlseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gJCgnI3N0eWxlLWZvbnRmYW1pbHktY2hvb3NlcicpLnZhbCgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRm9udCA9IGdldEZvbnRGYW1pbHlCeU5hbWUoIGZvbnROYW1lICk7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkRm9udCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNlQ2hvc2VuRm9udEZhbWlseSgpOiBubyBtYXRjaGluZyBmb250IGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEZvbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gc2l6ZSBzaG91bGQgcmV0YWluIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLmZvbnRGYW1pbHkoIHNlbGVjdGVkRm9udC52YWx1ZSgpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9udE5hbWUgPT09ICdTb21ldGhpbmcgZWxzZScpIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1vcHRpb25zJykuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1vcHRpb25zJykuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnVwZGF0ZUZvbnRGYW1pbHlDaG9vc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAoZGUpc2VsZWN0IG1hdGNoaW5nIGZvbnQgYWZ0ZXIgbWFudWFsIGFkanVzdG1lbnRzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGb250ID0gJC5ncmVwKFxuICAgICAgICAgICAgICAgIHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5mb250RmFtaWxpZXMoKSwgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgndmFsdWUnIGluIG8pKSByZXR1cm4gZmFsc2U7IC8vICdTb21ldGhpbmcgZWxzZScgbmV2ZXIgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoby52YWx1ZSgpICE9PSBzZWxmLnN0eWxlLmZvbnRGYW1pbHkoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApWzBdO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRm9udE5hbWUgPSAnU29tZXRoaW5nIGVsc2UnO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRm9udCkge1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nRm9udE5hbWUgPSBtYXRjaGluZ0ZvbnQubmFtZSgpO1xuICAgICAgICAgICAgICAgICQoJyNzdHlsZS1mb250ZmFtaWx5LW9wdGlvbnMnKS5oaWRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNzdHlsZS1mb250ZmFtaWx5LW9wdGlvbnMnKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1jaG9vc2VyJykudmFsKG1hdGNoaW5nRm9udE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0Rm9udEZhbWlseUJ5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRm9udCA9ICQuZ3JlcChcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMuZm9udEZhbWlsaWVzKCksIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ubmFtZSgpID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoaW5nRm9udCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dldEZvbnRGYW1pbHlCeW5hbWUoKTogbm8gc3VjaCBmb250IGFzIFwiJysgbmFtZSArJ1wiIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nRm9udDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubWluVGV4dFNpemVIZWxwZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhpcyBzaXplIGluIGNob3NlbiB1bml0c1xuICAgICAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU2l6ZSA9IHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtVGV4dFNpemUoKTtcbiAgICAgICAgICAgIGlmIChpc05hTihjaG9zZW5TaXplKSB8fCAkLnRyaW0oY2hvc2VuU2l6ZSkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0cyBhbnkgbm9uLW51bWVyaWMgY2hhcnMsIGFsbG93cyB3aGl0ZXNwYWNlIGFuZCBkZWNpbWFsXG4gICAgICAgICAgICAgICAgaHRtbCA9ICc8ZW0+VGhpcyB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyPC9lbT4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlY2hvIHRoZSBuZXcgc2l6ZSAoaW4gcHQpIGFzIGluY2hlcy9jbVxuICAgICAgICAgICAgICAgIGNob3NlblNpemUgPSBwYXJzZUZsb2F0KGNob3NlblNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRTaXplID0gc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gdW5pdHMuSU5DSEVTID9cbiAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5wb2ludHNUb0luY2hlcyggY2hvc2VuU2l6ZSApIDpcbiAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5wb2ludHNUb0NlbnRpbWV0ZXJzKCBjaG9zZW5TaXplICk7XG4gICAgICAgICAgICAgICAgY29udmVydGVkU2l6ZSA9IGNvbnZlcnRlZFNpemUudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdFN1ZmZpeCA9IHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgPT09IHVuaXRzLklOQ0hFUyA/XG4gICAgICAgICAgICAgICAgICAgICdpbmNoZXMnIDogJ2NtJztcbiAgICAgICAgICAgICAgICBodG1sID0gJ3B0ICZuYnNwOygnKyBjb252ZXJ0ZWRTaXplICsnICcrIHVuaXRTdWZmaXggKycpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9LCBzZWxmLCB7ZGVmZXJFdmFsdWF0aW9uOnRydWV9KTtcblxuICAgICAgICBzZWxmLm1pbkxpbmVUaGlja25lc3NIZWxwZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhpcyBzaXplIGluIGNob3NlbiB1bml0c1xuICAgICAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU2l6ZSA9IHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtTGluZVRoaWNrbmVzcygpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGNob3NlblNpemUpIHx8ICQudHJpbShjaG9zZW5TaXplKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyByZWplY3RzIGFueSBub24tbnVtZXJpYyBjaGFycywgYWxsb3dzIHdoaXRlc3BhY2UgYW5kIGRlY2ltYWxcbiAgICAgICAgICAgICAgICBodG1sID0gJzxlbT5UaGlzIHZhbHVlIG11c3QgYmUgYSBudW1iZXI8L2VtPic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVjaG8gdGhlIG5ldyBzaXplIChpbiBwdCkgYXMgaW5jaGVzL2NtXG4gICAgICAgICAgICAgICAgY2hvc2VuU2l6ZSA9IHBhcnNlRmxvYXQoY2hvc2VuU2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFNpemUgPSBzZWxmLnN0eWxlLnByaW50U2l6ZS51bml0cygpID09PSB1bml0cy5JTkNIRVMgP1xuICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LnBvaW50c1RvSW5jaGVzKCBjaG9zZW5TaXplICkgOlxuICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LnBvaW50c1RvQ2VudGltZXRlcnMoIGNob3NlblNpemUgKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRTaXplID0gY29udmVydGVkU2l6ZS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICAgIHZhciB1bml0U3VmZml4ID0gc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gdW5pdHMuSU5DSEVTID9cbiAgICAgICAgICAgICAgICAgICAgJ2luY2hlcycgOiAnY20nO1xuICAgICAgICAgICAgICAgIGh0bWwgPSAncHQgJm5ic3A7KCcrIGNvbnZlcnRlZFNpemUgKycgJysgdW5pdFN1ZmZpeCArJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYubW92ZUVsZW1lbnRVcCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wTGlzdCA9IHNlbGYuZWxlbWVudHMoKS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3MgPSAkLmluQXJyYXkoZWwsIHRlbXBMaXN0KTtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gY3VycmVudFBvcyAtIDE7XG4gICAgICAgICAgICAgIHRlbXBMaXN0W2N1cnJlbnRQb3NdID0gdGVtcExpc3RbcHJldmlvdXNQb3NdO1xuICAgICAgICAgICAgICB0ZW1wTGlzdFtwcmV2aW91c1Bvc10gPSBlbDtcbiAgICAgICAgICAgICAgc2VsZi5lbGVtZW50cyh0ZW1wTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5tb3ZlRWxlbWVudERvd24gPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICB2YXIgdGVtcExpc3QgPSBzZWxmLmVsZW1lbnRzKCkuc2xpY2UoMCk7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zID0gJC5pbkFycmF5KGVsLCB0ZW1wTGlzdCk7XG4gICAgICAgICAgICAgIHZhciBuZXh0UG9zID0gY3VycmVudFBvcyArIDE7XG4gICAgICAgICAgICAgIHRlbXBMaXN0W2N1cnJlbnRQb3NdID0gdGVtcExpc3RbbmV4dFBvc107XG4gICAgICAgICAgICAgIHRlbXBMaXN0W25leHRQb3NdID0gZWw7XG4gICAgICAgICAgICAgIHNlbGYuZWxlbWVudHModGVtcExpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY29uZmlybVJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lLCByZW1vdmVNZXRob2Q7XG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBJbGx1c3RyYXRlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhpcyB0cmVlPyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlSWxsdXN0cmF0ZWRUcmVlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgU3VwcG9ydGluZ0RhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhpcyBkYXRhc2V0PyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU3VwcG9ydGluZ0RhdGFzZXQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBPcm5hbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHJlbW92ZSB0aGlzIG9ybmFtZW50PyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlT3JuYW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNvbmZpcm1SZW1vdmVFbGVtZW50KCk6IHVuZXhwZWNlZCBlbGVtZW50IHR5cGU6ICdcIisgZWwubWV0YWRhdGEudHlwZSgpICtcIichXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEluc3RlYWQgb2YgZXhwbGljaXRseSBkZWZpbmluZyBhbGwgcG9zc2libGUgbWVtYmVycywgbGV0J3NcbiAgICAgICAgICogdHJ1c3QgdGhlIGtvLm1hcHBpbmcgcGx1Z2luIHRvIGhhbmRsZSBsb2FkaW5nIGFuZCBzYXZpbmcgXG4gICAgICAgICAqIGlsbHVzdHJhdGlvbiBkYXRhIGZyb20gSlMoT04pLCB3aXRoIG1hcHBpbmcgb3B0aW9ucyB0byBoYW5kbGVcbiAgICAgICAgICogYW55IGV4Y2VwdGlvbmFsIHN0dWZmLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1hcHBpbmdPcHRpb25zID0ge1xuICAgICAgICAgICAgLyogVXNlIHRvIGhhbmRsZSBzcGVjaWFsIGNhc2VzOlxuICAgICAgICAgICAgICogICdpZ25vcmUnIHRvIGtlZXAgc29tZSBjbHV0dGVyIG91dCBvZiB0aGUgc2F2ZWQgbW9kZWxcbiAgICAgICAgICAgICAqICAnaW5jbHVkZScgdG8gZm9yY2Ugdmlldy1tb2RlbCBwcm9wZXJ0aWVzIHRvIGJlIHNhdmVkXG4gICAgICAgICAgICAgKiAgJ2NvcHknIHRvIGtlZXAgc2ltcGxlIHZhbHVlcyBzaW1wbGUgKHZzLiBvYnNlcnZhYmxlKVxuICAgICAgICAgICAgICogICdvYnNlcnZlJyBPTkxZIGlmIGl0J3MgZWFzaWVyIHRvIHdoaXRlbGlzdCB0aGUgb2JzZXJ2YWJsZXNcbiAgICAgICAgICAgICAqICAnY3JlYXRlJyBtYXAgc29tZSBlbGVtZW50cyB0byBvYmplY3QgY2xhc3Nlc1xuICAgICAgICAgICAgICogICd1cGRhdGUnPyBjb252ZXJ0IERhdGVzIHRvIElTTyBkYXRlLXN0cmluZ3MsIGludHMgdG8gZmxvYXRzXG4gICAgICAgICAgICAgKiAgJ2tleSc6IHBpbiBlbGVtZW50cyB0byBzcGVjaWZpZWQga2V5c1xuICAgICAgICAgICAgICogU2VlIGh0dHA6Ly9rbm9ja291dGpzLmNvbS9kb2N1bWVudGF0aW9uL3BsdWdpbnMtbWFwcGluZy5odG1sXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdpZ25vcmUnOiBbICdjb25zdHJ1Y3RvcicgXSxcbiAgICAgICAgICAgICdpbmNsdWRlJzogWyBdLFxuICAgICAgICAgICAgJ2NvcHknOiBbICd2ZWdhU3BlYycgXSxcbiAgICAgICAgICAgIC8vICdvYnNlcnZlJzogWyBdLCAvLyBXQVJOSU5HOiB1c2luZyB0aGlzIGZsaXBzIGRlZmF1bHQgbWFwcGluZyFcbiAgICAgICAgICAgICdlbGVtZW50cyc6IHtcbiAgICAgICAgICAgICAgICAnY3JlYXRlJzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlc2UgYXMgb2JqZWN0IGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFQYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pbGx1c3RyYXRpb24gPSBzZWxmO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZGF0YS5tZXRhZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIGlsbHVzdHJhdGlvbiB0byBnZXQgSURzIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSWxsdXN0cmF0ZWRUcmVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElsbHVzdHJhdGVkVHJlZShfaWxsdXN0cmF0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1N1cHBvcnRpbmdEYXRhc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1cHBvcnRpbmdEYXRhc2V0KF9pbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT3JuYW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3JuYW1lbnQoX2lsbHVzdHJhdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBpdCBzaW1wbGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGVsZW1lbnQgdHlwZSAnXCIrIGRhdGEubWV0YWRhdGEudHlwZSArXCInISBDcmVhdGluZyBhIGdlbmVyaWMgb2JzZXJ2YWJsZS4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtvLm9ic2VydmFibGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAna2V5JzogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgJ2lkJyBhdHRyaWJ1dGUgdG8gcGluIHRoZXNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogTWFwIGluY29taW5nIGRhdGEgZnJvbSBhIEpTIG9iamVjdC4gTk9URSB0aGF0IHdlIGNhbiBhbHNvIGRvIFxuICAgICAgICAgKiB0aGlzIHBpZWNlbWVhbCB0byAoZm9yIGV4YW1wbGUpIGFwcGx5IG5ldyBzdHlsZXMgdG8gYW4gaWxsdXN0cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBBZGQgc29tZSB2YWxpY2F0aW9uIG9yIG90aGVyIHNhbml0eSBjaGVja3MgYWZ0ZXIgbWFwcGluZywgdG9cbiAgICAgICAgICogbWFrZSBzdXJlIHdlJ3JlIG5vdCBnZXR0aW5nIG5vbnNlbnNlIGZyb20gdGhlIHNhdmVkIG1vZGVsP1xuICAgICAgICAgKi9cbiAgICAgICAga28ubWFwcGluZy5mcm9tSlMoZGF0YSwgbWFwcGluZ09wdGlvbnMsIHNlbGYpO1xuXG4gICAgICAgIC8vIEFkZCB2YWxpZGF0aW9uIGZvciBmaWVsZHMgdGhhdCBuZWVkIGl0XG4gICAgICAgIHNlbGYubWV0YWRhdGEubmFtZS5leHRlbmQoe3JlcXVpcmVkOiB0cnVlfSk7XG5cbiAgICAgICAgLy8gUmVzZXQgc2VyaWFsIGVsZW1lbnQgSURzIGZvciB0aGlzIGlsbHVzdHJhdGlvblxuICAgICAgICBpbml0U2VyaWFsRWxlbWVudElEcygpO1xuXG4gICAgICAgIHNlbGYuZXhwb3J0TW9kZWxBc09iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IGtvLm1hcHBpbmcudG9KUyhzZWxmKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGFueSBjbGVhbnVwIGhlcmU/XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuZXhwb3J0TW9kZWxBc0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBqc29uID0ga28ubWFwcGluZy50b0pTT04oc2VsZik7XG4gICAgICAgICAgICAvLyBUT0RPOiBhbnkgY2xlYW51cCBoZXJlP1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH07XG5cbiAgICB9XG4gICAgLyogZGVmaW5lIFBVQkxJQyBtZXRob2RzICh0aGF0IGRvbid0IG5lZWQgcHJpdmF0ZSBkYXRhKSBpbiBpdHMgcHJvdG90eXBlICovXG4gICAgSWxsdXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IElsbHVzdHJhdGlvbixcblxuICAgICAgICBhcHBseVN0eWxlR3VpZGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIElsbHVzdHJhdGlvbi5tYXBwaW5nT3B0aW9ucywgc2VsZi5zdHlsZUd1aWRlKTtcblxuICAgICAgICAgICAgLyogU29tZSBwcm9wZXJ0aWVzIGFyZSAqZm9yY2VkKiAocmF0aGVyIHRoZW4gc3VnZ2VzdGVkKSB0byBjb21wbHlcbiAgICAgICAgICAgICAqIHdpdGggdGhlIGFjdGl2ZSBzdHlsZSBndWlkZS4gXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogUmVjb25zaWRlciB0aGlzISBFYWNoIGZpZWxkIHNob3VsZCBwcm9iYWJseSBiZSBkZWZpbmVkXG4gICAgICAgICAgICAgKiBlaXRoZXIgYXMgYSBjb25zdHJhaW50IE9SIGEgcGVyLWlsbHVzdHJhdGlvbiAqIHN0eWxlIGFzc2VydGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGZvcmNlZFN0eWxlcyA9IFtcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyJyxcbiAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAnZWRnZVRoaWNrbmVzcycsXG4gICAgICAgICAgICAgICAgJ25vZGVDb2xvcicsXG4gICAgICAgICAgICAgICAgJ25vZGVTaGFwZSdcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAkLmVhY2goZm9yY2VkU3R5bGVzLCBmdW5jdGlvbihpLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3R5bGVbcHJvcE5hbWVdKCBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHNbcHJvcE5hbWVdKCkgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVByaW50U2l6ZUNob29zZXIoKTtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlRm9udEZhbWlseUNob29zZXIoKTtcbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZElsbHVzdHJhdGVkVHJlZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHJlZSA9IG5ldyBJbGx1c3RyYXRlZFRyZWUoc2VsZik7XG4gICAgICAgICAgICBzZWxmLmVsZW1lbnRzLnB1c2godHJlZSk7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJbGx1c3RyYXRlZFRyZWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucmVtb3ZlKHRyZWUpO1xuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgICAgICBkZWxldGUgdHJlZTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRTdXBwb3J0aW5nRGF0YXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZHMgID0gbmV3IFN1cHBvcnRpbmdEYXRhc2V0KHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50cy5wdXNoKGRzKTtcbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgcmV0dXJuIGRzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVTdXBwb3J0aW5nRGF0YXNldDogZnVuY3Rpb24oZHMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucmVtb3ZlKGRzKTtcbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgZGVsZXRlIGRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE9ybmFtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvYmogID0gbmV3IE9ybmFtZW50KHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50cy5wdXNoKG9iaik7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZU9ybmFtZW50OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucmVtb3ZlKG9iaik7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogRm9yIGEgZ2l2ZW4gbm9kZSwgcmV0cmlldmUgdGhlIGJlc3QgcG9zc2libGUgbGFiZWwgZmllbGRcbiAgICAgICAgICogKG9wdGlvbmFsbHkgZnJvbSBhIHJhbmtlZCBsaXN0IG9mIGZpZWxkcykgb3IgaXRzIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgQ1VSUkVOVExZIFVOVVNFRCwgYnV0IG1heSBiZSB1c2VmdWwgaWYgd2Ugd2FudCB0byBzdXBwb3J0XG4gICAgICAgICAqIGZhbGxiYWNrIGxhYmVsaW5nIGJhc2VkIG9uIGEgcmFua2VkIGxpc3Qgb2Ygc291cmNlcywgZm9yIGV4YW1wbGVcbiAgICAgICAgICogICBbJ2V4cGxpY2l0TGFiZWwnLCAnb3R0VGF4b25OYW1lJywgJ29yaWdpbmFsTGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UHJlZmVycmVkTGFiZWxGaWVsZDogZnVuY3Rpb24obm9kZSwgcmFua2VkRmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmtlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJhbmtlZEZpZWxkcyA9IFsnZXhwbGljaXRMYWJlbCcsJ290dFRheG9uTmFtZScsJ29yaWdpbmFsTGFiZWwnLCdvdHRJZCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvdW5kTm9uRW1wdHlMYWJlbCA9ICdleHBsaWNpdExhYmVsJzsgIC8vIGEgaGFybWxlc3MgZGVmYXVsdFxuICAgICAgICAgICAgJC5lYWNoKHJhbmtlZEZpZWxkcywgZnVuY3Rpb24oaSxmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVtmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTm9uRW1wdHlMYWJlbCA9IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gc3RvcCBjaGVja2luZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVXNpbmcgbGFiZWwgZmllbGQgJ1wiKyBmb3VuZE5vbkVtcHR5TGFiZWwgK1wiJyBmb3IgdGhpcyBub2RlOlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZE5vbkVtcHR5TGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWZlcnJlZExhYmVsVGV4dDogZnVuY3Rpb24obm9kZSwgcmFua2VkRmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJlZmVycmVkRmllbGQgPSBzZWxmLmdldFByZWZlcnJlZExhYmVsRmllbGQobm9kZSwgcmFua2VkRmllbGRzKTtcbiAgICAgICAgICAgIHZhciBwcmVmZXJyZWRUZXh0ID0gbm9kZVtwcmVmZXJyZWRGaWVsZF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWZlcnJlZFRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZlcnJlZFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgfSxcblxuICAgICAgICAvKiBGb3IgYSBnaXZlbiBlbGVtZW50IChlZywgYSB0cmVlLCBub2RlLCBlZGdlLCBvcm5hbWVudCwgb3IgdGhlXG4gICAgICAgICAqIGlsbHVzdHJhdGlvbiBpdHNlbGYpLCBnZXQgdGhlIG1vc3QgXCJsb2NhbFwiIG1hdGNoaW5nIHN0eWxlIHZhbHVlIGZvclxuICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBCeSBkZWZhdWx0LCB0aGlzIHNob3VsZCBjb25mb3JtIHRvIHRoZSBcbiAgICAgICAgICogaWxsdXN0cmF0aW9uIGl0c2VsZiwgb3IgaXRzIGFjdGl2ZSBzdHlsZSBndWlkZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldEVmZmVjdGl2ZVN0eWxlOiBmdW5jdGlvbihvYmosIHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoJ3N0eWxlJyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgaW4gb2JqLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBvYnNlcnZhYmxlcyBvciBzaW1wbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob2JqLnN0eWxlW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW5lZFZhbHVlID0gc2VsZi5nZXRDb25zdHJhaW5lZFN0eWxlKHByb3BOYW1lLCByYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJhaW5lZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHdhc24ndCBmb3VuZCBsb2NhbGx5OyBjaGVjayB0aGUgbmV4dCBcImlubmVybW9zdFwiIGNvbnRleHQgXG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgSWxsdXN0cmF0ZWRUcmVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RWZmZWN0aXZlU3R5bGUoc2VsZiwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBJbGx1c3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0RWZmZWN0aXZlU3R5bGUoKTogc3R5bGUgJ1wiKyBwcm9wTmFtZSArXCInIG5vdCBmb3VuZCBpbiB0aGlzIHRyZWUncyBzdHlsZTpcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihvYmouc3R5bGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU3VwcG9ydGluZ0RhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0RWZmZWN0aXZlU3R5bGUoKTogU3VwcG9ydGluZ0RhdGFzZXQgaXMgbm90IHlldCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgT3JuYW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0RWZmZWN0aXZlU3R5bGUoKTogT3JuYW1lbnQgaXMgbm90IHlldCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdldEVmZmVjdGl2ZVN0eWxlKCk6IHVuZXhwZWN0ZWQgY29udGV4dCBvYmplY3Q6XCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Iob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbnN0cmFpbmVkU3R5bGU6IGZ1bmN0aW9uIChwcm9wTmFtZSwgcmF3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHN3aXRjaChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkZ2VUaGlja25lc3MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvcmRlclRoaWNrbmVzcyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGVzZSBhcmUgaW4gY29tbW9uIHVuaXRzIChwdD8pXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlubmVzdCA9IHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtTGluZVRoaWNrbmVzcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocmF3VmFsdWUsIHRoaW5uZXN0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgKG1hbnkpIG1vcmUgY2FzZXMgaGVyZSwgb3IgY29uc3RyYWluIGVsc2V3aGVyZS4uXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgZ29lcywgcmV0dXJuIHVuY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlVmVnYVNwZWM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8qIFN3ZWVwIHRoZSBJbGx1c3RyYXRpb24gbW9kZWwgYW5kIChyZSlnZW5lcmF0ZWQgYSBmdWxsIFZlZ2Egc3BlYy5cbiAgICAgICAgICAgICAqIFRoaXMgZHJpdmVzIHRoZSBkMyB2aXN1YWxpemF0aW9uIGluIHRoZSBlZGl0b3Igdmlld3BvcnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzcGVjID0gc2VsZi52ZWdhU3BlYztcblxuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGdyb3VwcyBhbmQgbWFya3MsIGFuZCByZXN0b3JlIHRoZSBlbXB0eSBpbGx1c3RyYXRpb24tZWxlbWVudHMgZ3JvdXBcbiAgICAgICAgICAgIHNwZWMubWFya3MgPSBbIF07XG4gICAgICAgICAgICAvLyByZWNrb24gdGhlIGN1cnJlbnQgd2lkdGggYW5kIGhlaWdodCBhcyBpbnRlcm5hbCBweFxuICAgICAgICAgICAgdmFyIHB4UHJpbnRXaWR0aCA9IHN0eWxpc3QucGh5c2ljYWxVbml0c1RvUGl4ZWxzKHNlbGYuc3R5bGUucHJpbnRTaXplLndpZHRoKCksIHN0eWxpc3QuaW50ZXJuYWxfcHBpKTtcbiAgICAgICAgICAgIHZhciBweFByaW50SGVpZ2h0ID0gc3R5bGlzdC5waHlzaWNhbFVuaXRzVG9QaXhlbHMoc2VsZi5zdHlsZS5wcmludFNpemUuaGVpZ2h0KCksIHN0eWxpc3QuaW50ZXJuYWxfcHBpKTtcbiAgICAgICAgICAgIHZhciBpbGx1c3RyYXRpb25FbGVtZW50c0dyb3VwID0ge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImdyb3VwXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWxsdXN0cmF0aW9uLWVsZW1lbnRzXCIsICAvLyBiZWNvbWVzIG1hcmtlciBjbGFzcyAuaWxsdXN0cmF0aW9uLWVsZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJlbnRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjoge1widmFsdWVcIjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjoge1widmFsdWVcIjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiB7XCJ2YWx1ZVwiOiBweFByaW50SGVpZ2h0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IHtcInZhbHVlXCI6IHB4UHJpbnRXaWR0aCB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2NhbGVzXCI6IFsgXSxcbiAgICAgICAgICAgICAgICBcImF4ZXNcIjogWyBdLFxuICAgICAgICAgICAgICAgIFwibWFya3NcIjogWyBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3BlYy5tYXJrcy5wdXNoKCBpbGx1c3RyYXRpb25FbGVtZW50c0dyb3VwICk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGFuZCByZWJ1aWxkIGRhdGEgYmFzZWQgb24gY3VycmVudCBlbGVtZW50c1xuICAgICAgICAgICAgc3BlYy5kYXRhID0gWyBdO1xuXG4gICAgICAgICAgICAkLmVhY2goc2VsZi5lbGVtZW50cygpLCBmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhcHByb3ByaWF0ZSBkYXRhICphbmQqIG1hcmtzIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIElsbHVzdHJhdGVkVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVNvdXJjZU5hbWUgPSBlbC5pZCgpOyAgLy8gXCJ0cmVlLTNcIiBvciBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogZGF0YVNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9ybWF0Jzoge1widHlwZVwiOlwidHJlZWpzb25cIn0sICAvLyBpbml0aWFsIG1hdGNoIGZvciBKU09OIG9iamVjdCwgdnMuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmdzIGZvciBcInRyZWVzQ29sbGVjdGlvblBvc2l0aW9uXCIsIFwidHJlZVBvc2l0aW9uXCIgb3IgXCJ0cmVlSURcIj9cbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGFsbCBwb3NzaWJsZSBwcm9wZXJ0aWVzIChjb21tb24gdG8gYnkgYWxsIGZvcm1hdHM/KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1lcmdlIHN1cHBvcnRpbmcgZGF0YSBmcm9tIG90aGVyIGZpbGVzPyBvciBkbyB0aGF0IGRvd25zdHJlYW0/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZmluYWwgdGFpbG9yaW5nIHRvIHBoeWxvZ3JhbSBsYXlvdXQgKG9uZSwgb3Igc2V2ZXJhbD8pXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKiBEZWZpbmUgZGF0YSBzb3VyY2UgZm9yIHRoaXMgZWxlbWVudCAoYWxsb3cgZm9yIGlubGluZSB0cmVlIGRhdGE/IGluIFxuICAgICAgICAgICAgICAgICAgICAgKiBleGlzdGluZyBkYXRhc2V0cz8gb3RoZXIga2luZHMgb2Ygc291cmNlcz8pXG4gICAgICAgICAgICAgICAgICAgICAqIE5PVEUgdGhhdCB3ZSBzaG91bGQgdXNlIGNhY2hlZCBkYXRhIHdoZW4gcG9zc2libGUsIHRvIGF2b2lkIFxuICAgICAgICAgICAgICAgICAgICAgKiBhbiBBSkFYIGZldGNoIGVhY2ggdGltZSB3ZSB0d2VhayB0aGUgdmlzdWFsIHByZXNlbnRhdGlvbiBvZiBhIHRyZWUhXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZVNvdXJjZUNhY2hlS2V5ID0gJ0VMRU1FTlQtU09VUkNFLSc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwubWV0YWRhdGEuc291cmNlLnR5cGUoKSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZGF0YVNvdXJjZVR5cGVzLkJVSUxUX0lOOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBkYXRhU291cmNlVHlwZXMuVVJMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVTb3VyY2VDYWNoZUtleSArPSAkLnRyaW0oZWwubWV0YWRhdGEuc291cmNlLnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldENhY2hlZERhdGEoIHRyZWVTb3VyY2VDYWNoZUtleSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOLkIuIFRoaXMgZGF0YSB3aWxsIGJlIHNhZmVseSBjbG9uZWQgYnkgVmVnYSB3aGVuIHNwZWMgaXMgcGFyc2VkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS52YWx1ZXMgPSBjYWNoZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS51cmwgPSBlbC5tZXRhZGF0YS5zb3VyY2UudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRhdGFTb3VyY2VUeXBlcy5VUExPQUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVZhbHVlID0gJC50cmltKGVsLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXBkYXRlVmVnYVNwZWMoKTogaWdub3JpbmcgZW1wdHkgcGFzdGUvdXBsb2FkcyBmb3Igbm93XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlU291cmNlQ2FjaGVLZXkgPSAoJ1BBU1RFRC1TT1VSQ0UtJyArIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRDYWNoZWREYXRhKCB0cmVlU291cmNlQ2FjaGVLZXkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTi5CLiBUaGlzIGRhdGEgd2lsbCBiZSBzYWZlbHkgY2xvbmVkIGJ5IFZlZ2Egd2hlbiBzcGVjIGlzIHBhcnNlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudmFsdWVzID0gY2FjaGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3RpbGwgd2FpdGluZyBmb3IgcGFzdGVkIHRleHQgKE5ld2ljaz8pIG9mICdcIisgZWwubWV0YWRhdGEubmFtZSgpICtcIid0byBiZSBjb252ZXJ0ZWQuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGNhc2VzIGZvciBvdGhlciBkYXRhIHNvdXJjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gc291cmNlIHR5cGUgZm9yIHRyZWUhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyogQnVpbGQgYW4gYXBwcm9wcmlhdGUgY2hhaW4gb2YgZGF0YSB0cmFuc2Zvcm1zICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHNvdXJjZSBkYXRhLCBpZiBub3QgYWxyZWFkeSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdGFzaFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FjaGVQYXRoXCI6ICdUcmVlSWxsdXN0cmF0b3IuY2FjaGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogdHJlZVNvdXJjZUNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbHVzaFwiOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IHRyYW5zZm9ybSBpbXBvcnRzIGRhdGEgZnJvbSBpdHMgc291cmNlIGZvcm1hdCB0byBvdXIgYmFzaWMgcGh5bG9UcmVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIm5leHNvblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyZWVzQ29sbGVjdGlvblBvc2l0aW9uXCI6MCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmVlUG9zaXRpb25cIjowXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNoYXBlIHRoZSBwaHlsb1RyZWUgdXNpbmcgcHJlZmVycmVkIHRyZWUgbGF5b3V0IGFuZCBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoeWxvZ3JhbVRyYW5zZm9ybSA9IHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJwaHlsb2dyYW1cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1wibGF5b3V0XCI6IFwiY2FydGVzaWFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1wicmFkaWFsQXJjXCI6IFs5MCwgMjcwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJyYWRpYWxTd2VlcFwiOiAnQ0xPQ0tXSVNFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmFkaWFsU3dlZXBcIjogJ0NPVU5URVJDTE9DS1dJU0UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cImJyYW5jaFN0eWxlXCI6IFwiZGlhZ29uYWxcIiwgIC8vIG90aGVyIG9wdGlvbnMgaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhbmNoTGVuZ3Roc1wiOiBcIlwiLCAgLy8gZW1wdHkvZmFsc2UsIG9yIGEgcHJvcGVydHkgbmFtZSB0byBjb21wYXJlP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBlbC53aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogZWwuaGVpZ2h0KCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYWRpdXNcIjogZWwucmFkaXVzKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aXBzQWxpZ25tZW50XCI6IGVsLnRpcHNBbGlnbm1lbnQoKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS50cmFuc2Zvcm0ucHVzaCggcGh5bG9ncmFtVHJhbnNmb3JtICk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwubGF5b3V0KCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRyZWVMYXlvdXRzLlJFQ1RBTkdMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHlsb2dyYW1UcmFuc2Zvcm0ubGF5b3V0ID0gJ2NhcnRlc2lhbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRyZWVMYXlvdXRzLkNJUkNMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHlsb2dyYW1UcmFuc2Zvcm0ubGF5b3V0ID0gJ3JhZGlhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRyZWVMYXlvdXRzLlRSSUFOR0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoeWxvZ3JhbVRyYW5zZm9ybS5sYXlvdXQgPSAnY2xhZG9ncmFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNwZWMuZGF0YS5wdXNoKHRyZWVEYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgbGFiZWwgcHJvcGVydGllcyAoZXNwLiBwb3NpdGlvbmluZykgYmFzZWQgb24gdGhlIGNob3NlbiBsYXlvdXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRIZWlnaHQgPSBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMubWluaW11bVRleHRTaXplKCk7ICAgLy8gVE9ETzogYWRqdXN0YWJsZSBmb250IHNpemUgKGNvbnZlcnQgcHQgdG8gcHgpXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYWxmVGV4dEhlaWdodCA9IHRleHRIZWlnaHQgKiAwLjQ7ICAgLy8gVE9ETzogYWRqdXN0YWJsZSBmb250IHNpemUgKGNvbnZlcnQgcHQgdG8gcHgpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsTGFiZWxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250U2l6ZVwiOiB7XCJ2YWx1ZVwiOiB0ZXh0SGVpZ2h0fSBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlbC5sYXlvdXQoKSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdHJlZUxheW91dHMuUkVDVEFOR0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0cmVlTGF5b3V0cy5UUklBTkdMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYWJlbCBvZmZzZXRzIGRlcGVuZCBvbiBvcmllbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbE51ZGdlWCwgbGFiZWxOdWRnZVksIGxhYmVsQWxpZ24sIGxhYmVsUm90YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVMYWJlbEdhcCA9IDY7ICAvLyBUT0RPOiBiYXNlIHRoaXMgb24gZm9udCBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlbC50aXBzQWxpZ25tZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhbGlnbm1lbnRzLlRPUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdGhlIG9kZCBtYXBwaW5nIG9mIFggYW5kIFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VYID0gbm9kZUxhYmVsR2FwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOdWRnZVkgPSBoYWxmVGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gLTkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYWxpZ25tZW50cy5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VYID0gbm9kZUxhYmVsR2FwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOdWRnZVkgPSBoYWxmVGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGFsaWdubWVudHMuQk9UVE9NOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOdWRnZVggPSBub2RlTGFiZWxHYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE51ZGdlWSA9IGhhbGZUZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUm90YXRpb24gPSA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGFsaWdubWVudHMuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VYID0gLW5vZGVMYWJlbEdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VZID0gaGFsZlRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUm90YXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzaW1wbGUgcHJvcGVydGllcyBmb3IgY2FydGVzaWFuIC8gcmVjdGFuZ3VsYXIgbGF5b3V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKGluaXRpYWxMYWJlbFByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IHtcImZpZWxkXCI6IFwieFwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IHtcImZpZWxkXCI6IFwieVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkeFwiOiB7XCJ2YWx1ZVwiOiBsYWJlbE51ZGdlWH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHlcIjoge1widmFsdWVcIjogbGFiZWxOdWRnZVl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsaWduXCI6IHtcInZhbHVlXCI6IGxhYmVsQWxpZ259LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IHtcInZhbHVlXCI6IGxhYmVsUm90YXRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdHJlZUxheW91dHMuQ0lSQ0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIHByb3BlcnRpZXMgZm9yIHJhZGlhbC9wb2xhciBsYXlvdXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUmFkaXVzIGFuZCB0aGV0YSAoYW5nbGUgZnJvbSBvcmlnaW4sIGluIHJhZGlhbnMpIGFyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFsdGVybmF0aXZlcyB0byBYIGFuZCBZIGZvciBwb2xhciBwcm9qZWN0aW9uLCBhbmQgYXNzdW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHRoZSB4IGFuZCB5IHByb3BlcnRpZXMgcmVwcmVzZW50IHRoZSBvcmlnaW4gb3IgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvZiB0aGUgbGF5b3V0LCBpZSwgdGhlIHJvb3Qgbm9kZS4gU2VlIGRpc2N1c3Npb24gYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBodHRwczovL2dpdGh1Yi5jb20vdHJpZmFjdGEvdmVnYS9wdWxsLzE4N1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoaW5pdGlhbExhYmVsUHJvcGVydGllcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjoge1widmFsdWVcIjogMH0sICAvLyB0aGlzIGlzIG9yaWdpbiBmb3IgcmFkaWFsL3BvbGFyIHByb2plY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IHtcInZhbHVlXCI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJhZGl1c1wiOiB7XCJmaWVsZFwiOiBcInJhZGl1c1wifSwgIC8vIHB4IGZyb20gb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGhldGFcIjoge1wiZmllbGRcIjogXCJ0aGV0YVwifSwgIC8vIGluIHJhZGlhbnMgKHdoYXQgZGlyZWN0aW9uIGZyb20gb3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsaWduXCI6IHtcImZpZWxkXCI6ICdhbGlnbid9LCAgLy8gTk9URSB0aGF0IHNvbWUgbGFiZWxzIGFyZSBmbGlwcGVkIDE4MGRlZyBmb3IgbGVnaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IHtcImZpZWxkXCI6IFwiYW5nbGVcIn0gICAvLyBpbiBkZWdyZWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBuZXcgdHJlZXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgcHJpbnRhYmxlIGFyZWEgKHNsaWdodGx5IHN0YWdnZXJlZCBmb3IgY2xhcml0eSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVNYXJrcyA9IHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJncm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IGVsLmlkKCksICAvLyBiZWNvbWVzIG1hcmtlciBjbGFzcyAudHJlZS0zIG9yIHNpbWlsYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbnRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiB7XCJ2YWx1ZVwiOiBlbC5yb290WCgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IHtcInZhbHVlXCI6IGVsLnJvb3RZKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJ0cmFuc2Zvcm1cIjoge1widmFsdWVcIjpcInNjYWxlKDgwMCwzMDApXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJ0cmFuc2Zvcm1cIjoge1widmFsdWVcIjpcInJvdGF0ZSgyNSkgc2NhbGUoMjAsMjApXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWFya3NcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLyogcGF0aHNmb3IgdHJlZSBlZGdlcyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE4uQi4gVGhpcyBleHBlY3RzIHByZS1leGlzdGluZyBsaW5rcyB3aXRoICdzb3VyY2UnIGFuZCAndGFyZ2V0JyBwcm9wZXJ0aWVzISBUaGUgJ2xpbmsnIHRyYW5zZm9ybSBpcyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3QgdG8gcHJvdmlkZSBhIHJlbmRlcmVkIHBhdGggb2YgdGhlIGRlc2lyZWQgdHlwZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInBhdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJmcm9tXCI6IHtcImRhdGFcIjogXCJwaHlsb1RyZWVcIiwgXCJwcm9wZXJ0eVwiOiBcImxpbmtzXCIsIFwidHJhbnNmb3JtXCI6IFt7XCJ0eXBlXCI6IFwibGlua1wiLCBcInNoYXBlXCI6IFwibGluZVwifV19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGFTb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zZm9ybVwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1widHlwZVwiOlwicGx1Y2tcIiwgXCJmaWVsZFwiOlwicGh5bG9FZGdlc1wiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IGRvIGFwcGx5IHRoZSAndGltZScgc2NhbGUgaGVyZT8gVFJZIGJydXRlLWZvcmNpbmcgeCBhbmQgeSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy97XCJ0eXBlXCI6XCJmb3JtdWxhXCIsIFwiZmllbGRcIjpcInNvdXJjZS54XCIsIFwiZXhwclwiOlwiZC5zb3VyY2UueVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3tcInR5cGVcIjpcImZvcm11bGFcIiwgXCJmaWVsZFwiOlwidGFyZ2V0LnhcIiwgXCJleHByXCI6XCJkLnRhcmdldC55XCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcInR5cGVcIjpcImxpbmtcIiwgXCJzaGFwZVwiOlwibGluZVwiIH0gIC8vIGxpbmUgfCBjdXJ2ZSB8IGRpYWdvbmFsIHwgZGlhZ29uYWxYIHwgZGlhZ29uYWxZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1widHlwZVwiOlwicGh5bG9ncmFtTGlua1wiLCBcInNoYXBlXCI6XCJyaWdodEFuZ2xlRGlhZ29uYWxcIiB9ICAvLyByaWdodEFuZ2xlRGlhZ29uYWwgfCByYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhdGhcIjoge1wiZmllbGRcIjogXCJwYXRoXCJ9LCAvLyAsIFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpcInhcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcInZhbHVlXCI6IHNlbGYuZ2V0RWZmZWN0aXZlU3R5bGUoZWwsICdlZGdlQ29sb3InKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiB7XCJ2YWx1ZVwiOiBzZWxmLmdldEVmZmVjdGl2ZVN0eWxlKGVsLCAnZWRnZVRoaWNrbmVzcycpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwic3Ryb2tlXCI6IHtcInZhbHVlXCI6IFwicmVkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8qIGdyb3VwIG5vZGUvbGFiZWwgcGFpcnMsIGZvciBlYXNpZXIgZXZlbnQgYmluZGluZyBsYXRlciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJncm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJrc1wiOltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN5bWJvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZyb21cIjoge1wiZGF0YVwiOiBkYXRhU291cmNlTmFtZSwgXCJ0cmFuc2Zvcm1cIjogW3tcInR5cGVcIjpcInBsdWNrXCIsIFwiZmllbGRcIjpcInBoeWxvTm9kZXNcIiB9XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbnRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IHtcIlhYc2NhbGVcIjogXCJ4XCIsIFwiZmllbGRcIjogXCJ4XCIsIFwibXVsdFwiOjF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiB7XCJYWHNjYWxlXCI6IFwieVwiLCBcImZpZWxkXCI6IFwieVwiLCBcIm11bHRcIjoxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IHtcInZhbHVlXCI6XCJjaXJjbGVcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaXplXCI6IHtcInZhbHVlXCI6IDh9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbFwiOiB7XCJ2YWx1ZVwiOiBcImJsYWNrXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJob3ZlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJmaWxsXCI6IHtcInZhbHVlXCI6IFwicmVkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8qIGVuZCBvZiBub2RlIG1hcmtzICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgIC8vIGxhYmVsIG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IHtcImRhdGFcIjogZGF0YVNvdXJjZU5hbWUsIFwidHJhbnNmb3JtXCI6IFt7XCJ0eXBlXCI6XCJwbHVja1wiLCBcImZpZWxkXCI6XCJwaHlsb05vZGVzXCIgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW50ZXJcIjogaW5pdGlhbExhYmVsUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjoge1wiZmllbGRcIjogZWwubm9kZUxhYmVsRmllbGQoKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbFwiOiB7XCJ2YWx1ZVwiOlwiYmxhY2tcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhvdmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxcIjoge1widmFsdWVcIjogXCJyZWRcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8qIGVuZCBvZiBsYWJlbCBtYXJrcyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiBlbmQgb2YgZ3JvdXBlZCBub2RlK2xhYmVsICovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXSAvKiBlbmQgb2YgaW5uZXIgZ3JvdXAgbWFya3MgKi9cbiAgICAgICAgICAgICAgICAgICAgfTsgLyogZW5kIG9mIGlubmVyIGdyb3VwICovXG5cbiAgICAgICAgICAgICAgICAgICAgaWxsdXN0cmF0aW9uRWxlbWVudHNHcm91cC5tYXJrcy5wdXNoKCB0cmVlTWFya3MgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTdXBwb3J0aW5nRGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVwZGF0ZVZlZ2FTcGVjKCk6IGlnbm9yaW5nIGRhdGFzZXRzIGZvciBub3dcIik7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgT3JuYW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGVWZWdhU3BlYygpOiBpZ25vcmluZyBvcm5hbWVudHMgZm9yIG5vd1wiKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1cGRhdGVWZWdhU3BlYygpOiB1bmV4cGVjZWQgZWxlbWVudCB0eXBlOiAnXCIrIGVsLm1ldGFkYXRhLnR5cGUoKSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBkZWZpbmUgY3VzdG9tIHN0eWxlcyBmb3IgbWFueSBkaWZmZXJlbnQgZWxlbWVudHMgb2ZcbiAgICAgKiB0aGUgc2NlbmUgZ3JhcGgsIGUuZy4sIGEgdHJlZSwgbm9kZSwgb3IgY2FwdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgU2NlbmVHcmFwaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBTY2VuZUdyYXBoKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjZW5lR3JhcGgoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2FmZWx5IHJlZmVyIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRPRE86IEJhc2VkIG9uIHRoZSBlbGVtZW50IHR5cGUsIG9mZmVyIGFwcHJvcHJpYXRlIHN0eWxlcyBhbmQgY29uc3RyYWludHNcbiAgICAgICAgLy8gVE9ETzogSW5jbHVkZSBvcHRpb25zIHRvIG1hcCBzZWxlY3RlZCBkYXRhIHRvIHZpc3VhbCBzdHlsZVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICB2YXIgSWxsdXN0cmF0ZWRUcmVlID0gZnVuY3Rpb24oaWxsdXN0cmF0aW9uLCBkYXRhKSB7XG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgSWxsdXN0cmF0ZWRUcmVlKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElsbHVzdHJhdGVkVHJlZShpbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZihkYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIFwiZW1wdHlcIiB0cmVlIG9iamVjdCBhYm92ZVxuICAgICAgICAgICAgZGF0YSA9IGdldE5ld0lsbHVzdHJhdGVkVHJlZU1vZGVsKGlsbHVzdHJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gcG9pbnQgYmFjayB0byBteSBwYXJlbnQgaWxsdXN0cmF0aW9uP1xuICAgICAgICAvL3NlbGYuaWxsdXN0cmF0aW9uID0gaWxsdXN0cmF0aW9uO1xuXG4gICAgICAgIC8vIEJpbmQgdG8gd3JpdGFibGUgY29tcHV0ZWQgb2JzZXJ2YWJsZXMsIHNvIHVzZXJzIGNhbiBcInRoaW5rIGluIHBoeXNpY2FsIHVuaXRzXCJcbiAgICAgICAgc2VsZi5waHlzaWNhbFdpZHRoID0gd3JhcEZpZWxkV2l0aFBoeXNpY2FsVW5pdHMoc2VsZiwgJ3dpZHRoJyk7XG4gICAgICAgIHNlbGYucGh5c2ljYWxIZWlnaHQgPSB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyhzZWxmLCAnaGVpZ2h0Jyk7XG4gICAgICAgIHNlbGYucGh5c2ljYWxSYWRpdXMgPSB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyhzZWxmLCAncmFkaXVzJyk7XG4gICAgICAgIHNlbGYucGh5c2ljYWxSb290WCA9IHdyYXBGaWVsZFdpdGhQaHlzaWNhbFVuaXRzKHNlbGYsICdyb290WCcpO1xuICAgICAgICBzZWxmLnBoeXNpY2FsUm9vdFkgPSB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyhzZWxmLCAncm9vdFknKTtcblxuICAgICAgICBrby5tYXBwaW5nLmZyb21KUyhkYXRhLCBJbGx1c3RyYXRpb24ubWFwcGluZ09wdGlvbnMsIHNlbGYpO1xuXG4gICAgICAgIC8vIEFkZCB2YWxpZGF0aW9uIGZvciBmaWVsZHMgdGhhdCBuZWVkIGl0XG4gICAgICAgIHNlbGYubWV0YWRhdGEubmFtZS5leHRlbmQoe3JlcXVpcmVkOiB0cnVlfSk7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBJbGx1c3RyYXRlZFRyZWUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogSWxsdXN0cmF0ZWRUcmVlLFxuXG4gICAgICAgIHVzZUNob3NlbkxheW91dDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbiB0cmVlTGF5b3V0cykge1xuICAgICAgICAgICAgICAgIHNlbGYubGF5b3V0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUNob3NlbkxheW91dCgpOiBVbmtub3duIHRyZWUgbGF5b3V0ICdcIisgbmV3VmFsdWUgK1wiJyFcIik7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH1cbiAgICAgICAgLFxuICAgICAgICB1c2VDaG9zZW5UcmVlRGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwaWNrIHVwIGxhdGVzdCBkYXRhIGZyb20gYm91bmQgd2lkZ2V0c1xuICAgICAgICAgICAgdmFyICRjaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWNob29zZXInKTtcbiAgICAgICAgICAgIHZhciAkb3BlbnRyZWVJRHNQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1vcGVudHJlZWlkcy1wYW5lbCcpO1xuICAgICAgICAgICAgdmFyICRuZXhzb25VcmxQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1uZXhzb251cmwtcGFuZWwnKTtcbiAgICAgICAgICAgIHZhciAkZmlsZVVwbG9hZFBhbmVsID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLXVwbG9hZC1wYW5lbCcpO1xuICAgICAgICAgICAgdmFyIGNob3NlblNvdXJjZSA9ICRjaG9vc2VyLnZhbCgpO1xuICAgICAgICAgICAgc3dpdGNoKGNob3NlblNvdXJjZSkge1xuICAgICAgICAgICAgICAgIC8qIE1hdGNoIGFnYWluc3Qgc3RyaW5ncyBkZWZpbmVkIGluIGBzdHlsaXN0LmpzYC4gV2UnbGwgc3RhcnRcbiAgICAgICAgICAgICAgICAgKiB3aXRoIHNvbWUgc3BlY2lhbCBjYXNlcyB0aGF0IGRyaXZlIGNoYW5nZXMgdG8gdGhlIFVJLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlciBPcGVuVHJlZSBzdHVkeSBhbmQgdHJlZSBpZHNcIjpcbiAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAkbmV4c29uVXJsUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0dWR5SUQgPSBzZWxmLm1ldGFkYXRhLnNvdXJjZS5waHlsZXN5c3RlbVN0dWR5SUQoKTsgXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlSUQgPSBzZWxmLm1ldGFkYXRhLnNvdXJjZS5waHlsZXN5c3RlbVRyZWVJRCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZU5leHNvblVSTCA9ICdodHRwOi8vYXBpLm9wZW50cmVlb2ZsaWZlLm9yZy9waHlsZXN5c3RlbS92MS9zdHVkeS8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgc3R1ZHlJRCArJy90cmVlLycrIHRyZWVJRCArJz9vdXRwdXRfbmV4bWwyanNvbj0xLjAuMCc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCB0cmVlTmV4c29uVVJMICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVudGVyIFVSTCB0byBOZXhTT04gMS4wXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkb3RoZXJGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1uZXhzb251cmwnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoICQudHJpbSgkb3RoZXJGaWVsZC52YWwoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgVVJMIHRvIGEgR2l0SHViIGdpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkbmV4c29uVXJsUGFuZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRvdGhlckZpZWxkID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLW5leHNvbnVybCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVXNlIGFub3RoZXIgZmllbGQgZm9yIEdpc3QgVVJMcz9cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoICQudHJpbSgkb3RoZXJGaWVsZC52YWwoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiUGFzdGUvZW50ZXIgdHJlZSBkYXRhXCI6XG4gICAgICAgICAgICAgICAgLy9jYXNlIFwiVXBsb2FkIHRyZWUgZGF0YVwiOlxuICAgICAgICAgICAgICAgIC8vY2FzZSBcIk5ld2ljayBzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAvL2Nhc2UgXCJOZXdpY2sgc3RyaW5nIHdpdGggZXh0cmEgZGF0YVwiOlxuICAgICAgICAgICAgICAgIC8vY2FzZSBcIk5FWFVTXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIFwicGFzdGVkIHRleHRcIiBmaWVsZCBmb3IgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgdmFyICRwYXN0ZWRGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1wYXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgJHBhc3RlZEZpZWxkLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBIYW5kbGUgY29tbW9uIGNhc2VzIGZvciBsaXN0ZWQgdHJlZSBzb3VyY2VzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBleHBsaWNpdCBcImZldGNoXCIgVVJMcyBmb3IgZGF0YSBvbiB0aGUgd2ViXG4gICAgICAgICAgICAgICAgICAgICAqICAtIEp1cHl0ZXIga2VybmVsIHZhbHVlcyBmcm9tIGEgaG9zdGluZyBub3RlYm9va1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhlIG1hdGNoaW5nIFVSTCBhdCBhbnkgbGV2ZWwgb2YgdGhpcyB0cmVlIG9mICpvYnNlcnZhYmxlKiBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RMaXN0cyA9IFtzdHlsaXN0LmF2YWlsYWJsZVRyZWVzKCldO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goc3R5bGlzdC5hdmFpbGFibGVUcmVlcygpLCBmdW5jdGlvbihpLCB0ZXN0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdjaGlsZHJlbicgaW4gdGVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0TGlzdHMucHVzaCh0ZXN0SXRlbS5jaGlsZHJlbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCh0ZXN0TGlzdHMsIGZ1bmN0aW9uKGksIHRlc3RMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBU1NVTUVTIHVuaXF1ZSBkaXNwbGF5IHRleHQgZm9yIGFsbCBpdGVtcyBpbiBuZXN0ZWQgbGlzdCFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFRyZWVzID0gJC5ncmVwKHRlc3RMaXN0LCBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ubmFtZSgpID09PSBjaG9zZW5Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRyZWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlSW5mbyA9IHNlbGVjdGVkVHJlZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyZWVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyB0cmVlIGZvdW5kIHVuZGVyICdcIisgY2hvc2VuU291cmNlICtcIichXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndXJsJyBpbiB0cmVlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRmaWxlVXBsb2FkUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCB0cmVlSW5mby51cmwoKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdrZXJuZWwnIGluIHRyZWVJbmZvKSB7IC8vIG9yICdrZXJuZWwnPyAnbmJrZXJuZWwnP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoaXMgaXMgJ3B5dGhvbicgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgdGhlIGZvcm1hdCBjaG9vc2VyIHdoaWxlIHdlIHRyeSB0byBndWVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dEZvcm1hdENob29zZXIgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXRGb3JtYXRDaG9vc2VyLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIFwicGFzdGVkIHRleHRcIiBmaWVsZCAoZGlzcGxheSBvbmx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRwYXN0ZWRGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1wYXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwYXN0ZWRGaWVsZC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBGb3IgYSBtdWx0aS1rZXJuZWwgbm90ZWJvb2ssIGV4cGVjdCBhIHNwZWNpZmljIGtlcm5lbC1pZCwgZWcgJ3B5dGhvbjInXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmJWYXJOYW1lID0gdHJlZUluZm8ubmFtZSgpLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRUcmVlU291cmNlRGF0YShuYlZhck5hbWUsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdkYXRhJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZVNvdXJjZURhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUbyBpbnRlcnByZXQgdGhpcyBhcyB0cmVlIHNvdXJjZSBkYXRhLCB3ZSdsbCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmVlZCB0byBmaWd1cmUgb3V0IGl0cyBmb3JtYXQuIFBhc3MgaXQgdG8gYSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2VyaWVzIG9mIFwic25pZmZlcnNcIiB0byBpZGVudGlmeSBOZXdpY2ssIE5leHNvbiwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbmRlYnVnZ2VyO1xuLy8gVE9ETzogcHVzaCB0aGlzIHNvdXJjZSBpbnRvIHBlcnNpc3RlbnQgc3RvcmFnZT9cbi8vL3NlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKHRyZWVTb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nRm9ybWF0ID0gbW9zdExpa2VseURhdGFGb3JtYXQodHJlZVNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXRGb3JtYXRDaG9vc2VyLnZhbChtYXRjaGluZ0Zvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3cgdGhpcyB0ZXh0IGluIHRoZSAoZGlzYWJsZWQpIHRleHQgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHBhc3RlZEZpZWxkLnZhbCh0cmVlU291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dEZvcm1hdENob29zZXIuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoaXMgc3RyaW5nIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgc3BlY2lhbCBjYXNlcyBhYm92ZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIFVSTCBvciBrZXJuZWwgZm91bmQgZm9yICdcIisgY2hvc2VuU291cmNlICtcIichXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgfVxuICAgICAgICAsXG4gICAgICAgIHVzZUNob3NlbkxhYmVsRmllbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gcGljayB1cCBsYXRlc3QgZGF0YSBmcm9tIGJvdW5kIHdpZGdldHNcbiAgICAgICAgICAgIHZhciAkY2hvb3NlciA9ICQoJyMnKyBzZWxmLmlkKCkgKyctbGFiZWxmaWVsZC1jaG9vc2VyJyk7XG4gICAgICAgICAgICBzZWxmLm5vZGVMYWJlbFRleHRGaWVsZCA9ICRjaG9vc2VyLnZhbCgpO1xuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH1cbiAgICAgICAgLFxuICAgICAgICBjb252ZXJ0UGFzdGVkRGF0YVRvVHJlZTogZnVuY3Rpb24odHJlZUlEKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gY29udmVydCBwYXN0ZWQvdXBsb2FkZWQgdGV4dCB0byBuZXhzb24sIHVzaW5nIHRoZSBjb252ZXJzaW9uXG4gICAgICAgICAgICAvLyBtZXRob2RzIGluIHRoZSBtYWluIG9wZW4gdHJlZSBjdXJhdGlvbiB0b29sLlxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAgLy8gdGhlIHRyZWUgaW4gcXVlc3Rpb25cbiAgICAgICAgICAgIHZhciAkcGFzdGVkRmllbGQgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtcGFzdGVkJyk7XG4gICAgICAgICAgICB2YXIgcGFzdGVkVGV4dCA9ICQudHJpbSgkcGFzdGVkRmllbGQudmFsKCkpO1xuICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoXCJQbGVhc2UgcGFzdGUgTmV3aWNrIG9yIG90aGVyIHRleHQgaW50byB0aGUgdGV4dCBhcmVhIHByb3ZpZGVkLCB0aGVuIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2xlYXIgYW55IGNhY2hlZCBhbmQgaW50ZXJuYWwgdmFsdWVzIHJlZ2FyZGxlc3MsIHRvIGhpZGUgYW4gb2xkIHRyZWU/XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoIHBhc3RlZFRleHQgKTtcbiAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVQTE9BRCk7XG4gICAgICAgICAgICB2YXIgdHJlZVNvdXJjZUNhY2hlS2V5ID0gKCdQQVNURUQtU09VUkNFLScgKyAkLnRyaW0oc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoKSkpO1xuICAgICAgICAgICAgLy8gVE9ETzogYnVpbGQgdXAgY2FjaGUga2V5IHdpdGggZm9ybWF0ICsgY29udGVudD9cbiAgICAgICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldENhY2hlZERhdGEoIHRyZWVTb3VyY2VDYWNoZUtleSApO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTi5CLiBUaGlzIGRhdGEgd2lsbCBiZSBzYWZlbHkgY2xvbmVkIGJ5IFZlZ2Egd2hlbiBzcGVjIGlzIHBhcnNlZCFcbiAgICAgICAgICAgICAgICAvLyBOT1RFIHRoYXQgd2Ugc2hvdWxkIHN0aWxsIHJlZnJlc2ggaW1tZWRpYXRlbHksIGluIGNhc2UgdGhlIGNhY2hlZCB0cmVlIGRhdGEgd2FzIGxvYWRlZFxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZWQgZm9yIGFub3RoZXIgdHJlZSwgb3IgYW4gZWFybGllciB2ZXJzaW9uIG9mIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9wZW50cmVlIHdlYiBzZXJ2aWNlcyB0byBjb252ZXJ0IHRvIG5leHNvblxuICAgICAgICAgICAgICAgIC8vVE9ETzogQXBwbHkgb3RoZXIgcGFzdGVkIGZvcm1hdHMgKGFuZCBSRU1FTUJFUiBUSEVNIGluIHRoZSBzYXZlZCBpbGx1c3RyYXRpb24hKVxuICAgICAgICAgICAgICAgIHZhciAkaW5wdXRGb3JtYXRDaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIC8vJGlucHV0Rm9ybWF0Q2hvb3Nlci5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dEZvcm1hdCA9ICRpbnB1dEZvcm1hdENob29zZXIudmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Rm9ybWF0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBjaG9vc2UgdGhlIGZvcm1hdCBvZiB0aGlzIHRyZWUgZGF0YSwgdGhlbiB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gY3Jvc3NEb21haW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9kZXZ0cmVlLm9wZW50cmVlb2ZsaWZlLm9yZy9jdXJhdG9yL3RvX25leHNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8qIE5PVEUgdGhhdCBpZFByZWZpeCBhbmQgZmlyc3RBdmFpbGFibGUqSUQgYXJncyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICogY3VycmVudGx5IHJlcXVpcmVkIHRvIGdldCB3ZWxsLWZvcm1lZCBOZXhzb24hXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoJ3tcIm91dHB1dFwiOiBcIm90Om5leHNvblwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImF1dGhfdG9rZW5cIjogXCJBTk9OWU1PVVNcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJpZFByZWZpeFwiOiBcIlwiLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUVkZ2VJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZU5vZGVJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZU9UVUlEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlT1RVc0lEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlVHJlZUlEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlVHJlZXNJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUFubm90YXRpb25JRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUFnZW50SURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVNZXNzYWdlSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiaW5wdXRGb3JtYXRcIjogJysgSlNPTi5zdHJpbmdpZnkoaW5wdXRGb3JtYXQpICsnLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImNvbnRlbnRcIjogJysgSlNPTi5zdHJpbmdpZnkoJC50cmltKHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCkpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnIH0nKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IGVycm9ycyBvciBtYWxmb3JtZWQgZGF0YSwgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFqb3Igc2VydmVyLXNpZGUgZXJyb3IsIGp1c3Qgc2hvdyByYXcgcmVzcG9uc2UgZm9yIHRlY2ggc3VwcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgKCcrIGpxWEhSLnN0YXR1cyArJykgY29udmVydGluZyB0aGlzIHRyZWUgdG8gTmV4c29uOlxcblxcbicrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgYmxvY2tlZCB0aGUgc2F2ZSBkdWUgdG8gbWFqb3IgdmFsaWRhdGlvbiBlcnJvcnMhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLnBhcnNlSlNPTihqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHByb3Blcmx5IHBhcnNlZCBKU09OLCBzaG93IGl0IG1vcmUgc2Vuc2libHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoYnV0IGZvciBub3csIHJlcGVhdCB0aGUgY3J1ZGUgZmVlZGJhY2sgdXNlZCBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgKCcrIGpxWEhSLnN0YXR1cyArJykgY29udmVydGluZyB0aGlzIHRyZWUgdG8gTmV4c29uOlxcblxcbicrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3RlZCB0cmVlIHdhcyBjb252ZXJ0ZWQgc3VjY2Vzc2Z1bGx5OyBjYXB0dXJlIHRoZSBOZXhzb24gYXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJC5wYXJzZUpTT04oanFYSFIucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4IGFueSBxdWlya3MgdG8gY29uZm9ybSB0byBvdXIgZXhwZWN0ZWQgTmV4c29uIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZml4VXBDb252ZXJ0ZWROZXhzb24oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGl0IGluIHRoZSBjYWNoZSwgYXQgdGhlIGtleSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDYWNoZWREYXRhKCB0cmVlU291cmNlQ2FjaGVLZXksIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBub2RlLWxhYmVsIGZpZWxkIHRvIHNob3cgXCJleHBsaWNpdFwiIGxhYmVscyAodGhpcyB3aWxsIHRyaWdnZXIgYSBkaXNwbGF5IHJlZnJlc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGxhYmVsQ2hvb3NlciA9ICQoJyMnKyBzZWxmLmlkKCkgKyctbGFiZWxmaWVsZC1jaG9vc2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbGFiZWxDaG9vc2VyLnZhbCgnZXhwbGljaXRMYWJlbCcpLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICxcbiAgICAgICAgdXNlQ2hvc2VuVGlwc0FsaWdubWVudDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbiBhbGlnbm1lbnRzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50aXBzQWxpZ25tZW50KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUNob3NlblRpcHNBbGlnbm1lbnQoKTogVW5rbm93biB0cmVlIGxheW91dCAnXCIrIG5ld1ZhbHVlICtcIichXCIpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIFN1cHBvcnRpbmdEYXRhc2V0ID0gZnVuY3Rpb24oaWxsdXN0cmF0aW9uLCBkYXRhKSB7XG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgU3VwcG9ydGluZ0RhdGFzZXQpICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTUlTU0lORyAnbmV3JyBrZXl3b3JkLCBwYXRjaGluZyB0aGlzIG5vd1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3VwcG9ydGluZ0RhdGFzZXQoaWxsdXN0cmF0aW9uLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YoZGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBsb2FkIHRoZSBcImVtcHR5XCIgZGF0YXNldCBvYmplY3QgYWJvdmVcbiAgICAgICAgICAgIGRhdGEgPSBnZXROZXdTdXBwb3J0aW5nRGF0YXNldE1vZGVsKGlsbHVzdHJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIElsbHVzdHJhdGlvbi5tYXBwaW5nT3B0aW9ucywgc2VsZik7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICB2YXIgT3JuYW1lbnQgPSBmdW5jdGlvbihpbGx1c3RyYXRpb24sIGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBPcm5hbWVudCkgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNSVNTSU5HICduZXcnIGtleXdvcmQsIHBhdGNoaW5nIHRoaXMgbm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcm5hbWVudChpbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZihkYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIFwiZW1wdHlcIiBvcm5hbWVudCBvYmplY3QgYWJvdmVcbiAgICAgICAgICAgIGRhdGEgPSBnZXROZXdPcm5hbWVudE1vZGVsKGlsbHVzdHJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIElsbHVzdHJhdGlvbi5tYXBwaW5nT3B0aW9ucywgc2VsZik7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuXG4gICAgLyogV2UgbmVlZCB0byBiZSBhYmxlIHRvIGRlZmluZSBjdXN0b20gc3R5bGVzIGZvciBtYW55IGRpZmZlcmVudCBlbGVtZW50cyBvZlxuICAgICAqIHRoZSBzY2VuZSBncmFwaCwgZS5nLiwgYSB0cmVlLCBub2RlLCBvciBjYXB0aW9uLlxuICAgICAqL1xuICAgIHZhciBTdHlsZU92ZXJyaWRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZU92ZXJyaWRlcykgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNSVNTSU5HICduZXcnIGtleXdvcmQsIHBhdGNoaW5nIHRoaXMgbm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZU92ZXJyaWRlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8qIFdlJ2xsIG9mdGVuIHdhbnQgdG8gc2hvdyB2YWx1ZXMgdXNpbmcgdGhlIGNob3NlbiBwaHlzaWNhbCB1bml0cyAoaW5jaGVzXG4gICAgICogb3IgY20pLCBidXQgc3RvcmUgdGhlbSBhcyBpbnRlcm5hbCBTVkcgcGl4ZWxzLiBUaGlzIG1ha2VzIGl0IGVhc3kgdG9cbiAgICAgKiBkZWNsYXJlIHRoZXNlIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMsIGVnLCB3cmFwIHdpZHRoID0+ICdwaHlzaWNhbFdpZHRoJ1xuICAgICAqL1xuICAgIHZhciB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyA9IGZ1bmN0aW9uKG9iaiwgZmllbGROYW1lLCBwcmVjaXNpb24pIHtcbiAgICAgICAgLy8gRGlzcGxheSB1c2luZyBzZWxlY3RlZCBwcmVjaXNpb24gKG51bWJlciBvZiBwbGFjZXMpLCB3aXRoIGh1bmRyZWR0aHMgYnkgZGVmYXVsdC5cbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDI7ICBcbiAgICAgICAgcmV0dXJuIGtvLmNvbXB1dGVkKHtcbiAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwaHlzaWNhbFZhbHVlID0gc3R5bGlzdC5waXhlbHNUb1BoeXNpY2FsVW5pdHMob2JqWyBmaWVsZE5hbWUgXSgpLCBzdHlsaXN0LmludGVybmFsX3BwaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHBoeXNpY2FsVmFsdWUgKyBcImUrXCIgKyBwcmVjaXNpb24pICsgXCJlLVwiICsgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYmpbIGZpZWxkTmFtZSBdKCBzdHlsaXN0LnBoeXNpY2FsVW5pdHNUb1BpeGVscyh2YWx1ZSwgc3R5bGlzdC5pbnRlcm5hbF9wcGkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvd25lcjogb2JqLFxuICAgICAgICAgICAgZGVmZXJFdmFsdWF0aW9uOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyogTmV3aWNrIChhbmQgb3RoZXI/KSBmb3JtYXRzIGNvbnZlcnRlZCBOZXhzb24gbWF5IGJlIG1pc3Npbmcgc29tZVxuICAgICAqIGVsZW1lbnRzIHdlIGV4cGVjdC4gQWRkIHRoZXNlIG5vdy4gKi9cbiAgICB2YXIgZml4VXBDb252ZXJ0ZWROZXhzb24gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vICdkYXRhJyBpcyBuZXhtbCBpbiB0eXBpY2FsIEpTT04gd3JhcHBlclxuICAgICAgICB2YXIgbmV4bWwgPSBkYXRhLmRhdGEubmV4bWw7XG4gICAgICAgIHZhciBub2RlSGFzQ2hpbGRyZW4gPSBmdW5jdGlvbihub2RlLCB0cmVlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgJC5lYWNoKHRyZWUuZWRnZSwgZnVuY3Rpb24oaSxlZGdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VbJ0Bzb3VyY2UnXSA9PT0gbm9kZVsnQGlkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRGb3VuZDtcbiAgICAgICAgfTtcbiAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLHRyZWVDb2xsZWN0aW9uKSB7IC8vIG1hcmsgY2hpbGRsZXNzIG5vZGVzIHdpdGggJ290OmlzbGVhZidcbiAgICAgICAgICAgICQuZWFjaCh0cmVlQ29sbGVjdGlvbi50cmVlLCBmdW5jdGlvbihpLCB0cmVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWZOb2RlcyA9ICQuZ3JlcCh0cmVlLm5vZGUsIGZ1bmN0aW9uKG5vZGUpIHsgXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSGFzQ2hpbGRyZW4obm9kZSx0cmVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IGludGVybmFsIG5vZGVzP1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsnXm90OmlzTGVhZiddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIFVzZSBzbmlmZmVycyB0byBkZXRlcm1pbmUgdGhlIG1vc3QgbGlrZWx5IGZvcm1hdCBvZiBpbnB1dCB0cmVlIGRhdGEgKi9cbiAgICB2YXIgbW9zdExpa2VseURhdGFGb3JtYXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuaXNQcm9iYWJseU5ld2ljayhkYXRhKSA/ICduZXdpY2snIDogXG4gICAgICAgICAgICAgICAgICAgdXRpbHMuaXNQcm9iYWJseU5FWFVTKGRhdGEpID8gJ25leHVzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmlzUHJvYmFibHlOZVhNTChkYXRhKSA/ICduZXh1cycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgIC8vIGZvcm1hdCB1bmtub3duXG4gICAgfVxuXG4gICAgLyogZXhwb3NlIGNsYXNzIGNvbnN0cnVjdG9ycyAoYW5kIHN0YXRpYyBtZXRob2RzKSBmb3IgaW5zdGFudGlhdGlvbiAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIGV4cG9zZSBlbnVtZXJhdGlvbnNcbiAgICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgICBjb2xvckRlcHRoczogY29sb3JEZXB0aHMsXG4gICAgICAgIHRyZWVMYXlvdXRzOiB0cmVlTGF5b3V0cyxcbiAgICAgICAgYWxpZ25tZW50czogYWxpZ25tZW50cyxcbiAgICAgICAgZGF0YVNvdXJjZVR5cGVzOiBkYXRhU291cmNlVHlwZXMsXG4gICAgICAgIHZlcnNpb25UeXBlczogdmVyc2lvblR5cGVzLFxuICAgICAgICBob3N0QXBwbGljYXRpb25zOiBob3N0QXBwbGljYXRpb25zLFxuICAgICAgICBjYWNoZTogY2FjaGUsXG5cbiAgICAgICAgLy8gZXhwb3NlIHZpZXctbW9kZWwgY2xhc3Nlc1xuICAgICAgICBJbGx1c3RyYXRpb246IElsbHVzdHJhdGlvbixcbiAgICAgICAgU2NlbmVHcmFwaDogU2NlbmVHcmFwaCxcbiAgICAgICAgSWxsdXN0cmF0ZWRUcmVlOiBJbGx1c3RyYXRlZFRyZWUsXG4gICAgICAgIFN1cHBvcnRpbmdEYXRhc2V0OiBTdXBwb3J0aW5nRGF0YXNldCxcbiAgICAgICAgT3JuYW1lbnQ6IE9ybmFtZW50LFxuICAgICAgICBTdHlsZU92ZXJyaWRlczogU3R5bGVPdmVycmlkZXNcbiAgICB9O1xufSh3aW5kb3csIGRvY3VtZW50LCAkLCBrbywgc3R5bGlzdCk7XG5cbmZvciAodmFyIG5hbWUgaW4gVHJlZUlsbHVzdHJhdG9yKSB7XG4gICAgZXhwb3J0c1sgbmFtZSBdID0gVHJlZUlsbHVzdHJhdG9yWyBuYW1lIF07XG59XG4iLCI7IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKiEgalF1ZXJ5IHYxLjguMyBqcXVlcnkuY29tIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXHJcbihmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIF8oZSl7dmFyIHQ9TVtlXT17fTtyZXR1cm4gdi5lYWNoKGUuc3BsaXQoeSksZnVuY3Rpb24oZSxuKXt0W25dPSEwfSksdH1mdW5jdGlvbiBIKGUsbixyKXtpZihyPT09dCYmZS5ub2RlVHlwZT09PTEpe3ZhciBpPVwiZGF0YS1cIituLnJlcGxhY2UoUCxcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO3I9ZS5nZXRBdHRyaWJ1dGUoaSk7aWYodHlwZW9mIHI9PVwic3RyaW5nXCIpe3RyeXtyPXI9PT1cInRydWVcIj8hMDpyPT09XCJmYWxzZVwiPyExOnI9PT1cIm51bGxcIj9udWxsOityK1wiXCI9PT1yPytyOkQudGVzdChyKT92LnBhcnNlSlNPTihyKTpyfWNhdGNoKHMpe312LmRhdGEoZSxuLHIpfWVsc2Ugcj10fXJldHVybiByfWZ1bmN0aW9uIEIoZSl7dmFyIHQ7Zm9yKHQgaW4gZSl7aWYodD09PVwiZGF0YVwiJiZ2LmlzRW1wdHlPYmplY3QoZVt0XSkpY29udGludWU7aWYodCE9PVwidG9KU09OXCIpcmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gZXQoKXtyZXR1cm4hMX1mdW5jdGlvbiB0dCgpe3JldHVybiEwfWZ1bmN0aW9uIHV0KGUpe3JldHVybiFlfHwhZS5wYXJlbnROb2RlfHxlLnBhcmVudE5vZGUubm9kZVR5cGU9PT0xMX1mdW5jdGlvbiBhdChlLHQpe2RvIGU9ZVt0XTt3aGlsZShlJiZlLm5vZGVUeXBlIT09MSk7cmV0dXJuIGV9ZnVuY3Rpb24gZnQoZSx0LG4pe3Q9dHx8MDtpZih2LmlzRnVuY3Rpb24odCkpcmV0dXJuIHYuZ3JlcChlLGZ1bmN0aW9uKGUscil7dmFyIGk9ISF0LmNhbGwoZSxyLGUpO3JldHVybiBpPT09bn0pO2lmKHQubm9kZVR5cGUpcmV0dXJuIHYuZ3JlcChlLGZ1bmN0aW9uKGUscil7cmV0dXJuIGU9PT10PT09bn0pO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXt2YXIgcj12LmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlVHlwZT09PTF9KTtpZihpdC50ZXN0KHQpKXJldHVybiB2LmZpbHRlcih0LHIsIW4pO3Q9di5maWx0ZXIodCxyKX1yZXR1cm4gdi5ncmVwKGUsZnVuY3Rpb24oZSxyKXtyZXR1cm4gdi5pbkFycmF5KGUsdCk+PTA9PT1ufSl9ZnVuY3Rpb24gbHQoZSl7dmFyIHQ9Y3Quc3BsaXQoXCJ8XCIpLG49ZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYobi5jcmVhdGVFbGVtZW50KXdoaWxlKHQubGVuZ3RoKW4uY3JlYXRlRWxlbWVudCh0LnBvcCgpKTtyZXR1cm4gbn1mdW5jdGlvbiBMdChlLHQpe3JldHVybiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpWzBdfHxlLmFwcGVuZENoaWxkKGUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpKX1mdW5jdGlvbiBBdChlLHQpe2lmKHQubm9kZVR5cGUhPT0xfHwhdi5oYXNEYXRhKGUpKXJldHVybjt2YXIgbixyLGkscz12Ll9kYXRhKGUpLG89di5fZGF0YSh0LHMpLHU9cy5ldmVudHM7aWYodSl7ZGVsZXRlIG8uaGFuZGxlLG8uZXZlbnRzPXt9O2ZvcihuIGluIHUpZm9yKHI9MCxpPXVbbl0ubGVuZ3RoO3I8aTtyKyspdi5ldmVudC5hZGQodCxuLHVbbl1bcl0pfW8uZGF0YSYmKG8uZGF0YT12LmV4dGVuZCh7fSxvLmRhdGEpKX1mdW5jdGlvbiBPdChlLHQpe3ZhciBuO2lmKHQubm9kZVR5cGUhPT0xKXJldHVybjt0LmNsZWFyQXR0cmlidXRlcyYmdC5jbGVhckF0dHJpYnV0ZXMoKSx0Lm1lcmdlQXR0cmlidXRlcyYmdC5tZXJnZUF0dHJpYnV0ZXMoZSksbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksbj09PVwib2JqZWN0XCI/KHQucGFyZW50Tm9kZSYmKHQub3V0ZXJIVE1MPWUub3V0ZXJIVE1MKSx2LnN1cHBvcnQuaHRtbDVDbG9uZSYmZS5pbm5lckhUTUwmJiF2LnRyaW0odC5pbm5lckhUTUwpJiYodC5pbm5lckhUTUw9ZS5pbm5lckhUTUwpKTpuPT09XCJpbnB1dFwiJiZFdC50ZXN0KGUudHlwZSk/KHQuZGVmYXVsdENoZWNrZWQ9dC5jaGVja2VkPWUuY2hlY2tlZCx0LnZhbHVlIT09ZS52YWx1ZSYmKHQudmFsdWU9ZS52YWx1ZSkpOm49PT1cIm9wdGlvblwiP3Quc2VsZWN0ZWQ9ZS5kZWZhdWx0U2VsZWN0ZWQ6bj09PVwiaW5wdXRcInx8bj09PVwidGV4dGFyZWFcIj90LmRlZmF1bHRWYWx1ZT1lLmRlZmF1bHRWYWx1ZTpuPT09XCJzY3JpcHRcIiYmdC50ZXh0IT09ZS50ZXh0JiYodC50ZXh0PWUudGV4dCksdC5yZW1vdmVBdHRyaWJ1dGUodi5leHBhbmRvKX1mdW5jdGlvbiBNdChlKXtyZXR1cm4gdHlwZW9mIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUhPVwidW5kZWZpbmVkXCI/ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik6dHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbCE9XCJ1bmRlZmluZWRcIj9lLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpOltdfWZ1bmN0aW9uIF90KGUpe0V0LnRlc3QoZS50eXBlKSYmKGUuZGVmYXVsdENoZWNrZWQ9ZS5jaGVja2VkKX1mdW5jdGlvbiBRdChlLHQpe2lmKHQgaW4gZSlyZXR1cm4gdDt2YXIgbj10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSkscj10LGk9SnQubGVuZ3RoO3doaWxlKGktLSl7dD1KdFtpXStuO2lmKHQgaW4gZSlyZXR1cm4gdH1yZXR1cm4gcn1mdW5jdGlvbiBHdChlLHQpe3JldHVybiBlPXR8fGUsdi5jc3MoZSxcImRpc3BsYXlcIik9PT1cIm5vbmVcInx8IXYuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfWZ1bmN0aW9uIFl0KGUsdCl7dmFyIG4scixpPVtdLHM9MCxvPWUubGVuZ3RoO2Zvcig7czxvO3MrKyl7bj1lW3NdO2lmKCFuLnN0eWxlKWNvbnRpbnVlO2lbc109di5fZGF0YShuLFwib2xkZGlzcGxheVwiKSx0PyghaVtzXSYmbi5zdHlsZS5kaXNwbGF5PT09XCJub25lXCImJihuLnN0eWxlLmRpc3BsYXk9XCJcIiksbi5zdHlsZS5kaXNwbGF5PT09XCJcIiYmR3QobikmJihpW3NdPXYuX2RhdGEobixcIm9sZGRpc3BsYXlcIixubihuLm5vZGVOYW1lKSkpKToocj1EdChuLFwiZGlzcGxheVwiKSwhaVtzXSYmciE9PVwibm9uZVwiJiZ2Ll9kYXRhKG4sXCJvbGRkaXNwbGF5XCIscikpfWZvcihzPTA7czxvO3MrKyl7bj1lW3NdO2lmKCFuLnN0eWxlKWNvbnRpbnVlO2lmKCF0fHxuLnN0eWxlLmRpc3BsYXk9PT1cIm5vbmVcInx8bi5zdHlsZS5kaXNwbGF5PT09XCJcIiluLnN0eWxlLmRpc3BsYXk9dD9pW3NdfHxcIlwiOlwibm9uZVwifXJldHVybiBlfWZ1bmN0aW9uIFp0KGUsdCxuKXt2YXIgcj1SdC5leGVjKHQpO3JldHVybiByP01hdGgubWF4KDAsclsxXS0obnx8MCkpKyhyWzJdfHxcInB4XCIpOnR9ZnVuY3Rpb24gZW4oZSx0LG4scil7dmFyIGk9bj09PShyP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpPzQ6dD09PVwid2lkdGhcIj8xOjAscz0wO2Zvcig7aTw0O2krPTIpbj09PVwibWFyZ2luXCImJihzKz12LmNzcyhlLG4rJHRbaV0sITApKSxyPyhuPT09XCJjb250ZW50XCImJihzLT1wYXJzZUZsb2F0KER0KGUsXCJwYWRkaW5nXCIrJHRbaV0pKXx8MCksbiE9PVwibWFyZ2luXCImJihzLT1wYXJzZUZsb2F0KER0KGUsXCJib3JkZXJcIiskdFtpXStcIldpZHRoXCIpKXx8MCkpOihzKz1wYXJzZUZsb2F0KER0KGUsXCJwYWRkaW5nXCIrJHRbaV0pKXx8MCxuIT09XCJwYWRkaW5nXCImJihzKz1wYXJzZUZsb2F0KER0KGUsXCJib3JkZXJcIiskdFtpXStcIldpZHRoXCIpKXx8MCkpO3JldHVybiBzfWZ1bmN0aW9uIHRuKGUsdCxuKXt2YXIgcj10PT09XCJ3aWR0aFwiP2Uub2Zmc2V0V2lkdGg6ZS5vZmZzZXRIZWlnaHQsaT0hMCxzPXYuc3VwcG9ydC5ib3hTaXppbmcmJnYuY3NzKGUsXCJib3hTaXppbmdcIik9PT1cImJvcmRlci1ib3hcIjtpZihyPD0wfHxyPT1udWxsKXtyPUR0KGUsdCk7aWYocjwwfHxyPT1udWxsKXI9ZS5zdHlsZVt0XTtpZihVdC50ZXN0KHIpKXJldHVybiByO2k9cyYmKHYuc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZXx8cj09PWUuc3R5bGVbdF0pLHI9cGFyc2VGbG9hdChyKXx8MH1yZXR1cm4gcitlbihlLHQsbnx8KHM/XCJib3JkZXJcIjpcImNvbnRlbnRcIiksaSkrXCJweFwifWZ1bmN0aW9uIG5uKGUpe2lmKFd0W2VdKXJldHVybiBXdFtlXTt2YXIgdD12KFwiPFwiK2UrXCI+XCIpLmFwcGVuZFRvKGkuYm9keSksbj10LmNzcyhcImRpc3BsYXlcIik7dC5yZW1vdmUoKTtpZihuPT09XCJub25lXCJ8fG49PT1cIlwiKXtQdD1pLmJvZHkuYXBwZW5kQ2hpbGQoUHR8fHYuZXh0ZW5kKGkuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSx7ZnJhbWVCb3JkZXI6MCx3aWR0aDowLGhlaWdodDowfSkpO2lmKCFIdHx8IVB0LmNyZWF0ZUVsZW1lbnQpSHQ9KFB0LmNvbnRlbnRXaW5kb3d8fFB0LmNvbnRlbnREb2N1bWVudCkuZG9jdW1lbnQsSHQud3JpdGUoXCI8IWRvY3R5cGUgaHRtbD48aHRtbD48Ym9keT5cIiksSHQuY2xvc2UoKTt0PUh0LmJvZHkuYXBwZW5kQ2hpbGQoSHQuY3JlYXRlRWxlbWVudChlKSksbj1EdCh0LFwiZGlzcGxheVwiKSxpLmJvZHkucmVtb3ZlQ2hpbGQoUHQpfXJldHVybiBXdFtlXT1uLG59ZnVuY3Rpb24gZm4oZSx0LG4scil7dmFyIGk7aWYodi5pc0FycmF5KHQpKXYuZWFjaCh0LGZ1bmN0aW9uKHQsaSl7bnx8c24udGVzdChlKT9yKGUsaSk6Zm4oZStcIltcIisodHlwZW9mIGk9PVwib2JqZWN0XCI/dDpcIlwiKStcIl1cIixpLG4scil9KTtlbHNlIGlmKCFuJiZ2LnR5cGUodCk9PT1cIm9iamVjdFwiKWZvcihpIGluIHQpZm4oZStcIltcIitpK1wiXVwiLHRbaV0sbixyKTtlbHNlIHIoZSx0KX1mdW5jdGlvbiBDbihlKXtyZXR1cm4gZnVuY3Rpb24odCxuKXt0eXBlb2YgdCE9XCJzdHJpbmdcIiYmKG49dCx0PVwiKlwiKTt2YXIgcixpLHMsbz10LnRvTG93ZXJDYXNlKCkuc3BsaXQoeSksdT0wLGE9by5sZW5ndGg7aWYodi5pc0Z1bmN0aW9uKG4pKWZvcig7dTxhO3UrKylyPW9bdV0scz0vXlxcKy8udGVzdChyKSxzJiYocj1yLnN1YnN0cigxKXx8XCIqXCIpLGk9ZVtyXT1lW3JdfHxbXSxpW3M/XCJ1bnNoaWZ0XCI6XCJwdXNoXCJdKG4pfX1mdW5jdGlvbiBrbihlLG4scixpLHMsbyl7cz1zfHxuLmRhdGFUeXBlc1swXSxvPW98fHt9LG9bc109ITA7dmFyIHUsYT1lW3NdLGY9MCxsPWE/YS5sZW5ndGg6MCxjPWU9PT1Tbjtmb3IoO2Y8bCYmKGN8fCF1KTtmKyspdT1hW2ZdKG4scixpKSx0eXBlb2YgdT09XCJzdHJpbmdcIiYmKCFjfHxvW3VdP3U9dDoobi5kYXRhVHlwZXMudW5zaGlmdCh1KSx1PWtuKGUsbixyLGksdSxvKSkpO3JldHVybihjfHwhdSkmJiFvW1wiKlwiXSYmKHU9a24oZSxuLHIsaSxcIipcIixvKSksdX1mdW5jdGlvbiBMbihlLG4pe3ZhciByLGkscz12LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKHIgaW4gbiluW3JdIT09dCYmKChzW3JdP2U6aXx8KGk9e30pKVtyXT1uW3JdKTtpJiZ2LmV4dGVuZCghMCxlLGkpfWZ1bmN0aW9uIEFuKGUsbixyKXt2YXIgaSxzLG8sdSxhPWUuY29udGVudHMsZj1lLmRhdGFUeXBlcyxsPWUucmVzcG9uc2VGaWVsZHM7Zm9yKHMgaW4gbClzIGluIHImJihuW2xbc11dPXJbc10pO3doaWxlKGZbMF09PT1cIipcIilmLnNoaWZ0KCksaT09PXQmJihpPWUubWltZVR5cGV8fG4uZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikpO2lmKGkpZm9yKHMgaW4gYSlpZihhW3NdJiZhW3NdLnRlc3QoaSkpe2YudW5zaGlmdChzKTticmVha31pZihmWzBdaW4gcilvPWZbMF07ZWxzZXtmb3IocyBpbiByKXtpZighZlswXXx8ZS5jb252ZXJ0ZXJzW3MrXCIgXCIrZlswXV0pe289czticmVha311fHwodT1zKX1vPW98fHV9aWYobylyZXR1cm4gbyE9PWZbMF0mJmYudW5zaGlmdChvKSxyW29dfWZ1bmN0aW9uIE9uKGUsdCl7dmFyIG4scixpLHMsbz1lLmRhdGFUeXBlcy5zbGljZSgpLHU9b1swXSxhPXt9LGY9MDtlLmRhdGFGaWx0ZXImJih0PWUuZGF0YUZpbHRlcih0LGUuZGF0YVR5cGUpKTtpZihvWzFdKWZvcihuIGluIGUuY29udmVydGVycylhW24udG9Mb3dlckNhc2UoKV09ZS5jb252ZXJ0ZXJzW25dO2Zvcig7aT1vWysrZl07KWlmKGkhPT1cIipcIil7aWYodSE9PVwiKlwiJiZ1IT09aSl7bj1hW3UrXCIgXCIraV18fGFbXCIqIFwiK2ldO2lmKCFuKWZvcihyIGluIGEpe3M9ci5zcGxpdChcIiBcIik7aWYoc1sxXT09PWkpe249YVt1K1wiIFwiK3NbMF1dfHxhW1wiKiBcIitzWzBdXTtpZihuKXtuPT09ITA/bj1hW3JdOmFbcl0hPT0hMCYmKGk9c1swXSxvLnNwbGljZShmLS0sMCxpKSk7YnJlYWt9fX1pZihuIT09ITApaWYobiYmZVtcInRocm93c1wiXSl0PW4odCk7ZWxzZSB0cnl7dD1uKHQpfWNhdGNoKGwpe3JldHVybntzdGF0ZTpcInBhcnNlcmVycm9yXCIsZXJyb3I6bj9sOlwiTm8gY29udmVyc2lvbiBmcm9tIFwiK3UrXCIgdG8gXCIraX19fXU9aX1yZXR1cm57c3RhdGU6XCJzdWNjZXNzXCIsZGF0YTp0fX1mdW5jdGlvbiBGbigpe3RyeXtyZXR1cm4gbmV3IGUuWE1MSHR0cFJlcXVlc3R9Y2F0Y2godCl7fX1mdW5jdGlvbiBJbigpe3RyeXtyZXR1cm4gbmV3IGUuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfWNhdGNoKHQpe319ZnVuY3Rpb24gJG4oKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3FuPXR9LDApLHFuPXYubm93KCl9ZnVuY3Rpb24gSm4oZSx0KXt2LmVhY2godCxmdW5jdGlvbih0LG4pe3ZhciByPShWblt0XXx8W10pLmNvbmNhdChWbltcIipcIl0pLGk9MCxzPXIubGVuZ3RoO2Zvcig7aTxzO2krKylpZihyW2ldLmNhbGwoZSx0LG4pKXJldHVybn0pfWZ1bmN0aW9uIEtuKGUsdCxuKXt2YXIgcixpPTAscz0wLG89WG4ubGVuZ3RoLHU9di5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBhLmVsZW19KSxhPWZ1bmN0aW9uKCl7dmFyIHQ9cW58fCRuKCksbj1NYXRoLm1heCgwLGYuc3RhcnRUaW1lK2YuZHVyYXRpb24tdCkscj1uL2YuZHVyYXRpb258fDAsaT0xLXIscz0wLG89Zi50d2VlbnMubGVuZ3RoO2Zvcig7czxvO3MrKylmLnR3ZWVuc1tzXS5ydW4oaSk7cmV0dXJuIHUubm90aWZ5V2l0aChlLFtmLGksbl0pLGk8MSYmbz9uOih1LnJlc29sdmVXaXRoKGUsW2ZdKSwhMSl9LGY9dS5wcm9taXNlKHtlbGVtOmUscHJvcHM6di5leHRlbmQoe30sdCksb3B0czp2LmV4dGVuZCghMCx7c3BlY2lhbEVhc2luZzp7fX0sbiksb3JpZ2luYWxQcm9wZXJ0aWVzOnQsb3JpZ2luYWxPcHRpb25zOm4sc3RhcnRUaW1lOnFufHwkbigpLGR1cmF0aW9uOm4uZHVyYXRpb24sdHdlZW5zOltdLGNyZWF0ZVR3ZWVuOmZ1bmN0aW9uKHQsbixyKXt2YXIgaT12LlR3ZWVuKGUsZi5vcHRzLHQsbixmLm9wdHMuc3BlY2lhbEVhc2luZ1t0XXx8Zi5vcHRzLmVhc2luZyk7cmV0dXJuIGYudHdlZW5zLnB1c2goaSksaX0sc3RvcDpmdW5jdGlvbih0KXt2YXIgbj0wLHI9dD9mLnR3ZWVucy5sZW5ndGg6MDtmb3IoO248cjtuKyspZi50d2VlbnNbbl0ucnVuKDEpO3JldHVybiB0P3UucmVzb2x2ZVdpdGgoZSxbZix0XSk6dS5yZWplY3RXaXRoKGUsW2YsdF0pLHRoaXN9fSksbD1mLnByb3BzO1FuKGwsZi5vcHRzLnNwZWNpYWxFYXNpbmcpO2Zvcig7aTxvO2krKyl7cj1YbltpXS5jYWxsKGYsZSxsLGYub3B0cyk7aWYocilyZXR1cm4gcn1yZXR1cm4gSm4oZixsKSx2LmlzRnVuY3Rpb24oZi5vcHRzLnN0YXJ0KSYmZi5vcHRzLnN0YXJ0LmNhbGwoZSxmKSx2LmZ4LnRpbWVyKHYuZXh0ZW5kKGEse2FuaW06ZixxdWV1ZTpmLm9wdHMucXVldWUsZWxlbTplfSkpLGYucHJvZ3Jlc3MoZi5vcHRzLnByb2dyZXNzKS5kb25lKGYub3B0cy5kb25lLGYub3B0cy5jb21wbGV0ZSkuZmFpbChmLm9wdHMuZmFpbCkuYWx3YXlzKGYub3B0cy5hbHdheXMpfWZ1bmN0aW9uIFFuKGUsdCl7dmFyIG4scixpLHMsbztmb3IobiBpbiBlKXtyPXYuY2FtZWxDYXNlKG4pLGk9dFtyXSxzPWVbbl0sdi5pc0FycmF5KHMpJiYoaT1zWzFdLHM9ZVtuXT1zWzBdKSxuIT09ciYmKGVbcl09cyxkZWxldGUgZVtuXSksbz12LmNzc0hvb2tzW3JdO2lmKG8mJlwiZXhwYW5kXCJpbiBvKXtzPW8uZXhwYW5kKHMpLGRlbGV0ZSBlW3JdO2ZvcihuIGluIHMpbiBpbiBlfHwoZVtuXT1zW25dLHRbbl09aSl9ZWxzZSB0W3JdPWl9fWZ1bmN0aW9uIEduKGUsdCxuKXt2YXIgcixpLHMsbyx1LGEsZixsLGMsaD10aGlzLHA9ZS5zdHlsZSxkPXt9LG09W10sZz1lLm5vZGVUeXBlJiZHdChlKTtuLnF1ZXVlfHwobD12Ll9xdWV1ZUhvb2tzKGUsXCJmeFwiKSxsLnVucXVldWVkPT1udWxsJiYobC51bnF1ZXVlZD0wLGM9bC5lbXB0eS5maXJlLGwuZW1wdHkuZmlyZT1mdW5jdGlvbigpe2wudW5xdWV1ZWR8fGMoKX0pLGwudW5xdWV1ZWQrKyxoLmFsd2F5cyhmdW5jdGlvbigpe2guYWx3YXlzKGZ1bmN0aW9uKCl7bC51bnF1ZXVlZC0tLHYucXVldWUoZSxcImZ4XCIpLmxlbmd0aHx8bC5lbXB0eS5maXJlKCl9KX0pKSxlLm5vZGVUeXBlPT09MSYmKFwiaGVpZ2h0XCJpbiB0fHxcIndpZHRoXCJpbiB0KSYmKG4ub3ZlcmZsb3c9W3Aub3ZlcmZsb3cscC5vdmVyZmxvd1gscC5vdmVyZmxvd1ldLHYuY3NzKGUsXCJkaXNwbGF5XCIpPT09XCJpbmxpbmVcIiYmdi5jc3MoZSxcImZsb2F0XCIpPT09XCJub25lXCImJighdi5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXR8fG5uKGUubm9kZU5hbWUpPT09XCJpbmxpbmVcIj9wLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjpwLnpvb209MSkpLG4ub3ZlcmZsb3cmJihwLm92ZXJmbG93PVwiaGlkZGVuXCIsdi5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3N8fGguZG9uZShmdW5jdGlvbigpe3Aub3ZlcmZsb3c9bi5vdmVyZmxvd1swXSxwLm92ZXJmbG93WD1uLm92ZXJmbG93WzFdLHAub3ZlcmZsb3dZPW4ub3ZlcmZsb3dbMl19KSk7Zm9yKHIgaW4gdCl7cz10W3JdO2lmKFVuLmV4ZWMocykpe2RlbGV0ZSB0W3JdLGE9YXx8cz09PVwidG9nZ2xlXCI7aWYocz09PShnP1wiaGlkZVwiOlwic2hvd1wiKSljb250aW51ZTttLnB1c2gocil9fW89bS5sZW5ndGg7aWYobyl7dT12Ll9kYXRhKGUsXCJmeHNob3dcIil8fHYuX2RhdGEoZSxcImZ4c2hvd1wiLHt9KSxcImhpZGRlblwiaW4gdSYmKGc9dS5oaWRkZW4pLGEmJih1LmhpZGRlbj0hZyksZz92KGUpLnNob3coKTpoLmRvbmUoZnVuY3Rpb24oKXt2KGUpLmhpZGUoKX0pLGguZG9uZShmdW5jdGlvbigpe3ZhciB0O3YucmVtb3ZlRGF0YShlLFwiZnhzaG93XCIsITApO2Zvcih0IGluIGQpdi5zdHlsZShlLHQsZFt0XSl9KTtmb3Iocj0wO3I8bztyKyspaT1tW3JdLGY9aC5jcmVhdGVUd2VlbihpLGc/dVtpXTowKSxkW2ldPXVbaV18fHYuc3R5bGUoZSxpKSxpIGluIHV8fCh1W2ldPWYuc3RhcnQsZyYmKGYuZW5kPWYuc3RhcnQsZi5zdGFydD1pPT09XCJ3aWR0aFwifHxpPT09XCJoZWlnaHRcIj8xOjApKX19ZnVuY3Rpb24gWW4oZSx0LG4scixpKXtyZXR1cm4gbmV3IFluLnByb3RvdHlwZS5pbml0KGUsdCxuLHIsaSl9ZnVuY3Rpb24gWm4oZSx0KXt2YXIgbixyPXtoZWlnaHQ6ZX0saT0wO3Q9dD8xOjA7Zm9yKDtpPDQ7aSs9Mi10KW49JHRbaV0scltcIm1hcmdpblwiK25dPXJbXCJwYWRkaW5nXCIrbl09ZTtyZXR1cm4gdCYmKHIub3BhY2l0eT1yLndpZHRoPWUpLHJ9ZnVuY3Rpb24gdHIoZSl7cmV0dXJuIHYuaXNXaW5kb3coZSk/ZTplLm5vZGVUeXBlPT09OT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzohMX12YXIgbixyLGk9ZS5kb2N1bWVudCxzPWUubG9jYXRpb24sbz1lLm5hdmlnYXRvcix1PWUualF1ZXJ5LGE9ZS4kLGY9QXJyYXkucHJvdG90eXBlLnB1c2gsbD1BcnJheS5wcm90b3R5cGUuc2xpY2UsYz1BcnJheS5wcm90b3R5cGUuaW5kZXhPZixoPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcscD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGQ9U3RyaW5nLnByb3RvdHlwZS50cmltLHY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IHYuZm4uaW5pdChlLHQsbil9LG09L1tcXC0rXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvLnNvdXJjZSxnPS9cXFMvLHk9L1xccysvLGI9L15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLHc9L14oPzpbXiM8XSooPFtcXHdcXFddKz4pW14+XSokfCMoW1xcd1xcLV0qKSQpLyxFPS9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxTPS9eW1xcXSw6e31cXHNdKiQvLHg9Lyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFQ9L1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZyxOPS9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGRcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvZyxDPS9eLW1zLS8saz0vLShbXFxkYS16XSkvZ2ksTD1mdW5jdGlvbihlLHQpe3JldHVybih0K1wiXCIpLnRvVXBwZXJDYXNlKCl9LEE9ZnVuY3Rpb24oKXtpLmFkZEV2ZW50TGlzdGVuZXI/KGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixBLCExKSx2LnJlYWR5KCkpOmkucmVhZHlTdGF0ZT09PVwiY29tcGxldGVcIiYmKGkuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixBKSx2LnJlYWR5KCkpfSxPPXt9O3YuZm49di5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnYsaW5pdDpmdW5jdGlvbihlLG4scil7dmFyIHMsbyx1LGE7aWYoIWUpcmV0dXJuIHRoaXM7aWYoZS5ub2RlVHlwZSlyZXR1cm4gdGhpcy5jb250ZXh0PXRoaXNbMF09ZSx0aGlzLmxlbmd0aD0xLHRoaXM7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2UuY2hhckF0KDApPT09XCI8XCImJmUuY2hhckF0KGUubGVuZ3RoLTEpPT09XCI+XCImJmUubGVuZ3RoPj0zP3M9W251bGwsZSxudWxsXTpzPXcuZXhlYyhlKTtpZihzJiYoc1sxXXx8IW4pKXtpZihzWzFdKXJldHVybiBuPW4gaW5zdGFuY2VvZiB2P25bMF06bixhPW4mJm4ubm9kZVR5cGU/bi5vd25lckRvY3VtZW50fHxuOmksZT12LnBhcnNlSFRNTChzWzFdLGEsITApLEUudGVzdChzWzFdKSYmdi5pc1BsYWluT2JqZWN0KG4pJiZ0aGlzLmF0dHIuY2FsbChlLG4sITApLHYubWVyZ2UodGhpcyxlKTtvPWkuZ2V0RWxlbWVudEJ5SWQoc1syXSk7aWYobyYmby5wYXJlbnROb2RlKXtpZihvLmlkIT09c1syXSlyZXR1cm4gci5maW5kKGUpO3RoaXMubGVuZ3RoPTEsdGhpc1swXT1vfXJldHVybiB0aGlzLmNvbnRleHQ9aSx0aGlzLnNlbGVjdG9yPWUsdGhpc31yZXR1cm4hbnx8bi5qcXVlcnk/KG58fHIpLmZpbmQoZSk6dGhpcy5jb25zdHJ1Y3RvcihuKS5maW5kKGUpfXJldHVybiB2LmlzRnVuY3Rpb24oZSk/ci5yZWFkeShlKTooZS5zZWxlY3RvciE9PXQmJih0aGlzLnNlbGVjdG9yPWUuc2VsZWN0b3IsdGhpcy5jb250ZXh0PWUuY29udGV4dCksdi5tYWtlQXJyYXkoZSx0aGlzKSl9LHNlbGVjdG9yOlwiXCIsanF1ZXJ5OlwiMS44LjNcIixsZW5ndGg6MCxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIGwuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiBlPT1udWxsP3RoaXMudG9BcnJheSgpOmU8MD90aGlzW3RoaXMubGVuZ3RoK2VdOnRoaXNbZV19LHB1c2hTdGFjazpmdW5jdGlvbihlLHQsbil7dmFyIHI9di5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksZSk7cmV0dXJuIHIucHJldk9iamVjdD10aGlzLHIuY29udGV4dD10aGlzLmNvbnRleHQsdD09PVwiZmluZFwiP3Iuc2VsZWN0b3I9dGhpcy5zZWxlY3RvcisodGhpcy5zZWxlY3Rvcj9cIiBcIjpcIlwiKStuOnQmJihyLnNlbGVjdG9yPXRoaXMuc2VsZWN0b3IrXCIuXCIrdCtcIihcIituK1wiKVwiKSxyfSxlYWNoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHYuZWFjaCh0aGlzLGUsdCl9LHJlYWR5OmZ1bmN0aW9uKGUpe3JldHVybiB2LnJlYWR5LnByb21pc2UoKS5kb25lKGUpLHRoaXN9LGVxOmZ1bmN0aW9uKGUpe3JldHVybiBlPStlLGU9PT0tMT90aGlzLnNsaWNlKGUpOnRoaXMuc2xpY2UoZSxlKzEpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxcInNsaWNlXCIsbC5jYWxsKGFyZ3VtZW50cykuam9pbihcIixcIikpfSxtYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHYubWFwKHRoaXMsZnVuY3Rpb24odCxuKXtyZXR1cm4gZS5jYWxsKHQsbix0KX0pKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcihudWxsKX0scHVzaDpmLHNvcnQ6W10uc29ydCxzcGxpY2U6W10uc3BsaWNlfSx2LmZuLmluaXQucHJvdG90eXBlPXYuZm4sdi5leHRlbmQ9di5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgZSxuLHIsaSxzLG8sdT1hcmd1bWVudHNbMF18fHt9LGE9MSxmPWFyZ3VtZW50cy5sZW5ndGgsbD0hMTt0eXBlb2YgdT09XCJib29sZWFuXCImJihsPXUsdT1hcmd1bWVudHNbMV18fHt9LGE9MiksdHlwZW9mIHUhPVwib2JqZWN0XCImJiF2LmlzRnVuY3Rpb24odSkmJih1PXt9KSxmPT09YSYmKHU9dGhpcywtLWEpO2Zvcig7YTxmO2ErKylpZigoZT1hcmd1bWVudHNbYV0pIT1udWxsKWZvcihuIGluIGUpe3I9dVtuXSxpPWVbbl07aWYodT09PWkpY29udGludWU7bCYmaSYmKHYuaXNQbGFpbk9iamVjdChpKXx8KHM9di5pc0FycmF5KGkpKSk/KHM/KHM9ITEsbz1yJiZ2LmlzQXJyYXkocik/cjpbXSk6bz1yJiZ2LmlzUGxhaW5PYmplY3Qocik/cjp7fSx1W25dPXYuZXh0ZW5kKGwsbyxpKSk6aSE9PXQmJih1W25dPWkpfXJldHVybiB1fSx2LmV4dGVuZCh7bm9Db25mbGljdDpmdW5jdGlvbih0KXtyZXR1cm4gZS4kPT09diYmKGUuJD1hKSx0JiZlLmpRdWVyeT09PXYmJihlLmpRdWVyeT11KSx2fSxpc1JlYWR5OiExLHJlYWR5V2FpdDoxLGhvbGRSZWFkeTpmdW5jdGlvbihlKXtlP3YucmVhZHlXYWl0Kys6di5yZWFkeSghMCl9LHJlYWR5OmZ1bmN0aW9uKGUpe2lmKGU9PT0hMD8tLXYucmVhZHlXYWl0OnYuaXNSZWFkeSlyZXR1cm47aWYoIWkuYm9keSlyZXR1cm4gc2V0VGltZW91dCh2LnJlYWR5LDEpO3YuaXNSZWFkeT0hMDtpZihlIT09ITAmJi0tdi5yZWFkeVdhaXQ+MClyZXR1cm47ci5yZXNvbHZlV2l0aChpLFt2XSksdi5mbi50cmlnZ2VyJiZ2KGkpLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKX0saXNGdW5jdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gdi50eXBlKGUpPT09XCJmdW5jdGlvblwifSxpc0FycmF5OkFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVybiB2LnR5cGUoZSk9PT1cImFycmF5XCJ9LGlzV2luZG93OmZ1bmN0aW9uKGUpe3JldHVybiBlIT1udWxsJiZlPT1lLndpbmRvd30saXNOdW1lcmljOmZ1bmN0aW9uKGUpe3JldHVybiFpc05hTihwYXJzZUZsb2F0KGUpKSYmaXNGaW5pdGUoZSl9LHR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PW51bGw/U3RyaW5nKGUpOk9baC5jYWxsKGUpXXx8XCJvYmplY3RcIn0saXNQbGFpbk9iamVjdDpmdW5jdGlvbihlKXtpZighZXx8di50eXBlKGUpIT09XCJvYmplY3RcInx8ZS5ub2RlVHlwZXx8di5pc1dpbmRvdyhlKSlyZXR1cm4hMTt0cnl7aWYoZS5jb25zdHJ1Y3RvciYmIXAuY2FsbChlLFwiY29uc3RydWN0b3JcIikmJiFwLmNhbGwoZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXCJpc1Byb3RvdHlwZU9mXCIpKXJldHVybiExfWNhdGNoKG4pe3JldHVybiExfXZhciByO2ZvcihyIGluIGUpO3JldHVybiByPT09dHx8cC5jYWxsKGUscil9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQ7Zm9yKHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sZXJyb3I6ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKGUpfSxwYXJzZUhUTUw6ZnVuY3Rpb24oZSx0LG4pe3ZhciByO3JldHVybiFlfHx0eXBlb2YgZSE9XCJzdHJpbmdcIj9udWxsOih0eXBlb2YgdD09XCJib29sZWFuXCImJihuPXQsdD0wKSx0PXR8fGksKHI9RS5leGVjKGUpKT9bdC5jcmVhdGVFbGVtZW50KHJbMV0pXToocj12LmJ1aWxkRnJhZ21lbnQoW2VdLHQsbj9udWxsOltdKSx2Lm1lcmdlKFtdLChyLmNhY2hlYWJsZT92LmNsb25lKHIuZnJhZ21lbnQpOnIuZnJhZ21lbnQpLmNoaWxkTm9kZXMpKSl9LHBhcnNlSlNPTjpmdW5jdGlvbih0KXtpZighdHx8dHlwZW9mIHQhPVwic3RyaW5nXCIpcmV0dXJuIG51bGw7dD12LnRyaW0odCk7aWYoZS5KU09OJiZlLkpTT04ucGFyc2UpcmV0dXJuIGUuSlNPTi5wYXJzZSh0KTtpZihTLnRlc3QodC5yZXBsYWNlKFQsXCJAXCIpLnJlcGxhY2UoTixcIl1cIikucmVwbGFjZSh4LFwiXCIpKSlyZXR1cm4obmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiK3QpKSgpO3YuZXJyb3IoXCJJbnZhbGlkIEpTT046IFwiK3QpfSxwYXJzZVhNTDpmdW5jdGlvbihuKXt2YXIgcixpO2lmKCFufHx0eXBlb2YgbiE9XCJzdHJpbmdcIilyZXR1cm4gbnVsbDt0cnl7ZS5ET01QYXJzZXI/KGk9bmV3IERPTVBhcnNlcixyPWkucGFyc2VGcm9tU3RyaW5nKG4sXCJ0ZXh0L3htbFwiKSk6KHI9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpLHIuYXN5bmM9XCJmYWxzZVwiLHIubG9hZFhNTChuKSl9Y2F0Y2gocyl7cj10fXJldHVybighcnx8IXIuZG9jdW1lbnRFbGVtZW50fHxyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSYmdi5lcnJvcihcIkludmFsaWQgWE1MOiBcIituKSxyfSxub29wOmZ1bmN0aW9uKCl7fSxnbG9iYWxFdmFsOmZ1bmN0aW9uKHQpe3QmJmcudGVzdCh0KSYmKGUuZXhlY1NjcmlwdHx8ZnVuY3Rpb24odCl7ZS5ldmFsLmNhbGwoZSx0KX0pKHQpfSxjYW1lbENhc2U6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZShDLFwibXMtXCIpLnJlcGxhY2UoayxMKX0sbm9kZU5hbWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09dC50b0xvd2VyQ2FzZSgpfSxlYWNoOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxzPTAsbz1lLmxlbmd0aCx1PW89PT10fHx2LmlzRnVuY3Rpb24oZSk7aWYocil7aWYodSl7Zm9yKGkgaW4gZSlpZihuLmFwcGx5KGVbaV0scik9PT0hMSlicmVha31lbHNlIGZvcig7czxvOylpZihuLmFwcGx5KGVbcysrXSxyKT09PSExKWJyZWFrfWVsc2UgaWYodSl7Zm9yKGkgaW4gZSlpZihuLmNhbGwoZVtpXSxpLGVbaV0pPT09ITEpYnJlYWt9ZWxzZSBmb3IoO3M8bzspaWYobi5jYWxsKGVbc10scyxlW3MrK10pPT09ITEpYnJlYWs7cmV0dXJuIGV9LHRyaW06ZCYmIWQuY2FsbChcIlxcdWZlZmZcXHUwMGEwXCIpP2Z1bmN0aW9uKGUpe3JldHVybiBlPT1udWxsP1wiXCI6ZC5jYWxsKGUpfTpmdW5jdGlvbihlKXtyZXR1cm4gZT09bnVsbD9cIlwiOihlK1wiXCIpLnJlcGxhY2UoYixcIlwiKX0sbWFrZUFycmF5OmZ1bmN0aW9uKGUsdCl7dmFyIG4scj10fHxbXTtyZXR1cm4gZSE9bnVsbCYmKG49di50eXBlKGUpLGUubGVuZ3RoPT1udWxsfHxuPT09XCJzdHJpbmdcInx8bj09PVwiZnVuY3Rpb25cInx8bj09PVwicmVnZXhwXCJ8fHYuaXNXaW5kb3coZSk/Zi5jYWxsKHIsZSk6di5tZXJnZShyLGUpKSxyfSxpbkFycmF5OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZih0KXtpZihjKXJldHVybiBjLmNhbGwodCxlLG4pO3I9dC5sZW5ndGgsbj1uP248MD9NYXRoLm1heCgwLHIrbik6bjowO2Zvcig7bjxyO24rKylpZihuIGluIHQmJnRbbl09PT1lKXJldHVybiBufXJldHVybi0xfSxtZXJnZTpmdW5jdGlvbihlLG4pe3ZhciByPW4ubGVuZ3RoLGk9ZS5sZW5ndGgscz0wO2lmKHR5cGVvZiByPT1cIm51bWJlclwiKWZvcig7czxyO3MrKyllW2krK109bltzXTtlbHNlIHdoaWxlKG5bc10hPT10KWVbaSsrXT1uW3MrK107cmV0dXJuIGUubGVuZ3RoPWksZX0sZ3JlcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT1bXSxzPTAsbz1lLmxlbmd0aDtuPSEhbjtmb3IoO3M8bztzKyspcj0hIXQoZVtzXSxzKSxuIT09ciYmaS5wdXNoKGVbc10pO3JldHVybiBpfSxtYXA6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpLHMsbz1bXSx1PTAsYT1lLmxlbmd0aCxmPWUgaW5zdGFuY2VvZiB2fHxhIT09dCYmdHlwZW9mIGE9PVwibnVtYmVyXCImJihhPjAmJmVbMF0mJmVbYS0xXXx8YT09PTB8fHYuaXNBcnJheShlKSk7aWYoZilmb3IoO3U8YTt1KyspaT1uKGVbdV0sdSxyKSxpIT1udWxsJiYob1tvLmxlbmd0aF09aSk7ZWxzZSBmb3IocyBpbiBlKWk9bihlW3NdLHMsciksaSE9bnVsbCYmKG9bby5sZW5ndGhdPWkpO3JldHVybiBvLmNvbmNhdC5hcHBseShbXSxvKX0sZ3VpZDoxLHByb3h5OmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxzO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIiYmKHI9ZVtuXSxuPWUsZT1yKSx2LmlzRnVuY3Rpb24oZSk/KGk9bC5jYWxsKGFyZ3VtZW50cywyKSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkobixpLmNvbmNhdChsLmNhbGwoYXJndW1lbnRzKSkpfSxzLmd1aWQ9ZS5ndWlkPWUuZ3VpZHx8di5ndWlkKysscyk6dH0sYWNjZXNzOmZ1bmN0aW9uKGUsbixyLGkscyxvLHUpe3ZhciBhLGY9cj09bnVsbCxsPTAsYz1lLmxlbmd0aDtpZihyJiZ0eXBlb2Ygcj09XCJvYmplY3RcIil7Zm9yKGwgaW4gcil2LmFjY2VzcyhlLG4sbCxyW2xdLDEsbyxpKTtzPTF9ZWxzZSBpZihpIT09dCl7YT11PT09dCYmdi5pc0Z1bmN0aW9uKGkpLGYmJihhPyhhPW4sbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGEuY2FsbCh2KGUpLG4pfSk6KG4uY2FsbChlLGkpLG49bnVsbCkpO2lmKG4pZm9yKDtsPGM7bCsrKW4oZVtsXSxyLGE/aS5jYWxsKGVbbF0sbCxuKGVbbF0scikpOmksdSk7cz0xfXJldHVybiBzP2U6Zj9uLmNhbGwoZSk6Yz9uKGVbMF0scik6b30sbm93OmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9fSksdi5yZWFkeS5wcm9taXNlPWZ1bmN0aW9uKHQpe2lmKCFyKXtyPXYuRGVmZXJyZWQoKTtpZihpLnJlYWR5U3RhdGU9PT1cImNvbXBsZXRlXCIpc2V0VGltZW91dCh2LnJlYWR5LDEpO2Vsc2UgaWYoaS5hZGRFdmVudExpc3RlbmVyKWkuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixBLCExKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdi5yZWFkeSwhMSk7ZWxzZXtpLmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsQSksZS5hdHRhY2hFdmVudChcIm9ubG9hZFwiLHYucmVhZHkpO3ZhciBuPSExO3RyeXtuPWUuZnJhbWVFbGVtZW50PT1udWxsJiZpLmRvY3VtZW50RWxlbWVudH1jYXRjaChzKXt9biYmbi5kb1Njcm9sbCYmZnVuY3Rpb24gbygpe2lmKCF2LmlzUmVhZHkpe3RyeXtuLmRvU2Nyb2xsKFwibGVmdFwiKX1jYXRjaChlKXtyZXR1cm4gc2V0VGltZW91dChvLDUwKX12LnJlYWR5KCl9fSgpfX1yZXR1cm4gci5wcm9taXNlKHQpfSx2LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGUsdCl7T1tcIltvYmplY3QgXCIrdCtcIl1cIl09dC50b0xvd2VyQ2FzZSgpfSksbj12KGkpO3ZhciBNPXt9O3YuQ2FsbGJhY2tzPWZ1bmN0aW9uKGUpe2U9dHlwZW9mIGU9PVwic3RyaW5nXCI/TVtlXXx8XyhlKTp2LmV4dGVuZCh7fSxlKTt2YXIgbixyLGkscyxvLHUsYT1bXSxmPSFlLm9uY2UmJltdLGw9ZnVuY3Rpb24odCl7bj1lLm1lbW9yeSYmdCxyPSEwLHU9c3x8MCxzPTAsbz1hLmxlbmd0aCxpPSEwO2Zvcig7YSYmdTxvO3UrKylpZihhW3VdLmFwcGx5KHRbMF0sdFsxXSk9PT0hMSYmZS5zdG9wT25GYWxzZSl7bj0hMTticmVha31pPSExLGEmJihmP2YubGVuZ3RoJiZsKGYuc2hpZnQoKSk6bj9hPVtdOmMuZGlzYWJsZSgpKX0sYz17YWRkOmZ1bmN0aW9uKCl7aWYoYSl7dmFyIHQ9YS5sZW5ndGg7KGZ1bmN0aW9uIHIodCl7di5lYWNoKHQsZnVuY3Rpb24odCxuKXt2YXIgaT12LnR5cGUobik7aT09PVwiZnVuY3Rpb25cIj8oIWUudW5pcXVlfHwhYy5oYXMobikpJiZhLnB1c2gobik6biYmbi5sZW5ndGgmJmkhPT1cInN0cmluZ1wiJiZyKG4pfSl9KShhcmd1bWVudHMpLGk/bz1hLmxlbmd0aDpuJiYocz10LGwobikpfXJldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gYSYmdi5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihlLHQpe3ZhciBuO3doaWxlKChuPXYuaW5BcnJheSh0LGEsbikpPi0xKWEuc3BsaWNlKG4sMSksaSYmKG48PW8mJm8tLSxuPD11JiZ1LS0pfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiB2LmluQXJyYXkoZSxhKT4tMX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gYT1bXSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGE9Zj1uPXQsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hYX0sbG9jazpmdW5jdGlvbigpe3JldHVybiBmPXQsbnx8Yy5kaXNhYmxlKCksdGhpc30sbG9ja2VkOmZ1bmN0aW9uKCl7cmV0dXJuIWZ9LGZpcmVXaXRoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dHx8W10sdD1bZSx0LnNsaWNlP3Quc2xpY2UoKTp0XSxhJiYoIXJ8fGYpJiYoaT9mLnB1c2godCk6bCh0KSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBjLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhcn19O3JldHVybiBjfSx2LmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9W1tcInJlc29sdmVcIixcImRvbmVcIix2LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsdi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIix2LkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLG49XCJwZW5kaW5nXCIscj17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzO3JldHVybiB2LkRlZmVycmVkKGZ1bmN0aW9uKG4pe3YuZWFjaCh0LGZ1bmN0aW9uKHQscil7dmFyIHM9clswXSxvPWVbdF07aVtyWzFdXSh2LmlzRnVuY3Rpb24obyk/ZnVuY3Rpb24oKXt2YXIgZT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtlJiZ2LmlzRnVuY3Rpb24oZS5wcm9taXNlKT9lLnByb21pc2UoKS5kb25lKG4ucmVzb2x2ZSkuZmFpbChuLnJlamVjdCkucHJvZ3Jlc3Mobi5ub3RpZnkpOm5bcytcIldpdGhcIl0odGhpcz09PWk/bjp0aGlzLFtlXSl9Om5bc10pfSksZT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlIT1udWxsP3YuZXh0ZW5kKGUscik6cn19LGk9e307cmV0dXJuIHIucGlwZT1yLnRoZW4sdi5lYWNoKHQsZnVuY3Rpb24oZSxzKXt2YXIgbz1zWzJdLHU9c1szXTtyW3NbMV1dPW8uYWRkLHUmJm8uYWRkKGZ1bmN0aW9uKCl7bj11fSx0W2VeMV1bMl0uZGlzYWJsZSx0WzJdWzJdLmxvY2spLGlbc1swXV09by5maXJlLGlbc1swXStcIldpdGhcIl09by5maXJlV2l0aH0pLHIucHJvbWlzZShpKSxlJiZlLmNhbGwoaSxpKSxpfSx3aGVuOmZ1bmN0aW9uKGUpe3ZhciB0PTAsbj1sLmNhbGwoYXJndW1lbnRzKSxyPW4ubGVuZ3RoLGk9ciE9PTF8fGUmJnYuaXNGdW5jdGlvbihlLnByb21pc2UpP3I6MCxzPWk9PT0xP2U6di5EZWZlcnJlZCgpLG89ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBmdW5jdGlvbihyKXt0W2VdPXRoaXMsbltlXT1hcmd1bWVudHMubGVuZ3RoPjE/bC5jYWxsKGFyZ3VtZW50cyk6cixuPT09dT9zLm5vdGlmeVdpdGgodCxuKTotLWl8fHMucmVzb2x2ZVdpdGgodCxuKX19LHUsYSxmO2lmKHI+MSl7dT1uZXcgQXJyYXkociksYT1uZXcgQXJyYXkociksZj1uZXcgQXJyYXkocik7Zm9yKDt0PHI7dCsrKW5bdF0mJnYuaXNGdW5jdGlvbihuW3RdLnByb21pc2UpP25bdF0ucHJvbWlzZSgpLmRvbmUobyh0LGYsbikpLmZhaWwocy5yZWplY3QpLnByb2dyZXNzKG8odCxhLHUpKTotLWl9cmV0dXJuIGl8fHMucmVzb2x2ZVdpdGgoZixuKSxzLnByb21pc2UoKX19KSx2LnN1cHBvcnQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHIscyxvLHUsYSxmLGwsYyxoLHA9aS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3Auc2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIsXCJ0XCIpLHAuaW5uZXJIVE1MPVwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCIsbj1wLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSxyPXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWzBdO2lmKCFufHwhcnx8IW4ubGVuZ3RoKXJldHVybnt9O3M9aS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLG89cy5hcHBlbmRDaGlsZChpLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLHU9cC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLHIuc3R5bGUuY3NzVGV4dD1cInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCIsdD17bGVhZGluZ1doaXRlc3BhY2U6cC5maXJzdENoaWxkLm5vZGVUeXBlPT09Myx0Ym9keTohcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxodG1sU2VyaWFsaXplOiEhcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLHN0eWxlOi90b3AvLnRlc3Qoci5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSksaHJlZk5vcm1hbGl6ZWQ6ci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpPT09XCIvYVwiLG9wYWNpdHk6L14wLjUvLnRlc3Qoci5zdHlsZS5vcGFjaXR5KSxjc3NGbG9hdDohIXIuc3R5bGUuY3NzRmxvYXQsY2hlY2tPbjp1LnZhbHVlPT09XCJvblwiLG9wdFNlbGVjdGVkOm8uc2VsZWN0ZWQsZ2V0U2V0QXR0cmlidXRlOnAuY2xhc3NOYW1lIT09XCJ0XCIsZW5jdHlwZTohIWkuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSxodG1sNUNsb25lOmkuY3JlYXRlRWxlbWVudChcIm5hdlwiKS5jbG9uZU5vZGUoITApLm91dGVySFRNTCE9PVwiPDpuYXY+PC86bmF2PlwiLGJveE1vZGVsOmkuY29tcGF0TW9kZT09PVwiQ1NTMUNvbXBhdFwiLHN1Ym1pdEJ1YmJsZXM6ITAsY2hhbmdlQnViYmxlczohMCxmb2N1c2luQnViYmxlczohMSxkZWxldGVFeHBhbmRvOiEwLG5vQ2xvbmVFdmVudDohMCxpbmxpbmVCbG9ja05lZWRzTGF5b3V0OiExLHNocmlua1dyYXBCbG9ja3M6ITEscmVsaWFibGVNYXJnaW5SaWdodDohMCxib3hTaXppbmdSZWxpYWJsZTohMCxwaXhlbFBvc2l0aW9uOiExfSx1LmNoZWNrZWQ9ITAsdC5ub0Nsb25lQ2hlY2tlZD11LmNsb25lTm9kZSghMCkuY2hlY2tlZCxzLmRpc2FibGVkPSEwLHQub3B0RGlzYWJsZWQ9IW8uZGlzYWJsZWQ7dHJ5e2RlbGV0ZSBwLnRlc3R9Y2F0Y2goZCl7dC5kZWxldGVFeHBhbmRvPSExfSFwLmFkZEV2ZW50TGlzdGVuZXImJnAuYXR0YWNoRXZlbnQmJnAuZmlyZUV2ZW50JiYocC5hdHRhY2hFdmVudChcIm9uY2xpY2tcIixoPWZ1bmN0aW9uKCl7dC5ub0Nsb25lRXZlbnQ9ITF9KSxwLmNsb25lTm9kZSghMCkuZmlyZUV2ZW50KFwib25jbGlja1wiKSxwLmRldGFjaEV2ZW50KFwib25jbGlja1wiLGgpKSx1PWkuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLHUudmFsdWU9XCJ0XCIsdS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJyYWRpb1wiKSx0LnJhZGlvVmFsdWU9dS52YWx1ZT09PVwidFwiLHUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLFwiY2hlY2tlZFwiKSx1LnNldEF0dHJpYnV0ZShcIm5hbWVcIixcInRcIikscC5hcHBlbmRDaGlsZCh1KSxhPWkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGEuYXBwZW5kQ2hpbGQocC5sYXN0Q2hpbGQpLHQuY2hlY2tDbG9uZT1hLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCx0LmFwcGVuZENoZWNrZWQ9dS5jaGVja2VkLGEucmVtb3ZlQ2hpbGQodSksYS5hcHBlbmRDaGlsZChwKTtpZihwLmF0dGFjaEV2ZW50KWZvcihsIGlue3N1Ym1pdDohMCxjaGFuZ2U6ITAsZm9jdXNpbjohMH0pZj1cIm9uXCIrbCxjPWYgaW4gcCxjfHwocC5zZXRBdHRyaWJ1dGUoZixcInJldHVybjtcIiksYz10eXBlb2YgcFtmXT09XCJmdW5jdGlvblwiKSx0W2wrXCJCdWJibGVzXCJdPWM7cmV0dXJuIHYoZnVuY3Rpb24oKXt2YXIgbixyLHMsbyx1PVwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVuO1wiLGE9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07aWYoIWEpcmV0dXJuO249aS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG4uc3R5bGUuY3NzVGV4dD1cInZpc2liaWxpdHk6aGlkZGVuO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7cG9zaXRpb246c3RhdGljO3RvcDowO21hcmdpbi10b3A6MXB4XCIsYS5pbnNlcnRCZWZvcmUobixhLmZpcnN0Q2hpbGQpLHI9aS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG4uYXBwZW5kQ2hpbGQociksci5pbm5lckhUTUw9XCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCIscz1yLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIiksc1swXS5zdHlsZS5jc3NUZXh0PVwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZVwiLGM9c1swXS5vZmZzZXRIZWlnaHQ9PT0wLHNbMF0uc3R5bGUuZGlzcGxheT1cIlwiLHNbMV0uc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cz1jJiZzWzBdLm9mZnNldEhlaWdodD09PTAsci5pbm5lckhUTUw9XCJcIixyLnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoxcHg7Ym9yZGVyOjFweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjRweDttYXJnaW4tdG9wOjElO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxJTtcIix0LmJveFNpemluZz1yLm9mZnNldFdpZHRoPT09NCx0LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0PWEub2Zmc2V0VG9wIT09MSxlLmdldENvbXB1dGVkU3R5bGUmJih0LnBpeGVsUG9zaXRpb249KGUuZ2V0Q29tcHV0ZWRTdHlsZShyLG51bGwpfHx7fSkudG9wIT09XCIxJVwiLHQuYm94U2l6aW5nUmVsaWFibGU9KGUuZ2V0Q29tcHV0ZWRTdHlsZShyLG51bGwpfHx7d2lkdGg6XCI0cHhcIn0pLndpZHRoPT09XCI0cHhcIixvPWkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxvLnN0eWxlLmNzc1RleHQ9ci5zdHlsZS5jc3NUZXh0PXUsby5zdHlsZS5tYXJnaW5SaWdodD1vLnN0eWxlLndpZHRoPVwiMFwiLHIuc3R5bGUud2lkdGg9XCIxcHhcIixyLmFwcGVuZENoaWxkKG8pLHQucmVsaWFibGVNYXJnaW5SaWdodD0hcGFyc2VGbG9hdCgoZS5nZXRDb21wdXRlZFN0eWxlKG8sbnVsbCl8fHt9KS5tYXJnaW5SaWdodCkpLHR5cGVvZiByLnN0eWxlLnpvb20hPVwidW5kZWZpbmVkXCImJihyLmlubmVySFRNTD1cIlwiLHIuc3R5bGUuY3NzVGV4dD11K1wid2lkdGg6MXB4O3BhZGRpbmc6MXB4O2Rpc3BsYXk6aW5saW5lO3pvb206MVwiLHQuaW5saW5lQmxvY2tOZWVkc0xheW91dD1yLm9mZnNldFdpZHRoPT09MyxyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHIuc3R5bGUub3ZlcmZsb3c9XCJ2aXNpYmxlXCIsci5pbm5lckhUTUw9XCI8ZGl2PjwvZGl2PlwiLHIuZmlyc3RDaGlsZC5zdHlsZS53aWR0aD1cIjVweFwiLHQuc2hyaW5rV3JhcEJsb2Nrcz1yLm9mZnNldFdpZHRoIT09MyxuLnN0eWxlLnpvb209MSksYS5yZW1vdmVDaGlsZChuKSxuPXI9cz1vPW51bGx9KSxhLnJlbW92ZUNoaWxkKHApLG49cj1zPW89dT1hPXA9bnVsbCx0fSgpO3ZhciBEPS8oPzpcXHtbXFxzXFxTXSpcXH18XFxbW1xcc1xcU10qXFxdKSQvLFA9LyhbQS1aXSkvZzt2LmV4dGVuZCh7Y2FjaGU6e30sZGVsZXRlZElkczpbXSx1dWlkOjAsZXhwYW5kbzpcImpRdWVyeVwiKyh2LmZuLmpxdWVyeStNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxub0RhdGE6e2VtYmVkOiEwLG9iamVjdDpcImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiLGFwcGxldDohMH0saGFzRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4gZT1lLm5vZGVUeXBlP3YuY2FjaGVbZVt2LmV4cGFuZG9dXTplW3YuZXhwYW5kb10sISFlJiYhQihlKX0sZGF0YTpmdW5jdGlvbihlLG4scixpKXtpZighdi5hY2NlcHREYXRhKGUpKXJldHVybjt2YXIgcyxvLHU9di5leHBhbmRvLGE9dHlwZW9mIG49PVwic3RyaW5nXCIsZj1lLm5vZGVUeXBlLGw9Zj92LmNhY2hlOmUsYz1mP2VbdV06ZVt1XSYmdTtpZigoIWN8fCFsW2NdfHwhaSYmIWxbY10uZGF0YSkmJmEmJnI9PT10KXJldHVybjtjfHwoZj9lW3VdPWM9di5kZWxldGVkSWRzLnBvcCgpfHx2Lmd1aWQrKzpjPXUpLGxbY118fChsW2NdPXt9LGZ8fChsW2NdLnRvSlNPTj12Lm5vb3ApKTtpZih0eXBlb2Ygbj09XCJvYmplY3RcInx8dHlwZW9mIG49PVwiZnVuY3Rpb25cIilpP2xbY109di5leHRlbmQobFtjXSxuKTpsW2NdLmRhdGE9di5leHRlbmQobFtjXS5kYXRhLG4pO3JldHVybiBzPWxbY10saXx8KHMuZGF0YXx8KHMuZGF0YT17fSkscz1zLmRhdGEpLHIhPT10JiYoc1t2LmNhbWVsQ2FzZShuKV09ciksYT8obz1zW25dLG89PW51bGwmJihvPXNbdi5jYW1lbENhc2UobildKSk6bz1zLG99LHJlbW92ZURhdGE6ZnVuY3Rpb24oZSx0LG4pe2lmKCF2LmFjY2VwdERhdGEoZSkpcmV0dXJuO3ZhciByLGkscyxvPWUubm9kZVR5cGUsdT1vP3YuY2FjaGU6ZSxhPW8/ZVt2LmV4cGFuZG9dOnYuZXhwYW5kbztpZighdVthXSlyZXR1cm47aWYodCl7cj1uP3VbYV06dVthXS5kYXRhO2lmKHIpe3YuaXNBcnJheSh0KXx8KHQgaW4gcj90PVt0XToodD12LmNhbWVsQ2FzZSh0KSx0IGluIHI/dD1bdF06dD10LnNwbGl0KFwiIFwiKSkpO2ZvcihpPTAscz10Lmxlbmd0aDtpPHM7aSsrKWRlbGV0ZSByW3RbaV1dO2lmKCEobj9COnYuaXNFbXB0eU9iamVjdCkocikpcmV0dXJufX1pZighbil7ZGVsZXRlIHVbYV0uZGF0YTtpZighQih1W2FdKSlyZXR1cm59bz92LmNsZWFuRGF0YShbZV0sITApOnYuc3VwcG9ydC5kZWxldGVFeHBhbmRvfHx1IT11LndpbmRvdz9kZWxldGUgdVthXTp1W2FdPW51bGx9LF9kYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdi5kYXRhKGUsdCxuLCEwKX0sYWNjZXB0RGF0YTpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lJiZ2Lm5vRGF0YVtlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO3JldHVybiF0fHx0IT09ITAmJmUuZ2V0QXR0cmlidXRlKFwiY2xhc3NpZFwiKT09PXR9fSksdi5mbi5leHRlbmQoe2RhdGE6ZnVuY3Rpb24oZSxuKXt2YXIgcixpLHMsbyx1LGE9dGhpc1swXSxmPTAsbD1udWxsO2lmKGU9PT10KXtpZih0aGlzLmxlbmd0aCl7bD12LmRhdGEoYSk7aWYoYS5ub2RlVHlwZT09PTEmJiF2Ll9kYXRhKGEsXCJwYXJzZWRBdHRyc1wiKSl7cz1hLmF0dHJpYnV0ZXM7Zm9yKHU9cy5sZW5ndGg7Zjx1O2YrKylvPXNbZl0ubmFtZSxvLmluZGV4T2YoXCJkYXRhLVwiKXx8KG89di5jYW1lbENhc2Uoby5zdWJzdHJpbmcoNSkpLEgoYSxvLGxbb10pKTt2Ll9kYXRhKGEsXCJwYXJzZWRBdHRyc1wiLCEwKX19cmV0dXJuIGx9cmV0dXJuIHR5cGVvZiBlPT1cIm9iamVjdFwiP3RoaXMuZWFjaChmdW5jdGlvbigpe3YuZGF0YSh0aGlzLGUpfSk6KHI9ZS5zcGxpdChcIi5cIiwyKSxyWzFdPXJbMV0/XCIuXCIrclsxXTpcIlwiLGk9clsxXStcIiFcIix2LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKG4pe2lmKG49PT10KXJldHVybiBsPXRoaXMudHJpZ2dlckhhbmRsZXIoXCJnZXREYXRhXCIraSxbclswXV0pLGw9PT10JiZhJiYobD12LmRhdGEoYSxlKSxsPUgoYSxlLGwpKSxsPT09dCYmclsxXT90aGlzLmRhdGEoclswXSk6bDtyWzFdPW4sdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9dih0aGlzKTt0LnRyaWdnZXJIYW5kbGVyKFwic2V0RGF0YVwiK2ksciksdi5kYXRhKHRoaXMsZSxuKSx0LnRyaWdnZXJIYW5kbGVyKFwiY2hhbmdlRGF0YVwiK2kscil9KX0sbnVsbCxuLGFyZ3VtZW50cy5sZW5ndGg+MSxudWxsLCExKSl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3YucmVtb3ZlRGF0YSh0aGlzLGUpfSl9fSksdi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZihlKXJldHVybiB0PSh0fHxcImZ4XCIpK1wicXVldWVcIixyPXYuX2RhdGEoZSx0KSxuJiYoIXJ8fHYuaXNBcnJheShuKT9yPXYuX2RhdGEoZSx0LHYubWFrZUFycmF5KG4pKTpyLnB1c2gobikpLHJ8fFtdfSxkZXF1ZXVlOmZ1bmN0aW9uKGUsdCl7dD10fHxcImZ4XCI7dmFyIG49di5xdWV1ZShlLHQpLHI9bi5sZW5ndGgsaT1uLnNoaWZ0KCkscz12Ll9xdWV1ZUhvb2tzKGUsdCksbz1mdW5jdGlvbigpe3YuZGVxdWV1ZShlLHQpfTtpPT09XCJpbnByb2dyZXNzXCImJihpPW4uc2hpZnQoKSxyLS0pLGkmJih0PT09XCJmeFwiJiZuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLGRlbGV0ZSBzLnN0b3AsaS5jYWxsKGUsbyxzKSksIXImJnMmJnMuZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIHYuX2RhdGEoZSxuKXx8di5fZGF0YShlLG4se2VtcHR5OnYuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7di5yZW1vdmVEYXRhKGUsdCtcInF1ZXVlXCIsITApLHYucmVtb3ZlRGF0YShlLG4sITApfSl9KX19KSx2LmZuLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oZSxuKXt2YXIgcj0yO3JldHVybiB0eXBlb2YgZSE9XCJzdHJpbmdcIiYmKG49ZSxlPVwiZnhcIixyLS0pLGFyZ3VtZW50cy5sZW5ndGg8cj92LnF1ZXVlKHRoaXNbMF0sZSk6bj09PXQ/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD12LnF1ZXVlKHRoaXMsZSxuKTt2Ll9xdWV1ZUhvb2tzKHRoaXMsZSksZT09PVwiZnhcIiYmdFswXSE9PVwiaW5wcm9ncmVzc1wiJiZ2LmRlcXVldWUodGhpcyxlKX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2LmRlcXVldWUodGhpcyxlKX0pfSxkZWxheTpmdW5jdGlvbihlLHQpe3JldHVybiBlPXYuZng/di5meC5zcGVlZHNbZV18fGU6ZSx0PXR8fFwiZnhcIix0aGlzLnF1ZXVlKHQsZnVuY3Rpb24odCxuKXt2YXIgcj1zZXRUaW1lb3V0KHQsZSk7bi5zdG9wPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpfX0pfSxjbGVhclF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSl9LHByb21pc2U6ZnVuY3Rpb24oZSxuKXt2YXIgcixpPTEscz12LkRlZmVycmVkKCksbz10aGlzLHU9dGhpcy5sZW5ndGgsYT1mdW5jdGlvbigpey0taXx8cy5yZXNvbHZlV2l0aChvLFtvXSl9O3R5cGVvZiBlIT1cInN0cmluZ1wiJiYobj1lLGU9dCksZT1lfHxcImZ4XCI7d2hpbGUodS0tKXI9di5fZGF0YShvW3VdLGUrXCJxdWV1ZUhvb2tzXCIpLHImJnIuZW1wdHkmJihpKyssci5lbXB0eS5hZGQoYSkpO3JldHVybiBhKCkscy5wcm9taXNlKG4pfX0pO3ZhciBqLEYsSSxxPS9bXFx0XFxyXFxuXS9nLFI9L1xcci9nLFU9L14oPzpidXR0b258aW5wdXQpJC9pLHo9L14oPzpidXR0b258aW5wdXR8b2JqZWN0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksVz0vXmEoPzpyZWF8KSQvaSxYPS9eKD86YXV0b2ZvY3VzfGF1dG9wbGF5fGFzeW5jfGNoZWNrZWR8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWR8c2VsZWN0ZWQpJC9pLFY9di5zdXBwb3J0LmdldFNldEF0dHJpYnV0ZTt2LmZuLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihlLHQpe3JldHVybiB2LmFjY2Vzcyh0aGlzLHYuYXR0cixlLHQsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7di5yZW1vdmVBdHRyKHRoaXMsZSl9KX0scHJvcDpmdW5jdGlvbihlLHQpe3JldHVybiB2LmFjY2Vzcyh0aGlzLHYucHJvcCxlLHQsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlUHJvcDpmdW5jdGlvbihlKXtyZXR1cm4gZT12LnByb3BGaXhbZV18fGUsdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dHJ5e3RoaXNbZV09dCxkZWxldGUgdGhpc1tlXX1jYXRjaChuKXt9fSl9LGFkZENsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLHMsbyx1O2lmKHYuaXNGdW5jdGlvbihlKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3YodGhpcykuYWRkQ2xhc3MoZS5jYWxsKHRoaXMsdCx0aGlzLmNsYXNzTmFtZSkpfSk7aWYoZSYmdHlwZW9mIGU9PVwic3RyaW5nXCIpe3Q9ZS5zcGxpdCh5KTtmb3Iobj0wLHI9dGhpcy5sZW5ndGg7bjxyO24rKyl7aT10aGlzW25dO2lmKGkubm9kZVR5cGU9PT0xKWlmKCFpLmNsYXNzTmFtZSYmdC5sZW5ndGg9PT0xKWkuY2xhc3NOYW1lPWU7ZWxzZXtzPVwiIFwiK2kuY2xhc3NOYW1lK1wiIFwiO2ZvcihvPTAsdT10Lmxlbmd0aDtvPHU7bysrKXMuaW5kZXhPZihcIiBcIit0W29dK1wiIFwiKTwwJiYocys9dFtvXStcIiBcIik7aS5jbGFzc05hbWU9di50cmltKHMpfX19cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUpe3ZhciBuLHIsaSxzLG8sdSxhO2lmKHYuaXNGdW5jdGlvbihlKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3YodGhpcykucmVtb3ZlQ2xhc3MoZS5jYWxsKHRoaXMsdCx0aGlzLmNsYXNzTmFtZSkpfSk7aWYoZSYmdHlwZW9mIGU9PVwic3RyaW5nXCJ8fGU9PT10KXtuPShlfHxcIlwiKS5zcGxpdCh5KTtmb3IodT0wLGE9dGhpcy5sZW5ndGg7dTxhO3UrKyl7aT10aGlzW3VdO2lmKGkubm9kZVR5cGU9PT0xJiZpLmNsYXNzTmFtZSl7cj0oXCIgXCIraS5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UocSxcIiBcIik7Zm9yKHM9MCxvPW4ubGVuZ3RoO3M8bztzKyspd2hpbGUoci5pbmRleE9mKFwiIFwiK25bc10rXCIgXCIpPj0wKXI9ci5yZXBsYWNlKFwiIFwiK25bc10rXCIgXCIsXCIgXCIpO2kuY2xhc3NOYW1lPWU/di50cmltKHIpOlwiXCJ9fX1yZXR1cm4gdGhpc30sdG9nZ2xlQ2xhc3M6ZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2YgZSxyPXR5cGVvZiB0PT1cImJvb2xlYW5cIjtyZXR1cm4gdi5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbihuKXt2KHRoaXMpLnRvZ2dsZUNsYXNzKGUuY2FsbCh0aGlzLG4sdGhpcy5jbGFzc05hbWUsdCksdCl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihuPT09XCJzdHJpbmdcIil7dmFyIGkscz0wLG89dih0aGlzKSx1PXQsYT1lLnNwbGl0KHkpO3doaWxlKGk9YVtzKytdKXU9cj91OiFvLmhhc0NsYXNzKGkpLG9bdT9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShpKX1lbHNlIGlmKG49PT1cInVuZGVmaW5lZFwifHxuPT09XCJib29sZWFuXCIpdGhpcy5jbGFzc05hbWUmJnYuX2RhdGEodGhpcyxcIl9fY2xhc3NOYW1lX19cIix0aGlzLmNsYXNzTmFtZSksdGhpcy5jbGFzc05hbWU9dGhpcy5jbGFzc05hbWV8fGU9PT0hMT9cIlwiOnYuX2RhdGEodGhpcyxcIl9fY2xhc3NOYW1lX19cIil8fFwiXCJ9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9XCIgXCIrZStcIiBcIixuPTAscj10aGlzLmxlbmd0aDtmb3IoO248cjtuKyspaWYodGhpc1tuXS5ub2RlVHlwZT09PTEmJihcIiBcIit0aGlzW25dLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShxLFwiIFwiKS5pbmRleE9mKHQpPj0wKXJldHVybiEwO3JldHVybiExfSx2YWw6ZnVuY3Rpb24oZSl7dmFyIG4scixpLHM9dGhpc1swXTtpZighYXJndW1lbnRzLmxlbmd0aCl7aWYocylyZXR1cm4gbj12LnZhbEhvb2tzW3MudHlwZV18fHYudmFsSG9va3Nbcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSxuJiZcImdldFwiaW4gbiYmKHI9bi5nZXQocyxcInZhbHVlXCIpKSE9PXQ/cjoocj1zLnZhbHVlLHR5cGVvZiByPT1cInN0cmluZ1wiP3IucmVwbGFjZShSLFwiXCIpOnI9PW51bGw/XCJcIjpyKTtyZXR1cm59cmV0dXJuIGk9di5pc0Z1bmN0aW9uKGUpLHRoaXMuZWFjaChmdW5jdGlvbihyKXt2YXIgcyxvPXYodGhpcyk7aWYodGhpcy5ub2RlVHlwZSE9PTEpcmV0dXJuO2k/cz1lLmNhbGwodGhpcyxyLG8udmFsKCkpOnM9ZSxzPT1udWxsP3M9XCJcIjp0eXBlb2Ygcz09XCJudW1iZXJcIj9zKz1cIlwiOnYuaXNBcnJheShzKSYmKHM9di5tYXAocyxmdW5jdGlvbihlKXtyZXR1cm4gZT09bnVsbD9cIlwiOmUrXCJcIn0pKSxuPXYudmFsSG9va3NbdGhpcy50eXBlXXx8di52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO2lmKCFufHwhKFwic2V0XCJpbiBuKXx8bi5zZXQodGhpcyxzLFwidmFsdWVcIik9PT10KXRoaXMudmFsdWU9c30pfX0pLHYuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hdHRyaWJ1dGVzLnZhbHVlO3JldHVybiF0fHx0LnNwZWNpZmllZD9lLnZhbHVlOmUudGV4dH19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLm9wdGlvbnMsaT1lLnNlbGVjdGVkSW5kZXgscz1lLnR5cGU9PT1cInNlbGVjdC1vbmVcInx8aTwwLG89cz9udWxsOltdLHU9cz9pKzE6ci5sZW5ndGgsYT1pPDA/dTpzP2k6MDtmb3IoO2E8dTthKyspe249clthXTtpZigobi5zZWxlY3RlZHx8YT09PWkpJiYodi5zdXBwb3J0Lm9wdERpc2FibGVkPyFuLmRpc2FibGVkOm4uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIik9PT1udWxsKSYmKCFuLnBhcmVudE5vZGUuZGlzYWJsZWR8fCF2Lm5vZGVOYW1lKG4ucGFyZW50Tm9kZSxcIm9wdGdyb3VwXCIpKSl7dD12KG4pLnZhbCgpO2lmKHMpcmV0dXJuIHQ7by5wdXNoKHQpfX1yZXR1cm4gb30sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG49di5tYWtlQXJyYXkodCk7cmV0dXJuIHYoZSkuZmluZChcIm9wdGlvblwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZD12LmluQXJyYXkodih0aGlzKS52YWwoKSxuKT49MH0pLG4ubGVuZ3RofHwoZS5zZWxlY3RlZEluZGV4PS0xKSxufX19LGF0dHJGbjp7fSxhdHRyOmZ1bmN0aW9uKGUsbixyLGkpe3ZhciBzLG8sdSxhPWUubm9kZVR5cGU7aWYoIWV8fGE9PT0zfHxhPT09OHx8YT09PTIpcmV0dXJuO2lmKGkmJnYuaXNGdW5jdGlvbih2LmZuW25dKSlyZXR1cm4gdihlKVtuXShyKTtpZih0eXBlb2YgZS5nZXRBdHRyaWJ1dGU9PVwidW5kZWZpbmVkXCIpcmV0dXJuIHYucHJvcChlLG4scik7dT1hIT09MXx8IXYuaXNYTUxEb2MoZSksdSYmKG49bi50b0xvd2VyQ2FzZSgpLG89di5hdHRySG9va3Nbbl18fChYLnRlc3Qobik/RjpqKSk7aWYociE9PXQpe2lmKHI9PT1udWxsKXt2LnJlbW92ZUF0dHIoZSxuKTtyZXR1cm59cmV0dXJuIG8mJlwic2V0XCJpbiBvJiZ1JiYocz1vLnNldChlLHIsbikpIT09dD9zOihlLnNldEF0dHJpYnV0ZShuLHIrXCJcIikscil9cmV0dXJuIG8mJlwiZ2V0XCJpbiBvJiZ1JiYocz1vLmdldChlLG4pKSE9PW51bGw/czoocz1lLmdldEF0dHJpYnV0ZShuKSxzPT09bnVsbD90OnMpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLHMsbz0wO2lmKHQmJmUubm9kZVR5cGU9PT0xKXtyPXQuc3BsaXQoeSk7Zm9yKDtvPHIubGVuZ3RoO28rKylpPXJbb10saSYmKG49di5wcm9wRml4W2ldfHxpLHM9WC50ZXN0KGkpLHN8fHYuYXR0cihlLGksXCJcIiksZS5yZW1vdmVBdHRyaWJ1dGUoVj9pOm4pLHMmJm4gaW4gZSYmKGVbbl09ITEpKX19LGF0dHJIb29rczp7dHlwZTp7c2V0OmZ1bmN0aW9uKGUsdCl7aWYoVS50ZXN0KGUubm9kZU5hbWUpJiZlLnBhcmVudE5vZGUpdi5lcnJvcihcInR5cGUgcHJvcGVydHkgY2FuJ3QgYmUgY2hhbmdlZFwiKTtlbHNlIGlmKCF2LnN1cHBvcnQucmFkaW9WYWx1ZSYmdD09PVwicmFkaW9cIiYmdi5ub2RlTmFtZShlLFwiaW5wdXRcIikpe3ZhciBuPWUudmFsdWU7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLHQpLG4mJihlLnZhbHVlPW4pLHR9fX0sdmFsdWU6e2dldDpmdW5jdGlvbihlLHQpe3JldHVybiBqJiZ2Lm5vZGVOYW1lKGUsXCJidXR0b25cIik/ai5nZXQoZSx0KTp0IGluIGU/ZS52YWx1ZTpudWxsfSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe2lmKGomJnYubm9kZU5hbWUoZSxcImJ1dHRvblwiKSlyZXR1cm4gai5zZXQoZSx0LG4pO2UudmFsdWU9dH19fSxwcm9wRml4Ont0YWJpbmRleDpcInRhYkluZGV4XCIscmVhZG9ubHk6XCJyZWFkT25seVwiLFwiZm9yXCI6XCJodG1sRm9yXCIsXCJjbGFzc1wiOlwiY2xhc3NOYW1lXCIsbWF4bGVuZ3RoOlwibWF4TGVuZ3RoXCIsY2VsbHNwYWNpbmc6XCJjZWxsU3BhY2luZ1wiLGNlbGxwYWRkaW5nOlwiY2VsbFBhZGRpbmdcIixyb3dzcGFuOlwicm93U3BhblwiLGNvbHNwYW46XCJjb2xTcGFuXCIsdXNlbWFwOlwidXNlTWFwXCIsZnJhbWVib3JkZXI6XCJmcmFtZUJvcmRlclwiLGNvbnRlbnRlZGl0YWJsZTpcImNvbnRlbnRFZGl0YWJsZVwifSxwcm9wOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxzLG8sdT1lLm5vZGVUeXBlO2lmKCFlfHx1PT09M3x8dT09PTh8fHU9PT0yKXJldHVybjtyZXR1cm4gbz11IT09MXx8IXYuaXNYTUxEb2MoZSksbyYmKG49di5wcm9wRml4W25dfHxuLHM9di5wcm9wSG9va3Nbbl0pLHIhPT10P3MmJlwic2V0XCJpbiBzJiYoaT1zLnNldChlLHIsbikpIT09dD9pOmVbbl09cjpzJiZcImdldFwiaW4gcyYmKGk9cy5nZXQoZSxuKSkhPT1udWxsP2k6ZVtuXX0scHJvcEhvb2tzOnt0YWJJbmRleDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciBuPWUuZ2V0QXR0cmlidXRlTm9kZShcInRhYmluZGV4XCIpO3JldHVybiBuJiZuLnNwZWNpZmllZD9wYXJzZUludChuLnZhbHVlLDEwKTp6LnRlc3QoZS5ub2RlTmFtZSl8fFcudGVzdChlLm5vZGVOYW1lKSYmZS5ocmVmPzA6dH19fX0pLEY9e2dldDpmdW5jdGlvbihlLG4pe3ZhciByLGk9di5wcm9wKGUsbik7cmV0dXJuIGk9PT0hMHx8dHlwZW9mIGkhPVwiYm9vbGVhblwiJiYocj1lLmdldEF0dHJpYnV0ZU5vZGUobikpJiZyLm5vZGVWYWx1ZSE9PSExP24udG9Mb3dlckNhc2UoKTp0fSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByO3JldHVybiB0PT09ITE/di5yZW1vdmVBdHRyKGUsbik6KHI9di5wcm9wRml4W25dfHxuLHIgaW4gZSYmKGVbcl09ITApLGUuc2V0QXR0cmlidXRlKG4sbi50b0xvd2VyQ2FzZSgpKSksbn19LFZ8fChJPXtuYW1lOiEwLGlkOiEwLGNvb3JkczohMH0saj12LnZhbEhvb2tzLmJ1dHRvbj17Z2V0OmZ1bmN0aW9uKGUsbil7dmFyIHI7cmV0dXJuIHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pLHImJihJW25dP3IudmFsdWUhPT1cIlwiOnIuc3BlY2lmaWVkKT9yLnZhbHVlOnR9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pO3JldHVybiByfHwocj1pLmNyZWF0ZUF0dHJpYnV0ZShuKSxlLnNldEF0dHJpYnV0ZU5vZGUocikpLHIudmFsdWU9dCtcIlwifX0sdi5lYWNoKFtcIndpZHRoXCIsXCJoZWlnaHRcIl0sZnVuY3Rpb24oZSx0KXt2LmF0dHJIb29rc1t0XT12LmV4dGVuZCh2LmF0dHJIb29rc1t0XSx7c2V0OmZ1bmN0aW9uKGUsbil7aWYobj09PVwiXCIpcmV0dXJuIGUuc2V0QXR0cmlidXRlKHQsXCJhdXRvXCIpLG59fSl9KSx2LmF0dHJIb29rcy5jb250ZW50ZWRpdGFibGU9e2dldDpqLmdldCxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3Q9PT1cIlwiJiYodD1cImZhbHNlXCIpLGouc2V0KGUsdCxuKX19KSx2LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWR8fHYuZWFjaChbXCJocmVmXCIsXCJzcmNcIixcIndpZHRoXCIsXCJoZWlnaHRcIl0sZnVuY3Rpb24oZSxuKXt2LmF0dHJIb29rc1tuXT12LmV4dGVuZCh2LmF0dHJIb29rc1tuXSx7Z2V0OmZ1bmN0aW9uKGUpe3ZhciByPWUuZ2V0QXR0cmlidXRlKG4sMik7cmV0dXJuIHI9PT1udWxsP3Q6cn19KX0pLHYuc3VwcG9ydC5zdHlsZXx8KHYuYXR0ckhvb2tzLnN0eWxlPXtnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3R5bGUuY3NzVGV4dC50b0xvd2VyQ2FzZSgpfHx0fSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zdHlsZS5jc3NUZXh0PXQrXCJcIn19KSx2LnN1cHBvcnQub3B0U2VsZWN0ZWR8fCh2LnByb3BIb29rcy5zZWxlY3RlZD12LmV4dGVuZCh2LnByb3BIb29rcy5zZWxlY3RlZCx7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTtyZXR1cm4gdCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KSxudWxsfX0pKSx2LnN1cHBvcnQuZW5jdHlwZXx8KHYucHJvcEZpeC5lbmN0eXBlPVwiZW5jb2RpbmdcIiksdi5zdXBwb3J0LmNoZWNrT258fHYuZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXt2LnZhbEhvb2tzW3RoaXNdPXtnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik9PT1udWxsP1wib25cIjplLnZhbHVlfX19KSx2LmVhY2goW1wicmFkaW9cIixcImNoZWNrYm94XCJdLGZ1bmN0aW9uKCl7di52YWxIb29rc1t0aGlzXT12LmV4dGVuZCh2LnZhbEhvb2tzW3RoaXNdLHtzZXQ6ZnVuY3Rpb24oZSx0KXtpZih2LmlzQXJyYXkodCkpcmV0dXJuIGUuY2hlY2tlZD12LmluQXJyYXkodihlKS52YWwoKSx0KT49MH19KX0pO3ZhciAkPS9eKD86dGV4dGFyZWF8aW5wdXR8c2VsZWN0KSQvaSxKPS9eKFteXFwuXSp8KSg/OlxcLiguKyl8KSQvLEs9Lyg/Ol58XFxzKWhvdmVyKFxcLlxcUyt8KVxcYi8sUT0vXmtleS8sRz0vXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sWT0vXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sWj1mdW5jdGlvbihlKXtyZXR1cm4gdi5ldmVudC5zcGVjaWFsLmhvdmVyP2U6ZS5yZXBsYWNlKEssXCJtb3VzZWVudGVyJDEgbW91c2VsZWF2ZSQxXCIpfTt2LmV2ZW50PXthZGQ6ZnVuY3Rpb24oZSxuLHIsaSxzKXt2YXIgbyx1LGEsZixsLGMsaCxwLGQsbSxnO2lmKGUubm9kZVR5cGU9PT0zfHxlLm5vZGVUeXBlPT09OHx8IW58fCFyfHwhKG89di5fZGF0YShlKSkpcmV0dXJuO3IuaGFuZGxlciYmKGQ9cixyPWQuaGFuZGxlcixzPWQuc2VsZWN0b3IpLHIuZ3VpZHx8KHIuZ3VpZD12Lmd1aWQrKyksYT1vLmV2ZW50cyxhfHwoby5ldmVudHM9YT17fSksdT1vLmhhbmRsZSx1fHwoby5oYW5kbGU9dT1mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIHY9PVwidW5kZWZpbmVkXCJ8fCEhZSYmdi5ldmVudC50cmlnZ2VyZWQ9PT1lLnR5cGU/dDp2LmV2ZW50LmRpc3BhdGNoLmFwcGx5KHUuZWxlbSxhcmd1bWVudHMpfSx1LmVsZW09ZSksbj12LnRyaW0oWihuKSkuc3BsaXQoXCIgXCIpO2ZvcihmPTA7ZjxuLmxlbmd0aDtmKyspe2w9Si5leGVjKG5bZl0pfHxbXSxjPWxbMV0saD0obFsyXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxnPXYuZXZlbnQuc3BlY2lhbFtjXXx8e30sYz0ocz9nLmRlbGVnYXRlVHlwZTpnLmJpbmRUeXBlKXx8YyxnPXYuZXZlbnQuc3BlY2lhbFtjXXx8e30scD12LmV4dGVuZCh7dHlwZTpjLG9yaWdUeXBlOmxbMV0sZGF0YTppLGhhbmRsZXI6cixndWlkOnIuZ3VpZCxzZWxlY3RvcjpzLG5lZWRzQ29udGV4dDpzJiZ2LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QocyksbmFtZXNwYWNlOmguam9pbihcIi5cIil9LGQpLG09YVtjXTtpZighbSl7bT1hW2NdPVtdLG0uZGVsZWdhdGVDb3VudD0wO2lmKCFnLnNldHVwfHxnLnNldHVwLmNhbGwoZSxpLGgsdSk9PT0hMSllLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKGMsdSwhMSk6ZS5hdHRhY2hFdmVudCYmZS5hdHRhY2hFdmVudChcIm9uXCIrYyx1KX1nLmFkZCYmKGcuYWRkLmNhbGwoZSxwKSxwLmhhbmRsZXIuZ3VpZHx8KHAuaGFuZGxlci5ndWlkPXIuZ3VpZCkpLHM/bS5zcGxpY2UobS5kZWxlZ2F0ZUNvdW50KyssMCxwKTptLnB1c2gocCksdi5ldmVudC5nbG9iYWxbY109ITB9ZT1udWxsfSxnbG9iYWw6e30scmVtb3ZlOmZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIHMsbyx1LGEsZixsLGMsaCxwLGQsbSxnPXYuaGFzRGF0YShlKSYmdi5fZGF0YShlKTtpZighZ3x8IShoPWcuZXZlbnRzKSlyZXR1cm47dD12LnRyaW0oWih0fHxcIlwiKSkuc3BsaXQoXCIgXCIpO2ZvcihzPTA7czx0Lmxlbmd0aDtzKyspe289Si5leGVjKHRbc10pfHxbXSx1PWE9b1sxXSxmPW9bMl07aWYoIXUpe2Zvcih1IGluIGgpdi5ldmVudC5yZW1vdmUoZSx1K3Rbc10sbixyLCEwKTtjb250aW51ZX1wPXYuZXZlbnQuc3BlY2lhbFt1XXx8e30sdT0ocj9wLmRlbGVnYXRlVHlwZTpwLmJpbmRUeXBlKXx8dSxkPWhbdV18fFtdLGw9ZC5sZW5ndGgsZj1mP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitmLnNwbGl0KFwiLlwiKS5zb3J0KCkuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGw7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrKyltPWRbY10sKGl8fGE9PT1tLm9yaWdUeXBlKSYmKCFufHxuLmd1aWQ9PT1tLmd1aWQpJiYoIWZ8fGYudGVzdChtLm5hbWVzcGFjZSkpJiYoIXJ8fHI9PT1tLnNlbGVjdG9yfHxyPT09XCIqKlwiJiZtLnNlbGVjdG9yKSYmKGQuc3BsaWNlKGMtLSwxKSxtLnNlbGVjdG9yJiZkLmRlbGVnYXRlQ291bnQtLSxwLnJlbW92ZSYmcC5yZW1vdmUuY2FsbChlLG0pKTtkLmxlbmd0aD09PTAmJmwhPT1kLmxlbmd0aCYmKCghcC50ZWFyZG93bnx8cC50ZWFyZG93bi5jYWxsKGUsZixnLmhhbmRsZSk9PT0hMSkmJnYucmVtb3ZlRXZlbnQoZSx1LGcuaGFuZGxlKSxkZWxldGUgaFt1XSl9di5pc0VtcHR5T2JqZWN0KGgpJiYoZGVsZXRlIGcuaGFuZGxlLHYucmVtb3ZlRGF0YShlLFwiZXZlbnRzXCIsITApKX0sY3VzdG9tRXZlbnQ6e2dldERhdGE6ITAsc2V0RGF0YTohMCxjaGFuZ2VEYXRhOiEwfSx0cmlnZ2VyOmZ1bmN0aW9uKG4scixzLG8pe2lmKCFzfHxzLm5vZGVUeXBlIT09MyYmcy5ub2RlVHlwZSE9PTgpe3ZhciB1LGEsZixsLGMsaCxwLGQsbSxnLHk9bi50eXBlfHxuLGI9W107aWYoWS50ZXN0KHkrdi5ldmVudC50cmlnZ2VyZWQpKXJldHVybjt5LmluZGV4T2YoXCIhXCIpPj0wJiYoeT15LnNsaWNlKDAsLTEpLGE9ITApLHkuaW5kZXhPZihcIi5cIik+PTAmJihiPXkuc3BsaXQoXCIuXCIpLHk9Yi5zaGlmdCgpLGIuc29ydCgpKTtpZigoIXN8fHYuZXZlbnQuY3VzdG9tRXZlbnRbeV0pJiYhdi5ldmVudC5nbG9iYWxbeV0pcmV0dXJuO249dHlwZW9mIG49PVwib2JqZWN0XCI/blt2LmV4cGFuZG9dP246bmV3IHYuRXZlbnQoeSxuKTpuZXcgdi5FdmVudCh5KSxuLnR5cGU9eSxuLmlzVHJpZ2dlcj0hMCxuLmV4Y2x1c2l2ZT1hLG4ubmFtZXNwYWNlPWIuam9pbihcIi5cIiksbi5uYW1lc3BhY2VfcmU9bi5uYW1lc3BhY2U/bmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK2Iuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGwsaD15LmluZGV4T2YoXCI6XCIpPDA/XCJvblwiK3k6XCJcIjtpZighcyl7dT12LmNhY2hlO2ZvcihmIGluIHUpdVtmXS5ldmVudHMmJnVbZl0uZXZlbnRzW3ldJiZ2LmV2ZW50LnRyaWdnZXIobixyLHVbZl0uaGFuZGxlLmVsZW0sITApO3JldHVybn1uLnJlc3VsdD10LG4udGFyZ2V0fHwobi50YXJnZXQ9cykscj1yIT1udWxsP3YubWFrZUFycmF5KHIpOltdLHIudW5zaGlmdChuKSxwPXYuZXZlbnQuc3BlY2lhbFt5XXx8e307aWYocC50cmlnZ2VyJiZwLnRyaWdnZXIuYXBwbHkocyxyKT09PSExKXJldHVybjttPVtbcyxwLmJpbmRUeXBlfHx5XV07aWYoIW8mJiFwLm5vQnViYmxlJiYhdi5pc1dpbmRvdyhzKSl7Zz1wLmRlbGVnYXRlVHlwZXx8eSxsPVkudGVzdChnK3kpP3M6cy5wYXJlbnROb2RlO2ZvcihjPXM7bDtsPWwucGFyZW50Tm9kZSltLnB1c2goW2wsZ10pLGM9bDtjPT09KHMub3duZXJEb2N1bWVudHx8aSkmJm0ucHVzaChbYy5kZWZhdWx0Vmlld3x8Yy5wYXJlbnRXaW5kb3d8fGUsZ10pfWZvcihmPTA7ZjxtLmxlbmd0aCYmIW4uaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtmKyspbD1tW2ZdWzBdLG4udHlwZT1tW2ZdWzFdLGQ9KHYuX2RhdGEobCxcImV2ZW50c1wiKXx8e30pW24udHlwZV0mJnYuX2RhdGEobCxcImhhbmRsZVwiKSxkJiZkLmFwcGx5KGwsciksZD1oJiZsW2hdLGQmJnYuYWNjZXB0RGF0YShsKSYmZC5hcHBseSYmZC5hcHBseShsLHIpPT09ITEmJm4ucHJldmVudERlZmF1bHQoKTtyZXR1cm4gbi50eXBlPXksIW8mJiFuLmlzRGVmYXVsdFByZXZlbnRlZCgpJiYoIXAuX2RlZmF1bHR8fHAuX2RlZmF1bHQuYXBwbHkocy5vd25lckRvY3VtZW50LHIpPT09ITEpJiYoeSE9PVwiY2xpY2tcInx8IXYubm9kZU5hbWUocyxcImFcIikpJiZ2LmFjY2VwdERhdGEocykmJmgmJnNbeV0mJih5IT09XCJmb2N1c1wiJiZ5IT09XCJibHVyXCJ8fG4udGFyZ2V0Lm9mZnNldFdpZHRoIT09MCkmJiF2LmlzV2luZG93KHMpJiYoYz1zW2hdLGMmJihzW2hdPW51bGwpLHYuZXZlbnQudHJpZ2dlcmVkPXksc1t5XSgpLHYuZXZlbnQudHJpZ2dlcmVkPXQsYyYmKHNbaF09YykpLG4ucmVzdWx0fXJldHVybn0sZGlzcGF0Y2g6ZnVuY3Rpb24obil7bj12LmV2ZW50LmZpeChufHxlLmV2ZW50KTt2YXIgcixpLHMsbyx1LGEsZixjLGgscCxkPSh2Ll9kYXRhKHRoaXMsXCJldmVudHNcIil8fHt9KVtuLnR5cGVdfHxbXSxtPWQuZGVsZWdhdGVDb3VudCxnPWwuY2FsbChhcmd1bWVudHMpLHk9IW4uZXhjbHVzaXZlJiYhbi5uYW1lc3BhY2UsYj12LmV2ZW50LnNwZWNpYWxbbi50eXBlXXx8e30sdz1bXTtnWzBdPW4sbi5kZWxlZ2F0ZVRhcmdldD10aGlzO2lmKGIucHJlRGlzcGF0Y2gmJmIucHJlRGlzcGF0Y2guY2FsbCh0aGlzLG4pPT09ITEpcmV0dXJuO2lmKG0mJighbi5idXR0b258fG4udHlwZSE9PVwiY2xpY2tcIikpZm9yKHM9bi50YXJnZXQ7cyE9dGhpcztzPXMucGFyZW50Tm9kZXx8dGhpcylpZihzLmRpc2FibGVkIT09ITB8fG4udHlwZSE9PVwiY2xpY2tcIil7dT17fSxmPVtdO2ZvcihyPTA7cjxtO3IrKyljPWRbcl0saD1jLnNlbGVjdG9yLHVbaF09PT10JiYodVtoXT1jLm5lZWRzQ29udGV4dD92KGgsdGhpcykuaW5kZXgocyk+PTA6di5maW5kKGgsdGhpcyxudWxsLFtzXSkubGVuZ3RoKSx1W2hdJiZmLnB1c2goYyk7Zi5sZW5ndGgmJncucHVzaCh7ZWxlbTpzLG1hdGNoZXM6Zn0pfWQubGVuZ3RoPm0mJncucHVzaCh7ZWxlbTp0aGlzLG1hdGNoZXM6ZC5zbGljZShtKX0pO2ZvcihyPTA7cjx3Lmxlbmd0aCYmIW4uaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtyKyspe2E9d1tyXSxuLmN1cnJlbnRUYXJnZXQ9YS5lbGVtO2ZvcihpPTA7aTxhLm1hdGNoZXMubGVuZ3RoJiYhbi5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO2krKyl7Yz1hLm1hdGNoZXNbaV07aWYoeXx8IW4ubmFtZXNwYWNlJiYhYy5uYW1lc3BhY2V8fG4ubmFtZXNwYWNlX3JlJiZuLm5hbWVzcGFjZV9yZS50ZXN0KGMubmFtZXNwYWNlKSluLmRhdGE9Yy5kYXRhLG4uaGFuZGxlT2JqPWMsbz0oKHYuZXZlbnQuc3BlY2lhbFtjLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8Yy5oYW5kbGVyKS5hcHBseShhLmVsZW0sZyksbyE9PXQmJihuLnJlc3VsdD1vLG89PT0hMSYmKG4ucHJldmVudERlZmF1bHQoKSxuLnN0b3BQcm9wYWdhdGlvbigpKSl9fXJldHVybiBiLnBvc3REaXNwYXRjaCYmYi5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLG4pLG4ucmVzdWx0fSxwcm9wczpcImF0dHJDaGFuZ2UgYXR0ck5hbWUgcmVsYXRlZE5vZGUgc3JjRWxlbWVudCBhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS53aGljaD09bnVsbCYmKGUud2hpY2g9dC5jaGFyQ29kZSE9bnVsbD90LmNoYXJDb2RlOnQua2V5Q29kZSksZX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihlLG4pe3ZhciByLHMsbyx1PW4uYnV0dG9uLGE9bi5mcm9tRWxlbWVudDtyZXR1cm4gZS5wYWdlWD09bnVsbCYmbi5jbGllbnRYIT1udWxsJiYocj1lLnRhcmdldC5vd25lckRvY3VtZW50fHxpLHM9ci5kb2N1bWVudEVsZW1lbnQsbz1yLmJvZHksZS5wYWdlWD1uLmNsaWVudFgrKHMmJnMuc2Nyb2xsTGVmdHx8byYmby5zY3JvbGxMZWZ0fHwwKS0ocyYmcy5jbGllbnRMZWZ0fHxvJiZvLmNsaWVudExlZnR8fDApLGUucGFnZVk9bi5jbGllbnRZKyhzJiZzLnNjcm9sbFRvcHx8byYmby5zY3JvbGxUb3B8fDApLShzJiZzLmNsaWVudFRvcHx8byYmby5jbGllbnRUb3B8fDApKSwhZS5yZWxhdGVkVGFyZ2V0JiZhJiYoZS5yZWxhdGVkVGFyZ2V0PWE9PT1lLnRhcmdldD9uLnRvRWxlbWVudDphKSwhZS53aGljaCYmdSE9PXQmJihlLndoaWNoPXUmMT8xOnUmMj8zOnUmND8yOjApLGV9fSxmaXg6ZnVuY3Rpb24oZSl7aWYoZVt2LmV4cGFuZG9dKXJldHVybiBlO3ZhciB0LG4scj1lLHM9di5ldmVudC5maXhIb29rc1tlLnR5cGVdfHx7fSxvPXMucHJvcHM/dGhpcy5wcm9wcy5jb25jYXQocy5wcm9wcyk6dGhpcy5wcm9wcztlPXYuRXZlbnQocik7Zm9yKHQ9by5sZW5ndGg7dDspbj1vWy0tdF0sZVtuXT1yW25dO3JldHVybiBlLnRhcmdldHx8KGUudGFyZ2V0PXIuc3JjRWxlbWVudHx8aSksZS50YXJnZXQubm9kZVR5cGU9PT0zJiYoZS50YXJnZXQ9ZS50YXJnZXQucGFyZW50Tm9kZSksZS5tZXRhS2V5PSEhZS5tZXRhS2V5LHMuZmlsdGVyP3MuZmlsdGVyKGUscik6ZX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGZvY3VzOntkZWxlZ2F0ZVR5cGU6XCJmb2N1c2luXCJ9LGJsdXI6e2RlbGVnYXRlVHlwZTpcImZvY3Vzb3V0XCJ9LGJlZm9yZXVubG9hZDp7c2V0dXA6ZnVuY3Rpb24oZSx0LG4pe3YuaXNXaW5kb3codGhpcykmJih0aGlzLm9uYmVmb3JldW5sb2FkPW4pfSx0ZWFyZG93bjpmdW5jdGlvbihlLHQpe3RoaXMub25iZWZvcmV1bmxvYWQ9PT10JiYodGhpcy5vbmJlZm9yZXVubG9hZD1udWxsKX19fSxzaW11bGF0ZTpmdW5jdGlvbihlLHQsbixyKXt2YXIgaT12LmV4dGVuZChuZXcgdi5FdmVudCxuLHt0eXBlOmUsaXNTaW11bGF0ZWQ6ITAsb3JpZ2luYWxFdmVudDp7fX0pO3I/di5ldmVudC50cmlnZ2VyKGksbnVsbCx0KTp2LmV2ZW50LmRpc3BhdGNoLmNhbGwodCxpKSxpLmlzRGVmYXVsdFByZXZlbnRlZCgpJiZuLnByZXZlbnREZWZhdWx0KCl9fSx2LmV2ZW50LmhhbmRsZT12LmV2ZW50LmRpc3BhdGNoLHYucmVtb3ZlRXZlbnQ9aS5yZW1vdmVFdmVudExpc3RlbmVyP2Z1bmN0aW9uKGUsdCxuKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4sITEpfTpmdW5jdGlvbihlLHQsbil7dmFyIHI9XCJvblwiK3Q7ZS5kZXRhY2hFdmVudCYmKHR5cGVvZiBlW3JdPT1cInVuZGVmaW5lZFwiJiYoZVtyXT1udWxsKSxlLmRldGFjaEV2ZW50KHIsbikpfSx2LkV2ZW50PWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2Ygdi5FdmVudCkpcmV0dXJuIG5ldyB2LkV2ZW50KGUsdCk7ZSYmZS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0aGlzLnR5cGU9ZS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWUuZGVmYXVsdFByZXZlbnRlZHx8ZS5yZXR1cm5WYWx1ZT09PSExfHxlLmdldFByZXZlbnREZWZhdWx0JiZlLmdldFByZXZlbnREZWZhdWx0KCk/dHQ6ZXQpOnRoaXMudHlwZT1lLHQmJnYuZXh0ZW5kKHRoaXMsdCksdGhpcy50aW1lU3RhbXA9ZSYmZS50aW1lU3RhbXB8fHYubm93KCksdGhpc1t2LmV4cGFuZG9dPSEwfSx2LkV2ZW50LnByb3RvdHlwZT17cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD10dDt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7aWYoIWUpcmV0dXJuO2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITF9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9dHQ7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O2lmKCFlKXJldHVybjtlLnN0b3BQcm9wYWdhdGlvbiYmZS5zdG9wUHJvcGFnYXRpb24oKSxlLmNhbmNlbEJ1YmJsZT0hMH0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10dCx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfSxpc0RlZmF1bHRQcmV2ZW50ZWQ6ZXQsaXNQcm9wYWdhdGlvblN0b3BwZWQ6ZXQsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6ZXR9LHYuZWFjaCh7bW91c2VlbnRlcjpcIm1vdXNlb3ZlclwiLG1vdXNlbGVhdmU6XCJtb3VzZW91dFwifSxmdW5jdGlvbihlLHQpe3YuZXZlbnQuc3BlY2lhbFtlXT17ZGVsZWdhdGVUeXBlOnQsYmluZFR5cGU6dCxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIG4scj10aGlzLGk9ZS5yZWxhdGVkVGFyZ2V0LHM9ZS5oYW5kbGVPYmosbz1zLnNlbGVjdG9yO2lmKCFpfHxpIT09ciYmIXYuY29udGFpbnMocixpKSllLnR5cGU9cy5vcmlnVHlwZSxuPXMuaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyksZS50eXBlPXQ7cmV0dXJuIG59fX0pLHYuc3VwcG9ydC5zdWJtaXRCdWJibGVzfHwodi5ldmVudC5zcGVjaWFsLnN1Ym1pdD17c2V0dXA6ZnVuY3Rpb24oKXtpZih2Lm5vZGVOYW1lKHRoaXMsXCJmb3JtXCIpKXJldHVybiExO3YuZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fc3VibWl0IGtleXByZXNzLl9zdWJtaXRcIixmdW5jdGlvbihlKXt2YXIgbj1lLnRhcmdldCxyPXYubm9kZU5hbWUobixcImlucHV0XCIpfHx2Lm5vZGVOYW1lKG4sXCJidXR0b25cIik/bi5mb3JtOnQ7ciYmIXYuX2RhdGEocixcIl9zdWJtaXRfYXR0YWNoZWRcIikmJih2LmV2ZW50LmFkZChyLFwic3VibWl0Ll9zdWJtaXRcIixmdW5jdGlvbihlKXtlLl9zdWJtaXRfYnViYmxlPSEwfSksdi5fZGF0YShyLFwiX3N1Ym1pdF9hdHRhY2hlZFwiLCEwKSl9KX0scG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe2UuX3N1Ym1pdF9idWJibGUmJihkZWxldGUgZS5fc3VibWl0X2J1YmJsZSx0aGlzLnBhcmVudE5vZGUmJiFlLmlzVHJpZ2dlciYmdi5ldmVudC5zaW11bGF0ZShcInN1Ym1pdFwiLHRoaXMucGFyZW50Tm9kZSxlLCEwKSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7aWYodi5ub2RlTmFtZSh0aGlzLFwiZm9ybVwiKSlyZXR1cm4hMTt2LmV2ZW50LnJlbW92ZSh0aGlzLFwiLl9zdWJtaXRcIil9fSksdi5zdXBwb3J0LmNoYW5nZUJ1YmJsZXN8fCh2LmV2ZW50LnNwZWNpYWwuY2hhbmdlPXtzZXR1cDpmdW5jdGlvbigpe2lmKCQudGVzdCh0aGlzLm5vZGVOYW1lKSl7aWYodGhpcy50eXBlPT09XCJjaGVja2JveFwifHx0aGlzLnR5cGU9PT1cInJhZGlvXCIpdi5ldmVudC5hZGQodGhpcyxcInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2VcIixmdW5jdGlvbihlKXtlLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lPT09XCJjaGVja2VkXCImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITApfSksdi5ldmVudC5hZGQodGhpcyxcImNsaWNrLl9jaGFuZ2VcIixmdW5jdGlvbihlKXt0aGlzLl9qdXN0X2NoYW5nZWQmJiFlLmlzVHJpZ2dlciYmKHRoaXMuX2p1c3RfY2hhbmdlZD0hMSksdi5ldmVudC5zaW11bGF0ZShcImNoYW5nZVwiLHRoaXMsZSwhMCl9KTtyZXR1cm4hMX12LmV2ZW50LmFkZCh0aGlzLFwiYmVmb3JlYWN0aXZhdGUuX2NoYW5nZVwiLGZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0OyQudGVzdCh0Lm5vZGVOYW1lKSYmIXYuX2RhdGEodCxcIl9jaGFuZ2VfYXR0YWNoZWRcIikmJih2LmV2ZW50LmFkZCh0LFwiY2hhbmdlLl9jaGFuZ2VcIixmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJiFlLmlzU2ltdWxhdGVkJiYhZS5pc1RyaWdnZXImJnYuZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLnBhcmVudE5vZGUsZSwhMCl9KSx2Ll9kYXRhKHQsXCJfY2hhbmdlX2F0dGFjaGVkXCIsITApKX0pfSxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQ7aWYodGhpcyE9PXR8fGUuaXNTaW11bGF0ZWR8fGUuaXNUcmlnZ2VyfHx0LnR5cGUhPT1cInJhZGlvXCImJnQudHlwZSE9PVwiY2hlY2tib3hcIilyZXR1cm4gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7cmV0dXJuIHYuZXZlbnQucmVtb3ZlKHRoaXMsXCIuX2NoYW5nZVwiKSwhJC50ZXN0KHRoaXMubm9kZU5hbWUpfX0pLHYuc3VwcG9ydC5mb2N1c2luQnViYmxlc3x8di5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24oZSx0KXt2YXIgbj0wLHI9ZnVuY3Rpb24oZSl7di5ldmVudC5zaW11bGF0ZSh0LGUudGFyZ2V0LHYuZXZlbnQuZml4KGUpLCEwKX07di5ldmVudC5zcGVjaWFsW3RdPXtzZXR1cDpmdW5jdGlvbigpe24rKz09PTAmJmkuYWRkRXZlbnRMaXN0ZW5lcihlLHIsITApfSx0ZWFyZG93bjpmdW5jdGlvbigpey0tbj09PTAmJmkucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHIsITApfX19KSx2LmZuLmV4dGVuZCh7b246ZnVuY3Rpb24oZSxuLHIsaSxzKXt2YXIgbyx1O2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiKXt0eXBlb2YgbiE9XCJzdHJpbmdcIiYmKHI9cnx8bixuPXQpO2Zvcih1IGluIGUpdGhpcy5vbih1LG4scixlW3VdLHMpO3JldHVybiB0aGlzfXI9PW51bGwmJmk9PW51bGw/KGk9bixyPW49dCk6aT09bnVsbCYmKHR5cGVvZiBuPT1cInN0cmluZ1wiPyhpPXIscj10KTooaT1yLHI9bixuPXQpKTtpZihpPT09ITEpaT1ldDtlbHNlIGlmKCFpKXJldHVybiB0aGlzO3JldHVybiBzPT09MSYmKG89aSxpPWZ1bmN0aW9uKGUpe3JldHVybiB2KCkub2ZmKGUpLG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfSxpLmd1aWQ9by5ndWlkfHwoby5ndWlkPXYuZ3VpZCsrKSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7di5ldmVudC5hZGQodGhpcyxlLGkscixuKX0pfSxvbmU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMub24oZSx0LG4sciwxKX0sb2ZmOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxzO2lmKGUmJmUucHJldmVudERlZmF1bHQmJmUuaGFuZGxlT2JqKXJldHVybiBpPWUuaGFuZGxlT2JqLHYoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKGkubmFtZXNwYWNlP2kub3JpZ1R5cGUrXCIuXCIraS5uYW1lc3BhY2U6aS5vcmlnVHlwZSxpLnNlbGVjdG9yLGkuaGFuZGxlciksdGhpcztpZih0eXBlb2YgZT09XCJvYmplY3RcIil7Zm9yKHMgaW4gZSl0aGlzLm9mZihzLG4sZVtzXSk7cmV0dXJuIHRoaXN9aWYobj09PSExfHx0eXBlb2Ygbj09XCJmdW5jdGlvblwiKXI9bixuPXQ7cmV0dXJuIHI9PT0hMSYmKHI9ZXQpLHRoaXMuZWFjaChmdW5jdGlvbigpe3YuZXZlbnQucmVtb3ZlKHRoaXMsZSxyLG4pfSl9LGJpbmQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLm9uKGUsbnVsbCx0LG4pfSx1bmJpbmQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vZmYoZSxudWxsLHQpfSxsaXZlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdih0aGlzLmNvbnRleHQpLm9uKGUsdGhpcy5zZWxlY3Rvcix0LG4pLHRoaXN9LGRpZTpmdW5jdGlvbihlLHQpe3JldHVybiB2KHRoaXMuY29udGV4dCkub2ZmKGUsdGhpcy5zZWxlY3Rvcnx8XCIqKlwiLHQpLHRoaXN9LGRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLm9uKHQsZSxuLHIpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD09PTE/dGhpcy5vZmYoZSxcIioqXCIpOnRoaXMub2ZmKHQsZXx8XCIqKlwiLG4pfSx0cmlnZ2VyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3YuZXZlbnQudHJpZ2dlcihlLHQsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oZSx0KXtpZih0aGlzWzBdKXJldHVybiB2LmV2ZW50LnRyaWdnZXIoZSx0LHRoaXNbMF0sITApfSx0b2dnbGU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLG49ZS5ndWlkfHx2Lmd1aWQrKyxyPTAsaT1mdW5jdGlvbihuKXt2YXIgaT0odi5fZGF0YSh0aGlzLFwibGFzdFRvZ2dsZVwiK2UuZ3VpZCl8fDApJXI7cmV0dXJuIHYuX2RhdGEodGhpcyxcImxhc3RUb2dnbGVcIitlLmd1aWQsaSsxKSxuLnByZXZlbnREZWZhdWx0KCksdFtpXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fCExfTtpLmd1aWQ9bjt3aGlsZShyPHQubGVuZ3RoKXRbcisrXS5ndWlkPW47cmV0dXJuIHRoaXMuY2xpY2soaSl9LGhvdmVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMubW91c2VlbnRlcihlKS5tb3VzZWxlYXZlKHR8fGUpfX0pLHYuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXt2LmZuW3RdPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG49PW51bGwmJihuPWUsZT1udWxsKSxhcmd1bWVudHMubGVuZ3RoPjA/dGhpcy5vbih0LG51bGwsZSxuKTp0aGlzLnRyaWdnZXIodCl9LFEudGVzdCh0KSYmKHYuZXZlbnQuZml4SG9va3NbdF09di5ldmVudC5rZXlIb29rcyksRy50ZXN0KHQpJiYodi5ldmVudC5maXhIb29rc1t0XT12LmV2ZW50Lm1vdXNlSG9va3MpfSksZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBudChlLHQsbixyKXtuPW58fFtdLHQ9dHx8Zzt2YXIgaSxzLGEsZixsPXQubm9kZVR5cGU7aWYoIWV8fHR5cGVvZiBlIT1cInN0cmluZ1wiKXJldHVybiBuO2lmKGwhPT0xJiZsIT09OSlyZXR1cm5bXTthPW8odCk7aWYoIWEmJiFyKWlmKGk9Ui5leGVjKGUpKWlmKGY9aVsxXSl7aWYobD09PTkpe3M9dC5nZXRFbGVtZW50QnlJZChmKTtpZighc3x8IXMucGFyZW50Tm9kZSlyZXR1cm4gbjtpZihzLmlkPT09ZilyZXR1cm4gbi5wdXNoKHMpLG59ZWxzZSBpZih0Lm93bmVyRG9jdW1lbnQmJihzPXQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKSkmJnUodCxzKSYmcy5pZD09PWYpcmV0dXJuIG4ucHVzaChzKSxufWVsc2V7aWYoaVsyXSlyZXR1cm4gUy5hcHBseShuLHguY2FsbCh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpLDApKSxuO2lmKChmPWlbM10pJiZaJiZ0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpcmV0dXJuIFMuYXBwbHkobix4LmNhbGwodC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGYpLDApKSxufXJldHVybiB2dChlLnJlcGxhY2UoaixcIiQxXCIpLHQsbixyLGEpfWZ1bmN0aW9uIHJ0KGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG49PT1cImlucHV0XCImJnQudHlwZT09PWV9fWZ1bmN0aW9uIGl0KGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKG49PT1cImlucHV0XCJ8fG49PT1cImJ1dHRvblwiKSYmdC50eXBlPT09ZX19ZnVuY3Rpb24gc3QoZSl7cmV0dXJuIE4oZnVuY3Rpb24odCl7cmV0dXJuIHQ9K3QsTihmdW5jdGlvbihuLHIpe3ZhciBpLHM9ZShbXSxuLmxlbmd0aCx0KSxvPXMubGVuZ3RoO3doaWxlKG8tLSluW2k9c1tvXV0mJihuW2ldPSEocltpXT1uW2ldKSl9KX0pfWZ1bmN0aW9uIG90KGUsdCxuKXtpZihlPT09dClyZXR1cm4gbjt2YXIgcj1lLm5leHRTaWJsaW5nO3doaWxlKHIpe2lmKHI9PT10KXJldHVybi0xO3I9ci5uZXh0U2libGluZ31yZXR1cm4gMX1mdW5jdGlvbiB1dChlLHQpe3ZhciBuLHIscyxvLHUsYSxmLGw9TFtkXVtlK1wiIFwiXTtpZihsKXJldHVybiB0PzA6bC5zbGljZSgwKTt1PWUsYT1bXSxmPWkucHJlRmlsdGVyO3doaWxlKHUpe2lmKCFufHwocj1GLmV4ZWModSkpKXImJih1PXUuc2xpY2UoclswXS5sZW5ndGgpfHx1KSxhLnB1c2gocz1bXSk7bj0hMTtpZihyPUkuZXhlYyh1KSlzLnB1c2gobj1uZXcgbShyLnNoaWZ0KCkpKSx1PXUuc2xpY2Uobi5sZW5ndGgpLG4udHlwZT1yWzBdLnJlcGxhY2UoaixcIiBcIik7Zm9yKG8gaW4gaS5maWx0ZXIpKHI9SltvXS5leGVjKHUpKSYmKCFmW29dfHwocj1mW29dKHIpKSkmJihzLnB1c2gobj1uZXcgbShyLnNoaWZ0KCkpKSx1PXUuc2xpY2Uobi5sZW5ndGgpLG4udHlwZT1vLG4ubWF0Y2hlcz1yKTtpZighbilicmVha31yZXR1cm4gdD91Lmxlbmd0aDp1P250LmVycm9yKGUpOkwoZSxhKS5zbGljZSgwKX1mdW5jdGlvbiBhdChlLHQscil7dmFyIGk9dC5kaXIscz1yJiZ0LmRpcj09PVwicGFyZW50Tm9kZVwiLG89dysrO3JldHVybiB0LmZpcnN0P2Z1bmN0aW9uKHQsbixyKXt3aGlsZSh0PXRbaV0paWYoc3x8dC5ub2RlVHlwZT09PTEpcmV0dXJuIGUodCxuLHIpfTpmdW5jdGlvbih0LHIsdSl7aWYoIXUpe3ZhciBhLGY9YitcIiBcIitvK1wiIFwiLGw9ZituO3doaWxlKHQ9dFtpXSlpZihzfHx0Lm5vZGVUeXBlPT09MSl7aWYoKGE9dFtkXSk9PT1sKXJldHVybiB0LnNpenNldDtpZih0eXBlb2YgYT09XCJzdHJpbmdcIiYmYS5pbmRleE9mKGYpPT09MCl7aWYodC5zaXpzZXQpcmV0dXJuIHR9ZWxzZXt0W2RdPWw7aWYoZSh0LHIsdSkpcmV0dXJuIHQuc2l6c2V0PSEwLHQ7dC5zaXpzZXQ9ITF9fX1lbHNlIHdoaWxlKHQ9dFtpXSlpZihzfHx0Lm5vZGVUeXBlPT09MSlpZihlKHQscix1KSlyZXR1cm4gdH19ZnVuY3Rpb24gZnQoZSl7cmV0dXJuIGUubGVuZ3RoPjE/ZnVuY3Rpb24odCxuLHIpe3ZhciBpPWUubGVuZ3RoO3doaWxlKGktLSlpZighZVtpXSh0LG4scikpcmV0dXJuITE7cmV0dXJuITB9OmVbMF19ZnVuY3Rpb24gbHQoZSx0LG4scixpKXt2YXIgcyxvPVtdLHU9MCxhPWUubGVuZ3RoLGY9dCE9bnVsbDtmb3IoO3U8YTt1KyspaWYocz1lW3VdKWlmKCFufHxuKHMscixpKSlvLnB1c2gocyksZiYmdC5wdXNoKHUpO3JldHVybiBvfWZ1bmN0aW9uIGN0KGUsdCxuLHIsaSxzKXtyZXR1cm4gciYmIXJbZF0mJihyPWN0KHIpKSxpJiYhaVtkXSYmKGk9Y3QoaSxzKSksTihmdW5jdGlvbihzLG8sdSxhKXt2YXIgZixsLGMsaD1bXSxwPVtdLGQ9by5sZW5ndGgsdj1zfHxkdCh0fHxcIipcIix1Lm5vZGVUeXBlP1t1XTp1LFtdKSxtPWUmJihzfHwhdCk/bHQodixoLGUsdSxhKTp2LGc9bj9pfHwocz9lOmR8fHIpP1tdOm86bTtuJiZuKG0sZyx1LGEpO2lmKHIpe2Y9bHQoZyxwKSxyKGYsW10sdSxhKSxsPWYubGVuZ3RoO3doaWxlKGwtLSlpZihjPWZbbF0pZ1twW2xdXT0hKG1bcFtsXV09Yyl9aWYocyl7aWYoaXx8ZSl7aWYoaSl7Zj1bXSxsPWcubGVuZ3RoO3doaWxlKGwtLSkoYz1nW2xdKSYmZi5wdXNoKG1bbF09Yyk7aShudWxsLGc9W10sZixhKX1sPWcubGVuZ3RoO3doaWxlKGwtLSkoYz1nW2xdKSYmKGY9aT9ULmNhbGwocyxjKTpoW2xdKT4tMSYmKHNbZl09IShvW2ZdPWMpKX19ZWxzZSBnPWx0KGc9PT1vP2cuc3BsaWNlKGQsZy5sZW5ndGgpOmcpLGk/aShudWxsLG8sZyxhKTpTLmFwcGx5KG8sZyl9KX1mdW5jdGlvbiBodChlKXt2YXIgdCxuLHIscz1lLmxlbmd0aCxvPWkucmVsYXRpdmVbZVswXS50eXBlXSx1PW98fGkucmVsYXRpdmVbXCIgXCJdLGE9bz8xOjAsZj1hdChmdW5jdGlvbihlKXtyZXR1cm4gZT09PXR9LHUsITApLGw9YXQoZnVuY3Rpb24oZSl7cmV0dXJuIFQuY2FsbCh0LGUpPi0xfSx1LCEwKSxoPVtmdW5jdGlvbihlLG4scil7cmV0dXJuIW8mJihyfHxuIT09Yyl8fCgodD1uKS5ub2RlVHlwZT9mKGUsbixyKTpsKGUsbixyKSl9XTtmb3IoO2E8czthKyspaWYobj1pLnJlbGF0aXZlW2VbYV0udHlwZV0paD1bYXQoZnQoaCksbildO2Vsc2V7bj1pLmZpbHRlcltlW2FdLnR5cGVdLmFwcGx5KG51bGwsZVthXS5tYXRjaGVzKTtpZihuW2RdKXtyPSsrYTtmb3IoO3I8cztyKyspaWYoaS5yZWxhdGl2ZVtlW3JdLnR5cGVdKWJyZWFrO3JldHVybiBjdChhPjEmJmZ0KGgpLGE+MSYmZS5zbGljZSgwLGEtMSkuam9pbihcIlwiKS5yZXBsYWNlKGosXCIkMVwiKSxuLGE8ciYmaHQoZS5zbGljZShhLHIpKSxyPHMmJmh0KGU9ZS5zbGljZShyKSkscjxzJiZlLmpvaW4oXCJcIikpfWgucHVzaChuKX1yZXR1cm4gZnQoaCl9ZnVuY3Rpb24gcHQoZSx0KXt2YXIgcj10Lmxlbmd0aD4wLHM9ZS5sZW5ndGg+MCxvPWZ1bmN0aW9uKHUsYSxmLGwsaCl7dmFyIHAsZCx2LG09W10seT0wLHc9XCIwXCIseD11JiZbXSxUPWghPW51bGwsTj1jLEM9dXx8cyYmaS5maW5kLlRBRyhcIipcIixoJiZhLnBhcmVudE5vZGV8fGEpLGs9Yis9Tj09bnVsbD8xOk1hdGguRTtUJiYoYz1hIT09ZyYmYSxuPW8uZWwpO2Zvcig7KHA9Q1t3XSkhPW51bGw7dysrKXtpZihzJiZwKXtmb3IoZD0wO3Y9ZVtkXTtkKyspaWYodihwLGEsZikpe2wucHVzaChwKTticmVha31UJiYoYj1rLG49KytvLmVsKX1yJiYoKHA9IXYmJnApJiZ5LS0sdSYmeC5wdXNoKHApKX15Kz13O2lmKHImJnchPT15KXtmb3IoZD0wO3Y9dFtkXTtkKyspdih4LG0sYSxmKTtpZih1KXtpZih5PjApd2hpbGUody0tKSF4W3ddJiYhbVt3XSYmKG1bd109RS5jYWxsKGwpKTttPWx0KG0pfVMuYXBwbHkobCxtKSxUJiYhdSYmbS5sZW5ndGg+MCYmeSt0Lmxlbmd0aD4xJiZudC51bmlxdWVTb3J0KGwpfXJldHVybiBUJiYoYj1rLGM9TikseH07cmV0dXJuIG8uZWw9MCxyP04obyk6b31mdW5jdGlvbiBkdChlLHQsbil7dmFyIHI9MCxpPXQubGVuZ3RoO2Zvcig7cjxpO3IrKyludChlLHRbcl0sbik7cmV0dXJuIG59ZnVuY3Rpb24gdnQoZSx0LG4scixzKXt2YXIgbyx1LGYsbCxjLGg9dXQoZSkscD1oLmxlbmd0aDtpZighciYmaC5sZW5ndGg9PT0xKXt1PWhbMF09aFswXS5zbGljZSgwKTtpZih1Lmxlbmd0aD4yJiYoZj11WzBdKS50eXBlPT09XCJJRFwiJiZ0Lm5vZGVUeXBlPT09OSYmIXMmJmkucmVsYXRpdmVbdVsxXS50eXBlXSl7dD1pLmZpbmQuSUQoZi5tYXRjaGVzWzBdLnJlcGxhY2UoJCxcIlwiKSx0LHMpWzBdO2lmKCF0KXJldHVybiBuO2U9ZS5zbGljZSh1LnNoaWZ0KCkubGVuZ3RoKX1mb3Iobz1KLlBPUy50ZXN0KGUpPy0xOnUubGVuZ3RoLTE7bz49MDtvLS0pe2Y9dVtvXTtpZihpLnJlbGF0aXZlW2w9Zi50eXBlXSlicmVhaztpZihjPWkuZmluZFtsXSlpZihyPWMoZi5tYXRjaGVzWzBdLnJlcGxhY2UoJCxcIlwiKSx6LnRlc3QodVswXS50eXBlKSYmdC5wYXJlbnROb2RlfHx0LHMpKXt1LnNwbGljZShvLDEpLGU9ci5sZW5ndGgmJnUuam9pbihcIlwiKTtpZighZSlyZXR1cm4gUy5hcHBseShuLHguY2FsbChyLDApKSxuO2JyZWFrfX19cmV0dXJuIGEoZSxoKShyLHQscyxuLHoudGVzdChlKSksbn1mdW5jdGlvbiBtdCgpe312YXIgbixyLGkscyxvLHUsYSxmLGwsYyxoPSEwLHA9XCJ1bmRlZmluZWRcIixkPShcInNpemNhY2hlXCIrTWF0aC5yYW5kb20oKSkucmVwbGFjZShcIi5cIixcIlwiKSxtPVN0cmluZyxnPWUuZG9jdW1lbnQseT1nLmRvY3VtZW50RWxlbWVudCxiPTAsdz0wLEU9W10ucG9wLFM9W10ucHVzaCx4PVtdLnNsaWNlLFQ9W10uaW5kZXhPZnx8ZnVuY3Rpb24oZSl7dmFyIHQ9MCxuPXRoaXMubGVuZ3RoO2Zvcig7dDxuO3QrKylpZih0aGlzW3RdPT09ZSlyZXR1cm4gdDtyZXR1cm4tMX0sTj1mdW5jdGlvbihlLHQpe3JldHVybiBlW2RdPXQ9PW51bGx8fHQsZX0sQz1mdW5jdGlvbigpe3ZhciBlPXt9LHQ9W107cmV0dXJuIE4oZnVuY3Rpb24obixyKXtyZXR1cm4gdC5wdXNoKG4pPmkuY2FjaGVMZW5ndGgmJmRlbGV0ZSBlW3Quc2hpZnQoKV0sZVtuK1wiIFwiXT1yfSxlKX0saz1DKCksTD1DKCksQT1DKCksTz1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsTT1cIig/OlxcXFxcXFxcLnxbLVxcXFx3XXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLF89TS5yZXBsYWNlKFwid1wiLFwidyNcIiksRD1cIihbKl4kfCF+XT89KVwiLFA9XCJcXFxcW1wiK08rXCIqKFwiK00rXCIpXCIrTytcIiooPzpcIitEK08rXCIqKD86KFsnXFxcIl0pKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqPylcXFxcM3woXCIrXytcIil8KXwpXCIrTytcIipcXFxcXVwiLEg9XCI6KFwiK00rXCIpKD86XFxcXCgoPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwyfChbXigpW1xcXFxdXSp8KD86KD86XCIrUCtcIil8W146XXxcXFxcXFxcXC4pKnwuKikpXFxcXCl8KVwiLEI9XCI6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIrTytcIiooKD86LVxcXFxkKT9cXFxcZCopXCIrTytcIipcXFxcKXwpKD89W14tXXwkKVwiLGo9bmV3IFJlZ0V4cChcIl5cIitPK1wiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIitPK1wiKyRcIixcImdcIiksRj1uZXcgUmVnRXhwKFwiXlwiK08rXCIqLFwiK08rXCIqXCIpLEk9bmV3IFJlZ0V4cChcIl5cIitPK1wiKihbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmPit+XSlcIitPK1wiKlwiKSxxPW5ldyBSZWdFeHAoSCksUj0vXig/OiMoW1xcd1xcLV0rKXwoXFx3Kyl8XFwuKFtcXHdcXC1dKykpJC8sVT0vXjpub3QvLHo9L1tcXHgyMFxcdFxcclxcblxcZl0qWyt+XS8sVz0vOm5vdFxcKCQvLFg9L2hcXGQvaSxWPS9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uL2ksJD0vXFxcXCg/IVxcXFwpL2csSj17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK00rXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrTStcIilcIiksTkFNRTpuZXcgUmVnRXhwKFwiXlxcXFxbbmFtZT1bJ1xcXCJdPyhcIitNK1wiKVsnXFxcIl0/XFxcXF1cIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK00ucmVwbGFjZShcIndcIixcIncqXCIpK1wiKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrUCksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrSCksUE9TOm5ldyBSZWdFeHAoQixcImlcIiksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8bnRofGZpcnN0fGxhc3QpLWNoaWxkKD86XFxcXChcIitPK1wiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIrTytcIiooPzooWystXXwpXCIrTytcIiooXFxcXGQrKXwpKVwiK08rXCIqXFxcXCl8KVwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitPK1wiKls+K35dfFwiK0IsXCJpXCIpfSxLPWZ1bmN0aW9uKGUpe3ZhciB0PWcuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0cnl7cmV0dXJuIGUodCl9Y2F0Y2gobil7cmV0dXJuITF9ZmluYWxseXt0PW51bGx9fSxRPUsoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwZW5kQ2hpbGQoZy5jcmVhdGVDb21tZW50KFwiXCIpKSwhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksRz1LKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxhIGhyZWY9JyMnPjwvYT5cIixlLmZpcnN0Q2hpbGQmJnR5cGVvZiBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlIT09cCYmZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIik9PT1cIiNcIn0pLFk9SyhmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxzZWxlY3Q+PC9zZWxlY3Q+XCI7dmFyIHQ9dHlwZW9mIGUubGFzdENoaWxkLmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpO3JldHVybiB0IT09XCJib29sZWFuXCImJnQhPT1cInN0cmluZ1wifSksWj1LKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxkaXYgY2xhc3M9J2hpZGRlbiBlJz48L2Rpdj48ZGl2IGNsYXNzPSdoaWRkZW4nPjwvZGl2PlwiLCFlLmdldEVsZW1lbnRzQnlDbGFzc05hbWV8fCFlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aD8hMTooZS5sYXN0Q2hpbGQuY2xhc3NOYW1lPVwiZVwiLGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoPT09Mil9KSxldD1LKGZ1bmN0aW9uKGUpe2UuaWQ9ZCswLGUuaW5uZXJIVE1MPVwiPGEgbmFtZT0nXCIrZCtcIic+PC9hPjxkaXYgbmFtZT0nXCIrZCtcIic+PC9kaXY+XCIseS5pbnNlcnRCZWZvcmUoZSx5LmZpcnN0Q2hpbGQpO3ZhciB0PWcuZ2V0RWxlbWVudHNCeU5hbWUmJmcuZ2V0RWxlbWVudHNCeU5hbWUoZCkubGVuZ3RoPT09MitnLmdldEVsZW1lbnRzQnlOYW1lKGQrMCkubGVuZ3RoO3JldHVybiByPSFnLmdldEVsZW1lbnRCeUlkKGQpLHkucmVtb3ZlQ2hpbGQoZSksdH0pO3RyeXt4LmNhbGwoeS5jaGlsZE5vZGVzLDApWzBdLm5vZGVUeXBlfWNhdGNoKHR0KXt4PWZ1bmN0aW9uKGUpe3ZhciB0LG49W107Zm9yKDt0PXRoaXNbZV07ZSsrKW4ucHVzaCh0KTtyZXR1cm4gbn19bnQubWF0Y2hlcz1mdW5jdGlvbihlLHQpe3JldHVybiBudChlLG51bGwsbnVsbCx0KX0sbnQubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG50KHQsbnVsbCxudWxsLFtlXSkubGVuZ3RoPjB9LHM9bnQuZ2V0VGV4dD1mdW5jdGlvbihlKXt2YXIgdCxuPVwiXCIscj0wLGk9ZS5ub2RlVHlwZTtpZihpKXtpZihpPT09MXx8aT09PTl8fGk9PT0xMSl7aWYodHlwZW9mIGUudGV4dENvbnRlbnQ9PVwic3RyaW5nXCIpcmV0dXJuIGUudGV4dENvbnRlbnQ7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKW4rPXMoZSl9ZWxzZSBpZihpPT09M3x8aT09PTQpcmV0dXJuIGUubm9kZVZhbHVlfWVsc2UgZm9yKDt0PWVbcl07cisrKW4rPXModCk7cmV0dXJuIG59LG89bnQuaXNYTUw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmKGUub3duZXJEb2N1bWVudHx8ZSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiB0P3Qubm9kZU5hbWUhPT1cIkhUTUxcIjohMX0sdT1udC5jb250YWlucz15LmNvbnRhaW5zP2Z1bmN0aW9uKGUsdCl7dmFyIG49ZS5ub2RlVHlwZT09PTk/ZS5kb2N1bWVudEVsZW1lbnQ6ZSxyPXQmJnQucGFyZW50Tm9kZTtyZXR1cm4gZT09PXJ8fCEhKHImJnIubm9kZVR5cGU9PT0xJiZuLmNvbnRhaW5zJiZuLmNvbnRhaW5zKHIpKX06eS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe3JldHVybiB0JiYhIShlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpJjE2KX06ZnVuY3Rpb24oZSx0KXt3aGlsZSh0PXQucGFyZW50Tm9kZSlpZih0PT09ZSlyZXR1cm4hMDtyZXR1cm4hMX0sbnQuYXR0cj1mdW5jdGlvbihlLHQpe3ZhciBuLHI9byhlKTtyZXR1cm4gcnx8KHQ9dC50b0xvd2VyQ2FzZSgpKSwobj1pLmF0dHJIYW5kbGVbdF0pP24oZSk6cnx8WT9lLmdldEF0dHJpYnV0ZSh0KToobj1lLmdldEF0dHJpYnV0ZU5vZGUodCksbj90eXBlb2YgZVt0XT09XCJib29sZWFuXCI/ZVt0XT90Om51bGw6bi5zcGVjaWZpZWQ/bi52YWx1ZTpudWxsOm51bGwpfSxpPW50LnNlbGVjdG9ycz17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOk4sbWF0Y2g6SixhdHRySGFuZGxlOkc/e306e2hyZWY6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiLDIpfSx0eXBlOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcInR5cGVcIil9fSxmaW5kOntJRDpyP2Z1bmN0aW9uKGUsdCxuKXtpZih0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCE9PXAmJiFuKXt2YXIgcj10LmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiByJiZyLnBhcmVudE5vZGU/W3JdOltdfX06ZnVuY3Rpb24oZSxuLHIpe2lmKHR5cGVvZiBuLmdldEVsZW1lbnRCeUlkIT09cCYmIXIpe3ZhciBpPW4uZ2V0RWxlbWVudEJ5SWQoZSk7cmV0dXJuIGk/aS5pZD09PWV8fHR5cGVvZiBpLmdldEF0dHJpYnV0ZU5vZGUhPT1wJiZpLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKS52YWx1ZT09PWU/W2ldOnQ6W119fSxUQUc6UT9mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lIT09cClyZXR1cm4gdC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKX06ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpO2lmKGU9PT1cIipcIil7dmFyIHIsaT1bXSxzPTA7Zm9yKDtyPW5bc107cysrKXIubm9kZVR5cGU9PT0xJiZpLnB1c2gocik7cmV0dXJuIGl9cmV0dXJuIG59LE5BTUU6ZXQmJmZ1bmN0aW9uKGUsdCl7aWYodHlwZW9mIHQuZ2V0RWxlbWVudHNCeU5hbWUhPT1wKXJldHVybiB0LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpfSxDTEFTUzpaJiZmdW5jdGlvbihlLHQsbil7aWYodHlwZW9mIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSE9PXAmJiFuKXJldHVybiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSl9fSxyZWxhdGl2ZTp7XCI+XCI6e2RpcjpcInBhcmVudE5vZGVcIixmaXJzdDohMH0sXCIgXCI6e2RpcjpcInBhcmVudE5vZGVcIn0sXCIrXCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wiLGZpcnN0OiEwfSxcIn5cIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCJ9fSxwcmVGaWx0ZXI6e0FUVFI6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS5yZXBsYWNlKCQsXCJcIiksZVszXT0oZVs0XXx8ZVs1XXx8XCJcIikucmVwbGFjZSgkLFwiXCIpLGVbMl09PT1cIn49XCImJihlWzNdPVwiIFwiK2VbM10rXCIgXCIpLGUuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS50b0xvd2VyQ2FzZSgpLGVbMV09PT1cIm50aFwiPyhlWzJdfHxudC5lcnJvcihlWzBdKSxlWzNdPSsoZVszXT9lWzRdKyhlWzVdfHwxKToyKihlWzJdPT09XCJldmVuXCJ8fGVbMl09PT1cIm9kZFwiKSksZVs0XT0rKGVbNl0rZVs3XXx8ZVsyXT09PVwib2RkXCIpKTplWzJdJiZudC5lcnJvcihlWzBdKSxlfSxQU0VVRE86ZnVuY3Rpb24oZSl7dmFyIHQsbjtpZihKLkNISUxELnRlc3QoZVswXSkpcmV0dXJuIG51bGw7aWYoZVszXSllWzJdPWVbM107ZWxzZSBpZih0PWVbNF0pcS50ZXN0KHQpJiYobj11dCh0LCEwKSkmJihuPXQuaW5kZXhPZihcIilcIix0Lmxlbmd0aC1uKS10Lmxlbmd0aCkmJih0PXQuc2xpY2UoMCxuKSxlWzBdPWVbMF0uc2xpY2UoMCxuKSksZVsyXT10O3JldHVybiBlLnNsaWNlKDAsMyl9fSxmaWx0ZXI6e0lEOnI/ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZS5yZXBsYWNlKCQsXCJcIiksZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0QXR0cmlidXRlKFwiaWRcIik9PT1lfX06ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZS5yZXBsYWNlKCQsXCJcIiksZnVuY3Rpb24odCl7dmFyIG49dHlwZW9mIHQuZ2V0QXR0cmlidXRlTm9kZSE9PXAmJnQuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO3JldHVybiBuJiZuLnZhbHVlPT09ZX19LFRBRzpmdW5jdGlvbihlKXtyZXR1cm4gZT09PVwiKlwiP2Z1bmN0aW9uKCl7cmV0dXJuITB9OihlPWUucmVwbGFjZSgkLFwiXCIpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24odCl7cmV0dXJuIHQubm9kZU5hbWUmJnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWV9KX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9a1tkXVtlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9bmV3IFJlZ0V4cChcIihefFwiK08rXCIpXCIrZStcIihcIitPK1wifCQpXCIpKSYmayhlLGZ1bmN0aW9uKGUpe3JldHVybiB0LnRlc3QoZS5jbGFzc05hbWV8fHR5cGVvZiBlLmdldEF0dHJpYnV0ZSE9PXAmJmUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpfSl9LEFUVFI6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBmdW5jdGlvbihyLGkpe3ZhciBzPW50LmF0dHIocixlKTtyZXR1cm4gcz09bnVsbD90PT09XCIhPVwiOnQ/KHMrPVwiXCIsdD09PVwiPVwiP3M9PT1uOnQ9PT1cIiE9XCI/cyE9PW46dD09PVwiXj1cIj9uJiZzLmluZGV4T2Yobik9PT0wOnQ9PT1cIio9XCI/biYmcy5pbmRleE9mKG4pPi0xOnQ9PT1cIiQ9XCI/biYmcy5zdWJzdHIocy5sZW5ndGgtbi5sZW5ndGgpPT09bjp0PT09XCJ+PVwiPyhcIiBcIitzK1wiIFwiKS5pbmRleE9mKG4pPi0xOnQ9PT1cInw9XCI/cz09PW58fHMuc3Vic3RyKDAsbi5sZW5ndGgrMSk9PT1uK1wiLVwiOiExKTohMH19LENISUxEOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBlPT09XCJudGhcIj9mdW5jdGlvbihlKXt2YXIgdCxpLHM9ZS5wYXJlbnROb2RlO2lmKG49PT0xJiZyPT09MClyZXR1cm4hMDtpZihzKXtpPTA7Zm9yKHQ9cy5maXJzdENoaWxkO3Q7dD10Lm5leHRTaWJsaW5nKWlmKHQubm9kZVR5cGU9PT0xKXtpKys7aWYoZT09PXQpYnJlYWt9fXJldHVybiBpLT1yLGk9PT1ufHxpJW49PT0wJiZpL24+PTB9OmZ1bmN0aW9uKHQpe3ZhciBuPXQ7c3dpdGNoKGUpe2Nhc2VcIm9ubHlcIjpjYXNlXCJmaXJzdFwiOndoaWxlKG49bi5wcmV2aW91c1NpYmxpbmcpaWYobi5ub2RlVHlwZT09PTEpcmV0dXJuITE7aWYoZT09PVwiZmlyc3RcIilyZXR1cm4hMDtuPXQ7Y2FzZVwibGFzdFwiOndoaWxlKG49bi5uZXh0U2libGluZylpZihuLm5vZGVUeXBlPT09MSlyZXR1cm4hMTtyZXR1cm4hMH19fSxQU0VVRE86ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWkucHNldWRvc1tlXXx8aS5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV18fG50LmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIitlKTtyZXR1cm4gcltkXT9yKHQpOnIubGVuZ3RoPjE/KG49W2UsZSxcIlwiLHRdLGkuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpP04oZnVuY3Rpb24oZSxuKXt2YXIgaSxzPXIoZSx0KSxvPXMubGVuZ3RoO3doaWxlKG8tLSlpPVQuY2FsbChlLHNbb10pLGVbaV09IShuW2ldPXNbb10pfSk6ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSwwLG4pfSk6cn19LHBzZXVkb3M6e25vdDpOKGZ1bmN0aW9uKGUpe3ZhciB0PVtdLG49W10scj1hKGUucmVwbGFjZShqLFwiJDFcIikpO3JldHVybiByW2RdP04oZnVuY3Rpb24oZSx0LG4saSl7dmFyIHMsbz1yKGUsbnVsbCxpLFtdKSx1PWUubGVuZ3RoO3doaWxlKHUtLSlpZihzPW9bdV0pZVt1XT0hKHRbdV09cyl9KTpmdW5jdGlvbihlLGkscyl7cmV0dXJuIHRbMF09ZSxyKHQsbnVsbCxzLG4pLCFuLnBvcCgpfX0pLGhhczpOKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gbnQoZSx0KS5sZW5ndGg+MH19KSxjb250YWluczpOKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4odC50ZXh0Q29udGVudHx8dC5pbm5lclRleHR8fHModCkpLmluZGV4T2YoZSk+LTF9fSksZW5hYmxlZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5kaXNhYmxlZD09PSExfSxkaXNhYmxlZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5kaXNhYmxlZD09PSEwfSxjaGVja2VkOmZ1bmN0aW9uKGUpe3ZhciB0PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gdD09PVwiaW5wdXRcIiYmISFlLmNoZWNrZWR8fHQ9PT1cIm9wdGlvblwiJiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LGUuc2VsZWN0ZWQ9PT0hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFpLnBzZXVkb3MuZW1wdHkoZSl9LGVtcHR5OmZ1bmN0aW9uKGUpe3ZhciB0O2U9ZS5maXJzdENoaWxkO3doaWxlKGUpe2lmKGUubm9kZU5hbWU+XCJAXCJ8fCh0PWUubm9kZVR5cGUpPT09M3x8dD09PTQpcmV0dXJuITE7ZT1lLm5leHRTaWJsaW5nfXJldHVybiEwfSxoZWFkZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIFgudGVzdChlLm5vZGVOYW1lKX0sdGV4dDpmdW5jdGlvbihlKXt2YXIgdCxuO3JldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cImlucHV0XCImJih0PWUudHlwZSk9PT1cInRleHRcIiYmKChuPWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSk9PW51bGx8fG4udG9Mb3dlckNhc2UoKT09PXQpfSxyYWRpbzpydChcInJhZGlvXCIpLGNoZWNrYm94OnJ0KFwiY2hlY2tib3hcIiksZmlsZTpydChcImZpbGVcIikscGFzc3dvcmQ6cnQoXCJwYXNzd29yZFwiKSxpbWFnZTpydChcImltYWdlXCIpLHN1Ym1pdDppdChcInN1Ym1pdFwiKSxyZXNldDppdChcInJlc2V0XCIpLGJ1dHRvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHQ9PT1cImlucHV0XCImJmUudHlwZT09PVwiYnV0dG9uXCJ8fHQ9PT1cImJ1dHRvblwifSxpbnB1dDpmdW5jdGlvbihlKXtyZXR1cm4gVi50ZXN0KGUubm9kZU5hbWUpfSxmb2N1czpmdW5jdGlvbihlKXt2YXIgdD1lLm93bmVyRG9jdW1lbnQ7cmV0dXJuIGU9PT10LmFjdGl2ZUVsZW1lbnQmJighdC5oYXNGb2N1c3x8dC5oYXNGb2N1cygpKSYmISEoZS50eXBlfHxlLmhyZWZ8fH5lLnRhYkluZGV4KX0sYWN0aXZlOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09ZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnR9LGZpcnN0OnN0KGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDpzdChmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6c3QoZnVuY3Rpb24oZSx0LG4pe3JldHVybltuPDA/bit0Om5dfSksZXZlbjpzdChmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLG9kZDpzdChmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0xO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLGx0OnN0KGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9bjwwP24rdDpuOy0tcj49MDspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6c3QoZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1uPDA/bit0Om47KytyPHQ7KWUucHVzaChyKTtyZXR1cm4gZX0pfX0sZj15LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uP2Z1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PT10PyhsPSEwLDApOighZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbnx8IXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjplLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpJjQpPy0xOjF9OmZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpcmV0dXJuIGw9ITAsMDtpZihlLnNvdXJjZUluZGV4JiZ0LnNvdXJjZUluZGV4KXJldHVybiBlLnNvdXJjZUluZGV4LXQuc291cmNlSW5kZXg7dmFyIG4scixpPVtdLHM9W10sbz1lLnBhcmVudE5vZGUsdT10LnBhcmVudE5vZGUsYT1vO2lmKG89PT11KXJldHVybiBvdChlLHQpO2lmKCFvKXJldHVybi0xO2lmKCF1KXJldHVybiAxO3doaWxlKGEpaS51bnNoaWZ0KGEpLGE9YS5wYXJlbnROb2RlO2E9dTt3aGlsZShhKXMudW5zaGlmdChhKSxhPWEucGFyZW50Tm9kZTtuPWkubGVuZ3RoLHI9cy5sZW5ndGg7Zm9yKHZhciBmPTA7ZjxuJiZmPHI7ZisrKWlmKGlbZl0hPT1zW2ZdKXJldHVybiBvdChpW2ZdLHNbZl0pO3JldHVybiBmPT09bj9vdChlLHNbZl0sLTEpOm90KGlbZl0sdCwxKX0sWzAsMF0uc29ydChmKSxoPSFsLG50LnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1bXSxyPTEsaT0wO2w9aCxlLnNvcnQoZik7aWYobCl7Zm9yKDt0PWVbcl07cisrKXQ9PT1lW3ItMV0mJihpPW4ucHVzaChyKSk7d2hpbGUoaS0tKWUuc3BsaWNlKG5baV0sMSl9cmV0dXJuIGV9LG50LmVycm9yPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiK2UpfSxhPW50LmNvbXBpbGU9ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9W10scz1BW2RdW2UrXCIgXCJdO2lmKCFzKXt0fHwodD11dChlKSksbj10Lmxlbmd0aDt3aGlsZShuLS0pcz1odCh0W25dKSxzW2RdP3IucHVzaChzKTppLnB1c2gocyk7cz1BKGUscHQoaSxyKSl9cmV0dXJuIHN9LGcucXVlcnlTZWxlY3RvckFsbCYmZnVuY3Rpb24oKXt2YXIgZSx0PXZ0LG49Lyd8XFxcXC9nLHI9L1xcPVtcXHgyMFxcdFxcclxcblxcZl0qKFteJ1wiXFxdXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXF0vZyxpPVtcIjpmb2N1c1wiXSxzPVtcIjphY3RpdmVcIl0sdT15Lm1hdGNoZXNTZWxlY3Rvcnx8eS5tb3pNYXRjaGVzU2VsZWN0b3J8fHkud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHx5Lm9NYXRjaGVzU2VsZWN0b3J8fHkubXNNYXRjaGVzU2VsZWN0b3I7SyhmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxzZWxlY3Q+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aHx8aS5wdXNoKFwiXFxcXFtcIitPK1wiKig/OmNoZWNrZWR8ZGlzYWJsZWR8aXNtYXB8bXVsdGlwbGV8cmVhZG9ubHl8c2VsZWN0ZWR8dmFsdWUpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8aS5wdXNoKFwiOmNoZWNrZWRcIil9KSxLKGZ1bmN0aW9uKGUpe2UuaW5uZXJIVE1MPVwiPHAgdGVzdD0nJz48L3A+XCIsZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3Rlc3RePScnXVwiKS5sZW5ndGgmJmkucHVzaChcIlsqXiRdPVwiK08rXCIqKD86XFxcIlxcXCJ8JycpXCIpLGUuaW5uZXJIVE1MPVwiPGlucHV0IHR5cGU9J2hpZGRlbicvPlwiLGUucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aHx8aS5wdXNoKFwiOmVuYWJsZWRcIixcIjpkaXNhYmxlZFwiKX0pLGk9bmV3IFJlZ0V4cChpLmpvaW4oXCJ8XCIpKSx2dD1mdW5jdGlvbihlLHIscyxvLHUpe2lmKCFvJiYhdSYmIWkudGVzdChlKSl7dmFyIGEsZixsPSEwLGM9ZCxoPXIscD1yLm5vZGVUeXBlPT09OSYmZTtpZihyLm5vZGVUeXBlPT09MSYmci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIT09XCJvYmplY3RcIil7YT11dChlKSwobD1yLmdldEF0dHJpYnV0ZShcImlkXCIpKT9jPWwucmVwbGFjZShuLFwiXFxcXCQmXCIpOnIuc2V0QXR0cmlidXRlKFwiaWRcIixjKSxjPVwiW2lkPSdcIitjK1wiJ10gXCIsZj1hLmxlbmd0aDt3aGlsZShmLS0pYVtmXT1jK2FbZl0uam9pbihcIlwiKTtoPXoudGVzdChlKSYmci5wYXJlbnROb2RlfHxyLHA9YS5qb2luKFwiLFwiKX1pZihwKXRyeXtyZXR1cm4gUy5hcHBseShzLHguY2FsbChoLnF1ZXJ5U2VsZWN0b3JBbGwocCksMCkpLHN9Y2F0Y2godil7fWZpbmFsbHl7bHx8ci5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKX19cmV0dXJuIHQoZSxyLHMsbyx1KX0sdSYmKEsoZnVuY3Rpb24odCl7ZT11LmNhbGwodCxcImRpdlwiKTt0cnl7dS5jYWxsKHQsXCJbdGVzdCE9JyddOnNpenpsZVwiKSxzLnB1c2goXCIhPVwiLEgpfWNhdGNoKG4pe319KSxzPW5ldyBSZWdFeHAocy5qb2luKFwifFwiKSksbnQubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKHQsbil7bj1uLnJlcGxhY2UocixcIj0nJDEnXVwiKTtpZighbyh0KSYmIXMudGVzdChuKSYmIWkudGVzdChuKSl0cnl7dmFyIGE9dS5jYWxsKHQsbik7aWYoYXx8ZXx8dC5kb2N1bWVudCYmdC5kb2N1bWVudC5ub2RlVHlwZSE9PTExKXJldHVybiBhfWNhdGNoKGYpe31yZXR1cm4gbnQobixudWxsLG51bGwsW3RdKS5sZW5ndGg+MH0pfSgpLGkucHNldWRvcy5udGg9aS5wc2V1ZG9zLmVxLGkuZmlsdGVycz1tdC5wcm90b3R5cGU9aS5wc2V1ZG9zLGkuc2V0RmlsdGVycz1uZXcgbXQsbnQuYXR0cj12LmF0dHIsdi5maW5kPW50LHYuZXhwcj1udC5zZWxlY3RvcnMsdi5leHByW1wiOlwiXT12LmV4cHIucHNldWRvcyx2LnVuaXF1ZT1udC51bmlxdWVTb3J0LHYudGV4dD1udC5nZXRUZXh0LHYuaXNYTUxEb2M9bnQuaXNYTUwsdi5jb250YWlucz1udC5jb250YWluc30oZSk7dmFyIG50PS9VbnRpbCQvLHJ0PS9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLGl0PS9eLlteOiNcXFtcXC4sXSokLyxzdD12LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LG90PXtjaGlsZHJlbjohMCxjb250ZW50czohMCxuZXh0OiEwLHByZXY6ITB9O3YuZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLHMsbyx1PXRoaXM7aWYodHlwZW9mIGUhPVwic3RyaW5nXCIpcmV0dXJuIHYoZSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHQ9MCxuPXUubGVuZ3RoO3Q8bjt0KyspaWYodi5jb250YWlucyh1W3RdLHRoaXMpKXJldHVybiEwfSk7bz10aGlzLnB1c2hTdGFjayhcIlwiLFwiZmluZFwiLGUpO2Zvcih0PTAsbj10aGlzLmxlbmd0aDt0PG47dCsrKXtyPW8ubGVuZ3RoLHYuZmluZChlLHRoaXNbdF0sbyk7aWYodD4wKWZvcihpPXI7aTxvLmxlbmd0aDtpKyspZm9yKHM9MDtzPHI7cysrKWlmKG9bc109PT1vW2ldKXtvLnNwbGljZShpLS0sMSk7YnJlYWt9fXJldHVybiBvfSxoYXM6ZnVuY3Rpb24oZSl7dmFyIHQsbj12KGUsdGhpcykscj1uLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodD0wO3Q8cjt0KyspaWYodi5jb250YWlucyh0aGlzLG5bdF0pKXJldHVybiEwfSl9LG5vdDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZnQodGhpcyxlLCExKSxcIm5vdFwiLGUpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsZSwhMCksXCJmaWx0ZXJcIixlKX0saXM6ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiYodHlwZW9mIGU9PVwic3RyaW5nXCI/c3QudGVzdChlKT92KGUsdGhpcy5jb250ZXh0KS5pbmRleCh0aGlzWzBdKT49MDp2LmZpbHRlcihlLHRoaXMpLmxlbmd0aD4wOnRoaXMuZmlsdGVyKGUpLmxlbmd0aD4wKX0sY2xvc2VzdDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXRoaXMubGVuZ3RoLHM9W10sbz1zdC50ZXN0KGUpfHx0eXBlb2YgZSE9XCJzdHJpbmdcIj92KGUsdHx8dGhpcy5jb250ZXh0KTowO2Zvcig7cjxpO3IrKyl7bj10aGlzW3JdO3doaWxlKG4mJm4ub3duZXJEb2N1bWVudCYmbiE9PXQmJm4ubm9kZVR5cGUhPT0xMSl7aWYobz9vLmluZGV4KG4pPi0xOnYuZmluZC5tYXRjaGVzU2VsZWN0b3IobixlKSl7cy5wdXNoKG4pO2JyZWFrfW49bi5wYXJlbnROb2RlfX1yZXR1cm4gcz1zLmxlbmd0aD4xP3YudW5pcXVlKHMpOnMsdGhpcy5wdXNoU3RhY2socyxcImNsb3Nlc3RcIixlKX0saW5kZXg6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/dHlwZW9mIGU9PVwic3RyaW5nXCI/di5pbkFycmF5KHRoaXNbMF0sdihlKSk6di5pbkFycmF5KGUuanF1ZXJ5P2VbMF06ZSx0aGlzKTp0aGlzWzBdJiZ0aGlzWzBdLnBhcmVudE5vZGU/dGhpcy5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2YgZT09XCJzdHJpbmdcIj92KGUsdCk6di5tYWtlQXJyYXkoZSYmZS5ub2RlVHlwZT9bZV06ZSkscj12Lm1lcmdlKHRoaXMuZ2V0KCksbik7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHV0KG5bMF0pfHx1dChyWzBdKT9yOnYudW5pcXVlKHIpKX0sYWRkQmFjazpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hZGQoZT09bnVsbD90aGlzLnByZXZPYmplY3Q6dGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSl9fSksdi5mbi5hbmRTZWxmPXYuZm4uYWRkQmFjayx2LmVhY2goe3BhcmVudDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJnQubm9kZVR5cGUhPT0xMT90Om51bGx9LHBhcmVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZGlyKGUsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2LmRpcihlLFwicGFyZW50Tm9kZVwiLG4pfSxuZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBhdChlLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oZSl7cmV0dXJuIGF0KGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZGlyKGUsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihlKXtyZXR1cm4gdi5kaXIoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdi5kaXIoZSxcIm5leHRTaWJsaW5nXCIsbil9LHByZXZVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHYuZGlyKGUsXCJwcmV2aW91c1NpYmxpbmdcIixuKX0sc2libGluZ3M6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuc2libGluZygoZS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxlKX0sY2hpbGRyZW46ZnVuY3Rpb24oZSl7cmV0dXJuIHYuc2libGluZyhlLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihlKXtyZXR1cm4gdi5ub2RlTmFtZShlLFwiaWZyYW1lXCIpP2UuY29udGVudERvY3VtZW50fHxlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6di5tZXJnZShbXSxlLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oZSx0KXt2LmZuW2VdPWZ1bmN0aW9uKG4scil7dmFyIGk9di5tYXAodGhpcyx0LG4pO3JldHVybiBudC50ZXN0KGUpfHwocj1uKSxyJiZ0eXBlb2Ygcj09XCJzdHJpbmdcIiYmKGk9di5maWx0ZXIocixpKSksaT10aGlzLmxlbmd0aD4xJiYhb3RbZV0/di51bmlxdWUoaSk6aSx0aGlzLmxlbmd0aD4xJiZydC50ZXN0KGUpJiYoaT1pLnJldmVyc2UoKSksdGhpcy5wdXNoU3RhY2soaSxlLGwuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIsXCIpKX19KSx2LmV4dGVuZCh7ZmlsdGVyOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbiYmKGU9XCI6bm90KFwiK2UrXCIpXCIpLHQubGVuZ3RoPT09MT92LmZpbmQubWF0Y2hlc1NlbGVjdG9yKHRbMF0sZSk/W3RbMF1dOltdOnYuZmluZC5tYXRjaGVzKGUsdCl9LGRpcjpmdW5jdGlvbihlLG4scil7dmFyIGk9W10scz1lW25dO3doaWxlKHMmJnMubm9kZVR5cGUhPT05JiYocj09PXR8fHMubm9kZVR5cGUhPT0xfHwhdihzKS5pcyhyKSkpcy5ub2RlVHlwZT09PTEmJmkucHVzaChzKSxzPXNbbl07cmV0dXJuIGl9LHNpYmxpbmc6ZnVuY3Rpb24oZSx0KXt2YXIgbj1bXTtmb3IoO2U7ZT1lLm5leHRTaWJsaW5nKWUubm9kZVR5cGU9PT0xJiZlIT09dCYmbi5wdXNoKGUpO3JldHVybiBufX0pO3ZhciBjdD1cImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixodD0vIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxwdD0vXlxccysvLGR0PS88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSx2dD0vPChbXFx3Ol0rKS8sbXQ9Lzx0Ym9keS9pLGd0PS88fCYjP1xcdys7Lyx5dD0vPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLGJ0PS88KD86c2NyaXB0fG9iamVjdHxlbWJlZHxvcHRpb258c3R5bGUpL2ksd3Q9bmV3IFJlZ0V4cChcIjwoPzpcIitjdCtcIilbXFxcXHMvPl1cIixcImlcIiksRXQ9L14oPzpjaGVja2JveHxyYWRpbykkLyxTdD0vY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLHh0PS9cXC8oamF2YXxlY21hKXNjcmlwdC9pLFR0PS9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8XFwtXFwtKXxbXFxdXFwtXXsyfT5cXHMqJC9nLE50PXtvcHRpb246WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0sbGVnZW5kOlsxLFwiPGZpZWxkc2V0PlwiLFwiPC9maWVsZHNldD5cIl0sdGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sY29sOlsyLFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIixcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sYXJlYTpbMSxcIjxtYXA+XCIsXCI8L21hcD5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX0sQ3Q9bHQoaSksa3Q9Q3QuYXBwZW5kQ2hpbGQoaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtOdC5vcHRncm91cD1OdC5vcHRpb24sTnQudGJvZHk9TnQudGZvb3Q9TnQuY29sZ3JvdXA9TnQuY2FwdGlvbj1OdC50aGVhZCxOdC50aD1OdC50ZCx2LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZXx8KE50Ll9kZWZhdWx0PVsxLFwiWDxkaXY+XCIsXCI8L2Rpdj5cIl0pLHYuZm4uZXh0ZW5kKHt0ZXh0OmZ1bmN0aW9uKGUpe3JldHVybiB2LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBlPT09dD92LnRleHQodGhpcyk6dGhpcy5lbXB0eSgpLmFwcGVuZCgodGhpc1swXSYmdGhpc1swXS5vd25lckRvY3VtZW50fHxpKS5jcmVhdGVUZXh0Tm9kZShlKSl9LG51bGwsZSxhcmd1bWVudHMubGVuZ3RoKX0sd3JhcEFsbDpmdW5jdGlvbihlKXtpZih2LmlzRnVuY3Rpb24oZSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbih0KXt2KHRoaXMpLndyYXBBbGwoZS5jYWxsKHRoaXMsdCkpfSk7aWYodGhpc1swXSl7dmFyIHQ9dihlLHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUoITApO3RoaXNbMF0ucGFyZW50Tm9kZSYmdC5pbnNlcnRCZWZvcmUodGhpc1swXSksdC5tYXAoZnVuY3Rpb24oKXt2YXIgZT10aGlzO3doaWxlKGUuZmlyc3RDaGlsZCYmZS5maXJzdENoaWxkLm5vZGVUeXBlPT09MSllPWUuZmlyc3RDaGlsZDtyZXR1cm4gZX0pLmFwcGVuZCh0aGlzKX1yZXR1cm4gdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKGUpe3JldHVybiB2LmlzRnVuY3Rpb24oZSk/dGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3YodGhpcykud3JhcElubmVyKGUuY2FsbCh0aGlzLHQpKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXYodGhpcyksbj10LmNvbnRlbnRzKCk7bi5sZW5ndGg/bi53cmFwQWxsKGUpOnQuYXBwZW5kKGUpfSl9LHdyYXA6ZnVuY3Rpb24oZSl7dmFyIHQ9di5pc0Z1bmN0aW9uKGUpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24obil7dih0aGlzKS53cmFwQWxsKHQ/ZS5jYWxsKHRoaXMsbik6ZSl9KX0sdW53cmFwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe3Yubm9kZU5hbWUodGhpcyxcImJvZHlcIil8fHYodGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKX0pLmVuZCgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsITAsZnVuY3Rpb24oZSl7KHRoaXMubm9kZVR5cGU9PT0xfHx0aGlzLm5vZGVUeXBlPT09MTEpJiZ0aGlzLmFwcGVuZENoaWxkKGUpfSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsITAsZnVuY3Rpb24oZSl7KHRoaXMubm9kZVR5cGU9PT0xfHx0aGlzLm5vZGVUeXBlPT09MTEpJiZ0aGlzLmluc2VydEJlZm9yZShlLHRoaXMuZmlyc3RDaGlsZCl9KX0sYmVmb3JlOmZ1bmN0aW9uKCl7aWYoIXV0KHRoaXNbMF0pKXJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywhMSxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcyl9KTtpZihhcmd1bWVudHMubGVuZ3RoKXt2YXIgZT12LmNsZWFuKGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHYubWVyZ2UoZSx0aGlzKSxcImJlZm9yZVwiLHRoaXMuc2VsZWN0b3IpfX0sYWZ0ZXI6ZnVuY3Rpb24oKXtpZighdXQodGhpc1swXSkpcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCExLGZ1bmN0aW9uKGUpe3RoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzLm5leHRTaWJsaW5nKX0pO2lmKGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPXYuY2xlYW4oYXJndW1lbnRzKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2sodi5tZXJnZSh0aGlzLGUpLFwiYWZ0ZXJcIix0aGlzLnNlbGVjdG9yKX19LHJlbW92ZTpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MDtmb3IoOyhuPXRoaXNbcl0pIT1udWxsO3IrKylpZighZXx8di5maWx0ZXIoZSxbbl0pLmxlbmd0aCkhdCYmbi5ub2RlVHlwZT09PTEmJih2LmNsZWFuRGF0YShuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSksdi5jbGVhbkRhdGEoW25dKSksbi5wYXJlbnROb2RlJiZuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7cmV0dXJuIHRoaXN9LGVtcHR5OmZ1bmN0aW9uKCl7dmFyIGUsdD0wO2Zvcig7KGU9dGhpc1t0XSkhPW51bGw7dCsrKXtlLm5vZGVUeXBlPT09MSYmdi5jbGVhbkRhdGEoZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpO3doaWxlKGUuZmlyc3RDaGlsZCllLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCl9cmV0dXJuIHRoaXN9LGNsb25lOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9ZT09bnVsbD8hMTplLHQ9dD09bnVsbD9lOnQsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdi5jbG9uZSh0aGlzLGUsdCl9KX0saHRtbDpmdW5jdGlvbihlKXtyZXR1cm4gdi5hY2Nlc3ModGhpcyxmdW5jdGlvbihlKXt2YXIgbj10aGlzWzBdfHx7fSxyPTAsaT10aGlzLmxlbmd0aDtpZihlPT09dClyZXR1cm4gbi5ub2RlVHlwZT09PTE/bi5pbm5lckhUTUwucmVwbGFjZShodCxcIlwiKTp0O2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiJiYheXQudGVzdChlKSYmKHYuc3VwcG9ydC5odG1sU2VyaWFsaXplfHwhd3QudGVzdChlKSkmJih2LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2V8fCFwdC50ZXN0KGUpKSYmIU50Wyh2dC5leGVjKGUpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pe2U9ZS5yZXBsYWNlKGR0LFwiPCQxPjwvJDI+XCIpO3RyeXtmb3IoO3I8aTtyKyspbj10aGlzW3JdfHx7fSxuLm5vZGVUeXBlPT09MSYmKHYuY2xlYW5EYXRhKG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKSxuLmlubmVySFRNTD1lKTtuPTB9Y2F0Y2gocyl7fX1uJiZ0aGlzLmVtcHR5KCkuYXBwZW5kKGUpfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKGUpe3JldHVybiB1dCh0aGlzWzBdKT90aGlzLmxlbmd0aD90aGlzLnB1c2hTdGFjayh2KHYuaXNGdW5jdGlvbihlKT9lKCk6ZSksXCJyZXBsYWNlV2l0aFwiLGUpOnRoaXM6di5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbih0KXt2YXIgbj12KHRoaXMpLHI9bi5odG1sKCk7bi5yZXBsYWNlV2l0aChlLmNhbGwodGhpcyx0LHIpKX0pOih0eXBlb2YgZSE9XCJzdHJpbmdcIiYmKGU9dihlKS5kZXRhY2goKSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5uZXh0U2libGluZyxuPXRoaXMucGFyZW50Tm9kZTt2KHRoaXMpLnJlbW92ZSgpLHQ/dih0KS5iZWZvcmUoZSk6dihuKS5hcHBlbmQoZSl9KSl9LGRldGFjaDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZW1vdmUoZSwhMCl9LGRvbU1hbmlwOmZ1bmN0aW9uKGUsbixyKXtlPVtdLmNvbmNhdC5hcHBseShbXSxlKTt2YXIgaSxzLG8sdSxhPTAsZj1lWzBdLGw9W10sYz10aGlzLmxlbmd0aDtpZighdi5zdXBwb3J0LmNoZWNrQ2xvbmUmJmM+MSYmdHlwZW9mIGY9PVwic3RyaW5nXCImJlN0LnRlc3QoZikpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3YodGhpcykuZG9tTWFuaXAoZSxuLHIpfSk7aWYodi5pc0Z1bmN0aW9uKGYpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSl7dmFyIHM9dih0aGlzKTtlWzBdPWYuY2FsbCh0aGlzLGksbj9zLmh0bWwoKTp0KSxzLmRvbU1hbmlwKGUsbixyKX0pO2lmKHRoaXNbMF0pe2k9di5idWlsZEZyYWdtZW50KGUsdGhpcyxsKSxvPWkuZnJhZ21lbnQscz1vLmZpcnN0Q2hpbGQsby5jaGlsZE5vZGVzLmxlbmd0aD09PTEmJihvPXMpO2lmKHMpe249biYmdi5ub2RlTmFtZShzLFwidHJcIik7Zm9yKHU9aS5jYWNoZWFibGV8fGMtMTthPGM7YSsrKXIuY2FsbChuJiZ2Lm5vZGVOYW1lKHRoaXNbYV0sXCJ0YWJsZVwiKT9MdCh0aGlzW2FdLFwidGJvZHlcIik6dGhpc1thXSxhPT09dT9vOnYuY2xvbmUobywhMCwhMCkpfW89cz1udWxsLGwubGVuZ3RoJiZ2LmVhY2gobCxmdW5jdGlvbihlLHQpe3Quc3JjP3YuYWpheD92LmFqYXgoe3VybDp0LnNyYyx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixhc3luYzohMSxnbG9iYWw6ITEsXCJ0aHJvd3NcIjohMH0pOnYuZXJyb3IoXCJubyBhamF4XCIpOnYuZ2xvYmFsRXZhbCgodC50ZXh0fHx0LnRleHRDb250ZW50fHx0LmlubmVySFRNTHx8XCJcIikucmVwbGFjZShUdCxcIlwiKSksdC5wYXJlbnROb2RlJiZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCl9KX1yZXR1cm4gdGhpc319KSx2LmJ1aWxkRnJhZ21lbnQ9ZnVuY3Rpb24oZSxuLHIpe3ZhciBzLG8sdSxhPWVbMF07cmV0dXJuIG49bnx8aSxuPSFuLm5vZGVUeXBlJiZuWzBdfHxuLG49bi5vd25lckRvY3VtZW50fHxuLGUubGVuZ3RoPT09MSYmdHlwZW9mIGE9PVwic3RyaW5nXCImJmEubGVuZ3RoPDUxMiYmbj09PWkmJmEuY2hhckF0KDApPT09XCI8XCImJiFidC50ZXN0KGEpJiYodi5zdXBwb3J0LmNoZWNrQ2xvbmV8fCFTdC50ZXN0KGEpKSYmKHYuc3VwcG9ydC5odG1sNUNsb25lfHwhd3QudGVzdChhKSkmJihvPSEwLHM9di5mcmFnbWVudHNbYV0sdT1zIT09dCksc3x8KHM9bi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksdi5jbGVhbihlLG4scyxyKSxvJiYodi5mcmFnbWVudHNbYV09dSYmcykpLHtmcmFnbWVudDpzLGNhY2hlYWJsZTpvfX0sdi5mcmFnbWVudHM9e30sdi5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGUsdCl7di5mbltlXT1mdW5jdGlvbihuKXt2YXIgcixpPTAscz1bXSxvPXYobiksdT1vLmxlbmd0aCxhPXRoaXMubGVuZ3RoPT09MSYmdGhpc1swXS5wYXJlbnROb2RlO2lmKChhPT1udWxsfHxhJiZhLm5vZGVUeXBlPT09MTEmJmEuY2hpbGROb2Rlcy5sZW5ndGg9PT0xKSYmdT09PTEpcmV0dXJuIG9bdF0odGhpc1swXSksdGhpcztmb3IoO2k8dTtpKyspcj0oaT4wP3RoaXMuY2xvbmUoITApOnRoaXMpLmdldCgpLHYob1tpXSlbdF0ocikscz1zLmNvbmNhdChyKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2socyxlLG8uc2VsZWN0b3IpfX0pLHYuZXh0ZW5kKHtjbG9uZTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxzLG87di5zdXBwb3J0Lmh0bWw1Q2xvbmV8fHYuaXNYTUxEb2MoZSl8fCF3dC50ZXN0KFwiPFwiK2Uubm9kZU5hbWUrXCI+XCIpP289ZS5jbG9uZU5vZGUoITApOihrdC5pbm5lckhUTUw9ZS5vdXRlckhUTUwsa3QucmVtb3ZlQ2hpbGQobz1rdC5maXJzdENoaWxkKSk7aWYoKCF2LnN1cHBvcnQubm9DbG9uZUV2ZW50fHwhdi5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSYmKGUubm9kZVR5cGU9PT0xfHxlLm5vZGVUeXBlPT09MTEpJiYhdi5pc1hNTERvYyhlKSl7T3QoZSxvKSxyPU10KGUpLGk9TXQobyk7Zm9yKHM9MDtyW3NdOysrcylpW3NdJiZPdChyW3NdLGlbc10pfWlmKHQpe0F0KGUsbyk7aWYobil7cj1NdChlKSxpPU10KG8pO2ZvcihzPTA7cltzXTsrK3MpQXQocltzXSxpW3NdKX19cmV0dXJuIHI9aT1udWxsLG99LGNsZWFuOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBzLG8sdSxhLGYsbCxjLGgscCxkLG0sZyx5PXQ9PT1pJiZDdCxiPVtdO2lmKCF0fHx0eXBlb2YgdC5jcmVhdGVEb2N1bWVudEZyYWdtZW50PT1cInVuZGVmaW5lZFwiKXQ9aTtmb3Iocz0wOyh1PWVbc10pIT1udWxsO3MrKyl7dHlwZW9mIHU9PVwibnVtYmVyXCImJih1Kz1cIlwiKTtpZighdSljb250aW51ZTtpZih0eXBlb2YgdT09XCJzdHJpbmdcIilpZighZ3QudGVzdCh1KSl1PXQuY3JlYXRlVGV4dE5vZGUodSk7ZWxzZXt5PXl8fGx0KHQpLGM9dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHkuYXBwZW5kQ2hpbGQoYyksdT11LnJlcGxhY2UoZHQsXCI8JDE+PC8kMj5cIiksYT0odnQuZXhlYyh1KXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCksZj1OdFthXXx8TnQuX2RlZmF1bHQsbD1mWzBdLGMuaW5uZXJIVE1MPWZbMV0rdStmWzJdO3doaWxlKGwtLSljPWMubGFzdENoaWxkO2lmKCF2LnN1cHBvcnQudGJvZHkpe2g9bXQudGVzdCh1KSxwPWE9PT1cInRhYmxlXCImJiFoP2MuZmlyc3RDaGlsZCYmYy5maXJzdENoaWxkLmNoaWxkTm9kZXM6ZlsxXT09PVwiPHRhYmxlPlwiJiYhaD9jLmNoaWxkTm9kZXM6W107Zm9yKG89cC5sZW5ndGgtMTtvPj0wOy0tbyl2Lm5vZGVOYW1lKHBbb10sXCJ0Ym9keVwiKSYmIXBbb10uY2hpbGROb2Rlcy5sZW5ndGgmJnBbb10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwW29dKX0hdi5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlJiZwdC50ZXN0KHUpJiZjLmluc2VydEJlZm9yZSh0LmNyZWF0ZVRleHROb2RlKHB0LmV4ZWModSlbMF0pLGMuZmlyc3RDaGlsZCksdT1jLmNoaWxkTm9kZXMsYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpfXUubm9kZVR5cGU/Yi5wdXNoKHUpOnYubWVyZ2UoYix1KX1jJiYodT1jPXk9bnVsbCk7aWYoIXYuc3VwcG9ydC5hcHBlbmRDaGVja2VkKWZvcihzPTA7KHU9YltzXSkhPW51bGw7cysrKXYubm9kZU5hbWUodSxcImlucHV0XCIpP190KHUpOnR5cGVvZiB1LmdldEVsZW1lbnRzQnlUYWdOYW1lIT1cInVuZGVmaW5lZFwiJiZ2LmdyZXAodS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLF90KTtpZihuKXttPWZ1bmN0aW9uKGUpe2lmKCFlLnR5cGV8fHh0LnRlc3QoZS50eXBlKSlyZXR1cm4gcj9yLnB1c2goZS5wYXJlbnROb2RlP2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTplKTpuLmFwcGVuZENoaWxkKGUpfTtmb3Iocz0wOyh1PWJbc10pIT1udWxsO3MrKylpZighdi5ub2RlTmFtZSh1LFwic2NyaXB0XCIpfHwhbSh1KSluLmFwcGVuZENoaWxkKHUpLHR5cGVvZiB1LmdldEVsZW1lbnRzQnlUYWdOYW1lIT1cInVuZGVmaW5lZFwiJiYoZz12LmdyZXAodi5tZXJnZShbXSx1LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKSxtKSxiLnNwbGljZS5hcHBseShiLFtzKzEsMF0uY29uY2F0KGcpKSxzKz1nLmxlbmd0aCl9cmV0dXJuIGJ9LGNsZWFuRGF0YTpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxzLG89MCx1PXYuZXhwYW5kbyxhPXYuY2FjaGUsZj12LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyxsPXYuZXZlbnQuc3BlY2lhbDtmb3IoOyhpPWVbb10pIT1udWxsO28rKylpZih0fHx2LmFjY2VwdERhdGEoaSkpe3I9aVt1XSxuPXImJmFbcl07aWYobil7aWYobi5ldmVudHMpZm9yKHMgaW4gbi5ldmVudHMpbFtzXT92LmV2ZW50LnJlbW92ZShpLHMpOnYucmVtb3ZlRXZlbnQoaSxzLG4uaGFuZGxlKTthW3JdJiYoZGVsZXRlIGFbcl0sZj9kZWxldGUgaVt1XTppLnJlbW92ZUF0dHJpYnV0ZT9pLnJlbW92ZUF0dHJpYnV0ZSh1KTppW3VdPW51bGwsdi5kZWxldGVkSWRzLnB1c2gocikpfX19fSksZnVuY3Rpb24oKXt2YXIgZSx0O3YudWFNYXRjaD1mdW5jdGlvbihlKXtlPWUudG9Mb3dlckNhc2UoKTt2YXIgdD0vKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoZSl8fC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyhlKXx8LyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyhlKXx8Lyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoZSl8fGUuaW5kZXhPZihcImNvbXBhdGlibGVcIik8MCYmLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyhlKXx8W107cmV0dXJue2Jyb3dzZXI6dFsxXXx8XCJcIix2ZXJzaW9uOnRbMl18fFwiMFwifX0sZT12LnVhTWF0Y2goby51c2VyQWdlbnQpLHQ9e30sZS5icm93c2VyJiYodFtlLmJyb3dzZXJdPSEwLHQudmVyc2lvbj1lLnZlcnNpb24pLHQuY2hyb21lP3Qud2Via2l0PSEwOnQud2Via2l0JiYodC5zYWZhcmk9ITApLHYuYnJvd3Nlcj10LHYuc3ViPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe3JldHVybiBuZXcgZS5mbi5pbml0KHQsbil9di5leHRlbmQoITAsZSx0aGlzKSxlLnN1cGVyY2xhc3M9dGhpcyxlLmZuPWUucHJvdG90eXBlPXRoaXMoKSxlLmZuLmNvbnN0cnVjdG9yPWUsZS5zdWI9dGhpcy5zdWIsZS5mbi5pbml0PWZ1bmN0aW9uKHIsaSl7cmV0dXJuIGkmJmkgaW5zdGFuY2VvZiB2JiYhKGkgaW5zdGFuY2VvZiBlKSYmKGk9ZShpKSksdi5mbi5pbml0LmNhbGwodGhpcyxyLGksdCl9LGUuZm4uaW5pdC5wcm90b3R5cGU9ZS5mbjt2YXIgdD1lKGkpO3JldHVybiBlfX0oKTt2YXIgRHQsUHQsSHQsQnQ9L2FscGhhXFwoW14pXSpcXCkvaSxqdD0vb3BhY2l0eT0oW14pXSopLyxGdD0vXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC8sSXQ9L14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLHF0PS9ebWFyZ2luLyxSdD1uZXcgUmVnRXhwKFwiXihcIittK1wiKSguKikkXCIsXCJpXCIpLFV0PW5ldyBSZWdFeHAoXCJeKFwiK20rXCIpKD8hcHgpW2EteiVdKyRcIixcImlcIiksenQ9bmV3IFJlZ0V4cChcIl4oWy0rXSk9KFwiK20rXCIpXCIsXCJpXCIpLFd0PXtCT0RZOlwiYmxvY2tcIn0sWHQ9e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix2aXNpYmlsaXR5OlwiaGlkZGVuXCIsZGlzcGxheTpcImJsb2NrXCJ9LFZ0PXtsZXR0ZXJTcGFjaW5nOjAsZm9udFdlaWdodDo0MDB9LCR0PVtcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXSxKdD1bXCJXZWJraXRcIixcIk9cIixcIk1velwiLFwibXNcIl0sS3Q9di5mbi50b2dnbGU7di5mbi5leHRlbmQoe2NzczpmdW5jdGlvbihlLG4pe3JldHVybiB2LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gciE9PXQ/di5zdHlsZShlLG4scik6di5jc3MoZSxuKX0sZSxuLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHNob3c6ZnVuY3Rpb24oKXtyZXR1cm4gWXQodGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gWXQodGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihlLHQpe3ZhciBuPXR5cGVvZiBlPT1cImJvb2xlYW5cIjtyZXR1cm4gdi5pc0Z1bmN0aW9uKGUpJiZ2LmlzRnVuY3Rpb24odCk/S3QuYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMuZWFjaChmdW5jdGlvbigpeyhuP2U6R3QodGhpcykpP3YodGhpcykuc2hvdygpOnYodGhpcykuaGlkZSgpfSl9fSksdi5leHRlbmQoe2Nzc0hvb2tzOntvcGFjaXR5OntnZXQ6ZnVuY3Rpb24oZSx0KXtpZih0KXt2YXIgbj1EdChlLFwib3BhY2l0eVwiKTtyZXR1cm4gbj09PVwiXCI/XCIxXCI6bn19fX0sY3NzTnVtYmVyOntmaWxsT3BhY2l0eTohMCxmb250V2VpZ2h0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e1wiZmxvYXRcIjp2LnN1cHBvcnQuY3NzRmxvYXQ/XCJjc3NGbG9hdFwiOlwic3R5bGVGbG9hdFwifSxzdHlsZTpmdW5jdGlvbihlLG4scixpKXtpZighZXx8ZS5ub2RlVHlwZT09PTN8fGUubm9kZVR5cGU9PT04fHwhZS5zdHlsZSlyZXR1cm47dmFyIHMsbyx1LGE9di5jYW1lbENhc2UobiksZj1lLnN0eWxlO249di5jc3NQcm9wc1thXXx8KHYuY3NzUHJvcHNbYV09UXQoZixhKSksdT12LmNzc0hvb2tzW25dfHx2LmNzc0hvb2tzW2FdO2lmKHI9PT10KXJldHVybiB1JiZcImdldFwiaW4gdSYmKHM9dS5nZXQoZSwhMSxpKSkhPT10P3M6ZltuXTtvPXR5cGVvZiByLG89PT1cInN0cmluZ1wiJiYocz16dC5leGVjKHIpKSYmKHI9KHNbMV0rMSkqc1syXStwYXJzZUZsb2F0KHYuY3NzKGUsbikpLG89XCJudW1iZXJcIik7aWYocj09bnVsbHx8bz09PVwibnVtYmVyXCImJmlzTmFOKHIpKXJldHVybjtvPT09XCJudW1iZXJcIiYmIXYuY3NzTnVtYmVyW2FdJiYocis9XCJweFwiKTtpZighdXx8IShcInNldFwiaW4gdSl8fChyPXUuc2V0KGUscixpKSkhPT10KXRyeXtmW25dPXJ9Y2F0Y2gobCl7fX0sY3NzOmZ1bmN0aW9uKGUsbixyLGkpe3ZhciBzLG8sdSxhPXYuY2FtZWxDYXNlKG4pO3JldHVybiBuPXYuY3NzUHJvcHNbYV18fCh2LmNzc1Byb3BzW2FdPVF0KGUuc3R5bGUsYSkpLHU9di5jc3NIb29rc1tuXXx8di5jc3NIb29rc1thXSx1JiZcImdldFwiaW4gdSYmKHM9dS5nZXQoZSwhMCxpKSkscz09PXQmJihzPUR0KGUsbikpLHM9PT1cIm5vcm1hbFwiJiZuIGluIFZ0JiYocz1WdFtuXSkscnx8aSE9PXQ/KG89cGFyc2VGbG9hdChzKSxyfHx2LmlzTnVtZXJpYyhvKT9vfHwwOnMpOnN9LHN3YXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGkscz17fTtmb3IoaSBpbiB0KXNbaV09ZS5zdHlsZVtpXSxlLnN0eWxlW2ldPXRbaV07cj1uLmNhbGwoZSk7Zm9yKGkgaW4gdCllLnN0eWxlW2ldPXNbaV07cmV0dXJuIHJ9fSksZS5nZXRDb21wdXRlZFN0eWxlP0R0PWZ1bmN0aW9uKHQsbil7dmFyIHIsaSxzLG8sdT1lLmdldENvbXB1dGVkU3R5bGUodCxudWxsKSxhPXQuc3R5bGU7cmV0dXJuIHUmJihyPXUuZ2V0UHJvcGVydHlWYWx1ZShuKXx8dVtuXSxyPT09XCJcIiYmIXYuY29udGFpbnModC5vd25lckRvY3VtZW50LHQpJiYocj12LnN0eWxlKHQsbikpLFV0LnRlc3QocikmJnF0LnRlc3QobikmJihpPWEud2lkdGgscz1hLm1pbldpZHRoLG89YS5tYXhXaWR0aCxhLm1pbldpZHRoPWEubWF4V2lkdGg9YS53aWR0aD1yLHI9dS53aWR0aCxhLndpZHRoPWksYS5taW5XaWR0aD1zLGEubWF4V2lkdGg9bykpLHJ9OmkuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSYmKER0PWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPWUuY3VycmVudFN0eWxlJiZlLmN1cnJlbnRTdHlsZVt0XSxzPWUuc3R5bGU7cmV0dXJuIGk9PW51bGwmJnMmJnNbdF0mJihpPXNbdF0pLFV0LnRlc3QoaSkmJiFGdC50ZXN0KHQpJiYobj1zLmxlZnQscj1lLnJ1bnRpbWVTdHlsZSYmZS5ydW50aW1lU3R5bGUubGVmdCxyJiYoZS5ydW50aW1lU3R5bGUubGVmdD1lLmN1cnJlbnRTdHlsZS5sZWZ0KSxzLmxlZnQ9dD09PVwiZm9udFNpemVcIj9cIjFlbVwiOmksaT1zLnBpeGVsTGVmdCtcInB4XCIscy5sZWZ0PW4sciYmKGUucnVudGltZVN0eWxlLmxlZnQ9cikpLGk9PT1cIlwiP1wiYXV0b1wiOml9KSx2LmVhY2goW1wiaGVpZ2h0XCIsXCJ3aWR0aFwiXSxmdW5jdGlvbihlLHQpe3YuY3NzSG9va3NbdF09e2dldDpmdW5jdGlvbihlLG4scil7aWYobilyZXR1cm4gZS5vZmZzZXRXaWR0aD09PTAmJkl0LnRlc3QoRHQoZSxcImRpc3BsYXlcIikpP3Yuc3dhcChlLFh0LGZ1bmN0aW9uKCl7cmV0dXJuIHRuKGUsdCxyKX0pOnRuKGUsdCxyKX0sc2V0OmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gWnQoZSxuLHI/ZW4oZSx0LHIsdi5zdXBwb3J0LmJveFNpemluZyYmdi5jc3MoZSxcImJveFNpemluZ1wiKT09PVwiYm9yZGVyLWJveFwiKTowKX19fSksdi5zdXBwb3J0Lm9wYWNpdHl8fCh2LmNzc0hvb2tzLm9wYWNpdHk9e2dldDpmdW5jdGlvbihlLHQpe3JldHVybiBqdC50ZXN0KCh0JiZlLmN1cnJlbnRTdHlsZT9lLmN1cnJlbnRTdHlsZS5maWx0ZXI6ZS5zdHlsZS5maWx0ZXIpfHxcIlwiKT8uMDEqcGFyc2VGbG9hdChSZWdFeHAuJDEpK1wiXCI6dD9cIjFcIjpcIlwifSxzZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLnN0eWxlLHI9ZS5jdXJyZW50U3R5bGUsaT12LmlzTnVtZXJpYyh0KT9cImFscGhhKG9wYWNpdHk9XCIrdCoxMDArXCIpXCI6XCJcIixzPXImJnIuZmlsdGVyfHxuLmZpbHRlcnx8XCJcIjtuLnpvb209MTtpZih0Pj0xJiZ2LnRyaW0ocy5yZXBsYWNlKEJ0LFwiXCIpKT09PVwiXCImJm4ucmVtb3ZlQXR0cmlidXRlKXtuLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtpZihyJiYhci5maWx0ZXIpcmV0dXJufW4uZmlsdGVyPUJ0LnRlc3Qocyk/cy5yZXBsYWNlKEJ0LGkpOnMrXCIgXCIraX19KSx2KGZ1bmN0aW9uKCl7di5zdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHR8fCh2LmNzc0hvb2tzLm1hcmdpblJpZ2h0PXtnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdi5zd2FwKGUse2Rpc3BsYXk6XCJpbmxpbmUtYmxvY2tcIn0sZnVuY3Rpb24oKXtpZih0KXJldHVybiBEdChlLFwibWFyZ2luUmlnaHRcIil9KX19KSwhdi5zdXBwb3J0LnBpeGVsUG9zaXRpb24mJnYuZm4ucG9zaXRpb24mJnYuZWFjaChbXCJ0b3BcIixcImxlZnRcIl0sZnVuY3Rpb24oZSx0KXt2LmNzc0hvb2tzW3RdPXtnZXQ6ZnVuY3Rpb24oZSxuKXtpZihuKXt2YXIgcj1EdChlLHQpO3JldHVybiBVdC50ZXN0KHIpP3YoZSkucG9zaXRpb24oKVt0XStcInB4XCI6cn19fX0pfSksdi5leHByJiZ2LmV4cHIuZmlsdGVycyYmKHYuZXhwci5maWx0ZXJzLmhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5vZmZzZXRXaWR0aD09PTAmJmUub2Zmc2V0SGVpZ2h0PT09MHx8IXYuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMmJihlLnN0eWxlJiZlLnN0eWxlLmRpc3BsYXl8fER0KGUsXCJkaXNwbGF5XCIpKT09PVwibm9uZVwifSx2LmV4cHIuZmlsdGVycy52aXNpYmxlPWZ1bmN0aW9uKGUpe3JldHVybiF2LmV4cHIuZmlsdGVycy5oaWRkZW4oZSl9KSx2LmVhY2goe21hcmdpbjpcIlwiLHBhZGRpbmc6XCJcIixib3JkZXI6XCJXaWR0aFwifSxmdW5jdGlvbihlLHQpe3YuY3NzSG9va3NbZSt0XT17ZXhwYW5kOmZ1bmN0aW9uKG4pe3ZhciByLGk9dHlwZW9mIG49PVwic3RyaW5nXCI/bi5zcGxpdChcIiBcIik6W25dLHM9e307Zm9yKHI9MDtyPDQ7cisrKXNbZSskdFtyXSt0XT1pW3JdfHxpW3ItMl18fGlbMF07cmV0dXJuIHN9fSxxdC50ZXN0KGUpfHwodi5jc3NIb29rc1tlK3RdLnNldD1adCl9KTt2YXIgcm49LyUyMC9nLHNuPS9cXFtcXF0kLyxvbj0vXFxyP1xcbi9nLHVuPS9eKD86Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxoaWRkZW58bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaSxhbj0vXig/OnNlbGVjdHx0ZXh0YXJlYSkvaTt2LmZuLmV4dGVuZCh7c2VyaWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHYucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKX0sc2VyaWFsaXplQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50cz92Lm1ha2VBcnJheSh0aGlzLmVsZW1lbnRzKTp0aGlzfSkuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZSYmIXRoaXMuZGlzYWJsZWQmJih0aGlzLmNoZWNrZWR8fGFuLnRlc3QodGhpcy5ub2RlTmFtZSl8fHVuLnRlc3QodGhpcy50eXBlKSl9KS5tYXAoZnVuY3Rpb24oZSx0KXt2YXIgbj12KHRoaXMpLnZhbCgpO3JldHVybiBuPT1udWxsP251bGw6di5pc0FycmF5KG4pP3YubWFwKG4sZnVuY3Rpb24oZSxuKXtyZXR1cm57bmFtZTp0Lm5hbWUsdmFsdWU6ZS5yZXBsYWNlKG9uLFwiXFxyXFxuXCIpfX0pOntuYW1lOnQubmFtZSx2YWx1ZTpuLnJlcGxhY2Uob24sXCJcXHJcXG5cIil9fSkuZ2V0KCl9fSksdi5wYXJhbT1mdW5jdGlvbihlLG4pe3ZhciByLGk9W10scz1mdW5jdGlvbihlLHQpe3Q9di5pc0Z1bmN0aW9uKHQpP3QoKTp0PT1udWxsP1wiXCI6dCxpW2kubGVuZ3RoXT1lbmNvZGVVUklDb21wb25lbnQoZSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHQpfTtuPT09dCYmKG49di5hamF4U2V0dGluZ3MmJnYuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKTtpZih2LmlzQXJyYXkoZSl8fGUuanF1ZXJ5JiYhdi5pc1BsYWluT2JqZWN0KGUpKXYuZWFjaChlLGZ1bmN0aW9uKCl7cyh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihyIGluIGUpZm4ocixlW3JdLG4scyk7cmV0dXJuIGkuam9pbihcIiZcIikucmVwbGFjZShybixcIitcIil9O3ZhciBsbixjbixobj0vIy4qJC8scG49L14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsZG49L14oPzphYm91dHxhcHB8YXBwXFwtc3RvcmFnZXwuK1xcLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLHZuPS9eKD86R0VUfEhFQUQpJC8sbW49L15cXC9cXC8vLGduPS9cXD8vLHluPS88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLGJuPS8oWz8mXSlfPVteJl0qLyx3bj0vXihbXFx3XFwrXFwuXFwtXSs6KSg/OlxcL1xcLyhbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxFbj12LmZuLmxvYWQsU249e30seG49e30sVG49W1wiKi9cIl0rW1wiKlwiXTt0cnl7Y249cy5ocmVmfWNhdGNoKE5uKXtjbj1pLmNyZWF0ZUVsZW1lbnQoXCJhXCIpLGNuLmhyZWY9XCJcIixjbj1jbi5ocmVmfWxuPXduLmV4ZWMoY24udG9Mb3dlckNhc2UoKSl8fFtdLHYuZm4ubG9hZD1mdW5jdGlvbihlLG4scil7aWYodHlwZW9mIGUhPVwic3RyaW5nXCImJkVuKXJldHVybiBFbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoIXRoaXMubGVuZ3RoKXJldHVybiB0aGlzO3ZhciBpLHMsbyx1PXRoaXMsYT1lLmluZGV4T2YoXCIgXCIpO3JldHVybiBhPj0wJiYoaT1lLnNsaWNlKGEsZS5sZW5ndGgpLGU9ZS5zbGljZSgwLGEpKSx2LmlzRnVuY3Rpb24obik/KHI9bixuPXQpOm4mJnR5cGVvZiBuPT1cIm9iamVjdFwiJiYocz1cIlBPU1RcIiksdi5hamF4KHt1cmw6ZSx0eXBlOnMsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTpuLGNvbXBsZXRlOmZ1bmN0aW9uKGUsdCl7ciYmdS5lYWNoKHIsb3x8W2UucmVzcG9uc2VUZXh0LHQsZV0pfX0pLmRvbmUoZnVuY3Rpb24oZSl7bz1hcmd1bWVudHMsdS5odG1sKGk/dihcIjxkaXY+XCIpLmFwcGVuZChlLnJlcGxhY2UoeW4sXCJcIikpLmZpbmQoaSk6ZSl9KSx0aGlzfSx2LmVhY2goXCJhamF4U3RhcnQgYWpheFN0b3AgYWpheENvbXBsZXRlIGFqYXhFcnJvciBhamF4U3VjY2VzcyBhamF4U2VuZFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe3YuZm5bdF09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub24odCxlKX19KSx2LmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGUsbil7dltuXT1mdW5jdGlvbihlLHIsaSxzKXtyZXR1cm4gdi5pc0Z1bmN0aW9uKHIpJiYocz1zfHxpLGk9cixyPXQpLHYuYWpheCh7dHlwZTpuLHVybDplLGRhdGE6cixzdWNjZXNzOmksZGF0YVR5cGU6c30pfX0pLHYuZXh0ZW5kKHtnZXRTY3JpcHQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdi5nZXQoZSx0LG4sXCJzY3JpcHRcIil9LGdldEpTT046ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2LmdldChlLHQsbixcImpzb25cIil9LGFqYXhTZXR1cDpmdW5jdGlvbihlLHQpe3JldHVybiB0P0xuKGUsdi5hamF4U2V0dGluZ3MpOih0PWUsZT12LmFqYXhTZXR0aW5ncyksTG4oZSx0KSxlfSxhamF4U2V0dGluZ3M6e3VybDpjbixpc0xvY2FsOmRuLnRlc3QobG5bMV0pLGdsb2JhbDohMCx0eXBlOlwiR0VUXCIsY29udGVudFR5cGU6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixwcm9jZXNzRGF0YTohMCxhc3luYzohMCxhY2NlcHRzOnt4bWw6XCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsaHRtbDpcInRleHQvaHRtbFwiLHRleHQ6XCJ0ZXh0L3BsYWluXCIsanNvbjpcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiLFwiKlwiOlRufSxjb250ZW50czp7eG1sOi94bWwvLGh0bWw6L2h0bWwvLGpzb246L2pzb24vfSxyZXNwb25zZUZpZWxkczp7eG1sOlwicmVzcG9uc2VYTUxcIix0ZXh0OlwicmVzcG9uc2VUZXh0XCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6ZS5TdHJpbmcsXCJ0ZXh0IGh0bWxcIjohMCxcInRleHQganNvblwiOnYucGFyc2VKU09OLFwidGV4dCB4bWxcIjp2LnBhcnNlWE1MfSxmbGF0T3B0aW9uczp7Y29udGV4dDohMCx1cmw6ITB9fSxhamF4UHJlZmlsdGVyOkNuKFNuKSxhamF4VHJhbnNwb3J0OkNuKHhuKSxhamF4OmZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gVChlLG4scyxhKXt2YXIgbCx5LGIsdyxTLFQ9bjtpZihFPT09MilyZXR1cm47RT0yLHUmJmNsZWFyVGltZW91dCh1KSxvPXQsaT1hfHxcIlwiLHgucmVhZHlTdGF0ZT1lPjA/NDowLHMmJih3PUFuKGMseCxzKSk7aWYoZT49MjAwJiZlPDMwMHx8ZT09PTMwNCljLmlmTW9kaWZpZWQmJihTPXguZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpLFMmJih2Lmxhc3RNb2RpZmllZFtyXT1TKSxTPXguZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpLFMmJih2LmV0YWdbcl09UykpLGU9PT0zMDQ/KFQ9XCJub3Rtb2RpZmllZFwiLGw9ITApOihsPU9uKGMsdyksVD1sLnN0YXRlLHk9bC5kYXRhLGI9bC5lcnJvcixsPSFiKTtlbHNle2I9VDtpZighVHx8ZSlUPVwiZXJyb3JcIixlPDAmJihlPTApfXguc3RhdHVzPWUseC5zdGF0dXNUZXh0PShufHxUKStcIlwiLGw/ZC5yZXNvbHZlV2l0aChoLFt5LFQseF0pOmQucmVqZWN0V2l0aChoLFt4LFQsYl0pLHguc3RhdHVzQ29kZShnKSxnPXQsZiYmcC50cmlnZ2VyKFwiYWpheFwiKyhsP1wiU3VjY2Vzc1wiOlwiRXJyb3JcIiksW3gsYyxsP3k6Yl0pLG0uZmlyZVdpdGgoaCxbeCxUXSksZiYmKHAudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFt4LGNdKSwtLXYuYWN0aXZlfHx2LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSl9dHlwZW9mIGU9PVwib2JqZWN0XCImJihuPWUsZT10KSxuPW58fHt9O3ZhciByLGkscyxvLHUsYSxmLGwsYz12LmFqYXhTZXR1cCh7fSxuKSxoPWMuY29udGV4dHx8YyxwPWghPT1jJiYoaC5ub2RlVHlwZXx8aCBpbnN0YW5jZW9mIHYpP3YoaCk6di5ldmVudCxkPXYuRGVmZXJyZWQoKSxtPXYuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksZz1jLnN0YXR1c0NvZGV8fHt9LGI9e30sdz17fSxFPTAsUz1cImNhbmNlbGVkXCIseD17cmVhZHlTdGF0ZTowLHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oZSx0KXtpZighRSl7dmFyIG49ZS50b0xvd2VyQ2FzZSgpO2U9d1tuXT13W25dfHxlLGJbZV09dH1yZXR1cm4gdGhpc30sZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIEU9PT0yP2k6bnVsbH0sZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oZSl7dmFyIG47aWYoRT09PTIpe2lmKCFzKXtzPXt9O3doaWxlKG49cG4uZXhlYyhpKSlzW25bMV0udG9Mb3dlckNhc2UoKV09blsyXX1uPXNbZS50b0xvd2VyQ2FzZSgpXX1yZXR1cm4gbj09PXQ/bnVsbDpufSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGUpe3JldHVybiBFfHwoYy5taW1lVHlwZT1lKSx0aGlzfSxhYm9ydDpmdW5jdGlvbihlKXtyZXR1cm4gZT1lfHxTLG8mJm8uYWJvcnQoZSksVCgwLGUpLHRoaXN9fTtkLnByb21pc2UoeCkseC5zdWNjZXNzPXguZG9uZSx4LmVycm9yPXguZmFpbCx4LmNvbXBsZXRlPW0uYWRkLHguc3RhdHVzQ29kZT1mdW5jdGlvbihlKXtpZihlKXt2YXIgdDtpZihFPDIpZm9yKHQgaW4gZSlnW3RdPVtnW3RdLGVbdF1dO2Vsc2UgdD1lW3guc3RhdHVzXSx4LmFsd2F5cyh0KX1yZXR1cm4gdGhpc30sYy51cmw9KChlfHxjLnVybCkrXCJcIikucmVwbGFjZShobixcIlwiKS5yZXBsYWNlKG1uLGxuWzFdK1wiLy9cIiksYy5kYXRhVHlwZXM9di50cmltKGMuZGF0YVR5cGV8fFwiKlwiKS50b0xvd2VyQ2FzZSgpLnNwbGl0KHkpLGMuY3Jvc3NEb21haW49PW51bGwmJihhPXduLmV4ZWMoYy51cmwudG9Mb3dlckNhc2UoKSksYy5jcm9zc0RvbWFpbj0hKCFhfHxhWzFdPT09bG5bMV0mJmFbMl09PT1sblsyXSYmKGFbM118fChhWzFdPT09XCJodHRwOlwiPzgwOjQ0MykpPT0obG5bM118fChsblsxXT09PVwiaHR0cDpcIj84MDo0NDMpKSkpLGMuZGF0YSYmYy5wcm9jZXNzRGF0YSYmdHlwZW9mIGMuZGF0YSE9XCJzdHJpbmdcIiYmKGMuZGF0YT12LnBhcmFtKGMuZGF0YSxjLnRyYWRpdGlvbmFsKSksa24oU24sYyxuLHgpO2lmKEU9PT0yKXJldHVybiB4O2Y9Yy5nbG9iYWwsYy50eXBlPWMudHlwZS50b1VwcGVyQ2FzZSgpLGMuaGFzQ29udGVudD0hdm4udGVzdChjLnR5cGUpLGYmJnYuYWN0aXZlKys9PT0wJiZ2LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7aWYoIWMuaGFzQ29udGVudCl7Yy5kYXRhJiYoYy51cmwrPShnbi50ZXN0KGMudXJsKT9cIiZcIjpcIj9cIikrYy5kYXRhLGRlbGV0ZSBjLmRhdGEpLHI9Yy51cmw7aWYoYy5jYWNoZT09PSExKXt2YXIgTj12Lm5vdygpLEM9Yy51cmwucmVwbGFjZShibixcIiQxXz1cIitOKTtjLnVybD1DKyhDPT09Yy51cmw/KGduLnRlc3QoYy51cmwpP1wiJlwiOlwiP1wiKStcIl89XCIrTjpcIlwiKX19KGMuZGF0YSYmYy5oYXNDb250ZW50JiZjLmNvbnRlbnRUeXBlIT09ITF8fG4uY29udGVudFR5cGUpJiZ4LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixjLmNvbnRlbnRUeXBlKSxjLmlmTW9kaWZpZWQmJihyPXJ8fGMudXJsLHYubGFzdE1vZGlmaWVkW3JdJiZ4LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLHYubGFzdE1vZGlmaWVkW3JdKSx2LmV0YWdbcl0mJnguc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIix2LmV0YWdbcl0pKSx4LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixjLmRhdGFUeXBlc1swXSYmYy5hY2NlcHRzW2MuZGF0YVR5cGVzWzBdXT9jLmFjY2VwdHNbYy5kYXRhVHlwZXNbMF1dKyhjLmRhdGFUeXBlc1swXSE9PVwiKlwiP1wiLCBcIitUbitcIjsgcT0wLjAxXCI6XCJcIik6Yy5hY2NlcHRzW1wiKlwiXSk7Zm9yKGwgaW4gYy5oZWFkZXJzKXguc2V0UmVxdWVzdEhlYWRlcihsLGMuaGVhZGVyc1tsXSk7aWYoIWMuYmVmb3JlU2VuZHx8Yy5iZWZvcmVTZW5kLmNhbGwoaCx4LGMpIT09ITEmJkUhPT0yKXtTPVwiYWJvcnRcIjtmb3IobCBpbntzdWNjZXNzOjEsZXJyb3I6MSxjb21wbGV0ZToxfSl4W2xdKGNbbF0pO289a24oeG4sYyxuLHgpO2lmKCFvKVQoLTEsXCJObyBUcmFuc3BvcnRcIik7ZWxzZXt4LnJlYWR5U3RhdGU9MSxmJiZwLnRyaWdnZXIoXCJhamF4U2VuZFwiLFt4LGNdKSxjLmFzeW5jJiZjLnRpbWVvdXQ+MCYmKHU9c2V0VGltZW91dChmdW5jdGlvbigpe3guYWJvcnQoXCJ0aW1lb3V0XCIpfSxjLnRpbWVvdXQpKTt0cnl7RT0xLG8uc2VuZChiLFQpfWNhdGNoKGspe2lmKCEoRTwyKSl0aHJvdyBrO1QoLTEsayl9fXJldHVybiB4fXJldHVybiB4LmFib3J0KCl9LGFjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9fSk7dmFyIE1uPVtdLF9uPS9cXD8vLERuPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy8sUG49di5ub3coKTt2LmFqYXhTZXR1cCh7anNvbnA6XCJjYWxsYmFja1wiLGpzb25wQ2FsbGJhY2s6ZnVuY3Rpb24oKXt2YXIgZT1Nbi5wb3AoKXx8di5leHBhbmRvK1wiX1wiK1BuKys7cmV0dXJuIHRoaXNbZV09ITAsZX19KSx2LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsZnVuY3Rpb24obixyLGkpe3ZhciBzLG8sdSxhPW4uZGF0YSxmPW4udXJsLGw9bi5qc29ucCE9PSExLGM9bCYmRG4udGVzdChmKSxoPWwmJiFjJiZ0eXBlb2YgYT09XCJzdHJpbmdcIiYmIShuLmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiZEbi50ZXN0KGEpO2lmKG4uZGF0YVR5cGVzWzBdPT09XCJqc29ucFwifHxjfHxoKXJldHVybiBzPW4uanNvbnBDYWxsYmFjaz12LmlzRnVuY3Rpb24obi5qc29ucENhbGxiYWNrKT9uLmpzb25wQ2FsbGJhY2soKTpuLmpzb25wQ2FsbGJhY2ssbz1lW3NdLGM/bi51cmw9Zi5yZXBsYWNlKERuLFwiJDFcIitzKTpoP24uZGF0YT1hLnJlcGxhY2UoRG4sXCIkMVwiK3MpOmwmJihuLnVybCs9KF9uLnRlc3QoZik/XCImXCI6XCI/XCIpK24uanNvbnArXCI9XCIrcyksbi5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4gdXx8di5lcnJvcihzK1wiIHdhcyBub3QgY2FsbGVkXCIpLHVbMF19LG4uZGF0YVR5cGVzWzBdPVwianNvblwiLGVbc109ZnVuY3Rpb24oKXt1PWFyZ3VtZW50c30saS5hbHdheXMoZnVuY3Rpb24oKXtlW3NdPW8sbltzXSYmKG4uanNvbnBDYWxsYmFjaz1yLmpzb25wQ2FsbGJhY2ssTW4ucHVzaChzKSksdSYmdi5pc0Z1bmN0aW9uKG8pJiZvKHVbMF0pLHU9bz10fSksXCJzY3JpcHRcIn0pLHYuYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi9qYXZhc2NyaXB0fGVjbWFzY3JpcHQvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZ2xvYmFsRXZhbChlKSxlfX19KSx2LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtlLmNhY2hlPT09dCYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIixlLmdsb2JhbD0hMSl9KSx2LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtpZihlLmNyb3NzRG9tYWluKXt2YXIgbixyPWkuaGVhZHx8aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF18fGkuZG9jdW1lbnRFbGVtZW50O3JldHVybntzZW5kOmZ1bmN0aW9uKHMsbyl7bj1pLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksbi5hc3luYz1cImFzeW5jXCIsZS5zY3JpcHRDaGFyc2V0JiYobi5jaGFyc2V0PWUuc2NyaXB0Q2hhcnNldCksbi5zcmM9ZS51cmwsbi5vbmxvYWQ9bi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oZSxpKXtpZihpfHwhbi5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KG4ucmVhZHlTdGF0ZSkpbi5vbmxvYWQ9bi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxyJiZuLnBhcmVudE5vZGUmJnIucmVtb3ZlQ2hpbGQobiksbj10LGl8fG8oMjAwLFwic3VjY2Vzc1wiKX0sci5pbnNlcnRCZWZvcmUobixyLmZpcnN0Q2hpbGQpfSxhYm9ydDpmdW5jdGlvbigpe24mJm4ub25sb2FkKDAsMSl9fX19KTt2YXIgSG4sQm49ZS5BY3RpdmVYT2JqZWN0P2Z1bmN0aW9uKCl7Zm9yKHZhciBlIGluIEhuKUhuW2VdKDAsMSl9OiExLGpuPTA7di5hamF4U2V0dGluZ3MueGhyPWUuQWN0aXZlWE9iamVjdD9mdW5jdGlvbigpe3JldHVybiF0aGlzLmlzTG9jYWwmJkZuKCl8fEluKCl9OkZuLGZ1bmN0aW9uKGUpe3YuZXh0ZW5kKHYuc3VwcG9ydCx7YWpheDohIWUsY29yczohIWUmJlwid2l0aENyZWRlbnRpYWxzXCJpbiBlfSl9KHYuYWpheFNldHRpbmdzLnhocigpKSx2LnN1cHBvcnQuYWpheCYmdi5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKG4pe2lmKCFuLmNyb3NzRG9tYWlufHx2LnN1cHBvcnQuY29ycyl7dmFyIHI7cmV0dXJue3NlbmQ6ZnVuY3Rpb24oaSxzKXt2YXIgbyx1LGE9bi54aHIoKTtuLnVzZXJuYW1lP2Eub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyxuLnVzZXJuYW1lLG4ucGFzc3dvcmQpOmEub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyk7aWYobi54aHJGaWVsZHMpZm9yKHUgaW4gbi54aHJGaWVsZHMpYVt1XT1uLnhockZpZWxkc1t1XTtuLm1pbWVUeXBlJiZhLm92ZXJyaWRlTWltZVR5cGUmJmEub3ZlcnJpZGVNaW1lVHlwZShuLm1pbWVUeXBlKSwhbi5jcm9zc0RvbWFpbiYmIWlbXCJYLVJlcXVlc3RlZC1XaXRoXCJdJiYoaVtcIlgtUmVxdWVzdGVkLVdpdGhcIl09XCJYTUxIdHRwUmVxdWVzdFwiKTt0cnl7Zm9yKHUgaW4gaSlhLnNldFJlcXVlc3RIZWFkZXIodSxpW3VdKX1jYXRjaChmKXt9YS5zZW5kKG4uaGFzQ29udGVudCYmbi5kYXRhfHxudWxsKSxyPWZ1bmN0aW9uKGUsaSl7dmFyIHUsZixsLGMsaDt0cnl7aWYociYmKGl8fGEucmVhZHlTdGF0ZT09PTQpKXtyPXQsbyYmKGEub25yZWFkeXN0YXRlY2hhbmdlPXYubm9vcCxCbiYmZGVsZXRlIEhuW29dKTtpZihpKWEucmVhZHlTdGF0ZSE9PTQmJmEuYWJvcnQoKTtlbHNle3U9YS5zdGF0dXMsbD1hLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLGM9e30saD1hLnJlc3BvbnNlWE1MLGgmJmguZG9jdW1lbnRFbGVtZW50JiYoYy54bWw9aCk7dHJ5e2MudGV4dD1hLnJlc3BvbnNlVGV4dH1jYXRjaChwKXt9dHJ5e2Y9YS5zdGF0dXNUZXh0fWNhdGNoKHApe2Y9XCJcIn0hdSYmbi5pc0xvY2FsJiYhbi5jcm9zc0RvbWFpbj91PWMudGV4dD8yMDA6NDA0OnU9PT0xMjIzJiYodT0yMDQpfX19Y2F0Y2goZCl7aXx8cygtMSxkKX1jJiZzKHUsZixjLGwpfSxuLmFzeW5jP2EucmVhZHlTdGF0ZT09PTQ/c2V0VGltZW91dChyLDApOihvPSsram4sQm4mJihIbnx8KEhuPXt9LHYoZSkudW5sb2FkKEJuKSksSG5bb109ciksYS5vbnJlYWR5c3RhdGVjaGFuZ2U9cik6cigpfSxhYm9ydDpmdW5jdGlvbigpe3ImJnIoMCwxKX19fX0pO3ZhciBxbixSbixVbj0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sem49bmV3IFJlZ0V4cChcIl4oPzooWy0rXSk9fCkoXCIrbStcIikoW2EteiVdKikkXCIsXCJpXCIpLFduPS9xdWV1ZUhvb2tzJC8sWG49W0duXSxWbj17XCIqXCI6W2Z1bmN0aW9uKGUsdCl7dmFyIG4scixpPXRoaXMuY3JlYXRlVHdlZW4oZSx0KSxzPXpuLmV4ZWModCksbz1pLmN1cigpLHU9K298fDAsYT0xLGY9MjA7aWYocyl7bj0rc1syXSxyPXNbM118fCh2LmNzc051bWJlcltlXT9cIlwiOlwicHhcIik7aWYociE9PVwicHhcIiYmdSl7dT12LmNzcyhpLmVsZW0sZSwhMCl8fG58fDE7ZG8gYT1hfHxcIi41XCIsdS89YSx2LnN0eWxlKGkuZWxlbSxlLHUrcik7d2hpbGUoYSE9PShhPWkuY3VyKCkvbykmJmEhPT0xJiYtLWYpfWkudW5pdD1yLGkuc3RhcnQ9dSxpLmVuZD1zWzFdP3UrKHNbMV0rMSkqbjpufXJldHVybiBpfV19O3YuQW5pbWF0aW9uPXYuZXh0ZW5kKEtuLHt0d2VlbmVyOmZ1bmN0aW9uKGUsdCl7di5pc0Z1bmN0aW9uKGUpPyh0PWUsZT1bXCIqXCJdKTplPWUuc3BsaXQoXCIgXCIpO3ZhciBuLHI9MCxpPWUubGVuZ3RoO2Zvcig7cjxpO3IrKyluPWVbcl0sVm5bbl09Vm5bbl18fFtdLFZuW25dLnVuc2hpZnQodCl9LHByZWZpbHRlcjpmdW5jdGlvbihlLHQpe3Q/WG4udW5zaGlmdChlKTpYbi5wdXNoKGUpfX0pLHYuVHdlZW49WW4sWW4ucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpZbixpbml0OmZ1bmN0aW9uKGUsdCxuLHIsaSxzKXt0aGlzLmVsZW09ZSx0aGlzLnByb3A9bix0aGlzLmVhc2luZz1pfHxcInN3aW5nXCIsdGhpcy5vcHRpb25zPXQsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPXIsdGhpcy51bml0PXN8fCh2LmNzc051bWJlcltuXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBlPVluLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBlJiZlLmdldD9lLmdldCh0aGlzKTpZbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oZSl7dmFyIHQsbj1Zbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uP3RoaXMucG9zPXQ9di5lYXNpbmdbdGhpcy5lYXNpbmddKGUsdGhpcy5vcHRpb25zLmR1cmF0aW9uKmUsMCwxLHRoaXMub3B0aW9ucy5kdXJhdGlvbik6dGhpcy5wb3M9dD1lLHRoaXMubm93PSh0aGlzLmVuZC10aGlzLnN0YXJ0KSp0K3RoaXMuc3RhcnQsdGhpcy5vcHRpb25zLnN0ZXAmJnRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLHRoaXMubm93LHRoaXMpLG4mJm4uc2V0P24uc2V0KHRoaXMpOlluLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyksdGhpc319LFluLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZT1Zbi5wcm90b3R5cGUsWW4ucHJvcEhvb2tzPXtfZGVmYXVsdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBlLmVsZW1bZS5wcm9wXT09bnVsbHx8ISFlLmVsZW0uc3R5bGUmJmUuZWxlbS5zdHlsZVtlLnByb3BdIT1udWxsPyh0PXYuY3NzKGUuZWxlbSxlLnByb3AsITEsXCJcIiksIXR8fHQ9PT1cImF1dG9cIj8wOnQpOmUuZWxlbVtlLnByb3BdfSxzZXQ6ZnVuY3Rpb24oZSl7di5meC5zdGVwW2UucHJvcF0/di5meC5zdGVwW2UucHJvcF0oZSk6ZS5lbGVtLnN0eWxlJiYoZS5lbGVtLnN0eWxlW3YuY3NzUHJvcHNbZS5wcm9wXV0hPW51bGx8fHYuY3NzSG9va3NbZS5wcm9wXSk/di5zdHlsZShlLmVsZW0sZS5wcm9wLGUubm93K2UudW5pdCk6ZS5lbGVtW2UucHJvcF09ZS5ub3d9fX0sWW4ucHJvcEhvb2tzLnNjcm9sbFRvcD1Zbi5wcm9wSG9va3Muc2Nyb2xsTGVmdD17c2V0OmZ1bmN0aW9uKGUpe2UuZWxlbS5ub2RlVHlwZSYmZS5lbGVtLnBhcmVudE5vZGUmJihlLmVsZW1bZS5wcm9wXT1lLm5vdyl9fSx2LmVhY2goW1widG9nZ2xlXCIsXCJzaG93XCIsXCJoaWRlXCJdLGZ1bmN0aW9uKGUsdCl7dmFyIG49di5mblt0XTt2LmZuW3RdPWZ1bmN0aW9uKHIsaSxzKXtyZXR1cm4gcj09bnVsbHx8dHlwZW9mIHI9PVwiYm9vbGVhblwifHwhZSYmdi5pc0Z1bmN0aW9uKHIpJiZ2LmlzRnVuY3Rpb24oaSk/bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dGhpcy5hbmltYXRlKFpuKHQsITApLHIsaSxzKX19KSx2LmZuLmV4dGVuZCh7ZmFkZVRvOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLmZpbHRlcihHdCkuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OnR9LGUsbixyKX0sYW5pbWF0ZTpmdW5jdGlvbihlLHQsbixyKXt2YXIgaT12LmlzRW1wdHlPYmplY3QoZSkscz12LnNwZWVkKHQsbixyKSxvPWZ1bmN0aW9uKCl7dmFyIHQ9S24odGhpcyx2LmV4dGVuZCh7fSxlKSxzKTtpJiZ0LnN0b3AoITApfTtyZXR1cm4gaXx8cy5xdWV1ZT09PSExP3RoaXMuZWFjaChvKTp0aGlzLnF1ZXVlKHMucXVldWUsbyl9LHN0b3A6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RvcDtkZWxldGUgZS5zdG9wLHQocil9O3JldHVybiB0eXBlb2YgZSE9XCJzdHJpbmdcIiYmKHI9bixuPWUsZT10KSxuJiZlIT09ITEmJnRoaXMucXVldWUoZXx8XCJmeFwiLFtdKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD0hMCxuPWUhPW51bGwmJmUrXCJxdWV1ZUhvb2tzXCIscz12LnRpbWVycyxvPXYuX2RhdGEodGhpcyk7aWYobilvW25dJiZvW25dLnN0b3AmJmkob1tuXSk7ZWxzZSBmb3IobiBpbiBvKW9bbl0mJm9bbl0uc3RvcCYmV24udGVzdChuKSYmaShvW25dKTtmb3Iobj1zLmxlbmd0aDtuLS07KXNbbl0uZWxlbT09PXRoaXMmJihlPT1udWxsfHxzW25dLnF1ZXVlPT09ZSkmJihzW25dLmFuaW0uc3RvcChyKSx0PSExLHMuc3BsaWNlKG4sMSkpOyh0fHwhcikmJnYuZGVxdWV1ZSh0aGlzLGUpfSl9fSksdi5lYWNoKHtzbGlkZURvd246Wm4oXCJzaG93XCIpLHNsaWRlVXA6Wm4oXCJoaWRlXCIpLHNsaWRlVG9nZ2xlOlpuKFwidG9nZ2xlXCIpLGZhZGVJbjp7b3BhY2l0eTpcInNob3dcIn0sZmFkZU91dDp7b3BhY2l0eTpcImhpZGVcIn0sZmFkZVRvZ2dsZTp7b3BhY2l0eTpcInRvZ2dsZVwifX0sZnVuY3Rpb24oZSx0KXt2LmZuW2VdPWZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdGhpcy5hbmltYXRlKHQsZSxuLHIpfX0pLHYuc3BlZWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUmJnR5cGVvZiBlPT1cIm9iamVjdFwiP3YuZXh0ZW5kKHt9LGUpOntjb21wbGV0ZTpufHwhbiYmdHx8di5pc0Z1bmN0aW9uKGUpJiZlLGR1cmF0aW9uOmUsZWFzaW5nOm4mJnR8fHQmJiF2LmlzRnVuY3Rpb24odCkmJnR9O3IuZHVyYXRpb249di5meC5vZmY/MDp0eXBlb2Ygci5kdXJhdGlvbj09XCJudW1iZXJcIj9yLmR1cmF0aW9uOnIuZHVyYXRpb24gaW4gdi5meC5zcGVlZHM/di5meC5zcGVlZHNbci5kdXJhdGlvbl06di5meC5zcGVlZHMuX2RlZmF1bHQ7aWYoci5xdWV1ZT09bnVsbHx8ci5xdWV1ZT09PSEwKXIucXVldWU9XCJmeFwiO3JldHVybiByLm9sZD1yLmNvbXBsZXRlLHIuY29tcGxldGU9ZnVuY3Rpb24oKXt2LmlzRnVuY3Rpb24oci5vbGQpJiZyLm9sZC5jYWxsKHRoaXMpLHIucXVldWUmJnYuZGVxdWV1ZSh0aGlzLHIucXVldWUpfSxyfSx2LmVhc2luZz17bGluZWFyOmZ1bmN0aW9uKGUpe3JldHVybiBlfSxzd2luZzpmdW5jdGlvbihlKXtyZXR1cm4uNS1NYXRoLmNvcyhlKk1hdGguUEkpLzJ9fSx2LnRpbWVycz1bXSx2LmZ4PVluLnByb3RvdHlwZS5pbml0LHYuZngudGljaz1mdW5jdGlvbigpe3ZhciBlLG49di50aW1lcnMscj0wO3FuPXYubm93KCk7Zm9yKDtyPG4ubGVuZ3RoO3IrKyllPW5bcl0sIWUoKSYmbltyXT09PWUmJm4uc3BsaWNlKHItLSwxKTtuLmxlbmd0aHx8di5meC5zdG9wKCkscW49dH0sdi5meC50aW1lcj1mdW5jdGlvbihlKXtlKCkmJnYudGltZXJzLnB1c2goZSkmJiFSbiYmKFJuPXNldEludGVydmFsKHYuZngudGljayx2LmZ4LmludGVydmFsKSl9LHYuZnguaW50ZXJ2YWw9MTMsdi5meC5zdG9wPWZ1bmN0aW9uKCl7Y2xlYXJJbnRlcnZhbChSbiksUm49bnVsbH0sdi5meC5zcGVlZHM9e3Nsb3c6NjAwLGZhc3Q6MjAwLF9kZWZhdWx0OjQwMH0sdi5meC5zdGVwPXt9LHYuZXhwciYmdi5leHByLmZpbHRlcnMmJih2LmV4cHIuZmlsdGVycy5hbmltYXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gdi5ncmVwKHYudGltZXJzLGZ1bmN0aW9uKHQpe3JldHVybiBlPT09dC5lbGVtfSkubGVuZ3RofSk7dmFyIGVyPS9eKD86Ym9keXxodG1sKSQvaTt2LmZuLm9mZnNldD1mdW5jdGlvbihlKXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiBlPT09dD90aGlzOnRoaXMuZWFjaChmdW5jdGlvbih0KXt2Lm9mZnNldC5zZXRPZmZzZXQodGhpcyxlLHQpfSk7dmFyIG4scixpLHMsbyx1LGEsZj17dG9wOjAsbGVmdDowfSxsPXRoaXNbMF0sYz1sJiZsLm93bmVyRG9jdW1lbnQ7aWYoIWMpcmV0dXJuO3JldHVybihyPWMuYm9keSk9PT1sP3Yub2Zmc2V0LmJvZHlPZmZzZXQobCk6KG49Yy5kb2N1bWVudEVsZW1lbnQsdi5jb250YWlucyhuLGwpPyh0eXBlb2YgbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QhPVwidW5kZWZpbmVkXCImJihmPWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLGk9dHIoYykscz1uLmNsaWVudFRvcHx8ci5jbGllbnRUb3B8fDAsbz1uLmNsaWVudExlZnR8fHIuY2xpZW50TGVmdHx8MCx1PWkucGFnZVlPZmZzZXR8fG4uc2Nyb2xsVG9wLGE9aS5wYWdlWE9mZnNldHx8bi5zY3JvbGxMZWZ0LHt0b3A6Zi50b3ArdS1zLGxlZnQ6Zi5sZWZ0K2Etb30pOmYpfSx2Lm9mZnNldD17Ym9keU9mZnNldDpmdW5jdGlvbihlKXt2YXIgdD1lLm9mZnNldFRvcCxuPWUub2Zmc2V0TGVmdDtyZXR1cm4gdi5zdXBwb3J0LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0JiYodCs9cGFyc2VGbG9hdCh2LmNzcyhlLFwibWFyZ2luVG9wXCIpKXx8MCxuKz1wYXJzZUZsb2F0KHYuY3NzKGUsXCJtYXJnaW5MZWZ0XCIpKXx8MCkse3RvcDp0LGxlZnQ6bn19LHNldE9mZnNldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9di5jc3MoZSxcInBvc2l0aW9uXCIpO3I9PT1cInN0YXRpY1wiJiYoZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpO3ZhciBpPXYoZSkscz1pLm9mZnNldCgpLG89di5jc3MoZSxcInRvcFwiKSx1PXYuY3NzKGUsXCJsZWZ0XCIpLGE9KHI9PT1cImFic29sdXRlXCJ8fHI9PT1cImZpeGVkXCIpJiZ2LmluQXJyYXkoXCJhdXRvXCIsW28sdV0pPi0xLGY9e30sbD17fSxjLGg7YT8obD1pLnBvc2l0aW9uKCksYz1sLnRvcCxoPWwubGVmdCk6KGM9cGFyc2VGbG9hdChvKXx8MCxoPXBhcnNlRmxvYXQodSl8fDApLHYuaXNGdW5jdGlvbih0KSYmKHQ9dC5jYWxsKGUsbixzKSksdC50b3AhPW51bGwmJihmLnRvcD10LnRvcC1zLnRvcCtjKSx0LmxlZnQhPW51bGwmJihmLmxlZnQ9dC5sZWZ0LXMubGVmdCtoKSxcInVzaW5nXCJpbiB0P3QudXNpbmcuY2FsbChlLGYpOmkuY3NzKGYpfX0sdi5mbi5leHRlbmQoe3Bvc2l0aW9uOmZ1bmN0aW9uKCl7aWYoIXRoaXNbMF0pcmV0dXJuO3ZhciBlPXRoaXNbMF0sdD10aGlzLm9mZnNldFBhcmVudCgpLG49dGhpcy5vZmZzZXQoKSxyPWVyLnRlc3QodFswXS5ub2RlTmFtZSk/e3RvcDowLGxlZnQ6MH06dC5vZmZzZXQoKTtyZXR1cm4gbi50b3AtPXBhcnNlRmxvYXQodi5jc3MoZSxcIm1hcmdpblRvcFwiKSl8fDAsbi5sZWZ0LT1wYXJzZUZsb2F0KHYuY3NzKGUsXCJtYXJnaW5MZWZ0XCIpKXx8MCxyLnRvcCs9cGFyc2VGbG9hdCh2LmNzcyh0WzBdLFwiYm9yZGVyVG9wV2lkdGhcIikpfHwwLHIubGVmdCs9cGFyc2VGbG9hdCh2LmNzcyh0WzBdLFwiYm9yZGVyTGVmdFdpZHRoXCIpKXx8MCx7dG9wOm4udG9wLXIudG9wLGxlZnQ6bi5sZWZ0LXIubGVmdH19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXMub2Zmc2V0UGFyZW50fHxpLmJvZHk7d2hpbGUoZSYmIWVyLnRlc3QoZS5ub2RlTmFtZSkmJnYuY3NzKGUsXCJwb3NpdGlvblwiKT09PVwic3RhdGljXCIpZT1lLm9mZnNldFBhcmVudDtyZXR1cm4gZXx8aS5ib2R5fSl9fSksdi5lYWNoKHtzY3JvbGxMZWZ0OlwicGFnZVhPZmZzZXRcIixzY3JvbGxUb3A6XCJwYWdlWU9mZnNldFwifSxmdW5jdGlvbihlLG4pe3ZhciByPS9ZLy50ZXN0KG4pO3YuZm5bZV09ZnVuY3Rpb24oaSl7cmV0dXJuIHYuYWNjZXNzKHRoaXMsZnVuY3Rpb24oZSxpLHMpe3ZhciBvPXRyKGUpO2lmKHM9PT10KXJldHVybiBvP24gaW4gbz9vW25dOm8uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W2ldOmVbaV07bz9vLnNjcm9sbFRvKHI/dihvKS5zY3JvbGxMZWZ0KCk6cyxyP3M6dihvKS5zY3JvbGxUb3AoKSk6ZVtpXT1zfSxlLGksYXJndW1lbnRzLmxlbmd0aCxudWxsKX19KSx2LmVhY2goe0hlaWdodDpcImhlaWdodFwiLFdpZHRoOlwid2lkdGhcIn0sZnVuY3Rpb24oZSxuKXt2LmVhY2goe3BhZGRpbmc6XCJpbm5lclwiK2UsY29udGVudDpuLFwiXCI6XCJvdXRlclwiK2V9LGZ1bmN0aW9uKHIsaSl7di5mbltpXT1mdW5jdGlvbihpLHMpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGgmJihyfHx0eXBlb2YgaSE9XCJib29sZWFuXCIpLHU9cnx8KGk9PT0hMHx8cz09PSEwP1wibWFyZ2luXCI6XCJib3JkZXJcIik7cmV0dXJuIHYuYWNjZXNzKHRoaXMsZnVuY3Rpb24obixyLGkpe3ZhciBzO3JldHVybiB2LmlzV2luZG93KG4pP24uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIrZV06bi5ub2RlVHlwZT09PTk/KHM9bi5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgobi5ib2R5W1wic2Nyb2xsXCIrZV0sc1tcInNjcm9sbFwiK2VdLG4uYm9keVtcIm9mZnNldFwiK2VdLHNbXCJvZmZzZXRcIitlXSxzW1wiY2xpZW50XCIrZV0pKTppPT09dD92LmNzcyhuLHIsaSx1KTp2LnN0eWxlKG4scixpLHUpfSxuLG8/aTp0LG8sbnVsbCl9fSl9KSxlLmpRdWVyeT1lLiQ9dix0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZS5hbWQualF1ZXJ5JiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiB2fSl9KSh3aW5kb3cpO1xuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgJCAhPSBcInVuZGVmaW5lZFwiID8gJCA6IHdpbmRvdy4kKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuIiwiLypcbiAqIEluIHRoaXMgZWRpdG9yLCB3ZSBnZW5lcmF0ZSBhIGRlY2xhcmF0aXZlIFZlZ2Egc3BlYyAoYW5kIGl0cyBkb3duc3RyZWFtIGQzXG4gKiB2aXN1YWxpemF0aW9uKSBmcm9tIGEgbW9yZSBkZXNjcmlwdGl2ZSBzY2VuZS1ncmFwaCBtb2RlbC4gVGhpcyBjb3JyZXNwb25kc1xuICogY2xvc2VseSB3aXRoIGEgd2ViIFVJIHRoYXQncyBib3VuZCBhbmQgZW5hYmxlZCB1c2luZyBLbm9ja291dEpTLlxuICovXG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgdmcgPSByZXF1aXJlKCd2ZWdhJyksXG4gICAgVHJlZUlsbHVzdHJhdG9yID0gcmVxdWlyZSgnLi9UcmVlSWxsdXN0cmF0b3IuanMnKSxcbiAgICBzdGFzaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdmcuZGF0YS5zdGFzaC5qcycpO1xuICAgIHBsdWNrVHJhbnNmb3JtID0gcmVxdWlyZSgnLi92Zy5kYXRhLnBsdWNrLmpzJyk7XG4gICAgbmV4c29uVHJhbnNmb3JtID0gcmVxdWlyZSgnLi92Zy5kYXRhLm5leHNvbi5qcycpO1xuICAgIHBoeWxvZ3JhbVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdmcuZGF0YS5waHlsb2dyYW0uanMnKTtcblxuLy8gZXhwb3NlIFRyZWVJbGx1c3RyYXRvciB0byBKUyBpbiB0aGUgbWFpbiBVSSBcbmdsb2JhbC5UcmVlSWxsdXN0cmF0b3IgPSBUcmVlSWxsdXN0cmF0b3I7XG5nbG9iYWwuJCA9ICQ7XG5cbi8vIHJlZ2lzdGVyIGN1c3RvbSB0cmFuc2Zvcm1zIHdpdGggdGhlIGluc3RhbGxlZCB2ZWdhXG52Zy50cmFuc2Zvcm1zWydzdGFzaCddID0gc3Rhc2hUcmFuc2Zvcm07XG52Zy50cmFuc2Zvcm1zWydwbHVjayddID0gcGx1Y2tUcmFuc2Zvcm07XG52Zy50cmFuc2Zvcm1zWyduZXhzb24nXSA9IG5leHNvblRyYW5zZm9ybTtcbnZnLnRyYW5zZm9ybXNbJ3BoeWxvZ3JhbSddID0gcGh5bG9ncmFtVHJhbnNmb3JtO1xuXG4vLyBwYXRjaCBtaXNzaW5nIEpTIGNvbnNvbGUgb24gc29tZSAodmVyeSkgb2xkIGJyb3dzZXJzXG5pZiAodHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUgPSB7XG4gICAgbG9nOiBmdW5jdGlvbihtc2cpIHt9LFxuICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge30sXG4gICAgZXJyb3I6IHdpbmRvdy5hbGVydFxufVxuXG4vLyBUZXN0IHF1ZXJ5LXN0cmluZyB2YXJpYWJsZXMsIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTE1ODMwMVxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBSZWdFeHAoJ1s/Jl0nICsgbmFtZSArICc9KFteJl0qKScpLmV4ZWMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgcmV0dXJuIG1hdGNoICYmIGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qIERldGVybWluZSB0aGUgY3VycmVudCBob3N0IGFwcGxpY2F0aW9uLCBzbyB3ZSBjYW4gYWRhcHQgdG8gdGhlIGFkdmFudGFnZXNcbiAqIGFuZCBsaW1pdGF0aW9ucyBvZiBlYWNoOlxuICogIC0gc3RvcmFnZSBvcHRpb25zIGFuZCByZXF1aXJlbWVudHNcbiAqICAgICAgLSBzbG90LSB2cy4gVVJMLWJhc2VkIHN0b3JhZ2VcbiAqICAgICAgLSBuYW1pbmcgcmVzdHJpY3Rpb25zICh1bmlxdWVuZXNzLCBldGMpXG4gKiAgLSBkYXRhIHNvdXJjZXMgYW5kIGZvcm1hdHMsIGUuZy5cbiAqICAgICAgLSB2YWx1ZXMgZnJvbSBhIHNlcnZlci1zaWRlIGtlcm5lbCBpbiBKdXB5dGVyXG4gKiAgICAgIC0gdXNlcidzIHJlc291cmNlcyBpbiBPcGVuVHJlZSByZXBvc2l0b3J5XG4gKiAgICAgIC0gc3BlY2lhbCBhZGFwdGVycy92YWxpZGF0b3JzIGZvciB0cmVlIGRhdGFcbiAqICAtIG9wdGlvbmFsIGZlYXR1cmVzIGFuZCBVSVxuICogIC0gYWRqdXN0bWVudHMgdG8gbGF5b3V0IGFuZCBzdHlsZVxuICpcbiAqIFRoZSBob3N0IGFwcGxpY2F0aW9uIHNob3VsZCBiZSBzcGVjaWZpZWQgb24gdGhlIHF1ZXJ5LXN0cmluZyBvZlxuICogJ3N0eWxpc3QuaHRtbCcsIGZvciBleGFtcGxlIFxuICogICAgICAuLi4vc3R5bGlzdC5odG1sP2hvc3RBcHBsaWNhdGlvbj1KVVBZVEVSX05PVEVCT09LXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHN0YW5kYWxvbmUgcGFnZSwgd2hpY2ggZGVwZW5kcyBlbnRpcmVseSBvbiBvdXRzaWRlXG4gKiB3ZWIgc2VydmljZXMgZm9yIGRhdGEgYW5kIHN0b3JhZ2UuXG4gKi9cbnZhciBob3N0QXBwbGljYXRpb24gPSBUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5TVEFOREFMT05FO1xuLy8gdmFsaWRhdGUgcmVjZWl2ZWQgaG9zdC1hcHAgc3RyaW5nIGFnYWluc3QgZW51bWVyYXRlZCB2YWx1ZXNcbiQuZWFjaChUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucywgZnVuY3Rpb24oaSwgdGVzdFZhbHVlKSB7XG4gICAgaWYgKGdldFBhcmFtZXRlckJ5TmFtZSgnaG9zdEFwcGxpY2F0aW9uJykgPT0gdGVzdFZhbHVlKSB7XG4gICAgICAgIGhvc3RBcHBsaWNhdGlvbiA9IHRlc3RWYWx1ZTtcbiAgICB9XG59KTtcbmNvbnNvbGUubG9nKFwiVHJlZSBJbGx1c3RyYXRvciBob3N0IGFwcGxpY2F0aW9uOiBcIisgaG9zdEFwcGxpY2F0aW9uKTtcblxuLyogT2ZmZXIgYWxsIHN0dWRpZXMgYW5kIHRyZWVzIGZyb20gdGhlIE9wZW4gVHJlZSBvZiBMaWZlIHJlcG9zaXRvcnksXG4gKiBwbHVzIG90aGVyIHNvdXJjZXMgYW5kIHRyZWUgZm9ybWF0cy4gV2UnbGwgbWFrZSBhIHRyZWUgb2YgS25vY2tvdXRcbiAqIG9ic2VydmFibGVzLCBzbyB3ZSBjYW4gdXBkYXRlIHRoZW0gKGFuZCB0aGUgVUkpIG9uLXRoZS1mbHkuXG4gKlxuICogVGhpcyBzaG91bGQgYWRhcHQgdG8gdGhlIGN1cnJlbnQgaG9zdCBhcHBsaWNhdGlvbiwgZm9yIGV4YW1wbGU6XG4gKiAgLSBcImxvY2FsXCIgdmFyaWFibGVzIGZyb20gYW4gaVB5dGhvbiBub3RlYm9vayAoaW5jbC4gc2VydmVyLXNpZGUga2VybmVsKVxuICogIC0gc2ltaWxhciBcImxvY2FsXCIgZGF0YSBpbiBhbiBBcmJvciB3b3JrZmxvd1xuICogIC0gdGhlIGN1cnJlbnQgdXNlcidzIHN0dWRpZXMvdHJlZXMvZmF2b3JpdGVzIGluIE9wZW5UcmVlXG4gKlxuICogTi5CLiBUaGUgY3VycmVudCBkaXNwbGF5IGxvZ2ljIHdpbGwgaGlkZSBhbnkgZ3JvdXAgdGhhdCBoYXMgbm8gY2hpbGRyZW4uXG4gKi9cbnZhciBhdmFpbGFibGVUcmVlcyA9IGtvLm1hcHBpbmcuZnJvbUpTKFtcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiUGxhY2Vob2xkZXIgdHJlZVwiLCBcbiAgICAgICAgdXJsOiAnLi9wbGFjZWhvbGRlci10cmVlLmpzb24nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiRnJvbSBub3RlYm9vayBrZXJuZWxcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEEgbGlzdCBvZiB2YXJpYWJsZXMsIGVhY2ggbWFya2VkIHdpdGggaXRzIGxhbmd1YWdlL2tlcm5lbCAqL1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiRXhhbXBsZXNcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlR1b3ZpbGEsIDIwMTNcIiwgXG4gICAgICAgICAgICAgICAgdXJsOiBidWlsZFN0dWR5RmV0Y2hVUkwoICcyMzgwJyApXG4gICAgICAgICAgICAgICAgLyogTk9URSB0aGF0IHRoaXMgb25lIGhhcyB0d28gdHJlZXMhXG4gICAgICAgICAgICAgICAgdHJlZUlEOiAndHJlZTQ5OTknLFxuICAgICAgICAgICAgICAgIG90dXNJRDogJ3RyZWU1MDAwJ1xuICAgICAgICAgICAgICAgICovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkphbnNlbiwgMjAwN1wiLCBcbiAgICAgICAgICAgICAgICB1cmw6IGJ1aWxkU3R1ZHlGZXRjaFVSTCggJ3BnXzEwJyApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRHJldyBCVCwgMjAxNFwiLCBcbiAgICAgICAgICAgICAgICB1cmw6IGJ1aWxkU3R1ZHlGZXRjaFVSTCggJ3BnXzI4MjEnIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlBhc3RlL2VudGVyIHRyZWUgZGF0YVwiXG4gICAgICAgIC8qXG4gICAgICAgIG5hbWU6IFwiUGFzdGUvZW50ZXIgdHJlZSBkYXRhIGFzLi4uXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJOZXdpY2sgc3RyaW5nXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJOZXdpY2sgc3RyaW5nIHdpdGggZXh0cmEgZGF0YVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiTkVYVVNcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICAgICovXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiVXBsb2FkIHRyZWUgZGF0YVwiXG4gICAgICAgIC8qXG4gICAgICAgIG5hbWU6IFwiVXBsb2FkIHRyZWUgZGF0YSBhcy4uLlwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiTmV3aWNrIHN0cmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiTmV3aWNrIHN0cmluZyB3aXRoIGV4dHJhIGRhdGFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIk5FWFVTXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgICAqL1xuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIk9uIHRoZSB3ZWJcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkVudGVyIE9wZW5UcmVlIHN0dWR5IGFuZCB0cmVlIGlkc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRW50ZXIgVVJMIHRvIE5leFNPTiAxLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkVudGVyIFVSTCB0byBhIEdpdEh1YiBnaXN0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbl0pO1xuXG5mdW5jdGlvbiB1cGRhdGVBdmFpbGFibGVUcmVlcygpIHtcbiAgICAvKiBCdWlsZCBhbiBhcHByb3ByaWF0ZSAobmVzdGVkKSBsaXN0IG9mIGNob2ljZXMsIGJhc2VkIG9uIHRoZSBjdXJyZW50IGhvc3RcbiAgICAgKiBhcHBsaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIE4uQi4gdGhpcyBzaG91bGQgYmUgcmVwZWF0YWJsZSB0byB1cGRhdGUgdHJlZSBzb3VyY2VzIGFzIHRoZXkgY29tZSBhbmQgZ28uXG4gICAgICovXG4gICAgc3dpdGNoKGhvc3RBcHBsaWNhdGlvbikge1xuICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci5ob3N0QXBwbGljYXRpb25zLkpVUFlURVJfTk9URUJPT0s6XG4gICAgICAgICAgICAvKiBGZXRjaCBub3RlYm9vayB2YXJpYWJsZXMgZnJvbSB0aGUgc2VydmVyLXNpZGUga2VybmVsLCB2aWFcbiAgICAgICAgICAgICAqIEp1cHl0ZXIncyBKUyBBUEkuXG4gICAgICAgICAgICAgKiBUT0RPOiBDYW4gd2UgZGVhbCB3aXRoIG11bHRpcGxlIGtlcm5lbHMgaW4gdGhlIG5ld2VzdCBub3RlYm9va3M/XG4gICAgICAgICAgICAgKiBUT0RPOiBDYW4gd2UgZGlzdGluZ3Vpc2ggUi12aWEtUHl0aG9uIGZyb20gdGhlIFB5dGhvbiBrZXJuZWw/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFRyZWVTb3VyY2VMaXN0KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdGVib29rU291cmNlTGlzdCA9IGtvLnV0aWxzLmFycmF5Rmlyc3QoYXZhaWxhYmxlVHJlZXMoKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lKCkgPT09ICdGcm9tIG5vdGVib29rIGtlcm5lbCc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm90ZWJvb2tTb3VyY2VMaXN0LmNoaWxkcmVuLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICgnZGF0YScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhlIGVtcHR5IGxpc3QsIHN1Z2dlc3QgYSByZW1lZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVib29rU291cmNlTGlzdC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKFwiTm8gdmFyaWFibGVzIGZvdW5kISBSdW4gY29kZSBjZWxscyBhbmQgdHJ5IGFnYWluLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKSAgLy8gaW5mby1vbmx5IChub3QgY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGFueSB2YXJpYWJsZXMgcmV0dXJuZWQgYW5kIHRoZWlyIHNvdXJjZSBrZXJuZWwvbGFuZ1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uKGksIG5iVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmJWYXIgaXMgYSB0d28taXRlbSBsaXN0IGxpa2UgWydIaSBtb20nLCAnc3RyJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmJWYXJOYW1lID0gbmJWYXJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5iVmFyVHlwZSA9IG5iVmFyWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYlZhckxhbmd1YWdlID0gbmJWYXJbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZWJvb2tTb3VyY2VMaXN0LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKG5iVmFyTmFtZSArXCIgKFwiKyBuYlZhckxhbmd1YWdlICtcIiBcIisgbmJWYXJUeXBlICtcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbDoga28ub2JzZXJ2YWJsZShuYlZhckxhbmd1YWdlKSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmZXJzIHRvIGtlcm5lbC1pZCB2cy4gbGFuZ3VhZ2U/IGVnICdweXRob24yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyB0aGUgZXJyb3IgaW4gdGhlIHNvdXJjZS1saXN0LCBhbmQgc3VnZ2VzdCBhIHJlbWVkeVxuICAgICAgICAgICAgICAgICAgICBub3RlYm9va1NvdXJjZUxpc3QuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKFwiRVJST1IgbG9hZGluZyBub3RlYm9vayB2YWx1ZXMuIFJ1biBjb2RlIGNlbGxzIGFuZCB0cnkgYWdhaW4uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSkgIC8vIGluZm8tb25seSAobm90IGNsaWNrYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5TVEFOREFMT05FOlxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkbyBoZXJlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8qIENvbnZlcnNpb24gdXRpbGl0aWVzIGZvciBwaHlzaWNhbCB1bml0c1xuICovXG52YXIgY21fcGVyX2luY2ggPSAyLjU0O1xuZnVuY3Rpb24gaW5jaGVzVG9DZW50aW1ldGVycyggaW5jaGVzICkge1xuICAgIHJldHVybiBpbmNoZXMgKiBjbV9wZXJfaW5jaDtcbn1cbmZ1bmN0aW9uIGNlbnRpbWV0ZXJzVG9JbmNoZXMoIGNtICkge1xuICAgIHJldHVybiBjbSAvIGNtX3Blcl9pbmNoO1xufVxuXG52YXIgcHRfcGVyX2luY2ggPSA3Mi4wO1xuZnVuY3Rpb24gaW5jaGVzVG9Qb2ludHMoIGluY2hlcywgcHBpICkge1xuICAgIHJldHVybiBpbmNoZXMgKiBwdF9wZXJfaW5jaDtcbn1cbmZ1bmN0aW9uIHBvaW50c1RvSW5jaGVzKCBwdCwgcHBpICkge1xuICAgIHJldHVybiBwdCAvIHB0X3Blcl9pbmNoO1xufVxuXG52YXIgcHRfcGVyX2NtID0gcHRfcGVyX2luY2ggLyBjbV9wZXJfaW5jaDtcbmZ1bmN0aW9uIGNlbnRpbWV0ZXJzVG9Qb2ludHMoIGNtLCBwcGkgKSB7XG4gICAgcmV0dXJuIGNtICogcHRfcGVyX2NtO1xufVxuZnVuY3Rpb24gcG9pbnRzVG9DZW50aW1ldGVycyggcHQsIHBwaSApIHtcbiAgICByZXR1cm4gcHQgLyBwdF9wZXJfY207XG59XG5cbmZ1bmN0aW9uIHBpeGVsc1RvSW5jaGVzKCBweCwgcHBpICkge1xuICAgIHJldHVybiBweCAvIHBwaTtcbn1cbmZ1bmN0aW9uIGluY2hlc1RvUGl4ZWxzKCBpbmNoZXMsIHBwaSApIHtcbiAgICByZXR1cm4gaW5jaGVzICogcHBpO1xufVxuZnVuY3Rpb24gcGl4ZWxzVG9DZW50aW1ldGVycyggcHgsIHBwaSApIHtcbiAgICByZXR1cm4gaW5jaGVzVG9DZW50aW1ldGVycyhweCAvIHBwaSk7XG59XG5mdW5jdGlvbiBjZW50aW1ldGVyc1RvUGl4ZWxzKCBjbSwgcHBpICkge1xuICAgIHJldHVybiBjZW50aW1ldGVyc1RvSW5jaGVzKCBjbSApICogcHBpO1xufVxuXG5mdW5jdGlvbiBwaXhlbHNUb1BoeXNpY2FsVW5pdHMoIHB4LCBwcGkgKSB7XG4gICAgaWYgKGlsbC5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gVHJlZUlsbHVzdHJhdG9yLnVuaXRzLklOQ0hFUykge1xuICAgICAgICByZXR1cm4gcGl4ZWxzVG9JbmNoZXMoIHB4LCBwcGkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGl4ZWxzVG9DZW50aW1ldGVycyggcHgsIHBwaSApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBoeXNpY2FsVW5pdHNUb1BpeGVscyggdW5pdHMsIHBwaSApIHtcbiAgICBpZiAoaWxsLnN0eWxlLnByaW50U2l6ZS51bml0cygpID09PSBUcmVlSWxsdXN0cmF0b3IudW5pdHMuSU5DSEVTKSB7XG4gICAgICAgIHJldHVybiBpbmNoZXNUb1BpeGVscyggdW5pdHMsIHBwaSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjZW50aW1ldGVyc1RvUGl4ZWxzKCB1bml0cywgcHBpICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQaHlzaWNhbFVuaXRTdWZmaXgoKSB7XG4gICAgaWYgKHBoeXNpY2FsVW5pdHMgPT09ICdJTkNIRVMnKSB7XG4gICAgICAgIHJldHVybiAnaW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnY20nO1xuICAgIH1cbn1cblxuLy8gcnVsZXIgbWV0cmljcyAoYWRqdXN0IGZvciBsZWdpYmlsaXR5KVxudmFyIHJ1bGVyV2lkdGggPSAyNTsgIC8vIHB4XG5cbi8qIE1haW50YWluIGEgZmV3IGluZGVwZW5kZW50IHNjYWxlcyAoaW4gcGl4ZWxzL2luY2gpIHRvIHN1cHBvcnQgdGhlXG4gKiBpbGx1c3RyYXRpb24gZWRpdG9yLiBUaGVzZSB3aWxsIHNvbWV0aW1lcyBhbGlnbiwgYnV0IGl0J3Mgdml0YWwgdGhhdCB3ZSBjYW5cbiAqIGRpc2NyaW1pbmF0ZSBiZXR3ZWVuIHRoZW0gYXMgZWFjaCBpcyBzdWl0ZWQgZm9yIGEgZGlmZmVyZW50IHB1cnBvc2VzLlxuICovXG52YXIgYnJvd3Nlcl9wcGk7ICAvLyBTVkcgcmVzb2x1dGlvbiBpbiBjdXJyZW50IGJyb3dzZXIgKG5vdCByZWxpYWJsZSEpXG52YXIgaW50ZXJuYWxfcHBpID0gOTA7ICAvLyBTVkcgZGVmYXVsdCBwaXhlbHMgcGVyIGluY2ggKGNhbiBiZSBtb2RpZmllZCB0byBzdWl0IHByaW50aW5nIGRldmljZSlcbnZhciBkaXNwbGF5X3BwaSA9IGludGVybmFsX3BwaTsgIC8vIHBpeGVscyBwZXIgaW5jaCBhdCBjdXJyZW50IG1hZ25pZmljYXRpb24gKHpvb20gbGV2ZWwpXG5cbi8qIFRyYWNrIHRoZSB2YWx1ZXMgdXNlZCBmb3Igb3VyIHZpZXdwb3J0IChvdmVyYWxsIHNpemUsIG1hcmdpbnMgdnMuIGlsbHVzdHJhdGlvbilcbiAqIGZvciBlYXN5IHJlLXVzZSBpbiBydWxlcnMsIGV0Yy4gRm9yIGJhY2tncm91bmQsIHNlZSBTVkcncyB2aWV3Qm94IGRvY3M6IFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAqL1xudmFyIHZpZXdib3ggPSB7XG4gICAgJ3gnOiAwLFxuICAgICd5JzogMCxcbiAgICAnd2lkdGgnOiAwLFxuICAgICdoZWlnaHQnOiAwLFxufVxuZnVuY3Rpb24gdXBkYXRlVmlld3BvcnRWaWV3Ym94KCR2aWV3cG9ydCkge1xuICAgIC8qIEFkanVzdCB0aGUgbWFpbiBWRyB2aWV3Qm94IGFzIG5lZWRlZCB0byBtYXRjaCB0aGUgY3VycmVudCBpbGx1c3RyYXRpb25cbiAgICAgKiBzaXplIGFuZCBjaG9zZW4gbWFnbmlmaWNhdGlvbi4gVGhlIHJlc3VsdCBzaG91bGQgYmUgdGhhdCBzY3JvbGxiYXJzIG9mZmVyIFxuICAgICAqIGFjY2VzcyB0byBhbGwgU1ZHIGVsZW1lbnRzIChpbiBvciBvdXQgb2YgdGhlIHByaW50ZWQgYXJlYSksIHdoaWxlIHRoZSB1c2VyXG4gICAgICogaXMgZnJlZSB0byBjaG9vc2UgYXJiaXRyYXJ5IGxldmVscyBvZiBtYWduaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIC8vIFRPRE86IG1haW50YWluIHRoZSBjdXJyZW50IGNlbnRlciBwb2ludCwgYnV0IHN1cnJlbmRlciBlbXB0eSB0ZXJyaXRvcnlcbiAgICBpZiAoISR2aWV3cG9ydCkge1xuICAgICAgICAkdmlld3BvcnQgPSAkKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYVwiKTtcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBsYXRlc3QgRElWIHNpemUrcHJvcG9ydGlvbnMuIChUaGVzZSBjYW4gY2hhbmdlIGlmIHRoZVxuICAgICAqIHVzZXIgdG9nZ2xlcyBzY3JvbGxiYXJzIG9yIHJlc2l6ZXMgdGhlIHN1cnJvdW5kaW5nIHBhZ2UuKSBUaGlzIGlzIHRoZVxuICAgICAqIG5ldyAqbWluaW11bSogc2l6ZSBmb3Igb3VyIFNWRyBlbGVtZW50LCB0byBhdm9pZCBnYXBzIGluIHRoZSB2aWV3cG9ydCFcbiAgICAgKi9cbiAgICB2YXIgdnBEaXYgPSAkdmlld3BvcnRbMF07XG4gICAgdmFyIGRpdldpZHRoID0gdnBEaXYuY2xpZW50V2lkdGg7XG4gICAgdmFyIGRpdkhlaWdodCA9IHZwRGl2LmNsaWVudEhlaWdodDtcbiAgICB2YXIgZGl2UHJvcG9ydGlvbnMgPSBkaXZXaWR0aCAvIGRpdkhlaWdodDtcblxuICAgIC8qIFdoYXQgbXVzdCBiZSBpbiB0aGUgdmlld2JveD8gQWxsIGlsbHVzdHJhdGlvbiBlbGVtZW50cyAoc28gd2UgY2FuIHNjcm9sbFxuICAgICAqIHRvIHRoZW0pLCBwbHVzIGFueSBwYWRkaW5nIG5lZWRlZCAoYXQgY3VycmVudCBtYWduaWZpY2F0aW9uKSB0byBmaWxsIHRoZVxuICAgICAqIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIHZhciBlYm94ID0gZ2V0SW5jbHVzaXZlSWxsdXN0cmF0aW9uQm91bmRpbmdCb3goKTtcbiAgICAvLyB0aGlzIGlzIHRoZSBhcmVhIHdpdGggYWxsIGlsbHVzdHJhdGlvbiBlbGVtZW50c1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IGVib3gueCArIChlYm94LndpZHRoIC8gMiksXG4gICAgICAgIHk6IGVib3gueSArIChlYm94LmhlaWdodCAvIDIpXG4gICAgfTtcblxuICAgIC8vIGNvcHkgdG8gb3VyIHBlcnNpc3RlbnQgdmlld2JveFxuICAgIGZvciAodmFyIHByb3AgaW4gZWJveCkge1xuICAgICAgICB2aWV3Ym94W3Byb3BdID0gZWJveFtwcm9wXTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcG9ydGlvbmFsV2lkdGggPSBNYXRoLnJvdW5kKHZpZXdib3gud2lkdGggKiB2aWV3cG9ydE1hZ25pZmljYXRpb24pO1xuICAgIHZhciBwcm9wb3J0aW9uYWxIZWlnaHQgPSBNYXRoLnJvdW5kKHZpZXdib3guaGVpZ2h0ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcblxuICAgIC8vIGNvbXBhcmUgaXRzIHByb3BvcnRpb25zIHRvIG91ciAqbmV3KiB2aWV3cG9ydDsgcGFkIGFzIG5lZWRlZCB0byBmaWxsIHNwYWNlXG4gICAgdmFyIGJib3ggPSB2aWV3Ym94O1xuICAgIGlmIChwcm9wb3J0aW9uYWxXaWR0aCA8IGRpdldpZHRoKSB7XG4gICAgICAgIC8vIGRpdiBpcyB3aWRlciwgcGFkIHZpZXdib3ggd2lkdGggdG8gbWF0Y2hcbiAgICAgICAgdmFyIGFkanVzdGVkV2lkdGggPSBkaXZXaWR0aCAvIHZpZXdwb3J0TWFnbmlmaWNhdGlvbjtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBhZGp1c3RlZFdpZHRoIC0gdmlld2JveC53aWR0aDtcbiAgICAgICAgdmlld2JveC53aWR0aCA9IGFkanVzdGVkV2lkdGg7XG4gICAgICAgIHZpZXdib3gueCAtPSAoZXh0cmFXaWR0aCAvIDIpO1xuICAgIH0gXG4gICAgaWYgKHByb3BvcnRpb25hbEhlaWdodCA8IGRpdkhlaWdodCkge1xuICAgICAgICAvLyBkaXYgaXMgdGFsbGVyLCBwYWQgdmlld2JveCBoZWlnaHQgdG8gbWF0Y2hcbiAgICAgICAgdmFyIGFkanVzdGVkSGVpZ2h0ID0gZGl2SGVpZ2h0IC8gdmlld3BvcnRNYWduaWZpY2F0aW9uO1xuICAgICAgICB2YXIgZXh0cmFIZWlnaHQgPSBhZGp1c3RlZEhlaWdodCAtIHZpZXdib3guaGVpZ2h0O1xuICAgICAgICB2aWV3Ym94LmhlaWdodCA9IGFkanVzdGVkSGVpZ2h0O1xuICAgICAgICB2aWV3Ym94LnkgLT0gKGV4dHJhSGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgLy8gbW92ZSBvdXIgYmFja2dyb3VuZCB0byB0aGUgbmV3IHZpZXdwb3J0IHRvcC1sZWZ0IGNvcm5lclxuICAgIGQzLnNlbGVjdEFsbCgnI3ZpZXdwb3J0LWJhY2tncm91bmQsICN2aWV3cG9ydC1ib3VuZHMnKVxuICAgICAgICAuYXR0cigneCcsIHZpZXdib3gueClcbiAgICAgICAgLmF0dHIoJ3knLCB2aWV3Ym94LnkpO1xuXG4gICAgLy8gVXBkYXRlIHBoeXNpY2FsIHNpemUgb2YgU1ZHIGVsZW1lbnQgYmFzZWQgb24gbmV3IHZpZXdib3ggYW5kIG1hZ25pZmljYXRpb25cbiAgICBwcm9wb3J0aW9uYWxXaWR0aCA9IE1hdGgucm91bmQodmlld2JveC53aWR0aCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgcHJvcG9ydGlvbmFsSGVpZ2h0ID0gTWF0aC5yb3VuZCh2aWV3Ym94LmhlaWdodCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgdmFyIHN2Z1dpZHRoID0gcHJvcG9ydGlvbmFsV2lkdGg7XG4gICAgdmFyIHN2Z0hlaWdodCA9IHByb3BvcnRpb25hbEhlaWdodDtcblxuICAgIC8vIE5PVEUgdGhhdCB3ZSBuZWVkIHRvIHVzZSBlbC5zZXRBdHRyaWJ1dGUgdG8ga2VlcCBtaXhlZC1jYXNlIGF0dHJpYnV0ZSBuYW1lc1xuICAgIHZhciBzdmcgPSAkdmlld3BvcnQuZmluZCgnc3ZnJylbMF07XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UncmUgYXQgbGVhc3QgZmlsbGluZyB0aGUgYXZhaWxhYmxlIHZpZXdwb3J0IERJVlxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc3ZnV2lkdGgpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN2Z0hlaWdodCk7XG5cbiAgICAvLyBUT0RPOiBudWRnZSBzY3JvbGxiYXJzIHRvIGhvbGQgYSBzdGVhZHkgdmlldz9cblxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAodmlld2JveC54ICsnICcrIHZpZXdib3gueSArJyAnKyB2aWV3Ym94LndpZHRoICsnICcrdmlld2JveC5oZWlnaHQpKTtcbiAgICAkKCcjdmlld2JveC1pbmRpY2F0b3InKS5odG1sKHN2Zy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSk7XG4gICAgJCgnI21hZy1pbmRpY2F0b3InKS5odG1sKHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgJCgnI3N2Zy13aWR0aC1pbmRpY2F0b3InKS5odG1sKHN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgICQoJyNzdmctaGVpZ2h0LWluZGljYXRvcicpLmh0bWwoc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXG4gICAgLypcbiAgICBjb25zb2xlLmxvZygnT0xEIGRpdiB3OiAnKyBzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICBjb25zb2xlLmxvZygnICB2aWV3Ym94LndpZHRoOiAnKyB2aWV3Ym94LndpZHRoKTtcbiAgICBjb25zb2xlLmxvZygnICAqIG1hZ25pZmljYXRpb246ICcrIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgY29uc29sZS5sb2coJyAgTkVXIGRpdiB3OiAnKyB2aWV3Ym94LndpZHRoICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBJTlQgZGl2IHc6ICcrIE1hdGgucm91bmQodmlld2JveC53aWR0aCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbikpO1xuICAgIGNvbnNvbGUubG9nKCdPTEQgZGl2IGg6ICcrIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcbiAgICBjb25zb2xlLmxvZygnICB2aWV3Ym94LmhlaWdodDogJysgdmlld2JveC5oZWlnaHQpO1xuICAgIGNvbnNvbGUubG9nKCcgICogbWFnbmlmaWNhdGlvbjogJysgdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBORVcgZGl2IGg6ICcrIHZpZXdib3guaGVpZ2h0ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBJTlQgZGl2IGg6ICcrIE1hdGgucm91bmQodmlld2JveC5oZWlnaHQgKiB2aWV3cG9ydE1hZ25pZmljYXRpb24pKTtcbiAgICAqL1xufVxuXG4vKiBUT0RPOiBMb2FkIGF2YWlsYWJsZSBzdHlsZXMgZnJvbSBhbiBleHRlcm5hbCBzb3VyY2Ugb3Igc3RvcmUuIFRoZXNlIG1pZ2h0IGJlXG4gKiBzaGFyZWQgb3IgcHJpdmF0ZS4gU3R5bGVzIHNob3VsZCBpbmNsdWRlIG5hbWUgYW5kIGRlc2NyaXB0aW9uLCBkZWZhdWx0cyBmb3JcbiAqIG1vc3QgdmlzdWFsIHByb3BlcnRpZXMsIGFuZCBjb25zdHJhaW50cyAoc29mdCBvciBoYXJkKSB0aGF0IHdlIGNhbiB0ZXN0XG4gKiBhZ2FpbnN0LlxuICovXG52YXIgYXZhaWxhYmxlU3R5bGVHdWlkZXMgPSBudWxsO1xuZnVuY3Rpb24gc2hvd1N0eWxlR3VpZGVQaWNrZXIoKSB7XG4gICAgLy8gZm9yIG5vdywgbG9hZCBmcm9tIGEgc3RhdGljIEpTT04gZmlsZSBcbiAgICB2YXIgbG9va3VwVVJMID0gJy4vc3R5bGUtZ3VpZGVzLmpzb24nO1xuXG4gICAgLy9zaG93TW9kYWxTY3JlZW4oXCJHYXRoZXJpbmcgc3R5bGUgZ3VpZGVzLi4uXCIsIHtTSE9XX0JVU1lfQkFSOnRydWV9KTtcbiAgICAkLmFqYXgoe1xuICAgICAgICBnbG9iYWw6IGZhbHNlLCAgLy8gc3VwcHJlc3Mgd2ViMnB5J3MgYWdncmVzc2l2ZSBlcnJvciBoYW5kbGluZz9cbiAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIC8vIGNyb3NzZG9tYWluOiB0cnVlLFxuICAgICAgICAvLyBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIHVybDogbG9va3VwVVJMLFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgLy9oaWRlTW9kYWxTY3JlZW4oKTtcbiAgICAgICAgICAgIGlmICgodGV4dFN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSAmJiAodGV4dFN0YXR1cyAhPT0gJ3BhcnNlcmVycm9yJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgbG9va2luZyB1cCB0aGUgYXZhaWxhYmxlIHN0eWxlIGd1aWRlcy4gKFNlZSBKUyBjb25zb2xlIGZvciBkZXRhaWxzLiknO1xuICAgICAgICAgICAgICAgIGFsZXJ0KGVyck1zZyk7IFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJNc2cgKydcXG5cXG50ZXh0U3RhdHVzPScrIHRleHRTdGF0dXMgKydcXG5cXG4nKyBqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vc2hvd0Vycm9yTWVzc2FnZShlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgcmF3IHJlc3BvbnNlIHRvIEpTT05cbiAgICAgICAgICAgIHZhciByZXN1bHRzSlNPTiA9ICQucGFyc2VKU09OKGpxWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0c0pTT04ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ05vIHN0eWxlIGd1aWRlcyBmb3VuZCEnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU3R5bGVHdWlkZXMgPSByZXN1bHRzSlNPTjtcbiAgICAgICAgICAgICAgICB2YXIgJGNob29zZXIgPSAkKCcjc3R5bGVndWlkZS1jaG9vc2VyJyk7XG4gICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHZhciAkY3VycmVudE5hbWVEaXNwbGF5ID0gJGNob29zZXIuZmluZCgnI2N1cnJlbnQtc3R5bGVndWlkZS1uYW1lJyk7XG4gICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5odG1sKCBpbGwuc3R5bGVHdWlkZS5uYW1lKCkgKTtcbiAgICAgICAgICAgICAgICBpZiAoaWxsLnN0eWxlR3VpZGUudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwaXZvdCBiYXNlZCBvbiB2ZXJzaW9uIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGlsbC5zdHlsZUd1aWRlLnZlcnNpb24udHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci52ZXJzaW9uVHlwZXMuQ0hFQ0tTVU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5hcHBlbmQoJzxlbSBjbGFzcz1cInZlcnNpb25cIj4mbmJzcDsgJmx0OycrIGlsbC5zdHlsZUd1aWRlLnZlcnNpb24udmFsdWUoKSArJyZndDs8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IudmVyc2lvblR5cGVzLlRJTUVTVEFNUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3VycmVudE5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyAgYXMgb2YgJysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnZlcnNpb25UeXBlcy5TRU1BTlRJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3VycmVudE5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyB2JysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5hcHBlbmQoJzxlbSBjbGFzcz1cInZlcnNpb25cIj5Vbmtub3duIHZlcnNpb24gdHlwZTogJysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcjY3VycmVudC1zdHlsZWd1aWRlLXNvdXJjZScpLmh0bWwoIGlsbC5zdHlsZUd1aWRlU291cmNlSFRNTCgpICk7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGF2YWlsYWJsZVN0eWxlR3VpZGVzLCBmdW5jdGlvbihpLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHRoZSBpbGxsdXN0cmF0aW9uJ3MgY3VycmVudCBzdHlsZSBndWlkZT8gY29tcGFyZSBuYW1lLCBzb3VyY2UsIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXNzaWduZWRTdHlsZUd1aWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzVmVyc2lvbk9mQXNzaWduZWRTdHlsZUd1aWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2gubmFtZSA9PT0gaWxsLnN0eWxlR3VpZGUubmFtZSgpKSAmJiAobWF0Y2guc291cmNlLnZhbHVlID09PSBpbGwuc3R5bGVHdWlkZS5zb3VyY2UudmFsdWUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXNzaWduZWRTdHlsZUd1aWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC52ZXJzaW9uLnZhbHVlICE9PSBpbGwuc3R5bGVHdWlkZS52ZXJzaW9uLnZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzVmVyc2lvbk9mQXNzaWduZWRTdHlsZUd1aWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgJG1hdGNoSW5mbyA9ICQoJzxkaXYgY2xhc3M9XCJtYXRjaFwiPjxpbWcgY2xhc3M9XCJ0aHVtYm5haWxcIj48L2ltZz48ZGl2IGNsYXNzPVwibmFtZVwiPjwvZGl2PjxkaXY+U291cmNlOiA8c3BhbiBjbGFzcz1cInNvdXJjZVwiPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVwiZGVzY3JpcHRpb25cIj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aHVtYiA9ICRtYXRjaEluZm8uZmluZCgnLnRodW1ibmFpbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3NpZ25lZFN0eWxlR3VpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uYWRkQ2xhc3MoJ2Fzc2lnbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2aW91c1ZlcnNpb25PZkFzc2lnbmVkU3R5bGVHdWlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uYWRkQ2xhc3MoJ3ByZXZpb3VzLXZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWIuYWZ0ZXIoJzxhIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIGhyZWY9XCIjXCIgb25jbGljaz1cInN0eWxpc3QuYXBwbHlDaG9zZW5TdHlsZUd1aWRlKHRoaXMpOyByZXR1cm4gZmFsc2U7XCI+VXBkYXRlPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWIuYWZ0ZXIoJzxhIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbCBkaXNhYmxlZFwiIGhyZWY9XCIjXCIgb25jbGljaz1cImFsZXJ0KFxcJ1RoaXMgc3R5bGUgZ3VpZGUgaXMgYWxyZWFkeSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IGlsbHVzdHJhdGlvbi5cXCcpOyByZXR1cm4gZmFsc2U7XCI+QXNzaWduZWQ8L2E+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2guY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aHVtYi5hZnRlcignPGEgY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgaHJlZj1cIiNcIiBvbmNsaWNrPVwic3R5bGlzdC5hcHBseUNob3NlblN0eWxlR3VpZGUodGhpcyk7IHJldHVybiBmYWxzZTtcIj5BcHBseTwvYT4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aHVtYi5hZnRlcignPGEgY2xhc3M9XCJidG4gYnRuLXNtYWxsIGRpc2FibGVkXCIgaHJlZj1cIiNcIiBvbmNsaWNrPVwiYWxlcnQoXFwnU29ycnksIHRoaXMgaXMganVzdCBhbiBlbXB0eSBleGFtcGxlLlxcJyk7IHJldHVybiBmYWxzZTtcIj5FeGFtcGxlPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uZmluZCgnLnRodW1ibmFpbCcpLmF0dHIoJ3NyYycsIG1hdGNoLnRodW1ibmFpbFNyYyB8fCAnLi9icm9rZW4ucG5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkbmFtZURpc3BsYXkgPSAkbWF0Y2hJbmZvLmZpbmQoJy5uYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICRuYW1lRGlzcGxheS5odG1sKG1hdGNoLm5hbWUgfHwgJzxlbT5ObyBuYW1lIGZvdW5kPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpdm90IGJhc2VkIG9uIHZlcnNpb24gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG1hdGNoLnZlcnNpb24udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnZlcnNpb25UeXBlcy5DSEVDS1NVTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyAmbHQ7JysgbWF0Y2gudmVyc2lvbi52YWx1ZSArJyZndDs8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci52ZXJzaW9uVHlwZXMuVElNRVNUQU1QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbmFtZURpc3BsYXkuYXBwZW5kKCc8ZW0gY2xhc3M9XCJ2ZXJzaW9uXCI+Jm5ic3A7ICBhcyBvZiAnKyBtYXRjaC52ZXJzaW9uLnZhbHVlICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IudmVyc2lvblR5cGVzLlNFTUFOVElDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbmFtZURpc3BsYXkuYXBwZW5kKCc8ZW0gY2xhc3M9XCJ2ZXJzaW9uXCI+Jm5ic3A7IHYnKyBtYXRjaC52ZXJzaW9uLnZhbHVlICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPlVua25vd24gdmVyc2lvbiB0eXBlOiAnKyBtYXRjaC5zb3VyY2UudHlwZSArJzwvZW0+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyICRzb3VyY2VEaXNwbGF5ID0gJG1hdGNoSW5mby5maW5kKCcuc291cmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpdm90IGJhc2VkIG9uIHNvdXJjZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2gobWF0Y2guc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci5kYXRhU291cmNlVHlwZXMuQlVJTFRfSU46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzb3VyY2VEaXNwbGF5Lmh0bWwoJzxzdHJvbmc+QnVpbHQtaW48L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci5kYXRhU291cmNlVHlwZXMuVVJMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc291cmNlRGlzcGxheS5odG1sKCc8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiJysgbWF0Y2guc291cmNlLnZhbHVlICsnXCI+JysgbWF0Y2guc291cmNlLnZhbHVlICsnPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc291cmNlRGlzcGxheS5odG1sKCc8ZW0+VW5rbm93biBzb3VyY2UgdHlwZTogJysgbWF0Y2guc291cmNlLnR5cGUgKyc8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNvdXJjZURpc3BsYXkuaHRtbCgnPGVtPk5vIHNvdXJjZSBmb3VuZDwvZW0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJG1hdGNoSW5mby5maW5kKCcuZGVzY3JpcHRpb24nKS5odG1sKCBtYXRjaC5kZXNjcmlwdGlvbiB8fCAnPGVtPk5vIGRlc2NyaXB0aW9uIGZvdW5kPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgdW5pcXVlIGtleSB0byBkZXRlcm1pbmUgdGhlIGNob3NlbiBzdHlsZSBndWlkZSBsYXRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2dLZXkgPSBtYXRjaC5uYW1lICsnfCcrIChtYXRjaC52ZXJzaW9uID8gbWF0Y2gudmVyc2lvbi52YWx1ZSA6IFwiXCIpICsnfCcrIChtYXRjaC5zb3VyY2UgPyBtYXRjaC5zb3VyY2UudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgJG1hdGNoSW5mby5hcHBlbmQoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgY2xhc3M9XCJtYXRjaC1rZXlcIiB2YWx1ZT1cIicrIHNnS2V5ICsnXCIgLz4nKTtcbiAgICAgICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5hcHBlbmQoJG1hdGNoSW5mbyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGNob29zZXIub2ZmKCdzaG93bicpLm9uKCdzaG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaXplIHNjcm9sbGluZyBsaXN0IHRvIGZpdCBpbiB0aGUgY3VycmVudCBET0ktbG9va3VwIHBvcHVwIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGNob29zZXIgPSAkKCcjc3R5bGVndWlkZS1jaG9vc2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzTGlzdEhlaWdodCA9ICRjaG9vc2VyLmZpbmQoJy5tb2RhbC1ib2R5JykuaGVpZ2h0KCkgLSAkY2hvb3Nlci5maW5kKCcuYmVmb3JlLW1hdGNoZXMnKS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm91dGVySGVpZ2h0KHJlc3VsdHNMaXN0SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcuZm91bmQtbWF0Y2hlcycpLmNzcygndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICRjaG9vc2VyLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyogVGhlIGN1cnJlbnQgVmVnYSBzcGVjIGlzIGdlbmVyYXRlZCB1c2luZyB0aGUgY2hvc2VuIHN0eWxlIChhYm92ZSkgYW5kIFxuICogdGhlIGlsbHVzdHJhdGlvbiBzb3VyY2UgYW5kIGRlY2lzaW9ucyBtYWRlIGluIHRoZSB3ZWIgVUkuIFdoZW4gdGhlXG4gKiBpbGx1c3RyYXRpb24gaXMgc2F2ZWQsIHRoZSBsYXRlc3QgY2FuIGFsc28gYmUgZW1iZWRkZWQuIE9yIHBlcmhhcHMgd2Ugc2hvdWxkXG4gKiBhbHdheXMgZ2VuZXJhdGUgaXQgZnJlc2ggZnJvbSB0aGUgc291cmNlIGRhdGEgYW5kIHNjZW5lIGdyYXBoIHdoZW5uXG4gKiAocmUpbG9hZGluZyB0aGUgaWxsdXN0cmF0aW9uP1xuICovXG52YXIgdmVnYVNwZWM7XG5mdW5jdGlvbiByZWZyZXNoVml6KG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTsgXG5cbiAgICBpbGwudXBkYXRlVmVnYVNwZWMoKTsgIC8vIFRPRE86IHRyaWdnZXIgdXBkYXRlcyBvbiBhIG1vcmUgc2Vuc2libGUgYmFzaXNcblxuICAgIHZnLnBhcnNlLnNwZWMoaWxsLnZlZ2FTcGVjLCBmdW5jdGlvbihjaGFydCkge1xuICAgICAgdmFyIHZpZXcgPSBjaGFydCh7ZWw6XCIjdml6LW91dGVyLWZyYW1lXCIsIHJlbmRlcmVyOlwic3ZnXCJ9KTtcbiAgICAgIC8vICwgZGF0YTpjYWNoZWREYXRhPyB9KSAgPD09IE1VU1QgQkUgSU5MSU5FLCBOT1QgVVJMIVxuLypcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGV2ZW50LCBpdGVtKSB7XG4gICAgICAgICAgLy8gaW52b2tlIGhvdmVyIHByb3BlcnRpZXMgb24gY291c2luIG9uZSBob3AgZm9yd2FyZCBpbiBzY2VuZWdyYXBoXG4gICAgICAgICAgdmlldy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvcHM6IFwiaG92ZXJcIixcbiAgICAgICAgICAgIGl0ZW1zOiBpdGVtLmNvdXNpbigxKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihldmVudCwgaXRlbSkge1xuICAgICAgICAgIC8vIHJlc2V0IGNvdXNpbiBpdGVtLCB1c2luZyBhbmltYXRlZCB0cmFuc2l0aW9uXG4gICAgICAgICAgdmlldy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvcHM6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICBpdGVtczogaXRlbS5jb3VzaW4oMSksXG4gICAgICAgICAgICBkdXJhdGlvbjogMjUwLFxuICAgICAgICAgICAgZWFzZTogXCJsaW5lYXJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuKi9cbiAgICAgICAgdmlldy51cGRhdGUoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5TSE9XX0FMTCkge1xuICAgICAgICAgICAgcmVzaXplVmlld3BvcnRUb1Nob3dBbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRUcmVlSWxsdXN0cmF0b3JXaW5kb3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgaWxsOyAgXG5cbi8vIExvYWQgYW4gaWxsdXN0cmF0aW9uIGZyb20gSlMvSlNPTiBkYXRhICh1c3UuIGNhbGxlZCBieSBjb252ZW5pZW5jZSBmdW5jdGlvbnMgYmVsb3cpXG5mdW5jdGlvbiBsb2FkSWxsdXN0cmF0aW9uRGF0YSggZGF0YSwgbmV3T3JFeGlzdGluZyApIHtcbiAgICAvLyBVc2UgYW4gSWxsdXN0cmF0aW9uIG9iamVjdCBhcyBvdXIgcHJpbWFyeSB2aWV3IG1vZGVsIGZvciBLbm9ja291dEpTXG4gICAgLy8gKGJ5IGNvbnZlbnRpb24sIGl0J3MgdXN1YWxseSBuYW1lZCAndmlld01vZGVsJylcbiAgICBpbGwgPSBuZXcgVHJlZUlsbHVzdHJhdG9yLklsbHVzdHJhdGlvbiggZGF0YSApO1xuICAgIC8vIGV4cG9ydCB0aGUgbmV3IGlsbHVzdHJhdGlvblxuICAgIGV4cG9ydHMuaWxsID0gaWxsOyBcblxuICAgIC8qIFRPRE86IGhhbmRsZSB0aGUgbmV3T3JFeGlzdGluZyBzdG9yYWdlIGluZm8/IG9yIG1heWJlIHRoaXMgaXNcbiAgICAgKiBoYW5kbGVkIGJ5IHRoZSBzdG9yYWdlIGJhY2tlbmQuLi5cbiAgICAgKi9cblxuICAgIC8vIGFkZCBhIHNpbmdsZSBwbGFjZWhvbGRlciB0cmVlXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGlsbC5hZGRJbGx1c3RyYXRlZFRyZWUoKTtcbiAgICB9XG5cbiAgICAvLyAocmUpYmluZCB0byBlZGl0b3IgVUkgd2l0aCBLbm9ja291dFxuICAgIHZhciAkYm91bmRFbGVtZW50cyA9ICQoJyNlZGl0b3InKTsgLy8gYWRkIG90aGVyIGVsZW1lbnRzP1xuICAgICQuZWFjaCgkYm91bmRFbGVtZW50cywgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAga28uY2xlYW5Ob2RlKGVsKTtcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyhpbGwsZWwpO1xuICAgIH0pO1xuXG4gICAgcmVmcmVzaFZpeigge1NIT1dfQUxMOiB0cnVlfSApO1xufVxuZnVuY3Rpb24gbG9hZEVtcHR5SWxsdXN0cmF0aW9uKCkge1xuICAgIC8qIExvYWQgYW4gZW1wdHkgaWxsdXN0cmF0aW9uIHdpdGggYSBwbGFjZWhvbGRlciB0cmVlLCB3aXRoXG4gICAgICogbm8gSUQgb3Igc2xvdCBhc3NpZ25lZCAoaS5lLiwgdHJlYXQgdGhpcyBhcyBhIG5ldyBpbGx1c3RyYXRpb24pLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBzaW1wbGUgdGVtcGxhdGU/XG4gICAgICovXG4gICAgbG9hZElsbHVzdHJhdGlvbkRhdGEoIG51bGwsICdORVcnICk7XG59XG4vLyBOLkIuIFRoZXJlIHNob3VsZCBiZSBhZGRpdGlvbmFsIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyBpbiB0aGUgc3RvcmFnZSBiYWNrZW5kXG4vLyAgLSBmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbiggZG9jSUQgKVxuLy8gIC0gZmV0Y2hBbmRMb2FkSWxsdXN0cmF0aW9uVGVtcGxhdGUoIHRlbXBsYXRlSUQgKVxuXG5mdW5jdGlvbiBmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbiggZG9jSUQgKSB7XG4gICAgLyogTG9hZCB0aGUgSlMgKG9yIEpTT04/KSBkYXRhIHByb3ZpZGVkLCBhbmQga2VlcCB0cmFjayBvZiBpdHMgb3JpZ2luYWwgSUQvc2xvdC5cbiAgICAgKi9cbiAgICBsb2FkSWxsdXN0cmF0aW9uKGRvY0lELCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBsb2FkSWxsdXN0cmF0aW9uRGF0YSggZGF0YSwgJ0VYSVNUSU5HJyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZS5lcnJvciB8fCBcIk5vIGRhdGEgcmV0dXJuZWQgKHVuc3BlY2lmaWVkIGVycm9yKSFcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZldGNoQW5kTG9hZElsbHVzdHJhdGlvblRlbXBsYXRlKCB0ZW1wbGF0ZUlEICkge1xuICAgIC8qIExvYWQgdGhlIEpTIChvciBKU09OKSBkYXRhIHByb3ZpZGVkLCBidXQgdHJlYXQgdGhpcyBhcyBhIG5ldyBpbGx1c3RyYXRpb24uXG4gICAgICpcbiAgICAgKiBOLkIuIEEgdGVtcGxhdGUgaXMgYmFzaWNhbGx5IGFuIGV4aXN0aW5nIGlsbHVzdHJhdGlvbiBkb2N1bWVudCwgd2l0aFxuICAgICAqIGludGVybmFsIHByb21wdHMgYW5kIHBsYWNlaG9sZGVyIHRyZWVzL2RhdGEsIGJ1dCB3ZSdsbCB0cmVhdCBpdCBhcyBuZXcuXG4gICAgICovXG4gICAgLy8gVE9ETzogZmV0Y2ggdXNpbmcgc3RvcmFnZSBiYWNrZW5kXG4gICAgbG9hZElsbHVzdHJhdGlvbihkb2NJRCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGxvYWRJbGx1c3RyYXRpb25EYXRhKCB0ZW1wbGF0ZSwgJ05FVycgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgXCJObyBkYXRhIHJldHVybmVkICh1bnNwZWNpZmllZCBlcnJvcikhXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIC8vIHRlc3QgZm9yIHRoZSBwcmVzZXQgcHBpIChwaXhlbHMgLyBpbmNoKSBpbiB0aGlzIGJyb3dzZXJcbiAgICBicm93c2VyX3BwaSA9ICQoJyNzdmctdG9vbGJveCcpLndpZHRoKCkgLyAxMC4wO1xuICAgIC8vIE5PVEUgdGhhdCB0aGlzIGlzIHN0aWxsIHVubGlrZWx5IHRvIG1hdGNoIHRoZSBwaHlzaWNhbCBzaXplIG9mIGFueSBwYXJ0aWN1bGFyIG1vbml0b3IhXG4gICAgLy8gSWYgdGhhdCdzIGltcG9ydGFudCwgd2UgbWlnaHQgd2FudCB0byBsZXQgdGhlIHVzZXIgdHdlYWsgdGhpcyB2YWx1ZS5cbiAgICAkKCcjYnJvd3Nlci1wcGktaW5kaWNhdG9yJykudGV4dChicm93c2VyX3BwaSk7XG4gICAgJCgnI2Rpc3BsYXktcHBpLWluZGljYXRvcicpLnRleHQoZGlzcGxheV9wcGkpO1xuXG4gICAgLy8gc2hvdyBvciBkaXNhYmxlIHRoZSBmdWxsLXNjcmVlbiB3aWRnZXRzXG4gICAgdmFyICRmdWxsU2NyZWVuVG9nZ2xlID0gJCgnYnV0dG9uI2VudGVyLWZ1bGwtc2NyZWVuJyk7XG4gICAgaWYgKCQuZnVsbHNjcmVlbi5pc05hdGl2ZWx5U3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gaWUsIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgZnVsbC1zY3JlZW4gQVBJc1xuICAgICAgICAkZnVsbFNjcmVlblRvZ2dsZS5zaG93KCk7XG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQoJ2ZzY3JlZW5jaGFuZ2UnLCBmdW5jdGlvbihlLCBzdGF0ZSwgZWxlbSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgY3VycmVudGx5IGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICAgICAgaWYgKCQuZnVsbHNjcmVlbi5pc0Z1bGxTY3JlZW4oKSkge1xuICAgICAgICAgICAgICAgICQoJyNlbnRlci1mdWxsLXNjcmVlbicpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKCcjZXhpdC1mdWxsLXNjcmVlbicpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgnI2VudGVyLWZ1bGwtc2NyZWVuJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICQoJyNleGl0LWZ1bGwtc2NyZWVuJykuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaW0gYW5kIGRpc2FibGUgdGhlIGZ1bGwtc2NyZWVuIHRvZ2dsZVxuICAgICAgICAkZnVsbFNjcmVlblRvZ2dsZS5jc3MoXCJvcGFjaXR5OiAwLjU7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZnVsbC1zY3JlZW4gZGlzcGxheS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgLnNob3coKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBBZGQgXCJzYWZldHkgbmV0XCIgaWYgdGhlcmUgYXJlIHVuc2F2ZWQgY2hhbmdlc1xuICAgIC8vIFRPRE86IEFkZCBKU09OIHN1cHBvcnQgZm9yIG9sZGVyIElFP1xuXG4gICAgLy8gVXBkYXRlIHRoZSBsaXN0IHdpdGggaW5pdGlhbCB2YWx1ZXNcbiAgICB1cGRhdGVBdmFpbGFibGVUcmVlcygpO1xuXG4gICAgLy8gSGFzIG15IG9wZW5lciBwcm92aWRlZCBhbiBpbml0aWFsIGlsbHVzdHJhdGlvbiBvciB0ZW1wbGF0ZT8gSWYgc28sIGxvYWQgaXQgbm93XG4gICAgdmFyIHN0YXJ0aW5nSUQgPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3N0YXJ0aW5nSUQnKTtcbiAgICBjb25zb2xlLmxvZyhcIj4+IHN0YXJ0aW5nSUQ6IFwiKyBzdGFydGluZ0lEICtcIiA8XCIrIHR5cGVvZihzdGFydGluZ0lEKSArXCI+XCIpO1xuICAgIHZhciBzdGFydGluZ1R5cGUgPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3N0YXJ0aW5nVHlwZScpO1xuICAgIGNvbnNvbGUubG9nKFwiPj4gc3RhcnRpbmdUeXBlOiBcIisgc3RhcnRpbmdUeXBlICtcIiA8XCIrIHR5cGVvZihzdGFydGluZ1R5cGUpICtcIj5cIik7XG4gICAgLy8gTi5CLiBUaGlzIHNob3VsZCBiZSBhIHN0cmluZywgc28gJzAnIGlzIGEgdmFsaWQgc2xvdCBpZGVudGlmaWVyIVxuICAgIGlmIChzdGFydGluZ0lEKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhcnRpbmdUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdJTExVU1RSQVRJT04nOlxuICAgICAgICAgICAgICAgIGZldGNoQW5kTG9hZEV4aXN0aW5nSWxsdXN0cmF0aW9uKCBzdGFydGluZ0lEICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdURU1QTEFURSc6XG4gICAgICAgICAgICAgICAgZmV0Y2hBbmRMb2FkSWxsdXN0cmF0aW9uVGVtcGxhdGUoIHN0YXJ0aW5nSUQgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHN0YXJ0aW5nVHlwZSBwcm92aWRlZCAoZXhwZWN0ZWQgJ0lMTFVTVFJBVElPTicgb3IgJ1RFTVBMQVRFJykhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRFbXB0eUlsbHVzdHJhdGlvbigpO1xuICAgIH1cblxuICAgIG1hdGNoVmlld3BvcnRUb1dpbmRvd1NpemUoKTtcblxuICAgIC8vIHJlc2l6aW5nIHRoZSB3aW5kb3cgc2hvdWxkIHJlZnJlc2gvcmVzaXplIHRoZSB2aWV3cG9ydFxuICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaFZpZXdwb3J0VG9XaW5kb3dTaXplKCk7XG4gICAgICAgICAgICB6b29tVmlld3BvcnQoJ1JFRlJFU0gnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY29tcGxldCByZXNpemU6XCIpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuZnVuY3Rpb24gYnVpbGRTdHVkeUZldGNoVVJMKCBzdHVkeUlEICkge1xuICAgIC8vIEFTU1VNRVMgd2UncmUgdXNpbmcgdGhlIHBoeWxlc3lzdGVtIEFQSSB0byBsb2FkIHN0dWRpZXMgZnJvbSB0aGUgT3BlblRyZWUgZGV2IHNpdGVcbiAgICB2YXIgdGVtcGxhdGUgPSBcImh0dHA6Ly9hcGkub3BlbnRyZWVvZmxpZmUub3JnL3BoeWxlc3lzdGVtL3YxL3N0dWR5L3tTVFVEWV9JRH0/b3V0cHV0X25leG1sMmpzb249MS4wLjAmYXV0aF90b2tlbj1BTk9OWU1PVVNcIlxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKCd7U1RVRFlfSUR9Jywgc3R1ZHlJRCk7XG59XG5cbi8qXG5mdW5jdGlvbiB1c2VDaG9zZW5TdHlsZSgpIHtcbiAgICB2aWV3TW9kZWwuc3R5bGUgPSBnZXRDaG9zZW5TdHlsZSgpO1xuICAgIHJlZnJlc2hWaXooKTtcbn1cbmZ1bmN0aW9uIGdldENob3NlblN0eWxlKCkge1xuICAgIHZhciBzdHlsZU5hbWUgPSAkKCcjc3R5bGUtY2hvb3NlcicpLnZhbCgpO1xuICAgIHJldHVybiBnZXRTdHlsZUJ5TmFtZSggc3R5bGVOYW1lICk7XG59XG5mdW5jdGlvbiBnZXRTdHlsZUJ5TmFtZSggc3R5bGVOYW1lICkge1xuICAgIHZhciBzZWxlY3RlZFN0eWxlcyA9ICQuZ3JlcChhdmFpbGFibGVTdHlsZXMsIGZ1bmN0aW9uKG8pIHtyZXR1cm4gby5uYW1lID09PSBzdHlsZU5hbWU7fSk7XG4gICAgdmFyIHN0eWxlSW5mbyA9IG51bGw7XG4gICAgaWYgKHNlbGVjdGVkU3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3R5bGVJbmZvID0gc2VsZWN0ZWRTdHlsZXNbMF07XG4gICAgfVxuICAgIGlmICghc3R5bGVOYW1lIHx8ICFzdHlsZUluZm8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gc3R5bGUgZm91bmQgdW5kZXIgJ1wiKyBzdHlsZU5hbWUgK1wiJyFcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVJbmZvLnN0eWxlO1xufVxuKi9cblxuZnVuY3Rpb24gdG9nZ2xlRml4ZWRSdWxlcnModG9nZ2xlKSB7XG4gICAgdmFyIHJ1bGVyc0FyZUhpZGRlbiA9ICQoJyN2aXotb3V0ZXItZnJhbWUnKS5oYXNDbGFzcygnaGlkZS1ydWxlcnMnKTtcbiAgICB2YXIgJHRvZ2dsZUJ0biA9ICQodG9nZ2xlKTtcbiAgICBpZiAocnVsZXJzQXJlSGlkZGVuKSB7XG4gICAgICAgIC8vIHNob3cgdGhlbSBub3dcbiAgICAgICAgJCgnI3Zpei1vdXRlci1mcmFtZScpLnJlbW92ZUNsYXNzKCdoaWRlLXJ1bGVycycpO1xuICAgICAgICAkdG9nZ2xlQnRuLnRleHQoJ0hpZGUgcnVsZXJzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGlkZSB0aGVtIG5vd1xuICAgICAgICAkKCcjdml6LW91dGVyLWZyYW1lJykuYWRkQ2xhc3MoJ2hpZGUtcnVsZXJzJyk7XG4gICAgICAgICR0b2dnbGVCdG4udGV4dCgnU2hvdyBydWxlcnMnKTtcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRWaWV3Ym94KCk7XG4gICAgem9vbVZpZXdwb3J0KCdSRUZSRVNIJyk7XG59XG5cbmZ1bmN0aW9uIGluaXRUcmVlSWxsdXN0cmF0b3JXaW5kb3coKSB7XG4gICAgdmFyICRvdXRlckZyYW1lID0gJChcIiN2aXotb3V0ZXItZnJhbWVcIik7XG4gICAgdmFyICRzY3JvbGxpbmdWaWV3cG9ydCA9ICRvdXRlckZyYW1lLmZpbmQoJ2Rpdi52ZWdhJyk7XG4gICAgdmFyICRydWxlclVuaXRzRGlzcGxheSA9ICRvdXRlckZyYW1lLmZpbmQoJyNmaXhlZC1ydWxlci11bml0cycpO1xuICAgIHZhciAkdG9wUnVsZXIgPSAkb3V0ZXJGcmFtZS5maW5kKCcjZml4ZWQtcnVsZXItdG9wJyk7XG4gICAgdmFyICRsZWZ0UnVsZXIgPSAkb3V0ZXJGcmFtZS5maW5kKCcjZml4ZWQtcnVsZXItbGVmdCcpO1xuICAgIC8vdmFyIHNjcm9sbGJhcldpZHRoID0gJHNjcm9sbGluZ1ZpZXdwb3J0WzBdLm9mZnNldFdpZHRoIC0gJHNjcm9sbGluZ1ZpZXdwb3J0WzBdLmNsaWVudFdpZHRoO1xuICAgIHZhciB0b3BSdWxlckFkanVzdGVkV2lkdGggPSAkc2Nyb2xsaW5nVmlld3BvcnRbMF0uY2xpZW50V2lkdGg7XG4gICAgdmFyIGxlZnRSdWxlckFkanVzdGVkSGVpZ2h0ID0gJHNjcm9sbGluZ1ZpZXdwb3J0WzBdLmNsaWVudEhlaWdodDtcblxuICAgICRydWxlclVuaXRzRGlzcGxheS5jc3Moe1xuICAgICAgICAnd2lkdGgnOiBydWxlcldpZHRoICtcInB4XCIsXG4gICAgICAgICdoZWlnaHQnOiBydWxlcldpZHRoICtcInB4XCIsXG4gICAgICAgICdsaW5lLWhlaWdodCc6IHJ1bGVyV2lkdGggK1wicHhcIixcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IE1hdGguZmxvb3IocnVsZXJXaWR0aCAvIDIuNSkgK1wicHhcIlxuICAgIH0pO1xuICAgICR0b3BSdWxlci5jc3Moe1xuICAgICAgICAnaGVpZ2h0JzogcnVsZXJXaWR0aCtcInB4XCIsXG4gICAgICAgIC8vIGFkanVzdCB3aWR0aCBzaW5jZSB0aGVyZSdzIG5vIHNjcm9sbGJhciBoZXJlXG4gICAgICAgICd3aWR0aCc6IHRvcFJ1bGVyQWRqdXN0ZWRXaWR0aCArJ3B4JyxcbiAgICAgICAgJ21hcmdpbi1yaWdodCc6IC1ydWxlcldpZHRoK1wicHhcIlxuICAgIH0pO1xuICAgICRsZWZ0UnVsZXIuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogcnVsZXJXaWR0aCtcInB4XCIsXG4gICAgICAgIC8vIGFkanVzdCBoZWlnaHQgc2luY2UgdGhlcmUncyBubyBzY3JvbGxiYXIgaGVyZVxuICAgICAgICAnaGVpZ2h0JzogbGVmdFJ1bGVyQWRqdXN0ZWRIZWlnaHQgKydweCcsXG4gICAgICAgICdtYXJnaW4tYm90dG9tJzogLXJ1bGVyV2lkdGgrXCJweFwiXG4gICAgfSk7XG4gICAgJHNjcm9sbGluZ1ZpZXdwb3J0LmNzcygnbWFyZ2luLXJpZ2h0JywgLShydWxlcldpZHRoKzEpK1wicHhcIik7XG5cbiAgICAvLyByZXNldCB1bml0cyBkaXNwbGF5OyBjbGVhciBvbGQgcnVsZXJzXG4gICAgJHJ1bGVyVW5pdHNEaXNwbGF5LnRleHQoIGlsbC5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gVHJlZUlsbHVzdHJhdG9yLnVuaXRzLklOQ0hFUyA/IFwiaW5cIiA6IFwiY21cIiApO1xuICAgIFxuICAgIC8vIGFkanVzdCB2aWV3cG9ydC92aWV3Ym94IHRvIHJlZmxlY3QgY3VycmVudCBtYWduaWZpY2F0aW9uIChkaXNwbGF5X3BwaSlcbiAgICB1cGRhdGVWaWV3cG9ydFZpZXdib3goICRzY3JvbGxpbmdWaWV3cG9ydCApO1xuXG4gICAgLy8gc3luYyBzY3JvbGxpbmcgb2YgcnVsZXJzIHRvIHZpZXdwb3J0XG4gICAgLy9UT0RPOiBkZWxlZ2F0ZSB0aGVzZSBmb3Igb25lLXRpbWUgY2FsbCFcbiAgICAkc2Nyb2xsaW5nVmlld3BvcnQub2ZmKCdzY3JvbGwnKS5vbignc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICR0b3BSdWxlci5zY3JvbGxMZWZ0KCRzY3JvbGxpbmdWaWV3cG9ydC5zY3JvbGxMZWZ0KCkpO1xuICAgICAgICAkbGVmdFJ1bGVyLnNjcm9sbFRvcCgkc2Nyb2xsaW5nVmlld3BvcnQuc2Nyb2xsVG9wKCkpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIHN5bmMgcmVzaXppbmcgb2YgcnVsZXJzIHRvIHZpZXdwb3J0XG4gICAgLy8gKG5vIGV2ZW50IGZvciB0aGlzIGV4Y2VwdCBvbiB0aGUgd2luZG93LCBpdCdzIGFuIG9uLWRlbWFuZCB0aGluZylcbiAgICB2YXIgdmlld3BvcnRXaWR0aCA9ICRzY3JvbGxpbmdWaWV3cG9ydFswXS5zY3JvbGxXaWR0aDtcbiAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSAkc2Nyb2xsaW5nVmlld3BvcnRbMF0uc2Nyb2xsSGVpZ2h0O1xuICAgIHZhciB0b3BSdWxlclNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbXG4gICAgICAgICAgICBwaXhlbHNUb1BoeXNpY2FsVW5pdHModmlld2JveC54LCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgcGl4ZWxzVG9QaHlzaWNhbFVuaXRzKHZpZXdib3gueCArIHZpZXdib3gud2lkdGgsIGludGVybmFsX3BwaSlcbiAgICAgICAgXSlcbiAgICAgICAgLnJhbmdlKFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB2aWV3cG9ydFdpZHRoXG4gICAgICAgIF0pO1xuICAgIHZhciB0b3BSdWxlciA9IGQzLnNlbGVjdChcIiNmaXhlZC1ydWxlci10b3Agc3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgdmlld3BvcnRXaWR0aCtcInB4XCIpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHJ1bGVyV2lkdGgrXCJweFwiKTtcbiAgICBkcmF3UnVsZXIodG9wUnVsZXIsICdIT1JJWk9OVEFMJywgaWxsLnN0eWxlLnByaW50U2l6ZS51bml0cygpLCB0b3BSdWxlclNjYWxlKTtcblxuICAgIHZhciBsZWZ0UnVsZXJTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW1xuICAgICAgICAgICAgcGl4ZWxzVG9QaHlzaWNhbFVuaXRzKHZpZXdib3gueSwgaW50ZXJuYWxfcHBpKSxcbiAgICAgICAgICAgIHBpeGVsc1RvUGh5c2ljYWxVbml0cyh2aWV3Ym94LnkgKyB2aWV3Ym94LmhlaWdodCwgaW50ZXJuYWxfcHBpKVxuICAgICAgICBdKVxuICAgICAgICAucmFuZ2UoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0XG4gICAgICAgIF0pO1xuICAgIHZhciBsZWZ0UnVsZXIgPSBkMy5zZWxlY3QoXCIjZml4ZWQtcnVsZXItbGVmdCBzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBydWxlcldpZHRoK1wicHhcIilcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgdmlld3BvcnRIZWlnaHQrXCJweFwiKTtcbiAgICBkcmF3UnVsZXIobGVmdFJ1bGVyLCAnVkVSVElDQUwnLCBpbGwuc3R5bGUucHJpbnRTaXplLnVuaXRzKCksIGxlZnRSdWxlclNjYWxlKTtcbiAgICBcbiAgICBlbmFibGVWaWV3cG9ydE1hc2soKTtcbn1cblxuZnVuY3Rpb24gcm91bmRUb05lYXJlc3QoIGludGVydmFsLCBpbnB1dCApIHtcbiAgICAvLyByb3VuZCB0byBzb21ldGhpbmcgbW9yZSBpbnRlcmVzdGluZyB0aGFuIFwiYW55IGludGVnZXJcIlxuICAgIC8vIEVYQU1QTEU6IHJvdW5kVG9OZWFyZXN0KCAwLjEyNSwgLTAuNTIgKSA9PT4gIC0wLjVcbiAgICAvLyBFWEFNUExFOiByb3VuZFRvTmVhcmVzdCggNywgNDYgKSA9PT4gIDQ5XG4gICAgcmV0dXJuIE1hdGgucm91bmQoaW5wdXQgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbDtcbn1cblxuZnVuY3Rpb24gZHJhd1J1bGVyKCBzdmdQYXJlbnQsIG9yaWVudGF0aW9uLCB1bml0cywgc2NhbGUgKSB7XG4gICAgLyogRHJhdyBhIHJ1bGVyIGluIHRoZSBjaG9zZW4gY29udGV4dCAoYXNzdW1lcyBTVkcgb3IgY2hpbGQgb2YgYW4gU1ZHKSwgd2l0aFxuICAgICAgICAtIGFwcHJvcHJpYXRlIHVuaXRzXG4gICAgICAgIC0gc2Vuc2libGUvbGVnaWJsZSBzdWJ0aWNrcyAoZWcsIG1pbGxpbWV0ZXJzIG9yIHNpeHRlZW50aHMgb2YgYW4gaW5jaCkgXG4gICAgICAgIC0gc2l6ZSBhbmQgYWRqdXN0IGJhc2VkIG9uIG9yaWVudGF0aW9uIChIT1JJWk9OVEFMIHwgVkVSVElDQUwpXG4gICAgICovXG4gICAgLy8gY2xlYXIgYW55IHByaW9yIHJ1bGVyIGdyb3VwXG4gICAgc3ZnUGFyZW50LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgIHZhciBudWRnZVRvcCA9IG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gMCA6IHJ1bGVyV2lkdGggLSAxO1xuICAgIHZhciBudWRnZUxlZnQgPSBvcmllbnRhdGlvbiA9PT0gJ1ZFUlRJQ0FMJyA/IHJ1bGVyV2lkdGggLSAxIDogMDtcblxuICAgIHZhciBydWxlckF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgLnRpY2tWYWx1ZXMoZDMucmFuZ2UoXG4gICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgxLjAsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgxLjAsIHNjYWxlLmRvbWFpbigpWzFdICsgMSksIFxuICAgICAgICAgICAgMSkpXG4gICAgICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnZCcpKSAgLy8gd2hvbGUgbnVtYmVyc1xuICAgICAgICAub3JpZW50KCBvcmllbnRhdGlvbiA9PT0gJ1ZFUlRJQ0FMJyA/ICdsZWZ0JyA6ICd0b3AnICk7XG5cbiAgICBzdmdQYXJlbnRcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzJylcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgIC5jYWxsKHJ1bGVyQXhpcyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdJTkNIRVMnKSB7XG4gICAgICAgIC8vIHRyeWluZyBzdWJ0aWNrcywgdXNpbmcgYWRkaXRpb25hbCBheGVzIG9uIHRoZSBzYW1lIHNjYWxlXG4gICAgICAgIHZhciBpbmNoV2lkdGggPSBpbmNoZXNUb1BpeGVscygxLCBkaXNwbGF5X3BwaSk7XG4gICAgICAgIHN1YnRpY2tzQXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgIC50aWNrVmFsdWVzKGQzLnJhbmdlKFxuICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuNSwgc2NhbGUuZG9tYWluKClbMF0pLCBcbiAgICAgICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgwLjUsIHNjYWxlLmRvbWFpbigpWzFdKSwgXG4gICAgICAgICAgICAgICAgMC41KSlcbiAgICAgICAgICAgIC50aWNrRm9ybWF0KCcnKSAvLyB1bmxhYmVsZWRcbiAgICAgICAgICAgIC50aWNrU2l6ZSg2KVxuICAgICAgICAgICAgLm9yaWVudCggb3JpZW50YXRpb24gPT09ICdWRVJUSUNBTCcgPyAnbGVmdCcgOiAndG9wJyApO1xuICAgICAgICBzdmdQYXJlbnRcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsJ291dGVyLWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuXG4gICAgICAgIHN1YnRpY2tzQXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgIC50aWNrVmFsdWVzKGQzLnJhbmdlKFxuICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuMjUsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4yNSwgc2NhbGUuZG9tYWluKClbMV0pLCBcbiAgICAgICAgICAgICAgICAwLjI1KSlcbiAgICAgICAgICAgIC50aWNrRm9ybWF0KCcnKSAvLyB1bmxhYmVsZWRcbiAgICAgICAgICAgIC50aWNrU2l6ZSg0KVxuICAgICAgICAgICAgLm9yaWVudCggb3JpZW50YXRpb24gPT09ICdWRVJUSUNBTCcgPyAnbGVmdCcgOiAndG9wJyApO1xuICAgICAgICBzdmdQYXJlbnRcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsJ291dGVyLWF4aXMgc3VidGlja3MnKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuXG4gICAgICAgIGlmIChpbmNoV2lkdGggPiAyMCkge1xuICAgICAgICAgICAgc3VidGlja3NBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyhkMy5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4xMjUsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuMTI1LCBzY2FsZS5kb21haW4oKVsxXSksIFxuICAgICAgICAgICAgICAgICAgICAwLjEyNSkpXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoJycpIC8vIHVubGFiZWxlZFxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgyKVxuICAgICAgICAgICAgICAgIC5vcmllbnQoIG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gJ2xlZnQnIDogJ3RvcCcgKTtcbiAgICAgICAgICAgIHN2Z1BhcmVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzIHN1YnRpY2tzJylcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgbnVkZ2VMZWZ0ICtcIiwgXCIrIG51ZGdlVG9wICtcIilcIilcbiAgICAgICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJhdyB0aWNrcyBmb3IgbWlsbGltZXRlcnNcbiAgICAgICAgdmFyIGNtV2lkdGggPSBjZW50aW1ldGVyc1RvUGl4ZWxzKDEsIGRpc3BsYXlfcHBpKTtcbiAgICAgICAgaWYgKGNtV2lkdGggPiAzMCkge1xuICAgICAgICAgICAgc3VidGlja3NBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyhkMy5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4xLCBzY2FsZS5kb21haW4oKVswXSksIFxuICAgICAgICAgICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgwLjEsIHNjYWxlLmRvbWFpbigpWzFdKSwgXG4gICAgICAgICAgICAgICAgICAgIDAuMSkpXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoJycpIC8vIHVubGFiZWxlZFxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgzKVxuICAgICAgICAgICAgICAgIC5vcmllbnQoIG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gJ2xlZnQnIDogJ3RvcCcgKTtcbiAgICAgICAgICAgIHN2Z1BhcmVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzIHN1YnRpY2tzJylcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgbnVkZ2VMZWZ0ICtcIiwgXCIrIG51ZGdlVG9wICtcIilcIilcbiAgICAgICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgdG9wQmFySGVpZ2h0LCBib3R0b21CYXJIZWlnaHQ7XG5mdW5jdGlvbiBtYXRjaFZpZXdwb3J0VG9XaW5kb3dTaXplKCkge1xuICAgIGlmICghdG9wQmFySGVpZ2h0KSB7XG4gICAgICAgIHRvcEJhckhlaWdodCA9ICQoJyN2aXotdG9wLWNvbnRyb2wtYmFyJykuaGVpZ2h0KCk7XG4gICAgICAgIGJvdHRvbUJhckhlaWdodCA9ICQoJyN2aXotYm90dG9tLWNvbnRyb2wtYmFyJykuaGVpZ2h0KCk7XG4gICAgICAgIC8vIGZyZWV6ZSB0aGUgY29udHJvbCBiYXJzIGF0IHRoZWlyIGN1cnJlbnQgaGVpZ2h0ICAgICAgICBcbiAgICAgICAgJCgnI3Zpei10b3AtY29udHJvbC1iYXInKS5oZWlnaHQodG9wQmFySGVpZ2h0KTtcbiAgICAgICAgJCgnI3Zpei1ib3R0b20tY29udHJvbC1iYXInKS5oZWlnaHQoYm90dG9tQmFySGVpZ2h0KTtcbiAgICB9XG4gICAgdmFyIGNvbHVtbkhlaWdodCA9ICQoJyNzdGlja3ktdmlld2VyLWZyYW1lJykuaGVpZ2h0KCk7XG4gICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IGNvbHVtbkhlaWdodCAtIHRvcEJhckhlaWdodCAtIGJvdHRvbUJhckhlaWdodDtcbiAgICB2YXIgJG91dGVyRnJhbWUgPSAkKFwiI3Zpei1vdXRlci1mcmFtZVwiKTtcbiAgICB2YXIgbnVkZ2UgPSAtNjA7XG4gICAgJG91dGVyRnJhbWUuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCArIG51ZGdlKTtcbn1cblxudmFyIHZpZXdwb3J0TWFnbmlmaWNhdGlvbiA9IDEuMDtcbmZ1bmN0aW9uIHpvb21WaWV3cG9ydCggZGlyZWN0aW9uT3Jab29tTGV2ZWwgKSB7XG4gICAgLy8gbGV0J3MgdXNlIHNpbXBsZSwgcHJvcG9ydGlvbmFsIHN0ZXBzIHVwIGFuZCBkb3duXG4gICAgdmFyIHN0ZXBVcCA9IDEuMjU7XG4gICAgdmFyIHN0ZXBEb3duID0gMC44OyAgLy8gc2hvdWxkIGJlIGludmVyc2Ugb2Ygc3RlcFVwXG4gICAgdmFyIHByZXZpb3VzTWFnbmlmaWNhdGlvbiA9IHZpZXdwb3J0TWFnbmlmaWNhdGlvbjtcblxuICAgIHN3aXRjaChkaXJlY3Rpb25Pclpvb21MZXZlbCkge1xuICAgICAgICBjYXNlICdSRUZSRVNIJzpcbiAgICAgICAgICAgIC8vIGp1c3QgdXBkYXRlIGF0IHRoZSBjdXJyZW50IG1hZ25pZmljYXRpb24gKGUuZy4gd2hlbiB3aW5kb3cgaXMgcmVzaXplZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJTic6XG4gICAgICAgICAgICB2aWV3cG9ydE1hZ25pZmljYXRpb24gKj0gc3RlcFVwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09VVCc6XG4gICAgICAgICAgICB2aWV3cG9ydE1hZ25pZmljYXRpb24gKj0gc3RlcERvd247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogXG4gICAgICAgICAgICAvLyBhc3N1bWUgaXQncyBhbiBleHBsaWNpdCB6b29tIGxldmVsLCB3aGVyZSAxLjAgbWVhbnMgXCJhY3R1YWwgc2l6ZVwiXG4gICAgICAgICAgICB2aWV3cG9ydE1hZ25pZmljYXRpb24gPSBkaXJlY3Rpb25Pclpvb21MZXZlbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkaXNwbGF5X3BwaSA9IGludGVybmFsX3BwaSAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbjtcbiAgICAkKCcjZGlzcGxheS1wcGktaW5kaWNhdG9yJykudGV4dChkaXNwbGF5X3BwaSk7XG5cbiAgICAvLyBUT0RPOiByZXNldCBjZW50ZXIgcG9pbnQgb2Ygdmlld2JveD8gYmFzZWQgb24gY2xpY2sgWFksIG9yIGN1cnJlbnQgY2VudGVyP1xuICAgIC8vIFRPRE86IHVwZGF0ZSBzY3JvbGxUb3AsIHNjcm9sbExlZnQgdG8gc3RheSBpbiBwbGFjZT9cblxuICAgIGluaXRUcmVlSWxsdXN0cmF0b3JXaW5kb3coKTtcbn1cblxuZnVuY3Rpb24gcmVzaXplVmlld3BvcnRUb1Nob3dBbGwoKSB7XG4gICAgLy8gc2hvdyBmdWxsIGlsbHVzdHJhdGlvbiBib3VuZHMgKGFuZCBhbGwgU1ZHIGVsZW1lbnRzISkgaW4gdGhlIHZpZXdwb3J0XG4gICAgdmFyIGJib3ggPSBnZXRJbmNsdXNpdmVJbGx1c3RyYXRpb25Cb3VuZGluZ0JveCgpO1xuXG4gICAgLy8gbWF0Y2ggdGhlIHZpZXdwb3J0J3MgcHJvcG9ydGlvbnMgKHdpZHRoL2hlaWdodClcbiAgICB2YXIgJHZpZXdwb3J0ID0gJChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2FcIik7XG4gICAgLy8gTk9URSB0aGF0IHdlIHdhbnQgdG8gbWF0Y2ggaXRzICppbm5lciogc2l6ZSwgbm90IGluY2wuIHNjcm9sbGJhcnMhXG4gICAgdmFyIGRpdldpZHRoID0gJHZpZXdwb3J0WzBdLmNsaWVudFdpZHRoO1xuICAgIHZhciBkaXZIZWlnaHQgPSAkdmlld3BvcnRbMF0uY2xpZW50SGVpZ2h0O1xuICAgIC8vIGNvbXBhcmUgaXRzIHByb3BvcnRpb25zIHRvIG91ciBib3VuZGluZyBib3g7IHBhZCBhcyBuZWVkZWQgdG8gbWF0Y2hcbiAgICAvLyBUT0RPOiB0aGlzIGlzIGR1cGxpY2F0ZSBjb2RlISByZWZhY3RvciB0byBEUllcbiAgICB2YXIgZGl2UHJvcG9ydGlvbnMgPSBkaXZXaWR0aCAvIGRpdkhlaWdodDtcbiAgICB2YXIgYmJveFByb3BvcnRpb25zID0gYmJveC53aWR0aCAvIGJib3guaGVpZ2h0O1xuICAgIGlmIChkaXZQcm9wb3J0aW9ucyA+IGJib3hQcm9wb3J0aW9ucykge1xuICAgICAgICAvLyBkaXYgaXMgd2lkZXIsIHBhZCBiYm94IHdpZHRoIHRvIG1hdGNoXG4gICAgICAgIHZhciBhZGp1c3RlZFdpZHRoID0gZGl2UHJvcG9ydGlvbnMgKiBiYm94LmhlaWdodDtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBhZGp1c3RlZFdpZHRoIC0gYmJveC53aWR0aDtcbiAgICAgICAgYmJveC53aWR0aCA9IGFkanVzdGVkV2lkdGg7XG4gICAgICAgIGJib3gueCAtPSAoZXh0cmFXaWR0aCAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpdiBpcyB0YWxsZXIgKG9yIGVxdWFsKSwgcGFkIGJib3ggaGVpZ2h0IHRvIG1hdGNoXG4gICAgICAgIHZhciBmbGlwcGVkRGl2UHJvcG9ydGlvbnMgPSBkaXZIZWlnaHQgLyBkaXZXaWR0aDtcbiAgICAgICAgdmFyIGFkanVzdGVkSGVpZ2h0ID0gZmxpcHBlZERpdlByb3BvcnRpb25zICogYmJveC53aWR0aDtcbiAgICAgICAgdmFyIGV4dHJhSGVpZ2h0ID0gYWRqdXN0ZWRIZWlnaHQgLSBiYm94LmhlaWdodDtcbiAgICAgICAgYmJveC5oZWlnaHQgPSBhZGp1c3RlZEhlaWdodDtcbiAgICAgICAgYmJveC54IC09IChleHRyYUhlaWdodCAvIDIpO1xuICAgIH1cblxuICAgIC8vIGNvcHkgdG8gb3VyIHBlcnNpc3RlbnQgdmlld2JveFxuICAgIGZvciAodmFyIHByb3AgaW4gYmJveCkge1xuICAgICAgICB2aWV3Ym94W3Byb3BdID0gYmJveFtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBtYXRjaCB0aGUgdmlld3BvcnQncyBmaW5hbCBzaXplIChkaXNhYmxlZCBzY3JvbGxiYXJzKT9cbiAgICBcbiAgICAvKiBTY2FsZSB0aGUgcHJvcG9ydGlvbmFsIFNWRyB0byBmaXQgdGhlIHZpZXdwb3J0IERJVi4gVG8gZG8gdGhpcywgd2VcbiAgICAgKiBkZXRlcm1pbmUgaG93IGJpZyB0aGUgbmV3IHZpZXdib3ggd291bGQgYmUgaW4gcGl4ZWxzICh1c2luZyBkZWZhdWx0X3BwaSlcbiAgICAgKiBhbmQgbWFnbmlmeSB0aGlzIHRvIGZpdCB0aGUgdmlld3BvcnRESVYuXG4gICAgICovXG4gICAgdmFyIG5ld01hZ25pZmljYXRpb24gPSBkaXZXaWR0aCAvIHZpZXdib3gud2lkdGg7XG4gICAgLy8gdXBkYXRlIHRoZSBkaXNwbGF5XG4gICAgem9vbVZpZXdwb3J0KCBuZXdNYWduaWZpY2F0aW9uICk7ICAvLyBjYWxscyBpbml0VHJlZUlsbHVzdHJhdG9yV2luZG93KCk7XG59XG5mdW5jdGlvbiBnZXRNaW5pbWFsSWxsdXN0cmF0aW9uQm91bmRpbmdCb3goKSB7XG4gICAgLy8gUmV0dXJuIGp1c3QgdGhlIHJlZ2lvbiBkZWZpbmVkIGZvciBwcmludGluZyAoY29weWluZyBpdHMgcHJvcGVydGllc1xuICAgIC8vIHRvIGEgc2ltcGxlIE9iamVjdCwgdG8gcHJldmVudCBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciBpbiBJRSlcbiAgICB2YXIgYmJveCA9ICQoJyNpbGx1c3RyYXRpb24tYmFja2dyb3VuZCcpWzBdLmdldEJCb3goKTtcbiAgICByZXR1cm4gJC5leHRlbmQoe30sIGJib3gpO1xufVxuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlSWxsdXN0cmF0aW9uQm91bmRpbmdCb3goKSB7XG4gICAgLy8gRmV0Y2ggdGhlIHJlZ2lvbiBkZWZpbmVkIGZvciBwcmludGluZywgUExVUyBhbnkgXCJvdXQgb2YgYm91bmRzXCIgU1ZHXG4gICAgLy8gZWxlbWVudHMuIEFnYWluLCB3ZSdsbCBjb3B5aW5nIGl0cyBwcm9wZXJ0aWVzIHRvIGEgc2ltcGxlIE9iamVjdCwgdG9cbiAgICAvLyBwcmV2ZW50IE5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yIGluIElFLlxuICAgIHZhciBiYm94ID0gZDMuc2VsZWN0KCdnLmlsbHVzdHJhdGlvbi1lbGVtZW50cycpLm5vZGUoKS5nZXRCQm94KCk7XG4gICAgLyogUkVNSU5ERVI6IFRoaXMgZGVzaWduYXRlZCBncm91cCBzaG91bGQgY29udGFpbiBhbGwgaWxsdXN0cmF0aW9uIGVsZW1lbnRzXG4gICAgICAgYW5kIGFuIGludmlzaWJsZSBib3ggbWF0Y2hpbmcgdGhlIHByaW50ZWQgYXJlYS4gKi9cbiAgICByZXR1cm4gJC5leHRlbmQoe30sIGJib3gpO1xufVxuZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY0JvdW5kaW5nQm94KCkge1xuICAgIC8vIGdhdGhlciBvdXRlcm1vc3QgYm91bmRzIGJhc2VkIG9uIGRpYWdub3N0aWMgZWxlbWVudHMgZm91bmRcbiAgICB2YXIgYmJveCA9IGdldE1pbmltYWxJbGx1c3RyYXRpb25Cb3VuZGluZ0JveCgpO1xuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIHZhciBydWxlcnMgPSB2aWV3cG9ydFNWRy5zZWxlY3QoXCIjcnVsZXJzXCIpLm5vZGUoKTtcbiAgICBpZiAocnVsZXJzKSB7XG4gICAgICAgIGJib3ggPSBnZXRDb21iaW5lZEJvdW5kaW5nQm94KCBiYm94LCBydWxlcnMuZ2V0QkJveCgpICk7XG4gICAgfVxuICAgIHZhciBjcm9wbWFya3MgPSB2aWV3cG9ydFNWRy5zZWxlY3QoXCIjY3JvcC1tYXJrc1wiKS5ub2RlKCk7XG4gICAgaWYgKGNyb3BtYXJrcykge1xuICAgICAgICBiYm94ID0gZ2V0Q29tYmluZWRCb3VuZGluZ0JveCggYmJveCwgY3JvcG1hcmtzLmdldEJCb3goKSApO1xuICAgIH1cbiAgICB2YXIgZGVzY3JpcHRpb24gPSB2aWV3cG9ydFNWRy5zZWxlY3QoXCIjZGVzY3JpcHRpb25cIikubm9kZSgpO1xuICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICBiYm94ID0gZ2V0Q29tYmluZWRCb3VuZGluZ0JveCggYmJveCwgZGVzY3JpcHRpb24uZ2V0QkJveCgpICk7XG4gICAgfVxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYmJveCk7XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZEJvdW5kaW5nQm94KCBib3gxLCBib3gyICkge1xuICAgIC8vIHJlY2tvbiB0aGUgXCJ1bmlvblwiIG9mIHR3byBib3VuZGluZyBib3hlc1xuICAgIHZhciBiYm94ID0gJC5leHRlbmQoe30sIGJveDEpO1xuICAgIC8vIGNvbXBhcmUgKG9idmlvdXMpIGxlZnQgYW5kIHRvcCBleHRlbnRzXG4gICAgdmFyIGJib3hMZWZ0ID0gYmJveC54O1xuICAgIHZhciBib3gyTGVmdCA9IGJveDIueDtcbiAgICBpZiAoYm94MkxlZnQgPCBiYm94TGVmdCkge1xuICAgICAgICAvLyBpbmNyZWFzZSB3aWR0aCwgdGhlbiByZXNldCBsZWZ0IGVkZ2VcbiAgICAgICAgYmJveC53aWR0aCA9IGJib3gud2lkdGggKyAoYmJveExlZnQgLSBib3gyTGVmdCk7XG4gICAgICAgIGJib3gueCA9IGJveDJMZWZ0O1xuICAgIH1cbiAgICB2YXIgYmJveFRvcCA9IGJib3gueTtcbiAgICB2YXIgYm94MlRvcCA9IGJveDIueTtcbiAgICBpZiAoYm94MlRvcCA8IGJib3hUb3ApIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgaGVpZ2h0LCB0aGVuIHJlc2V0IHRvcCBlZGdlXG4gICAgICAgIGJib3guaGVpZ2h0ID0gYmJveC5oZWlnaHQgKyAoYmJveFRvcCAtIGJveDJUb3ApO1xuICAgICAgICBiYm94LnkgPSBib3gyVG9wO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIChpbXBsaWNpdCkgcmlnaHQgYW5kIGJvdHRvbSBleHRlbnRzXG4gICAgdmFyIGJib3hSaWdodCA9IGJib3gueCArIGJib3gud2lkdGg7XG4gICAgdmFyIGJveDJSaWdodCA9IGJveDIueCArIGJveDIud2lkdGg7XG4gICAgaWYgKGJveDJSaWdodCA+IGJib3hSaWdodCkge1xuICAgICAgICBiYm94LndpZHRoID0gYm94MlJpZ2h0IC0gYmJveC54O1xuICAgIH1cbiAgICB2YXIgYmJveEJvdHRvbSA9IGJib3gueSArIGJib3guaGVpZ2h0O1xuICAgIHZhciBib3gyQm90dG9tID0gYm94Mi55ICsgYm94Mi5oZWlnaHQ7XG4gICAgaWYgKGJveDJCb3R0b20gPiBiYm94Qm90dG9tKSB7XG4gICAgICAgIGJib3guaGVpZ2h0ID0gYm94MkJvdHRvbSAtIGJib3gueTtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG59XG5cbi8qIEFubm95aW5nIGJyb3dzZXIgcXVpcmshIEZpcmVmb3gvTWFjIChhbmQgcG9zc2libHkgb3RoZXJzPykgaGF2ZSBkaWZmZXJlbnQgU1ZHXG4gKiBtYXNraW5nIGJlaGF2aW9yLCB3aGVyZSB0aGUgbWFzayBpdHNlbGYgbXVzdCB0cmFuc2Zvcm0gYWxvbmcgd2l0aCB0aGUgU1ZHIGl0IGlzXG4gKiBtYXNraW5nLiBJbiB0aGVzZSBjYXNlcywgd2UgbmVlZCB0byBtYXRjaCBzY2FsZSBhbmQgXCJpbnZlcnRcIiBYIGFuZCBZXG4gKiBwb3NpdGlvbiBvZiB0aGUgbWFzay5cbiAqL1xudmFyIHN2Z01hc2tSZXF1aXJlc1RyYW5zZm9ybSA9ICQuYnJvd3Nlci5tb3ppbGxhOyAgLy8gICYmICQuYnJvd3Nlci52ZXJzaW9uIDwgXCIzNVwiO1xuLyogTk9URSB0aGF0IHRlc3QgdGhpcyB3aWxsIGZhaWwgd2hlbiB3ZSB1cGdyYWRlIHRvIGpRdWVyeSAxLjkrISBJbiB0aGF0IGNhc2UsIGNvbnNpZGVyOlxuICAgICogdGhlIGpRdWVyeSBNaWdyYXRlIHBsdWdpbiBvciB0aGlzIHNuaXBwZXQ6XG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1taWdyYXRlL2Jsb2IvZTZiZGE2YTg0YzI5NGViMTMxOWZjZWI0OGMwOWY1MTA0MmM4MDg5Mi9zcmMvY29yZS5qcyNMNTBcbiAgICAqIE1vZGVybml6ciAodGhvdWdoIGl0IGRvZXNuJ3Qgc2VlbSB0byBkZXRlY3QgdGhpcyBwYXJ0aWN1bGFyIHF1aXJrKVxuICAgICogc25pZmZpbmcgdGhlIEpTICduYXZpZ2F0b3InIG9iamVjdCBmb3IgbW9yZSBpbmZvcm1hdGlvbiAgXG4gKi9cblxuLyogTWFuYWdlIHJlLXVzYWJsZSBTVkcgZWxlbWVudHMgaW4gdGhlIHZpZXdwb3J0LiBUaGVzZSBhcmUgdHlwaWNhbGx5IGRlZmluZWRcbiAgIGluIGEgcGVyc2lzdGVudCBTVkcgZGVmcyBlbGVtZW50LCB3aGVyZSB0aGV5IGNhbiBiZSBtb2RpZmllZCBhbmQgcmUtdXNlZFxuICAgKGluY2x1ZGluZyBtdWx0aXBsZSBpbnN0YW5jZXMpIGZvciBtYXNraW5nLCBjbGlwcGluZywgYW5kIG9wdGlvbmFsIHByaW50ZWRcbiAgIG91dHB1dCBsaWtlIGNyb3AgbWFya3MgYW5kIGRpYWdub3N0aWMgcnVsZXJzLlxuXG4gICBOT1RFIHRoYXQgd2UgbmVlZCB0byB1c2UgZDMgdG8gY3JlYXRlIFNWRyBlbGVtZW50cy4galF1ZXJ5IGZsdWJzIHRoZVxuICAgbmFtZXNwYWNlcyFcbiovXG5mdW5jdGlvbiBlbmFibGVWaWV3cG9ydE1hc2soKSB7XG4gICAgLy92YXIgdG9vbGJveFNWRyA9IGQzLnNlbGVjdEFsbChcIiNzdmctdG9vbGJveFwiKTtcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICBpZiAodmlld3BvcnRTVkcuZW1wdHkoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJlbmFibGVWaWV3cG9ydE1hc2soKTogdmlld3BvcnQgU1ZHIG5vdCBmb3VuZCFcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWFzayA9IGQzLnNlbGVjdCgnI3ZpZXdwb3J0LW1hc2snKTtcblxuICAgIGlmIChzdmdNYXNrUmVxdWlyZXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gc2V0IGV4cGxpY2l0IHNpemUgYW5kIHNjYWxlIGZvciB0aGUgdmlld3BvcnQgbWFzayBpdHNlbGZcbiAgICAgICAgZDMuc2VsZWN0KFwiI3ZpZXdwb3J0LW1hc2tcIilcbiAgICAgICAgICAgIC5hdHRyKCdtYXNrVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdmlld2JveC53aWR0aCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbilcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB2aWV3Ym94LmhlaWdodCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgICAgIC8vIHNjYWxlIHRoZSBtYXNrICE/IHNlZW1zIHRvIGJlIHJlcXVpcmVkIGZvciBGRi9NYWMsIGF0IGxlYXN0XG4gICAgICAgIHZhciBtYXNrR3JvdXBUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcrIC0odmlld2JveC54ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKSArJywnKyAtKHZpZXdib3gueSAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbikgKycpIHNjYWxlKCcrIHZpZXdwb3J0TWFnbmlmaWNhdGlvbiArJyknO1xuICAgICAgICAvL2NvbnNvbGUubG9nKG1hc2tHcm91cFRyYW5zZm9ybSk7XG4gICAgICAgIGQzLnNlbGVjdChcIiNtYXNrLXNoYXBlc1wiKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIG1hc2tHcm91cFRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gbWF0Y2ggdGhlIG1hc2sncyB2aWV3cG9ydC1ib3VuZHMgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZVxuICAgIGQzLnNlbGVjdChcIiN2aWV3cG9ydC1ib3VuZHNcIilcbiAgICAgICAgLmF0dHIoJ3gnLCB2aWV3Ym94LngpXG4gICAgICAgIC5hdHRyKCd5Jywgdmlld2JveC55KVxuICAgICAgICAuYXR0cignd2lkdGgnLCB2aWV3Ym94LndpZHRoKVxuICAgICAgICAuYXR0cignaGVpZ2h0Jywgdmlld2JveC5oZWlnaHQpO1xuICAgIC8vIG1hdGNoIHRoZSBtYXNrJ3MgaWxsdXN0cmF0aW9uLWJvdW5kcyB0byB0aGUgY3VycmVudCBpbGx1c3RyYXRpb24gc2l6ZVxuICAgIGQzLnNlbGVjdChcIiNpbGx1c3RyYXRpb24tYm91bmRzXCIpXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAuYXR0cignd2lkdGgnLCBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpLCBpbnRlcm5hbF9wcGkpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUuaGVpZ2h0KCksIGludGVybmFsX3BwaSkpO1xuXG4gICAgLy8gYXNzaWduIHRoZSBtYXNrIHRvIHRoZSBtYWluIHZpZXdwb3J0IChmYWRlcyBzdHVmZiBvdXRzaWRlIHRoZSBwcmludCBhcmVhKVxuICAgIHZpZXdwb3J0U1ZHLmF0dHIoJ21hc2snLCAndXJsKCN2aWV3cG9ydC1tYXNrKScpO1xuXG4gICAgaWYgKHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiN2aWV3cG9ydC1iYWNrZ3JvdW5kXCIpLmVtcHR5KCkpIHtcbiAgICAgICAgLy8gYWRkIG1pbGRlciBiYWNrZHJvcCBmb3Igd29yayBhcmVhIChvdXRzaWRlIHRoZSBwcmludCBhcmVhKVxuICAgICAgICB2aWV3cG9ydFNWRy5pbnNlcnQoJ3JlY3QnLCAnc3ZnID4gZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3ZpZXdwb3J0LWJhY2tncm91bmQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzEwMCUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICcjY2NjJyk7XG4gICAgICAgIC8vIGFkZCBhIHdoaXRlIGJhY2tncm91bmQgZm9yIHRoZSBwcmludCBhcmVhXG4gICAgICAgIHZpZXdwb3J0U1ZHLmluc2VydCgndXNlJywgJ3N2ZyA+IGcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdpbGx1c3RyYXRpb24tYmFja2dyb3VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3hsaW5rOmhyZWYnLCAnI2lsbHVzdHJhdGlvbi1ib3VuZHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywnI2JiYicpO1xuICAgIH1cbiAgICBkMy5zZWxlY3QoJyN2aWV3cG9ydC1iYWNrZ3JvdW5kJylcbiAgICAgICAgLmF0dHIoJ3gnLCB2aWV3Ym94LngpXG4gICAgICAgIC5hdHRyKCd5Jywgdmlld2JveC55KTtcbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjdmlld3BvcnQtYmFja2dyb3VuZCwgI2lsbHVzdHJhdGlvbi1iYWNrZ3JvdW5kXCIpXG4gICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xufVxuZnVuY3Rpb24gZGlzYWJsZVZpZXdwb3J0TWFzaygpIHtcbiAgICAvLyByZW1vdmUgYW5kIGNsZWFuIHVwIG1hc2tpbmcgc3R1ZmYgKHByaW9yIHRvIHByaW50aW5nPylcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICB2aWV3cG9ydFNWRy5hdHRyKCdtYXNrJywgbnVsbCk7XG4vKlxuICAgIHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiN2aWV3cG9ydC1iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuICAgIHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiNpbGx1c3RyYXRpb24tYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiovXG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI3ZpZXdwb3J0LWJhY2tncm91bmQsICNpbGx1c3RyYXRpb24tYmFja2dyb3VuZFwiKVxuICAgICAgICAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xufVxuXG5mdW5jdGlvbiBlbmFibGVQcmludGluZ0Nyb3BBcmVhKCkge1xuICAgIGQzLnNlbGVjdCgnZGl2LnZlZ2Egc3ZnIGcuaWxsdXN0cmF0aW9uLWVsZW1lbnRzJylcbiAgICAgICAgLnN0eWxlKCdjbGlwLXBhdGgnLCd1cmwoI3ByaW50aW5nLWNsaXAtcGF0aCknKTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVQcmludGluZ0Nyb3BBcmVhKCkge1xuICAgIGQzLnNlbGVjdCgnZGl2LnZlZ2Egc3ZnIGcuaWxsdXN0cmF0aW9uLWVsZW1lbnRzJylcbiAgICAgICAgLnN0eWxlKCdjbGlwLXBhdGgnLCdub25lJyk7XG59XG5cbi8qIE1hbmFnZSBkaWFnbm9zdGljIG1hcmtpbmdzIChjcm9wIG1hcmtzLCBkZXNjcmlwdGlvbiwgcnVsZXJzKSBmb3IgcHJpbnRlZCBvdXRwdXQgKi9cbmZ1bmN0aW9uIHNob3dQcmludGluZ0RpYWdub3N0aWNzKCkge1xuICAgIHNob3dQcmludGluZ0Nyb3BNYXJrcygpO1xuICAgIHNob3dQcmludGluZ0Rlc2NyaXB0aW9uKCk7XG4gICAgc2hvd1ByaW50aW5nUnVsZXJzKCk7XG59XG5mdW5jdGlvbiBoaWRlUHJpbnRpbmdEaWFnbm9zdGljcygpIHtcbiAgICBoaWRlUHJpbnRpbmdDcm9wTWFya3MoKTtcbiAgICBoaWRlUHJpbnRpbmdEZXNjcmlwdGlvbigpO1xuICAgIGhpZGVQcmludGluZ1J1bGVycygpO1xufVxuZnVuY3Rpb24gc2hvd1ByaW50aW5nQ3JvcE1hcmtzKCkge1xuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdEFsbChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIGlmICh2aWV3cG9ydFNWRy5lbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNob3dQcmludGluZ0Nyb3BNYXJrcygpOiB2aWV3cG9ydCBTVkcgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjY3JvcC1tYXJrc1wiKS5lbXB0eSgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnN0YW5jZSBvZiBjcm9wIG1hcmtzIGFuZCBcbiAgICAgICAgdmlld3BvcnRTVkcuaW5zZXJ0KCd1c2UnLCAnc3ZnID4gZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2Nyb3AtbWFya3MnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgJyNwcmludGluZy1jcm9wLW1hcmtzJyk7XG4gICAgfVxuICAgIC8vIGFkanVzdCBwbGFjZW1lbnQgb2YgbWFya3MgdG8gbWF0Y2ggZm9yIGlsbHVzdHJhdGlvbiBzaXplXG4gICAgdmFyIHByaW50VG9wRWRnZSA9IDA7ICAvLyBubyBuZWVkIHRvIHNldCB0aGVzZVxuICAgIHZhciBwcmludExlZnRFZGdlID0gMDtcbiAgICB2YXIgcHJpbnRCb3R0b21FZGdlID0gcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUuaGVpZ2h0KCksIGludGVybmFsX3BwaSk7XG4gICAgdmFyIHByaW50UmlnaHRFZGdlID0gcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUud2lkdGgoKSwgaW50ZXJuYWxfcHBpKTtcbiAgICBkMy5zZWxlY3QoJyNjcm9wLW1hcmstdG9wLXJpZ2h0JylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKFwiKyBwcmludFJpZ2h0RWRnZSArXCIsIDApXCIpO1xuICAgIGQzLnNlbGVjdCgnI2Nyb3AtbWFyay1ib3R0b20tbGVmdCcpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZSgwLCBcIisgcHJpbnRCb3R0b21FZGdlICtcIilcIik7XG4gICAgZDMuc2VsZWN0KCcjY3JvcC1tYXJrLWJvdHRvbS1yaWdodCcpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZShcIisgcHJpbnRSaWdodEVkZ2UgK1wiLCBcIisgcHJpbnRCb3R0b21FZGdlICtcIilcIik7XG59XG5mdW5jdGlvbiBoaWRlUHJpbnRpbmdDcm9wTWFya3MoKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBjcm9wLW1hcmsgaW5zdGFuY2VzXG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI2Nyb3AtbWFya3NcIikucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBzaG93UHJpbnRpbmdEZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICBpZiAodmlld3BvcnRTVkcuZW1wdHkoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJzaG93UHJpbnRpbmdEZXNjcmlwdGlvbigpOiB2aWV3cG9ydCBTVkcgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjZGVzY3JpcHRpb25cIikuZW1wdHkoKSkge1xuICAgICAgICAvLyBjcmVhdGUgaW5zdGFuY2Ugb2YgY3JvcCBtYXJrcyBhbmQgXG4gICAgICAgIHZpZXdwb3J0U1ZHLmluc2VydCgndXNlJywgJ3N2ZyA+IGcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdkZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3hsaW5rOmhyZWYnLCAnI3ByaW50aW5nLWRlc2NyaXB0aW9uJyk7XG4gICAgfVxuICAgIC8vIE5PVEUgdGhhdCB3ZSBuZWVkIHRvIG1vdmUgdGhlICpvcmlnaW5hbCogdGV4dCBlbGVtZW50IHRvIGdldCBpdHMgcHJvcGVyIGJvdW5kaW5nIGJveCFcbiAgICBkMy5zZWxlY3QoJyNwcmludGluZy1kZXNjcmlwdGlvbi1uYW1lJylcbiAgICAgICAgLmF0dHIoJ3gnLCAtNTApXG4gICAgICAgIC5hdHRyKCd5JywgLTExMClcbiAgICAgICAgLnRleHQoXCJUT0RPOiBBZGQgdGhlIGFjdHVhbCBpbGx1c3RyYXRpb24gbmFtZSwgb3IgJ1VudGl0bGVkJ1wiKTtcbiAgICB2YXIgcmlnaHROb3cgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBkaXNwbGF5RGF0ZVRpbWUgPSBcIkdlbmVyYXRlZCBcIisgcmlnaHROb3cudG9Mb2NhbGVEYXRlU3RyaW5nKCkgK1wiIC0gXCIrIHJpZ2h0Tm93LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIGQzLnNlbGVjdCgnI3ByaW50aW5nLWRlc2NyaXB0aW9uLWRhdGV0aW1lJylcbiAgICAgICAgLmF0dHIoJ3gnLCAtNTApXG4gICAgICAgIC5hdHRyKCd5JywgLTk0KVxuICAgICAgICAudGV4dChkaXNwbGF5RGF0ZVRpbWUpO1xufVxuZnVuY3Rpb24gaGlkZVByaW50aW5nRGVzY3JpcHRpb24oKSB7XG4gICAgLy8gcmVtb3ZlIGRlc2NyaXB0aW9uIGluc3RhbmNlXG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI2Rlc2NyaXB0aW9uXCIpLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gc2hvd1ByaW50aW5nUnVsZXJzKCkge1xuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdEFsbChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIGlmICh2aWV3cG9ydFNWRy5lbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNob3dQcmludGluZ0Rlc2NyaXB0aW9uKCk6IHZpZXdwb3J0IFNWRyBub3QgZm91bmQhXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiNydWxlcnNcIikuZW1wdHkoKSkge1xuICAgICAgICAvLyBjcmVhdGUgaW5zdGFuY2Ugb2YgY3JvcCBtYXJrcyBhbmQgXG4gICAgICAgIHZpZXdwb3J0U1ZHLmluc2VydCgndXNlJywgJ3N2ZyA+IGcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdydWxlcnMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgJyNwcmludGluZy1ydWxlcnMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIC02MCk7XG4gICAgfVxuICAgIC8vIHNldCBzY2FsZSBmb3IgaW5jaCBydWxlclxuICAgIHZhciB1bml0V2lkdGggPSBpbmNoZXNUb1BpeGVscygxLjAsIGludGVybmFsX3BwaSk7XG4gICAgZDMuc2VsZWN0KCcjcnVsZXItaW5jaGVzIGxpbmUnKVxuICAgICAgICAuYXR0cigneDInLCA2ICogdW5pdFdpZHRoKTtcbiAgICBkMy5zZWxlY3RBbGwoJyNydWxlci1pbmNoZXMgcmVjdCcpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdW5pdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGkgKiAyICogdW5pdFdpZHRoKSArIHVuaXRXaWR0aClcbiAgICAgICAgfSk7XG4gICAgLy8gc2V0IHNjYWxlIGZvciBjbSBydWxlclxuICAgIHVuaXRXaWR0aCA9IGNlbnRpbWV0ZXJzVG9QaXhlbHMoMS4wLCBpbnRlcm5hbF9wcGkpO1xuICAgIGQzLnNlbGVjdCgnI3J1bGVyLWNtIGxpbmUnKVxuICAgICAgICAuYXR0cigneDInLCAxNiAqIHVuaXRXaWR0aCk7XG4gICAgZDMuc2VsZWN0QWxsKCcjcnVsZXItY20gcmVjdCcpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdW5pdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGkgKiAyICogdW5pdFdpZHRoKSArIHVuaXRXaWR0aClcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBoaWRlUHJpbnRpbmdSdWxlcnMoKSB7XG4gICAgLy8gcmVtb3ZlIGRlc2NyaXB0aW9uIGluc3RhbmNlXG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI3J1bGVyc1wiKS5yZW1vdmUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJpbnRhYmxlU1ZHKCBvcHRpb25zICkge1xuICAgIC8vIFRPRE86IEFkZCBhbiBvcHRpb24gdG8gZ2VuZXJhdGUgc3RhbmRhbG9uZSBTVkcsIHZzLiBpbmxpbmUgZm9yIEhUTUw1XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICAvLyBzaGlmdCBTVkcgZnJvbSBlZGl0aW5nIHRvIHByaW50aW5nXG4gICAgZGlzYWJsZVZpZXdwb3J0TWFzaygpO1xuICAgIGVuYWJsZVByaW50aW5nQ3JvcEFyZWEoKTtcbiAgICBpZiAob3B0aW9ucy5JTkNMVURFX0RJQUdOT1NUSUNTKSB7XG4gICAgICAgIHNob3dQcmludGluZ0RpYWdub3N0aWNzKCk7XG4gICAgfVxuXG4gICAgLy8gY2FwdHVyZSB0aGUgdmlld2JveCBhbmQgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCB3b3JraW5nIHZpZXdcbiAgICB2YXIgaWxsdXN0cmF0aW9uID0gZDMuc2VsZWN0KCcjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2ZycpO1xuICAgIHZhciB3b3JraW5nVmlldyA9IHtcbiAgICAgICAgJ3dpZHRoJzogaWxsdXN0cmF0aW9uLmF0dHIoXCJ3aWR0aFwiKSxcbiAgICAgICAgJ2hlaWdodCc6IGlsbHVzdHJhdGlvbi5hdHRyKFwiaGVpZ2h0XCIpLFxuICAgICAgICAndmlld0JveCc6IGlsbHVzdHJhdGlvbi5hdHRyKFwidmlld0JveFwiKVxuICAgIH1cblxuICAgIC8vIG1vZGlmeSB0aGUgdmlld2JveCB0byBjYXB0dXJlIGp1c3QgdGhlIGlsbHVzdHJhdGlvbiBlbGVtZW50cyAoYW5kIHBvc3NpYmx5IGRpYWdub3N0aWMgc3R1ZmYpXG4gICAgdmFyIHByaW50Vmlld0JveCA9IChvcHRpb25zLklOQ0xVREVfRElBR05PU1RJQ1MpID9cbiAgICAgICAgZ2V0RGlhZ25vc3RpY0JvdW5kaW5nQm94KCkgOiBcbiAgICAgICAgZ2V0TWluaW1hbElsbHVzdHJhdGlvbkJvdW5kaW5nQm94KCk7XG5cbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKFwicHJpbnRWaWV3Qm94OiBcIik7XG4gICAgY29uc29sZS5sb2cocHJpbnRWaWV3Qm94KTtcbiAgICAqL1xuXG4gICAgLy8gc2hpZnQgdGhlIG1haW4gU1ZHIGRpbWVuc2lvbnMgdG8gcGh5c2ljYWwgdW5pdHMgKGZvciBtb3JlIGFjY3VyYXRlIHByaW50IHNpemUpXG4gICAgdmFyIHVuaXRTdWZmaXggPSBpbGwudW5pdHNDc3NTdWZmaXgoKTtcbiAgICAvLyByZWNrb24gcGh5c2ljYWwgc2l6ZSBpbiBkZWZhdWx0IChwcmludC1yZWFkeSkgcHBpIHRvIFwiZnJlZXplXCIgdGhlIHBpeGVsIHNpemUgb2YgdGhlIHRvcC1sZXZlbCBTVkdcbiAgICBpbGx1c3RyYXRpb25cbiAgICAgICAgLyogTi5CLiBSZWx5aW5nIG9uIFwibmF0dXJhbFwiIFNWRyByZXMgKDkwIHBwaSkgcHJpbnRzIG5vdC1xdWl0ZSB0byBzY2FsZSFcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwcmludFZpZXdCb3gud2lkdGgpICAgLy8gcmVseSBvbiBidWlsdC1pbiA/XG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHByaW50Vmlld0JveC5oZWlnaHQpXG4gICAgICAgICovXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc3RhdGUgV1JPTkcgcGh5c2ljYWwgc2l6ZSwgdXNpbmcgYnJvd3NlciBQUEk7IHByaW50cyBjb3JyZWN0bHksIGJ1dCBnaXZlcyBtZSBhIG1pZ3JhaW5lXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGl4ZWxzVG9QaHlzaWNhbFVuaXRzKHByaW50Vmlld0JveC53aWR0aCwgYnJvd3Nlcl9wcGkpICsgdW5pdFN1ZmZpeClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcGl4ZWxzVG9QaHlzaWNhbFVuaXRzKHByaW50Vmlld0JveC5oZWlnaHQsIGJyb3dzZXJfcHBpKSArIHVuaXRTdWZmaXgpXG4gICAgICAgIC5hdHRyKFwidmlld0JveFwiLCAocHJpbnRWaWV3Qm94LnggKycgJysgcHJpbnRWaWV3Qm94LnkgKycgJysgcHJpbnRWaWV3Qm94LndpZHRoICsnICcrcHJpbnRWaWV3Qm94LmhlaWdodCkpO1xuXG4gICAgLypcbiAgICBjb25zb2xlLmxvZyggXCJ3OiBcIisgaWxsdXN0cmF0aW9uLmF0dHIoJ3dpZHRoJykgKTtcbiAgICBjb25zb2xlLmxvZyggXCJoOiBcIisgaWxsdXN0cmF0aW9uLmF0dHIoJ2hlaWdodCcpICk7XG4gICAgY29uc29sZS5sb2coIFwidjogXCIrIGlsbHVzdHJhdGlvbi5hdHRyKCd2aWV3Qm94JykgKTtcbiAgICBjb25zb2xlLmxvZyhcImRpc3BsYXlfcHBpOiBcIisgZGlzcGxheV9wcGkpO1xuICAgIGNvbnNvbGUubG9nKFwiaW50ZXJuYWxfcHBpOiBcIisgaW50ZXJuYWxfcHBpKTtcbiAgICBjb25zb2xlLmxvZyhcImJyb3dzZXJfcHBpOiBcIisgaW50ZXJuYWxfcHBpKTtcbiAgICBjb25zb2xlLmxvZyhcInZpZXdwb3J0TWFnbmlmaWNhdGlvbjogXCIrIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgKi9cblxuICAgIC8vIG1vbWVudGFyaWx5IFwic3BsaWNlXCIgcGVyc2lzdGVudCBkZWZzIGludG8gdGhlIGlsbHVzdHJhdGlvbiwgY2FwdHVyZSB0aGUgcmVzdWx0XG4gICAgdmFyIHRvb2xib3ggPSBkMy5zZWxlY3QoJyNzdmctdG9vbGJveCcpO1xuICAgIHZhciBkZWZzID0gdG9vbGJveC5zZWxlY3QoJ2RlZnMnKTtcbiAgICAkKGlsbHVzdHJhdGlvbi5ub2RlKCkpLnByZXBlbmQoZGVmcyk7XG5cbiAgICAvKlxuICAgICAqIENhcHR1cmUgdGhlIHJlc3VsdGluZyBTVkcgKGllLCBUaGUgTW9tZW50IG9mIFRydXRoKS4uLiBcbiAgICAgKi9cbiAgICB2YXIgY29tYmluZWRTVkcgPSAkKCcjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhJykuaHRtbCgpO1xuXG4gICAgLy8gUmVwbGFjZSBTYWZhcmkncyB3ZWlyZCBuYW1lc3BhY2UgcHJlZml4ZXMgKE5TMTosIE5TMjosIGV0Yykgd2l0aCB0aGUgcmVhbCBkZWFsXG4gICAgY29tYmluZWRTVkcgPSBjb21iaW5lZFNWRy5yZXBsYWNlKC9OU1xcZCs6L2dpLCAneGxpbms6Jyk7XG5cbiAgICAvKlxuICAgICAqIC4uLiB0aGVuIHVud2luZCBhbGwgdGhlc2UgY2hhbmdlcyB0byByZXN0b3JlIG91ciBub3JtYWwgd29ya2luZyB2aWV3LiBcbiAgICAgKi9cblxuICAgIC8vIHJlcGxhY2UgdGhlIHBlcnNpc3RlbnQgZGVmc1xuICAgICQodG9vbGJveC5ub2RlKCkpLnByZXBlbmQoZGVmcyk7XG5cbiAgICAvLyByZXN0b3JlIHBpeGVsIGRpbWVuc2lvbnMgKGluIGRlZmVyZW5jZSB0byBWZWdhKVxuICAgIGlsbHVzdHJhdGlvblxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdvcmtpbmdWaWV3LndpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB3b3JraW5nVmlldy5oZWlnaHQpXG4gICAgICAgIC5hdHRyKFwidmlld0JveFwiLCB3b3JraW5nVmlldy52aWV3Qm94KTtcblxuICAgIC8vIHJldmVyc2UgYWxsIHRoZSBwcmV2aW91cyBzdGVwc1xuICAgIGlmIChvcHRpb25zLklOQ0xVREVfRElBR05PU1RJQ1MpIHtcbiAgICAgICAgaGlkZVByaW50aW5nRGlhZ25vc3RpY3MoKTtcbiAgICB9XG4gICAgZGlzYWJsZVByaW50aW5nQ3JvcEFyZWEoKTtcbiAgICBlbmFibGVWaWV3cG9ydE1hc2soKTtcblxuICAgIHJldHVybiBjb21iaW5lZFNWRztcbn1cblxuZnVuY3Rpb24gcHJpbnRJbGx1c3RyYXRpb24oKSB7XG4gICAgLy8gcHJpbnQgc3RhbmRhbG9uZSBTVkcgYXMgYSBzaW1wbGUgZG9jdW1lbnRcbiAgICB2YXIgdz13aW5kb3cub3BlbigpO1xuICAgIGlmICghdykge1xuICAgICAgICBhbGVydChcIlBsZWFzZSBhbGxvdyBwb3B1cHMgZm9yIHRoaXMgZG9tYWluLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2hvd0RpYWdub3N0aWNzID0gJCgnI3RvZ2dsZS1wcmludGluZy1kaWFnbm9zdGljcycpLmlzKCc6Y2hlY2tlZCcpO1xuICAgIHZhciBsZWF2ZVdpbmRvd09wZW4gPSAkKCcjdG9nZ2xlLW9mZmVyLXN2ZycpLmlzKCc6Y2hlY2tlZCcpO1xuXG4gICAgLy8gZ2VuZXJhdGUgYSBzaW1wbGUgSFRNTDUgcGFnZSB3aXRoIGlubGluZSBTVkdcbiAgICAvLyBUT0RPOiBnZW5lcmF0ZSBzdGFuZGFsb25lIFNWRyBkb2N1bWVudCAodG8gc2F2ZSBvciBzaGFyZSkgaW5zdGVhZD9cbiAgICB2YXIgZG9jID0gdy5kb2N1bWVudDtcbiAgICBkb2Mub3BlbihcInRleHQvaHRtbFwiLCBcInJlcGxhY2VcIik7XG4gICAgZG9jLndyaXRlKCc8IURPQ1RZUEUgaHRtbD48SFRNTD48SEVBRD48VElUTEU+VHJlZSBJbGx1c3RyYXRvciAtIFNWRyBmb3IgcHJpbnRpbmc8L1RJVExFPjwvSEVBRD48Qk9EWT48L0JPRFk+PC9IVE1MPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIHZhciBvdXRwdXRTVkcgPSBnZXRQcmludGFibGVTVkcoIHtJTkNMVURFX0RJQUdOT1NUSUNTOiBzaG93RGlhZ25vc3RpY3N9ICk7XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIHJlbmRlciB0aGUgbmV3IHdpbmRvdyBzbyB3ZSBjYW4gdXNlIGl0cyBoZWlnaHRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGVhdmVXaW5kb3dPcGVuKSB7XG4gICAgICAgICAgICAvLyB3cml0ZSBqdXN0IHRoZSBTVkcgdG8gdGhlIG5ldyB3aW5kb3csIHRvIGJlIGNvcGllZCB0byBjbGlwYm9hcmRcbiAgICAgICAgICAgIHZhciBpdHNDbGllbnRIZWlnaHQgPSAkKCdodG1sJywgZG9jKVswXS5jbGllbnRIZWlnaHQgLSA1MDtcbiAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9ICc8dGV4dGFyZWEgc3R5bGU9XCJ3aWR0aDogOTUlOyBoZWlnaHQ6ICcrIGl0c0NsaWVudEhlaWdodCArJ3B4O1wiPicrIG91dHB1dFNWRyArJzwvdGV4dGFyZWE+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbCBwcmludCtjbG9zZSBiZWhhdmlvclxuICAgICAgICAgICAgZG9jLmJvZHkuaW5uZXJIVE1MID0gb3V0cHV0U1ZHO1xuICAgICAgICAgICAgdy5wcmludCgpO1xuICAgICAgICAgICAgdy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSwgNTAwKTtcbn1cblxuLyogQWNjb3JkaW9uIFVJIGhlbHBlcnMgKi9cbmZ1bmN0aW9uIGFjY29yZGlvblBhbmVsU2hvd24oZSkge1xuICAgIHZhciAkaGVhZGluZyA9ICQoZS50YXJnZXQpLnByZXYoJy5wYW5lbC1oZWFkaW5nJyk7XG4gICAgJGhlYWRpbmcuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAudGV4dCgnQ2xpY2sgdG8gY2xvc2UgdGhpcyBwYW5lbCcpO1xufVxuZnVuY3Rpb24gYWNjb3JkaW9uUGFuZWxIaWRkZW4oZSkge1xuICAgIHZhciAkaGVhZGluZyA9ICQoZS50YXJnZXQpLnByZXYoJy5wYW5lbC1oZWFkaW5nJyk7XG4gICAgJGhlYWRpbmcuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAudGV4dCgnQ2xpY2sgdG8gb3BlbiB0aGlzIHBhbmVsJyk7XG59XG5mdW5jdGlvbiBzaG93QWNjb3JkaW9uSGludChlKSB7XG4gICAgJChlLnRhcmdldClcbiAgICAgICAgLmZpbmQoXCJpLmhlbHAtcm9sbG92ZXJcIilcbiAgICAgICAgLnNob3coKTtcbn1cbmZ1bmN0aW9uIGhpZGVBY2NvcmRpb25IaW50KGUpIHtcbiAgICAkKGUudGFyZ2V0KVxuICAgICAgICAuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAuaGlkZSgpO1xufVxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgJCgnI3RpLW1haW4tYWNjb3JkaW9uIC5wYW5lbC1ib2R5Jykub24oJ3Nob3duJywgYWNjb3JkaW9uUGFuZWxTaG93bik7XG4gICAgJCgnI3RpLW1haW4tYWNjb3JkaW9uIC5wYW5lbC1ib2R5Jykub24oJ2hpZGRlbicsIGFjY29yZGlvblBhbmVsSGlkZGVuKTtcblxuICAgICQoJyN0aS1tYWluLWFjY29yZGlvbiAucGFuZWwtaGVhZGluZycpLm9uKCdtb3VzZWVudGVyJywgc2hvd0FjY29yZGlvbkhpbnQpO1xuICAgICQoJyN0aS1tYWluLWFjY29yZGlvbiAucGFuZWwtaGVhZGluZycpLm9uKCdtb3VzZWxlYXZlJywgaGlkZUFjY29yZGlvbkhpbnQpO1xufSk7XG5cbmZ1bmN0aW9uIGRvTm90aGluZygpIHtcbiAgICAvLyBvY2Nhc2lvbmFsbHkgdXNlZnVsIGluIEtub2Nrb3V0LmpzIGNsaWNrIGJpbmRpbmdzXG4gICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBnZXRQcmludEFyZWFMYW5kbWFya3MoKSB7XG4gICAgLy8gZ2F0aGVyIGludGVyZXN0aW5nIGNvb3JkaW5hdGVzIGluIGludGVybmFsIHBpeGVsc1xuICAgIGlmIChpbGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpLCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgaGVpZ2h0OiBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoKSwgaW50ZXJuYWxfcHBpKSxcbiAgICAgICAgICAgIGxlZnRYOiAwLFxuICAgICAgICAgICAgY2VudGVyWDogcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUud2lkdGgoKSAvIDIuMCwgaW50ZXJuYWxfcHBpKSxcbiAgICAgICAgICAgIHJpZ2h0WDogcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUud2lkdGgoKSwgaW50ZXJuYWxfcHBpKSxcbiAgICAgICAgICAgIHRvcFk6IDAsXG4gICAgICAgICAgICBjZW50ZXJZOiBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoKSAvIDIuMCwgaW50ZXJuYWxfcHBpKSxcbiAgICAgICAgICAgIGJvdHRvbVk6IHBoeXNpY2FsVW5pdHNUb1BpeGVscyhpbGwuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpLCBpbnRlcm5hbF9wcGkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciB2YWx1ZXNcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogICAxLjAsXG4gICAgICAgIGhlaWdodDogIDEuMCxcbiAgICAgICAgbGVmdFg6ICAgMC4wLFxuICAgICAgICBjZW50ZXJYOiAwLjUsXG4gICAgICAgIHJpZ2h0WDogIDEuMCxcbiAgICAgICAgdG9wWTogICAgMC4wLFxuICAgICAgICBjZW50ZXJZOiAwLjUsXG4gICAgICAgIGJvdHRvbVk6IDEuMFxuICAgIH07XG59XG4gXG5mdW5jdGlvbiBlbnRlckZ1bGxTY3JlZW4oKSB7XG4gICAgdmFyIHRlc3QgPSAkKCcjZnVsbC1zY3JlZW4tYXJlYScpLmZ1bGxzY3JlZW4oKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICAkLmZ1bGxzY3JlZW4uZXhpdCgpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXBwbHlDaG9zZW5TdHlsZUd1aWRlKGNsaWNrZWQpIHtcbiAgICB2YXIgJGNsaWNrZWQgPSAkKGNsaWNrZWQpO1xuICAgIHZhciAkc2dCbG9jayA9ICRjbGlja2VkLmNsb3Nlc3QoJy5tYXRjaCcpO1xuICAgIC8vIFRPRE86IHJlcGxhY2UgdGhpcyBkdW1iIG1hdGNoaW5nIHdpdGggS08gYmluZGluZyB0byBhY3R1YWwgZGF0YVxuICAgIHZhciBtYXRjaEtleSA9ICRzZ0Jsb2NrLmZpbmQoJy5tYXRjaC1rZXknKS52YWwoKTtcbiAgICBjb25zb2xlLmxvZyhcIj4gTG9va2luZyBmb3IgbWF0Y2hLZXk6IFwiKyBtYXRjaEtleSk7XG4gICAgdmFyIGNob3NlblN0eWxlR3VpZGUgPSBudWxsO1xuICAgICQuZWFjaChhdmFpbGFibGVTdHlsZUd1aWRlcywgZnVuY3Rpb24oaSwgc2cpIHtcbiAgICAgICAgLy8gaXMgdGhpcyB0aGUgaWxsbHVzdHJhdGlvbidzIGN1cnJlbnQgc3R5bGUgZ3VpZGU/IGNvbXBhcmUgbmFtZSwgc291cmNlLCB2ZXJzaW9uXG4gICAgICAgIHZhciB0ZXN0S2V5ICA9IHNnLm5hbWUgKyd8Jysgc2cudmVyc2lvbi52YWx1ZSArJ3wnKyBzZy5zb3VyY2UudmFsdWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4gY29tcGFyaW5nIHRlc3RLZXk6IFwiKyB0ZXN0S2V5KTtcbiAgICAgICAgaWYgKHRlc3RLZXkgPT09IG1hdGNoS2V5KSB7XG4gICAgICAgICAgICBjaG9zZW5TdHlsZUd1aWRlID0gc2c7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNob3NlblN0eWxlR3VpZGUpIHtcbiAgICAgICAgYWxlcnQoJ1VuYWJsZSB0byBtYXRjaCB0aGUgY2hvc2VuIHN0eWxlIGd1aWRlIScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRPRE86IGFwcGx5IC8gbWVyZ2UgdGhpcyBzdHlsZSBndWlkZSBpbnRvIHRoZSBjdXJyZW50IGlsbHVzdHJhdGlvblxuICAgIGlsbC5hcHBseVN0eWxlR3VpZGUoY2hvc2VuU3R5bGVHdWlkZSk7XG4gICAgLy8gY2xvc2UgdGhlIG1vZGFsIGNob29zZXJcbiAgICAkc2dCbG9jay5jbG9zZXN0KCcubW9kYWwtc3R5bGVndWlkZS1jaG9vc2VyJykuZmluZCgnLm1vZGFsLWhlYWRlciAuY2xvc2UnKS5jbGljaygpO1xufVxuXG4vLyBtYW5hZ2UgaWxsdXN0cmF0aW9ucyAodXNpbmcgYW4gYWRhcHRlciB3aXRoIEFQSSBtZXRob2RzLCBhbHJlYWR5IGxvYWRlZClcbnZhciBjdXJyZW50SWxsdXN0cmF0aW9uTGlzdCA9IG51bGw7XG4gICAgLy8ga2VlcCB0aGUgbGF0ZXN0IG9yZGVyZWQgYXJyYXkgKHdpdGggcG9zaXRpb25zLCBuYW1lcywgZGVzY3JpcHRpb25zKVxuZnVuY3Rpb24gbG9hZElsbHVzdHJhdGlvbkxpc3QoY2FsbGJhY2spIHtcbiAgICBjb25zb2xlLmxvZyhcImxvYWRJbGx1c3RyYXRpb25MaXN0KCkgU1RBUlRJTkcuLi5cIik7XG4gICAgZ2V0SWxsdXN0cmF0aW9uTGlzdChmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAvLyBzaG93IHRoZSByZXR1cm5lZCBsaXN0IChvciByZXBvcnQgYW55IGVycm9yKSBmcm9tIHRoZSB1cHN0cmVhbSByZXNwb25zZVxuICAgICAgICBpZiAoJ2RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBleHBlY3QgYW4gb3JkZXJlZCBhcnJheSB3aXRoIG5hbWVzIGFuZCBkZXNjcmlwdGlvbnNcbiAgICAgICAgICAgIGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2hvd0lsbHVzdHJhdGlvbkxpc3QoKSB7XG4gICAgaWYgKGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0KSB7XG4gICAgICAgIC8vIFNob3cgbmFtZXMgYW5kIGRlc2NyaXB0aW9ucyBpbiBhIHNpbXBsZSwgZ2VuZXJhbCBjaG9vc2VyXG4gICAgICAgIHZhciAkY2hvb3NlciA9ICQoJyNzaW1wbGUtY2hvb3NlcicpO1xuICAgICAgICAkY2hvb3Nlci5maW5kKCdbaWQ9XCJkaWFsb2ctaGVhZGluZ1wiXScpLmh0bWwoJ0Nob29zZSBhbiBleGlzdGluZyBpbGx1c3RyYXRpb24nKTtcbiAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5lbXB0eSgpO1xuICAgICAgICAkLmVhY2goY3VycmVudElsbHVzdHJhdGlvbkxpc3QsIGZ1bmN0aW9uKGksIG1hdGNoKSB7XG4gICAgICAgICAgICAvKiBMaXN0IGl0ZW0gc2hvdWxkIGluY2x1ZGUgdGhlc2UgcHJvcGVydGllc1xuICAgICAgICAgICAgICogIC0gbmFtZVxuICAgICAgICAgICAgICogIC0gZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAqICAtIHNvdXJjZVxuICAgICAgICAgICAgICogTi5CLiBJbiBzbG90LWJhc2VkIHN0b3JhZ2UsIGBpYCBpcyB0aGUgb25seSBzb3VyY2UgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyICRtYXRjaEluZm8gPSAkKCc8ZGl2IGNsYXNzPVwibWF0Y2hcIj48ZGl2IGNsYXNzPVwibmFtZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJkZXNjcmlwdGlvblwiPjwvZGl2PjwvZGl2PicpO1xuICAgICAgICAgICAgJG1hdGNoSW5mby5maW5kKCcubmFtZScpLmh0bWwobWF0Y2gubmFtZSB8fCAnPGVtPk5vIG5hbWUgZm91bmQ8L2VtPicpXG4gICAgICAgICAgICAkbWF0Y2hJbmZvLmZpbmQoJy5kZXNjcmlwdGlvbicpLmh0bWwobWF0Y2guZGVzY3JpcHRpb24gfHwgJycpO1xuICAgICAgICAgICAgJG1hdGNoSW5mby5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbiggbWF0Y2guc291cmNlIHx8IGkpO1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBtb2RhbCBjaG9vc2VyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcubW9kYWwtc2ltcGxlLWNob29zZXInKS5maW5kKCcubW9kYWwtaGVhZGVyIC5jbG9zZScpLmNsaWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRjaG9vc2VyLmZpbmQoJy5mb3VuZC1tYXRjaGVzJykuYXBwZW5kKCRtYXRjaEluZm8pO1xuICAgICAgICB9KTtcbiAgICAgICAgJGNob29zZXIub2ZmKCdzaG93bicpLm9uKCdzaG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gc2l6ZSBzY3JvbGxpbmcgbGlzdCB0byBmaXQgaW4gdGhlIGN1cnJlbnQgRE9JLWxvb2t1cCBwb3B1cCB3aW5kb3dcbiAgICAgICAgICAgIHZhciAkY2hvb3NlciA9ICQoJyNzaW1wbGUtY2hvb3NlcicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHNMaXN0SGVpZ2h0ID0gJGNob29zZXIuZmluZCgnLm1vZGFsLWJvZHknKS5oZWlnaHQoKSAtICRjaG9vc2VyLmZpbmQoJy5iZWZvcmUtbWF0Y2hlcycpLmhlaWdodCgpO1xuICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKVxuICAgICAgICAgICAgICAgIC5vdXRlckhlaWdodChyZXN1bHRzTGlzdEhlaWdodClcbiAgICAgICAgICAgICAgICAuY3NzKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5jc3MoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgJGNob29zZXIubW9kYWwoJ3Nob3cnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIHRoZSBpbml0aWFsIGxpc3QsIHRoZW4gcmV0dXJuIGhlcmVcbiAgICAgICAgbG9hZElsbHVzdHJhdGlvbkxpc3Qoc2hvd0lsbHVzdHJhdGlvbkxpc3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhdmVDdXJyZW50SWxsdXN0cmF0aW9uKHNhdmVUb0lEKSB7XG4gICAgY29uc29sZS5sb2coXCJzYXZlQ3VycmVudElsbHVzdHJhdGlvbigpIFNUQVJUSU5HLi4uXCIpO1xuICAgIC8vIFRPRE86IEhvdyBzaG91bGQgdGhpcyBJRCBiZSBkZXRlcm1pbmVkP1xuICAgIC8vICAtIHVuaXF1ZS9zZXJpYWxpemVkIHNsdWcsIGFsYSB0cmVlIGNvbGxlY3Rpb25zP1xuICAgIC8vICAtIGlmIHByb3ZpZGVkIGFzIGluY29taW5nIGFyZywgdXNlIHRvIFNhdmUgQXNcbiAgICAvLyAgLSBhZGQgYW4gZXhwbGljaXQgYXJnIGZvciBTQVZFLCBTQVZFX0FTLCBEVVBMSUNBVEVcbiAgICAvLyAgLSBzaG91bGQgdGhlc2UgZGV0YWlscyBiZSBkZWxlZ2F0ZWQgdG8gdGhlIHN0b3JhZ2UgYWRhcHRlcj9cbiAgICAvLyAgLSBPUiBzaG91bGQgd2UgcmVseSBlbnRpcmVseSBvbiAoYW5kIHBvc3NpYmx5IG1vZGlmeSkgaXRzIGludGVybmFsIG1ldGFkYXRhP1xuICAgIC8vIEN1cnJlbnQgYmVoYXZpb3IgKGluIElQeXRob24gbm90ZWJvb2spIGlzIHRvIGFzc3VtZSB0aGUgY3VycmVudCAobnRoKVxuICAgIC8vIHN0b3JhZ2Ugc2xvdCwgdW5sZXNzICdORVcnIG9yIGFub3RoZXIgaW50ZWdlciBpcyBhc3NlcnRlZCBoZXJlLlxuICAgIHNhdmVJbGx1c3RyYXRpb24oc2F2ZVRvSUQsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIChyZSlsb2FkIHRoZSBzYXZlZCBpbGx1c3RyYXRpb24gKG9yIHJlcG9ydCBhbnkgZXJyb3IpXG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciggcmVzcG9uc2UuZXJyb3IgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBFeHBvc2Ugc29tZSBtZW1iZXJzIHRvIG91dHNpZGUgY29kZSAoZWcsIEtub2Nrb3V0IGJpbmRpbmdzLCBvbkNsaWNrXG4vLyBhdHRyaWJ1dGVzLi4uKVxudmFyIGFwaSA9IFtcbiAgICAnVHJlZUlsbHVzdHJhdG9yJyxcbiAgICAnc2hvd0lsbHVzdHJhdGlvbkxpc3QnLFxuICAgICdmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbicsXG4gICAgJ2ZldGNoQW5kTG9hZElsbHVzdHJhdGlvblRlbXBsYXRlJyxcbiAgICAnc2F2ZUN1cnJlbnRJbGx1c3RyYXRpb24nLFxuICAgICdpbmNoZXNUb0NlbnRpbWV0ZXJzJyxcbiAgICAnY2VudGltZXRlcnNUb0luY2hlcycsXG4gICAgJ2luY2hlc1RvUG9pbnRzJyxcbiAgICAncG9pbnRzVG9JbmNoZXMnLFxuICAgICdjZW50aW1ldGVyc1RvUG9pbnRzJyxcbiAgICAncG9pbnRzVG9DZW50aW1ldGVycycsXG4gICAgJ3BpeGVsc1RvSW5jaGVzJyxcbiAgICAnaW5jaGVzVG9QaXhlbHMnLFxuICAgICdwaXhlbHNUb0NlbnRpbWV0ZXJzJyxcbiAgICAnY2VudGltZXRlcnNUb1BpeGVscycsXG4gICAgJ3BpeGVsc1RvUGh5c2ljYWxVbml0cycsXG4gICAgJ3BoeXNpY2FsVW5pdHNUb1BpeGVscycsXG4gICAgJ3BvaW50c1RvQ2VudGltZXRlcnMnLFxuICAgICdnZXRQcmludEFyZWFMYW5kbWFya3MnLFxuICAgICd0b2dnbGVGaXhlZFJ1bGVycycsXG4gICAgJ3JlZnJlc2hWaXonLFxuICAgICdkb05vdGhpbmcnLFxuICAgICdicm93c2VyX3BwaScsXG4gICAgJ2ludGVybmFsX3BwaScsXG4gICAgJ2Rpc3BsYXlfcHBpJyxcbiAgICAnYXZhaWxhYmxlVHJlZXMnLFxuICAgICd6b29tVmlld3BvcnQnLFxuICAgICdwcmludElsbHVzdHJhdGlvbicsXG4gICAgJ3Jlc2l6ZVZpZXdwb3J0VG9TaG93QWxsJyxcbiAgICAnYXZhaWxhYmxlU3R5bGVHdWlkZXMnLFxuICAgICdzaG93U3R5bGVHdWlkZVBpY2tlcicsXG4gICAgJ2FwcGx5Q2hvc2VuU3R5bGVHdWlkZScsXG4gICAgJ2VudGVyRnVsbFNjcmVlbicsXG4gICAgJ2V4aXRGdWxsU2NyZWVuJyxcbiAgICAnaWxsJ1xuXTtcbiQuZWFjaChhcGksIGZ1bmN0aW9uKGksIG1ldGhvZE5hbWUpIHtcbiAgICAvLyBwb3B1bGF0ZSB0aGUgZGVmYXVsdCAnbW9kdWxlLmV4cG9ydHMnIG9iamVjdFxuICAgIGV4cG9ydHNbIG1ldGhvZE5hbWUgXSA9IGV2YWwoIG1ldGhvZE5hbWUgKTtcbn0pO1xuIiwiLyogXG4gKiBHZW5lcmFsbHkgdXNlZnVsIHRvb2xzIGZvciBtb2R1bGVzIGluIFRyZWUgSWxsdXN0cmF0b3IuIFRoZXkgbWlnaHQgYmVcbiAqIGNvbmNlcm5lZCB3aXRoIGRpc3BsYXkgbG9naWMsIGdlb21ldHJ5IGFuZCB0cmFuc2Zvcm1hdGlvbiwgdGV4dCBmb3JtYXR0aW5nO1xuICogYW55dGhpbmcgdGhhdCBzcGFucyBvdXIgbm9ybWFsIGxpbmVzIG9mIHJlc3BvbnNpYmlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIGppZ2dsZSggcmFuZ2UgKSB7XG4gICAgLy8gUmV0dXJuIGEgbnVtYmVyICstIHplcm8sIHdpdGhpbiB0aGlzIHJhbmdlXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIHJhbmdlICogMikgLSByYW5nZTsgXG59XG5cblxuLyogXCJTbmlmZmVyc1wiIHRvIGd1ZXNzIHRoZSBmb3JtYXQgb2YgdXNlci1lbnRlcmVkIHRyZWUgZGF0YS4gXG4gKiBOLkIuIHRoZXNlIGRvbid0IG5lZWQgdG8gYmUgZm9vbC1wcm9vZjsgdGhleSdyZSBqdXN0IHVzZWQgdG8gcHJlLXNlbGVjdFxuICogdGhlIG1vc3QgbGlrZWx5IGZvcm1hdC4gXG4gKi9cbmZ1bmN0aW9uIGlzUHJvYmFibHlOZXdpY2soZGF0YSkge1xuICAgIGlmICh0eXBlb2YoZGF0YSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGF0YSA9ICQudHJpbShkYXRhKTtcbiAgICAvLyBMb29rIGZvciBleHBlY3RlZCBzdGFydCBhbmQgZW5kIG1hcmtzXG4gICAgLy8gTi5CLiB0aGlzIHdpbGwgcmVqZWN0IGEgdmFsaWQgKGJ1dCB0cml2aWFsKSBzdHJpbmcgbGlrZSAnQTsnXG4gICAgaWYgKGRhdGEuc3RhcnRzV2l0aCgnKCcpICYmIGRhdGEuZW5kc1dpdGgoJyk7JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIG1hdGNoZXNORVhVU0Jsb2NrU3RhcnRlciA9IG5ldyBSZWdFeHAoJ2JlZ2luIFxcXFx3KzsnKTtcbmZ1bmN0aW9uIGlzUHJvYmFibHlORVhVUyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZihkYXRhKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBMb29rIGZvciByZXF1aXJlZCg/KSBmaXJzdCBsaW5lXG4gICAgaWYgKCQudHJpbShkYXRhKS5zdGFydHNXaXRoKFwiI25leHVzXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyAuLi4gb3IgYWNjZXB0IHR5cGljYWwgTkVYVVMgYmxvY2sgc3RhcnRlclxuICAgIGlmIChtYXRjaGVzTkVYVVNCbG9ja1N0YXJ0ZXIudGVzdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Byb2JhYmx5TmVYTUwoZGF0YSkge1xuICAgIC8qIE5PVEUgdGhhdCB0aGlzIGlzIHRoZSBtb3N0IFwiZXhwZW5zaXZlXCIgc25pZmZlciwgc28gaXQncyBwcm9iYWJseVxuICAgICAqIGJlc3QgdG8gY2hlY2sgdGhlIG90aGVycyBmaXJzdC5cbiAgICAgKi9cbiAgICB2YXIgdGVzdFhNTDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFhNTERvY3VtZW50KSB7XG4gICAgICAgIHRlc3RYTUwgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZXN0WE1MID0gJC5wYXJzZVhNTChkYXRhKTtcbiAgICAgICAgICAgIGlmICghdGVzdFhNTCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGRhdGEgaXMgbm90IGEgc3RyaW5nLCByZXN1bHQgaXMgbnVsbCBcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gdmFyIGZhaWxlZCB0byBwYXJzZSBhcyBYTUxcbiAgICAgICAgICAgIC8vL2NvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJCh0ZXN0WE1MKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBYTUwgaXMgc3RyYW5nZWx5IGVtcHR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJvb3ROb2RlTmFtZSA9ICQodGVzdFhNTCkuY2hpbGRyZW4oKVswXS5ub2RlTmFtZTtcbiAgICBzd2l0Y2goIHJvb3ROb2RlTmFtZSApIHtcbiAgICAgICAgY2FzZSAnbmV4Om5leG1sJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICduZXhtbCc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gZXhwb3J0IHNvbWUgbWVtYmVycyBhcyBhIHNpbXBsZSBBUElcbnZhciBhcGkgPSBbXG4gICAgJ2ppZ2dsZScsXG4gICAgJ2lzUHJvYmFibHlOZXdpY2snLFxuICAgICdpc1Byb2JhYmx5TkVYVVMnLFxuICAgICdpc1Byb2JhYmx5TmVYTUwnXG5dO1xuJC5lYWNoKGFwaSwgZnVuY3Rpb24oaSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIHBvcHVsYXRlIHRoZSBkZWZhdWx0ICdtb2R1bGUuZXhwb3J0cycgb2JqZWN0XG4gICAgZXhwb3J0c1sgbWV0aG9kTmFtZSBdID0gZXZhbCggbWV0aG9kTmFtZSApO1xufSk7XG5cbiIsIi8qIFxuICogVHJhbnNmb3JtIE5FWHNvbiBkYXRhIGludG8gYSBmb3JtIHN1aXRhYmxlIGZvciB1c2UgaW4gdGhlIFRyZWUgSWxsdXN0cmF0b3JcbiAqIGFuZCBkMy5waHlsb2dyYW0uanMuIFRoaXMgZXh0ZW5kcyB0aGUgVmVnYSdzIHZnLmRhdGEgc3BhY2Ugc28gd2UgY2FuIHRha2VcbiAqIGFkdmFudGFnZSBvZiBpdHMgcGlwZWxpbmUgYW5kIG90aGVyIGZlYXR1cmVzLiBJdCdzIHBhdHRlcm5lZCBhZnRlciB0aGUgXG4gKiBwcm9qZWN0J3MgdHJlZW1hcC5qcywgd2hpY2ggYWxzbyBkb2VzIHRyYW5zZm9ybWF0aW9uIHRpZWQgdG8gYSBzcGVjaWZpYyBcbiAqIGQzIHJlcHJlc2VudGF0aW9uLlxuICogXG4gKiBBbnRpY2lwYXRlIG90aGVyIGltcG9ydGVycyBsaWtlIHRoaXMgb25lIGZvciBORVhNTCwgZXRjLiAoYXNzdW1lcyBKU09OPyBvclxuICogY2FuIHdlIHBhcnNlIGZyZWUtZm9ybSB0ZXh0PyBZRVMsIHNpbmNlIHZlZ2EgaGFuZGxlcyBDU1YsIGV0Yy4pLiBFYWNoIG9uZSBcbiAqIHNob3VsZCBwcm9kdWNlIHRoZSBzYW1lIG91dHB1dDogYSB1bmlmb3JtIEpTIG9iamVjdCByZXByZXNlbnRpbmcgYVxuICogZDMtcmVhZHkgdHJlZSAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9PcGVuVHJlZU9mTGlmZS90cmVlLWlsbHVzdHJhdG9yL3dpa2kvQnVpbGRpbmctb24tRDMtYW5kLVZlZ2EjZGF0YS1pbXBvcnRlcnMpXG4gKi9cbnZhciB2ZyAgPSByZXF1aXJlKCd2ZWdhJyksXG4gICAgLy9kMyAgPSByZXF1aXJlKCdkMycpLFxuICAgIGxvZyAgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBOZXhzb24oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgICB0cmVlSUQ6IHt0eXBlOiAndmFsdWUnfSxcbiAgICAgIHRyZWVzQ29sbGVjdGlvblBvc2l0aW9uOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMH0sXG4gICAgICB0cmVlUG9zaXRpb246IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwfVxuICB9KTtcbiAgcmV0dXJuIHRoaXMucHJvZHVjZXModHJ1ZSlcbiAgICAgICAgICAgICAubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChOZXhzb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXhzb247XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnY29udmVydGluZyB0byBuZXhzb24nXSk7XG5cbiAgdmFyIHRyZWVJRCA9IHRoaXMucGFyYW0oJ3RyZWVJRCcpLFxuICAgICAgdHJlZXNDb2xsZWN0aW9uUG9zaXRpb24gPSB0aGlzLnBhcmFtKCd0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbicpLFxuICAgICAgdHJlZVBvc2l0aW9uID0gdGhpcy5wYXJhbSgndHJlZVBvc2l0aW9uJyksXG4gICAgICBuZXhtbCA9IG51bGw7XG5cbiAgLypcbiAgICogTkVYc29uLXNwZWNpZmljIGxvZ2ljLCBlbmNhcHN1bGF0ZWQgZm9yIGVhc3kgYWNjZXNzIHRvIG5leG1sLCBldGMuXG4gICAqXG4gICAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vT3BlblRyZWVPZkxpZmUvb3BlbnRyZWUvYmxvYi83OWFhMWY0ZjcyOTQwYzBmNTcwOGZkMmNlZDU2MTkwZDhjMzRhZDlhL2N1cmF0b3Ivc3RhdGljL2pzL3N0dWR5LWVkaXRvci5qc1xuICAgKi9cbiAgdmFyIGZhc3RMb29rdXBzID0ge1xuICAgICAgJ05PREVTX0JZX0lEJzogbnVsbCxcbiAgICAgICdPVFVTX0JZX0lEJzogbnVsbCxcbiAgICAgICdFREdFU19CWV9TT1VSQ0VfSUQnOiBudWxsLFxuICAgICAgJ0VER0VTX0JZX1RBUkdFVF9JRCc6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0RmFzdExvb2t1cCggbG9va3VwTmFtZSApIHtcbiAgICAgIC8vIHJldHVybiAob3IgYnVpbGQpIGEgZmxhdCBsaXN0IG9mIE5leHNvbiBlbGVtZW50cyBieSBJRFxuICAgICAgaWYgKGxvb2t1cE5hbWUgaW4gZmFzdExvb2t1cHMpIHtcbiAgICAgICAgICBpZiAoZmFzdExvb2t1cHNbIGxvb2t1cE5hbWUgXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBidWlsZEZhc3RMb29rdXAoIGxvb2t1cE5hbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhc3RMb29rdXBzWyBsb29rdXBOYW1lIF07XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gc3VjaCBsb29rdXAgYXMgJ1wiKyBsb29rdXBOYW1lICtcIichXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRGYXN0TG9va3VwKCBsb29rdXBOYW1lICkge1xuICAgICAgLy8gKHJlKWJ1aWxkIGFuZCBzdG9yZSBhIGZsYXQgbGlzdCBvZiBOZXhzb24gZWxlbWVudHMgYnkgSURcbiAgICAgIGlmIChsb29rdXBOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgY2xlYXJGYXN0TG9va3VwKCBsb29rdXBOYW1lICk7XG4gICAgICAgICAgdmFyIG5ld0xvb2t1cCA9IHt9O1xuICAgICAgICAgIHN3aXRjaCggbG9va3VwTmFtZSApIHtcblxuICAgICAgICAgICAgICBjYXNlICdOT0RFU19CWV9JRCc6XG4gICAgICAgICAgICAgICAgICAvLyBhc3N1bWVzIHRoYXQgYWxsIG5vZGUgaWRzIGFyZSB1bmlxdWUsIGFjcm9zcyBhbGwgdHJlZXNcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLm5vZGUsIGZ1bmN0aW9uKCBpLCBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRzSUQgPSBub2RlWydAaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0c0lEIGluIG5ld0xvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVwbGljYXRlIG5vZGUgSUQgJ1wiKyBpdHNJRCArXCInIGZvdW5kIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMb29rdXBbIGl0c0lEIF0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdPVFVTX0JZX0lEJzpcbiAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZXMgdGhhdCBhbGwgbm9kZSBpZHMgYXJlIHVuaXF1ZSwgYWNyb3NzIGFsbCB0cmVlc1xuICAgICAgICAgICAgICAgICAgLy8gQU5EICdvdHVzJyBjb2xsZWN0aW9ucyFcbiAgICAgICAgICAgICAgICAgICQuZWFjaChuZXhtbC5vdHVzLCBmdW5jdGlvbiggaSwgb3R1c0NvbGxlY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG90dXNDb2xsZWN0aW9uLm90dSwgZnVuY3Rpb24oIGksIG90dSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0c0lEID0gb3R1WydAaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0c0lEIGluIG5ld0xvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVwbGljYXRlIG90dSBJRCAnXCIrIGl0c0lEICtcIicgZm91bmQhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgaXRzSUQgXSA9IG90dTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnRURHRVNfQllfU09VUkNFX0lEJzpcbiAgICAgICAgICAgICAgICAgIC8vIGFsbG93IG11bHRpcGxlIHZhbHVlcyBmb3IgZWFjaCBzb3VyY2UgKGllLCBtdWx0aXBsZSBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLmVkZ2UsIGZ1bmN0aW9uKCBpLCBlZGdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSUQgPSBlZGdlWydAc291cmNlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJRCBpbiBuZXdMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgc291cmNlSUQgXS5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFycmF5LCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgc291cmNlSUQgXSA9IFsgZWRnZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ0VER0VTX0JZX1RBUkdFVF9JRCc6XG4gICAgICAgICAgICAgICAgICAvLyBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgZm9yIGVhY2ggdGFyZ2V0IChmb3IgY29uZmxpY3RlZCB0cmVlcylcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLmVkZ2UsIGZ1bmN0aW9uKCBpLCBlZGdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SUQgPSBlZGdlWydAdGFyZ2V0J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJRCBpbiBuZXdMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgdGFyZ2V0SUQgXS5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFycmF5LCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgdGFyZ2V0SUQgXSA9IFsgZWRnZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZhc3RMb29rdXBzWyBsb29rdXBOYW1lIF0gPSBuZXdMb29rdXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzdWNoIGxvb2t1cCBhcyAnXCIrIGxvb2t1cE5hbWUgK1wiJyFcIik7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJGYXN0TG9va3VwKCBsb29rdXBOYW1lICkge1xuICAgICAgLy8gY2xlYXIgY2hvc2VuIGxvb2t1cCwgb24gZGVtYW5kIChlZywgYWZ0ZXIgbWVyZ2luZyBpbiBuZXcgT1RVcylcbiAgICAgIGlmIChsb29rdXBOYW1lID09PSAnQUxMJykge1xuICAgICAgICAgIGZvciAodmFyIGFOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgICAgIGZhc3RMb29rdXBzWyBhTmFtZSBdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsb29rdXBOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgZmFzdExvb2t1cHNbIGxvb2t1cE5hbWUgXSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHN1Y2ggbG9va3VwIGFzICdcIisgbG9va3VwTmFtZSArXCInIVwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXROZXhzb25DaGlsZHJlbihkKSB7XG4gICAgICB2YXIgcGFyZW50SUQgPSBkWydAaWQnXTtcbiAgICAgIHZhciBpdHNDaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIGNoaWxkRWRnZXMgPSBnZXRUcmVlRWRnZXNCeUlEKG51bGwsIHBhcmVudElELCAnU09VUkNFJyk7XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgb25lIGNoaWxkLCBpdCdzIHByb2JhYmx5IGEgbGF0ZW50IHJvb3Qtbm9kZSB0aGF0XG4gICAgICAvLyBzaG91bGQgYmUgaGlkZGVuIGluIHRoZSB0cmVlIHZpZXcuXG4gICAgICBpZiAoY2hpbGRFZGdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyB0cmVhdCBJVFMgY2hpbGQgbm9kZSBhcyBteSBpbW1lZGlhdGUgY2hpbGQgaW4gdGhlIGRpc3BsYXllZCB0cmVlXG4gICAgICAgICAgdmFyIG9ubHlDaGlsZE5vZGVJRCA9IGNoaWxkRWRnZXNbMF1bJ0B0YXJnZXQnXTtcbiAgICAgICAgICBjaGlsZEVkZ2VzID0gZ2V0VHJlZUVkZ2VzQnlJRChudWxsLCBvbmx5Q2hpbGROb2RlSUQsICdTT1VSQ0UnKTtcbiAgICAgIH1cblxuICAgICAgJC5lYWNoKGNoaWxkRWRnZXMsIGZ1bmN0aW9uKGluZGV4LCBlZGdlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkSUQgPSBlZGdlWydAdGFyZ2V0J107XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGdldFRyZWVOb2RlQnlJRChjaGlsZElEKTtcbiAgICAgICAgICBpZiAoISgnQGlkJyBpbiBjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCI+Pj4+Pj4+IGNoaWxkTm9kZSBpcyBhIDxcIisgdHlwZW9mKGNoaWxkTm9kZSkgK1wiPlwiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdHNDaGlsZHJlbi5wdXNoKCBjaGlsZE5vZGUgKTtcbiAgICAgIH0pO1xuICAgICAgLy8gTi5CLiBEMyBsYXlvdXRzIGV4cGVjdCBudWxsLCBpbnN0ZWFkIG9mIGFuIGVtcHR5IGFycmF5XG4gICAgICAvLy9yZXR1cm4gKGl0c0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkgPyBudWxsOiBpdHNDaGlsZHJlbjtcbiAgICAgIHJldHVybiBpdHNDaGlsZHJlbjtcbiAgfVxuICBmdW5jdGlvbiBnZXRUcmVlTm9kZUJ5SUQoaWQpIHtcbiAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBtYXRjaGluZyAob3Igbm9uZSkgd2l0aGluIGEgdHJlZVxuICAgICAgLy8gKE5PVEUgdGhhdCB3ZSBub3cgdXNlIGEgZmxhdCBjb2xsZWN0aW9uIGFjcm9zcyBhbGwgdHJlZXMsIHNvIHRoZXJlJ3Mgbm8gJ3RyZWUnIGFyZ3VtZW50KVxuICAgICAgdmFyIGxvb2t1cCA9IGdldEZhc3RMb29rdXAoJ05PREVTX0JZX0lEJyk7XG4gICAgICByZXR1cm4gbG9va3VwWyBpZCBdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T1RVQnlJRChpZCkge1xuICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIG1hdGNoaW5nIChvciBub25lKSBpbiB0aGlzIHN0dWR5XG4gICAgICB2YXIgbG9va3VwID0gZ2V0RmFzdExvb2t1cCgnT1RVU19CWV9JRCcpO1xuICAgICAgcmV0dXJuIGxvb2t1cFsgaWQgXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRyZWVFZGdlc0J5SUQodHJlZSwgaWQsIHNvdXJjZU9yVGFyZ2V0KSB7XG4gICAgICAvLyBsb29rIGZvciBhbnkgZWRnZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgKm5vZGUqIElEOyByZXR1cm5cbiAgICAgIC8vIGFuIGFycmF5IG9mIDAsIDEsIG9yIG1vcmUgbWF0Y2hpbmcgZWRnZXMgd2l0aGluIGEgdHJlZVxuICAgICAgLy9cbiAgICAgIC8vICdzb3VyY2VPclRhcmdldCcgbGV0cyB1cyBmaWx0ZXIsIHNob3VsZCBiZSAnU09VUkNFJywgJ1RBUkdFVCcsICdBTlknXG4gICAgICB2YXIgZm91bmRFZGdlcyA9IFtdO1xuICAgICAgdmFyIG1hdGNoaW5nRWRnZXMgPSBudWxsO1xuXG4gICAgICBpZiAoKHNvdXJjZU9yVGFyZ2V0ID09PSAnU09VUkNFJykgfHwgKHNvdXJjZU9yVGFyZ2V0ID09PSAnQU5ZJykpIHtcbiAgICAgICAgICAvLyBmZXRjaCBhbmQgYWRkIGVkZ2VzIHdpdGggdGhpcyBzb3VyY2Ugbm9kZVxuICAgICAgICAgIHZhciBzb3VyY2VMb29rdXAgPSBnZXRGYXN0TG9va3VwKCdFREdFU19CWV9TT1VSQ0VfSUQnKTtcbiAgICAgICAgICBtYXRjaGluZ0VkZ2VzID0gc291cmNlTG9va3VwWyBpZCBdO1xuICAgICAgICAgIGlmIChtYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgIGZvdW5kRWRnZXMgPSBmb3VuZEVkZ2VzLmNvbmNhdCggbWF0Y2hpbmdFZGdlcyApO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChzb3VyY2VPclRhcmdldCA9PT0gJ1RBUkdFVCcpIHx8IChzb3VyY2VPclRhcmdldCA9PT0gJ0FOWScpKSB7XG4gICAgICAgICAgLy8gZmV0Y2ggYW5kIGFkZCBlZGdlcyB3aXRoIHRoaXMgdGFyZ2V0IG5vZGVcbiAgICAgICAgICB2YXIgdGFyZ2V0TG9va3VwID0gZ2V0RmFzdExvb2t1cCgnRURHRVNfQllfVEFSR0VUX0lEJyk7XG4gICAgICAgICAgbWF0Y2hpbmdFZGdlcyA9IHRhcmdldExvb2t1cFsgaWQgXTtcbiAgICAgICAgICBpZiAobWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICBmb3VuZEVkZ2VzID0gZm91bmRFZGdlcy5jb25jYXQoIG1hdGNoaW5nRWRnZXMgKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3VuZEVkZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNwZWNpZmllZFRyZWUoKSB7XG4gICAgdmFyIHRyZWUgPSBudWxsO1xuICAgIC8vIHRyeSBhbGwgaW5jb21pbmcgb3B0aW9ucyB0byBsb2NhdGUgdGhpcyB0cmVlXG4gICAgaWYgKCQudHJpbSh0cmVlSUQpICE9PSAnJykge1xuICAgICAgICB0cmVlID0gZ2V0VHJlZUJ5SUQodHJlZUlEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cmVlID0gZ2V0VHJlZUJ5UG9zaXRpb24odHJlZXNDb2xsZWN0aW9uUG9zaXRpb24sIHRyZWVQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRyZWVCeUlEKGlkKSB7XG4gICAgICB2YXIgYWxsVHJlZXMgPSBbXTtcbiAgICAgIGlmICghbmV4bWwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgICQuZWFjaChuZXhtbC50cmVlcywgZnVuY3Rpb24oaSwgdHJlZXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgJC5lYWNoKHRyZWVzQ29sbGVjdGlvbi50cmVlLCBmdW5jdGlvbihpLCB0cmVlKSB7XG4gICAgICAgICAgICAgIGFsbFRyZWVzLnB1c2goIHRyZWUgKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvdW5kVHJlZSA9IG51bGw7XG4gICAgICAkLmVhY2goIGFsbFRyZWVzLCBmdW5jdGlvbihpLCB0cmVlKSB7XG4gICAgICAgICAgaWYgKHRyZWVbJ0BpZCddID09PSBpZCkge1xuICAgICAgICAgICAgICBmb3VuZFRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmRUcmVlO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRyZWVCeVBvc2l0aW9uKGNvbGxlY3Rpb25Qb3MsIHRyZWVQb3MpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IG5leG1sLnRyZWVzW2NvbGxlY3Rpb25Qb3NdO1xuICAgIHZhciB0cmVlID0gY29sbGVjdGlvbi50cmVlW3RyZWVQb3NdO1xuICAgIHJldHVybiB0cmVlO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb3ROb2RlKCkge1xuICAgIC8vIHVzZSBvcHRpb25zIHRvIGZpbmQgdGhlIHJvb3Qgbm9kZSwgb3IgcmV0dXJuIG51bGxcbiAgICB2YXIgZm91bmRSb290ID0gbnVsbDtcbiAgICB2YXIgdHJlZSA9IGdldFNwZWNpZmllZFRyZWUoKTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzcGVjaWZpZWRSb290ID0gdHJlZVsnXm90OnNwZWNpZmllZFJvb3QnXSB8fCBudWxsO1xuICAgIHZhciByb290Tm9kZUlEID0gc3BlY2lmaWVkUm9vdCA/IHNwZWNpZmllZFJvb3QgOiB0cmVlLm5vZGVbMF1bJ0BpZCddO1xuICAgICQuZWFjaCh0cmVlLm5vZGUsIGZ1bmN0aW9uKGksIG5vZGUpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgbm9kZSB3aXRoIHRoaXMgSUQgYW5kIHNlZSBpZiBpdCBoYXMgYW4gYXNzaWduZWQgT1RVXG4gICAgICAgIGlmIChub2RlWydAaWQnXSA9PT0gcm9vdE5vZGVJRCkge1xuICAgICAgICAgICAgZm91bmRSb290ID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZFJvb3Q7XG4gIH1cbiAgLyogRU5EIG9mICdORVhzb24tc3BlY2lmaWMgbG9naWMnICovXG5cbiAgZnVuY3Rpb24gY29udmVydChmdWxsTmV4c29uKSB7XG4gICAgLy8gY29udmVydCBhIG5ldyAob3IgY2hhbmdlZD8pIHRyZWUgdG8gVHJlZSBJbGx1c3RyYXRvcidzIHByZWZlcnJlZCBmb3JtYXRcbiAgICBuZXhtbCA9IGZ1bGxOZXhzb24uZGF0YS5uZXhtbDtcblxuICAgIHZhciBsYXlvdXQgPSBkMy5sYXlvdXQuY2x1c3RlcigpICAvLyBvciB0cmVlIChzZWVtcyBtb3N0IGJhc2ljKVxuICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbihnZXROZXhzb25DaGlsZHJlbiksICAvLyBiZWxvd1xuICAgICAgICBwYXJhbXMgPSBbICdzaXplJyBdLCAgLy8gW1wicm91bmRcIiwgXCJzdGlja3lcIiwgXCJyYXRpb1wiLCBcInBhZGRpbmdcIl0sXG4gICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAvL1wieFwiOiBcInhcIixcbiAgICAgICAgICAvL1wieVwiOiBcInlcIixcbiAgICAgICAgICAvL1wiZHhcIjogXCJ3aWR0aFwiLFxuICAgICAgICAgIC8vXCJkeVwiOiBcImhlaWdodFwiXG4gICAgICAgIH07XG5cbiAgICB2YXIgcm9vdE5vZGUgPSBnZXRSb290Tm9kZSgpOyAgLy8gZGVmaW5lZCBiZWxvd1xuICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIHJvb3Qgbm9kZSBmb3VuZCFcIik7XG4gICAgICBjb25zb2xlLndhcm4oXCIgIHRyZWVJRDogXCIrIHRyZWVJRCk7XG4gICAgICBjb25zb2xlLndhcm4oXCIgIHRyZWVzQ29sbGVjdGlvblBvc2l0aW9uOiBcIisgdHJlZXNDb2xsZWN0aW9uUG9zaXRpb24pO1xuICAgICAgY29uc29sZS53YXJuKFwiICB0cmVlUG9zaXRpb246IFwiKyB0cmVlUG9zaXRpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGEgPSB7XG4gICAgICAgIC8vIGNvcHkgX2lkIG9mIHNvdXJjZSBkYXRhXG4gICAgICAgICdfaWQnOiBmdWxsTmV4c29uLl9pZFxuICAgIH07XG5cbiAgICBkYXRhLnBoeWxvTm9kZXMgPSBsYXlvdXRcbiAgICAgIC8vLnNpemUodmcuZGF0YS5zaXplKHNpemUsIGdyb3VwKSlcbiAgICAgIC8vLnZhbHVlKHZhbHVlKVxuICAgICAgICAubm9kZXMocm9vdE5vZGUpO1xuXG4gICAgLy8gYWRkIGFsbCBwb3NzaWJsZSBsYWJlbHMgdG8gZWFjaCBub2RlXG4gICAgdmFyIHRyZWUgPSBnZXRTcGVjaWZpZWRUcmVlKCk7XG4gICAgJC5lYWNoKGRhdGEucGh5bG9Ob2RlcywgZnVuY3Rpb24oaSwgbm9kZSkge1xuICAgICAgLyogTi5CLiBJdCdzIGJlc3QgdG8gcHJvdmlkZSBhdCBsZWFzdCBhbiBlbXB0eSBzdHJpbmcgZm9yIGFsbFxuICAgICAgICogcHJvcGVydGllcywgdG8gYXZvaWQgc2hvd2luZyAndW5kZWZpbmVkJyBsYWJlbHMgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAqL1xuICAgICAgbm9kZS5leHBsaWNpdExhYmVsID0gJyc7XG4gICAgICBub2RlLm9yaWdpbmFsTGFiZWwgPSAnJztcbiAgICAgIG5vZGUub3R0VGF4b25OYW1lID0gJyc7XG4gICAgICBub2RlLm90dElkID0gJyc7XG4gICAgICBpZiAoJ2xhYmVsJyBpbiBub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4gbm9kZSBcIisgaSArXCIgaGFzICdsYWJlbCdcIik7XG4gICAgICAgIG5vZGUuZXhwbGljaXRMYWJlbCA9IG5vZGVbJ2xhYmVsJ107XG4gICAgICB9XG4gICAgICBpZiAoJ0BsYWJlbCcgaW4gbm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+IG5vZGUgXCIrIGkgK1wiIGhhcyAnQGxhYmVsJ1wiKTtcbiAgICAgICAgbm9kZS5leHBsaWNpdExhYmVsID0gbm9kZVsnQGxhYmVsJ107XG4gICAgICB9XG4gICAgICBpZiAoJ0BvdHUnIGluIG5vZGUpIHtcbiAgICAgICAgdmFyIGl0c09UVSA9IGdldE9UVUJ5SUQoIG5vZGVbJ0BvdHUnXSApO1xuICAgICAgICAvLyBhdHRhY2ggT1RVIHdpdGggcG9zc2libGUgbGFiZWwocykgaGVyZVxuICAgICAgICBpZiAoaXRzT1RVKSB7XG4gICAgICAgICAgLy8gbnVkZ2UgdGhlIHJlbGV2YW50IHByb3BlcnRpZXMgaW50byBhIGdlbmVyaWMgZm9ybVxuICAgICAgICAgIGlmICgnXm90Om9yaWdpbmFsTGFiZWwnIGluIGl0c09UVSkge1xuICAgICAgICAgICAgbm9kZS5vcmlnaW5hbExhYmVsID0gaXRzT1RVWydeb3Q6b3JpZ2luYWxMYWJlbCddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ15vdDpvdHRUYXhvbk5hbWUnIGluIGl0c09UVSkge1xuICAgICAgICAgICAgbm9kZS5vdHRUYXhvbk5hbWUgPSBpdHNPVFVbJ15vdDpvdHRUYXhvbk5hbWUnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdeb3Q6b3R0SWQnIGluIGl0c09UVSkge1xuICAgICAgICAgICAgbm9kZS5vdHRJZCA9IGl0c09UVVsnXm90Om90dElkJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnQGxhYmVsJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdW5jb21tb24sIGJ1dCBhcHBlYXJzIGluIG91ciBjb252ZXJ0ZWQgTmV3aWNrLlxuICAgICAgICAgICAgLy8gWWllbGQgdG8gYW4gZXhwbGljaXQgbGFiZWwgb24gdGhlIG5vZGUgaXRzZWxmIVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCI+PiBzdGVhbGluZyBvdHUgbGFiZWwgJ1wiKyBpdHNPVFVbJ0BsYWJlbCddICtcIicgZm9yIHRoaXMgbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICgkLnRyaW0obm9kZS5leHBsaWNpdExhYmVsKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgbm9kZS5leHBsaWNpdExhYmVsID0gaXRzT1RVWydAbGFiZWwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRhdGEucGh5bG9FZGdlcyA9IGxheW91dC5saW5rcyhkYXRhLnBoeWxvTm9kZXMpO1xuLyogdHJhbnNsYXRlIGluY29taW5nIGtleXMgdG8gdGhlaXIgb3V0cHV0IG5hbWVzP1xuICAgIHZhciBrZXlzID0gdmcua2V5cyhvdXRwdXQpLFxuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICB2YXIga2V5LCB2YWw7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSAhPT0gb3V0cHV0W2tleV0pIHtcbiAgICAgICAgICB2YWwgPSBkW2tleV07XG4gICAgICAgICAgZGVsZXRlIGRba2V5XTtcbiAgICAgICAgICBkW291dHB1dFtrZXldXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9kLmNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oZCk7XG4gICAgfSk7XG4qL1xuXG5cbi8qXG4gICAgY29uc29sZS5sb2coXCJPVVRHT0lORyBkYXRhIGZyb20gbmV4c29uIHRyYW5zZm9ybTpcIik7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4qL1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIFxuICAvL2lucHV0LmFkZC5mb3JFYWNoKGNvbnZlcnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LmFkZC5sZW5ndGg7IGkrKykge1xuICAgIC8vIGFjdHVhbGx5IHJlcGxhY2UgZWFjaCBpdGVtIHdpdGggdGhlIG5ldyBzdHVjdHVyZVxuICAgIGlucHV0LmFkZFtpXSA9IGNvbnZlcnQoaW5wdXQuYWRkW2ldKTtcbiAgfVxuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIC8vaW5wdXQubW9kLmZvckVhY2goY29udmVydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5tb2QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGFjdHVhbGx5IHJlcGxhY2UgZWFjaCBpdGVtIHdpdGggdGhlIG5ldyBzdHVjdHVyZVxuICAgICAgaW5wdXQubW9kW2ldID0gY29udmVydChpbnB1dC5tb2RbaV0pO1xuICAgIH1cbiAgfVxuICAvLyByZXR1cm4gdGhlIG1vZGlmaWVkIENoYW5nZVNldFxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5leHNvbjtcblxuTmV4c29uLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJOZXhzb24gdHJhbnNmb3JtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUcmFuc2Zvcm1zIE5FWHNvbiBkYXRhIGludG8gYSBmb3JtIHN1aXRhYmxlIGZvciB1c2UgaW4gdGhlIFRyZWUgSWxsdXN0cmF0b3JcIlxuICAgICAgICAgICAgICAgKyBcIiBhbmQgZDMucGh5bG9ncmFtLmpzLlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1wiZW51bVwiOiBbXCJuZXhzb25cIl19LFxuICAgIFwidHJlZUlEXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBleHBsaWNpdCB0cmVlIElEIChzaG91bGQgYmUgZGVmaW5pdGl2ZSlcIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJzdHJpbmdcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSAgLy8gVE9ETzogc2lnbmFsP1xuICAgIH0sXG4gICAgXCJ0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvblwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9vayBpbiB0aGUgbnRoICd0cmVlcycgZWxlbWVudCAoY29sbGVjdGlvbiBvZiAndHJlZScpXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwiaW50ZWdlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLCAgLy8gVE9ETzogc2lnbmFsP1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIFwidHJlZVBvc2l0aW9uXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb252ZXJ0IHRoZSBudGggJ3RyZWUnIGZvdW5kIGluIHRoaXMgY29sbGVjdGlvblwiLCAvLyBUT0RPOiBjb25maXJtXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwiaW50ZWdlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsICAvLyBUT0RPOiBjb25maXJtIHRoaXNcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eXBlXCJdICAvLyBUT0RPOiBhZGQgcmVxdWlyZWQgcGFyYW1zXG59O1xuXG5cblxuXG5cblxuXG5pZiAoZmFsc2UpIHtcblxudmcudHJhbnNmb3Jtcy5uZXhzb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxheW91dCA9IGQzLmxheW91dC5jbHVzdGVyKCkgIC8vIG9yIHRyZWUgKHNlZW1zIG1vc3QgYmFzaWMpXG4gICAgICAgICAgICAgICAgIC8vLmNoaWxkcmVuKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzOyB9KSxcbiAgICAgICAgICAgICAgICAgLy8uc2l6ZShbMjAsMjBdKSAgLy8gZGVmYXVsdHMgdG8gWzEuMCwgMS4wXVxuICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oZ2V0TmV4c29uQ2hpbGRyZW4pLCAgLy8gYmVsb3dcbiAgICAgIHZhbHVlID0gdmcuYWNjZXNzb3IoXCJkYXRhXCIpLFxuICAgICAgZnVsbE5leHNvbiA9IG51bGwsXG4gICAgICBuZXhtbCA9IG51bGwsXG4gICAgICAvL3NpemUgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgICAgIHBhcmFtcyA9IFsgJ3NpemUnIF0sICAvLyBbXCJyb3VuZFwiLCBcInN0aWNreVwiLCBcInJhdGlvXCIsIFwicGFkZGluZ1wiXSxcbiAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgLy9cInhcIjogXCJ4XCIsXG4gICAgICAgIC8vXCJ5XCI6IFwieVwiLFxuICAgICAgICAvL1wiZHhcIjogXCJ3aWR0aFwiLFxuICAgICAgICAvL1wiZHlcIjogXCJoZWlnaHRcIlxuICAgICAgfTtcblxuICAvLyBFeHBlY3QgdGhlIElEIG9mIHRoZSBzcGVjaWZpZWQgdHJlZSwgb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWRcbiAgLy8gdHJlZXMgY29sbGVjdGlvbiBhbmQgdHJlZS5cbiAgdmFyIHRyZWVJRCA9IG51bGwsXG4gICAgICB0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbiA9IDAsXG4gICAgICB0cmVlUG9zaXRpb24gPSAwO1xuXG4gIGZ1bmN0aW9uIG5leHNvbihkYXRhLCBkYiwgZ3JvdXApIHtcbi8qXG5jb25zb2xlLmxvZyhcIklOQ09NSU5HIGRhdGEgdG8gbmV4c29uIHRyYW5zZm9ybTpcIik7XG5jb25zb2xlLmxvZyhkYXRhKTtcbiovXG4gICAgZnVsbE5leHNvbiA9IGRhdGFbJ2RhdGEnXTsgIC8vIHN0YXNoIHRoZSBjb21wbGV0ZSBORVhzb24hXG4gICAgbmV4bWwgPSBmdWxsTmV4c29uLmRhdGEubmV4bWw7XG4gICAgdmFyIHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUoKTsgIC8vIGRlZmluZWQgYmVsb3dcbiAgICBpZiAoIXJvb3ROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHJvb3Qgbm9kZSBmb3VuZCFcIik7XG4gICAgICAgIGNvbnNvbGUud2FybihcIiAgdHJlZUlEOiBcIisgdHJlZUlEKTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiICB0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbjogXCIrIHRyZWVzQ29sbGVjdGlvblBvc2l0aW9uKTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiICB0cmVlUG9zaXRpb246IFwiKyB0cmVlUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YSA9IHt9O1xuXG4gICAgZGF0YS5waHlsb05vZGVzID0gbGF5b3V0XG4gICAgICAvLy5zaXplKHZnLmRhdGEuc2l6ZShzaXplLCBncm91cCkpXG4gICAgICAvLy52YWx1ZSh2YWx1ZSlcbiAgICAgIC5ub2Rlcyhyb290Tm9kZSk7XG5cbiAgICAvLyBhZGQgYWxsIHBvc3NpYmxlIGxhYmVscyB0byBlYWNoIG5vZGVcbiAgICB2YXIgdHJlZSA9IGdldFNwZWNpZmllZFRyZWUoKTtcbiAgICAkLmVhY2goZGF0YS5waHlsb05vZGVzLCBmdW5jdGlvbihpLCBub2RlKSB7XG4gICAgICAgIC8qIE4uQi4gSXQncyBiZXN0IHRvIHByb3ZpZGUgYXQgbGVhc3QgYW4gZW1wdHkgc3RyaW5nIGZvciBhbGxcbiAgICAgICAgICogcHJvcGVydGllcywgdG8gYXZvaWQgc2hvd2luZyAndW5kZWZpbmVkJyBsYWJlbHMgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGUuZXhwbGljaXRMYWJlbCA9ICcnO1xuICAgICAgICBub2RlLm9yaWdpbmFsTGFiZWwgPSAnJztcbiAgICAgICAgbm9kZS5vdHRUYXhvbk5hbWUgPSAnJztcbiAgICAgICAgbm9kZS5vdHRJZCA9ICcnO1xuICAgICAgICBpZiAoJ2xhYmVsJyBpbiBub2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIj4+IG5vZGUgXCIrIGkgK1wiIGhhcyAnbGFiZWwnXCIpO1xuICAgICAgICAgICAgbm9kZS5leHBsaWNpdExhYmVsID0gbm9kZVsnbGFiZWwnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ0BsYWJlbCcgaW4gbm9kZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCI+PiBub2RlIFwiKyBpICtcIiBoYXMgJ0BsYWJlbCdcIik7XG4gICAgICAgICAgICBub2RlLmV4cGxpY2l0TGFiZWwgPSBub2RlWydAbGFiZWwnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ0BvdHUnIGluIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpdHNPVFUgPSBnZXRPVFVCeUlEKCBub2RlWydAb3R1J10gKTtcbiAgICAgICAgICAgIC8vIGF0dGFjaCBPVFUgd2l0aCBwb3NzaWJsZSBsYWJlbChzKSBoZXJlXG4gICAgICAgICAgICBpZiAoaXRzT1RVKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVkZ2UgdGhlIHJlbGV2YW50IHByb3BlcnRpZXMgaW50byBhIGdlbmVyaWMgZm9ybVxuICAgICAgICAgICAgICAgIGlmICgnXm90Om9yaWdpbmFsTGFiZWwnIGluIGl0c09UVSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9yaWdpbmFsTGFiZWwgPSBpdHNPVFVbJ15vdDpvcmlnaW5hbExhYmVsJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnXm90Om90dFRheG9uTmFtZScgaW4gaXRzT1RVKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub3R0VGF4b25OYW1lID0gaXRzT1RVWydeb3Q6b3R0VGF4b25OYW1lJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnXm90Om90dElkJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vdHRJZCA9IGl0c09UVVsnXm90Om90dElkJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnQGxhYmVsJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGFwcGVhcnMgaW4gb3VyIGNvbnZlcnRlZCBOZXdpY2suXG4gICAgICAgICAgICAgICAgICAgIC8vIFlpZWxkIHRvIGFuIGV4cGxpY2l0IGxhYmVsIG9uIHRoZSBub2RlIGl0c2VsZiFcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCI+PiBzdGVhbGluZyBvdHUgbGFiZWwgJ1wiKyBpdHNPVFVbJ0BsYWJlbCddICtcIicgZm9yIHRoaXMgbm9kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQudHJpbShub2RlLmV4cGxpY2l0TGFiZWwpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5leHBsaWNpdExhYmVsID0gaXRzT1RVWydAbGFiZWwnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRhdGEucGh5bG9FZGdlcyA9IGxheW91dC5saW5rcyhkYXRhLnBoeWxvTm9kZXMpO1xuLyogdHJhbnNsYXRlIGluY29taW5nIGtleXMgdG8gdGhlaXIgb3V0cHV0IG5hbWVzP1xuICAgIHZhciBrZXlzID0gdmcua2V5cyhvdXRwdXQpLFxuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICB2YXIga2V5LCB2YWw7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSAhPT0gb3V0cHV0W2tleV0pIHtcbiAgICAgICAgICB2YWwgPSBkW2tleV07XG4gICAgICAgICAgZGVsZXRlIGRba2V5XTtcbiAgICAgICAgICBkW291dHB1dFtrZXldXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9kLmNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oZCk7XG4gICAgfSk7XG4qL1xuXG4gICAgXG4vKlxuICAgIGNvbnNvbGUubG9nKFwiT1VUR09JTkcgZGF0YSBmcm9tIG5leHNvbiB0cmFuc2Zvcm06XCIpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuKi9cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIG5leHNvbi52YWx1ZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgdmFsdWUgPSB2Zy5hY2Nlc3NvcihmaWVsZCk7XG4gICAgcmV0dXJuIG5leHNvbjtcbiAgfTtcblxuICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgbmV4c29uW25hbWVdID0gZnVuY3Rpb24oeCkge1xuICAgICAgbGF5b3V0W25hbWVdKHgpO1xuICAgICAgcmV0dXJuIG5leHNvbjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHN0b2xlbiBmcm9tIGZhY2V0LmpzXG4gIG5leHNvbi5rZXlzID0gZnVuY3Rpb24oaykge1xuICAgIGtleXMgPSB2Zy5hcnJheShrKS5tYXAodmcuYWNjZXNzb3IpO1xuICAgIHJldHVybiBuZXhzb247XG4gIH07XG4gIG5leHNvbi5zb3J0ID0gZnVuY3Rpb24ocykge1xuICAgIHNvcnQgPSB2Zy5kYXRhLnNvcnQoKS5ieShzKTtcbiAgICByZXR1cm4gbmV4c29uO1xuICB9O1xuXG4gIC8vIEV4cG9zZSBtZXRob2RzIHRvIGFjY2VwdCB0cmVlIElEIChvciBvcmRpbmFsIHBvc2l0aW9uIG9mIHRoZSBcbiAgLy8gZGVzaXJlZCB0cmVlcyBjb2xsZWN0aW9uIGFuZCBhIHRyZWUgd2l0aGluIGl0KS5cbiAgbmV4c29uLnRyZWVJRCA9IGZ1bmN0aW9uKHMpIHtcbiAgICB0cmVlSUQgPSBzO1xuICAgIHJldHVybiBuZXhzb247XG4gIH07XG4gIG5leHNvbi50cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbiA9IG47XG4gICAgcmV0dXJuIG5leHNvbjtcbiAgfTtcbiAgbmV4c29uLnRyZWVQb3NpdGlvbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0cmVlUG9zaXRpb24gPSBuO1xuICAgIHJldHVybiBuZXhzb247XG4gIH07XG5cbiAgICAvKlxuICAgICAqIE5FWHNvbi1zcGVjaWZpYyBsb2dpYywgZW5jYXBzdWxhdGVkIGZvciBlYXN5IGFjY2VzcyB0byBuZXhtbCwgZXRjLlxuTU9WRURcbiAgICAgKi9cblxuICBuZXhzb24ub3V0cHV0ID0gZnVuY3Rpb24obWFwKSB7XG4gICAgLy8gYnVpbGQgY2hpbGRyZW5cbiAgICB2Zy5rZXlzKG91dHB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAobWFwW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0W2tdID0gbWFwW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXhzb247XG4gIH07XG5cbiAgcmV0dXJuIG5leHNvbjtcbn07XG5cbn1cblxuXG4iLCIvKlxuICAoSGVhdmlseSkgYWRhcHRlZCBmcm9tIEtlbi1pY2hpIFVlZGEncyAnZDMucGh5bG9ncmFtLmpzJ1xuXG4gIFdyYXBwZXIgYXJvdW5kIGEgZDMtYmFzZWQgcGh5bG9ncmFtICh0cmVlIHdoZXJlIGJyYW5jaCBsZW5ndGhzIGFyZSBzY2FsZWQpLFxuICByZWZhY3RvcmVkIGludG8gYSBWZWdhIHRyYW5zZm9ybS4gV2hhdCBkb2VzIHRoaXMgY2hhbmdlP1xuICAgIC0gUmV0dXJucyB0cmFuc2Zvcm1lZCBkYXRhIChhbiBvYmplY3Qgd2l0aCBub2RlcyBhbmQgbGlua3MsIHByb2plY3RlZCB0b1xuICAgICAgdGhlIGNvb3JkaW5hdGUgc3BhY2UgYmFzZWQgb24gdGhlIGNob3NlbiBsYXlvdXQpLlxuICAgIC0gQXNzdW1lcyBhbGwgaW5jb21pbmcgZGF0YSBoYXMgcHJvcG9ydGlvbmFsIHgveSB2YWx1ZXMgKDAuMCB0byAxLjApLlxuICAgIC0gRG9lc24ndCByZW5kZXIgYW55dGhpbmchIEp1c3QgcGFzc2VzIHRoZSBwcm9qZWN0ZWQgZGF0YSBmb3IgZG93bnN0cmVhbVxuICAgICAgcmVuZGVyaW5nLlxuXG4gIFRoaXMgaW5jbHVkZXMgbmV3IGFuZCBtb2RpZmllZCBsYXlvdXRzLCBpbmNsdWRpbmdcbiAgICAtIHJhZGlhbCAoY2lyY3VsYXIpIGxheW91dCB3aXRoICpzY2FsZWQqIGJyYW5jaCBsZW5ndGhzXG4gICAgLSBhIHRyYWRpdGlvbmFsIGNsYWRvZ3JhbSB3aXRoIHN0cmFpZ2h0LCBkaWFnb25hbCBlZGdlc1xuXG4gIENvcHlyaWdodCAoYykgMjAxNCwgSmltIEFsbG1hblxuICBDb3B5cmlnaHQgKGMpIDIwMTMsIEtlbi1pY2hpIFVlZGFcblxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnlcbiAgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kXG4gIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAgQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbiAgRE9DVU1FTlRBVElPTlxuXG4gIGJ1aWxkQ2FydGVzaWFuKG5vZGVzLCBsaW5rcywgb3B0aW9ucylcbiAgICBDcmVhdGVzIGEgcGh5bG9ncmFtLlxuICAgIEFyZ3VtZW50czpcbiAgICAgIG5vZGVzOiBKUyBhcnJheSBvZiBub2Rlc1xuICAgICAgbGlua3M6IEpTIGFycmF5IG9mIGxpbmtzXG4gICAgT3B0aW9uczpcbiAgICAgIHRyZWVcbiAgICAgICAgUHJlLWNvbnN0cnVjdGVkIGQzIHRyZWUgbGF5b3V0LlxuICAgICAgZGlhZ29uYWxcbiAgICAgICAgRnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBkIGF0dHJpYnV0ZSBmb3IgYW4gc3ZnOnBhdGguIERlZmF1bHRzIHRvIGFcbiAgICAgICAgcmlnaHQtYW5nbGUgZGlhZ29uYWwuXG4gICAgICBza2lwVGlja3NcbiAgICAgICAgU2tpcCB0aGUgdGljayBydWxlLlxuICAgICAgc2tpcEJyYW5jaExlbmd0aFNjYWxpbmdcbiAgICAgICAgTWFrZSBhIGRlbmRyb2dyYW0gaW5zdGVhZCBvZiBhIHBoeWxvZ3JhbS5cbiAgXG4gIGJ1aWxkUmFkaWFsKG5vZGVzLCBsaW5rcywgb3B0aW9ucylcbiAgICBDcmVhdGVzIGEgcmFkaWFsIGRlbmRyb2dyYW0uXG4gICAgT3B0aW9uczogc2FtZSBhcyBidWlsZCwgYnV0IHdpdGhvdXQgZGlhZ29uYWwsIHNraXBUaWNrcywgYW5kXG4gICAgICBza2lwQnJhbmNoTGVuZ3RoU2NhbGluZ1xuICBcbiAgYnVpbGRDbGFkb2dyYW0obm9kZXMsIGxpbmtzLCBvcHRpb25zKVxuICAgIENyZWF0ZXMgYSBcInRyaWFuZ3VsYXJcIiBkZW5kcm9ncmFtXG4gICAgT3B0aW9uczogVE9ET1xuXG4gIHJpZ2h0QW5nbGVEaWFnb25hbCgpXG4gICAgU2ltaWxhciB0byBkMy5kaWFnb25hbCBleGNlcHQgaXQgY3JlYXRlIGFuIG9ydGhvZ29uYWwgY3Jvb2sgaW5zdGVhZCBvZiBhXG4gICAgc21vb3RoIEJlemllciBjdXJ2ZS5cbiAgICBcbiAgcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsKClcbiAgICBkMy5waHlsb2dyYW0ucmlnaHRBbmdsZURpYWdvbmFsIGZvciByYWRpYWwgbGF5b3V0cy5cbiovXG52YXIgdmcgID0gcmVxdWlyZSgndmVnYScpLFxuICAgIGxvZyAgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBQaHlsb2dyYW0oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgbGF5b3V0OiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ2NhcnRlc2lhbid9LFxuICAgIHdpZHRoOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMS4wfSxcbiAgICBoZWlnaHQ6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAxLjB9LFxuICAgIC8vIHNvbWUgYXJlIG9ubHkgdXNlZCBpbiByYWRpYWwgbGF5b3V0LCBpZ25vcmVkIGluIG90aGVyc1xuICAgIHJhZGl1czoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDAuNX0sXG4gICAgcmFkaWFsQXJjOiB7dHlwZTogJ2FycmF5PHZhbHVlPicsIGRlZmF1bHQ6IFswLCAzNjBdfSxcbiAgICByYWRpYWxTd2VlcDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdDTE9DS1dJU0UnfSwgIC8vICdDTE9DS1dJU0UnIHwgJ0NPVU5URVJDTE9DS1dJU0UnXG4gICAgLy8gb3RoZXJzIGFyZSB1c2VkIG9ubHkgaW4gbm9uLXJhZGlhbCBsYXlvdXRzXG4gICAgdGlwc0FsaWdubWVudDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdSSUdIVCd9LFxuICAgIGJyYW5jaFN0eWxlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJyd9LCAvLyB1c3UuIGRldGVybWluZWQgYnkgbGF5b3V0XG4gICAgYnJhbmNoTGVuZ3Roczoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICcnfSxcbiAgICBub2RlTGFiZWxTb3VyY2U6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnTUFQUEVEJ30sIC8vICdPUklHSU5BTCcgfCAnTUFQUEVEJ1xuICAgIHNob3dGYWxsYmFja0xhYmVsczoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IHRydWV9XG4gICAgLy8gc29tZSBhcmUgcmVja29uZWQgaW50ZXJuYWxseSAobm90IGF2YWlsYWJsZSB0byB0aGUgY2FsbGVyKVxuICAgIC8vZGVzY2VudEF4aXM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAneCd9LCAvLyAneCcgfCAneSdcbiAgICAvL29yaWVudGF0aW9uOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogLTkwfSxcbiAgfSk7XG4gIHJldHVybiB0aGlzLnByb2R1Y2VzKHRydWUpXG4gICAgICAgICAgICAgLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoUGh5bG9ncmFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGh5bG9ncmFtO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ21ha2luZyBhIHBoeWxvZ3JhbSddKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LmFkZC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuYnVpbGRQaHlsb2dyYW0oaW5wdXQuYWRkW2ldKTtcbiAgfVxuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubW9kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJ1aWxkUGh5bG9ncmFtKGlucHV0Lm1vZFtpXSk7XG4gICAgfVxuICB9XG4gIC8qIE4uQi4gVHlwaWNhbCBub3RhdGlvbiBkb2Vzbid0IHdvcmsgaGVyZSAoJ3RoaXMnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBjYWxsZWQgZnVuYylcbiAgaW5wdXQuYWRkLmZvckVhY2goKTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaCh0aGlzLmJ1aWxkUGh5bG9ncmFtKTtcbiAgfVxuICAqL1xuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbnByb3RvdHlwZS5idWlsZFBoeWxvZ3JhbSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvLyByZWFkIGluIHBhcmFtc1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLnBhcmFtKCdsYXlvdXQnKTsgIC8vICdjYXJ0ZXNpYW4nIHwgJ3JhZGlhbCcgfCAnY2xhZG9ncmFtJyB8ID8/P1xuXG4gICAgLy8gTk9URSB0aGF0IHdpZHRoIGFuZCBoZWlnaHQgcmVmZXIgdG8gdGhlIGZpbmFsIGRpc3BsYXksIHNvIHRoZXNlIG1pZ2h0XG4gICAgLy8gbWFwIHRvIFggb3IgWSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gb3JpZW50YXRpb25cbiAgICB2YXIgd2lkdGggPSB0aGlzLnBhcmFtKCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLnBhcmFtKCdoZWlnaHQnKTtcbiAgICB2YXIgcmFkaXVzID0gdGhpcy5wYXJhbSgncmFkaXVzJyk7ICAvLyBmb3IgcmFkaWFsIGxheW91dFxuICAgIHZhciByYWRpYWxBcmMgPSB0aGlzLnBhcmFtKCdyYWRpYWxBcmMnKTsgIC8vIGFuZ2xlcyBvZiBhcmMgKHJhZGlhbCBsYXlvdXQgb25seSlcbiAgICB2YXIgcmFkaWFsU3dlZXAgPSB0aGlzLnBhcmFtKCdyYWRpYWxTd2VlcCcpOyAgLy8gJ0NMT0NLV0lTRScgb3IgJ0NPVU5URVJDTE9DS1dJU0UnXG4gICAgdmFyIGJyYW5jaFN0eWxlID0gdGhpcy5wYXJhbSgnYnJhbmNoU3R5bGUnKTtcbiAgICAgICAgLy8gJ3JpZ2h0QW5nbGVEaWFnb25hbCcsICdyYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWwnLCBvciBhIHN0YW5kYXJkXG4gICAgICAgIC8vIEQzIGRpYWdvbmFsOyBieSBkZWZhdWx0LCB0aGlzIHdpbGwgYmUgYmFzZWQgb24gdGhlIGNob3NlbiBsYXlvdXRcbiAgICB2YXIgYnJhbmNoTGVuZ3RocyA9IHRoaXMucGFyYW0oJ2JyYW5jaExlbmd0aHMnKTtcbiAgICB2YXIgdGlwc0FsaWdubWVudCA9IHRoaXMucGFyYW0oJ3RpcHNBbGlnbm1lbnQnKTtcbiAgICAgICAgLy8gZGlzcmVnYXJkIGZvciByYWRpYWwgbGF5b3V0cz9cbiAgICB2YXIgb3JpZW50YXRpb247IC8vIHRoaXMucGFyYW0oJ29yaWVudGF0aW9uJyk7XG4gICAgICAgIC8vIGRlZ3JlZXMgb2Ygcm90YXRpb24gZnJvbSBkZWZhdWx0ICgwLCAtOTAsIDkwLCAxODApXG4gICAgICAgIC8vIE5PVEUgdGhhdCB0aGlzIGlzIG5vdCBzZXQgZGlyZWN0bHkgKGZyb20gdmVnYSBzcGVjKSBidXQgZnJvbSB3aXRoaW5cbiAgICB2YXIgZGVzY2VudEF4aXM7IC8vIHRoaXMucGFyYW0oJ2Rlc2NlbnRBeGlzJyk7XG4gICAgICAgIC8vIG5lZWRlZCB0byByZW5kZXIgcGF0aHMgY29ycmVjdGx5XG4gICAgICAgIC8vIFRPRE86IGFkZCBtb3JlIGZyb20gb3B0aW9ucyBiZWxvd1xuICAgIHZhciBub2RlTGFiZWxTb3VyY2UgPSB0aGlzLnBhcmFtKCdub2RlTGFiZWxTb3VyY2UnKTsgIC8vICdPUklHSU5BTCcgb3IgJ01BUFBFRCdcbiAgICAgICAgLy8gY2hvb3NlIHByZWZlcnJlZCBzb3VyY2UgZm9yIGxhYmVsczsgZmFsbCBiYWNrIGFzIG5lZWRlZCBhbmQgdXNlIG1hcmtlciBjbGFzc2VzXG4gICAgICAgIC8vIHRvIGRpc3Rpbmd1aXNoIHRoZXNlIGluIGRpc3BsYXlcbiAgICB2YXIgc2hvd0ZhbGxiYWNrTGFiZWxzID0gdGhpcy5wYXJhbSgnc2hvd0ZhbGxiYWNrTGFiZWxzJyk7ICAvLyBib29sZWFuXG5cbiAgICAvKiBhcHBseSBzb21lIGludGVybmFsIGNvbnN0cmFpbnRzIChmb3JtZXJseSBpbiBwYXJhbSBzZXR0ZXJzKSAqL1xuXG4gICAgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgIC8vIE4uQi4gcmFkaWFsIGxheW91dCBuZWVkcyBmaXhlZCAoLTkwKSBvcmllbnRhdGlvblxuICAgICAgb3JpZW50YXRpb24gPSAtOTA7XG4gICAgICBkZXNjZW50QXhpcyA9ICd4JztcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoKHRpcHNBbGlnbm1lbnQpIHtcbiAgICAgICAgY2FzZSAnVE9QJzpcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IDE4MDtcbiAgICAgICAgICBkZXNjZW50QXhpcyA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUklHSFQnOlxuICAgICAgICAgIG9yaWVudGF0aW9uID0gLTkwO1xuICAgICAgICAgIGRlc2NlbnRBeGlzID0gJ3gnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCT1RUT00nOlxuICAgICAgICAgIG9yaWVudGF0aW9uID0gMDtcbiAgICAgICAgICBkZXNjZW50QXhpcyA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgb3JpZW50YXRpb24gPSA5MDtcbiAgICAgICAgICBkZXNjZW50QXhpcyA9ICd4JztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaHlsb2dyYW0oZGF0YSkge1xuICAgICAgLy8gRXhwZWN0aW5nIGluY29taW5nIGRhdGEgaW4gdGhlICdwaHlsb3RyZWUnIGZvcm1hdCBkZXNjcmliZWQgaGVyZTpcbiAgICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vT3BlblRyZWVPZkxpZmUvdHJlZS1pbGx1c3RyYXRvci93aWtpL0J1aWxkaW5nLW9uLUQzLWFuZC1WZWdhXG5cbiAgICAgIC8vY29uc29sZS5sb2coJ1NUQVJUSU5HIHBoeWxvZ3JhbSB0cmFuc2Zvcm0uLi4nKTtcblxuICAgICAgLy8gc2NhbGUgYWxsIGNvb3JkaW5hdGVzIGFzIGRpcmVjdGVkXG4gICAgICBpZiAoKHdpZHRoICE9PSAxLjApIHx8IChoZWlnaHQgIT09IDEuMCkpIHtcbiAgICAgICAgICBkYXRhLnBoeWxvTm9kZXMubWFwKHNjYWxlUG9pbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24gIT09IDApIHtcbiAgICAgICAgICAvLyByb3RhdGUgYWxsIG5vZGVzIGJ5IG4gZGVncmVlc1xuICAgICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAocm90YXRlUG9pbnRCeU9yaWVudGF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgdGhlIGNob3NlbiBsYXlvdXQsIGluIGEgMXgxIFwidmlydHVhbCBzcGFjZVwiLi4/XG4gICAgICB2YXIgbGF5b3V0R2VuZXJhdG9yO1xuICAgICAgc3dpdGNoKGxheW91dCkge1xuICAgICAgICAgIGNhc2UgJ3JhZGlhbCc6XG4gICAgICAgICAgICAgIGxheW91dEdlbmVyYXRvciA9IHJhZGlhbExheW91dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2xhZG9ncmFtJzpcbiAgICAgICAgICAgICAgbGF5b3V0R2VuZXJhdG9yID0gY2xhZG9ncmFtTGF5b3V0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYXJ0ZXNpYW4nOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxheW91dEdlbmVyYXRvciA9IGNhcnRlc2lhbkxheW91dDtcbiAgICAgIH1cbiAgICAgIGxheW91dEdlbmVyYXRvcihkYXRhKTtcblxuICAgICAgLy8gc2V0IChvciByZXZpc2UpIHBhdGhzIGZvciBhbGwgbGlua3NcbiAgICAgIHZhciBwYXRoR2VuZXJhdG9yO1xuICAgICAgc3dpdGNoKGJyYW5jaFN0eWxlKSB7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAvLyBpZiBub25lIHNwZWNpZmllZCwgbWF0Y2ggdGhlIGxheW91dFxuICAgICAgICAgICAgc3dpdGNoKGxheW91dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlhbCc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSByYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhZG9ncmFtJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IHN0cmFpZ2h0TGluZURpYWdvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NhcnRlc2lhbic6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSByaWdodEFuZ2xlRGlhZ29uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgZm9yIG1vcmV0cmFkaXRpb25hbCBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gZDMuc3ZnW2JyYW5jaFN0eWxlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmFpZ2h0TGluZURpYWdvbmFsJzpcbiAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBzdHJhaWdodExpbmVEaWFnb25hbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlhbFJpZ2h0QW5nbGVEaWFnb25hbCc6XG4gICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHRBbmdsZURpYWdvbmFsJzpcbiAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSByaWdodEFuZ2xlRGlhZ29uYWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaWFnb25hbCc6XG4gICAgICAgICAgICAvLyBpbnRlcmNlcHQgYW5kIHN3aXRjaCBpdHMgeC95IGJpYXNcbiAgICAgICAgICAgIGlmIChkZXNjZW50QXhpcyA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29waWVkIGZyb20gdmcuZGF0YS5saW5rID4gZGlhZ29uYWxYXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gZC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gZC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gKHMueCArIHQueCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBzLnggKyBcIixcIiArIHMueVxuICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJDXCIgKyBtICAgKyBcIixcIiArIHMueVxuICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgXCIgKyBtICAgKyBcIixcIiArIHQueVxuICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgXCIgKyB0LnggKyBcIixcIiArIHQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcGllZCBmcm9tIHZnLmRhdGEubGluayA+IGRpYWdvbmFsWVxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGQuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IChzLnkgKyB0LnkpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgcy54ICsgXCIsXCIgKyBzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICArIFwiQ1wiICsgcy54ICsgXCIsXCIgKyBtXG4gICAgICAgICAgICAgICAgICAgICAgICAgKyBcIiBcIiArIHQueCArIFwiLFwiICsgbVxuICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgXCIgKyB0LnggKyBcIixcIiArIHQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmFkaWFsJzpcbiAgICAgICAgICAgIC8vIGludGVyY2VwdCBhbmQgc3dpdGNoIGl0cyB4L3kgYmlhc1xuICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IGQzLnN2Zy5kaWFnb25hbC5yYWRpYWwoKTtcbiAgICAgICAgICAgICAgICAvLy5wcm9qZWN0aW9uKGZ1bmN0aW9uIChkKSB7IHJldHVybiBbZC55LCBkLnhdOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IGQzLnN2Z1ticmFuY2hTdHlsZV0oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBoeWxvRWRnZXMuZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIGQucGF0aCA9IHBhdGhHZW5lcmF0b3IoZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gY29weSBsYXlvdXQgcHJvcGVydGllcyB0byB0aGUgcGh5bG90cmVlLCBmb3IgcG9zc2libGUgdXNlIGRvd25zdHJlYW1cbiAgICAgIGRhdGEubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgZGF0YS50aXBzQWxpZ25tZW50ID0gdGlwc0FsaWdubWVudDtcbiAgICAgIGRhdGEuZGVzY2VudEF4aXMgPSBkZXNjZW50QXhpczsgIC8vIGltcGxpY2l0IGluIHRpcHNBbGlnbm1lbnQ/XG4gICAgICBkYXRhLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247ICAvLyBpbXBsaWNpdCBpbiB0aXBzQWxpZ25tZW50P1xuICAgICAgZGF0YS53aWR0aCA9IHdpZHRoO1xuICAgICAgZGF0YS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBkYXRhLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIGRhdGEuYnJhbmNoU3R5bGUgPSBicmFuY2hTdHlsZTtcbiAgICAgIGRhdGEuYnJhbmNoTGVuZ3RocyA9IGJyYW5jaExlbmd0aHM7XG4gICAgICBkYXRhLm5vZGVMYWJlbFNvdXJjZSA9IG5vZGVMYWJlbFNvdXJjZTtcbiAgICAgIGRhdGEuc2hvd0ZhbGxiYWNrTGFiZWxzID0gc2hvd0ZhbGxiYWNrTGFiZWxzO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgICBcbiAgICB2YXIgZGlzcGxhY2VQb2ludCA9IGZ1bmN0aW9uKHBvaW50LCBkZWx0YSkge1xuICAgICAgICAvLyB3aGVyZSAnZGVsdGEnIGlzIGFuIG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xuICAgICAgICBwb2ludC54ICs9IGRlbHRhLng7XG4gICAgICAgIHBvaW50LnkgKz0gZGVsdGEueTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cblxuICAgIC8vIFJldHVybiB3aWR0aCAqb3IqIGhlaWdodCwgYXMgYXBwcm9wcmlhdGUgZm9yIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uXG4gICAgdmFyIGdldE91dGVyRGltZW5zaW9uRm9yWCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2gob3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgY2FzZSAtMTgwOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcblxuICAgICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGNhc2UgLTkwOlxuICAgICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBjYXNlIC0yNzA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0T3V0ZXJEaW1lbnNpb25Gb3JYKCk6IFVuZXhwZWN0ZWQgdmFsdWUgZm9yIG9yaWVudGF0aW9uOiAnXCIrIG9yaWVudGF0aW9uICtcIidcIik7XG4gICAgfVxuICAgIHZhciBnZXRPdXRlckRpbWVuc2lvbkZvclkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIGNhc2UgLTE4MDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGNhc2UgLTkwOlxuICAgICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBjYXNlIC0yNzA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJnZXRPdXRlckRpbWVuc2lvbkZvclkoKTogVW5leHBlY3RlZCB2YWx1ZSBmb3Igb3JpZW50YXRpb246ICdcIisgb3JpZW50YXRpb24gK1wiJ1wiKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIC8vIHdoZXJlIHBvaW50IGlzIGFueSBvYmplY3QgaGF2aW5nIHggYW5kIHkgcHJvcGVydGllc1xuICAgICAgICAvLyBOT1RFIHRoYXQgd2UncmUgc2NhbGluZyB1cCBmcm9tIGZyYWN0aW9uYWwgdmFsdWVzICgwLjAgLSAxLjApLCBzb1xuICAgICAgICAvLyB0aGUgbm9taW5hbCB3aWR0aCtoZWlnaHQgYXJlIGFsc28gb3VyIHNjYWxpbmcgbXVsdGlwbGllcnNcbiAgICAgICAgcG9pbnQueCAqPSBnZXRPdXRlckRpbWVuc2lvbkZvclgoKTtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICAgIHBvaW50LnkgKj0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnQueSAqPSBnZXRPdXRlckRpbWVuc2lvbkZvclkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FsZSBjYXJ0ZXNpYW5feCBhbmQgeSwgaWYgc3RvcmVkXG4gICAgICAgIGlmICgnY2FydGVzaWFuX3gnIGluIHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feCAqPSBnZXRPdXRlckRpbWVuc2lvbkZvclgoKTtcbiAgICAgICAgICAgIHBvaW50LmNhcnRlc2lhbl95ICo9IGdldE91dGVyRGltZW5zaW9uRm9yWSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRlUG9pbnRCeU9yaWVudGF0aW9uID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSB2ZWdhIGlucHV0ICdvcmllbnRhdGlvbicgdmFsdWUgdG8gc3BpbiB0aGUgdHJlZVxuICAgICAgICByZXR1cm4gcm90YXRlUG9pbnQocG9pbnQsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgdmFyIHJvdGF0ZVBvaW50QnlZID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgLy8gWSBjb29yZGluYXRlIHNob3VsZCBiZSBiZXR3ZWVuIDAuMCBhbmQgMS4wXG4gICAgICAgIHZhciB5QW5nbGUgPSAzNjAuMCAqIHBvaW50Lng7XG4gICAgICAgIHJldHVybiByb3RhdGVQb2ludChwb2ludCwgeUFuZ2xlKTtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRlUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgYW5nbGUsIHBpdm90KSB7XG4gICAgICAgIC8vIHdoZXJlIHBvaW50IGlzIGFueSBvYmplY3QgaGF2aW5nIHggYW5kIHkgcHJvcGVydGllcywgYW5kICdwaXZvdCdcbiAgICAgICAgLy8gaXMgYW4gb3B0aW9uYWwgc2Vjb25kIHBvaW50XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luLFxuICAgICAgICAgICAgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKGFuZ2xlIHx8IG9yaWVudGF0aW9uKSwgLy8gY29udmVydCB0byByYWRpYW5zXG4gICAgICAgICAgICAvLyBkZWZhdWx0IG1pZHBvaW50IGlzIG9yaWdpbiAoMCwwKVxuICAgICAgICAgICAgeG0gPSAocGl2b3QgJiYgJ3gnIGluIHBpdm90KSA/IHBpdm90LnggOiAwLFxuICAgICAgICAgICAgeW0gPSAocGl2b3QgJiYgJ3knIGluIHBpdm90KSA/IHBpdm90LnkgOiAwLFxuICAgICAgICAgICAgeCA9IHBvaW50LngsICAgIC8vIGNhcHR1cmUgb2xkIHggYW5kIHkgZm9yIHRoaXMgcG9pbnRcbiAgICAgICAgICAgIHkgPSBwb2ludC55O1xuXG4gICAgICAgIC8vIHN1YnRyYWN0IG1pZHBvaW50cywgcm90YXRlIGZyb20gb3JpZ2luLCB0aGVuIHJlc3RvcmUgdGhlbVxuICAgICAgICBwb2ludC54ID0gKHggLSB4bSkgKiBjb3MoYW5nbGUpIC0gKHkgLSB5bSkgKiBzaW4oYW5nbGUpICsgeG07XG4gICAgICAgIHBvaW50LnkgPSAoeCAtIHhtKSAqIHNpbihhbmdsZSkgKyAoeSAtIHltKSAqIGNvcyhhbmdsZSkgKyB5bTtcbiAgICAgICAgaWYgKCdjYXJ0ZXNpYW5feCcgaW4gcG9pbnQpIHtcbiAgICAgICAgICAgIGN4ID0gcG9pbnQuY2FydGVzaWFuX3gsICAgIC8vIGNhcHR1cmUgb2xkIGNvb3Jkc1xuICAgICAgICAgICAgY3kgPSBwb2ludC5jYXJ0ZXNpYW5feTtcbiAgICAgICAgICAgIHBvaW50LmNhcnRlc2lhbl94ID0gKGN4IC0geG0pICogY29zKGFuZ2xlKSAtIChjeSAtIHltKSAqIHNpbihhbmdsZSkgKyB4bTtcbiAgICAgICAgICAgIHBvaW50LmNhcnRlc2lhbl95ID0gKGN4IC0geG0pICogc2luKGFuZ2xlKSArIChjeSAtIHltKSAqIGNvcyhhbmdsZSkgKyB5bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyhyKSB7XG4gICAgICAgIHJldHVybiAociAqIDE4MCAvIE1hdGguUEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICogTWF0aC5QSSAvIDE4MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURlZ3JlZXMoZCkge1xuICAgICAgICAvLyBjb252ZXJ0IHRvIHBvc2l0aXZlIGludGVnZXIsIGUuZy4gLTkwID09PiAyNzBcbiAgICAgICAgcmV0dXJuIChkICsgKDM2MCAqIDMpKSAlIDM2MDtcbiAgICB9XG5cbiAgLy8gQ29udmVydCBYWSBhbmQgcmFkaXVzIHRvIGFuZ2xlIG9mIGEgY2lyY2xlIGNlbnRlcmVkIGF0IDAsMFxuICB2YXIgY29vcmRpbmF0ZVRvQW5nbGUgPSBmdW5jdGlvbihjb29yZCwgcmFkaXVzKSB7XG4gICAgdmFyIHdob2xlQW5nbGUgPSAyICogTWF0aC5QSSxcbiAgICAgICAgcXVhcnRlckFuZ2xlID0gd2hvbGVBbmdsZSAvIDQ7XG4gICAgXG4gICAgdmFyIGNvb3JkUXVhZCA9IGNvb3JkWzBdID49IDAgP1xuICAgICAgICAgICAgKGNvb3JkWzFdID49IDAgPyAxIDogMikgOlxuICAgICAgICAgICAgKGNvb3JkWzFdID49IDAgPyA0IDogMyksXG4gICAgICAgIGNvb3JkQmFzZUFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hc2luKGNvb3JkWzFdIC8gcmFkaXVzKSk7XG4gICAgXG4gICAgLy8gU2luY2UgdGhpcyBpcyBqdXN0IGJhc2VkIG9uIHRoZSBhbmdsZSBvZiB0aGUgcmlnaHQgdHJpYW5nbGUgZm9ybWVkXG4gICAgLy8gYnkgdGhlIGNvb3JkaW5hdGUgYW5kIHRoZSBvcmlnaW4sIGVhY2ggcXVhZCB3aWxsIGhhdmUgZGlmZmVyZW50XG4gICAgLy8gb2Zmc2V0c1xuICAgIHN3aXRjaCAoY29vcmRRdWFkKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvb3JkQW5nbGUgPSBxdWFydGVyQW5nbGUgLSBjb29yZEJhc2VBbmdsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNvb3JkQW5nbGUgPSBxdWFydGVyQW5nbGUgKyBjb29yZEJhc2VBbmdsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGNvb3JkQW5nbGUgPSAyKnF1YXJ0ZXJBbmdsZSArIHF1YXJ0ZXJBbmdsZSAtIGNvb3JkQmFzZUFuZ2xlO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0OlxuICAgICAgICBjb29yZEFuZ2xlID0gMypxdWFydGVyQW5nbGUgKyBjb29yZEJhc2VBbmdsZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkQW5nbGU7XG4gIH1cblxuICAvKiBwYXRoIGdlbmVyYXRvcnMgKi9cblxuICB2YXIgc3RyYWlnaHRMaW5lRGlhZ29uYWwgPSBmdW5jdGlvbihkKSB7XG4gICAgLy8gZG8tbm90aGluZyBwcm9qZWN0aW9uIChqdXN0IGlzb2xhdGVzIHggYW5kIHkpXG4gICAgdmFyIHByb2plY3Rpb24gPSBmdW5jdGlvbihkKSB7IHJldHVybiBbZC54LCBkLnldOyB9XG4gICAgXG4gICAgdmFyIHBhdGggPSBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgcmV0dXJuIFwiTVwiICsgcGF0aERhdGFbMF0gKyAnICcgKyBwYXRoRGF0YVsxXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCkge1xuICAgICAgdmFyIHBhdGhEYXRhID0gW2Quc291cmNlLCBkLnRhcmdldF07XG4gICAgICBwYXRoRGF0YSA9IHBhdGhEYXRhLm1hcChwcm9qZWN0aW9uKTtcbiAgICAgIHJldHVybiBwYXRoKHBhdGhEYXRhKTtcbiAgICB9XG4gICAgXG4gICAgZGlhZ29uYWwucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0aW9uID0geDtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIFxuICAgIGRpYWdvbmFsLnBhdGggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYXRoO1xuICAgICAgcGF0aCA9IHg7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH1cblxuICB2YXIgcmlnaHRBbmdsZURpYWdvbmFsID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIGRvLW5vdGhpbmcgcHJvamVjdGlvbiAoanVzdCBpc29sYXRlcyB4IGFuZCB5KVxuICAgIHZhciBwcm9qZWN0aW9uID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gW2QueCwgZC55XTsgfVxuICAgIFxuICAgIHZhciBwYXRoID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgIHJldHVybiBcIk1cIiArIHBhdGhEYXRhWzBdICsgJyAnICsgcGF0aERhdGFbMV0gKyBcIiBcIiArIHBhdGhEYXRhWzJdO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBkaWFnb25hbChkKSB7XG4gICAgICB2YXIgbWlkcG9pbnRYID0gKGQuc291cmNlLnggKyBkLnRhcmdldC54KSAvIDIsXG4gICAgICAgICAgbWlkcG9pbnRZID0gKGQuc291cmNlLnkgKyBkLnRhcmdldC55KSAvIDIsXG4gICAgICAgICAgcGF0aERhdGEgPSAoZGVzY2VudEF4aXMgPT09ICd4JykgP1xuICAgICAgICAgICAgICAgICAgICBbZC5zb3VyY2UsIHt4OiBkLnNvdXJjZS54LCB5OiBkLnRhcmdldC55fSwgZC50YXJnZXRdIDpcbiAgICAgICAgICAgICAgICAgICAgW2Quc291cmNlLCB7eDogZC50YXJnZXQueCwgeTogZC5zb3VyY2UueX0sIGQudGFyZ2V0XTtcbiAgICAgIHBhdGhEYXRhID0gcGF0aERhdGEubWFwKHByb2plY3Rpb24pO1xuICAgICAgcmV0dXJuIHBhdGgocGF0aERhdGEpXG4gICAgfVxuICAgIFxuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdGlvbiA9IHg7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBcbiAgICBkaWFnb25hbC5wYXRoID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGF0aDtcbiAgICAgIHBhdGggPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9XG4gIFxuICB2YXIgY2FydGVzaWFuVG9Qb2xhclByb2plY3Rpb24gPSBmdW5jdGlvbihkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge3JldHVyblR5cGU6ICdYWS1BUlJBWSd9OyAvLyBvciAnUE9MQVItQ09PUkRTJ1xuICAgIC8vIHJhZGl1cyBpcyBzaW1wbHkgdGhlIHggY29vcmRpbmF0ZVxuICAgIHZhciByID0gZC54O1xuXG4gICAgLy8vdmFyIGEgPSAoZC55IC0gMCkgLyAxODAgKiBNYXRoLlBJO1xuICAgIC8vIGEgPSBhbmdsZT8gb3Igc29tZXRoaW5nIGVsc2U/XG5cbiAgICAvLyBBbmdsZSBpcyBpbmZsdWVuY2VkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSwgYXJjIGFuZCBzd2VlcC5cbiAgICAvLyBtYXAgWSBjb29yZGluYXRlIHRvIHRvdGFsIHNwZWNpZmllZCB3aWR0aFxuICAgIHZhciB0b3RhbEFyY0RlZ3JlZXM7XG4gICAgLy8gZm9yY2UgYm90aCBhbmdsZXMgdG8gcG9zaXRpdmUgbnVtYmVyc1xuICAgIHZhciBzdGFydEFuZ2xlID0gKHJhZGlhbEFyY1swXSArIDM2MCkgJSAzNjA7XG4gICAgdmFyIGVuZEFuZ2xlID0gKHJhZGlhbEFyY1sxXSArIDM2MCkgJSAzNjA7XG4gICAgLy8gY2hlY2sgZm9yIGFyY3MgdGhhdCBjcm9zcyB0aGUgemVybyBsaW5lXG4gICAgdmFyIHNoaWZ0QW5nbGU7XG4gICAgaWYgKHJhZGlhbFN3ZWVwID09PSAnQ09VTlRFUkNMT0NLV0lTRScpIHtcbiAgICAgICAgaWYgKGVuZEFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgdG90YWxBcmNEZWdyZWVzID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG90YWxBcmNEZWdyZWVzID0gKGVuZEFuZ2xlKzM2MCkgLSBzdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIHNoaWZ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIH0gZWxzZSB7IC8vIGFzc3VtZXMgJ0NMT0NLV0lTRScpXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIHRvdGFsQXJjRGVncmVlcyA9IHN0YXJ0QW5nbGUgLSBlbmRBbmdsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvdGFsQXJjRGVncmVlcyA9IChzdGFydEFuZ2xlKzM2MCkgLSBlbmRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBzaGlmdEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgfVxuICAgIHZhciBwcm9wb3J0aW9uYWxZID0gKChkLnkgLyBnZXRPdXRlckRpbWVuc2lvbkZvclgoKSkgKiB0b3RhbEFyY0RlZ3JlZXMpO1xuICAgIC8vIHNoaWZ0IGFuZ2xlIDkwIGRlZ3JlZXMgKGZyb20gMD1kb3duIHRvIDA9cmlnaHQpXG4gICAgLy8vcHJvcG9ydGlvbmFsWSAtPSA5MDtcblxuICAgIC8vIE9SIHJvdGF0ZSBhbmdsZSB0byB0aGUgc3RhcnQgb3IgZW5kIGFuZ2xlP1xuICAgIC8vL3Byb3BvcnRpb25hbFkgPSAocHJvcG9ydGlvbmFsWSArIHNoaWZ0QW5nbGUgKyAzNjApICUgMzYwO1xuXG4gICAgdmFyIGEgPSBwcm9wb3J0aW9uYWxZIC8gMTgwICogTWF0aC5QSTtcbiAgICAvLyByZW1hcCBhbmdsZSB0byB0aGUgc3BlY2lmaWVkIGFyYywgaW4gdGhlIHN3ZWVwIGRpcmVjdGlvblxuXG4gICAgLy8gVE9ETzogcmVja29uIGFuZ2xlIGJhc2VkIG9uIGhlaWdodC93aWR0aCBhbmQgc3dlZXBcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5UeXBlID09PSAnUE9MQVJfQ09PUkRTJykge1xuICAgICAgICAvLyBhZGQgcmFkaXVzIGFuZCBhbmdsZSAodGhldGEpIGZvciBsYWJlbCBkaXNwbGF5IGluIHZlZ2FcbiAgICAgICAgdmFyIGxhYmVsQW5nbGUgPSBub3JtYWxpemVEZWdyZWVzKHJhZGlhbnNUb0RlZ3JlZXMoYSkpO1xuICAgICAgICB2YXIgbGFiZWxBbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgIC8vIFRPRE86IGFkanVzdGFibGUgbnVkZ2Ugc2VwYXJhdGVzIGxhYmVsIHRleHQgZnJvbSBkcmF3biBub2RlXG4gICAgICAgIHZhciBudWRnZVJhZGl1cyA9IDQ7IC8vIHB4P1xuICAgICAgICAvLyBUT0RPOiBhZGp1c3RhYmxlIG51ZGdlIChzaG91bGQgdmFyeSB3aXRoIHRleHQgc2l6ZSkgc2hpZnRzIGFuZ2xlXG4gICAgICAgIC8vIGZyb20gdGhlIGxhYmVsJ3MgYmFzZWxpbmUgdG8gdGhlIG1pZGRsZSBvZiBpdHMgeC1oZWlnaHRcbiAgICAgICAgdmFyIG51ZGdlVGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKDAuNik7XG5cbiAgICAgICAgLy8gdGVzdCBmb3IgdXBzaWRlLWRvd24gbGFiZWxzIChhc3N1bWluZyAwIGRlZyA9IGR1ZSByaWdodClcbiAgICAgICAgaWYgKChsYWJlbEFuZ2xlID4gOTApICYmIChsYWJlbEFuZ2xlIDwgMjcwKSkge1xuICAgICAgICAgICAgLy8gbGVmdC1zaWRlIGxhYmVscyBzaG91bGQgYmUgZmxpcHBlZCBhbmQgYWxpZ25lZCByaWdodFxuICAgICAgICAgICAgbGFiZWxBbGlnbm1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgbGFiZWxBbmdsZSA9IG5vcm1hbGl6ZURlZ3JlZXMobGFiZWxBbmdsZSArIDE4MCk7XG4gICAgICAgICAgICBudWRnZVRoZXRhID0gIC0obnVkZ2VUaGV0YSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZUFuZExhYmVsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIC8vIFgsIFkgY29vcmRpbmF0ZXMgZm9yIHRoZSBub2RlIGl0c2VsZlxuICAgICAgICAgICAgJ3gnOiByICogTWF0aC5jb3MoYSksXG4gICAgICAgICAgICAneSc6IHIgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgcGxhY2luZyB0aGUgbGFiZWxcbiAgICAgICAgICAgICdyYWRpdXMnOiByICsgbnVkZ2VSYWRpdXMsXG4gICAgICAgICAgICAndGhldGEnOiBhIC0gZGVncmVlc1RvUmFkaWFucyhvcmllbnRhdGlvbikgKyBudWRnZVRoZXRhLCAvLyBpbiByYWRpYW5zIVxuICAgICAgICAgICAgJ2FuZ2xlJzogbGFiZWxBbmdsZSxcbiAgICAgICAgICAgICdhbGlnbic6IGxhYmVsQWxpZ25tZW50XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBub2RlQW5kTGFiZWxQcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldHVybiBYWS1DT09SRFMgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gW3IgKiBNYXRoLmNvcyhhKSwgciAqIE1hdGguc2luKGEpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIFdlIG5lZWQgYSBzdGFuZGFsb25lIHZlcnNpb24gb2YgdGhpcywgc2luY2Ugd2UncmUgbWFwcGluZyAocHJlc2VydmVkKVxuICAgIC8vIGNhcnRlc2lhbl94IGFuZCBjYXJ0ZXNpYW5feSB0byBwb2xhciBjb29yZGluYXRlcy5cblxuICAgIC8vIHRyYW5zbGF0ZSBmcm9tIGNhcnRlc2lhbiB0byBwb2xhciBjb29yZGluYXRlc1xuICAgIHZhciBwcm9qZWN0aW9uID0gY2FydGVzaWFuVG9Qb2xhclByb2plY3Rpb247XG4gICAgICAgICAgICBcbiAgICB2YXIgcGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICAgIHZhciBzcmMgPSBwYXRoRGF0YVswXSxcbiAgICAgICAgICAgIG1pZCA9IHBhdGhEYXRhWzFdLFxuICAgICAgICAgICAgZHN0ID0gcGF0aERhdGFbMl0sXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLnNxcnQoc3JjWzBdKnNyY1swXSArIHNyY1sxXSpzcmNbMV0pLFxuICAgICAgICAgICAgc3JjQW5nbGUgPSBjb29yZGluYXRlVG9BbmdsZShzcmMsIHJhZGl1cyksXG4gICAgICAgICAgICBtaWRBbmdsZSA9IGNvb3JkaW5hdGVUb0FuZ2xlKG1pZCwgcmFkaXVzKSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZSA9IE1hdGguYWJzKG1pZEFuZ2xlIC0gc3JjQW5nbGUpID4gTWF0aC5QSSA/IG1pZEFuZ2xlIDw9IHNyY0FuZ2xlIDogbWlkQW5nbGUgPiBzcmNBbmdsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gMCxcbiAgICAgICAgICAgIGxhcmdlQXJjID0gMCxcbiAgICAgICAgICAgIHN3ZWVwID0gY2xvY2t3aXNlID8gMCA6IDE7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gJ00nICsgc3JjICsgJyAnICtcbiAgICAgICAgICBcIkFcIiArIFtyYWRpdXMscmFkaXVzXSArICcgJyArIHJvdGF0aW9uICsgJyAnICsgbGFyZ2VBcmMrJywnK3N3ZWVwICsgJyAnICsgbWlkICtcbiAgICAgICAgICAnTCcgKyBkc3Q7XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nO1xuICAgIH1cbiAgICAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGRpYWdvbmFsKGQpIHtcbiAgICAgIHZhciBtaWRwb2ludFggPSAoZC5zb3VyY2UuY2FydGVzaWFuX3ggKyBkLnRhcmdldC5jYXJ0ZXNpYW5feCkgLyAyLFxuICAgICAgICAgIG1pZHBvaW50WSA9IChkLnNvdXJjZS5jYXJ0ZXNpYW5feSArIGQudGFyZ2V0LmNhcnRlc2lhbl95KSAvIDIsXG4gICAgICAgICAgcGF0aERhdGEgPSAoZGVzY2VudEF4aXMgPT09ICd4JykgP1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogZC5zb3VyY2UuY2FydGVzaWFuX3gsIHk6IGQuc291cmNlLmNhcnRlc2lhbl95fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feCwgeTogZC50YXJnZXQuY2FydGVzaWFuX3l9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6IGQudGFyZ2V0LmNhcnRlc2lhbl94LCB5OiBkLnRhcmdldC5jYXJ0ZXNpYW5feX1cbiAgICAgICAgICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feCwgeTogZC5zb3VyY2UuY2FydGVzaWFuX3l9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6IGQudGFyZ2V0LmNhcnRlc2lhbl94LCB5OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogZC50YXJnZXQuY2FydGVzaWFuX3gsIHk6IGQudGFyZ2V0LmNhcnRlc2lhbl95fVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgcGF0aERhdGEgPSBwYXRoRGF0YS5tYXAocHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gcGF0aChwYXRoRGF0YSlcbiAgICB9XG4gICAgICAgICAgICBcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH1cbiAgXG4gICAgLyogbGF5b3V0IGdlbmVyYXRvcnMgKHBvc2l0aW9uIHBvaW50cyBpbiAxLjAsIDEuMCBzcGFjZSkgKi9cbiAgICB2YXIgY2FydGVzaWFuTGF5b3V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvLyBwbGFjZSBhbGwgbm9kZXMgZm9yIHRoZSByYWRpYWwgbGF5b3V0IChhbHJlYWR5IGRvbmUpXG5cbiAgICAgICAgLy8ganVzdCBudWRnZSBhbGwgcG9pbnRzIHRvIHB1dCB0aGUgcm9vdCBub2RlIGF0IDAsMFxuICAgICAgICBtb3ZlUm9vdFRvT3JpZ2luKGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBtb3ZlUm9vdFRvT3JpZ2luID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gbW92ZSBhbGwgcG9pbnRzIHRvIHB1dCB0aGUgcm9vdCBub2RlIGF0IG9yaWdpbiAoMC4wKVxuICAgICAgICB2YXIgcm9vdE5vZGUgPSBkYXRhLnBoeWxvTm9kZXNbMF07ICAvLyBJIGJlbGlldmUgdGhpcyBpcyBhbHdheXMgdHJ1ZVxuICAgICAgICB2YXIgbnVkZ2VSb290VG9PcmlnaW4gPSB7eDogLShyb290Tm9kZS54KSwgeTogLShyb290Tm9kZS55KX07XG4gICAgICAgIHZhciBhbGlnblBvaW50c1RvT3JpZ2luID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGFjZVBvaW50KHBvaW50LCBudWRnZVJvb3RUb09yaWdpbik7XG4gICAgICAgIH07XG4gICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAoYWxpZ25Qb2ludHNUb09yaWdpbik7XG4gICAgfVxuXG4gICAgdmFyIHJhZGlhbExheW91dCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gcGxhY2UgYWxsIG5vZGVzIGZvciB0aGUgcmFkaWFsIGxheW91dFxuICAgICAgICAvLyBwcm9qZWN0IHBvaW50cyAobm9kZXMpIHRvIHJhZGlhdGUgb3V0IGZyb20gY2VudGVyXG4gICAgICAgIG1vdmVSb290VG9PcmlnaW4oZGF0YSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcHJlc2VydmVDYXJ0ZXNpYW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feCA9IHBvaW50Lng7XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5waHlsb05vZGVzLm1hcChwcmVzZXJ2ZUNhcnRlc2lhbkNvb3JkaW5hdGVzKTtcblxuICAgICAgICAvLy9kYXRhLnBoeWxvTm9kZXMubWFwKHJvdGF0ZVBvaW50QnlZKTtcbiAgICAgICAgZGF0YS5waHlsb05vZGVzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBwY29vcmRzID0gY2FydGVzaWFuVG9Qb2xhclByb2plY3Rpb24oZCwge3JldHVyblR5cGU6J1BPTEFSX0NPT1JEUyd9KTtcbiAgICAgICAgICAgIGQucmFkaXVzICA9IHBjb29yZHMucmFkaXVzO1xuICAgICAgICAgICAgZC50aGV0YSAgPSBwY29vcmRzLnRoZXRhO1xuICAgICAgICAgICAgZC5hbmdsZSAgPSBwY29vcmRzLmFuZ2xlO1xuICAgICAgICAgICAgZC5hbGlnbiAgPSBwY29vcmRzLmFsaWduO1xuICAgICAgICAgICAgZC54ID0gcGNvb3Jkcy54O1xuICAgICAgICAgICAgZC55ID0gcGNvb3Jkcy55O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNsYWRvZ3JhbUxheW91dCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gcGxhY2UgYWxsIG5vZGVzIGZvciB0aGUgXCJ0cmlhbmd1bGFyXCIgY2xhZG9ncmFtIGxheW91dFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGJyYW5jaCBsZW5ndGhzP1xuXG4gICAgICAgIC8vIHByb2plY3QgcG9pbnRzIChub2RlcykgdG8gcmFkaWF0ZSBvdXQgZnJvbSBjZW50ZXJcbiAgICAgICAgbW92ZVJvb3RUb09yaWdpbihkYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8qIFByZWNhbGN1bGF0ZSBhdmFpbGFibGUgbGVhZi1ub2RlIHBvc2l0aW9ucyAoYmFzZWQgb24gbnVtYmVyIG9mXG4gICAgICAgICAqIGxlYXZlcywgZmluYWwgd2lkdGggJiBoZWlnaHQsIGFuZCB0aXAgYWxpZ25tZW50KS4gVGhlbiBkb1xuICAgICAgICAgKiBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgZnJvbSB0aGUgcm9vdCB0byBhc3NpZ24gdGhlIGxlYXZlcyB0byB0aGVzZVxuICAgICAgICAgKiBwb3NpdGlvbnMsIHBsYWNpbmcgYWxsIGFuY2VzdG9ycyBhbG9uZyB0aGUgd2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGxlYWZOb2RlcyA9ICQuZ3JlcChkYXRhLnBoeWxvTm9kZXMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuWydeb3Q6aXNMZWFmJ10gPT09IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBuTGVhdmVzID0gbGVhZk5vZGVzLmxlbmd0aDtcblxuICAgICAgICAvKiBIb3cgZmFyIHNob3VsZCB3ZSBtb3ZlIG9uIHRoZSBkZXNjZW50IGF4aXMgZm9yIGVhY2ggc3RlcCBpbiBkZXB0aD9cbiAgICAgICAgICogTk9URSB0aGF0IHdlJ2xsIG5vcm1hbGl6ZSB0aGlzIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICogbGF0ZXI7IGZvciBub3csIGxldCdzIG1hdGNoIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGxlYWYgbm9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGVwdGhTdGVwO1xuXG4gICAgICAgIHZhciBsZWFmUG9zaXRpb25zID0gWyBdO1xuICAgICAgICB2YXIgc3RhcnRpbmdMZWFmWCwgbGVhZlhzdGVwLFxuICAgICAgICAgICAgc3RhcnRpbmdMZWFmWSwgbGVhZllzdGVwO1xuICAgICAgICBzd2l0Y2godGlwc0FsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSAnVE9QJzpcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xlYWZYID0gLSh3aWR0aCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgbGVhZlhzdGVwID0gd2lkdGggLyAobkxlYXZlcy0xKTtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xlYWZZID0gLWhlaWdodDtcbiAgICAgICAgICAgICAgICBsZWFmWXN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIGRlcHRoU3RlcCA9IC1sZWFmWHN0ZXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSSUdIVCc6XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGxlYWZYc3RlcCA9IDA7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWSA9IC0oaGVpZ2h0IC8gMi4wKTtcbiAgICAgICAgICAgICAgICBsZWFmWXN0ZXAgPSBoZWlnaHQgLyAobkxlYXZlcy0xKTtcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZXAgPSBsZWFmWXN0ZXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdCT1RUT00nOlxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlggPSAtKHdpZHRoIC8gMi4wKTtcbiAgICAgICAgICAgICAgICBsZWFmWHN0ZXAgPSB3aWR0aCAvIChuTGVhdmVzLTEpO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlkgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGVhZllzdGVwID0gMDtcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZXAgPSBsZWFmWHN0ZXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMRUZUJzpcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xlYWZYID0gLXdpZHRoO1xuICAgICAgICAgICAgICAgIGxlYWZYc3RlcCA9IDA7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWSA9IC0oaGVpZ2h0IC8gMi4wKTtcbiAgICAgICAgICAgICAgICBsZWFmWXN0ZXAgPSBoZWlnaHQgLyAobkxlYXZlcy0xKTtcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZXAgPSAtbGVhZllzdGVwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVhZk5vZGVzLm1hcChmdW5jdGlvbihuLCBpKSB7XG4gICAgICAgICAgICBsZWFmUG9zaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICd4Jzogc3RhcnRpbmdMZWFmWCArIChsZWFmWHN0ZXAgKiBpKSxcbiAgICAgICAgICAgICAgICAneSc6IHN0YXJ0aW5nTGVhZlkgKyAobGVhZllzdGVwICogaSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcm9vdE5vZGUgPSBkYXRhLnBoeWxvTm9kZXNbMF07ICAvLyBJIGJlbGlldmUgdGhpcyBpcyBhbHdheXMgdHJ1ZVxuICAgICAgICB2YXIgZnVsbEV4dGVudHMgPSBkaXN0cmlidXRlQ2hpbGRyZW5Bc0NsYWRvZ3JhbShyb290Tm9kZSwgbGVhZlBvc2l0aW9ucywgZGVwdGhTdGVwKTtcblxuICAgICAgICAvLyByZWFsaWduIHJvb3Qgbm9kZSB0byBvcmlnaW4gKGl0IGdldHMgXCJwdXNoZWRcIiBmYXIgYXdheSBieSBjb21wbGV4IHRyZWVzKVxuICAgICAgICBtb3ZlUm9vdFRvT3JpZ2luKGRhdGEpO1xuXG4gICAgICAgIC8vIFNjYWxlIHRoZSByZXN1bHRpbmcgbGF5b3V0IHRvIG1hdGNoIHRoZSBkZXNpcmVkIHdpZHRoIChvciBoZWlnaHQpXG4gICAgICAgIHN3aXRjaCh0aXBzQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjYXNlICdUT1AnOlxuICAgICAgICAgICAgY2FzZSAnQk9UVE9NJzpcbiAgICAgICAgICAgICAgICAvLyB3aWR0aCBpcyBhbHJlYWR5IGdvb2Q7IGhlaWdodCBzaG91bGQgYmUgc3F1ZWV6ZWQgKG9yIHN0cmV0Y2hlZClcbiAgICAgICAgICAgICAgICB2YXIgc3F1ZWV6ZSA9IGhlaWdodCAvIChmdWxsRXh0ZW50cy5tYXhZIC0gZnVsbEV4dGVudHMubWluWSk7XG4gICAgICAgICAgICAgICAgdmFyIGZpdFRvSGVpZ2h0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueSAqPSBzcXVlZXplO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAoZml0VG9IZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUklHSFQnOlxuICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0IGlzIGFscmVhZHkgZ29vZDsgd2lkdGggc2hvdWxkIGJlIHNxdWVlemVkIChvciBzdHJldGNoZWQpXG4gICAgICAgICAgICAgICAgdmFyIHNxdWVlemUgPSB3aWR0aCAvIChmdWxsRXh0ZW50cy5tYXhYIC0gZnVsbEV4dGVudHMubWluWCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpdFRvV2lkdGggPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC54ICo9IHNxdWVlemU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5waHlsb05vZGVzLm1hcChmaXRUb1dpZHRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgIFxuICAgIHZhciBkaXN0cmlidXRlQ2hpbGRyZW5Bc0NsYWRvZ3JhbSA9IGZ1bmN0aW9uKG5vZGUsIGxlYWZQb3NpdGlvbnMsIGRlcHRoU3RlcCkge1xuICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBleHRlbnRzID0ge1xuICAgICAgICAgICAgbWluWDogIE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtYXhYOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG1pblk6ICBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4WTogLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBkZXNjZW5kYW50TGVhZkNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgICAgICAgIGlmIChuWydeb3Q6aXNMZWFmJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSBuZXh0IGF2YWlsYWJsZSBsZWFmIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGxlYWZQb3MgPSBsZWFmUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbi54ID0gbGVhZlBvcy54O1xuICAgICAgICAgICAgICAgIG4ueSA9IGxlYWZQb3MueTtcblxuICAgICAgICAgICAgICAgIGV4dGVudHMubWluWCA9IE1hdGgubWluKG4ueCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblkgPSBNYXRoLm1pbihuLnksIGV4dGVudHMubWluWSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhYID0gTWF0aC5tYXgobi54LCBleHRlbnRzLm1heFgpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSA9IE1hdGgubWF4KG4ueSwgZXh0ZW50cy5tYXhZKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRXh0ZW50cyA9IGRpc3RyaWJ1dGVDaGlsZHJlbkFzQ2xhZG9ncmFtKG4sIGxlYWZQb3NpdGlvbnMsIGRlcHRoU3RlcCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5taW5YID0gTWF0aC5taW4obi54LCBjaGlsZEV4dGVudHMubWluWCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblkgPSBNYXRoLm1pbihuLnksIGNoaWxkRXh0ZW50cy5taW5ZLCBleHRlbnRzLm1pblkpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WCA9IE1hdGgubWF4KG4ueCwgY2hpbGRFeHRlbnRzLm1heFgsIGV4dGVudHMubWF4WCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhZID0gTWF0aC5tYXgobi55LCBjaGlsZEV4dGVudHMubWF4WSwgZXh0ZW50cy5tYXhZKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgKz0gY2hpbGRFeHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qIFBvc2l0aW9uIHRoaXMgbm9kZSBiYXNlZCBvbiBpdHMgZGVwdGggYW5kIGNoaWxkcmVuJ3MgcG9zaXRpb25zLlxuICAgICAgICAgKiBOb3RlIHRoYXQgd2UgbmVlZCB0byBwbGFjZSBpdCBvbiB0aGUgZGVzY2VudCBheGlzIHNvIHRoYXQgaXRcbiAgICAgICAgICogbWFpbnRhaW5zIChpZiBwb3NzaWJsZSkgdGhlIHByb3BlciBhbmdsZWQgZWRnZXMgZm9yIHRoZVxuICAgICAgICAgKiBjbGFkb2dyYW0gbGF5b3V0LiBUaGlzIHNvbWV0aW1lcyBtZWFucyB3ZSBuZWVkIHRvIGZvcmNlXG4gICAgICAgICAqIGxvbmdlciBlZGdlcyBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoKHRpcHNBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWSAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB4IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHhcbiAgICAgICAgICAgICAgICBub2RlLnggPSAoZXh0ZW50cy5tYXhYICsgZXh0ZW50cy5taW5YKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0JPVFRPTSc6XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWSAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB4IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHhcbiAgICAgICAgICAgICAgICBub2RlLnggPSAoZXh0ZW50cy5tYXhYICsgZXh0ZW50cy5taW5YKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JJR0hUJzpcbiAgICAgICAgICAgICAgICBub2RlLnggPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50cy5taW5YIC0gZGVwdGhTdGVwLCAgLy8gb25lIHN0ZXAgY2xvc2VyIHRvIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhYIC0gKChleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgLSAxKSAqIGRlcHRoU3RlcClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIHkgc2hvdWxkIGJlIG1pZHBvaW50IG9mIGFsbCBkZXNjZW5kYW50cycgeVxuICAgICAgICAgICAgICAgIG5vZGUueSA9IChleHRlbnRzLm1heFkgKyBleHRlbnRzLm1pblkpIC8gMi4wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WCAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWCAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB5IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHlcbiAgICAgICAgICAgICAgICBub2RlLnkgPSAoZXh0ZW50cy5tYXhZICsgZXh0ZW50cy5taW5ZKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBleHRlbnRzIGFuZCByZXR1cm4gdG8gcGFyZW50XG4gICAgICAgIGV4dGVudHMubWluWCA9IE1hdGgubWluKG5vZGUueCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgZXh0ZW50cy5taW5ZID0gTWF0aC5taW4obm9kZS55LCBleHRlbnRzLm1pblkpO1xuICAgICAgICBleHRlbnRzLm1heFggPSBNYXRoLm1heChub2RlLngsIGV4dGVudHMubWF4WCk7XG4gICAgICAgIGV4dGVudHMubWF4WSA9IE1hdGgubWF4KG5vZGUueSwgZXh0ZW50cy5tYXhZKTtcblxuICAgICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gcGh5bG9ncmFtKGRhdGEpO1xufVxuXG5cblxuLyoqKioqIFNDUkFQIEFSRUEgKioqKiovXG5cbi8qXG4gIHN0eWxlVHJlZU5vZGVzID0gZnVuY3Rpb24odmlzKSB7XG5cbiAgICB2aXMuc2VsZWN0QWxsKCdnLm5vZGUgY2lyY2xlJylcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSk7XG5cbiAgICB2aXMuc2VsZWN0QWxsKCdnLmxlYWYubm9kZSBjaXJjbGUnKVxuICAgICAgICAuYXR0cihcInJcIiwgNC41KTtcbiAgICBcbiAgICB2aXMuc2VsZWN0QWxsKCdnLnJvb3Qubm9kZSBjaXJjbGUnKVxuICAgICAgICAuYXR0cihcInJcIiwgNC41KTtcbiAgfVxuKi9cbiAgXG4gIGZ1bmN0aW9uIHNjYWxlQnJhbmNoTGVuZ3Rocyhub2Rlcywgdykge1xuICAgIC8vIFZpc2l0IGFsbCBub2RlcyBhbmQgYWRqdXN0IHkgcG9zIHdpZHRoIGRpc3RhbmNlIG1ldHJpY1xuICAgIHZhciB2aXNpdFByZU9yZGVyID0gZnVuY3Rpb24ocm9vdCwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHJvb3QpXG4gICAgICBpZiAocm9vdC5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gcm9vdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgdmlzaXRQcmVPcmRlcihyb290LmNoaWxkcmVuW2ldLCBjYWxsYmFjaylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRQcmVPcmRlcihub2Rlc1swXSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgLy8gVE9ETzogaWYgd2UgaGF2ZSBtaXhlZCB0cmVlcyAoc29tZSBlZGdlcyB3aXRoIGxlbmd0aHMpLCBjb25zaWRlciAxXG4gICAgICAvLyBhcyBkZWZhdWx0IGxlbmd0aCB2ZXJzdXMgMD9cbiAgICAgIG5vZGUucm9vdERpc3QgPSAobm9kZS5wYXJlbnQgPyBub2RlLnBhcmVudC5yb290RGlzdCA6IDApICsgKG5vZGUubGVuZ3RoIHx8IDApXG4gICAgfSlcbiAgICB2YXIgcm9vdERpc3RzID0gbm9kZXMubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ucm9vdERpc3Q7IH0pO1xuICAgIHZhciB5c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgZDMubWF4KHJvb3REaXN0cyldKVxuICAgICAgLnJhbmdlKFswLCB3XSk7XG4gICAgdmlzaXRQcmVPcmRlcihub2Rlc1swXSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS55ID0geXNjYWxlKG5vZGUucm9vdERpc3QpXG4gICAgfSlcbiAgICByZXR1cm4geXNjYWxlXG4gIH1cbiAgXG4gIFxuICB2YXIgYnVpbGRDYXJ0ZXNpYW4gPSBmdW5jdGlvbihzZWxlY3Rvciwgbm9kZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciB3ID0gb3B0aW9ucy53aWR0aCB8fCBkMy5zZWxlY3Qoc2VsZWN0b3IpLnN0eWxlKCd3aWR0aCcpIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXR0cignd2lkdGgnKSxcbiAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGQzLnNlbGVjdChzZWxlY3Rvcikuc3R5bGUoJ2hlaWdodCcpIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXR0cignaGVpZ2h0JyksXG4gICAgICAgIHcgPSBwYXJzZUludCh3KSxcbiAgICAgICAgaCA9IHBhcnNlSW50KGgpO1xuICAgIHZhciB0cmVlID0gb3B0aW9ucy50cmVlIHx8IGQzLmxheW91dC5jbHVzdGVyKClcbiAgICAgIC5zaXplKFtoLCB3XSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuLmxlbmd0aCA6IC0xOyB9KVxuICAgIHZhciBkaWFnb25hbCA9IG9wdGlvbnMuZGlhZ29uYWwgfHwgcmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgdmFyIHZpcyA9IG9wdGlvbnMudmlzIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXBwZW5kKFwic3ZnOnN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHcgKyAzMDApXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGggKyAzMClcbiAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgxMjAsIDIwKVwiKTtcblxuICAgIGlmICghb3B0aW9ucy52aXMpIHtcbiAgICAgIC8vIGFkZCBhbnkgc3BlY2lhbCBmaWx0ZXJzIChvbmNlIG9ubHkpXG4gICAgICBkMy5zZWxlY3Qoc2VsZWN0b3IpLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAuYXBwZW5kKCdkZWZzJylcbiAgICAgICAgIC5hcHBlbmQoXCJzdmc6ZmlsdGVyXCIpXG4gICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJoaWdobGlnaHRcIilcbiAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgLy8gYWRkIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoaXMgcGFyZW50XG4gICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXBwZW5kKFwic3ZnOmZlRmxvb2RcIilcbiAgICAgICAgICAgICAgICAgLy8uYXR0cihcImZsb29kLWNvbG9yXCIsIFwiI2ZmZWVkZFwiKSAgLy8gbWF0Y2hlcyAuaGVscC1ib3ggYmcgY29sb3IhXG4gICAgICAgICAgICAgICAgIC5hdHRyKFwiZmxvb2QtY29sb3JcIiwgXCIjZmZiMjY1XCIpICAgIC8vIGRhcmtlbmVkIHRvIGFsbG93IHRpbnRcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJmbG9vZC1vcGFjaXR5XCIsIFwiMC41XCIpXG4gICAgICAgICAgICAgICAgIC5hdHRyKFwicmVzdWx0XCIsIFwidGludFwiKTtcbiAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hcHBlbmQoXCJzdmc6ZmVCbGVuZFwiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcIm1vZGVcIiwgXCJtdWx0aXBseVwiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcImluMlwiLCBcInRpbnRcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJpbjNcIiwgXCJCYWNrZ3JvdW5kSW1hZ2VcIik7XG4gICAgICAgICAgICAgICAvKiBBTFRFUk5BVElWRSBTT0xVVElPTiwgdXNpbmcgZmVDb21wb3NpdGVcbiAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hcHBlbmQoXCJzdmc6ZmVDb21wb3NpdGVcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJpblwiLCBcIlNvdXJjZUdyYXBoaWNcIik7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gdHJlZShub2Rlcyk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuc2tpcEJyYW5jaExlbmd0aFNjYWxpbmcpIHtcbiAgICAgIHZhciB5c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCB3XSlcbiAgICAgICAgLnJhbmdlKFswLCB3XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5c2NhbGUgPSBzY2FsZUJyYW5jaExlbmd0aHMobm9kZXMsIHcpXG4gICAgfVxuICAgIFxuICAgIGlmICghb3B0aW9ucy5za2lwVGlja3MpIHtcbiAgICAgIHZhciBsaW5lcyA9IHZpcy5zZWxlY3RBbGwoJ2xpbmUnKVxuICAgICAgICAgIC5kYXRhKHlzY2FsZS50aWNrcygxMCkpO1xuICAgICAgXG4gICAgICBsaW5lc1xuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAgICAgICAuYXR0cigneTEnLCAwKVxuICAgICAgICAgIC5hdHRyKCd5MicsIGgpXG4gICAgICAgICAgLmF0dHIoJ3gxJywgeXNjYWxlKVxuICAgICAgICAgIC5hdHRyKCd4MicsIHlzY2FsZSlcbiAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiNlZWVcIik7XG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgIHZhciB0ZXh0X3J1bGVzID0gdmlzLnNlbGVjdEFsbChcInRleHQucnVsZVwiKVxuICAgICAgICAgIC5kYXRhKHlzY2FsZS50aWNrcygxMCkpO1xuXG4gICAgICB0ZXh0X3J1bGVzXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInN2Zzp0ZXh0XCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJ1bGVcIilcbiAgICAgICAgICAuYXR0cihcInhcIiwgeXNjYWxlKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgLTMpXG4gICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnOHB4JylcbiAgICAgICAgICAuYXR0cignZmlsbCcsICcjY2NjJylcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLnJvdW5kKGQqMTAwKSAvIDEwMDsgfSk7XG5cbiAgICAgIHRleHRfcnVsZXNcbiAgICAgICAgLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG4gICAgICAgIFxuICAgIFxuICAgIC8vIERBVEEgSk9JTlxuICAgIC8qIG1vcmUgaW50ZXJhY3Rpb25zIGFuZCBzdHlsZXMgb24gZmluYWwgbWFya3NcbiAgICB2YXIgcGF0aF9saW5rcyA9IHZpcy5zZWxlY3RBbGwoXCJwYXRoLmxpbmtcIilcbiAgICAgICAgLmRhdGEodHJlZS5saW5rcyhub2RlcyksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc291cmNlWydAaWQnXSArJ18nKyBkLnRhcmdldFsnQGlkJ107IH0pO1xuXG4gICAgdmFyIHBhdGhfbGlua190cmlnZ2VycyA9IHZpcy5zZWxlY3RBbGwoXCJwYXRoLmxpbmstdHJpZ2dlclwiKVxuICAgICAgICAuZGF0YSh0cmVlLmxpbmtzKG5vZGVzKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2VbJ0BpZCddICsnXycrIGQudGFyZ2V0WydAaWQnXSArJ190cmlnZ2VyJzsgfSk7XG5cbiAgICB2YXIgZ19ub2RlcyA9IHZpcy5zZWxlY3RBbGwoXCJnLm5vZGVcIilcbiAgICAgICAgLmRhdGEobm9kZXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbJ0BpZCddOyB9KTtcblxuICAgIC8vIFVQREFURSAob25seSBhZmZlY3RzIGV4aXN0aW5nIGxpbmtzKVxuICAgIHBhdGhfbGlua3NcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjYWFhXCIpO1xuICAgIFxuICAgIHBhdGhfbGlua190cmlnZ2Vyc1xuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIm9yYW5nZVwiKTtcblxuICAgIFxuICAgIC8vIEVOVEVSIChvbmx5IGFmZmVjdHMgbmV3IGxpbmtzOyBkbyBvbmUtdGltZSBpbml0aWFsaXphdGlvbiBoZXJlKVxuICAgIHBhdGhfbGlua3NcbiAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInN2ZzpwYXRoXCIpICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlZCAodmlzaWJsZSkgZWRnZVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmtcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiI2YzM1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgXCI0cHhcIik7XG4gICAgXG4gICAgcGF0aF9saW5rX3RyaWdnZXJzXG4gICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoXCJzdmc6cGF0aFwiKSAgICAgICAgICAgICAgICAgICAvLyBcImhpdCBhcmVhXCIgZm9yIGNsaWNraW5nIGVkZ2VcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5rLXRyaWdnZXJcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwicmVkXCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCBcIjRweFwiKVxuICAgICAgICAgICAgLy8uYXR0cigncG9pbnRlci1ldmVudHMnLCAnYWxsJylcblxuICAgIGdfbm9kZXNcbiAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAgIC5hcHBlbmQoXCJzdmc6Y2lyY2xlXCIpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMi41KVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdyZWQnKVxuICAgICAgICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpICAgICAgLy8gZGV0ZWN0IG9uIGludmlzaWJsZSBzdHVmZlxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1vcGFjaXR5JywgJzAuMCcpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgJzhweCcpO1xuXG4gICAgLy8gRU5URVIgKyBVUERBVEUgKGFmZmVjdHMgYWxsIG5ldyBBTkQgZXhpc3RpbmcgbGlua3MpXG4gICAgcGF0aF9saW5rc1xuICAgICAgICAuYXR0cihcImRcIiwgZGlhZ29uYWwpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsaW5rIFwiKyAoZC5zb3VyY2UuaW5ncm91cCA/IFwiaW5ncm91cFwiIDogXCJvdXRncm91cFwiKTsgfSk7XG4gICAgICAgIFxuICAgIHBhdGhfbGlua190cmlnZ2Vyc1xuICAgICAgICAuYXR0cihcImRcIiwgZGlhZ29uYWwpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsaW5rLXRyaWdnZXIgXCIrIChkLnNvdXJjZS5pbmdyb3VwID8gXCJpbmdyb3VwXCIgOiBcIm91dGdyb3VwXCIpOyB9KTtcblxuICAgIGdfbm9kZXNcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgLy8gTi5CLiBUaGVzZSBjbGFzc2VzIGFyZSBvdmVycmlkZGVuIGJ5IHN0dWR5LWVkaXRvci5qcyFcbiAgICAgICAgICBpZiAobi5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG4uZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJyb290IG5vZGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcImlubmVyIG5vZGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwibGVhZiBub2RlXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChcIm5vZGVib3gtXCIrIGRbJ0BpZCddKTsgfSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBkLnkgKyBcIixcIiArIGQueCArIFwiKVwiOyB9KVxuXG4gICAgLy8gRVhJVFxuICAgIHBhdGhfbGlua3NcbiAgICAgIC5leGl0KClcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgcGF0aF9saW5rX3RyaWdnZXJzXG4gICAgICAuZXhpdCgpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGdfbm9kZXNcbiAgICAgIC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAqL1xuICAgIC8vIGFueSBkeW5hbWljIHJlYWRqdXN0bWVudHMgb2Ygbm9uLUNTUyBhdHRyaWJ1dGVzXG4gICAgLy8vc3R5bGVUcmVlTm9kZXModmlzKTtcbiAgICBcbiAgICAvKiBub2RlIGxhYmVsaW5nXG4gICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgU1VQRVItU0xPVyB3aXRoIGxhcmdlIHRyZWVzPyBsaWtlIE1JTlVURVMgdG8gcnVuLi4uXG4gICAgLy8gSXMgdGhlcmUgYSBmYXN0ZXIvY3J1ZGVyIHdheSB0byBjbGVhciB0aGUgZGVja3M/XG4gICAgdmlzLnNlbGVjdEFsbCgnZy5ub2RlIHRleHQnKS5yZW1vdmUoKTtcblxuICAgIC8vIHByb3ZpZGUgYW4gZW1wdHkgbGFiZWwgYXMgbGFzdCByZXNvcnQsIHNvIHdlIGNhbiBzZWUgaGlnaGxpZ2h0c1xuICAgIHZhciBkZWZhdWx0Tm9kZUxhYmVsID0gXCJ1bm5hbWVkXCI7XG5cbiAgICBpZiAoIW9wdGlvbnMuc2tpcExhYmVscykge1xuICAgICAgLy8gcmVmcmVzaCBhbGwgbGFiZWxzIGJhc2VkIG9uIHRyZWUgcG9zaXRpb25cbiAgICAgIHZpcy5zZWxlY3RBbGwoJ2cubm9kZScpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6dGV4dFwiKVxuICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAgICAgICAuYXR0cihcImR4XCIsIC02KVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgLTYpXG4gICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCAnZW5kJylcbiAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxuICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICBzd2l0Y2goZC5sYWJlbFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgKCdtYXBwZWQgbGFiZWwnKTpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyMwMDAnO1xuICAgICAgICAgICAgICAgICAgY2FzZSAoJ25vZGUgaWQnKTpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5hbWJpZ3VvdXNMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyNiOTRhNDgnOyAgLy8gc2hvdyBhbWJpZ3VvdXMgbGFiZWxzLCBtYXRjaCByZWQgcHJvbXB0c1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5hZGphY2VudEVkZ2VMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyM4ODgnO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnIzg4OCc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyM4ODgnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLy8udGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLmxlbmd0aDsgfSk7XG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtc3R5bGUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoZC5sYWJlbFR5cGUgPT09ICdtYXBwZWQgbGFiZWwnID8gJ2luaGVyaXQnIDogJ2l0YWxpYycpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gKGQubmFtZSArICcgKCcrZC5sZW5ndGgrJyknKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVMYWJlbCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoZC5sYWJlbFR5cGUgPT09ICdub2RlIGlkJykge1xuICAgICAgICAgICAgICAgICAgbm9kZUxhYmVsID0gJyc7ICAvLyBoaWRlIHRoZXNlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBub2RlTGFiZWwgPSBkLm5hbWUgfHwgZGVmYXVsdE5vZGVMYWJlbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc3VwcGxlbWVudGFsTGFiZWwgPSBkLmFtYmlndW91c0xhYmVsIHx8IGQuYWRqYWNlbnRFZGdlTGFiZWw7XG4gICAgICAgICAgICAgIGlmIChzdXBwbGVtZW50YWxMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVMYWJlbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlTGFiZWwgPSBzdXBwbGVtZW50YWxMYWJlbDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZUxhYmVsID0gbm9kZUxhYmVsICtcIiBbXCIrIHN1cHBsZW1lbnRhbExhYmVsICtcIl1cIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbm9kZUxhYmVsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICB2aXMuc2VsZWN0QWxsKCdnLnJvb3Qubm9kZSB0ZXh0JylcbiAgICAgICAgICAuYXR0cihcImR4XCIsIC04KVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMyk7XG5cbiAgICAgIHZpcy5zZWxlY3RBbGwoJ2cubGVhZi5ub2RlIHRleHQnKVxuICAgICAgICAuYXR0cihcImR4XCIsIDgpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgMylcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xuICAgIH1cbiAgICBcbiAgICAqL1xuXG4gICAgcmV0dXJuIHt0cmVlOiB0cmVlLCB2aXM6IHZpc31cbiAgfVxuICBcbiAgdmFyIGJ1aWxkUmFkaWFsID0gZnVuY3Rpb24obm9kZXMsIGxpbmtzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAvKiBzZXQgd2lkdGgsIHJhZGl1cywgc3BhY2UgZm9yIGVkZ2UgbGFiZWxzXG4gICAgdmFyIHcgPSBvcHRpb25zLndpZHRoIHx8IGQzLnNlbGVjdChzZWxlY3Rvcikuc3R5bGUoJ3dpZHRoJykgfHwgZDMuc2VsZWN0KHNlbGVjdG9yKS5hdHRyKCd3aWR0aCcpLFxuICAgICAgICByID0gdyAvIDIsXG4gICAgICAgIC8vIE5PVEUgdGhlIGZ1ZGdlIGZhY3RvciBoZXJlOyBsb25nZXIgbGFiZWxzIHdpbGwgYmUgY2xpcHBlZCFcbiAgICAgICAgbGFiZWxXaWR0aCA9IG9wdGlvbnMuc2tpcExhYmVscyA/IDEwIDogb3B0aW9ucy5sYWJlbFdpZHRoIHx8IDEyMDtcbiAgICAqL1xuICAgIFxuICAgIC8qIGJ1aWxkIFNWRywgc2V0IHNpemUgYW5kIG9mZmV0IChjZW50ZXIgaXMgMCwwKVxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3Qoc2VsZWN0b3IpLmFwcGVuZChcInN2ZzpzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByICogMilcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgciAqIDIpXG4gICAgICAuYXBwZW5kKFwic3ZnOmdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyByICsgXCIsXCIgKyByICsgXCIpXCIpO1xuICAgICovXG4gICAgICAgIFxuICAgIC8qIHNldCBzcGFjZSB3aXRoIHggYXMgcG9sYXIgY29vcmRpbmF0ZXMgKDM2MCBkZWdyZWVzKSwgeSA9IDEuMCAqL1xuICAgIHZhciB0cmVlID0gZDMubGF5b3V0LnRyZWUoKSAgLy8gVE9ETzogdXNlIGNsdXN0ZXIgaGVyZT9cbiAgICAgIC5zaXplKFszNjAsIDUwMF0pICAgLy8gV0FTIChbMzYwLCByIC0gbGFiZWxXaWR0aF0pXG4gICAgICAvLyBzb3J0IHBvcHVsb3VzIHRvIHNwYXJzZSBicmFuY2hlc1xuICAgICAgLnNvcnQoZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5jaGlsZHJlbiA/IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDogLTE7IH0pXG4gICAgICAuc2VwYXJhdGlvbihmdW5jdGlvbihhLCBiKSB7IHJldHVybiAoYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoOyB9KTtcbiAgICBcbiAgICB2YXIgcGh5bG9ncmFtID0gYnVpbGRDYXJ0ZXNpYW4oc2VsZWN0b3IsIG5vZGVzLCB7XG4gICAgICB2aXM6IHZpcyxcbiAgICAgIHRyZWU6IHRyZWUsXG4gICAgICBza2lwQnJhbmNoTGVuZ3RoU2NhbGluZzogdHJ1ZSxcbiAgICAgIHNraXBUaWNrczogdHJ1ZSxcbiAgICAgIHNraXBMYWJlbHM6IG9wdGlvbnMuc2tpcExhYmVscyxcbiAgICAgIGRpYWdvbmFsOiByYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWwoKVxuICAgIH0pXG4gICAgdmlzLnNlbGVjdEFsbCgnZy5ub2RlJylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwicm90YXRlKFwiICsgKGQueCAtIDkwKSArIFwiKXRyYW5zbGF0ZShcIiArIGQueSArIFwiKVwiOyB9KVxuICAgIFxuICAgIGlmICghb3B0aW9ucy5za2lwTGFiZWxzKSB7XG4gICAgICB2aXMuc2VsZWN0QWxsKCdnLmxlYWYubm9kZSB0ZXh0JylcbiAgICAgICAgLmF0dHIoXCJkeFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyA4IDogLTg7IH0pXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzFlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IFwic3RhcnRcIiA6IFwiZW5kXCI7IH0pXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IG51bGwgOiBcInJvdGF0ZSgxODApXCI7IH0pXG4gICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKTtcblxuICAgICAgdmlzLnNlbGVjdEFsbCgnZy5pbm5lci5ub2RlIHRleHQnKVxuICAgICAgICAuYXR0cihcImR4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IC02IDogNjsgfSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyBcImVuZFwiIDogXCJzdGFydFwiOyB9KVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyBudWxsIDogXCJyb3RhdGUoMTgwKVwiOyB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHt0cmVlOiB0cmVlLCB2aXM6IHZpc31cbiAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBoeWxvZ3JhbTtcblxuUGh5bG9ncmFtLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJQaHlsb2dyYW0gdHJhbnNmb3JtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQcm9qZWN0cyBoaWVyYXJjaGljYWwgZGF0YSAocHJlc3VtYWJseSBhIHRyZWUpIGludG8gb25lIG9mIHNldmVyYWwgbGF5b3V0cyBcIitcbiAgICAgICAgICAgICAgICAgXCJhbmQgcGFzc2VzIHRoZSByZXN1bHRzIGZvciBkb3duc3RyZWFtIHJlbmRlcmluZy5cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ0eXBlXCI6IHtcImVudW1cIjogW1wicGh5bG9ncmFtXCJdfSxcbiAgICBcImxheW91dFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdWxkIGJlICdyYWRpYWwnLCAnY2xhZG9ncmFtJywgb3IgJ2NhcnRlc2lhbicuXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImRlZmF1bHRcIjogJ2NhcnRlc2lhbidcbiAgICB9LFxuICAgIFwid2lkdGhcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZHRoIG9mIG92ZXJhbGwgcGh5bG9ncmFtLCBpbiBjaG9zZW4gcGh5c2ljYWwgdW5pdHNcIiwgLy8gVE9ETzogQ09ORklSTVxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIm51bWJlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMFxuICAgIH0sXG4gICAgXCJoZWlnaHRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCBvZiBvdmVyYWxsIHBoeWxvZ3JhbSwgaW4gY2hvc2VuIHBoeXNpY2FsIHVuaXRzXCIsIC8vIFRPRE86IENPTkZJUk1cbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJudW1iZXJcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSxcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjBcbiAgICB9LFxuICAgIFwicmFkaXVzXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSYWRpdXMgKGZyb20gY2VudGVyIHRvIGVkZ2UpIG9mIGEgcmFkaWFsIGxheW91dCwgaW4gYXJiaXRyYXJ5IHVuaXRzLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIm51bWJlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDAuNVxuICAgIH0sXG4gICAgXCJyYWRpYWxBcmNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuZ2xlcyBvZiBhcmMgW3N0YXJ0LCBlbmRdIGZvciBhIGNpcmN1bGFyIGxheW91dC5cIixcbiAgICAgIFwib25lT2ZcIjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFswLCAzNjBdXG4gICAgfSxcbiAgICBcInJhZGlhbFN3ZWVwXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEaXJlY3Rpb24gb2YgYXJjLCBDTE9DS1dJU0Ugb3IgQ09VTlRFUkNMT0NLV0lTRS5cIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJzdHJpbmdcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSxcbiAgICAgIFwiZW51bVwiOiBbXCJDTE9DS1dJU0VcIiwgXCJDT1VOVEVSQ0xPQ0tXSVNFXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICdDTE9DS1dJU0UnXG4gICAgfSxcbiAgICBcInRpcHNBbGlnbm1lbnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIldoaWNoIGVkZ2Ugd2lsbCBzaG93IHRoZSBsYWJlbGVkIHRpcHMuXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImVudW1cIjogW1wiVE9QXCIsIFwiUklHSFRcIiwgXCJCT1RUT01cIiwgXCJMRUZUXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICdyaWdodCdcbiAgICB9LFxuICAgIFwiYnJhbmNoU3R5bGVcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk92ZXJyaWRlIHRoZSBsYXlvdXQncyBzdHlsZSAocmFyZWx5IHVzZWQpLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJlbnVtXCI6IFtcInJpZ2h0QW5nbGVEaWFnb25hbFwiLCBcInJhZGlhbFJpZ2h0QW5nbGVEaWFnb25hbFwiLFxuICAgICAgICAgICAgICAgXCJzdHJhaWdodExpbmVEaWFnb25hbFwiLCBcImRpYWdvbmFsXCIsIFwicmFkaWFsXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICcnXG4gICAgfSxcbiAgICBcImJyYW5jaExlbmd0aHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk1hcCBhIGRhdGEgZmllbGQgdG8gYnJhbmNoIGxlbmd0aHMgKE5PVCBZRVQgSU1QTEVNRU5URUQpLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLCAgLy8gaXMgdGhpcyB0eXBlIFwiZmllbGRcIj9cbiAgICAgIFwiZGVmYXVsdFwiOiAnJ1xuICAgIH0sXG4gICAgXCJub2RlTGFiZWxTb3VyY2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvb2sgZm9yIHRpcCBsYWJlbHMgaW4gYSBkYXRhIGZpZWxkLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIlhYWFhYWFhYWFhYXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImVudW1cIjogW1wiWFhYWFhYWFhYWFhcIiwgXCJYWFhYWFhYWFhYWFwiXSxcbiAgICAgIFwiZGVmYXVsdFwiOiAnJ1xuICAgIH0sXG4gICAgXCJzaG93RmFsbGJhY2tMYWJlbHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByaW1hcnkgbGFiZWwgaXMgbm90IGZvdW5kLCBzaG93IGFsdGVybmF0aXZlcy5cIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJib29sZWFuXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsICAvLyBUT0RPOiBjb25maXJtIHRoaXNcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eXBlXCJdICAvLyBUT0RPOiByZXZpZXcgcGFyYW1zIVxufTtcbiIsIi8qIFxuICogQSBzaW1wbGUgdHJhbnNmb3JtIHRvIGdyYWIgdGhlIG5hbWVkIHByb3BlcnR5IGZyb20gYSBKUyBvYmplY3QgKG5vdCBhblxuICogYXJyYXkpLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBkZWFsIHdpdGggaGllcmFyY2hpY2FsIGRhdGEgd2l0aCBcbiAqIG11bHRpcGxlIFwiaW5uZXJcIiBkYXRhc2V0cyAoZWcsIG5vZGVzIGFuZCBlZGdlcykgYW5kIGNvbXBsZXggdXBzdHJlYW1cbiAqIHRyYW5zZm9ybXMuXG4gKlxuICogRVhBTVBMRTpcbiAqICAgIFwiZnJvbVwiOiB7XG4gKiAgICAgIFwiZGF0YVwiOiBcInBoeWxvVHJlZVwiLCBcbiAqICAgICAgXCJ0cmFuc2Zvcm1cIjogW1xuICogICAgICAgICAge1widHlwZVwiOlwicGx1Y2tcIiwgXCJmaWVsZFwiOlwicGh5bG9Ob2Rlc1wiIH1cbiAqICAgICAgXSBcbiAqICB9LFxuICovXG52YXIgdmcgID0gcmVxdWlyZSgndmVnYScpLFxuICAgIGxvZyAgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBQbHVjayhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICAgIGZpZWxkOiB7dHlwZTogJ2ZpZWxkJ31cbiAgfSk7XG4gIC8vIFRPRE86IGNvbmZpcm0gdGhhdCB0aGlzIGlzIGFwcHJvcHJpYXRlIGhlcmVcbiAgcmV0dXJuIHRoaXMucHJvZHVjZXModHJ1ZSlcbiAgICAgICAgICAgICAubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChQbHVjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWNrO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ3BsdWNraW5nJ10pO1xuXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZCA9IHRoaXMucGFyYW0oJ2ZpZWxkJyk7XG5cbiAgLy8gRm9yIG5vdywgdGhpcyB0cmFuc2Zvcm0gQVNTVU1FUyBqdXN0IG9uZSBpbmNvbWluZyB0dXBsZSwgd2hpY2ggd2lsbCBiZVxuICAvLyBjb21wbGV0ZWx5IHJlcGxhY2VkIGJ5IHRoZSBwbHVja2VkIHZhbHVlcy5cbiAgYXNzZXJ0KGlucHV0LmFkZC5sZW5ndGggPCAyLCBcbiAgICAgICAgIFwiVGhlIHBsdWNrIHRyYW5zZm9ybSBjYW4gb25seSByZXBsYWNlIGEgc2luZ2xlIGFkZGVkIGRhdHVtLlwiKTtcbiAgdmFyIHBsdWNrZWRWYWx1ZXMgPSBmaWVsZC5hY2Nlc3NvcihpbnB1dC5hZGRbMF0pOyAvLyByZXR1cm5zIHBsdWNrZWQgYXJyYXlcbiAgLy8gYWRkIF9pZCBwcm9wZXJ0aWVzPyBub3QgY2xlYXIgaWYgdGhpcyBpcyBuZWVkZWRcbiAgdmFyIG5leHRBdmFpbGFibGVJRCA9IDEwMDAwMDA7XG4gIHZhciBhc3NpZ25VbmlxdWVJRCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghKCdfaWQnIGluIG9iaikpIHtcbiAgICAgIG9iai5faWQgPSAoJ18nKyArK25leHRBdmFpbGFibGVJRCk7XG4gICAgfVxuICB9XG4gIHBsdWNrZWRWYWx1ZXMuZm9yRWFjaChhc3NpZ25VbmlxdWVJRCk7XG4gIGlucHV0LmFkZCA9IHBsdWNrZWRWYWx1ZXM7ICAgIC8vIHJlcGxhY2UgdGhlIGluY29taW5nIHR1cGxlXG5cbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICAvLyBBY3R1YWxseSwgd2UgY2FuIGFsc28gcmVwbGFjZSBqdXN0IG9uZSBtb2RpZmllZCB0dXBsZSwgaWYgZm91bmRcbiAgICBhc3NlcnQoaW5wdXQubW9kLmxlbmd0aCA8IDIsIFxuICAgICAgICAgICBcIlRoZSBwbHVjayB0cmFuc2Zvcm0gY2FuIG9ubHkgcmVwbGFjZSBhIHNpbmdsZSBtb2RpZmllZCBkYXR1bS5cIik7XG4gICAgcGx1Y2tlZFZhbHVlcyA9IGZpZWxkLmFjY2Vzc29yKGlucHV0Lm1vZFswXSk7XG4gICAgcGx1Y2tlZFZhbHVlcy5mb3JFYWNoKGFzc2lnblVuaXF1ZUlEKTtcbiAgICBpbnB1dC5tb2QgPSBwbHVja2VkVmFsdWVzO1xuICB9XG4gIC8vIHJldHVybiB0aGUgbW9kaWZpZWQgQ2hhbmdlU2V0XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Y2s7XG5cblBsdWNrLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJQbHVjayB0cmFuc2Zvcm1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkdyYWJzIGEgcHJvcGVydHkgKG9yIGRlZXBlciBwYXRoKSBmcm9tIGEgaGllcmFyY2h5LlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1wiZW51bVwiOiBbXCJwbHVja1wiXX0sXG4gICAgXCJmaWVsZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hpY2ggZmllbGQgb2YgdGhlIGRhdGEgeW91IHdhbnQgdG8gc2VsZWN0LlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcImZpZWxkXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0gIC8vIFRPRE86IHNpZ25hbD9cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1widHlwZVwiLCBcImZpZWxkXCJdXG59O1xuXG4vKlxudmcudHJhbnNmb3Jtcy5wbHVjayA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBmaWVsZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcGx1Y2soZGF0YSkgeyAgICBcbiAgICB2YXIgcmVzdWx0ID0gZmllbGQoZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBcbiAgcGx1Y2suZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gICAgZmllbGQgPSB2Zy5hY2Nlc3NvcihmKTtcbiAgICByZXR1cm4gcGx1Y2s7XG4gIH07XG5cbiAgcmV0dXJuIHBsdWNrO1xufTtcbiovXG4iLCIvKiBcbiAqIFN0b3JlIHRoZSBpbmNvbWluZyBkYXRhIChpZiBpdCdzIG5vdCBhbHJlYWR5IGZvdW5kKSBpbiB0aGUgc3BlY2lmaWVkIG9iamVjdFxuICogdXNpbmcgdGhlIHNwZWNpZmllZCBrZXksIHRoZW4gcGFzcyBpdCBhbG9uZyB1bmNoYW5nZWQuXG4gKlxuICogVGhpcyBpcyBhIFwiZG8tbm90aGluZ1wiIGRhdGEgdHJhbnNmb3JtIHRvIGFsbG93IGNhY2hpbmcgb2YgaW50ZXJtZWRpYXRlIHJlc3VsdHNcbiAqIGZyb20gd2l0aGluIGEgVmVnYSBwaXBlbGluZSAoYSBzZXJpZXMgb2YgdHJhbnNmb3JtcykuIFRoZSBpbnRlbnQgaXMgdG9cbiAqIHN1cHBvcnQgYSBtdWNoIGZhc3RlciBwaXBlbGluZSBmb3IgZnJlcXVlbnRseSBtb2RpZmllZCB2aXN1YWxpemF0aW9ucywgYXNcbiAqIHVzZWQgaW4gdGhlIFRyZWUgSWxsdXN0cmF0b3IgcHJvamVjdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL09wZW5UcmVlT2ZMaWZlL3RyZWUtaWxsdXN0cmF0b3JcbiAqIFxuICogTm90ZSB0aGF0IHRoaXMgdHJhbnNmb3JtIGRvZXNuJ3QgY29uY2VybiBpdHNlbGYgd2l0aCB0aGUgZGV0YWlscyBvZiB0aGUgY2FjaGluZyBcbiAqIG1lY2hhbmlzbTsgaXQncyBhc3N1bWVkIHRvIGJlIGFuIGV4aXN0aW5nIEphdmFzY3JpcHQgb2JqZWN0IChhc3NvY2lhdGl2ZVxuICogYXJyYXkpIHRoYXQgZnVuY3Rpb25zIGFzIGEgc2ltcGxlIGtleS92YWx1ZSBzdG9yZS4gU2ltaWxhcmx5LCB0aGUgaG9zdFxuICogYXBwbGljYXRpb24gaXMgcmVzcG9uc2libGUgZm9yIGRlZmluaW5nIGlkZW1wb3RlbnQga2V5cyBmb3IgY2FjaGVkIGRhdGEuXG4gKiBcbiAqIEFsc28sIG5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgKnJldHJpZXZlKiBjYWNoZWQgZGF0YSBvciBzcGVlZCB0aGluZ3MgdXAgb25cbiAqIGl0cyBvd24hIEluc3RlYWQsIGJ5IGZlZWRpbmcgYSBjYWNoZSBpdCBlbmFibGVzIHRoZSBob3N0IGFwcGxpY2F0aW9uIHRvXG4gKiBjb25zdHJ1Y3QgYSBzaW1wbGVyIHBpcGVsaW5lIGJ5IHByb3ZpZGluZyBjYWNoZWQgZGF0YSBpbnN0ZWFkIG9mIFVSTHMsXG4gKiBvbWl0dGluZyB1bm5lZWRlZCB0cmFuc2Zvcm1zLCBldGMuXG4gKi9cbnZhciB2ZyAgPSByZXF1aXJlKCd2ZWdhJyksXG4gICAgbG9nICA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3ZlZ2Evc3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIFN0YXNoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgICAgY2FjaGVQYXRoOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgICBrZXk6IHt0eXBlOiAndmFsdWUnfSxcbiAgICAgIGZsdXNoOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogZmFsc2V9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xuICAvLyBUT0RPOiBhZGQgY2FsbHMgdG8gbXV0YXRlcygpLCByb3V0ZXIoKT9cbn1cblxudmFyIHByb3RvdHlwZSA9IChTdGFzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXNoO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ3N0YXNoaW5nJ10pO1xuXG4gIHZhciBjYWNoZVBhdGggPSB0aGlzLnBhcmFtKCdjYWNoZVBhdGgnKSxcbiAgICAgIGNhY2hlID0gZXZhbChjYWNoZVBhdGgpLFxuICAgICAga2V5ID0gdGhpcy5wYXJhbSgna2V5JyksXG4gICAgICBmbHVzaCA9IHRoaXMucGFyYW0oJ2ZsdXNoJyk7XG5cbiAgaWYgKCFjYWNoZSB8fCAodHlwZW9mIGNhY2hlICE9PSAnb2JqZWN0JykpIHtcbiAgICAvLyBpZiBhbiBpbnZhbGlkIGNhY2hlIHBhdGggaXMgc3VibWl0dGVkLCB0cmVhdCB0aGlzIGFzIGEgbm8tb3BcbiAgICBjb25zb2xlLndhcm4oJ3N0YXNoIHRyYW5zZm9ybTogbm8gY2FjaGUgZm91bmQgaW4gZXZhbCgnKyBjYWNoZVBhdGggKycpISBza2lwcGluZyB0aGlzIGRhdGEnKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICAvLyBGb3Igbm93LCB0aGlzIHRyYW5zZm9ybSBBU1NVTUVTIGp1c3Qgb25lIGluY29taW5nIHR1cGxlLCB3aGljaCB3aWxsIGJlXG4gIC8vIGNvbXBsZXRlbHkgcmVwbGFjZWQgYnkgdGhlIHBsdWNrZWQgdmFsdWVzLlxuICBhc3NlcnQoKGlucHV0LmFkZC5sZW5ndGggPCAyICYmXG4gICAgICAgICAgaW5wdXQubW9kLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgIGlucHV0LnJlbS5sZW5ndGggPT09IDApLFxuICAgICAgICAgXCJUaGUgc3Rhc2ggdHJhbnNmb3JtIG9ubHkgc3RvcmVzIGEgc2luZ2xlIGFkZGVkIGRhdHVtLlwiKTtcblxuICAvKiBTdGFzaCBhIHNpbmdsZSBpbmNvbWluZyBkYXR1bS4gTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHN0b3JlIGEgKmNvcHkqIG9mXG4gICAqIHRoZSBkYXRhLCBzaW5jZSBWZWdhIGFsd2F5cyBjbG9uZXMgZGF0YSBpbiBhIHNwZWMgKHNlZSBjb21tZW50IGFib3ZlKS5cbiAgICovXG4gIGlmIChmbHVzaCB8fCAhKGtleSBpbiBjYWNoZSkpIHtcbiAgICAvLyBiZSBzdXJlIHRvIGNhY2hlIHRoZSBcInJhd1wiIGRhdGEgYXMgcmV0dXJuZWQgZnJvbSBzb3VyY2VcbiAgICBjYWNoZVsga2V5IF0gPSBkbC5kdXBsaWNhdGUoaW5wdXQuYWRkWzBdKTtcbiAgICAvLyBOLkIuIGRsLmR1cGxpY2F0ZSBjbGVhbnMgdXAgYW55IHdlaXJkIG1ldGhvZHMgYW5kIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgfVxuXG4vKiBPUiBzaG91bGQgd2Ugc3Rhc2ggYWxsIGRhdGEgcGllY2VtZWFsLCBiYXNlZCBvbiBzdGF0ZT8/XG4gIC8vIG1vdmUgbmV3IChhbmQgcG9zc2libHkgY2hhbmdlZCkgZGF0YSB0byB0aGUgY2FjaGVcbiAgZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAvL21vdmUgb25lIGRhdHVtICh0dXBsZT8pIGludG8gdGhlIGNhY2hlXG4gICAgY29uc29sZS5sb2coXCJzZXR0aW5nICdcIisgeCArXCInLi4uXCIpO1xuICAgIC8vVHVwbGUuc2V0KHgsIGZpZWxkLCBleHByKHgsIG51bGwsIHNpZ25hbHMpKTtcbiAgfVxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cbiovXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3Rhc2g7XG5cblN0YXNoLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJTdGFzaCB0cmFuc2Zvcm1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlN0b3JlcyB0aGUgaW5jb21pbmcgZGF0YSAoaWYgaXQncyBub3QgYWxyZWFkeSBmb3VuZCkgaW4gdGhlXCIgK1xuICAgIFwiIHNwZWNpZmllZCBvYmplY3QgdXNpbmcgdGhlIHNwZWNpZmllZCBrZXksIHRoZW4gcGFzc2VzIGl0IGFsb25nIHVuY2hhbmdlZC5cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ0eXBlXCI6IHtcImVudW1cIjogW1wic3Rhc2hcIl19LFxuICAgIFwiY2FjaGVQYXRoXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGZpZWxkIHBvaW50aW5nIHRvIHRoZSBjYWNoZSBvYmplY3RcIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJzdHJpbmdcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSAgLy8gVE9ETzogc2lnbmFsP1xuICAgIH0sXG4gICAgXCJrZXlcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgdW5pcXVlIGtleSBmb3IgdGhpcyBkYXRhIGluIHRoZSBzdGFzaFwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dXG4gICAgfSxcbiAgICBcImZsdXNoXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlLCB3aWxsIHJlcGxhY2UgYW55IGV4aXN0aW5nIHN0YXNoZWQgZGF0YS5cIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJib29sZWFuXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsICAvLyBUT0RPOiBjb25maXJtIHRoaXNcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eXBlXCIsIFwia2V5XCIsIFwiY2FjaGVQYXRoXCJdXG59O1xuIl19
