(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.stylist = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":131}],2:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],3:[function(require,module,exports){
/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function(uri) {
				var
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
				;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				if (Uint8Array && blobParts[i] instanceof Uint8Array) {
					builder.append(blobParts[i].buffer);
				}
				else {
					builder.append(blobParts[i]);
				}
			}
		}
		var blob = builder.getBlob(type);
		if (!blob.slice && blob.webkitSlice) {
			blob.slice = blob.webkitSlice;
		}
		return blob;
	};

	var getPrototypeOf = Object.getPrototypeOf || function(object) {
		return object.__proto__;
	};
	view.Blob.prototype = getPrototypeOf(new view.Blob());
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

},{}],4:[function(require,module,exports){

},{}],5:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":2,"ieee754":57,"is-array":60}],6:[function(require,module,exports){
require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;
},{"../modules/_core":10,"../modules/web.immediate":26}],7:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],8:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":21}],9:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],10:[function(require,module,exports){
var core = module.exports = {version: '2.3.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],11:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":7}],12:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":15}],13:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":16,"./_is-object":21}],14:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":10,"./_ctx":11,"./_global":16,"./_hide":17}],15:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],16:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],17:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":12,"./_object-dp":22,"./_property-desc":23}],18:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":16}],19:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":12,"./_dom-create":13,"./_fails":15}],20:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],21:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],22:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":8,"./_descriptors":12,"./_ie8-dom-define":19,"./_to-primitive":25}],23:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],24:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":9,"./_ctx":11,"./_dom-create":13,"./_global":16,"./_html":18,"./_invoke":20}],25:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":21}],26:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":14,"./_task":24}],27:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":61}],28:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.dsv = {}));
}(this, function (exports) { 'use strict';

  var dsv = function(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n]"),
        delimiterCode = delimiter.charCodeAt(0);

    function parse(text, f) {
      var o;
      return parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) { return f(a(row), i); } : a;
      });
    }

    function parseRows(text, f) {
      var EOL = {}, // sentinel value for end-of-line
          EOF = {}, // sentinel value for end-of-file
          rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // the current line number
          t, // the current token
          eol; // is the current token followed by EOL?

      function token() {
        if (I >= N) return EOF; // special case: end of file
        if (eol) return eol = false, EOL; // special case: end of line

        // special case: quotes
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, "\"");
        }

        // common case: find next delimiter or newline
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; // \n
          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
          else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }

        // special case: last token before EOF
        return text.slice(j);
      }

      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }

      return rows;
    }

    function format(rows) {
      if (Array.isArray(rows[0])) return formatRows(rows); // deprecated; use formatRows
      var fieldSet = Object.create(null), fields = [];

      // Compute unique fields in order of discovery.
      rows.forEach(function(row) {
        for (var field in row) {
          if (!((field += "") in fieldSet)) {
            fields.push(fieldSet[field] = field);
          }
        }
      });

      return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(text) {
      return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatRows: formatRows
    };
  }

  exports.csv = dsv(",");
  exports.tsv = dsv("\t");

  exports.dsv = dsv;

}));
},{}],29:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.format = {}));
}(this, function (exports) { 'use strict';

  var zhCn = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["¥", ""]
  };

  var ruRu = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0руб."]
  };

  var ptBr = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["R$", ""]
  };

  var plPl = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "zł"]
  };

  var nlNl = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€\xa0", ""]
  };

  var mkMk = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0ден."]
  };

  var jaJp = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["", "円"]
  };

  var itIt = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€", ""]
  };

  var heIl = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["₪", ""]
  };

  var frFr = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var frCa = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "$"]
  };

  var fiFi = {
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var esEs = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var enUs = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  };

  var enGb = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["£", ""]
  };

  var enCa = {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  };

  var deDe = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };

  var caEs = {
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  };


  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, p + i - 1)[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };


  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function locale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function format(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      return function(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            var i = -1, n = value.length, c;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      };
    }

    function formatPrefix(specifier, value) {
      var f = format((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: format,
      formatPrefix: formatPrefix
    };
  }

  function precisionRound(step, max) {
    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  var localeDefinitions = {
    "ca-ES": caEs,
    "de-DE": deDe,
    "en-CA": enCa,
    "en-GB": enGb,
    "en-US": enUs,
    "es-ES": esEs,
    "fi-FI": fiFi,
    "fr-CA": frCa,
    "fr-FR": frFr,
    "he-IL": heIl,
    "it-IT": itIt,
    "ja-JP": jaJp,
    "mk-MK": mkMk,
    "nl-NL": nlNl,
    "pl-PL": plPl,
    "pt-BR": ptBr,
    "ru-RU": ruRu,
    "zh-CN": zhCn
  };

  var defaultLocale = locale(enUs);
  exports.format = defaultLocale.format;
  exports.formatPrefix = defaultLocale.formatPrefix;

  function localeFormat(definition) {
    if (typeof definition === "string") {
      if (!localeDefinitions.hasOwnProperty(definition)) return null;
      definition = localeDefinitions[definition];
    }
    return locale(definition);
  }
  ;

  exports.localeFormat = localeFormat;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

}));
},{}],30:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.timeFormat = {}));
}(this, function (exports) { 'use strict';

  var zhCn = {
    dateTime: "%a %b %e %X %Y",
    date: "%Y/%-m/%-d",
    time: "%H:%M:%S",
    periods: ["上午", "下午"],
    days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    shortDays: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    shortMonths: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
  };

  var ruRu = {
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
    shortDays: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
    months: ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
    shortMonths: ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
  };

  var ptBr = {
    dateTime: "%A, %e de %B de %Y. %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
    shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
    months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
    shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
  };

  var plPl = {
    dateTime: "%A, %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
    shortDays: ["Niedz.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
    months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
    shortMonths: ["Stycz.", "Luty", "Marz.", "Kwie.", "Maj", "Czerw.", "Lipc.", "Sierp.", "Wrz.", "Paźdz.", "Listop.", "Grudz."]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */
  };

  var nlNl = {
    dateTime: "%a %e %B %Y %T",
    date: "%d-%m-%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
    shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
    months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
    shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
  };

  var mkMk = {
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
    shortDays: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
    months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
    shortMonths: ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
  };

  var jaJp = {
    dateTime: "%Y %b %e %a %X",
    date: "%Y/%m/%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
    shortDays: ["日", "月", "火", "水", "木", "金", "土"],
    months: ["睦月", "如月", "弥生", "卯月", "皐月", "水無月", "文月", "葉月", "長月", "神無月", "霜月", "師走"],
    shortMonths: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
  };

  var itIt = {
    dateTime: "%A %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
    shortDays: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
    months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
    shortMonths: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
  };

  var heIl = {
    dateTime: "%A, %e ב%B %Y %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
    shortDays: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
    months: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
    shortMonths: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"]
  };

  var frFr = {
    dateTime: "%A, le %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
  };

  var frCa = {
    dateTime: "%a %e %b %Y %X",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["", ""],
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["jan", "fév", "mar", "avr", "mai", "jui", "jul", "aoû", "sep", "oct", "nov", "déc"]
  };

  var fiFi = {
    dateTime: "%A, %-d. %Bta %Y klo %X",
    date: "%-d.%-m.%Y",
    time: "%H:%M:%S",
    periods: ["a.m.", "p.m."],
    days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"],
    shortDays: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
    months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
    shortMonths: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kesä", "Heinä", "Elo", "Syys", "Loka", "Marras", "Joulu"]
  };

  var esEs = {
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
    shortDays: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
    months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
    shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
  };

  var enUs = {
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var enGb = {
    dateTime: "%a %e %b %X %Y",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var enCa = {
    dateTime: "%a %b %e %X %Y",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  };

  var deDe = {
    dateTime: "%A, der %e. %B %Y, %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
  };

  var caEs = {
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
    shortDays: ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
    months: ["gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre"],
    shortMonths: ["gen.", "febr.", "març", "abr.", "maig", "juny", "jul.", "ag.", "set.", "oct.", "nov.", "des."]
  };

  var t0 = new Date;
  var t1 = new Date;

  function newInterval(floori, offseti, count) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.round = function(date) {
      var d0 = new Date(+date),
          d1 = new Date(date - 1);
      floori(d0), floori(d1), offseti(d1, 1);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), date;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [];
      start = new Date(start - 1);
      stop = new Date(+stop);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      offseti(start, 1), floori(start);
      if (start < stop) range.push(new Date(+start));
      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        while (--step >= 0) while (offseti(date, 1), !test(date));
      });
    };

    if (count) interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    return interval;
  }

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);

  var year = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / 864e5;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / 6048e5;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);

  var utcYear = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCMonth(0, 1);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  });

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
  }

  function locale(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "S": formatSeconds,
      "U": formatWeekNumberSunday,
      "w": formatWeekdayNumber,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "S": formatUTCSeconds,
      "U": formatUTCWeekNumberSunday,
      "w": formatUTCWeekdayNumber,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "S": parseSeconds,
      "U": parseWeekNumberSunday,
      "w": parseWeekdayNumber,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            if (format = formats[c]) c = format(date, pad == null ? (c === "e" ? " " : "0") : pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function(string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string, 0);
        if (i != string.length) return null;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          if ("w" in d && ("W" in d || "U" in d)) {
            var day = utcDate(newYear(d.y)).getUTCDay();
            if ("W" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;
            d.m = 0;
            d.d = d.w + d.U * 7 - (day + 6) % 7;
          }
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        if ("w" in d && ("W" in d || "U" in d)) {
          var day = newDate(newYear(d.y)).getDay();
          if ("W" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;
          d.m = 0;
          d.d = d.w + d.U * 7 - (day + 6) % 7;
        }
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function parsePeriod(d, string, i) {
      var n = periodLookup[string.slice(i, i += 2).toLowerCase()];
      return n == null ? -1 : (d.p = n, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.parse = newParse(specifier, localDate);
        f.toString = function() { return specifier; };
        return f;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.parse = newParse(specifier, utcDate);
        f.toString = function() { return specifier; };
        return f;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"};
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
    if (n) {
      d.Z = n[1] ? 0              // 'Z' for UTC
          : n[3] ? -(n[2] + n[3]) // sign differs from getTimezoneOffset!
                 : -n[2] * 100;
      return i + n[0].length;
    }
    return -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(year(d), d), p, 2);
  }

  function formatWeekdayNumber(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(year(d), d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d), d), p, 2);
  }

  function formatUTCWeekdayNumber(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };

  formatIsoNative.toString = function() {
    return isoSpecifier;
  };

  var formatIso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z")
      ? formatIsoNative
      : enUs.utcFormat(isoSpecifier);

  var isoFormat = formatIso;

  var localeDefinitions = {
    "ca-ES": caEs,
    "de-DE": deDe,
    "en-CA": enCa,
    "en-GB": enGb,
    "en-US": enUs,
    "es-ES": esEs,
    "fi-FI": fiFi,
    "fr-CA": frCa,
    "fr-FR": frFr,
    "he-IL": heIl,
    "it-IT": itIt,
    "ja-JP": jaJp,
    "mk-MK": mkMk,
    "nl-NL": nlNl,
    "pl-PL": plPl,
    "pt-BR": ptBr,
    "ru-RU": ruRu,
    "zh-CN": zhCn
  };

  var defaultLocale = locale(enUs);
  exports.format = defaultLocale.format;
  exports.utcFormat = defaultLocale.utcFormat;

  function localeFormat(definition) {
    if (typeof definition === "string") {
      if (!localeDefinitions.hasOwnProperty(definition)) return null;
      definition = localeDefinitions[definition];
    }
    return locale(definition);
  }
  ;

  exports.localeFormat = localeFormat;
  exports.isoFormat = isoFormat;

}));
},{}],31:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.time = {}));
}(this, function (exports) { 'use strict';

  var t1 = new Date;

  var t0 = new Date;

  function newInterval(floori, offseti, count) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.round = function(date) {
      var d0 = new Date(+date),
          d1 = new Date(date - 1);
      floori(d0), floori(d1), offseti(d1, 1);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), date;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [];
      start = new Date(start - 1);
      stop = new Date(+stop);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      offseti(start, 1), floori(start);
      if (start < stop) range.push(new Date(+start));
      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        while (--step >= 0) while (offseti(date, 1), !test(date));
      });
    };

    if (count) interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    return interval;
  }

  var second = newInterval(function(date) {
    date.setMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  });

  exports.seconds = second.range;

  var minute = newInterval(function(date) {
    date.setSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  });

  exports.minutes = minute.range;

  var hour = newInterval(function(date) {
    date.setMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  });

  exports.hours = hour.range;

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
  });

  exports.days = day.range;

  function weekday(i) {
    return newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
    });
  }

  exports.sunday = weekday(0);

  exports.sundays = exports.sunday.range;

  exports.monday = weekday(1);

  exports.mondays = exports.monday.range;

  exports.tuesday = weekday(2);

  exports.tuesdays = exports.tuesday.range;

  exports.wednesday = weekday(3);

  exports.wednesdays = exports.wednesday.range;

  exports.thursday = weekday(4);

  exports.thursdays = exports.thursday.range;

  exports.friday = weekday(5);

  exports.fridays = exports.friday.range;

  exports.saturday = weekday(6);

  exports.saturdays = exports.saturday.range;

  var week = exports.sunday;

  exports.weeks = week.range;

  var month = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setDate(1);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  });

  exports.months = month.range;

  var year = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  });

  exports.years = year.range;

  var utcSecond = newInterval(function(date) {
    date.setUTCMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  });

  exports.utcSeconds = utcSecond.range;

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  });

  exports.utcMinutes = utcMinute.range;

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  });

  exports.utcHours = utcHour.range;

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / 864e5;
  });

  exports.utcDays = utcDay.range;

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / 6048e5;
    });
  }

  exports.utcSunday = utcWeekday(0);

  exports.utcSundays = exports.utcSunday.range;

  exports.utcMonday = utcWeekday(1);

  exports.utcMondays = exports.utcMonday.range;

  exports.utcTuesday = utcWeekday(2);

  exports.utcTuesdays = exports.utcTuesday.range;

  exports.utcWednesday = utcWeekday(3);

  exports.utcWednesdays = exports.utcWednesday.range;

  exports.utcThursday = utcWeekday(4);

  exports.utcThursdays = exports.utcThursday.range;

  exports.utcFriday = utcWeekday(5);

  exports.utcFridays = exports.utcFriday.range;

  exports.utcSaturday = utcWeekday(6);

  exports.utcSaturdays = exports.utcSaturday.range;

  var utcWeek = exports.utcSunday;

  exports.utcWeeks = utcWeek.range;

  var utcMonth = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCDate(1);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  });

  exports.utcMonths = utcMonth.range;

  var utcYear = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCMonth(0, 1);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  });

  exports.utcYears = utcYear.range;

  exports.interval = newInterval;
  exports.second = second;
  exports.minute = minute;
  exports.hour = hour;
  exports.day = day;
  exports.week = week;
  exports.month = month;
  exports.year = year;
  exports.utcSecond = utcSecond;
  exports.utcMinute = utcMinute;
  exports.utcHour = utcHour;
  exports.utcDay = utcDay;
  exports.utcWeek = utcWeek;
  exports.utcMonth = utcMonth;
  exports.utcYear = utcYear;

}));
},{}],32:[function(require,module,exports){
var util = require('../util'),
    Measures = require('./measures'),
    Collector = require('./collector');

function Aggregator() {
  this._cells = {};
  this._aggr = [];
  this._stream = false;
}

var Flags = Aggregator.Flags = {
  ADD_CELL: 1,
  MOD_CELL: 2
};

var proto = Aggregator.prototype;

// Parameters

proto.stream = function(v) {
  if (v == null) return this._stream;
  this._stream = !!v;
  this._aggr = [];
  return this;
};

// key accessor to use for streaming removes
proto.key = function(key) {
  if (key == null) return this._key;
  this._key = util.$(key);
  return this;
};

// Input: array of objects of the form
// {name: string, get: function}
proto.groupby = function(dims) {
  this._dims = util.array(dims).map(function(d, i) {
    d = util.isString(d) ? {name: d, get: util.$(d)}
      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}
      : (d.name && util.isFunction(d.get)) ? d : null;
    if (d == null) throw 'Invalid groupby argument: ' + d;
    return d;
  });
  return this.clear();
};

// Input: array of objects of the form
// {name: string, ops: [string, ...]}
proto.summarize = function(fields) {
  fields = summarize_args(fields);
  this._count = true;
  var aggr = (this._aggr = []),
      m, f, i, j, op, as, get;

  for (i=0; i<fields.length; ++i) {
    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {
      op = f.ops[j];
      if (op !== 'count') this._count = false;
      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));
      m.push(Measures[op](as));
    }
    get = f.get && util.$(f.get) ||
      (f.name === '*' ? util.identity : util.$(f.name));
    aggr.push({
      name: f.name,
      measures: Measures.create(
        m,
        this._stream, // streaming remove flag
        get,          // input tuple getter
        this._assign) // output tuple setter
    });
  }
  return this.clear();
};

// Convenience method to summarize by count
proto.count = function() {
  return this.summarize({'*':'count'});
};

// Override to perform custom tuple value assignment
proto._assign = function(object, name, value) {
  object[name] = value;
};

function summarize_args(fields) {
  if (util.isArray(fields)) { return fields; }
  if (fields == null) { return []; }
  var a = [], name, ops;
  for (name in fields) {
    ops = util.array(fields[name]);
    a.push({name: name, ops: ops});
  }
  return a;
}

// Cell Management

proto.clear = function() {
  return (this._cells = {}, this);
};

proto._cellkey = function(x) {
  var d = this._dims,
      n = d.length, i,
      k = String(d[0].get(x));
  for (i=1; i<n; ++i) {
    k += '|' + d[i].get(x);
  }
  return k;
};

proto._cell = function(x) {
  var key = this._dims.length ? this._cellkey(x) : '';
  return this._cells[key] || (this._cells[key] = this._newcell(x, key));
};

proto._newcell = function(x, key) {
  var cell = {
    num:   0,
    tuple: this._newtuple(x, key),
    flag:  Flags.ADD_CELL,
    aggs:  {}
  };

  var aggr = this._aggr, i;
  for (i=0; i<aggr.length; ++i) {
    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);
  }
  if (cell.collect) {
    cell.data = new Collector(this._key);
  }
  return cell;
};

proto._newtuple = function(x) {
  var dims = this._dims,
      t = {}, i, n;
  for (i=0, n=dims.length; i<n; ++i) {
    t[dims[i].name] = dims[i].get(x);
  }
  return this._ingest(t);
};

// Override to perform custom tuple ingestion
proto._ingest = util.identity;

// Process Tuples

proto._add = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num += 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.add(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].add(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_add) this._on_add(x, cell);
};

proto._rem = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num -= 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.rem(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].rem(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_rem) this._on_rem(x, cell);
};

proto._mod = function(curr, prev) {
  var cell0 = this._cell(prev),
      cell1 = this._cell(curr),
      aggr = this._aggr, i;

  if (cell0 !== cell1) {
    cell0.num -= 1;
    cell1.num += 1;
    if (cell0.collect) cell0.data.rem(prev);
    if (cell1.collect) cell1.data.add(curr);
  } else if (cell0.collect && !util.isObject(curr)) {
    cell0.data.rem(prev);
    cell0.data.add(curr);
  }

  for (i=0; i<aggr.length; ++i) {
    cell0.aggs[aggr[i].name].rem(prev);
    cell1.aggs[aggr[i].name].add(curr);
  }
  cell0.flag |= Flags.MOD_CELL;
  cell1.flag |= Flags.MOD_CELL;
  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);
};

proto.result = function() {
  var result = [],
      aggr = this._aggr,
      cell, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    if (cell.num > 0) {
      // consolidate collector values
      if (cell.collect) {
        cell.data.values();
      }
      // update tuple properties
      for (i=0; i<aggr.length; ++i) {
        cell.aggs[aggr[i].name].set();
      }
      // add output tuple
      result.push(cell.tuple);
    } else {
      delete this._cells[k];
    }
    cell.flag = 0;
  }

  this._rems = false;
  return result;
};

proto.changes = function(output) {
  var changes = output || {add:[], rem:[], mod:[]},
      aggr = this._aggr,
      cell, flag, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    flag = cell.flag;

    // consolidate collector values
    if (cell.collect) {
      cell.data.values();
    }

    // update tuple properties
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].set();
    }

    // organize output tuples
    if (cell.num <= 0) {
      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??
      delete this._cells[k];
      if (this._on_drop) this._on_drop(cell);
    } else {
      if (this._on_keep) this._on_keep(cell);
      if (flag & Flags.ADD_CELL) {
        changes.add.push(cell.tuple);
      } else if (flag & Flags.MOD_CELL) {
        changes.mod.push(cell.tuple);
      }
    }

    cell.flag = 0;
  }

  this._rems = false;
  return changes;
};

proto.execute = function(input) {
  return this.clear().insert(input).result();
};

proto.insert = function(input) {
  this._consolidate();
  for (var i=0; i<input.length; ++i) {
    this._add(input[i]);
  }
  return this;
};

proto.remove = function(input) {
  if (!this._stream) {
    throw 'Aggregator not configured for streaming removes.' +
      ' Call stream(true) prior to calling summarize.';
  }
  for (var i=0; i<input.length; ++i) {
    this._rem(input[i]);
  }
  this._rems = true;
  return this;
};

// consolidate removals
proto._consolidate = function() {
  if (!this._rems) return;
  for (var k in this._cells) {
    if (this._cells[k].collect) {
      this._cells[k].data.values();
    }
  }
  this._rems = false;
};

module.exports = Aggregator;
},{"../util":54,"./collector":33,"./measures":35}],33:[function(require,module,exports){
var util = require('../util');
var stats = require('../stats');

var REM = '__dl_rem__';

function Collector(key) {
  this._add = [];
  this._rem = [];
  this._key = key || null;
  this._last = null;
}

var proto = Collector.prototype;

proto.add = function(v) {
  this._add.push(v);
};

proto.rem = function(v) {
  this._rem.push(v);
};

proto.values = function() {
  this._get = null;
  if (this._rem.length === 0) return this._add;

  var a = this._add,
      r = this._rem,
      k = this._key,
      x = Array(a.length - r.length),
      i, j, n, m;

  if (!util.isObject(r[0])) {
    // processing raw values
    m = stats.count.map(r);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (m[a[i]] > 0) {
        m[a[i]] -= 1;
      } else {
        x[j++] = a[i];
      }
    }
  } else if (k) {
    // has unique key field, so use that
    m = util.toMap(r, k);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }
    }
  } else {
    // no unique key, mark tuples directly
    for (i=0, n=r.length; i<n; ++i) {
      r[i][REM] = 1;
    }
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!a[i][REM]) { x[j++] = a[i]; }
    }
    for (i=0, n=r.length; i<n; ++i) {
      delete r[i][REM];
    }
  }

  this._rem = [];
  return (this._add = x);
};

// memoizing statistics methods

proto.extent = function(get) {
  if (this._get !== get || !this._ext) {
    var v = this.values(),
        i = stats.extent.index(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;    
  }
  return this._ext;
};

proto.argmin = function(get) {
  return this.extent(get)[0];
};

proto.argmax = function(get) {
  return this.extent(get)[1];
};

proto.min = function(get) {
  var m = this.extent(get)[0];
  return m ? get(m) : +Infinity;
};

proto.max = function(get) {
  var m = this.extent(get)[1];
  return m ? get(m) : -Infinity;
};

proto.quartile = function(get) {
  if (this._get !== get || !this._q) {
    this._q = stats.quartile(this.values(), get);
    this._get = get;    
  }
  return this._q;
};

proto.q1 = function(get) {
  return this.quartile(get)[0];
};

proto.q2 = function(get) {
  return this.quartile(get)[1];
};

proto.q3 = function(get) {
  return this.quartile(get)[2];
};

module.exports = Collector;

},{"../stats":51,"../util":54}],34:[function(require,module,exports){
var util = require('../util');
var Aggregator = require('./aggregator');

module.exports = function() {
  // flatten arguments into a single array
  var args = [].reduce.call(arguments, function(a, x) {
    return a.concat(util.array(x));
  }, []);
  // create and return an aggregator
  return new Aggregator()
    .groupby(args)
    .summarize({'*':'values'});
};

},{"../util":54,"./aggregator":32}],35:[function(require,module,exports){
var util = require('../util');

var types = {
  'values': measure({
    name: 'values',
    init: 'cell.collect = true;',
    set:  'cell.data.values()', idx: -1
  }),
  'count': measure({
    name: 'count',
    set:  'cell.num'
  }),
  'missing': measure({
    name: 'missing',
    set:  'this.missing'
  }),
  'valid': measure({
    name: 'valid',
    set:  'this.valid'
  }),
  'sum': measure({
    name: 'sum',
    init: 'this.sum = 0;',
    add:  'this.sum += v;',
    rem:  'this.sum -= v;',
    set:  'this.sum'
  }),
  'mean': measure({
    name: 'mean',
    init: 'this.mean = 0;',
    add:  'var d = v - this.mean; this.mean += d / this.valid;',
    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',
    set:  'this.mean'
  }),
  'average': measure({
    name: 'average',
    set:  'this.mean',
    req:  ['mean'], idx: 1
  }),
  'variance': measure({
    name: 'variance',
    init: 'this.dev = 0;',
    add:  'this.dev += d * (v - this.mean);',
    rem:  'this.dev -= d * (v - this.mean);',
    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',
    req:  ['mean'], idx: 1
  }),
  'variancep': measure({
    name: 'variancep',
    set:  'this.valid > 1 ? this.dev / this.valid : 0',
    req:  ['variance'], idx: 2
  }),
  'stdev': measure({
    name: 'stdev',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',
    req:  ['variance'], idx: 2
  }),
  'stdevp': measure({
    name: 'stdevp',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',
    req:  ['variance'], idx: 2
  }),
  'median': measure({
    name: 'median',
    set:  'cell.data.q2(this.get)',
    req:  ['values'], idx: 3
  }),
  'q1': measure({
    name: 'q1',
    set:  'cell.data.q1(this.get)',
    req:  ['values'], idx: 3
  }),
  'q3': measure({
    name: 'q3',
    set:  'cell.data.q3(this.get)',
    req:  ['values'], idx: 3
  }),
  'distinct': measure({
    name: 'distinct',
    set:  'this.distinct(cell.data.values(), this.get)',
    req:  ['values'], idx: 3
  }),
  'argmin': measure({
    name: 'argmin',
    add:  'if (v < this.min) this.argmin = t;',
    rem:  'if (v <= this.min) this.argmin = null;',
    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',
    req:  ['min'], str: ['values'], idx: 3
  }),
  'argmax': measure({
    name: 'argmax',
    add:  'if (v > this.max) this.argmax = t;',
    rem:  'if (v >= this.max) this.argmax = null;',
    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',
    req:  ['max'], str: ['values'], idx: 3
  }),
  'min': measure({
    name: 'min',
    init: 'this.min = +Infinity;',
    add:  'if (v < this.min) this.min = v;',
    rem:  'if (v <= this.min) this.min = NaN;',
    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',
    str:  ['values'], idx: 4
  }),
  'max': measure({
    name: 'max',
    init: 'this.max = -Infinity;',
    add:  'if (v > this.max) this.max = v;',
    rem:  'if (v >= this.max) this.max = NaN;',
    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',
    str:  ['values'], idx: 4
  }),
  'modeskew': measure({
    name: 'modeskew',
    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',
    req:  ['mean', 'stdev', 'median'], idx: 5
  })
};

function measure(base) {
  return function(out) {
    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);
    m.out = out || base.name;
    return m;
  };
}

function resolve(agg, stream) {
  function collect(m, a) {
    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }
    if (a.req) a.req.forEach(helper);
    if (stream && a.str) a.str.forEach(helper);
    return m;
  }
  var map = agg.reduce(
    collect,
    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})
  );
  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });
}

function create(agg, stream, accessor, mutator) {
  var all = resolve(agg, stream),
      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',
      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',
      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',
      set = 'var t = this.tuple; var cell = this.cell;';

  all.forEach(function(a) {
    if (a.idx < 0) {
      ctr = a.init + ctr;
      add = a.add + add;
      rem = a.rem + rem;
    } else {
      ctr += a.init;
      add += a.add;
      rem += a.rem;
    }
  });
  agg.slice()
    .sort(function(a, b) { return a.idx - b.idx; })
    .forEach(function(a) {
      set += 'this.assign(t,\''+a.out+'\','+a.set+');';
    });
  set += 'return t;';

  /* jshint evil: true */
  ctr = Function('cell', 't', ctr);
  ctr.prototype.assign = mutator;
  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);
  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);
  ctr.prototype.set = Function(set);
  ctr.prototype.get = accessor;
  ctr.prototype.distinct = require('../stats').count.distinct;
  ctr.prototype.isValid = util.isValid;
  ctr.fields = agg.map(util.$('out'));
  return ctr;
}

types.create = create;
module.exports = types;
},{"../stats":51,"../util":54}],36:[function(require,module,exports){
var util = require('../util'),
    time = require('../time'),
    EPSILON = 1e-15;

function bins(opt) {
  if (!opt) { throw Error("Missing binning options."); }

  // determine range
  var maxb = opt.maxbins || 15,
      base = opt.base || 10,
      logb = Math.log(base),
      div = opt.div || [5, 2],      
      min = opt.min,
      max = opt.max,
      span = max - min,
      step, level, minstep, precision, v, i, eps;

  if (opt.step) {
    // if step size is explicitly given, use that
    step = opt.step;
  } else if (opt.steps) {
    // if provided, limit choice to acceptable step sizes
    step = opt.steps[Math.min(
      opt.steps.length - 1,
      bisect(opt.steps, span/maxb, 0, opt.steps.length)
    )];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = opt.minstep || 0;
    step = Math.max(
      minstep,
      Math.pow(base, Math.round(Math.log(span) / logb) - level)
    );
    
    // increase step size if too many bins
    do { step *= base; } while (Math.ceil(span/step) > maxb);

    // decrease step size if allowed
    for (i=0; i<div.length; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  }

  // update precision, min and max
  v = Math.log(step);
  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;
  eps = Math.pow(base, -precision - 1);
  min = Math.min(min, Math.floor(min / step + eps) * step);
  max = Math.ceil(max / step) * step;

  return {
    start: min,
    stop:  max,
    step:  step,
    unit:  {precision: precision},
    value: value,
    index: index
  };
}

function bisect(a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
}

function value(v) {
  return this.step * Math.floor(v / this.step + EPSILON);
}

function index(v) {
  return Math.floor((v - this.start) / this.step + EPSILON);
}

function date_value(v) {
  return this.unit.date(value.call(this, v));
}

function date_index(v) {
  return index.call(this, this.unit.unit(v));
}

bins.date = function(opt) {
  if (!opt) { throw Error("Missing date binning options."); }

  // find time step, then bin
  var units = opt.utc ? time.utc : time,
      dmin = opt.min,
      dmax = opt.max,
      maxb = opt.maxbins || 20,
      minb = opt.minbins || 4,
      span = (+dmax) - (+dmin),
      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),
      spec = bins({
        min:     unit.min != null ? unit.min : unit.unit(dmin),
        max:     unit.max != null ? unit.max : unit.unit(dmax),
        maxbins: maxb,
        minstep: unit.minstep,
        steps:   unit.step
      });

  spec.unit = unit;
  spec.index = date_index;
  if (!opt.raw) spec.value = date_value;
  return spec;
};

module.exports = bins;

},{"../time":53,"../util":54}],37:[function(require,module,exports){
var bins = require('./bins'),
    gen  = require('../generate'),
    type = require('../import/type'),
    util = require('../util'),
    stats = require('../stats');

var qtype = {
  'integer': 1,
  'number': 1,
  'date': 1
};

function $bin(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return !b ? (opt.accessor || util.identity) :
    util.$func('bin', b.unit.unit ?
      function(x) { return b.value(b.unit.unit(x)); } :
      function(x) { return b.value(x); }
    )(opt.accessor);
}

function histogram(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return b ?
    numerical(values, opt.accessor, b) :
    categorical(values, opt.accessor, opt && opt.sort);
}

function spec(opt) {
  var t = opt.type, b = null;
  if (t == null || qtype[t]) {
    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;
    b = (t === 'date') ? bins.date(opt) : bins(opt);
  }
  return b;
}

function options() {
  var a = arguments,
      i = 0,
      values = util.isArray(a[i]) ? a[i++] : null,
      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,
      opt = util.extend({}, a[i]);
  
  if (values) {
    opt.type = opt.type || type(values, f);
    if (qtype[opt.type]) {
      var ext = stats.extent(values, f);
      opt = util.extend({min: ext[0], max: ext[1]}, opt);
    }
  }
  if (f) { opt.accessor = f; }
  return opt;
}

function numerical(values, f, b) {
  var h = gen.range(b.start, b.stop + b.step/2, b.step)
    .map(function(v) { return {value: b.value(v), count: 0}; });

  for (var i=0, v, j; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      j = b.index(v);
      if (j < 0 || j >= h.length || !isFinite(j)) continue;
      h[j].count += 1;
    }
  }
  h.bins = b;
  return h;
}

function categorical(values, f, sort) {
  var u = stats.unique(values, f),
      c = stats.count.map(values, f);
  return u.map(function(k) { return {value: k, count: c[k]}; })
    .sort(util.comparator(sort ? '-count' : '+value'));
}

module.exports = {
  $bin: $bin,
  histogram: histogram
};
},{"../generate":39,"../import/type":48,"../stats":51,"../util":54,"./bins":36}],38:[function(require,module,exports){
var d3_time = require('d3-time'),
    d3_timeF = require('d3-time-format'),
    d3_numberF = require('d3-format'),
    numberF = d3_numberF, // defaults to EN-US
    timeF = d3_timeF;     // defaults to EN-US

function numberLocale(l) {
  var f = d3_numberF.localeFormat(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  numberF = f;
}

function timeLocale(l) {
  var f = d3_timeF.localeFormat(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  timeF = f;
}

module.exports = {
  // Update number formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-format
  numberLocale: numberLocale,
  number:       function(f) { return numberF.format(f); },
  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },

  // Update time formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-time-format
  timeLocale:   timeLocale,
  time:         function(f) { return timeF.format(f); },  
  utc:          function(f) { return timeF.utcFormat(f); },

  // Set number and time locale simultaneously.
  locale:       function(l) { numberLocale(l); timeLocale(l); },

  // automatic formatting functions
  auto: {
    number:   numberAutoFormat,
    time:     function() { return timeAutoFormat(); },
    utc:      function() { return utcAutoFormat(); }
  }
};

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function intervals(domain, count) {
  if (!domain.length) domain = [0];
  if (count == null) count = 10;

  var start = domain[0],
      stop = domain[domain.length - 1];

  if (stop < start) { error = stop; stop = start; start = error; }

  var span = (stop - start) || (count = 1, start || stop || 1),
      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),
      error = span / count / step;

  // Filter ticks to get closer to the desired count.
  if (error >= e10) step *= 10;
  else if (error >= e5) step *= 5;
  else if (error >= e2) step *= 2;

  // Round start and stop values to step interval.
  return [
    Math.ceil(start / step) * step,
    Math.floor(stop / step) * step + step / 2, // inclusive
    step
  ];
}

function numberAutoFormat(domain, count, f) {
  var range = intervals(domain, count);
  if (f == null) {
    f = ',.' + d3_numberF.precisionFixed(range[2]) + 'f';
  } else {
    switch (f = d3_numberF.formatSpecifier(f), f.type) {
      case 's': {
        var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));
        if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);
        return numberF.formatPrefix(f, value);
      }
      case '':
      case 'e':
      case 'g':
      case 'p':
      case 'r': {
        if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');
        break;
      }
      case 'f':
      case '%': {
        if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - (f.type === '%') * 2;
        break;
      }
    }
  }
  return numberF.format(f);
}

function timeAutoFormat() {
  var f = timeF.format,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.second(date) < d ? formatMillisecond
        : d3_time.minute(date) < d ? formatSecond
        : d3_time.hour(date) < d ? formatMinute
        : d3_time.day(date) < d ? formatHour
        : d3_time.month(date) < d ?
          (d3_time.week(date) < d ? formatDay : formatWeek)
        : d3_time.year(date) < d ? formatMonth
        : formatYear)(date);
  };
}

function utcAutoFormat() {
  var f = timeF.utcFormat,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.utcSecond(date) < d ? formatMillisecond
        : d3_time.utcMinute(date) < d ? formatSecond
        : d3_time.utcHour(date) < d ? formatMinute
        : d3_time.utcDay(date) < d ? formatHour
        : d3_time.utcMonth(date) < d ?
          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)
        : d3_time.utcYear(date) < d ? formatMonth
        : formatYear)(date);
  };
}

},{"d3-format":29,"d3-time":31,"d3-time-format":30}],39:[function(require,module,exports){
var gen = module.exports = {};

gen.repeat = function(val, n) {
  var a = Array(n), i;
  for (i=0; i<n; ++i) a[i] = val;
  return a;
};

gen.zeros = function(n) {
  return gen.repeat(0, n);
};

gen.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step == Infinity) throw new Error('Infinite range');
  var range = [], i = -1, j;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
  else while ((j = start + step * ++i) < stop) range.push(j);
  return range;
};

gen.random = {};

gen.random.uniform = function(min, max) {
  if (max === undefined) {
    max = min === undefined ? 1 : min;
    min = 0;
  }
  var d = max - min;
  var f = function() {
    return min + d * Math.random();
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};

gen.random.integer = function(a, b) {
  if (b === undefined) {
    b = a;
    a = 0;
  }
  var d = b - a;
  var f = function() {
    return a + Math.floor(d * Math.random());
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};

gen.random.normal = function(mean, stdev) {
  mean = mean || 0;
  stdev = stdev || 1;
  var next;
  var f = function() {
    var x = 0, y = 0, rds, c;
    if (next !== undefined) {
      x = next;
      next = undefined;
      return x;
    }
    do {
      x = Math.random()*2-1;
      y = Math.random()*2-1;
      rds = x*x + y*y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
    next = mean + y*c*stdev;
    return mean + x*c*stdev;
  };
  f.samples = function(n) { return gen.zeros(n).map(f); };
  return f;
};
},{}],40:[function(require,module,exports){
var util = require('../../util');
var d3_dsv = require('d3-dsv');

function dsv(data, format) {
  if (data) {
    var h = format.header;
    data = (h ? h.join(format.delimiter) + '\n' : '') + data;
  }
  return d3_dsv.dsv(format.delimiter).parse(data);
}

dsv.delimiter = function(delim) {
  var fmt = {delimiter: delim};
  return function(data, format) {
    return dsv(data, format ? util.extend(format, fmt) : fmt);
  };
};

module.exports = dsv;
},{"../../util":54,"d3-dsv":28}],41:[function(require,module,exports){
var dsv = require('./dsv');

module.exports = {
  json: require('./json'),
  topojson: require('./topojson'),
  treejson: require('./treejson'),
  dsv: dsv,
  csv: dsv.delimiter(','),
  tsv: dsv.delimiter('\t')
};
},{"./dsv":40,"./json":42,"./topojson":43,"./treejson":44}],42:[function(require,module,exports){
var util = require('../../util');

module.exports = function(data, format) {
  var d = util.isObject(data) && !util.isBuffer(data) ?
    data : JSON.parse(data);
  if (format && format.property) {
    d = util.accessor(format.property)(d);
  }
  return d;
};

},{"../../util":54}],43:[function(require,module,exports){
(function (global){
var json = require('./json');

var reader = function(data, format) {
  var topojson = reader.topojson;
  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }

  var t = json(data, format), obj;

  if (format && format.feature) {
    if ((obj = t.objects[format.feature])) {
      return topojson.feature(t, obj).features;
    } else {
      throw Error('Invalid TopoJSON object: ' + format.feature);
    }
  } else if (format && format.mesh) {
    if ((obj = t.objects[format.mesh])) {
      return [topojson.mesh(t, t.objects[format.mesh])];
    } else {
      throw Error('Invalid TopoJSON object: ' + format.mesh);
    }
  } else {
    throw Error('Missing TopoJSON feature or mesh parameter.');
  }
};

reader.topojson = (typeof window !== "undefined" ? window['topojson'] : typeof global !== "undefined" ? global['topojson'] : null);
module.exports = reader;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./json":42}],44:[function(require,module,exports){
var json = require('./json');

module.exports = function(data, format) {
  data = json(data, format);
  return toTable(data, (format && format.children));
};

function toTable(root, childrenField) {
  childrenField = childrenField || 'children';
  var table = [];
  
  function visit(node) {
    table.push(node);
    var children = node[childrenField];
    if (children) {
      for (var i=0; i<children.length; ++i) {
        visit(children[i], node);
      }
    }
  }
  
  visit(root, null);
  return (table.root = root, table);
}
},{"./json":42}],45:[function(require,module,exports){
// Matches absolute URLs with optional protocol
//   https://...    file://...    //...
var protocol_re = /^([A-Za-z]+:)?\/\//;

// Special treatment in node.js for the file: protocol
var fileProtocol = 'file://';

// Validate and cleanup URL to ensure that it is allowed to be accessed
// Returns cleaned up URL, or false if access is not allowed
function sanitizeUrl(opt) {
  var url = opt.url;
  if (!url && opt.file) { return fileProtocol + opt.file; }

  // In case this is a relative url (has no host), prepend opt.baseURL
  if (opt.baseURL && !protocol_re.test(url)) {
    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {
      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    }
    url = opt.baseURL + url;
  }
  // relative protocol, starts with '//'
  if (!load.useXHR && startsWith(url, '//')) {
    url = (opt.defaultProtocol || 'http') + ':' + url;
  }
  // If opt.domainWhiteList is set, only allows url, whose hostname
  // * Is the same as the origin (window.location.hostname)
  // * Equals one of the values in the whitelist
  // * Is a proper subdomain of one of the values in the whitelist
  if (opt.domainWhiteList) {
    var domain, origin;
    if (load.useXHR) {
      var a = document.createElement('a');
      a.href = url;
      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
      // IE doesn't populate all link properties when setting .href with a relative URL,
      // however .href will return an absolute URL which then can be used on itself
      // to populate these additional fields.
      if (a.host === '') {
        a.href = a.href;
      }
      domain = a.hostname.toLowerCase();
      origin = window.location.hostname;
    } else {
      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5
      var parts = require('url').parse(url);
      domain = parts.hostname;
      origin = null;
    }

    if (origin !== domain) {
      var whiteListed = opt.domainWhiteList.some(function(d) {
        var idx = domain.length - d.length;
        return d === domain ||
          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);
      });
      if (!whiteListed) {
        throw 'URL is not whitelisted: ' + url;
      }
    }
  }
  return url;
}

function load(opt, callback) {
  var error = callback || function(e) { throw e; }, url;

  try {
    url = load.sanitizeUrl(opt); // enable override
  } catch (err) {
    error(err);
    return;
  }

  if (!url) {
    error('Invalid URL: ' + opt.url);
  } else if (load.useXHR) {
    // on client, use xhr
    return xhr(url, callback);
  } else if (startsWith(url, fileProtocol)) {
    // on server, if url starts with 'file://', strip it and load from file
    return file(url.slice(fileProtocol.length), callback);
  } else if (url.indexOf('://') < 0) { // TODO better protocol check?
    // on server, if no protocol assume file
    return file(url, callback);
  } else {
    // for regular URLs on server
    return http(url, callback);
  }
}

function xhrHasResponse(request) {
  var type = request.responseType;
  return type && type !== 'text' ?
    request.response : // null on error
    request.responseText; // '' on error
}

function xhr(url, callback) {
  var async = !!callback;
  var request = new XMLHttpRequest();
  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)
  if (this.XDomainRequest &&
      !('withCredentials' in request) &&
      /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();

  function respond() {
    var status = request.status;
    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
      callback(null, request.responseText);
    } else {
      callback(request, null);
    }
  }

  if (async) {
    if ('onload' in request) {
      request.onload = request.onerror = respond;
    } else {
      request.onreadystatechange = function() {
        if (request.readyState > 3) respond();
      };
    }
  }
  
  request.open('GET', url, async);
  request.send();
  
  if (!async && xhrHasResponse(request)) {
    return request.responseText;
  }
}

function file(filename, callback) {
  var fs = require('fs');
  if (!callback) {
    return fs.readFileSync(filename, 'utf8');
  }
  fs.readFile(filename, callback);
}

function http(url, callback) {
  if (!callback) {
    return require('sync-request')('GET', url).getBody();
  }
  
  var options = {url: url, encoding: null, gzip: true};
  require('request')(options, function(error, response, body) {
    if (!error && response.statusCode === 200) {
      callback(null, body);
    } else {
      error = error ||
        'Load failed with response code ' + response.statusCode + '.';
      callback(error, null);
    }
  });
}

function startsWith(string, searchString) {
  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;
}

load.sanitizeUrl = sanitizeUrl;

load.useXHR = (typeof XMLHttpRequest !== 'undefined');

module.exports = load;

},{"fs":4,"request":4,"sync-request":4,"url":4}],46:[function(require,module,exports){
var util = require('../util');
var type = require('./type');
var formats = require('./formats');

function read(data, format) {
  var type = (format && format.type) || 'json';
  data = formats[type](data, format);
  if (format && format.parse) parse(data, format.parse);
  return data;
}

function parse(data, types) {
  var cols, parsers, d, i, j, clen, len = data.length;

  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);
  cols = util.keys(types);
  parsers = cols.map(function(c) { return type.parsers[types[c]]; });

  for (i=0, clen=cols.length; i<len; ++i) {
    d = data[i];
    for (j=0; j<clen; ++j) {
      d[cols[j]] = parsers[j](d[cols[j]]);
    }
  }
  type.annotation(data, types);
}

read.formats = formats;
module.exports = read;

},{"../util":54,"./formats":41,"./type":48}],47:[function(require,module,exports){
var util = require('../util');
var load = require('./load');
var read = require('./read');

module.exports = util
  .keys(read.formats)
  .reduce(function(out, type) {
    out[type] = function(opt, format, callback) {
      // process arguments
      if (util.isString(opt)) { opt = {url: opt}; }
      if (arguments.length === 2 && util.isFunction(format)) {
        callback = format;
        format = undefined;
      }

      // set up read format
      format = util.extend({parse: 'auto'}, format);
      format.type = type;

      // load data
      var data = load(opt, callback ? function(error, data) {
        if (error) { callback(error, null); return; }
        try {
          // data loaded, now parse it (async)
          data = read(data, format);
          callback(null, data);
        } catch (e) {
          callback(e, null);
        }
      } : undefined);
      
      // data loaded, now parse it (sync)
      if (!callback) return read(data, format);
    };
    return out;
  }, {});

},{"../util":54,"./load":45,"./read":46}],48:[function(require,module,exports){
var util = require('../util');

var TYPES = '__types__';

var PARSERS = {
  boolean: util.boolean,
  integer: util.number,
  number:  util.number,
  date:    util.date,
  string:  function(x) { return x==='' ? null : x; }
};

var TESTS = {
  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },
  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },
  number: function(x) { return !isNaN(+x) && !util.isDate(x); },
  date: function(x) { return !isNaN(Date.parse(x)); }
};

function annotation(data, types) {
  if (!types) return data && data[TYPES] || null;
  data[TYPES] = types;
}

function type(values, f) {
  f = util.$(f);
  var v, i, n;

  // if data array has type annotations, use them
  if (values[TYPES]) {
    v = f(values[TYPES]);
    if (util.isString(v)) return v;
  }

  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {
    v = f ? f(values[i]) : values[i];
  }

  return util.isDate(v) ? 'date' :
    util.isNumber(v)    ? 'number' :
    util.isBoolean(v)   ? 'boolean' :
    util.isString(v)    ? 'string' : null;
}

function typeAll(data, fields) {
  if (!data.length) return;
  fields = fields || util.keys(data[0]);
  return fields.reduce(function(types, f) {
    return (types[f] = type(data, f), types);
  }, {});
}

function infer(values, f) {
  f = util.$(f);
  var i, j, v;

  // types to test for, in precedence order
  var types = ['boolean', 'integer', 'number', 'date'];

  for (i=0; i<values.length; ++i) {
    // get next value to test
    v = f ? f(values[i]) : values[i];
    // test value against remaining types
    for (j=0; j<types.length; ++j) {
      if (util.isValid(v) && !TESTS[types[j]](v)) {
        types.splice(j, 1);
        j -= 1;
      }
    }
    // if no types left, return 'string'
    if (types.length === 0) return 'string';
  }

  return types[0];
}

function inferAll(data, fields) {
  fields = fields || util.keys(data[0]);
  return fields.reduce(function(types, f) {
    types[f] = infer(data, f);
    return types;
  }, {});
}

type.annotation = annotation;
type.all = typeAll;
type.infer = infer;
type.inferAll = inferAll;
type.parsers = PARSERS;
module.exports = type;
},{"../util":54}],49:[function(require,module,exports){
var util = require('./util');

var dl = {
  version:    '1.4.6',
  load:       require('./import/load'),
  read:       require('./import/read'),
  type:       require('./import/type'),
  Aggregator: require('./aggregate/aggregator'),
  groupby:    require('./aggregate/groupby'),
  bins:       require('./bins/bins'),
  $bin:       require('./bins/histogram').$bin,
  histogram:  require('./bins/histogram').histogram,
  format:     require('./format'),
  print:      require('./print'),
  template:   require('./template'),
  time:       require('./time')
};

util.extend(dl, util);
util.extend(dl, require('./generate'));
util.extend(dl, require('./stats'));
util.extend(dl, require('./import/readers'));

module.exports = dl;
},{"./aggregate/aggregator":32,"./aggregate/groupby":34,"./bins/bins":36,"./bins/histogram":37,"./format":38,"./generate":39,"./import/load":45,"./import/read":46,"./import/readers":47,"./import/type":48,"./print":50,"./stats":51,"./template":52,"./time":53,"./util":54}],50:[function(require,module,exports){
var util = require('./util');
var type = require('./import/type');
var stats = require('./stats');
var template = require('./template');

var FMT = {
  'date':    '|time:"%m/%d/%Y %H:%M:%S"',
  'number':  '|number:".4f"',
  'integer': '|number:"d"'
};

var POS = {
  'number':  'left',
  'integer': 'left'
};

module.exports.table = function(data, opt) {
  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);
  var fields = opt.fields || util.keys(data[0]),
      types = type.all(data);

  if (opt.start || opt.limit) {
    var a = opt.start || 0,
        b = opt.limit ? a + opt.limit : data.length;
    data = data.slice(a, b);
  }

  // determine char width of fields
  var lens = fields.map(function(name) {
    var format = FMT[types[name]] || '',
        t = template('{{' + name + format + '}}'),
        l = stats.max(data, function(x) { return t(x).length; });
    l = Math.max(Math.min(name.length, opt.minwidth), l);
    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;
  });

  // print header row
  var head = fields.map(function(name, i) {
    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);
  }).join(opt.separator);

  // build template function for each row
  var tmpl = template(fields.map(function(name, i) {
    return '{{' +
      name +
      (FMT[types[name]] || '') +
      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +
      ('|truncate:' + lens[i]) +
    '}}';
  }).join(opt.separator));

  // print table
  return head + "\n" + data.map(tmpl).join('\n');
};

module.exports.summary = function(s) {
  s = s ? s.__summary__ ? s : stats.summary(s) : this;
  var str = [], i, n;
  for (i=0, n=s.length; i<n; ++i) {
    str.push('-- ' + s[i].field + ' --');
    if (s[i].type === 'string' || s[i].distinct < 10) {
      str.push(printCategoricalProfile(s[i]));
    } else {
      str.push(printQuantitativeProfile(s[i]));
    }
    str.push('');
  }
  return str.join('\n');
};

function printQuantitativeProfile(p) {
  return [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'min:      ' + p.min,
    'max:      ' + p.max,
    'median:   ' + p.median,
    'mean:     ' + p.mean,
    'stdev:    ' + p.stdev,
    'modeskew: ' + p.modeskew
  ].join('\n');
}

function printCategoricalProfile(p) {
  var list = [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'top values: '
  ];
  var u = p.unique;
  var top = util.keys(u)
    .sort(function(a,b) { return u[b] - u[a]; })
    .slice(0, 6)
    .map(function(v) { return ' \'' + v + '\' (' + u[v] + ')'; });
  return list.concat(top).join('\n');
}
},{"./import/type":48,"./stats":51,"./template":52,"./util":54}],51:[function(require,module,exports){
var util = require('./util');
var type = require('./import/type');
var gen = require('./generate');
var stats = {};

// Collect unique values.
// Output: an array of unique values, in first-observed order
stats.unique = function(values, f, results) {
  f = util.$(f);
  results = results || [];
  var u = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    results.push(v);
  }
  return results;
};

// Return the length of the input array.
stats.count = function(values) {
  return values && values.length || 0;
};

// Count the number of non-null, non-undefined, non-NaN values.
stats.count.valid = function(values, f) {
  f = util.$(f);
  var v, i, n, valid = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) valid += 1;
  }
  return valid;
};

// Count the number of null or undefined values.
stats.count.missing = function(values, f) {
  f = util.$(f);
  var v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v == null) count += 1;
  }
  return count;
};

// Count the number of distinct values.
// Null, undefined and NaN are each considered distinct values.
stats.count.distinct = function(values, f) {
  f = util.$(f);
  var u = {}, v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    count += 1;
  }
  return count;
};

// Construct a map from distinct values to occurrence counts.
stats.count.map = function(values, f) {
  f = util.$(f);
  var map = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    map[v] = (v in map) ? map[v] + 1 : 1;
  }
  return map;
};

// Compute the median of an array of numbers.
stats.median = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  return stats.quantile(values, 0.5);
};

// Computes the quartile boundaries of an array of numbers.
stats.quartile = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  var q = stats.quantile;
  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
};

// Compute the quantile of a sorted array of numbers.
// Adapted from the D3.js implementation.
stats.quantile = function(values, f, p) {
  if (p === undefined) { p = f; f = util.identity; }
  f = util.$(f);
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = +f(values[h - 1]),
      e = H - h;
  return e ? v + e * (f(values[h]) - v) : v;
};

// Compute the sum of an array of numbers.
stats.sum = function(values, f) {
  f = util.$(f);
  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) sum += v;
  }
  return sum;
};

// Compute the mean (average) of an array of numbers.
stats.mean = function(values, f) {
  f = util.$(f);
  var mean = 0, delta, i, n, c, v;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
    }
  }
  return mean;
};

// Compute the sample variance of an array of numbers.
stats.variance = function(values, f) {
  f = util.$(f);
  if (!util.isArray(values) || values.length < 2) return 0;
  var mean = 0, M2 = 0, delta, i, c, v;
  for (i=0, c=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
      M2 = M2 + delta * (v - mean);
    }
  }
  M2 = M2 / (c - 1);
  return M2;
};

// Compute the sample standard deviation of an array of numbers.
stats.stdev = function(values, f) {
  return Math.sqrt(stats.variance(values, f));
};

// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
stats.modeskew = function(values, f) {
  var avg = stats.mean(values, f),
      med = stats.median(values, f),
      std = stats.stdev(values, f);
  return std === 0 ? 0 : (avg - med) / std;
};

// Find the minimum value in an array.
stats.min = function(values, f) {
  return stats.extent(values, f)[0];
};

// Find the maximum value in an array.
stats.max = function(values, f) {
  return stats.extent(values, f)[1];
};

// Find the minimum and maximum of an array of values.
stats.extent = function(values, f) {
  f = util.$(f);
  var a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) a = v;
      if (v > b) b = v;
    }
  }
  return [a, b];
};

// Find the integer indices of the minimum and maximum values.
stats.extent.index = function(values, f) {
  f = util.$(f);
  var x = -1, y = -1, a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; x = y = i; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) { a = v; x = i; }
      if (v > b) { b = v; y = i; }
    }
  }
  return [x, y];
};

// Compute the dot product of two arrays of numbers.
stats.dot = function(values, a, b) {
  var sum = 0, i, v;
  if (!b) {
    if (values.length !== a.length) {
      throw Error('Array lengths must match.');
    }
    for (i=0; i<values.length; ++i) {
      v = values[i] * a[i];
      if (v === v) sum += v;
    }
  } else {
    a = util.$(a);
    b = util.$(b);
    for (i=0; i<values.length; ++i) {
      v = a(values[i]) * b(values[i]);
      if (v === v) sum += v;
    }
  }
  return sum;
};

// Compute ascending rank scores for an array of values.
// Ties are assigned their collective mean rank.
stats.rank = function(values, f) {
  f = util.$(f) || util.identity;
  var a = values.map(function(v, i) {
      return {idx: i, val: f(v)};
    })
    .sort(util.comparator('val'));

  var n = values.length,
      r = Array(n),
      tie = -1, p = {}, i, v, mu;

  for (i=0; i<n; ++i) {
    v = a[i].val;
    if (tie < 0 && p === v) {
      tie = i - 1;
    } else if (tie > -1 && p !== v) {
      mu = 1 + (i-1 + tie) / 2;
      for (; tie<i; ++tie) r[a[tie].idx] = mu;
      tie = -1;
    }
    r[a[i].idx] = i + 1;
    p = v;
  }

  if (tie > -1) {
    mu = 1 + (n-1 + tie) / 2;
    for (; tie<n; ++tie) r[a[tie].idx] = mu;
  }

  return r;
};

// Compute the sample Pearson product-moment correlation of two arrays of numbers.
stats.cor = function(values, a, b) {
  var fn = b;
  b = fn ? values.map(util.$(b)) : a;
  a = fn ? values.map(util.$(a)) : values;

  var dot = stats.dot(a, b),
      mua = stats.mean(a),
      mub = stats.mean(b),
      sda = stats.stdev(a),
      sdb = stats.stdev(b),
      n = values.length;

  return (dot - n*mua*mub) / ((n-1) * sda * sdb);
};

// Compute the Spearman rank correlation of two arrays of values.
stats.cor.rank = function(values, a, b) {
  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),
      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),
      n = values.length, i, s, d;

  for (i=0, s=0; i<n; ++i) {
    d = ra[i] - rb[i];
    s += d * d;
  }

  return 1 - 6*s / (n * (n*n-1));
};

// Compute the distance correlation of two arrays of numbers.
// http://en.wikipedia.org/wiki/Distance_correlation
stats.cor.dist = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a;

  var A = stats.dist.mat(X),
      B = stats.dist.mat(Y),
      n = A.length,
      i, aa, bb, ab;

  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
    aa += A[i]*A[i];
    bb += B[i]*B[i];
    ab += A[i]*B[i];
  }

  return Math.sqrt(ab / Math.sqrt(aa*bb));
};

// Compute the vector distance between two arrays of numbers.
// Default is Euclidean (exp=2) distance, configurable via exp argument.
stats.dist = function(values, a, b, exp) {
  var f = util.isFunction(b) || util.isString(b),
      X = values,
      Y = f ? values : a,
      e = f ? exp : b,
      L2 = e === 2 || e == null,
      n = values.length, s = 0, d, i;
  if (f) {
    a = util.$(a);
    b = util.$(b);
  }
  for (i=0; i<n; ++i) {
    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
    s += L2 ? d*d : Math.pow(Math.abs(d), e);
  }
  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
};

// Construct a mean-centered distance matrix for an array of numbers.
stats.dist.mat = function(X) {
  var n = X.length,
      m = n*n,
      A = Array(m),
      R = gen.zeros(n),
      M = 0, v, i, j;

  for (i=0; i<n; ++i) {
    A[i*n+i] = 0;
    for (j=i+1; j<n; ++j) {
      A[i*n+j] = (v = Math.abs(X[i] - X[j]));
      A[j*n+i] = v;
      R[i] += v;
      R[j] += v;
    }
  }

  for (i=0; i<n; ++i) {
    M += R[i];
    R[i] /= n;
  }
  M /= m;

  for (i=0; i<n; ++i) {
    for (j=i; j<n; ++j) {
      A[i*n+j] += M - R[i] - R[j];
      A[j*n+i] = A[i*n+j];
    }
  }

  return A;
};

// Compute the Shannon entropy (log base 2) of an array of counts.
stats.entropy = function(counts, f) {
  f = util.$(f);
  var i, p, s = 0, H = 0, n = counts.length;
  for (i=0; i<n; ++i) {
    s += (f ? f(counts[i]) : counts[i]);
  }
  if (s === 0) return 0;
  for (i=0; i<n; ++i) {
    p = (f ? f(counts[i]) : counts[i]) / s;
    if (p) H += p * Math.log(p);
  }
  return -H / Math.LN2;
};

// Compute the mutual information between two discrete variables.
// Returns an array of the form [MI, MI_distance] 
// MI_distance is defined as 1 - I(a,b) / H(a,b).
// http://en.wikipedia.org/wiki/Mutual_information
stats.mutual = function(values, a, b, counts) {
  var x = counts ? values.map(util.$(a)) : values,
      y = counts ? values.map(util.$(b)) : a,
      z = counts ? values.map(util.$(counts)) : b;

  var px = {},
      py = {},
      n = z.length,
      s = 0, I = 0, H = 0, p, t, i;

  for (i=0; i<n; ++i) {
    px[x[i]] = 0;
    py[y[i]] = 0;
  }

  for (i=0; i<n; ++i) {
    px[x[i]] += z[i];
    py[y[i]] += z[i];
    s += z[i];
  }

  t = 1 / (s * Math.LN2);
  for (i=0; i<n; ++i) {
    if (z[i] === 0) continue;
    p = (s * z[i]) / (px[x[i]] * py[y[i]]);
    I += z[i] * t * Math.log(p);
    H += z[i] * t * Math.log(z[i]/s);
  }

  return [I, 1 + I/H];
};

// Compute the mutual information between two discrete variables.
stats.mutual.info = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[0];
};

// Compute the mutual information distance between two discrete variables.
// MI_distance is defined as 1 - I(a,b) / H(a,b).
stats.mutual.dist = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[1];
};

// Compute a profile of summary statistics for a variable.
stats.profile = function(values, f) {
  var mean = 0,
      valid = 0,
      missing = 0,
      distinct = 0,
      min = null,
      max = null,
      M2 = 0,
      vals = [],
      u = {}, delta, sd, i, v, x;

  // compute summary stats
  for (i=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];

    // update unique values
    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);

    if (v == null) {
      ++missing;
    } else if (util.isValid(v)) {
      // update stats
      x = (typeof v === 'string') ? v.length : v;
      if (min===null || x < min) min = x;
      if (max===null || x > max) max = x;
      delta = x - mean;
      mean = mean + delta / (++valid);
      M2 = M2 + delta * (x - mean);
      vals.push(x);
    }
  }
  M2 = M2 / (valid - 1);
  sd = Math.sqrt(M2);

  // sort values for median and iqr
  vals.sort(util.cmp);

  return {
    type:     type(values, f),
    unique:   u,
    count:    values.length,
    valid:    valid,
    missing:  missing,
    distinct: distinct,
    min:      min,
    max:      max,
    mean:     mean,
    stdev:    sd,
    median:   (v = stats.quantile(vals, 0.5)),
    q1:       stats.quantile(vals, 0.25),
    q3:       stats.quantile(vals, 0.75),
    modeskew: sd === 0 ? 0 : (mean - v) / sd
  };
};

// Compute profiles for all variables in a data set.
stats.summary = function(data, fields) {
  fields = fields || util.keys(data[0]);
  var s = fields.map(function(f) {
    var p = stats.profile(data, util.$(f));
    return (p.field = f, p);
  });
  return (s.__summary__ = true, s);
};

module.exports = stats;
},{"./generate":39,"./import/type":48,"./util":54}],52:[function(require,module,exports){
var util = require('./util'),
    format = require('./format');

var context = {
  formats:    [],
  format_map: {},
  truncate:   util.truncate,
  pad:        util.pad
};

function template(text) {
  var src = source(text, 'd');
  src = 'var __t; return ' + src + ';';

  /* jshint evil: true */
  return (new Function('d', src)).bind(context);
}

template.source = source;
template.context = context;
module.exports = template;

// Clear cache of format objects.
// This can *break* prior template functions, so invoke with care!
template.clearFormatCache = function() {
  context.formats = [];
  context.format_map = {};
};

// Generate property access code for use within template source.
// object: the name of the object (variable) containing template data
// property: the property access string, verbatim from template tag
template.property = function(object, property) {
  var src = util.field(property).map(util.str).join('][');
  return object + '[' + src + ']';
};

// Generate source code for a template function.
// text: the template text
// variable: the name of the data object variable ('obj' by default)
// properties: optional hash for collecting all accessed properties
function source(text, variable, properties) {
  variable = variable || 'obj';
  var index = 0;
  var src = '\'';
  var regex = template_re;

  // Compile the template source, escaping string literals appropriately.
  text.replace(regex, function(match, interpolate, offset) {
    src += text
      .slice(index, offset)
      .replace(template_escaper, template_escapeChar);
    index = offset + match.length;

    if (interpolate) {
      src += '\'\n+((__t=(' +
        template_var(interpolate, variable, properties) +
        '))==null?\'\':__t)+\n\'';
    }

    // Adobe VMs need the match returned to produce the correct offest.
    return match;
  });
  return src + '\'';
}

function template_var(text, variable, properties) {
  var filters = text.match(filter_re);
  var prop = filters.shift().trim();
  var stringCast = true;

  function strcall(fn) {
    fn = fn || '';
    if (stringCast) {
      stringCast = false;
      src = 'String(' + src + ')' + fn;
    } else {
      src += fn;
    }
    return src;
  }

  function date() {
    return '(typeof ' + src + '==="number"?new Date('+src+'):'+src+')';
  }

  function number_format(fmt, key) {
    a = template_format(args[0], key, fmt);
    stringCast = false;
    src = 'this.formats['+a+']('+src+')';
  }
  
  function time_format(fmt, key) {
    a = template_format(args[0], key, fmt);
    stringCast = false;
    src = 'this.formats['+a+']('+date()+')';
  }

  if (properties) properties[prop] = 1;
  var src = template.property(variable, prop);

  for (var i=0; i<filters.length; ++i) {
    var f = filters[i], args = null, pidx, a, b;

    if ((pidx=f.indexOf(':')) > 0) {
      f = f.slice(0, pidx);
      args = filters[i].slice(pidx+1)
        .match(args_re)
        .map(function(s) { return s.trim(); });
    }
    f = f.trim();

    switch (f) {
      case 'length':
        strcall('.length');
        break;
      case 'lower':
        strcall('.toLowerCase()');
        break;
      case 'upper':
        strcall('.toUpperCase()');
        break;
      case 'lower-locale':
        strcall('.toLocaleLowerCase()');
        break;
      case 'upper-locale':
        strcall('.toLocaleUpperCase()');
        break;
      case 'trim':
        strcall('.trim()');
        break;
      case 'left':
        a = util.number(args[0]);
        strcall('.slice(0,' + a + ')');
        break;
      case 'right':
        a = util.number(args[0]);
        strcall('.slice(-' + a +')');
        break;
      case 'mid':
        a = util.number(args[0]);
        b = a + util.number(args[1]);
        strcall('.slice(+'+a+','+b+')');
        break;
      case 'slice':
        a = util.number(args[0]);
        strcall('.slice('+ a +
          (args.length > 1 ? ',' + util.number(args[1]) : '') +
          ')');
        break;
      case 'truncate':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.truncate(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'pad':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.pad(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'number':
        number_format(format.number, 'number');
        break;
      case 'time':
        time_format(format.time, 'time');
        break;
      case 'time-utc':
        time_format(format.utc, 'time-utc');
        break;
      default:
        throw Error('Unrecognized template filter: ' + f);
    }
  }

  return src;
}

var template_re = /\{\{(.+?)\}\}|$/g,
    filter_re = /(?:"[^"]*"|\'[^\']*\'|[^\|"]+|[^\|\']+)+/g,
    args_re = /(?:"[^"]*"|\'[^\']*\'|[^,"]+|[^,\']+)+/g;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var template_escapes = {
  '\'':     '\'',
  '\\':     '\\',
  '\r':     'r',
  '\n':     'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var template_escaper = /\\|'|\r|\n|\u2028|\u2029/g;

function template_escapeChar(match) {
  return '\\' + template_escapes[match];
}

function template_format(pattern, key, fmt) {
  if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
      (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
    pattern = pattern.slice(1, -1);
  } else {
    throw Error('Format pattern must be quoted: ' + pattern);
  }
  key = key + ':' + pattern;
  if (!context.format_map[key]) {
    var f = fmt(pattern);
    var i = context.formats.length;
    context.formats.push(f);
    context.format_map[key] = i;
  }
  return context.format_map[key];
}

},{"./format":38,"./util":54}],53:[function(require,module,exports){
var d3_time = require('d3-time');

var tempDate = new Date(),
    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD
    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);

function date(d) {
  return (tempDate.setTime(+d), tempDate);
}

// create a time unit entry
function entry(type, date, unit, step, min, max) {
  var e = {
    type: type,
    date: date,
    unit: unit
  };
  if (step) {
    e.step = step;
  } else {
    e.minstep = 1;
  }
  if (min != null) e.min = min;
  if (max != null) e.max = max;
  return e;
}

function create(type, unit, base, step, min, max) {
  return entry(type,
    function(d) { return unit.offset(base, d); },
    function(d) { return unit.count(base, d); },
    step, min, max);
}

var locale = [
  create('second', d3_time.second, baseDate),
  create('minute', d3_time.minute, baseDate),
  create('hour',   d3_time.hour,   baseDate),
  create('day',    d3_time.day,    baseDate, [1, 7]),
  create('month',  d3_time.month,  baseDate, [1, 3, 6]),
  create('year',   d3_time.year,   baseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(1970, 0, 1, 0, 0, d); },
    function(d) { return date(d).getSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(1970, 0, 1, 0, d); },
    function(d) { return date(d).getMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(1970, 0, 1, d); },
    function(d) { return date(d).getHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(1970, 0, 4+d); },
    function(d) { return date(d).getDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(1970, 0, d); },
    function(d) { return date(d).getDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(1970, d % 12, 1); },
    function(d) { return date(d).getMonth(); },
    [1], 0, 11
  )
];

var utc = [
  create('second', d3_time.utcSecond, utcBaseDate),
  create('minute', d3_time.utcMinute, utcBaseDate),
  create('hour',   d3_time.utcHour,   utcBaseDate),
  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),
  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),
  create('year',   d3_time.utcYear,   utcBaseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },
    function(d) { return date(d).getUTCSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },
    function(d) { return date(d).getUTCMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },
    function(d) { return date(d).getUTCHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },
    function(d) { return date(d).getUTCDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(Date.UTC(1970, 0, d)); },
    function(d) { return date(d).getUTCDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },
    function(d) { return date(d).getUTCMonth(); },
    [1], 0, 11
  )
];

var STEPS = [
  [31536e6, 5],  // 1-year
  [7776e6, 4],   // 3-month
  [2592e6, 4],   // 1-month
  [12096e5, 3],  // 2-week
  [6048e5, 3],   // 1-week
  [1728e5, 3],   // 2-day
  [864e5, 3],    // 1-day
  [432e5, 2],    // 12-hour
  [216e5, 2],    // 6-hour
  [108e5, 2],    // 3-hour
  [36e5, 2],     // 1-hour
  [18e5, 1],     // 30-minute
  [9e5, 1],      // 15-minute
  [3e5, 1],      // 5-minute
  [6e4, 1],      // 1-minute
  [3e4, 0],      // 30-second
  [15e3, 0],     // 15-second
  [5e3, 0],      // 5-second
  [1e3, 0]       // 1-second
];

function find(units, span, minb, maxb) {
  var step = STEPS[0], i, n, bins;

  for (i=1, n=STEPS.length; i<n; ++i) {
    step = STEPS[i];
    if (span > step[0]) {
      bins = span / step[0];
      if (bins > maxb) {
        return units[STEPS[i-1][1]];
      }
      if (bins >= minb) {
        return units[step[1]];
      }
    }
  }
  return units[STEPS[n-1][1]];
}

function toUnitMap(units) {
  var map = {}, i, n;
  for (i=0, n=units.length; i<n; ++i) {
    map[units[i].type] = units[i];
  }
  map.find = function(span, minb, maxb) {
    return find(units, span, minb, maxb);
  };
  return map;
}

module.exports = toUnitMap(locale);
module.exports.utc = toUnitMap(utc);

},{"d3-time":31}],54:[function(require,module,exports){
var buffer = require('buffer'),
    time = require('./time'),
    utc = time.utc;

var u = module.exports = {};

// utility functions

var FNAME = '__name__';

u.namedfunc = function(name, f) { return (f[FNAME] = name, f); };

u.name = function(f) { return f==null ? null : f[FNAME]; };

u.identity = function(x) { return x; };

u.true = u.namedfunc('true', function() { return true; });

u.false = u.namedfunc('false', function() { return false; });

u.duplicate = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};

u.equal = function(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
};

u.extend = function(obj) {
  for (var x, name, i=1, len=arguments.length; i<len; ++i) {
    x = arguments[i];
    for (name in x) { obj[name] = x[name]; }
  }
  return obj;
};

u.length = function(x) {
  return x != null && x.length != null ? x.length : null;
};

u.keys = function(x) {
  var keys = [], k;
  for (k in x) keys.push(k);
  return keys;
};

u.vals = function(x) {
  var vals = [], k;
  for (k in x) vals.push(x[k]);
  return vals;
};

u.toMap = function(list, f) {
  return (f = u.$(f)) ?
    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :
    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});
};

u.keystr = function(values) {
  // use to ensure consistent key generation across modules
  var n = values.length;
  if (!n) return '';
  for (var s=String(values[0]), i=1; i<n; ++i) {
    s += '|' + String(values[i]);
  }
  return s;
};

// type checking functions

var toString = Object.prototype.toString;

u.isObject = function(obj) {
  return obj === Object(obj);
};

u.isFunction = function(obj) {
  return toString.call(obj) === '[object Function]';
};

u.isString = function(obj) {
  return typeof value === 'string' || toString.call(obj) === '[object String]';
};

u.isArray = Array.isArray || function(obj) {
  return toString.call(obj) === '[object Array]';
};

u.isNumber = function(obj) {
  return typeof obj === 'number' || toString.call(obj) === '[object Number]';
};

u.isBoolean = function(obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

u.isDate = function(obj) {
  return toString.call(obj) === '[object Date]';
};

u.isValid = function(obj) {
  return obj != null && obj === obj;
};

u.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;

// type coercion functions

u.number = function(s) {
  return s == null || s === '' ? null : +s;
};

u.boolean = function(s) {
  return s == null || s === '' ? null : s==='false' ? false : !!s;
};

u.date = function(s) {
  return s == null || s === '' ? null : Date.parse(s);
};

u.array = function(x) {
  return x != null ? (u.isArray(x) ? x : [x]) : [];
};

u.str = function(x) {
  return u.isArray(x) ? '[' + x.map(u.str) + ']'
    : u.isObject(x) ? JSON.stringify(x)
    : u.isString(x) ? ('\''+util_escape_str(x)+'\'') : x;
};

var escape_str_re = /(^|[^\\])'/g;

function util_escape_str(x) {
  return x.replace(escape_str_re, '$1\\\'');
}

// data access functions

var field_re = /\[(.*?)\]|[^.\[]+/g;

u.field = function(f) {
  return String(f).match(field_re).map(function(d) {
    return d[0] !== '[' ? d :
      d[1] !== "'" && d[1] !== '"' ? d.slice(1, -1) :
      d.slice(2, -2).replace(/\\(["'])/g, '$1');
  });
};

u.accessor = function(f) {
  var s;
  return f==null || u.isFunction(f) ? f :
    u.namedfunc(f, (s = u.field(f)).length > 1 ?
      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :
      function(x) { return x[f]; }
    );
};

// short-cut for accessor
u.$ = u.accessor;

u.mutator = function(f) {
  var s;
  return u.isString(f) && (s=u.field(f)).length > 1 ?
    function(x, v) {
      for (var i=0; i<s.length-1; ++i) x = x[s[i]];
      x[s[i]] = v;
    } :
    function(x, v) { x[f] = v; };
};


u.$func = function(name, op) {
  return function(f) {
    f = u.$(f) || u.identity;
    var n = name + (u.name(f) ? '_'+u.name(f) : '');
    return u.namedfunc(n, function(d) { return op(f(d)); });
  };
};

u.$valid  = u.$func('valid', u.isValid);
u.$length = u.$func('length', u.length);

u.$in = function(f, values) {
  f = u.$(f);
  var map = u.isArray(values) ? u.toMap(values) : values;
  return function(d) { return !!map[f(d)]; };
};

u.$year   = u.$func('year', time.year.unit);
u.$month  = u.$func('month', time.months.unit);
u.$date   = u.$func('date', time.dates.unit);
u.$day    = u.$func('day', time.weekdays.unit);
u.$hour   = u.$func('hour', time.hours.unit);
u.$minute = u.$func('minute', time.minutes.unit);
u.$second = u.$func('second', time.seconds.unit);

u.$utcYear   = u.$func('utcYear', utc.year.unit);
u.$utcMonth  = u.$func('utcMonth', utc.months.unit);
u.$utcDate   = u.$func('utcDate', utc.dates.unit);
u.$utcDay    = u.$func('utcDay', utc.weekdays.unit);
u.$utcHour   = u.$func('utcHour', utc.hours.unit);
u.$utcMinute = u.$func('utcMinute', utc.minutes.unit);
u.$utcSecond = u.$func('utcSecond', utc.seconds.unit);

// comparison / sorting functions

u.comparator = function(sort) {
  var sign = [];
  if (sort === undefined) sort = [];
  sort = u.array(sort).map(function(f) {
    var s = 1;
    if      (f[0] === '-') { s = -1; f = f.slice(1); }
    else if (f[0] === '+') { s = +1; f = f.slice(1); }
    sign.push(s);
    return u.accessor(f);
  });
  return function(a,b) {
    var i, n, f, x, y;
    for (i=0, n=sort.length; i<n; ++i) {
      f = sort[i]; x = f(a); y = f(b);
      if (x < y) return -1 * sign[i];
      if (x > y) return sign[i];
    }
    return 0;
  };
};

u.cmp = function(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else if (a >= b) {
    return 0;
  } else if (a === null) {
    return -1;
  } else if (b === null) {
    return 1;
  }
  return NaN;
};

u.numcmp = function(a, b) { return a - b; };

u.stablesort = function(array, sortBy, keyFn) {
  var indices = array.reduce(function(idx, v, i) {
    return (idx[keyFn(v)] = i, idx);
  }, {});

  array.sort(function(a, b) {
    var sa = sortBy(a),
        sb = sortBy(b);
    return sa < sb ? -1 : sa > sb ? 1
         : (indices[keyFn(a)] - indices[keyFn(b)]);
  });

  return array;
};


// string functions

u.pad = function(s, length, pos, padchar) {
  padchar = padchar || " ";
  var d = length - s.length;
  if (d <= 0) return s;
  switch (pos) {
    case 'left':
      return strrep(d, padchar) + s;
    case 'middle':
    case 'center':
      return strrep(Math.floor(d/2), padchar) +
         s + strrep(Math.ceil(d/2), padchar);
    default:
      return s + strrep(d, padchar);
  }
};

function strrep(n, str) {
  var s = "", i;
  for (i=0; i<n; ++i) s += str;
  return s;
}

u.truncate = function(s, length, pos, word, ellipsis) {
  var len = s.length;
  if (len <= length) return s;
  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\u2026';
  var l = Math.max(0, length - ellipsis.length);

  switch (pos) {
    case 'left':
      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));
    case 'middle':
    case 'center':
      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);
      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +
        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));
    default:
      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;
  }
};

function truncateOnWord(s, len, rev) {
  var cnt = 0, tok = s.split(truncate_word_re);
  if (rev) {
    s = (tok = tok.reverse())
      .filter(function(w) { cnt += w.length; return cnt <= len; })
      .reverse();
  } else {
    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });
  }
  return s.length ? s.join('').trim() : tok[0].slice(0, len);
}

var truncate_word_re = /([\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF])/;

},{"./time":53,"buffer":4}],55:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],56:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("FileSaver.js", function() {
    return saveAs;
  });
}

},{}],57:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],58:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],60:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],61:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],62:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],63:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":92,"./utils":94}],64:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":68,"./stream/Crc32Probe":87,"./stream/DataLengthProbe":88,"./stream/DataWorker":89}],65:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":69,"./stream/GenericWorker":90}],66:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};
// vim: set shiftwidth=4 softtabstop=4:

},{"./utils":94}],67:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],68:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":114}],69:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = new pako[action]({
        raw:true,
        level : options.level || -1 // default compression
    });
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};

    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":90,"./utils":94,"pako":98}],70:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":66,"../signature":85,"../stream/GenericWorker":90,"../utf8":93,"../utils":94}],71:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":65,"./ZipFileWorker":70}],72:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.3";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":67,"./external":68,"./load":73,"./object":77,"./support":92}],73:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":68,"./nodejsUtils":76,"./stream/Crc32Probe":87,"./utf8":93,"./utils":94,"./zipEntries":95}],74:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":90,"../utils":94}],75:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var util = require('util');
util.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"readable-stream":78,"util":131}],76:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBuffer : function(data, encoding){
        return new Buffer(data, encoding);
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":5}],77:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":64,"./defaults":67,"./generate":71,"./nodejs/NodejsStreamInputAdapter":74,"./nodejsUtils":76,"./stream/GenericWorker":90,"./stream/StreamHelper":91,"./utf8":93,"./utils":94,"./zipObject":97}],78:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":127}],79:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":94,"./DataReader":80}],80:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specifed index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":94}],81:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":94,"./Uint8ArrayReader":83}],82:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":94,"./DataReader":80}],83:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":94,"./ArrayReader":79}],84:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

// vim: set shiftwidth=4 softtabstop=4:

},{"../support":92,"../utils":94,"./ArrayReader":79,"./NodeBufferReader":81,"./StringReader":82,"./Uint8ArrayReader":83}],85:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],86:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":94,"./GenericWorker":90}],87:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":66,"../utils":94,"./GenericWorker":90}],88:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":94,"./GenericWorker":90}],89:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":94,"./GenericWorker":90}],90:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],91:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} resultType the name of the final type
 * @param {String} chunkType the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(resultType, chunkType, dataArray, mimeType) {
    var content = null;
    switch(resultType) {
        case "blob" :
            return utils.newBlob(dataArray, mimeType);
        case "base64" :
            content = concat(chunkType, dataArray);
            return base64.encode(content);
        default :
            content = concat(chunkType, dataArray);
            return utils.transformTo(resultType, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, chunkType, dataArray, mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
            internalType = "arraybuffer";
        break;
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

}).call(this,require("buffer").Buffer)

},{"../base64":63,"../external":68,"../nodejs/NodejsStreamOutputAdapter":75,"../support":92,"../utils":94,"./ConvertWorker":86,"./GenericWorker":90,"buffer":5}],92:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":5,"readable-stream":78}],93:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBuffer(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":76,"./stream/GenericWorker":90,"./support":92,"./utils":94}],94:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('core-js/library/fn/set-immediate');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {Array[String|ArrayBuffer]} parts the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(parts, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob(parts, {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i++) {
                builder.append(parts[i]);
            }
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.newBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.newBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        // copy the uint8array: DO NOT propagate the original ArrayBuffer, it
        // can be way larger (the whole zip file for example).
        var copy = new Uint8Array(input.length);
        if (input.length) {
            copy.set(input, 0);
        }
        return copy.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBuffer(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("The data of '" + name + "' is in an unsupported format !")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":63,"./external":68,"./nodejsUtils":76,"./support":92,"core-js/library/fn/set-immediate":6}],95:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the speficied signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip : can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":84,"./signature":85,"./support":92,"./utf8":93,"./utils":94,"./zipEntry":96}],96:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":64,"./compressions":65,"./crc32":66,"./reader/readerFor":84,"./support":92,"./utf8":93,"./utils":94}],97:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
        }
        var result = this._decompressWorker();

        var isUnicodeString = !this._dataBinary;

        if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":64,"./stream/DataWorker":89,"./stream/GenericWorker":90,"./stream/StreamHelper":91,"./utf8":93}],98:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":99,"./lib/inflate":100,"./lib/utils/common":101,"./lib/zlib/constants":104}],99:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":101,"./utils/strings":102,"./zlib/deflate":106,"./zlib/messages":111,"./zlib/zstream":113}],100:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":101,"./utils/strings":102,"./zlib/constants":104,"./zlib/gzheader":107,"./zlib/inflate":109,"./zlib/messages":111,"./zlib/zstream":113}],101:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],102:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":101}],103:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],104:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],105:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],106:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":101,"./adler32":103,"./crc32":105,"./messages":111,"./trees":112}],107:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],108:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],109:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":101,"./adler32":103,"./crc32":105,"./inffast":108,"./inftrees":110}],110:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":101}],111:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],112:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":101}],113:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],114:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":58}],115:[function(require,module,exports){
(function (process){
'use strict';
module.exports = nextTick;

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < args.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

}).call(this,require('_process'))

},{"_process":116}],116:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],117:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":118}],118:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/



/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":120,"./_stream_writable":122,"core-util-is":27,"inherits":59,"process-nextick-args":115}],119:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":121,"core-util-is":27,"inherits":59}],120:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      processNextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    processNextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":118,"_process":116,"buffer":5,"core-util-is":27,"events":55,"inherits":59,"isarray":62,"process-nextick-args":115,"string_decoder/":128,"util":4}],121:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":118,"core-util-is":27,"inherits":59}],122:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function (){try {
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: require('util-deprecate')(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use ' +
      '_writableState.getBuffer() instead.')
});
}catch(_){}}());


function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = nop;

  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
.indexOf((encoding + '').toLowerCase()) > -1))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    processNextTick(cb, er);
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      processNextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var buffer = [];
    var cbs = [];
    while (entry) {
      cbs.push(entry.callback);
      buffer.push(entry);
      entry = entry.next;
    }

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    state.lastBufferedRequest = null;
    doWrite(stream, state, true, state.length, buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      processNextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":118,"buffer":5,"core-util-is":27,"events":55,"inherits":59,"process-nextick-args":115,"util-deprecate":129}],123:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":119}],124:[function(require,module,exports){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":118,"./lib/_stream_passthrough.js":119,"./lib/_stream_readable.js":120,"./lib/_stream_transform.js":121,"./lib/_stream_writable.js":122}],125:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":121}],126:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":122}],127:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":55,"inherits":59,"readable-stream/duplex.js":117,"readable-stream/passthrough.js":123,"readable-stream/readable.js":124,"readable-stream/transform.js":125,"readable-stream/writable.js":126}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":5}],129:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],130:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],131:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":130,"_process":116,"inherits":59}],132:[function(require,module,exports){
var DEPS = require('./Dependencies').ALL;

function create(cs, reflow) {
  var out = {};
  copy(cs, out);

  out.add = [];
  out.mod = [];
  out.rem = [];

  out.reflow = reflow;

  return out;
}

function copy(a, b) {
  b.stamp = a ? a.stamp : 0;
  b.sort  = a ? a.sort  : null;
  b.facet = a ? a.facet : null;
  b.trans = a ? a.trans : null;
  b.dirty = a ? a.dirty : [];
  b.request = a ? a.request : null;
  for (var d, i=0, n=DEPS.length; i<n; ++i) {
    b[d=DEPS[i]] = a ? a[d] : {};
  }
}

module.exports = {
  create: create,
  copy: copy
};
},{"./Dependencies":135}],133:[function(require,module,exports){
var log = require('vega-logging'),
    Tuple = require('./Tuple'),
    Base = require('./Node').prototype;

function Collector(graph) {
  Base.init.call(this, graph);
  this._data = [];
  this.router(true).collector(true);
}

var prototype = (Collector.prototype = Object.create(Base));
prototype.constructor = Collector;

prototype.data = function() {
  return this._data;
};

prototype.evaluate = function(input) {
  log.debug(input, ["collecting"]);

  if (input.rem.length) {
    this._data = Tuple.idFilter(this._data, input.rem);
  }

  if (input.add.length) {
    this._data = this._data.length ? this._data.concat(input.add) : input.add;
  }

  if (input.sort) {
    this._data.sort(input.sort);
  }

  if (input.reflow) {
    input.mod = input.mod.concat(
      Tuple.idFilter(this._data, input.add, input.mod, input.rem));
    input.reflow = false;
  }

  return input;
};

module.exports = Collector;
},{"./Node":138,"./Tuple":140,"vega-logging":147}],134:[function(require,module,exports){
var log = require('vega-logging'),
    ChangeSet = require('./ChangeSet'), 
    Collector = require('./Collector'),
    Tuple = require('./Tuple'),
    Node = require('./Node'); // jshint ignore:line

function DataSource(graph, name, facet) {
  this._graph = graph;
  this._name = name;
  this._data = [];
  this._source = null;
  this._facet  = facet;
  this._input  = ChangeSet.create();
  this._output = null; // Output changeset

  this._inputNode  = null;
  this._outputNode = null;
  this._pipeline  = null; // Pipeline of transformations.
  this._collector = null; // Collector to materialize output of pipeline.
  this._mutates = false;  // Does any pipeline operator mutate tuples?
}

var prototype = DataSource.prototype;

prototype.name = function(name) {
  if (!arguments.length) return this._name;
  return (this._name = name, this);
};

prototype.source = function(src) {
  if (!arguments.length) return this._source;
  return (this._source = this._graph.data(src));
};

prototype.insert = function(tuples) {
  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));
  return this;
};

prototype.remove = function(where) {
  var remove = this._data.filter(where);
  this._input.rem = this._input.rem.concat(remove);
  return this;
};

prototype.update = function(where, field, func) {
  var mod = this._input.mod,
      ids = Tuple.idMap(mod);

  this._input.fields[field] = 1;

  this._data.filter(where).forEach(function(x) {
    var prev = x[field],
        next = func(x);
    if (prev !== next) {
      Tuple.set(x, field, next);
      if (ids[x._id] !== 1) {
        mod.push(x);
        ids[x._id] = 1;
      }
    }
  });

  return this;
};

prototype.values = function(data) {
  if (!arguments.length) return this._collector.data();

  // Replace backing data
  this._input.rem = this._data.slice();
  if (data) { this.insert(data); }
  return this;
};

prototype.mutates = function(m) {
  if (!arguments.length) return this._mutates;
  this._mutates = this._mutates || m;
  return this;
};

prototype.last = function() {
  return this._output;
};

prototype.fire = function(input) {
  if (input) this._input = input;
  this._graph.propagate(this._input, this._pipeline[0]);
  return this;
};

prototype.pipeline = function(pipeline) {
  if (!arguments.length) return this._pipeline;

  var graph = this._graph,
      status;

  pipeline.unshift(this._inputNode = DataSourceInput(this));
  status = graph.preprocess(pipeline);

  if (status.router) {
    pipeline.push(status.collector = new Collector(graph));
  }

  pipeline.push(this._outputNode = DataSourceOutput(this));
  this._collector = status.collector;
  this._mutates = !!status.mutates;
  graph.connect(this._pipeline = pipeline);

  return this;
};

prototype.synchronize = function() {
  this._graph.synchronize(this._pipeline);
  return this;
};

prototype.listener = function() { 
  return DataSourceListener(this).addListener(this._inputNode);
};

prototype.addListener = function(l) {
  if (l instanceof DataSource) {
    this._collector.addListener(l.listener());
  } else {
    this._outputNode.addListener(l);      
  }
  return this;
};

prototype.removeListener = function(l) {
  this._outputNode.removeListener(l);
};

prototype.listeners = function(ds) {
  return (ds ? this._collector : this._outputNode).listeners();
};

// Input node applies the datasource's delta, and propagates it to 
// the rest of the pipeline. It receives touches to reflow data.
function DataSourceInput(ds) {
  var input = new Node(ds._graph)
    .router(true)
    .collector(true);

  input.data = function() {
    return ds._data;
  };

  input.evaluate = function(input) {
    log.debug(input, ['input', ds._name]);

    var delta = ds._input, 
        out = ChangeSet.create(input), f;

    // Delta might contain fields updated through API
    for (f in delta.fields) {
      out.fields[f] = 1;
    }

    // update data
    if (delta.rem.length) {
      ds._data = Tuple.idFilter(ds._data, delta.rem);
    }

    if (delta.add.length) {
      ds._data = ds._data.concat(delta.add);
    }

    // if reflowing, add any other tuples not currently in changeset
    if (input.reflow) {
      delta.mod = delta.mod.concat(
        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));
    }

    // reset change list
    ds._input = ChangeSet.create();

    out.add = delta.add; 
    out.mod = delta.mod;
    out.rem = delta.rem;
    out.facet = ds._facet;
    return out;
  };

  return input;
}

// Output node captures the last changeset seen by this datasource
// (needed for joins and builds) and materializes any nested data.
// If this datasource is faceted, materializes the values in the facet.
function DataSourceOutput(ds) {
  var output = new Node(ds._graph)
    .router(true)
    .reflows(true)
    .collector(true);

  output.data = function() {
    return ds._collector ? ds._collector.data() : ds._data;
  };

  output.evaluate = function(input) {
    log.debug(input, ['output', ds._name]);

    var out = ChangeSet.create(input, true);

    if (ds._facet) {
      ds._facet.values = ds.values();
      input.facet = null;
    }

    ds._output = input;
    out.data[ds._name] = 1;
    return out;
  };

  return output;
}

function DataSourceListener(ds) {
  var l = new Node(ds._graph).router(true);

  l.evaluate = function(input) {
    // Tuple derivation carries a cost. So only derive if the pipeline has
    // operators that mutate, and thus would override the source data.
    if (ds.mutates()) {  
      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly
          output = ChangeSet.create(input);

      output.add = input.add.map(function(t) {
        return (map[t._id] = Tuple.derive(t));
      });

      output.mod = input.mod.map(function(t) {
        return Tuple.rederive(t, map[t._id]);
      });

      output.rem = input.rem.map(function(t) { 
        var o = map[t._id];
        return (map[t._id] = null, o);
      });

      return (ds._input = output);
    } else {
      return (ds._input = input);
    }
  };

  return l;
}

module.exports = DataSource;

},{"./ChangeSet":132,"./Collector":133,"./Node":138,"./Tuple":140,"vega-logging":147}],135:[function(require,module,exports){
var deps = module.exports = {
  ALL: ['data', 'fields', 'scales', 'signals']
};
deps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });

},{}],136:[function(require,module,exports){
var dl = require('datalib'),
    Heap = require('./Heap'),
    ChangeSet = require('./ChangeSet'),
    DataSource = require('./DataSource'),
    Collector = require('./Collector'),
    Tuple = require('./Tuple'),
    Signal = require('./Signal'),
    Deps = require('./Dependencies');

function Graph() {
}

var prototype = Graph.prototype;

prototype.init = function() {
  this._stamp = 0;
  this._rank  = 0;

  this._data = {};
  this._signals = {};

  this.doNotPropagate = {};
};

prototype.rank = function() {
  return ++this._rank;
};

prototype.values = function(type, names, hash) {
  var data = (type === Deps.SIGNALS ? this._signals : this._data),
      n = (names !== undefined ? names : dl.keys(data)),
      vals, i;

  if (Array.isArray(n)) {
    vals = hash || {};
    for (i=0; i<n.length; ++i) {
      vals[n[i]] = data[n[i]].values();
    }
    return vals;
  } else {
    return data[n].values();
  }
};

// Retain for backwards-compatibility
prototype.dataValues = function(names) {
  return this.values(Deps.DATA, names);
};

// Retain for backwards-compatibility
prototype.signalValues = function(names) {
  return this.values(Deps.SIGNALS, names);
};

prototype.data = function(name, pipeline, facet) {
  var db = this._data;
  if (!arguments.length) {
    var all = [], key;
    for (key in db) { all.push(db[key]); }
    return all;
  } else if (arguments.length === 1) {
    return db[name];
  } else {
    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));
  }
};

prototype.signal = function(name, init) {
  if (arguments.length === 1) {
    var m = this;
    return Array.isArray(name) ?
      name.map(function(n) { return m._signals[n]; }) :
      this._signals[name];
  } else {
    return (this._signals[name] = new Signal(this, name, init));
  }
};

prototype.signalRef = function(ref) {
  if (!Array.isArray(ref)) {
    ref = dl.field(ref);
  }

  var value = this.signal(ref[0]).value();
  if (ref.length > 1) {
    for (var i=1, n=ref.length; i<n; ++i) {
      value = value[ref[i]];
    }
  }
  return value;
};

// Stamp should be specified with caution. It is necessary for inline datasources,
// which need to be populated during the same cycle even though propagation has
// passed that part of the dataflow graph.  
prototype.propagate = function(pulse, node, stamp) {
  var pulses = {},
      listeners, next, nplse, tpls, ntpls, i, len;

  // new PQ with each propagation cycle so that we can pulse branches
  // of the dataflow graph during a propagation (e.g., when creating
  // a new inline datasource).
  var pq = new Heap(function(a, b) {
    // Sort on qrank (queue-rank).
    // Rank can change during propagation due to rewiring.
    return a._qrank - b._qrank;
  });

  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');

  pulse.stamp = stamp || ++this._stamp;
  pulses[node._id] = pulse;
  pq.push(node.qrank(true));

  while (pq.size() > 0) {
    node  = pq.peek();
    pulse = pulses[node._id];

    if (node.rank() !== node.qrank()) {
      // A node's rank might change during a propagation. Re-queue if so.
      pq.replace(node.qrank(true));
    } else {
      // Evaluate node and propagate pulse.
      pq.pop();
      pulses[node._id] = null;
      listeners = node._listeners;
      pulse = this.evaluate(pulse, node);

      // Propagate the pulse. 
      if (pulse !== this.doNotPropagate) {
        // Ensure reflow pulses always send reflow pulses even if skipped.
        if (!pulse.reflow && node.reflows()) {
          pulse = ChangeSet.create(pulse, true);
        }

        for (i=0, len=listeners.length; i<len; ++i) {
          next = listeners[i];

          if ((nplse = pulses[next._id]) !== undefined) {
            if (nplse === null) throw Error('Already propagated to node.');
            if (nplse === pulse) continue;  // Re-queueing the same pulse.

            // We've already queued this node. Ensure there should be at most one
            // pulse with tuples (add/mod/rem), and the remainder will be reflows. 
            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;
            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;

            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');

            // Combine reflow and tuples into a single pulse. 
            pulses[next._id] = tpls ? pulse : nplse;
            pulses[next._id].reflow = pulse.reflow || nplse.reflow;
          } else {
            // First time we're seeing this node, queue it for propagation.
            pq.push(next.qrank(true));
            pulses[next._id] = pulse;
          }
        }
      }
    }
  }
};

// Process a new branch of the dataflow graph prior to connection:
// (1) Insert new Collector nodes as needed. 
// (2) Track + return mutation/routing status of the branch.
prototype.preprocess = function(branch) {
  var graph = this,
      mutates = 0,
      node, router, collector, collects;

  for (var i=0; i<branch.length; ++i) {
    node = branch[i];

    // Batch nodes need access to a materialized dataset. 
    if (node.batch() && !node._collector) {
      if (router || !collector) {
        node = new Collector(graph);
        branch.splice(i, 0, node);
        router = false;
      } else {
        node._collector = collector;
      }
    }

    if ((collects = node.collector())) collector = node;
    router  = router  || node.router() && !collects;
    mutates = mutates || node.mutates();

    // A collector needs to be inserted after tuple-producing
    // nodes for correct previous value tracking.
    if (node.produces()) {
      branch.splice(i+1, 0, new Collector(graph));
      router = false;
    }
  }

  return {router: router, collector: collector, mutates: mutates};
};

prototype.connect = function(branch) {
  var collector, node, data, signals, i, n, j, m;

  // connect the pipeline
  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (node.collector()) collector = node;

    data = node.dependency(Deps.DATA);
    for (j=0, m=data.length; j<m; ++j) {
      this.data(data[j]).addListener(collector);
    }

    signals = node.dependency(Deps.SIGNALS);
    for (j=0, m=signals.length; j<m; ++j) {
      this.signal(signals[j]).addListener(collector);
    }

    if (i > 0) branch[i-1].addListener(node);
  }

  return branch;
};

prototype.disconnect = function(branch) {
  var collector, node, data, signals, i, n, j, m;

  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (node.collector()) collector = node;

    data = node.dependency(Deps.DATA);
    for (j=0, m=data.length; j<m; ++j) {
      this.data(data[j]).removeListener(collector);
    }

    signals = node.dependency(Deps.SIGNALS);
    for (j=0, m=signals.length; j<m; ++j) {
      this.signal(signals[j]).removeListener(collector);
    }

    node.disconnect();
  }

  return branch;
};

prototype.synchronize = function(branch) {
  var ids = {},
      node, data, i, n, j, m, d, id;

  for (i=0, n=branch.length; i<n; ++i) {
    node = branch[i];
    if (!node.collector()) continue;

    for (j=0, data=node.data(), m=data.length; j<m; ++j) {
      id = (d = data[j])._id;
      if (ids[id]) continue; 
      Tuple.prev_update(d);
      ids[id] = 1; 
    }
  }

  return this;
};

prototype.reevaluate = function(pulse, node) {
  var reflowed = pulse.reflow && node.last() >= pulse.stamp,
      run = node.router() || pulse.add.length || pulse.rem.length;

  return run || !reflowed || node.reevaluate(pulse);
};

prototype.evaluate = function(pulse, node) {
  if (!this.reevaluate(pulse, node)) return pulse;
  pulse = node.evaluate(pulse);
  node.last(pulse.stamp);
  return pulse;
};

module.exports = Graph;

},{"./ChangeSet":132,"./Collector":133,"./DataSource":134,"./Dependencies":135,"./Heap":137,"./Signal":139,"./Tuple":140,"datalib":49}],137:[function(require,module,exports){
function Heap(comparator) {
  this.cmp = comparator;
  this.nodes = [];
}

var prototype = Heap.prototype;

prototype.size = function() {
  return this.nodes.length;
};

prototype.clear = function() {
  return (this.nodes = [], this);
};

prototype.peek = function() {
  return this.nodes[0];
};

prototype.push = function(x) {
  var array = this.nodes;
  array.push(x);
  return _siftdown(array, 0, array.length-1, this.cmp);
};

prototype.pop = function() {
  var array = this.nodes,
      last = array.pop(),
      item;

  if (array.length) {
    item = array[0];
    array[0] = last;
    _siftup(array, 0, this.cmp);
  } else {
    item = last;
  }
  return item;
};

prototype.replace = function(item) {
  var array = this.nodes,
      retval = array[0];
  array[0] = item;
  _siftup(array, 0, this.cmp);
  return retval;
};

prototype.pushpop = function(item) {
  var array = this.nodes, ref = array[0];
  if (array.length && this.cmp(ref, item) < 0) {
    array[0] = item;
    item = ref;
    _siftup(array, 0, this.cmp);
  }
  return item;
};

function _siftdown(array, start, idx, cmp) {
  var item, parent, pidx;

  item = array[idx];
  while (idx > start) {
    pidx = (idx - 1) >> 1;
    parent = array[pidx];
    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return (array[idx] = item);
}

function _siftup(array, idx, cmp) {
  var start = idx,
      end = array.length,
      item = array[idx],
      cidx = 2 * idx + 1, ridx;

  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }
    array[idx] = array[cidx];
    idx = cidx;
    cidx = 2 * idx + 1;
  }
  array[idx] = item;
  return _siftdown(array, start, idx, cmp);
}

module.exports = Heap;

},{}],138:[function(require,module,exports){
var DEPS = require('./Dependencies').ALL,
    nodeID = 0;

function Node(graph) {
  if (graph) this.init(graph);
}

var Flags = Node.Flags = {
  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.
  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.
  Produces:   0x04, // Produces new tuples. 
  Mutates:    0x08, // Sets properties of incoming tuples.
  Reflows:    0x10, // Forwards a reflow pulse.
  Batch:      0x20  // Performs batch data processing, needs collector.
};

var prototype = Node.prototype;

prototype.init = function(graph) {
  this._id = ++nodeID;
  this._graph = graph;
  this._rank  = graph.rank(); // Topological sort by rank
  this._qrank = null; // Rank when enqueued for propagation
  this._stamp = 0;    // Last stamp seen

  this._listeners = [];
  this._listeners._ids = {}; // To prevent duplicate listeners

  // Initialize dependencies.
  this._deps = {};
  for (var i=0, n=DEPS.length; i<n; ++i) {
    this._deps[DEPS[i]] = [];
  }

  // Initialize status flags.
  this._flags = 0;

  return this;
};

prototype.rank = function() {
  return this._rank;
};

prototype.qrank = function(/* set */) {
  if (!arguments.length) return this._qrank;
  return (this._qrank = this._rank, this);
};

prototype.last = function(stamp) { 
  if (!arguments.length) return this._stamp;
  return (this._stamp = stamp, this);
};

// -- status flags ---

prototype._setf = function(v, b) {
  if (b) { this._flags |= v; } else { this._flags &= ~v; }
  return this;
};

prototype.router = function(state) {
  if (!arguments.length) return (this._flags & Flags.Router);
  return this._setf(Flags.Router, state);
};

prototype.collector = function(state) {
  if (!arguments.length) return (this._flags & Flags.Collector);
  return this._setf(Flags.Collector, state);
};

prototype.produces = function(state) {
  if (!arguments.length) return (this._flags & Flags.Produces);
  return this._setf(Flags.Produces, state);
};

prototype.mutates = function(state) {
  if (!arguments.length) return (this._flags & Flags.Mutates);
  return this._setf(Flags.Mutates, state);
};

prototype.reflows = function(state) {
  if (!arguments.length) return (this._flags & Flags.Reflows);
  return this._setf(Flags.Reflows, state);
};

prototype.batch = function(state) {
  if (!arguments.length) return (this._flags & Flags.Batch);
  return this._setf(Flags.Batch, state);
};

prototype.dependency = function(type, deps) {
  var d = this._deps[type],
      n = d._names || (d._names = {});  // To prevent dupe deps

  // Get dependencies of the given type
  if (arguments.length === 1) {
    return d;
  }

  if (deps === null) {
    // Clear dependencies of the given type
    d.splice(0, d.length);
    d._names = {};
  } else if (!Array.isArray(deps)) {
    // Separate this case to avoid cost of array creation
    if (n[deps]) return this;
    d.push(deps);
    n[deps] = 1;
  } else {
    for (var i=0, len=deps.length, dep; i<len; ++i) {
      dep = deps[i];
      if (n[dep]) continue;
      d.push(dep);
      n[dep] = 1;
    }
  }

  return this;
};

prototype.listeners = function() {
  return this._listeners;
};

prototype.addListener = function(l) {
  if (!(l instanceof Node)) {
    throw Error('Listener is not a Node');
  }
  if (this._listeners._ids[l._id]) return this;

  this._listeners.push(l);
  this._listeners._ids[l._id] = 1;
  if (this._rank > l._rank) {
    var q = [l],
        g = this._graph, cur;
    while (q.length) {
      cur = q.shift();
      cur._rank = g.rank();
      q.unshift.apply(q, cur.listeners());
    }
  }

  return this;
};

prototype.removeListener = function(l) {
  if (!this._listeners._ids[l._id]) return false;
  
  var idx = this._listeners.indexOf(l),
      b = idx >= 0;

  if (b) {
    this._listeners.splice(idx, 1);
    this._listeners._ids[l._id] = null;
  }
  return b;
};

prototype.disconnect = function() {
  this._listeners = [];
  this._listeners._ids = {};
};

// Evaluate this dataflow node for the current pulse.
// Subclasses should override to perform custom processing.
prototype.evaluate = function(pulse) {
  return pulse;
};

// Should this node be re-evaluated for the current pulse?
// Searches pulse to see if any dependencies have updated.
prototype.reevaluate = function(pulse) {
  var prop, dep, i, n, j, m;

  for (i=0, n=DEPS.length; i<n; ++i) {
    prop = DEPS[i];
    dep = this._deps[prop];
    for (j=0, m=dep.length; j<m; ++j) {
      if (pulse[prop][dep[j]]) return true;
    }
  }

  return false;
};

Node.reset = function() { nodeID = 0; };

module.exports = Node;

},{"./Dependencies":135}],139:[function(require,module,exports){
var ChangeSet = require('./ChangeSet'),
    Node = require('./Node'), // jshint ignore:line
    Base = Node.prototype;

function Signal(graph, name, initialValue) {
  Base.init.call(this, graph);
  this._name  = name;
  this._value = initialValue;
  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.
  this._handlers = [];
  return this;
}

var prototype = (Signal.prototype = Object.create(Base));
prototype.constructor = Signal;

prototype.name = function() {
  return this._name;
};

prototype.value = function(val) {
  if (!arguments.length) return this._value;
  return (this._value = val, this);
};

// Alias to value, for shared API with DataSource
prototype.values = prototype.value;

prototype.verbose = function(v) {
  if (!arguments.length) return this._verbose;
  return (this._verbose = !!v, this);
};

prototype.evaluate = function(input) {
  return input.signals[this._name] ? input : this._graph.doNotPropagate;
};

prototype.fire = function(cs) {
  if (!cs) cs = ChangeSet.create(null, true);
  cs.signals[this._name] = 1;
  this._graph.propagate(cs, this);
};

prototype.on = function(handler) {
  var signal = this,
      node = new Node(this._graph);

  node.evaluate = function(input) {
    handler(signal.name(), signal.value());
    return input;
  };

  this._handlers.push({
    handler: handler,
    node: node
  });

  return this.addListener(node);
};

prototype.off = function(handler) {
  var h = this._handlers, i, x;

  for (i=h.length; --i>=0;) {
    if (!handler || h[i].handler === handler) {
      x = h.splice(i, 1)[0];
      this.removeListener(x.node);
    }
  }

  return this;
};

module.exports = Signal;

},{"./ChangeSet":132,"./Node":138}],140:[function(require,module,exports){
var tupleID = 0;

function ingest(datum) {
  datum = (datum === Object(datum)) ? datum : {data: datum};
  datum._id = ++tupleID;
  if (datum._prev) datum._prev = null;
  return datum;
}

function idMap(a, ids) {
  ids = ids || {};
  for (var i=0, n=a.length; i<n; ++i) {
    ids[a[i]._id] = 1;
  }
  return ids;
}

function copy(t, c) {
  c = c || {};
  for (var k in t) {
    if (k !== '_prev' && k !== '_id') c[k] = t[k];
  }
  return c;
}

module.exports = {
  ingest: ingest,
  idMap: idMap,

  derive: function(d) {
    return ingest(copy(d));
  },

  rederive: function(d, t) {
    return copy(d, t);
  },

  set: function(t, k, v) {
    return t[k] === v ? 0 : (t[k] = v, 1);
  },

  prev: function(t) {
    return t._prev || t;
  },

  prev_init: function(t) {
    if (!t._prev) { t._prev = {_id: t._id}; }
  },

  prev_update: function(t) {
    var p = t._prev, k, v;
    if (p) for (k in t) {
      if (k !== '_prev' && k !== '_id') {
        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;
      }
    }
  },

  reset: function() { tupleID = 0; },

  idFilter: function(data) {
    var ids = {};
    for (var i=arguments.length; --i>0;) {
      idMap(arguments[i], ids);
    }
    return data.filter(function(x) { return !ids[x._id]; });
  }
};

},{}],141:[function(require,module,exports){
module.exports = {
  ChangeSet:    require('./ChangeSet'),
  Collector:    require('./Collector'),
  DataSource:   require('./DataSource'),
  Dependencies: require('./Dependencies'),
  Graph:        require('./Graph'),
  Node:         require('./Node'),
  Signal:       require('./Signal'),
  Tuple:        require('./Tuple'),
  debug:        require('vega-logging').debug
};

},{"./ChangeSet":132,"./Collector":133,"./DataSource":134,"./Dependencies":135,"./Graph":136,"./Node":138,"./Signal":139,"./Tuple":140,"vega-logging":147}],142:[function(require,module,exports){
function toMap(list) {
  var map = {}, i, n;
  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;
  return map;
}

function keys(object) {
  var list = [], k;
  for (k in object) list.push(k);
  return list;
}

module.exports = function(opt) {
  opt = opt || {};
  var constants = opt.constants || require('./constants'),
      functions = (opt.functions || require('./functions'))(codegen),
      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,
      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,
      memberDepth = 0,
      FIELD_VAR = opt.fieldVar || 'datum',
      GLOBAL_VAR = opt.globalVar || 'signals',
      globals = {},
      fields = {};

  function codegen_wrap(ast) {    
    var retval = {
      code: codegen(ast),
      globals: keys(globals),
      fields: keys(fields)
    };
    globals = {};
    fields = {};
    return retval;
  }

  function lookupGlobal(id) {
    return GLOBAL_VAR + '["' + id + '"]';
  }

  function codegen(ast) {
    if (typeof ast === 'string') return ast;
    var generator = CODEGEN_TYPES[ast.type];
    if (generator == null) {
      throw new Error('Unsupported type: ' + ast.type);
    }
    return generator(ast);
  }

  var CODEGEN_TYPES = {
    'Literal': function(n) {
        return n.raw;
      },
    'Identifier': function(n) {
        var id = n.name;
        if (memberDepth > 0) {
          return id;
        }
        if (constants.hasOwnProperty(id)) {
          return constants[id];
        }
        if (idWhiteList) {
          if (idWhiteList.hasOwnProperty(id)) {
            return id;
          } else {
            globals[id] = 1;
            return lookupGlobal(id);
          }
        }
        if (idBlackList && idBlackList.hasOwnProperty(id)) {
          throw new Error('Illegal identifier: ' + id);
        }
        return id;
      },
    'Program': function(n) {
        return n.body.map(codegen).join('\n');
      },
    'MemberExpression': function(n) {
        var d = !n.computed;
        var o = codegen(n.object);
        if (d) memberDepth += 1;
        var p = codegen(n.property);
        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...
        if (d) memberDepth -= 1;
        return o + (d ? '.'+p : '['+p+']');
      },
    'CallExpression': function(n) {
        if (n.callee.type !== 'Identifier') {
          throw new Error('Illegal callee type: ' + n.callee.type);
        }
        var callee = n.callee.name;
        var args = n.arguments;
        var fn = functions.hasOwnProperty(callee) && functions[callee];
        if (!fn) throw new Error('Unrecognized function: ' + callee);
        return fn instanceof Function ?
          fn(args) :
          fn + '(' + args.map(codegen).join(',') + ')';
      },
    'ArrayExpression': function(n) {
        return '[' + n.elements.map(codegen).join(',') + ']';
      },
    'BinaryExpression': function(n) {
        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
      },
    'UnaryExpression': function(n) {
        return '(' + n.operator + codegen(n.argument) + ')';
      },
    'ConditionalExpression': function(n) {
        return '(' + codegen(n.test) +
          '?' + codegen(n.consequent) +
          ':' + codegen(n.alternate) +
          ')';
      },
    'LogicalExpression': function(n) {
        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
      },
    'ObjectExpression': function(n) {
        return '{' + n.properties.map(codegen).join(',') + '}';
      },
    'Property': function(n) {
        memberDepth += 1;
        var k = codegen(n.key);
        memberDepth -= 1;
        return k + ':' + codegen(n.value);
      },
    'ExpressionStatement': function(n) {
        return codegen(n.expression);
      }
  };

  codegen_wrap.functions = functions;
  codegen_wrap.constants = constants;
  return codegen_wrap;
};

},{"./constants":143,"./functions":144}],143:[function(require,module,exports){
module.exports = {
  'NaN':     'NaN',
  'E':       'Math.E',
  'LN2':     'Math.LN2',
  'LN10':    'Math.LN10',
  'LOG2E':   'Math.LOG2E',
  'LOG10E':  'Math.LOG10E',
  'PI':      'Math.PI',
  'SQRT1_2': 'Math.SQRT1_2',
  'SQRT2':   'Math.SQRT2'
};
},{}],144:[function(require,module,exports){
module.exports = function(codegen) {

  function fncall(name, args, cast, type) {
    var obj = codegen(args[0]);
    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }
    return obj + '.' + name + (type < 0 ? '' : type === 0 ?
      '()' :
      '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return function(args) {
      return fncall(name, args, cast, type);
    };
  }

  var DATE = 'new Date',
      STRING = 'String',
      REGEXP = 'RegExp';

  return {
    // MATH functions
    'isNaN':    'isNaN',
    'isFinite': 'isFinite',
    'abs':      'Math.abs',
    'acos':     'Math.acos',
    'asin':     'Math.asin',
    'atan':     'Math.atan',
    'atan2':    'Math.atan2',
    'ceil':     'Math.ceil',
    'cos':      'Math.cos',
    'exp':      'Math.exp',
    'floor':    'Math.floor',
    'log':      'Math.log',
    'max':      'Math.max',
    'min':      'Math.min',
    'pow':      'Math.pow',
    'random':   'Math.random',
    'round':    'Math.round',
    'sin':      'Math.sin',
    'sqrt':     'Math.sqrt',
    'tan':      'Math.tan',

    'clamp': function(args) {
      if (args.length < 3)
        throw new Error('Missing arguments to clamp function.');
      if (args.length > 3)
      throw new Error('Too many arguments to clamp function.');
      var a = args.map(codegen);
      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';
    },

    // DATE functions
    'now':             'Date.now',
    'datetime':        DATE,
    'date':            fn('getDate', DATE, 0),
    'day':             fn('getDay', DATE, 0),
    'year':            fn('getFullYear', DATE, 0),
    'month':           fn('getMonth', DATE, 0),
    'hours':           fn('getHours', DATE, 0),
    'minutes':         fn('getMinutes', DATE, 0),
    'seconds':         fn('getSeconds', DATE, 0),
    'milliseconds':    fn('getMilliseconds', DATE, 0),
    'time':            fn('getTime', DATE, 0),
    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),
    'utcdate':         fn('getUTCDate', DATE, 0),
    'utcday':          fn('getUTCDay', DATE, 0),
    'utcyear':         fn('getUTCFullYear', DATE, 0),
    'utcmonth':        fn('getUTCMonth', DATE, 0),
    'utchours':        fn('getUTCHours', DATE, 0),
    'utcminutes':      fn('getUTCMinutes', DATE, 0),
    'utcseconds':      fn('getUTCSeconds', DATE, 0),
    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),

    // shared sequence functions
    'length':      fn('length', null, -1),
    'indexof':     fn('indexOf', null),
    'lastindexof': fn('lastIndexOf', null),

    // STRING functions
    'parseFloat':  'parseFloat',
    'parseInt':    'parseInt',
    'upper':       fn('toUpperCase', STRING, 0),
    'lower':       fn('toLowerCase', STRING, 0),
    'slice':       fn('slice', STRING),
    'substring':   fn('substring', STRING),

    // REGEXP functions
    'regexp':  REGEXP,
    'test':    fn('test', REGEXP),

    // Control Flow functions
    'if': function(args) {
        if (args.length < 3)
          throw new Error('Missing arguments to if function.');
        if (args.length > 3)
        throw new Error('Too many arguments to if function.');
        var a = args.map(codegen);
        return a[0]+'?'+a[1]+':'+a[2];
      }
  };
};
},{}],145:[function(require,module,exports){
var parser = require('./parser'),
    codegen = require('./codegen');
    
var expr = module.exports = {
  parse: function(input, opt) {
      return parser.parse('('+input+')', opt);
    },
  code: function(opt) {
      return codegen(opt);
    },
  compiler: function(args, opt) {
      args = args.slice();
      var generator = codegen(opt),
          len = args.length,
          compile = function(str) {
            var value = generator(expr.parse(str));
            args[len] = '"use strict"; return (' + value.code + ');';
            value.fn = Function.apply(null, args);
            return value;
          };
      compile.codegen = generator;
      return compile;
    },
  functions: require('./functions'),
  constants: require('./constants')
};

},{"./codegen":142,"./constants":143,"./functions":144,"./parser":146}],146:[function(require,module,exports){
/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* istanbul ignore next */
module.exports = (function() {
  'use strict';

  var Token,
      TokenName,
      Syntax,
      PropertyKind,
      Messages,
      Regex,
      source,
      strict,
      index,
      lineNumber,
      lineStart,
      length,
      lookahead,
      state,
      extra;

  Token = {
      BooleanLiteral: 1,
      EOF: 2,
      Identifier: 3,
      Keyword: 4,
      NullLiteral: 5,
      NumericLiteral: 6,
      Punctuator: 7,
      StringLiteral: 8,
      RegularExpression: 9
  };

  TokenName = {};
  TokenName[Token.BooleanLiteral] = 'Boolean';
  TokenName[Token.EOF] = '<end>';
  TokenName[Token.Identifier] = 'Identifier';
  TokenName[Token.Keyword] = 'Keyword';
  TokenName[Token.NullLiteral] = 'Null';
  TokenName[Token.NumericLiteral] = 'Numeric';
  TokenName[Token.Punctuator] = 'Punctuator';
  TokenName[Token.StringLiteral] = 'String';
  TokenName[Token.RegularExpression] = 'RegularExpression';

  Syntax = {
      AssignmentExpression: 'AssignmentExpression',
      ArrayExpression: 'ArrayExpression',
      BinaryExpression: 'BinaryExpression',
      CallExpression: 'CallExpression',
      ConditionalExpression: 'ConditionalExpression',
      ExpressionStatement: 'ExpressionStatement',
      Identifier: 'Identifier',
      Literal: 'Literal',
      LogicalExpression: 'LogicalExpression',
      MemberExpression: 'MemberExpression',
      ObjectExpression: 'ObjectExpression',
      Program: 'Program',
      Property: 'Property',
      UnaryExpression: 'UnaryExpression'
  };

  PropertyKind = {
      Data: 1,
      Get: 2,
      Set: 4
  };

  // Error messages should be identical to V8.
  Messages = {
      UnexpectedToken:  'Unexpected token %0',
      UnexpectedNumber:  'Unexpected number',
      UnexpectedString:  'Unexpected string',
      UnexpectedIdentifier:  'Unexpected identifier',
      UnexpectedReserved:  'Unexpected reserved word',
      UnexpectedEOS:  'Unexpected end of input',
      NewlineAfterThrow:  'Illegal newline after throw',
      InvalidRegExp: 'Invalid regular expression',
      UnterminatedRegExp:  'Invalid regular expression: missing /',
      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
      InvalidLHSInForIn:  'Invalid left-hand side in for-in',
      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
      NoCatchOrFinally:  'Missing catch or finally after try',
      UnknownLabel: 'Undefined label \'%0\'',
      Redeclaration: '%0 \'%1\' has already been declared',
      IllegalContinue: 'Illegal continue statement',
      IllegalBreak: 'Illegal break statement',
      IllegalReturn: 'Illegal return statement',
      StrictModeWith:  'Strict mode code may not include a with statement',
      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
      StrictVarName:  'Variable name may not be eval or arguments in strict mode',
      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
      StrictDelete:  'Delete of an unqualified identifier in strict mode.',
      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
      StrictReservedWord:  'Use of future reserved word in strict mode'
  };

  // See also tools/generate-unicode-regex.py.
  Regex = {
      NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
      NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
  };

  // Ensure the condition is true, otherwise throw an error.
  // This is only to have a better contract semantic, i.e. another safety net
  // to catch a logic error. The condition shall be fulfilled in normal case.
  // Do NOT use this to enforce a certain condition on any user input.

  function assert(condition, message) {
      if (!condition) {
          throw new Error('ASSERT: ' + message);
      }
  }

  function isDecimalDigit(ch) {
      return (ch >= 0x30 && ch <= 0x39);   // 0..9
  }

  function isHexDigit(ch) {
      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
  }

  function isOctalDigit(ch) {
      return '01234567'.indexOf(ch) >= 0;
  }

  // 7.2 White Space

  function isWhiteSpace(ch) {
      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
  }

  // 7.3 Line Terminators

  function isLineTerminator(ch) {
      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
  }

  // 7.6 Identifier Names and Identifiers

  function isIdentifierStart(ch) {
      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
          (ch === 0x5C) ||                      // \ (backslash)
          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
  }

  function isIdentifierPart(ch) {
      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
          (ch >= 0x30 && ch <= 0x39) ||         // 0..9
          (ch === 0x5C) ||                      // \ (backslash)
          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
  }

  // 7.6.1.2 Future Reserved Words

  function isFutureReservedWord(id) {
      switch (id) {
      case 'class':
      case 'enum':
      case 'export':
      case 'extends':
      case 'import':
      case 'super':
          return true;
      default:
          return false;
      }
  }

  function isStrictModeReservedWord(id) {
      switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'yield':
      case 'let':
          return true;
      default:
          return false;
      }
  }

  // 7.6.1.1 Keywords

  function isKeyword(id) {
      if (strict && isStrictModeReservedWord(id)) {
          return true;
      }

      // 'const' is specialized as Keyword in V8.
      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
      // Some others are from future reserved words.

      switch (id.length) {
      case 2:
          return (id === 'if') || (id === 'in') || (id === 'do');
      case 3:
          return (id === 'var') || (id === 'for') || (id === 'new') ||
              (id === 'try') || (id === 'let');
      case 4:
          return (id === 'this') || (id === 'else') || (id === 'case') ||
              (id === 'void') || (id === 'with') || (id === 'enum');
      case 5:
          return (id === 'while') || (id === 'break') || (id === 'catch') ||
              (id === 'throw') || (id === 'const') || (id === 'yield') ||
              (id === 'class') || (id === 'super');
      case 6:
          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
              (id === 'switch') || (id === 'export') || (id === 'import');
      case 7:
          return (id === 'default') || (id === 'finally') || (id === 'extends');
      case 8:
          return (id === 'function') || (id === 'continue') || (id === 'debugger');
      case 10:
          return (id === 'instanceof');
      default:
          return false;
      }
  }

  function skipComment() {
      var ch, start;

      start = (index === 0);
      while (index < length) {
          ch = source.charCodeAt(index);

          if (isWhiteSpace(ch)) {
              ++index;
          } else if (isLineTerminator(ch)) {
              ++index;
              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                  ++index;
              }
              ++lineNumber;
              lineStart = index;
              start = true;
          } else {
              break;
          }
      }
  }

  function scanHexEscape(prefix) {
      var i, len, ch, code = 0;

      len = (prefix === 'u') ? 4 : 2;
      for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
              ch = source[index++];
              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
          } else {
              return '';
          }
      }
      return String.fromCharCode(code);
  }

  function scanUnicodeCodePointEscape() {
      var ch, code, cu1, cu2;

      ch = source[index];
      code = 0;

      // At least, one hex digit is required.
      if (ch === '}') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      while (index < length) {
          ch = source[index++];
          if (!isHexDigit(ch)) {
              break;
          }
          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
      }

      if (code > 0x10FFFF || ch !== '}') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      // UTF-16 Encoding
      if (code <= 0xFFFF) {
          return String.fromCharCode(code);
      }
      cu1 = ((code - 0x10000) >> 10) + 0xD800;
      cu2 = ((code - 0x10000) & 1023) + 0xDC00;
      return String.fromCharCode(cu1, cu2);
  }

  function getEscapedIdentifier() {
      var ch, id;

      ch = source.charCodeAt(index++);
      id = String.fromCharCode(ch);

      // '\u' (U+005C, U+0075) denotes an escaped character.
      if (ch === 0x5C) {
          if (source.charCodeAt(index) !== 0x75) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          ++index;
          ch = scanHexEscape('u');
          if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          id = ch;
      }

      while (index < length) {
          ch = source.charCodeAt(index);
          if (!isIdentifierPart(ch)) {
              break;
          }
          ++index;
          id += String.fromCharCode(ch);

          // '\u' (U+005C, U+0075) denotes an escaped character.
          if (ch === 0x5C) {
              id = id.substr(0, id.length - 1);
              if (source.charCodeAt(index) !== 0x75) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              ++index;
              ch = scanHexEscape('u');
              if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              id += ch;
          }
      }

      return id;
  }

  function getIdentifier() {
      var start, ch;

      start = index++;
      while (index < length) {
          ch = source.charCodeAt(index);
          if (ch === 0x5C) {
              // Blackslash (U+005C) marks Unicode escape sequence.
              index = start;
              return getEscapedIdentifier();
          }
          if (isIdentifierPart(ch)) {
              ++index;
          } else {
              break;
          }
      }

      return source.slice(start, index);
  }

  function scanIdentifier() {
      var start, id, type;

      start = index;

      // Backslash (U+005C) starts an escaped character.
      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

      // There is no keyword or literal with only one character.
      // Thus, it must be an identifier.
      if (id.length === 1) {
          type = Token.Identifier;
      } else if (isKeyword(id)) {
          type = Token.Keyword;
      } else if (id === 'null') {
          type = Token.NullLiteral;
      } else if (id === 'true' || id === 'false') {
          type = Token.BooleanLiteral;
      } else {
          type = Token.Identifier;
      }

      return {
          type: type,
          value: id,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  // 7.7 Punctuators

  function scanPunctuator() {
      var start = index,
          code = source.charCodeAt(index),
          code2,
          ch1 = source[index],
          ch2,
          ch3,
          ch4;

      switch (code) {

      // Check for most common single-character punctuators.
      case 0x2E:  // . dot
      case 0x28:  // ( open bracket
      case 0x29:  // ) close bracket
      case 0x3B:  // ; semicolon
      case 0x2C:  // , comma
      case 0x7B:  // { open curly brace
      case 0x7D:  // } close curly brace
      case 0x5B:  // [
      case 0x5D:  // ]
      case 0x3A:  // :
      case 0x3F:  // ?
      case 0x7E:  // ~
          ++index;
          if (extra.tokenize) {
              if (code === 0x28) {
                  extra.openParenToken = extra.tokens.length;
              } else if (code === 0x7B) {
                  extra.openCurlyToken = extra.tokens.length;
              }
          }
          return {
              type: Token.Punctuator,
              value: String.fromCharCode(code),
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };

      default:
          code2 = source.charCodeAt(index + 1);

          // '=' (U+003D) marks an assignment or comparison operator.
          if (code2 === 0x3D) {
              switch (code) {
              case 0x2B:  // +
              case 0x2D:  // -
              case 0x2F:  // /
              case 0x3C:  // <
              case 0x3E:  // >
              case 0x5E:  // ^
              case 0x7C:  // |
              case 0x25:  // %
              case 0x26:  // &
              case 0x2A:  // *
                  index += 2;
                  return {
                      type: Token.Punctuator,
                      value: String.fromCharCode(code) + String.fromCharCode(code2),
                      lineNumber: lineNumber,
                      lineStart: lineStart,
                      start: start,
                      end: index
                  };

              case 0x21: // !
              case 0x3D: // =
                  index += 2;

                  // !== and ===
                  if (source.charCodeAt(index) === 0x3D) {
                      ++index;
                  }
                  return {
                      type: Token.Punctuator,
                      value: source.slice(start, index),
                      lineNumber: lineNumber,
                      lineStart: lineStart,
                      start: start,
                      end: index
                  };
              }
          }
      }

      // 4-character punctuator: >>>=

      ch4 = source.substr(index, 4);

      if (ch4 === '>>>=') {
          index += 4;
          return {
              type: Token.Punctuator,
              value: ch4,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // 3-character punctuators: === !== >>> <<= >>=

      ch3 = ch4.substr(0, 3);

      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
          index += 3;
          return {
              type: Token.Punctuator,
              value: ch3,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // Other 2-character punctuators: ++ -- << >> && ||
      ch2 = ch3.substr(0, 2);

      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
          index += 2;
          return {
              type: Token.Punctuator,
              value: ch2,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      // 1-character punctuators: < > = ! + - * % & | ^ /

      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
          ++index;
          return {
              type: Token.Punctuator,
              value: ch1,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
  }

  // 7.8.3 Numeric Literals

  function scanHexLiteral(start) {
      var number = '';

      while (index < length) {
          if (!isHexDigit(source[index])) {
              break;
          }
          number += source[index++];
      }

      if (number.length === 0) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseInt('0x' + number, 16),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function scanOctalLiteral(start) {
      var number = '0' + source[index++];
      while (index < length) {
          if (!isOctalDigit(source[index])) {
              break;
          }
          number += source[index++];
      }

      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseInt(number, 8),
          octal: true,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function scanNumericLiteral() {
      var number, start, ch;

      ch = source[index];
      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
          'Numeric literal must start with a decimal digit or a decimal point');

      start = index;
      number = '';
      if (ch !== '.') {
          number = source[index++];
          ch = source[index];

          // Hex number starts with '0x'.
          // Octal number starts with '0'.
          if (number === '0') {
              if (ch === 'x' || ch === 'X') {
                  ++index;
                  return scanHexLiteral(start);
              }
              if (isOctalDigit(ch)) {
                  return scanOctalLiteral(start);
              }

              // decimal number starts with '0' such as '09' is illegal.
              if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
          }

          while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
          }
          ch = source[index];
      }

      if (ch === '.') {
          number += source[index++];
          while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
          }
          ch = source[index];
      }

      if (ch === 'e' || ch === 'E') {
          number += source[index++];

          ch = source[index];
          if (ch === '+' || ch === '-') {
              number += source[index++];
          }
          if (isDecimalDigit(source.charCodeAt(index))) {
              while (isDecimalDigit(source.charCodeAt(index))) {
                  number += source[index++];
              }
          } else {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
      }

      if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  // 7.8.4 String Literals

  function scanStringLiteral() {
      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
      startLineNumber = lineNumber;
      startLineStart = lineStart;

      quote = source[index];
      assert((quote === '\'' || quote === '"'),
          'String literal must starts with a quote');

      start = index;
      ++index;

      while (index < length) {
          ch = source[index++];

          if (ch === quote) {
              quote = '';
              break;
          } else if (ch === '\\') {
              ch = source[index++];
              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                  case 'u':
                  case 'x':
                      if (source[index] === '{') {
                          ++index;
                          str += scanUnicodeCodePointEscape();
                      } else {
                          restore = index;
                          unescaped = scanHexEscape(ch);
                          if (unescaped) {
                              str += unescaped;
                          } else {
                              index = restore;
                              str += ch;
                          }
                      }
                      break;
                  case 'n':
                      str += '\n';
                      break;
                  case 'r':
                      str += '\r';
                      break;
                  case 't':
                      str += '\t';
                      break;
                  case 'b':
                      str += '\b';
                      break;
                  case 'f':
                      str += '\f';
                      break;
                  case 'v':
                      str += '\x0B';
                      break;

                  default:
                      if (isOctalDigit(ch)) {
                          code = '01234567'.indexOf(ch);

                          // \0 is not octal escape sequence
                          if (code !== 0) {
                              octal = true;
                          }

                          if (index < length && isOctalDigit(source[index])) {
                              octal = true;
                              code = code * 8 + '01234567'.indexOf(source[index++]);

                              // 3 digits are only allowed when string starts
                              // with 0, 1, 2, 3
                              if ('0123'.indexOf(ch) >= 0 &&
                                      index < length &&
                                      isOctalDigit(source[index])) {
                                  code = code * 8 + '01234567'.indexOf(source[index++]);
                              }
                          }
                          str += String.fromCharCode(code);
                      } else {
                          str += ch;
                      }
                      break;
                  }
              } else {
                  ++lineNumber;
                  if (ch ===  '\r' && source[index] === '\n') {
                      ++index;
                  }
                  lineStart = index;
              }
          } else if (isLineTerminator(ch.charCodeAt(0))) {
              break;
          } else {
              str += ch;
          }
      }

      if (quote !== '') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }

      return {
          type: Token.StringLiteral,
          value: str,
          octal: octal,
          startLineNumber: startLineNumber,
          startLineStart: startLineStart,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
      };
  }

  function testRegExp(pattern, flags) {
      var tmp = pattern,
          value;

      if (flags.indexOf('u') >= 0) {
          // Replace each astral symbol and every Unicode code point
          // escape sequence with a single ASCII symbol to avoid throwing on
          // regular expressions that are only valid in combination with the
          // `/u` flag.
          // Note: replacing with the ASCII symbol `x` might cause false
          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
          // perfectly valid pattern that is equivalent to `[a-b]`, but it
          // would be replaced by `[x-b]` which throws an error.
          tmp = tmp
              .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                  if (parseInt($1, 16) <= 0x10FFFF) {
                      return 'x';
                  }
                  throwError({}, Messages.InvalidRegExp);
              })
              .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
      }

      // First, detect invalid regular expressions.
      try {
          value = new RegExp(tmp);
      } catch (e) {
          throwError({}, Messages.InvalidRegExp);
      }

      // Return a regular expression object for this pattern-flag pair, or
      // `null` in case the current environment doesn't support the flags it
      // uses.
      try {
          return new RegExp(pattern, flags);
      } catch (exception) {
          return null;
      }
  }

  function scanRegExpBody() {
      var ch, str, classMarker, terminated, body;

      ch = source[index];
      assert(ch === '/', 'Regular expression literal must start with a slash');
      str = source[index++];

      classMarker = false;
      terminated = false;
      while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === '\\') {
              ch = source[index++];
              // ECMA-262 7.8.5
              if (isLineTerminator(ch.charCodeAt(0))) {
                  throwError({}, Messages.UnterminatedRegExp);
              }
              str += ch;
          } else if (isLineTerminator(ch.charCodeAt(0))) {
              throwError({}, Messages.UnterminatedRegExp);
          } else if (classMarker) {
              if (ch === ']') {
                  classMarker = false;
              }
          } else {
              if (ch === '/') {
                  terminated = true;
                  break;
              } else if (ch === '[') {
                  classMarker = true;
              }
          }
      }

      if (!terminated) {
          throwError({}, Messages.UnterminatedRegExp);
      }

      // Exclude leading and trailing slash.
      body = str.substr(1, str.length - 2);
      return {
          value: body,
          literal: str
      };
  }

  function scanRegExpFlags() {
      var ch, str, flags, restore;

      str = '';
      flags = '';
      while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch.charCodeAt(0))) {
              break;
          }

          ++index;
          if (ch === '\\' && index < length) {
              ch = source[index];
              if (ch === 'u') {
                  ++index;
                  restore = index;
                  ch = scanHexEscape('u');
                  if (ch) {
                      flags += ch;
                      for (str += '\\u'; restore < index; ++restore) {
                          str += source[restore];
                      }
                  } else {
                      index = restore;
                      flags += 'u';
                      str += '\\u';
                  }
                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
              } else {
                  str += '\\';
                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
          } else {
              flags += ch;
              str += ch;
          }
      }

      return {
          value: flags,
          literal: str
      };
  }

  function scanRegExp() {
      var start, body, flags, value;

      lookahead = null;
      skipComment();
      start = index;

      body = scanRegExpBody();
      flags = scanRegExpFlags();
      value = testRegExp(body.value, flags.value);

      if (extra.tokenize) {
          return {
              type: Token.RegularExpression,
              value: value,
              regex: {
                  pattern: body.value,
                  flags: flags.value
              },
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
          };
      }

      return {
          literal: body.literal + flags.literal,
          value: value,
          regex: {
              pattern: body.value,
              flags: flags.value
          },
          start: start,
          end: index
      };
  }

  function collectRegex() {
      var pos, loc, regex, token;

      skipComment();

      pos = index;
      loc = {
          start: {
              line: lineNumber,
              column: index - lineStart
          }
      };

      regex = scanRegExp();

      loc.end = {
          line: lineNumber,
          column: index - lineStart
      };

      if (!extra.tokenize) {
          // Pop the previous token, which is likely '/' or '/='
          if (extra.tokens.length > 0) {
              token = extra.tokens[extra.tokens.length - 1];
              if (token.range[0] === pos && token.type === 'Punctuator') {
                  if (token.value === '/' || token.value === '/=') {
                      extra.tokens.pop();
                  }
              }
          }

          extra.tokens.push({
              type: 'RegularExpression',
              value: regex.literal,
              regex: regex.regex,
              range: [pos, index],
              loc: loc
          });
      }

      return regex;
  }

  function isIdentifierName(token) {
      return token.type === Token.Identifier ||
          token.type === Token.Keyword ||
          token.type === Token.BooleanLiteral ||
          token.type === Token.NullLiteral;
  }

  function advanceSlash() {
      var prevToken,
          checkToken;
      // Using the following algorithm:
      // https://github.com/mozilla/sweet.js/wiki/design
      prevToken = extra.tokens[extra.tokens.length - 1];
      if (!prevToken) {
          // Nothing before that: it cannot be a division.
          return collectRegex();
      }
      if (prevToken.type === 'Punctuator') {
          if (prevToken.value === ']') {
              return scanPunctuator();
          }
          if (prevToken.value === ')') {
              checkToken = extra.tokens[extra.openParenToken - 1];
              if (checkToken &&
                      checkToken.type === 'Keyword' &&
                      (checkToken.value === 'if' ||
                       checkToken.value === 'while' ||
                       checkToken.value === 'for' ||
                       checkToken.value === 'with')) {
                  return collectRegex();
              }
              return scanPunctuator();
          }
          if (prevToken.value === '}') {
              // Dividing a function by anything makes little sense,
              // but we have to check for that.
              if (extra.tokens[extra.openCurlyToken - 3] &&
                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                  // Anonymous function.
                  checkToken = extra.tokens[extra.openCurlyToken - 4];
                  if (!checkToken) {
                      return scanPunctuator();
                  }
              } else if (extra.tokens[extra.openCurlyToken - 4] &&
                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                  // Named function.
                  checkToken = extra.tokens[extra.openCurlyToken - 5];
                  if (!checkToken) {
                      return collectRegex();
                  }
              } else {
                  return scanPunctuator();
              }
              return scanPunctuator();
          }
          return collectRegex();
      }
      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
          return collectRegex();
      }
      return scanPunctuator();
  }

  function advance() {
      var ch;

      skipComment();

      if (index >= length) {
          return {
              type: Token.EOF,
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: index,
              end: index
          };
      }

      ch = source.charCodeAt(index);

      if (isIdentifierStart(ch)) {
          return scanIdentifier();
      }

      // Very common: ( and ) and ;
      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
          return scanPunctuator();
      }

      // String literal starts with single quote (U+0027) or double quote (U+0022).
      if (ch === 0x27 || ch === 0x22) {
          return scanStringLiteral();
      }


      // Dot (.) U+002E can also start a floating-point number, hence the need
      // to check the next character.
      if (ch === 0x2E) {
          if (isDecimalDigit(source.charCodeAt(index + 1))) {
              return scanNumericLiteral();
          }
          return scanPunctuator();
      }

      if (isDecimalDigit(ch)) {
          return scanNumericLiteral();
      }

      // Slash (/) U+002F can also start a regex.
      if (extra.tokenize && ch === 0x2F) {
          return advanceSlash();
      }

      return scanPunctuator();
  }

  function collectToken() {
      var loc, token, value, entry;

      skipComment();
      loc = {
          start: {
              line: lineNumber,
              column: index - lineStart
          }
      };

      token = advance();
      loc.end = {
          line: lineNumber,
          column: index - lineStart
      };

      if (token.type !== Token.EOF) {
          value = source.slice(token.start, token.end);
          entry = {
              type: TokenName[token.type],
              value: value,
              range: [token.start, token.end],
              loc: loc
          };
          if (token.regex) {
              entry.regex = {
                  pattern: token.regex.pattern,
                  flags: token.regex.flags
              };
          }
          extra.tokens.push(entry);
      }

      return token;
  }

  function lex() {
      var token;

      token = lookahead;
      index = token.end;
      lineNumber = token.lineNumber;
      lineStart = token.lineStart;

      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

      index = token.end;
      lineNumber = token.lineNumber;
      lineStart = token.lineStart;

      return token;
  }

  function peek() {
      var pos, line, start;

      pos = index;
      line = lineNumber;
      start = lineStart;
      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
      index = pos;
      lineNumber = line;
      lineStart = start;
  }

  function Position() {
      this.line = lineNumber;
      this.column = index - lineStart;
  }

  function SourceLocation() {
      this.start = new Position();
      this.end = null;
  }

  function WrappingSourceLocation(startToken) {
      if (startToken.type === Token.StringLiteral) {
          this.start = {
              line: startToken.startLineNumber,
              column: startToken.start - startToken.startLineStart
          };
      } else {
          this.start = {
              line: startToken.lineNumber,
              column: startToken.start - startToken.lineStart
          };
      }
      this.end = null;
  }

  function Node() {
      // Skip comment.
      index = lookahead.start;
      if (lookahead.type === Token.StringLiteral) {
          lineNumber = lookahead.startLineNumber;
          lineStart = lookahead.startLineStart;
      } else {
          lineNumber = lookahead.lineNumber;
          lineStart = lookahead.lineStart;
      }
      if (extra.range) {
          this.range = [index, 0];
      }
      if (extra.loc) {
          this.loc = new SourceLocation();
      }
  }

  function WrappingNode(startToken) {
      if (extra.range) {
          this.range = [startToken.start, 0];
      }
      if (extra.loc) {
          this.loc = new WrappingSourceLocation(startToken);
      }
  }

  WrappingNode.prototype = Node.prototype = {

      finish: function () {
          if (extra.range) {
              this.range[1] = index;
          }
          if (extra.loc) {
              this.loc.end = new Position();
              if (extra.source) {
                  this.loc.source = extra.source;
              }
          }
      },

      finishArrayExpression: function (elements) {
          this.type = Syntax.ArrayExpression;
          this.elements = elements;
          this.finish();
          return this;
      },

      finishAssignmentExpression: function (operator, left, right) {
          this.type = Syntax.AssignmentExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
      },

      finishBinaryExpression: function (operator, left, right) {
          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
          this.finish();
          return this;
      },

      finishCallExpression: function (callee, args) {
          this.type = Syntax.CallExpression;
          this.callee = callee;
          this.arguments = args;
          this.finish();
          return this;
      },

      finishConditionalExpression: function (test, consequent, alternate) {
          this.type = Syntax.ConditionalExpression;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
          this.finish();
          return this;
      },

      finishExpressionStatement: function (expression) {
          this.type = Syntax.ExpressionStatement;
          this.expression = expression;
          this.finish();
          return this;
      },

      finishIdentifier: function (name) {
          this.type = Syntax.Identifier;
          this.name = name;
          this.finish();
          return this;
      },

      finishLiteral: function (token) {
          this.type = Syntax.Literal;
          this.value = token.value;
          this.raw = source.slice(token.start, token.end);
          if (token.regex) {
              if (this.raw == '//') {
                this.raw = '/(?:)/';
              }
              this.regex = token.regex;
          }
          this.finish();
          return this;
      },

      finishMemberExpression: function (accessor, object, property) {
          this.type = Syntax.MemberExpression;
          this.computed = accessor === '[';
          this.object = object;
          this.property = property;
          this.finish();
          return this;
      },

      finishObjectExpression: function (properties) {
          this.type = Syntax.ObjectExpression;
          this.properties = properties;
          this.finish();
          return this;
      },

      finishProgram: function (body) {
          this.type = Syntax.Program;
          this.body = body;
          this.finish();
          return this;
      },

      finishProperty: function (kind, key, value) {
          this.type = Syntax.Property;
          this.key = key;
          this.value = value;
          this.kind = kind;
          this.finish();
          return this;
      },

      finishUnaryExpression: function (operator, argument) {
          this.type = Syntax.UnaryExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = true;
          this.finish();
          return this;
      }
  };

  // Return true if there is a line terminator before the next token.

  function peekLineTerminator() {
      var pos, line, start, found;

      pos = index;
      line = lineNumber;
      start = lineStart;
      skipComment();
      found = lineNumber !== line;
      index = pos;
      lineNumber = line;
      lineStart = start;

      return found;
  }

  // Throw an exception

  function throwError(token, messageFormat) {
      var error,
          args = Array.prototype.slice.call(arguments, 2),
          msg = messageFormat.replace(
              /%(\d)/g,
              function (whole, index) {
                  assert(index < args.length, 'Message reference must be in range');
                  return args[index];
              }
          );

      if (typeof token.lineNumber === 'number') {
          error = new Error('Line ' + token.lineNumber + ': ' + msg);
          error.index = token.start;
          error.lineNumber = token.lineNumber;
          error.column = token.start - lineStart + 1;
      } else {
          error = new Error('Line ' + lineNumber + ': ' + msg);
          error.index = index;
          error.lineNumber = lineNumber;
          error.column = index - lineStart + 1;
      }

      error.description = msg;
      throw error;
  }

  function throwErrorTolerant() {
      try {
          throwError.apply(null, arguments);
      } catch (e) {
          if (extra.errors) {
              extra.errors.push(e);
          } else {
              throw e;
          }
      }
  }


  // Throw an exception because of the token.

  function throwUnexpected(token) {
      if (token.type === Token.EOF) {
          throwError(token, Messages.UnexpectedEOS);
      }

      if (token.type === Token.NumericLiteral) {
          throwError(token, Messages.UnexpectedNumber);
      }

      if (token.type === Token.StringLiteral) {
          throwError(token, Messages.UnexpectedString);
      }

      if (token.type === Token.Identifier) {
          throwError(token, Messages.UnexpectedIdentifier);
      }

      if (token.type === Token.Keyword) {
          if (isFutureReservedWord(token.value)) {
              throwError(token, Messages.UnexpectedReserved);
          } else if (strict && isStrictModeReservedWord(token.value)) {
              throwErrorTolerant(token, Messages.StrictReservedWord);
              return;
          }
          throwError(token, Messages.UnexpectedToken, token.value);
      }

      // BooleanLiteral, NullLiteral, or Punctuator.
      throwError(token, Messages.UnexpectedToken, token.value);
  }

  // Expect the next token to match the specified punctuator.
  // If not, an exception will be thrown.

  function expect(value) {
      var token = lex();
      if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpected(token);
      }
  }

  /**
   * @name expectTolerant
   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates
   * to <code>expect(value)</code>
   * @param {String} value The value we are expecting the lookahead token to have
   * @since 2.0
   */
  function expectTolerant(value) {
      if (extra.errors) {
          var token = lookahead;
          if (token.type !== Token.Punctuator && token.value !== value) {
              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
          } else {
              lex();
          }
      } else {
          expect(value);
      }
  }

  // Return true if the next token matches the specified punctuator.

  function match(value) {
      return lookahead.type === Token.Punctuator && lookahead.value === value;
  }

  // Return true if the next token matches the specified keyword

  function matchKeyword(keyword) {
      return lookahead.type === Token.Keyword && lookahead.value === keyword;
  }

  function consumeSemicolon() {
      var line;

      // Catch the very common case first: immediately a semicolon (U+003B).
      if (source.charCodeAt(index) === 0x3B || match(';')) {
          lex();
          return;
      }

      line = lineNumber;
      skipComment();
      if (lineNumber !== line) {
          return;
      }

      if (lookahead.type !== Token.EOF && !match('}')) {
          throwUnexpected(lookahead);
      }
  }

  // 11.1.4 Array Initialiser

  function parseArrayInitialiser() {
      var elements = [], node = new Node();

      expect('[');

      while (!match(']')) {
          if (match(',')) {
              lex();
              elements.push(null);
          } else {
              elements.push(parseAssignmentExpression());

              if (!match(']')) {
                  expect(',');
              }
          }
      }

      lex();

      return node.finishArrayExpression(elements);
  }

  // 11.1.5 Object Initialiser

  function parseObjectPropertyKey() {
      var token, node = new Node();

      token = lex();

      // Note: This function is called only from parseObjectProperty(), where
      // EOF and Punctuator tokens are already filtered out.

      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
              throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return node.finishLiteral(token);
      }

      return node.finishIdentifier(token.value);
  }

  function parseObjectProperty() {
      var token, key, id, value, node = new Node();

      token = lookahead;

      if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          expect(':');
          value = parseAssignmentExpression();
          return node.finishProperty('init', id, value);
      }
      if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpected(token);
      } else {
          key = parseObjectPropertyKey();
          expect(':');
          value = parseAssignmentExpression();
          return node.finishProperty('init', key, value);
      }
  }

  function parseObjectInitialiser() {
      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();

      expect('{');

      while (!match('}')) {
          property = parseObjectProperty();

          if (property.key.type === Syntax.Identifier) {
              name = property.key.name;
          } else {
              name = toString(property.key.value);
          }
          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

          key = '$' + name;
          if (Object.prototype.hasOwnProperty.call(map, key)) {
              if (map[key] === PropertyKind.Data) {
                  if (strict && kind === PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                  } else if (kind !== PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.AccessorDataProperty);
                  }
              } else {
                  if (kind === PropertyKind.Data) {
                      throwErrorTolerant({}, Messages.AccessorDataProperty);
                  } else if (map[key] & kind) {
                      throwErrorTolerant({}, Messages.AccessorGetSet);
                  }
              }
              map[key] |= kind;
          } else {
              map[key] = kind;
          }

          properties.push(property);

          if (!match('}')) {
              expectTolerant(',');
          }
      }

      expect('}');

      return node.finishObjectExpression(properties);
  }

  // 11.1.6 The Grouping Operator

  function parseGroupExpression() {
      var expr;

      expect('(');

      ++state.parenthesisCount;

      expr = parseExpression();

      expect(')');

      return expr;
  }


  // 11.1 Primary Expressions

  var legalKeywords = {"if":1, "this":1};

  function parsePrimaryExpression() {
      var type, token, expr, node;

      if (match('(')) {
          return parseGroupExpression();
      }

      if (match('[')) {
          return parseArrayInitialiser();
      }

      if (match('{')) {
          return parseObjectInitialiser();
      }

      type = lookahead.type;
      node = new Node();

      if (type === Token.Identifier || legalKeywords[lookahead.value]) {
          expr = node.finishIdentifier(lex().value);
      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && lookahead.octal) {
              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
          }
          expr = node.finishLiteral(lex());
      } else if (type === Token.Keyword) {
          throw new Error("Disabled.");
      } else if (type === Token.BooleanLiteral) {
          token = lex();
          token.value = (token.value === 'true');
          expr = node.finishLiteral(token);
      } else if (type === Token.NullLiteral) {
          token = lex();
          token.value = null;
          expr = node.finishLiteral(token);
      } else if (match('/') || match('/=')) {
          if (typeof extra.tokens !== 'undefined') {
              expr = node.finishLiteral(collectRegex());
          } else {
              expr = node.finishLiteral(scanRegExp());
          }
          peek();
      } else {
          throwUnexpected(lex());
      }

      return expr;
  }

  // 11.2 Left-Hand-Side Expressions

  function parseArguments() {
      var args = [];

      expect('(');

      if (!match(')')) {
          while (index < length) {
              args.push(parseAssignmentExpression());
              if (match(')')) {
                  break;
              }
              expectTolerant(',');
          }
      }

      expect(')');

      return args;
  }

  function parseNonComputedProperty() {
      var token, node = new Node();

      token = lex();

      if (!isIdentifierName(token)) {
          throwUnexpected(token);
      }

      return node.finishIdentifier(token.value);
  }

  function parseNonComputedMember() {
      expect('.');

      return parseNonComputedProperty();
  }

  function parseComputedMember() {
      var expr;

      expect('[');

      expr = parseExpression();

      expect(']');

      return expr;
  }

  function parseLeftHandSideExpressionAllowCall() {
      var expr, args, property, startToken, previousAllowIn = state.allowIn;

      startToken = lookahead;
      state.allowIn = true;
      expr = parsePrimaryExpression();

      for (;;) {
          if (match('.')) {
              property = parseNonComputedMember();
              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
          } else if (match('(')) {
              args = parseArguments();
              expr = new WrappingNode(startToken).finishCallExpression(expr, args);
          } else if (match('[')) {
              property = parseComputedMember();
              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
          } else {
              break;
          }
      }
      state.allowIn = previousAllowIn;

      return expr;
  }

  // 11.3 Postfix Expressions

  function parsePostfixExpression() {
      var expr = parseLeftHandSideExpressionAllowCall();

      if (lookahead.type === Token.Punctuator) {
          if ((match('++') || match('--')) && !peekLineTerminator()) {
              throw new Error("Disabled.");
          }
      }

      return expr;
  }

  // 11.4 Unary Operators

  function parseUnaryExpression() {
      var token, expr, startToken;

      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
          expr = parsePostfixExpression();
      } else if (match('++') || match('--')) {
          throw new Error("Disabled.");
      } else if (match('+') || match('-') || match('~') || match('!')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
          throw new Error("Disabled.");
      } else {
          expr = parsePostfixExpression();
      }

      return expr;
  }

  function binaryPrecedence(token, allowIn) {
      var prec = 0;

      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return 0;
      }

      switch (token.value) {
      case '||':
          prec = 1;
          break;

      case '&&':
          prec = 2;
          break;

      case '|':
          prec = 3;
          break;

      case '^':
          prec = 4;
          break;

      case '&':
          prec = 5;
          break;

      case '==':
      case '!=':
      case '===':
      case '!==':
          prec = 6;
          break;

      case '<':
      case '>':
      case '<=':
      case '>=':
      case 'instanceof':
          prec = 7;
          break;

      case 'in':
          prec = allowIn ? 7 : 0;
          break;

      case '<<':
      case '>>':
      case '>>>':
          prec = 8;
          break;

      case '+':
      case '-':
          prec = 9;
          break;

      case '*':
      case '/':
      case '%':
          prec = 11;
          break;

      default:
          break;
      }

      return prec;
  }

  // 11.5 Multiplicative Operators
  // 11.6 Additive Operators
  // 11.7 Bitwise Shift Operators
  // 11.8 Relational Operators
  // 11.9 Equality Operators
  // 11.10 Binary Bitwise Operators
  // 11.11 Binary Logical Operators

  function parseBinaryExpression() {
      var marker, markers, expr, token, prec, stack, right, operator, left, i;

      marker = lookahead;
      left = parseUnaryExpression();

      token = lookahead;
      prec = binaryPrecedence(token, state.allowIn);
      if (prec === 0) {
          return left;
      }
      token.prec = prec;
      lex();

      markers = [marker, lookahead];
      right = parseUnaryExpression();

      stack = [left, token, right];

      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

          // Reduce: make a binary expression from the three topmost entries.
          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
              right = stack.pop();
              operator = stack.pop().value;
              left = stack.pop();
              markers.pop();
              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
              stack.push(expr);
          }

          // Shift.
          token = lex();
          token.prec = prec;
          stack.push(token);
          markers.push(lookahead);
          expr = parseUnaryExpression();
          stack.push(expr);
      }

      // Final reduce to clean-up the stack.
      i = stack.length - 1;
      expr = stack[i];
      markers.pop();
      while (i > 1) {
          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
          i -= 2;
      }

      return expr;
  }

  // 11.12 Conditional Operator

  function parseConditionalExpression() {
      var expr, previousAllowIn, consequent, alternate, startToken;

      startToken = lookahead;

      expr = parseBinaryExpression();

      if (match('?')) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(':');
          alternate = parseAssignmentExpression();

          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
      }

      return expr;
  }

  // 11.13 Assignment Operators

  function parseAssignmentExpression() {
      var oldParenthesisCount, token, expr, startToken;

      oldParenthesisCount = state.parenthesisCount;

      startToken = lookahead;
      token = lookahead;

      expr = parseConditionalExpression();

      return expr;
  }

  // 11.14 Comma Operator

  function parseExpression() {
      var expr = parseAssignmentExpression();

      if (match(',')) {
          throw new Error("Disabled."); // no sequence expressions
      }

      return expr;
  }

  // 12.4 Expression Statement

  function parseExpressionStatement(node) {
      var expr = parseExpression();
      consumeSemicolon();
      return node.finishExpressionStatement(expr);
  }

  // 12 Statements

  function parseStatement() {
      var type = lookahead.type,
          expr,
          node;

      if (type === Token.EOF) {
          throwUnexpected(lookahead);
      }

      if (type === Token.Punctuator && lookahead.value === '{') {
          throw new Error("Disabled."); // block statement
      }

      node = new Node();

      if (type === Token.Punctuator) {
          switch (lookahead.value) {
          case ';':
              throw new Error("Disabled."); // empty statement
          case '(':
              return parseExpressionStatement(node);
          default:
              break;
          }
      } else if (type === Token.Keyword) {
          throw new Error("Disabled."); // keyword
      }

      expr = parseExpression();
      consumeSemicolon();
      return node.finishExpressionStatement(expr);
  }

  // 14 Program

  function parseSourceElement() {
      if (lookahead.type === Token.Keyword) {
          switch (lookahead.value) {
          case 'const':
          case 'let':
              throw new Error("Disabled.");
          case 'function':
              throw new Error("Disabled.");
          default:
              return parseStatement();
          }
      }

      if (lookahead.type !== Token.EOF) {
          return parseStatement();
      }
  }

  function parseSourceElements() {
      var sourceElement, sourceElements = [], token, directive, firstRestricted;

      while (index < length) {
          token = lookahead;
          if (token.type !== Token.StringLiteral) {
              break;
          }

          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
              // this is not directive
              break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
              strict = true;
              if (firstRestricted) {
                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
              }
          } else {
              if (!firstRestricted && token.octal) {
                  firstRestricted = token;
              }
          }
      }

      while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
              break;
          }
          sourceElements.push(sourceElement);
      }
      return sourceElements;
  }

  function parseProgram() {
      var body, node;

      skipComment();
      peek();
      node = new Node();
      strict = true; // assume strict

      body = parseSourceElements();
      return node.finishProgram(body);
  }

  function filterTokenLocation() {
      var i, entry, token, tokens = [];

      for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
              type: entry.type,
              value: entry.value
          };
          if (entry.regex) {
              token.regex = {
                  pattern: entry.regex.pattern,
                  flags: entry.regex.flags
              };
          }
          if (extra.range) {
              token.range = entry.range;
          }
          if (extra.loc) {
              token.loc = entry.loc;
          }
          tokens.push(token);
      }

      extra.tokens = tokens;
  }

  function tokenize(code, options) {
      var toString,
          tokens;

      toString = String;
      if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
      }

      source = code;
      index = 0;
      lineNumber = (source.length > 0) ? 1 : 0;
      lineStart = 0;
      length = source.length;
      lookahead = null;
      state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
      };

      extra = {};

      // Options matching.
      options = options || {};

      // Of course we collect tokens here.
      options.tokens = true;
      extra.tokens = [];
      extra.tokenize = true;
      // The following two fields are necessary to compute the Regex tokens.
      extra.openParenToken = -1;
      extra.openCurlyToken = -1;

      extra.range = (typeof options.range === 'boolean') && options.range;
      extra.loc = (typeof options.loc === 'boolean') && options.loc;

      if (typeof options.tolerant === 'boolean' && options.tolerant) {
          extra.errors = [];
      }

      try {
          peek();
          if (lookahead.type === Token.EOF) {
              return extra.tokens;
          }

          lex();
          while (lookahead.type !== Token.EOF) {
              try {
                  lex();
              } catch (lexError) {
                  if (extra.errors) {
                      extra.errors.push(lexError);
                      // We have to break on the first error
                      // to avoid infinite loops.
                      break;
                  } else {
                      throw lexError;
                  }
              }
          }

          filterTokenLocation();
          tokens = extra.tokens;
          if (typeof extra.errors !== 'undefined') {
              tokens.errors = extra.errors;
          }
      } catch (e) {
          throw e;
      } finally {
          extra = {};
      }
      return tokens;
  }

  function parse(code, options) {
      var program, toString;

      toString = String;
      if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
      }

      source = code;
      index = 0;
      lineNumber = (source.length > 0) ? 1 : 0;
      lineStart = 0;
      length = source.length;
      lookahead = null;
      state = {
          allowIn: true,
          labelSet: {},
          parenthesisCount: 0,
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
      };

      extra = {};
      if (typeof options !== 'undefined') {
          extra.range = (typeof options.range === 'boolean') && options.range;
          extra.loc = (typeof options.loc === 'boolean') && options.loc;

          if (extra.loc && options.source !== null && options.source !== undefined) {
              extra.source = toString(options.source);
          }

          if (typeof options.tokens === 'boolean' && options.tokens) {
              extra.tokens = [];
          }
          if (typeof options.tolerant === 'boolean' && options.tolerant) {
              extra.errors = [];
          }
      }

      try {
          program = parseProgram();
          if (typeof extra.tokens !== 'undefined') {
              filterTokenLocation();
              program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== 'undefined') {
              program.errors = extra.errors;
          }
      } catch (e) {
          throw e;
      } finally {
          extra = {};
      }

      return program;
  }

  return {
    tokenize: tokenize,
    parse: parse
  };

})();
},{}],147:[function(require,module,exports){
var ts = Date.now();

function write(msg) {
  msg = '[Vega Log] ' + msg;
  console.log(msg);
}

function error(msg) {
  msg = '[Vega Err] ' + msg;
  console.error(msg);
}

function debug(input, args) {
  if (!debug.enable) return;
  var log = Function.prototype.bind.call(console.log, console);
  var state = {
    prevTime:  Date.now() - ts,
    stamp: input.stamp
  };

  if (input.add) {
    state.add = input.add.length;
    state.mod = input.mod.length;
    state.rem = input.rem.length;
    state.reflow = !!input.reflow;
  }

  log.apply(console, (args.push(JSON.stringify(state)), args));
  ts = Date.now();
}

module.exports = {
  log:   write,
  error: error,
  debug: (debug.enable = false, debug)
};

},{}],148:[function(require,module,exports){
module.exports = {
  path:       require('./path'),
  render:     require('./render'),
  Item:       require('./util/Item'),
  bound:      require('./util/bound'),
  Bounds:     require('./util/Bounds'),
  canvas:     require('./util/canvas'),
  Gradient:   require('./util/Gradient'),
  toJSON:     require('./util/scene').toJSON,
  fromJSON:   require('./util/scene').fromJSON
};
},{"./path":150,"./render":170,"./util/Bounds":176,"./util/Gradient":178,"./util/Item":180,"./util/bound":181,"./util/canvas":182,"./util/scene":184}],149:[function(require,module,exports){
var segmentCache = {},
    bezierCache = {},
    join = [].join;

// Copied from Inkscape svgtopdf, thanks!
function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var key = join.call(arguments);
  if (segmentCache[key]) {
    return segmentCache[key];
  }

  var th = rotateX * (Math.PI/180);
  var sin_th = Math.sin(th);
  var cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  var a00 = cos_th / rx;
  var a01 = sin_th / rx;
  var a10 = (-sin_th) / ry;
  var a11 = (cos_th) / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;

  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
  var sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  var sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);

  var th0 = Math.atan2(y0-yc, x0-xc);
  var th1 = Math.atan2(y1-yc, x1-xc);

  var th_arc = th1-th0;
  if (th_arc < 0 && sweep === 1){
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }

  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
  var result = [];
  for (var i=0; i<segs; ++i) {
    var th2 = th0 + i * th_arc / segs;
    var th3 = th0 + (i+1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return (segmentCache[key] = result);
}

function bezier(params) {
  var key = join.call(params);
  if (bezierCache[key]) {
    return bezierCache[key];
  }
  
  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];

  var a00 = cos_th * rx;
  var a01 = -sin_th * ry;
  var a10 = sin_th * rx;
  var a11 = cos_th * ry;

  var cos_th0 = Math.cos(th0);
  var sin_th0 = Math.sin(th0);
  var cos_th1 = Math.cos(th1);
  var sin_th1 = Math.sin(th1);

  var th_half = 0.5 * (th1 - th0);
  var sin_th_h2 = Math.sin(th_half * 0.5);
  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  var x1 = cx + cos_th0 - t * sin_th0;
  var y1 = cy + sin_th0 + t * cos_th0;
  var x3 = cx + cos_th1;
  var y3 = cy + sin_th1;
  var x2 = x3 + t * sin_th1;
  var y2 = y3 - t * cos_th1;

  return (bezierCache[key] = [
    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,
    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,
    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3
  ]);
}

module.exports = {
  segments: segments,
  bezier: bezier,
  cache: {
    segments: segmentCache,
    bezier: bezierCache
  }
};

},{}],150:[function(require,module,exports){
module.exports = {
  parse:  require('./parse'),
  render: require('./render')
};

},{"./parse":151,"./render":152}],151:[function(require,module,exports){
// Path parsing and rendering code adapted from fabric.js -- Thanks!
var cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },
    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\d)([-+])/g, /\s|,|###/];

module.exports = function(pathstr) {
  var result = [],
      path,
      curr,
      chunks,
      parsed, param,
      cmd, len, i, j, n, m;

  // First, break path into command sequence
  path = pathstr
    .slice()
    .replace(regexp[0], '###$1')
    .split(regexp[1])
    .slice(1);

  // Next, parse each command in turn
  for (i=0, n=path.length; i<n; ++i) {
    curr = path[i];
    chunks = curr
      .slice(1)
      .trim()
      .replace(regexp[2],'$1###$2')
      .split(regexp[3]);
    cmd = curr.charAt(0);

    parsed = [cmd];
    for (j=0, m=chunks.length; j<m; ++j) {
      if ((param = +chunks[j]) === param) { // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length-1 > len) {
      for (j=1, m=parsed.length; j<m; j+=len) {
        result.push([cmd].concat(parsed.slice(j, j+len)));
      }
    }
    else {
      result.push(parsed);
    }
  }

  return result;
};

},{}],152:[function(require,module,exports){
var arc = require('./arc');

module.exports = function(g, path, l, t) {
  var current, // current instruction
      previous = null,
      x = 0, // current x
      y = 0, // current y
      controlX = 0, // current control point x
      controlY = 0, // current control point y
      tempX,
      tempY,
      tempControlX,
      tempControlY;

  if (l == null) l = 0;
  if (t == null) t = 0;

  g.beginPath();

  for (var i=0, len=path.length; i<len; ++i) {
    current = path[i];

    switch (current[0]) { // first letter

      case 'l': // lineto, relative
        x += current[1];
        y += current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'L': // lineto, absolute
        x = current[1];
        y = current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'h': // horizontal lineto, relative
        x += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'H': // horizontal lineto, absolute
        x = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'v': // vertical lineto, relative
        y += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'V': // verical lineto, absolute
        y = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'm': // moveTo, relative
        x += current[1];
        y += current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'M': // moveTo, absolute
        x = current[1];
        y = current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'c': // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        g.bezierCurveTo(
          x + current[1] + l, // x1
          y + current[2] + t, // y1
          controlX + l, // x2
          controlY + t, // y2
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'C': // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        g.bezierCurveTo(
          current[1] + l,
          current[2] + t,
          controlX + l,
          controlY + t,
          x + l,
          y + t
        );
        break;

      case 's': // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          x + current[1] + l,
          y + current[2] + t,
          tempX + l,
          tempY + t
        );

        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = x + current[1];
        controlY = y + current[2];

        x = tempX;
        y = tempY;
        break;

      case 'S': // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        // calculate reflection of previous control points
        controlX = 2*x - controlX;
        controlY = 2*y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = current[1];
        controlY = current[2];

        break;

      case 'q': // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];

        controlX = x + current[1];
        controlY = y + current[2];

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'Q': // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];

        g.quadraticCurveTo(
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't': // shorthand quadraticCurveTo, relative

        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        }
        else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        }
        else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2];

        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + x + l,
          current[7] + y + t
        ]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + l,
          current[7] + t
        ]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        g.closePath();
        break;
    }
    previous = current;
  }
};

function drawArc(g, x, y, coords) {
  var seg = arc.segments(
    coords[5], // end x
    coords[6], // end y
    coords[0], // radius x
    coords[1], // radius y
    coords[3], // large flag
    coords[4], // sweep flag
    coords[2], // rotation
    x, y
  );
  for (var i=0; i<seg.length; ++i) {
    var bez = arc.bezier(seg[i]);
    g.bezierCurveTo.apply(g, bez);
  }
}

},{"./arc":149}],153:[function(require,module,exports){
function Handler() {
  this._active = null;
  this._handlers = {};
}

var prototype = Handler.prototype;

prototype.initialize = function(el, pad, obj) {
  this._el = el;
  this._obj = obj || null;
  return this.padding(pad);
};

prototype.element = function() {
  return this._el;
};

prototype.padding = function(pad) {
  this._padding = pad || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.scene = function(scene) {
  if (!arguments.length) return this._scene;
  this._scene = scene;
  return this;
};

// add an event handler
// subclasses should override
prototype.on = function(/*type, handler*/) {};

// remove an event handler
// subclasses should override
prototype.off = function(/*type, handler*/) {};

// return an array with all registered event handlers
prototype.handlers = function() {
  var h = this._handlers, a = [], k;
  for (k in h) { a.push.apply(a, h[k]); }
  return a;
};

prototype.eventName = function(name) {
  var i = name.indexOf('.');
  return i < 0 ? name : name.slice(0,i);
};

module.exports = Handler;
},{}],154:[function(require,module,exports){
function Renderer() {
  this._el = null;
  this._bgcolor = null;
}

var prototype = Renderer.prototype;

prototype.initialize = function(el, width, height, padding) {
  this._el = el;
  return this.resize(width, height, padding);
};

// Returns the parent container element for a visualization
prototype.element = function() {
  return this._el;
};

// Returns the scene element (e.g., canvas or SVG) of the visualization
// Subclasses must override if the first child is not the scene element
prototype.scene = function() {
  return this._el && this._el.firstChild;
};

prototype.background = function(bgcolor) {
  if (arguments.length === 0) return this._bgcolor;
  this._bgcolor = bgcolor;
  return this;
};

prototype.resize = function(width, height, padding) {
  this._width = width;
  this._height = height;
  this._padding = padding || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.render = function(/*scene, items*/) {
  return this;
};

module.exports = Renderer;
},{}],155:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler'),
    marks = require('./marks');

function CanvasHandler() {
  Handler.call(this);
  this._down = null;
  this._touch = null;
  this._first = true;
}

var base = Handler.prototype;
var prototype = (CanvasHandler.prototype = Object.create(base));
prototype.constructor = CanvasHandler;

prototype.initialize = function(el, pad, obj) {
  // add event listeners
  var canvas = this._canvas = DOM.find(el, 'canvas');
  if (canvas) {
    var that = this;
    this.events.forEach(function(type) {
      canvas.addEventListener(type, function(evt) {
        if (prototype[type]) {
          prototype[type].call(that, evt);
        } else {
          that.fire(type, evt);
        }
      });
    });
  }

  return base.initialize.call(this, el, pad, obj);
};

prototype.canvas = function() {
  return this._canvas;
};

// retrieve the current canvas context
prototype.context = function() {
  return this._canvas.getContext('2d');
};

// supported events
prototype.events = [
  'keydown',
  'keypress',
  'keyup',
  'mousedown',
  'mouseup',
  'mousemove',
  'mouseout',
  'mouseover',
  'click',
  'dblclick',
  'wheel',
  'mousewheel',
  'touchstart',
  'touchmove',
  'touchend'
];

// to keep firefox happy
prototype.DOMMouseScroll = function(evt) {
  this.fire('mousewheel', evt);
};

prototype.mousemove = function(evt) {
  var a = this._active,
      p = this.pickEvent(evt);

  if (p === a) {
    // active item and picked item are the same
    this.fire('mousemove', evt); // fire move
  } else {
    // active item and picked item are different
    this.fire('mouseout', evt);  // fire out for prior active item
    this._active = p;            // set new active item
    this.fire('mouseover', evt); // fire over for new active item
    this.fire('mousemove', evt); // fire move for new active item
  }
};

prototype.mouseout = function(evt) {
  this.fire('mouseout', evt);
  this._active = null;
};

prototype.mousedown = function(evt) {
  this._down = this._active;
  this.fire('mousedown', evt);
};

prototype.click = function(evt) {
  if (this._down === this._active) {
    this.fire('click', evt);
    this._down = null;
  }
};

prototype.touchstart = function(evt) {
  this._touch = this.pickEvent(evt.changedTouches[0]);

  if (this._first) {
    this._active = this._touch;
    this._first = false;
  }

  this.fire('touchstart', evt, true);
};

prototype.touchmove = function(evt) {
  this.fire('touchmove', evt, true);
};

prototype.touchend = function(evt) {
  this.fire('touchend', evt, true);
  this._touch = null;
};

// fire an event
prototype.fire = function(type, evt, touch) {
  var a = touch ? this._touch : this._active,
      h = this._handlers[type], i, len;
  if (h) {
    evt.vegaType = type;
    for (i=0, len=h.length; i<len; ++i) {
      h[i].handler.call(this._obj, evt, a);
    }
  }
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers;
  (h[name] || (h[name] = [])).push({
    type: type,
    handler: handler
  });
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type !== type) continue;
    if (!handler || h[i].handler === handler) h.splice(i, 1);
  }
  return this;
};

prototype.pickEvent = function(evt) {
  var rect = this._canvas.getBoundingClientRect(),
      pad = this._padding, x, y;
  return this.pick(this._scene,
    x = (evt.clientX - rect.left),
    y = (evt.clientY - rect.top),
    x - pad.left, y - pad.top);
};

// find the scenegraph item at the current mouse position
// x, y -- the absolute x, y mouse coordinates on the canvas element
// gx, gy -- the relative coordinates within the current group
prototype.pick = function(scene, x, y, gx, gy) {
  var g = this.context(),
      mark = marks[scene.marktype];
  return mark.pick.call(this, g, scene, x, y, gx, gy);
};

module.exports = CanvasHandler;

},{"../../util/dom":183,"../Handler":153,"./marks":162}],156:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Bounds = require('../../util/Bounds'),
    ImageLoader = require('../../util/ImageLoader'),
    Canvas = require('../../util/canvas'),
    Renderer = require('../Renderer'),
    marks = require('./marks');

function CanvasRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
}

CanvasRenderer.RETINA = true;

var base = Renderer.prototype;
var prototype = (CanvasRenderer.prototype = Object.create(base));
prototype.constructor = CanvasRenderer;

prototype.initialize = function(el, width, height, padding) {
  this._canvas = Canvas.instance(width, height);
  if (el) {
    DOM.clear(el, 0).appendChild(this._canvas);
    this._canvas.setAttribute('class', 'marks');
  }
  return base.initialize.call(this, el, width, height, padding);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  Canvas.resize(this._canvas, this._width, this._height,
    this._padding, CanvasRenderer.RETINA);
  return this;
};

prototype.canvas = function() {
  return this._canvas;
};

prototype.context = function() {
  return this._canvas ? this._canvas.getContext('2d') : null;
};

prototype.pendingImages = function() {
  return this._loader.pending();
};

function clipToBounds(g, items) {
  if (!items) return null;

  var b = new Bounds(), i, n, item, mark, group;
  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    group = mark.group;
    item = marks[mark.marktype].nested ? mark : item;
    b.union(translate(item.bounds, group));
    if (item['bounds:prev']) {
      b.union(translate(item['bounds:prev'], group));
    }
  }
  b.round();

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();

  return b;
}

function translate(bounds, group) {
  if (group == null) return bounds;
  var b = bounds.clone();
  for (; group != null; group = group.mark.group) {
    b.translate(group.x || 0, group.y || 0);
  }
  return b;
}

prototype.render = function(scene, items) {
  var g = this.context(),
      p = this._padding,
      w = this._width + p.left + p.right,
      h = this._height + p.top + p.bottom,
      b;

  // setup
  this._scene = scene; // cache scene for async redraw
  g.save();
  b = clipToBounds(g, items);
  this.clear(-p.left, -p.top, w, h);

  // render
  this.draw(g, scene, b);
  
  // takedown
  g.restore();
  this._scene = null; // clear scene cache

  return this;
};

prototype.draw = function(ctx, scene, bounds) {
  var mark = marks[scene.marktype];
  mark.draw.call(this, ctx, scene, bounds);
};

prototype.clear = function(x, y, w, h) {
  var g = this.context();
  g.clearRect(x, y, w, h);
  if (this._bgcolor != null) {
    g.fillStyle = this._bgcolor;
    g.fillRect(x, y, w, h); 
  }
};

prototype.loadImage = function(uri) {
  var renderer = this,
      scene = this._scene;
  return this._loader.loadImage(uri, function() {
    renderer.renderAsync(scene);
  });
};

prototype.renderAsync = function(scene) {
  // TODO make safe for multiple scene rendering?
  var renderer = this;
  if (renderer._async_id) {
    clearTimeout(renderer._async_id);
  }
  renderer._async_id = setTimeout(function() {
    renderer.render(scene);
    delete renderer._async_id;
  }, 10);
};

module.exports = CanvasRenderer;

},{"../../util/Bounds":176,"../../util/ImageLoader":179,"../../util/canvas":182,"../../util/dom":183,"../Renderer":154,"./marks":162}],157:[function(require,module,exports){
module.exports = {
  Handler:  require('./CanvasHandler'),
  Renderer: require('./CanvasRenderer')
};
},{"./CanvasHandler":155,"./CanvasRenderer":156}],158:[function(require,module,exports){
var util = require('./util');
var halfpi = Math.PI / 2;

function path(g, o) {
  var x = o.x || 0,
      y = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi;
  g.beginPath();
  if (ir === 0) g.moveTo(x, y);
  else g.arc(x, y, ir, sa, ea, 0);
  g.arc(x, y, or, ea, sa, 1);
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":169}],159:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    areaPath = require('../../../util/svg').path.area;

function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(areaPath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":151,"../../../path/render":152,"../../../util/svg":185,"./util":169}],160:[function(require,module,exports){
var util = require('./util'),
    EMPTY = [];

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var groups = scene.items,
      renderer = this,
      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;

  for (i=0, n=groups.length; i<n; ++i) {
    group = groups[i];
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    gx = group.x || 0;
    gy = group.y || 0;
    w = group.width || 0;
    h = group.height || 0;

    // draw group background
    if (group.stroke || group.fill) {
      opac = group.opacity == null ? 1 : group.opacity;
      if (opac > 0) {
        if (group.fill && util.fill(g, group, opac)) {
          g.fillRect(gx, gy, w, h);
        }
        if (group.stroke && util.stroke(g, group, opac)) {
          g.strokeRect(gx, gy, w, h);
        }
      }
    }

    // setup graphics context
    g.save();
    g.translate(gx, gy);
    if (group.clip) {
      g.beginPath();
      g.rect(0, 0, w, h);
      g.clip();
    }
    if (bounds) bounds.translate(-gx, -gy);

    // draw group contents
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer === 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=items.length; j<m; ++j) {
      renderer.draw(g, items[j], bounds);
    }
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer !== 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=legends.length; j<m; ++j) {
      renderer.draw(g, legends[j], bounds);
    }

    // restore graphics context
    if (bounds) bounds.translate(gx, gy);
    g.restore();
  }    
}

function pick(g, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy)) {
    return null;
  }

  var groups = scene.items || EMPTY, subscene,
      group, axes, items, legends, hits, dx, dy, i, j, b;

  for (i=groups.length; --i>=0;) {
    group = groups[i];

    // first hit test against bounding box
    // if a group is clipped, that should be handled by the bounds check.
    b = group.bounds;
    if (b && !b.contains(gx, gy)) continue;

    // passed bounds check, so test sub-groups
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    dx = (group.x || 0);
    dy = (group.y || 0);

    g.save();
    g.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    for (j=legends.length; --j>=0;) {
      subscene = legends[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interactive !== false && subscene.layer !== 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=items.length; --j>=0;) {
      subscene = items[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interative !== false && subscene.layer === 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    g.restore();

    if (scene.interactive !== false && (group.fill || group.stroke) &&
        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {
      return group;
    }
  }

  return null;
}

module.exports = {
  draw: draw,
  pick: pick
};

},{"./util":169}],161:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var renderer = this,
      items = scene.items, o;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    if (!(o.image && o.image.url === o.url)) {
      o.image = renderer.loadImage(o.url);
      o.image.url = o.url;
    }

    var x = o.x || 0,
        y = o.y || 0,
        w = o.width || (o.image && o.image.width) || 0,
        h = o.height || (o.image && o.image.height) || 0,
        opac;
    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);
    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);

    if (o.image.loaded) {
      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;
      g.drawImage(o.image, x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":169}],162:[function(require,module,exports){
module.exports = {
  arc:    require('./arc'),
  area:   require('./area'),
  group:  require('./group'),
  image:  require('./image'),
  line:   require('./line'),
  path:   require('./path'),
  rect:   require('./rect'),
  rule:   require('./rule'),
  symbol: require('./symbol'),
  text:   require('./text')
};

},{"./arc":158,"./area":159,"./group":160,"./image":161,"./line":163,"./path":164,"./rect":165,"./rule":166,"./symbol":167,"./text":168}],163:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    linePath = require('../../../util/svg').path.line;
    
function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(linePath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path, false);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":151,"../../../path/render":152,"../../../util/svg":185,"./util":169}],164:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render');

function path(g, o) {
  if (o.path == null) return true;
  var p = o.pathCache || (o.pathCache = parse(o.path));
  render(g, p, o.x, o.y);
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};

},{"../../../path/parse":151,"../../../path/render":152,"./util":169}],165:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, w, h;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    x = o.x || 0;
    y = o.y || 0;
    w = o.width || 0;
    h = o.height || 0;

    if (o.fill && util.fill(g, o, opac)) {
      g.fillRect(x, y, w, h);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeRect(x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":169}],166:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x1, y1, x2, y2;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;
      
    x1 = o.x || 0;
    y1 = o.y || 0;
    x2 = o.x2 != null ? o.x2 : x1;
    y2 = o.y2 != null ? o.y2 : y1;

    if (o.stroke && util.stroke(g, o, opac)) {
      g.beginPath();
      g.moveTo(x1, y1);
      g.lineTo(x2, y2);
      g.stroke();
    }
  }
}

function stroke(g, o) {
  var x1 = o.x || 0,
      y1 = o.y || 0,
      x2 = o.x2 != null ? o.x2 : x1,
      y2 = o.y2 != null ? o.y2 : y1,
      lw = o.strokeWidth,
      lc = o.strokeCap;

  g.lineWidth = lw != null ? lw : 1;
  g.lineCap   = lc != null ? lc : 'butt';
  g.beginPath();
  g.moveTo(x1, y1);
  g.lineTo(x2, y2);
}

function hit(g, o, x, y) {
  if (!g.isPointInStroke) return false;
  stroke(g, o);
  return g.isPointInStroke(x, y);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"./util":169}],167:[function(require,module,exports){
var util = require('./util');

var sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180);

function path(g, o) {
  var size = o.size != null ? o.size : 100,
      x = o.x, y = o.y, r, t, rx, ry;

  g.beginPath();

  if (o.shape == null || o.shape === 'circle') {
    r = Math.sqrt(size / Math.PI);
    g.arc(x, y, r, 0, 2*Math.PI, 0);
    g.closePath();
    return;
  }

  switch (o.shape) {
    case 'cross':
      r = Math.sqrt(size / 5) / 2;
      t = 3*r;
      g.moveTo(x-t, y-r);
      g.lineTo(x-r, y-r);
      g.lineTo(x-r, y-t);
      g.lineTo(x+r, y-t);
      g.lineTo(x+r, y-r);
      g.lineTo(x+t, y-r);
      g.lineTo(x+t, y+r);
      g.lineTo(x+r, y+r);
      g.lineTo(x+r, y+t);
      g.lineTo(x-r, y+t);
      g.lineTo(x-r, y+r);
      g.lineTo(x-t, y+r);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y);
      g.lineTo(x, y+ry);
      g.lineTo(x-rx, y);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      g.rect(x-r, y-r, t, t);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y+ry);
      g.lineTo(x+rx, y-ry);
      g.lineTo(x-rx, y-ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y+ry);
      g.lineTo(x-rx, y+ry);
  }
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":169}],168:[function(require,module,exports){
var Bounds = require('../../../util/Bounds'),
    textBounds = require('../../../util/bound').text,
    text = require('../../../util/text'),
    util = require('./util'),
    tempBounds = new Bounds();

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, r, t, str;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    str = text.value(o.text);
    if (!str) continue;
    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    g.font = text.font(o);
    g.textAlign = o.align || 'left';

    x = (o.x || 0);
    y = (o.y || 0);
    if ((r = o.radius)) {
      t = (o.theta || 0) - Math.PI/2;
      x += r * Math.cos(t);
      y += r * Math.sin(t);
    }

    if (o.angle) {
      g.save();
      g.translate(x, y);
      g.rotate(o.angle * Math.PI/180);
      x = y = 0; // reset x, y
    }
    x += (o.dx || 0);
    y += (o.dy || 0) + text.offset(o);

    if (o.fill && util.fill(g, o, opac)) {
      g.fillText(str, x, y);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeText(str, x, y);
    }
    if (o.angle) g.restore();
  }
}

function hit(g, o, x, y, gx, gy) {
  if (o.fontSize <= 0) return false;
  if (!o.angle) return true; // bounds sufficient if no rotation

  // project point into space of unrotated bounds
  var b = textBounds(o, tempBounds, true),
      a = -o.angle * Math.PI / 180,
      cos = Math.cos(a),
      sin = Math.sin(a),
      ox = o.x,
      oy = o.y,
      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),
      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);

  return b.contains(px, py);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"../../../util/Bounds":176,"../../../util/bound":181,"../../../util/text":186,"./util":169}],169:[function(require,module,exports){
function drawPathOne(path, g, o, items) {
  if (path(g, items)) return;

  var opac = o.opacity == null ? 1 : o.opacity;
  if (opac===0) return;

  if (o.fill && fill(g, o, opac)) { g.fill(); }
  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }
}

function drawPathAll(path, g, scene, bounds) {
  var i, len, item;
  for (i=0, len=scene.items.length; i<len; ++i) {
    item = scene.items[i];
    if (!bounds || bounds.intersects(item.bounds)) {
      drawPathOne(path, g, item, item);
    }
  }
}

function drawAll(pathFunc) {
  return function(g, scene, bounds) {
    drawPathAll(pathFunc, g, scene, bounds);
  };
}

function drawOne(pathFunc) {
  return function(g, scene, bounds) {
    if (!scene.items.length) return;
    if (!bounds || bounds.intersects(scene.bounds)) {
      drawPathOne(pathFunc, g, scene.items[0], scene.items);
    }
  };
}

var trueFunc = function() { return true; };

function pick(test) {
  if (!test) test = trueFunc;

  return function(g, scene, x, y, gx, gy) {
    if (!scene.items.length) return null;

    var o, b, i;

    if (g.pixelratio != null && g.pixelratio !== 1) {
      x *= g.pixelratio;
      y *= g.pixelratio;
    }

    for (i=scene.items.length; --i >= 0;) {
      o = scene.items[i]; b = o.bounds;
      // first hit test against bounding box
      if ((b && !b.contains(gx, gy)) || !b) continue;
      // if in bounding box, perform more careful test
      if (test(g, o, x, y, gx, gy)) return o;
    }
    return null;
  };
}

function testPath(path, filled) {
  return function(g, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = (filled == null) ? item.fill : filled,
        stroke = item.stroke && g.isPointInStroke, lw, lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      g.lineWidth = lw != null ? lw : 1;
      g.lineCap   = lc != null ? lc : 'butt';
    }

    return path(g, o) ? false :
      (fill && g.isPointInPath(x, y)) ||
      (stroke && g.isPointInStroke(x, y));
  };
}

function pickPath(path) {
  return pick(testPath(path));
}

function fill(g, o, opacity) {
  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.fillStyle = color(g, o, o.fill);
    return true;
  } else {
    return false;
  }
}

function stroke(g, o, opacity) {
  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;
  if (lw <= 0) return false;

  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.strokeStyle = color(g, o, o.stroke);
    g.lineWidth = lw;
    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';
    g.vgLineDash(o.strokeDash || null);
    g.vgLineDashOffset(o.strokeDashOffset || 0);
    return true;
  } else {
    return false;
  }
}

function color(g, o, value) {
  return (value.id) ?
    gradient(g, value, o.bounds) :
    value;
}

function gradient(g, p, b) {
  var w = b.width(),
      h = b.height(),
      x1 = b.x1 + p.x1 * w,
      y1 = b.y1 + p.y1 * h,
      x2 = b.x1 + p.x2 * w,
      y2 = b.y1 + p.y2 * h,
      grad = g.createLinearGradient(x1, y1, x2, y2),
      stop = p.stops,
      i, n;

  for (i=0, n=stop.length; i<n; ++i) {
    grad.addColorStop(stop[i].offset, stop[i].color);
  }
  return grad;
}

module.exports = {
  drawOne:  drawOne,
  drawAll:  drawAll,
  pick:     pick,
  pickPath: pickPath,
  testPath: testPath,
  stroke:   stroke,
  fill:     fill,
  color:    color,
  gradient: gradient
};

},{}],170:[function(require,module,exports){
module.exports = {
  'canvas': require('./canvas'),
  'svg':    require('./svg')
};

},{"./canvas":157,"./svg":174}],171:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler');

function SVGHandler() {
  Handler.call(this);
}

var base = Handler.prototype;
var prototype = (SVGHandler.prototype = Object.create(base));
prototype.constructor = SVGHandler;

prototype.initialize = function(el, pad, obj) {
  this._svg = DOM.find(el, 'svg');
  return base.initialize.call(this, el, pad, obj);
};

prototype.svg = function() {
  return this._svg;
};

// wrap an event listener for the SVG DOM
prototype.listener = function(handler) {
  var that = this;
  return function(evt) {
    var target = evt.target,
        item = target.__data__;
    evt.vegaType = evt.type;
    item = Array.isArray(item) ? item[0] : item;
    handler.call(that._obj, evt, item);
  };
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers,
      x = {
        type:     type,
        handler:  handler,
        listener: this.listener(handler)
      };

  (h[name] || (h[name] = [])).push(x);
  svg.addEventListener(name, x.listener);
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type === type && !handler || h[i].handler === handler) {
      svg.removeEventListener(name, h[i].listener);
      h.splice(i, 1);
    }
  }
  return this;
};

module.exports = SVGHandler;

},{"../../util/dom":183,"../Handler":153}],172:[function(require,module,exports){
var ImageLoader = require('../../util/ImageLoader'),
    Renderer = require('../Renderer'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    SVG = require('../../util/svg'),
    ns = SVG.metadata.xmlns,
    marks = require('./marks');

function SVGRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
  this._dirtyID = 0;
}

var base = Renderer.prototype;
var prototype = (SVGRenderer.prototype = Object.create(base));
prototype.constructor = SVGRenderer;

prototype.initialize = function(el, width, height, padding) {
  if (el) {
    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');
    DOM.clear(el, 1);
    // set the svg root group
    this._root = DOM.child(this._svg, 0, 'g', ns);
    DOM.clear(this._svg, 1);
  }

  // create the svg definitions cache
  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };

  // set background color if defined
  this.background(this._bgcolor);

  return base.initialize.call(this, el, width, height, padding);
};

prototype.background = function(bgcolor) {
  if (arguments.length && this._svg) {
    this._svg.style.setProperty('background-color', bgcolor);
  }
  return base.background.apply(this, arguments);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  
  if (this._svg) {
    var w = this._width,
        h = this._height,
        p = this._padding;
  
    this._svg.setAttribute('width', w + p.left + p.right);
    this._svg.setAttribute('height', h + p.top + p.bottom);
    
    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');
  }

  return this;
};

prototype.svg = function() {
  if (!this._svg) return null;

  var attr = {
    'class':  'marks',
    'width':  this._width + this._padding.left + this._padding.right,
    'height': this._height + this._padding.top + this._padding.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};


// -- Render entry point --

prototype.render = function(scene, items) {
  if (this._dirtyCheck(items)) {
    if (this._dirtyAll) this._resetDefs();
    this.draw(this._root, scene, -1);
    DOM.clear(this._root, 1);
  }
  this.updateDefs();
  return this;
};

prototype.draw = function(el, scene, index) {
  this.drawMark(el, scene, index, marks[scene.marktype]);
};


// -- Manage SVG definitions ('defs') block --

prototype.updateDefs = function() {
  var svg = this._svg,
      defs = this._defs,
      el = defs.el,
      index = 0, id;

  for (id in defs.gradient) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateGradient(el, defs.gradient[id], index++);
  }

  for (id in defs.clipping) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateClipping(el, defs.clipping[id], index++);
  }

  // clean-up
  if (el) {
    if (index === 0) {
      svg.removeChild(el);
      defs.el = null;
    } else {
      DOM.clear(el, index);      
    }
  }
};

function updateGradient(el, grad, index) {
  var i, n, stop;

  el = DOM.child(el, index, 'linearGradient', ns);
  el.setAttribute('id', grad.id);
  el.setAttribute('x1', grad.x1);
  el.setAttribute('x2', grad.x2);
  el.setAttribute('y1', grad.y1);
  el.setAttribute('y2', grad.y2);
  
  for (i=0, n=grad.stops.length; i<n; ++i) {
    stop = DOM.child(el, i, 'stop', ns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }
  DOM.clear(el, i);
}

function updateClipping(el, clip, index) {
  var rect;

  el = DOM.child(el, index, 'clipPath', ns);
  el.setAttribute('id', clip.id);
  rect = DOM.child(el, 0, 'rect', ns);
  rect.setAttribute('x', 0);
  rect.setAttribute('y', 0);
  rect.setAttribute('width', clip.width);
  rect.setAttribute('height', clip.height);
}

prototype._resetDefs = function() {
  var def = this._defs;
  def.clip_id = 1;
  def.gradient = {};
  def.clipping = {};
};


// -- Manage rendering of items marked as dirty --

prototype.isDirty = function(item) {
  return this._dirtyAll || item.dirty === this._dirtyID;
};

prototype._dirtyCheck = function(items) {
  this._dirtyAll = true;
  if (!items) return true;

  var id = ++this._dirtyID,
      item, mark, type, mdef, i, n, o;

  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    if (mark.marktype !== type) {
      // memoize mark instance lookup
      type = mark.marktype;
      mdef = marks[type];
    }

    if (item.status === 'exit') { // EXIT
      if (item._svg) {
        if (mdef.nest && item.mark.items.length) {
          // if nested mark with remaining points, update instead
          this._update(mdef, item._svg, item.mark.items[0]);
          o = item.mark.items[0];
          o._svg = item._svg;
          o._update = id;
        } else {
          // otherwise remove from DOM
          DOM.remove(item._svg);
        }
        item._svg = null;
      }
      continue;
    }

    item = (mdef.nest ? mark.items[0] : item);
    if (item._update === id) { // Already processed
      continue;
    } else if (item._svg) { // UPDATE
      this._update(mdef, item._svg, item);
    } else { // ENTER
      this._dirtyAll = false;
      dirtyParents(item, id);
    }
    item._update = id;
  }
  return !this._dirtyAll;
};

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item=item.mark.group) {
    item.dirty = id;
    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
}


// -- Construct & maintain scenegraph to SVG mapping ---

// Draw a mark container.
prototype.drawMark = function(el, scene, index, mdef) {
  if (!this.isDirty(scene)) return;

  var items = mdef.nest ?
        (scene.items && scene.items.length ? [scene.items[0]] : []) :
        scene.items || [],
      events = scene.interactive === false ? 'none' : null,
      isGroup = (mdef.tag === 'g'),
      className = DOM.cssClass(scene),
      p, i, n, c, d, insert;

  p = DOM.child(el, index+1, 'g', ns, className);
  p.setAttribute('class', className);
  scene._svg = p;
  if (!isGroup && events) {
    p.style.setProperty('pointer-events', events);
  }

  for (i=0, n=items.length; i<n; ++i) {
    if (this.isDirty(d = items[i])) {
      insert = !(this._dirtyAll || d._svg);
      c = bind(p, mdef, d, i, insert);
      this._update(mdef, c, d);
      if (isGroup) {
        if (insert) this._dirtyAll = true;
        this._recurse(c, d);
        if (insert) this._dirtyAll = false;
      }
    }
  }
  DOM.clear(p, i);
  return p;
};

// Recursively process group contents.
prototype._recurse = function(el, group) {
  var items = group.items || [],
      legends = group.legendItems || [],
      axes = group.axisItems || [],
      idx = 0, j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    this.draw(el, items[j], idx++);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    this.drawMark(el, legends[j], idx++, marks.group);
  }

  // remove any extraneous DOM elements
  DOM.clear(el, 1 + idx);
};

// Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.
function bind(el, mdef, item, index, insert) {
  // create svg element, bind item data for D3 compatibility
  var node = DOM.child(el, index, mdef.tag, ns, null, insert);
  node.__data__ = item;
  node.__values__ = {fill: 'default'};

  // create background rect
  if (mdef.tag === 'g') {
    var bg = DOM.child(node, 0, 'rect', ns, 'background');
    bg.__data__ = item;
  }

  // add pointer from scenegraph item to svg element
  return (item._svg = node);
}


// -- Set attributes & styles on SVG elements ---

var href = (typeof window !== 'undefined' ? window.location.href : ''),
    element = null, // temp var for current SVG element
    values = null;  // temp var for current values hash

// Extra configuration for certain mark types
var mark_extras = {
  group: function(mdef, el, item) {
    element = el.childNodes[0];
    values = el.__values__; // use parent's values hash
    mdef.background(emit, item, this);

    var value = item.mark.interactive === false ? 'none' : null;
    if (value !== values.events) {
      element.style.setProperty('pointer-events', value);
      values.events = value;
    }
  },
  text: function(mdef, el, item) {
    var str = text.value(item.text);
    if (str !== values.text) {
      el.textContent = str;
      values.text = str;
    }
    str = text.font(item);
    if (str !== values.font) {
      el.style.setProperty('font', str);
      values.font = str;
    }
  }
};

prototype._update = function(mdef, el, item) {
  // set dom element and values cache
  // provides access to emit method
  element = el;
  values = el.__values__;

  // apply svg attributes
  mdef.attr(emit, item, this);

  // some marks need special treatment
  var extra = mark_extras[mdef.type];
  if (extra) extra(mdef, el, item);

  // apply svg css styles
  // note: element may be modified by 'extra' method
  this.style(element, item);
};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return;

  if (value != null) {
    // if value is provided, update DOM attribute
    if (ns) {
      element.setAttributeNS(ns, name, value);
    } else {
      element.setAttribute(name, value);
    }
  } else {
    // else remove DOM attribute
    if (ns) {
      element.removeAttributeNS(ns, name);
    } else {
      element.removeAttribute(name);
    }
  }

  // note current value for future comparison
  values[name] = value;
}

prototype.style = function(el, o) {
  if (o == null) return;
  var i, n, prop, name, value;

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    value = o[prop];
    if (value === values[prop]) continue;

    name = SVG.styles[prop];
    if (value == null) {
      if (name === 'fill') {
        el.style.setProperty(name, 'none');
      } else {
        el.style.removeProperty(name);
      }
    } else {
      if (value.id) {
        // ensure definition is included
        this._defs.gradient[value.id] = value;
        value = 'url(' + href + '#' + value.id + ')';
      }
      el.style.setProperty(name, value+'');
    }

    values[prop] = value;
  }
};

module.exports = SVGRenderer;

},{"../../util/ImageLoader":179,"../../util/dom":183,"../../util/svg":185,"../../util/text":186,"../Renderer":154,"./marks":175}],173:[function(require,module,exports){
var Renderer = require('../Renderer'),
    ImageLoader = require('../../util/ImageLoader'),
    SVG = require('../../util/svg'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    openTag = DOM.openTag,
    closeTag = DOM.closeTag,
    MARKS = require('./marks');

function SVGStringRenderer(loadConfig) {
  Renderer.call(this);

  this._loader = new ImageLoader(loadConfig);

  this._text = {
    head: '',
    root: '',
    foot: '',
    defs: '',
    body: ''
  };

  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };
}

var base = Renderer.prototype;
var prototype = (SVGStringRenderer.prototype = Object.create(base));
prototype.constructor = SVGStringRenderer;

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  var p = this._padding,
      t = this._text;

  var attr = {
    'class':  'marks',
    'width':  this._width + p.left + p.right,
    'height': this._height + p.top + p.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  t.head = openTag('svg', attr);
  t.root = openTag('g', {
    transform: 'translate(' + p.left + ',' + p.top + ')'
  });
  t.foot = closeTag('g') + closeTag('svg');

  return this;
};

prototype.svg = function() {
  var t = this._text;
  return t.head + t.defs + t.root + t.body + t.foot;
};

prototype.render = function(scene) {
  this._text.body = this.mark(scene);
  this._text.defs = this.buildDefs();
  return this;
};

prototype.reset = function() {
  this._defs.clip_id = 0;
  return this;
};

prototype.buildDefs = function() {
  var all = this._defs,
      defs = '',
      i, id, def, stops;

  for (id in all.gradient) {
    def = all.gradient[id];
    stops = def.stops;

    defs += openTag('linearGradient', {
      id: id,
      x1: def.x1,
      x2: def.x2,
      y1: def.y1,
      y2: def.y2
    });
    
    for (i=0; i<stops.length; ++i) {
      defs += openTag('stop', {
        offset: stops[i].offset,
        'stop-color': stops[i].color
      }) + closeTag('stop');
    }
    
    defs += closeTag('linearGradient');
  }
  
  for (id in all.clipping) {
    def = all.clipping[id];

    defs += openTag('clipPath', {id: id});

    defs += openTag('rect', {
      x: 0,
      y: 0,
      width: def.width,
      height: def.height
    }) + closeTag('rect');

    defs += closeTag('clipPath');
  }
  
  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};

var object;

function emit(name, value, ns, prefixed) {
  object[prefixed || name] = value;
}

prototype.attributes = function(attr, item) {
  object = {};
  attr(emit, item, this);
  return object;
};

prototype.mark = function(scene) {
  var mdef = MARKS[scene.marktype],
      tag  = mdef.tag,
      attr = mdef.attr,
      nest = mdef.nest || false,
      data = nest ?
          (scene.items && scene.items.length ? [scene.items[0]] : []) :
          (scene.items || []),
      defs = this._defs,
      str = '',
      style, i, item;

  if (tag !== 'g' && scene.interactive === false) {
    style = 'style="pointer-events: none;"';
  }

  // render opening group tag
  str += openTag('g', {
    'class': DOM.cssClass(scene)
  }, style);

  // render contained elements
  for (i=0; i<data.length; ++i) {
    item = data[i];
    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;
    str += openTag(tag, this.attributes(attr, item), style);
    if (tag === 'text') {
      str += escape_text(text.value(item.text));
    } else if (tag === 'g') {
      str += openTag('rect',
        this.attributes(mdef.background, item),
        styles(item, scene, 'bgrect', defs)) + closeTag('rect');
      str += this.markGroup(item);
    }
    str += closeTag(tag);
  }

  // render closing group tag
  return str + closeTag('g');
};

prototype.markGroup = function(scene) {
  var str = '',
      axes = scene.axisItems || [],
      items = scene.items || [],
      legends = scene.legendItems || [],
      j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    str += this.mark(items[j]);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    str += this.mark(legends[j]);
  }

  return str;
};

function styles(o, mark, tag, defs) {
  if (o == null) return '';
  var i, n, prop, name, value, s = '';

  if (tag === 'bgrect' && mark.interactive === false) {
    s += 'pointer-events: none;';
  }

  if (tag === 'text') {
    s += 'font: ' + text.font(o) + ';';
  }

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    name = SVG.styles[prop];
    value = o[prop];

    if (value == null) {
      if (name === 'fill') {
        s += (s.length ? ' ' : '') + 'fill: none;';
      }
    } else {
      if (value.id) {
        // ensure definition is included
        defs.gradient[value.id] = value;
        value = 'url(#' + value.id + ')';
      }
      s += (s.length ? ' ' : '') + name + ': ' + value + ';';
    }
  }

  return s ? 'style="' + s + '"' : null;
}

function escape_text(s) {
  return s.replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
}

module.exports = SVGStringRenderer;

},{"../../util/ImageLoader":179,"../../util/dom":183,"../../util/svg":185,"../../util/text":186,"../Renderer":154,"./marks":175}],174:[function(require,module,exports){
module.exports = {
  Handler:  require('./SVGHandler'),
  Renderer: require('./SVGRenderer'),
  string: {
    Renderer : require('./SVGStringRenderer')
  }
};
},{"./SVGHandler":171,"./SVGRenderer":172,"./SVGStringRenderer":173}],175:[function(require,module,exports){
var text = require('../../util/text'),
    SVG = require('../../util/svg'),
    textAlign = SVG.textAlign,
    path = SVG.path;

function translateItem(o) {
  return translate(o.x || 0, o.y || 0);
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}

module.exports = {
  arc: {
    tag:  'path',
    type: 'arc',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.arc(o));
    }
  },
  area: {
    tag:  'path',
    type: 'area',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.area(items));
    }
  },
  group: {
    tag:  'g',
    type: 'group',
    attr: function(emit, o, renderer) {
      var id = null, defs, c;
      emit('transform', translateItem(o));
      if (o.clip) {
        defs = renderer._defs;
        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);
        c = defs.clipping[id] || (defs.clipping[id] = {id: id});
        c.width = o.width || 0;
        c.height = o.height || 0;
      }
      emit('clip-path', id ? ('url(#' + id + ')') : null);
    },
    background: function(emit, o) {
      emit('class', 'background');
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  image: {
    tag:  'image',
    type: 'image',
    attr: function(emit, o, renderer) {
      var x = o.x || 0,
          y = o.y || 0,
          w = o.width || 0,
          h = o.height || 0,
          url = renderer.imageURL(o.url);

      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);
      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);

      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');
      emit('transform', translate(x, y));
      emit('width', w);
      emit('height', h);
    }
  },
  line: {
    tag:  'path',
    type: 'line',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.line(items));
    }
  },
  path: {
    tag:  'path',
    type: 'path',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', o.path);
    }
  },
  rect: {
    tag:  'rect',
    type: 'rect',
    nest: false,
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  rule: {
    tag:  'line',
    type: 'rule',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);
      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);
    }
  },
  symbol: {
    tag:  'path',
    type: 'symbol',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.symbol(o));
    }
  },
  text: {
    tag:  'text',
    type: 'text',
    nest: false,
    attr: function(emit, o) {
      var dx = (o.dx || 0),
          dy = (o.dy || 0) + text.offset(o),
          x = (o.x || 0),
          y = (o.y || 0),
          a = o.angle || 0,
          r = o.radius || 0, t;

      if (r) {
        t = (o.theta || 0) - Math.PI/2;
        x += r * Math.cos(t);
        y += r * Math.sin(t);
      }

      emit('text-anchor', textAlign[o.align] || 'start');
      
      if (a) {
        t = translate(x, y) + ' rotate('+a+')';
        if (dx || dy) t += ' ' + translate(dx, dy);
      } else {
        t = translate(x+dx, y+dy);
      }
      emit('transform', t);
    }
  }
};

},{"../../util/svg":185,"../../util/text":186}],176:[function(require,module,exports){
function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}

var prototype = Bounds.prototype;

prototype.clone = function() {
  return new Bounds(this);
};

prototype.clear = function() {
  this.x1 = +Number.MAX_VALUE;
  this.y1 = +Number.MAX_VALUE;
  this.x2 = -Number.MAX_VALUE;
  this.y2 = -Number.MAX_VALUE;
  return this;
};

prototype.set = function(x1, y1, x2, y2) {
  this.x1 = x1;
  this.y1 = y1;
  this.x2 = x2;
  this.y2 = y2;
  return this;
};

prototype.add = function(x, y) {
  if (x < this.x1) this.x1 = x;
  if (y < this.y1) this.y1 = y;
  if (x > this.x2) this.x2 = x;
  if (y > this.y2) this.y2 = y;
  return this;
};

prototype.expand = function(d) {
  this.x1 -= d;
  this.y1 -= d;
  this.x2 += d;
  this.y2 += d;
  return this;
};

prototype.round = function() {
  this.x1 = Math.floor(this.x1);
  this.y1 = Math.floor(this.y1);
  this.x2 = Math.ceil(this.x2);
  this.y2 = Math.ceil(this.y2);
  return this;
};

prototype.translate = function(dx, dy) {
  this.x1 += dx;
  this.x2 += dx;
  this.y1 += dy;
  this.y2 += dy;
  return this;
};

prototype.rotate = function(angle, x, y) {
  var cos = Math.cos(angle),
      sin = Math.sin(angle),
      cx = x - x*cos + y*sin,
      cy = y - x*sin - y*cos,
      x1 = this.x1, x2 = this.x2,
      y1 = this.y1, y2 = this.y2;

  return this.clear()
    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)
    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)
    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)
    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);
};

prototype.union = function(b) {
  if (b.x1 < this.x1) this.x1 = b.x1;
  if (b.y1 < this.y1) this.y1 = b.y1;
  if (b.x2 > this.x2) this.x2 = b.x2;
  if (b.y2 > this.y2) this.y2 = b.y2;
  return this;
};

prototype.encloses = function(b) {
  return b && (
    this.x1 <= b.x1 &&
    this.x2 >= b.x2 &&
    this.y1 <= b.y1 &&
    this.y2 >= b.y2
  );
};

prototype.intersects = function(b) {
  return b && !(
    this.x2 < b.x1 ||
    this.x1 > b.x2 ||
    this.y2 < b.y1 ||
    this.y1 > b.y2
  );
};

prototype.contains = function(x, y) {
  return !(
    x < this.x1 ||
    x > this.x2 ||
    y < this.y1 ||
    y > this.y2
  );
};

prototype.width = function() {
  return this.x2 - this.x1;
};

prototype.height = function() {
  return this.y2 - this.y1;
};

module.exports = Bounds;

},{}],177:[function(require,module,exports){
module.exports = function(b) {
  function noop() { }
  function add(x,y) { b.add(x, y); }

  return {
    bounds: function(_) {
      if (!arguments.length) return b;
      return (b = _, this);
    },
    beginPath: noop,
    closePath: noop,
    moveTo: add,
    lineTo: add,
    quadraticCurveTo: function(x1, y1, x2, y2) {
      b.add(x1, y1);
      b.add(x2, y2);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      b.add(x1, y1);
      b.add(x2, y2);
      b.add(x3, y3);
    }
  };
};

},{}],178:[function(require,module,exports){
var gradient_id = 0;

function Gradient(type) {
  this.id = 'gradient_' + (gradient_id++);
  this.type = type || 'linear';
  this.stops = [];
  this.x1 = 0;
  this.x2 = 1;
  this.y1 = 0;
  this.y2 = 0;
}

var prototype = Gradient.prototype;

prototype.stop = function(offset, color) {
  this.stops.push({
    offset: offset,
    color: color
  });
  return this;
};

module.exports = Gradient;
},{}],179:[function(require,module,exports){
(function (global){
var load = require('datalib/src/import/load');

function ImageLoader(loadConfig) {
  this._pending = 0;
  this._config = loadConfig || ImageLoader.Config; 
}

// Overridable global default load configuration
ImageLoader.Config = null;

var prototype = ImageLoader.prototype;

prototype.pending = function() {
  return this._pending;
};

prototype.params = function(uri) {
  var p = {url: uri}, k;
  for (k in this._config) { p[k] = this._config[k]; }
  return p;
};

prototype.imageURL = function(uri) {
  return load.sanitizeUrl(this.params(uri));
};

function browser(uri, callback) {
  var url = load.sanitizeUrl(this.params(uri));
  if (!url) { // error
    if (callback) callback(uri, null);
    return null;
  }

  var loader = this,
      image = new Image();

  loader._pending += 1;

  image.onload = function() {
    loader._pending -= 1;
    image.loaded = true;
    if (callback) callback(null, image);
  };
  image.src = url;

  return image;
}

function server(uri, callback) {
  var loader = this,
      image = new ((typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null).Image)();

  loader._pending += 1;

  load(this.params(uri), function(err, data) {
    loader._pending -= 1;
    if (err) {
      if (callback) callback(err, null);
      return null;
    }
    image.src = data;
    image.loaded = true;
    if (callback) callback(null, image);
  });

  return image;
}

prototype.loadImage = function(uri, callback) {
  return load.useXHR ?
    browser.call(this, uri, callback) :
    server.call(this, uri, callback);
};

module.exports = ImageLoader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"datalib/src/import/load":45}],180:[function(require,module,exports){
function Item(mark) {
  this.mark = mark;
}

var prototype = Item.prototype;

prototype.hasPropertySet = function(name) {
  var props = this.mark.def.properties;
  return props && props[name] != null;
};

prototype.cousin = function(offset, index) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      group = mark.group,
      iidx = index==null ? mark.items.indexOf(this) : index,
      midx = group.items.indexOf(mark) + offset;
  return group.items[midx].items[iidx];
};

prototype.sibling = function(offset) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      iidx = mark.items.indexOf(this) + offset;
  return mark.items[iidx];
};

prototype.remove = function() {
  var item = this,
      list = item.mark.items,
      i = list.indexOf(item);
  if (i >= 0) {
    if (i===list.length-1) {
      list.pop();
    } else {
      list.splice(i, 1);
    }
  }
  return item;
};

prototype.touch = function() {
  if (this.pathCache) this.pathCache = null;
};

module.exports = Item;
},{}],181:[function(require,module,exports){
var BoundsContext = require('./BoundsContext'),
    Bounds = require('./Bounds'),
    canvas = require('./canvas'),
    svg = require('./svg'),
    text = require('./text'),
    paths = require('../path'),
    parse = paths.parse,
    drawPath = paths.render,
    areaPath = svg.path.area,
    linePath = svg.path.line,
    halfpi = Math.PI / 2,
    sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180),
    g2D = null,
    bc = BoundsContext();

function context() {
  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));
}

function strokeBounds(o, bounds) {
  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {
    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);
  }
  return bounds;
}

function pathBounds(o, path, bounds, x, y) {
  if (path == null) {
    bounds.set(0, 0, 0, 0);
  } else {
    drawPath(bc.bounds(bounds), path, x, y);
    strokeBounds(o, bounds);
  }
  return bounds;
}

function path(o, bounds) {
  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;
  return pathBounds(o, p, bounds, o.x, o.y);
}

function area(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(areaPath(items)));
  return pathBounds(item, p, bounds);
}

function line(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(linePath(items)));
  return pathBounds(item, p, bounds);
}

function rect(o, bounds) {
  var x, y;
  return strokeBounds(o, bounds.set(
    x = o.x || 0,
    y = o.y || 0,
    (x + o.width) || 0,
    (y + o.height) || 0
  ));
}

function image(o, bounds) {
  var x = o.x || 0,
      y = o.y || 0,
      w = o.width || 0,
      h = o.height || 0;
  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));
  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));
  return bounds.set(x, y, x+w, y+h);
}

function rule(o, bounds) {
  var x1, y1;
  return strokeBounds(o, bounds.set(
    x1 = o.x || 0,
    y1 = o.y || 0,
    o.x2 != null ? o.x2 : x1,
    o.y2 != null ? o.y2 : y1
  ));
}

function arc(o, bounds) {
  var cx = o.x || 0,
      cy = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi,
      xmin = Infinity, xmax = -Infinity,
      ymin = Infinity, ymax = -Infinity,
      a, i, n, x, y, ix, iy, ox, oy;

  var angles = [sa, ea],
      s = sa - (sa % halfpi);
  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {
    angles.push(s);
  }

  for (i=0, n=angles.length; i<n; ++i) {
    a = angles[i];
    x = Math.cos(a); ix = ir*x; ox = or*x;
    y = Math.sin(a); iy = ir*y; oy = or*y;
    xmin = Math.min(xmin, ix, ox);
    xmax = Math.max(xmax, ix, ox);
    ymin = Math.min(ymin, iy, oy);
    ymax = Math.max(ymax, iy, oy);
  }

  return strokeBounds(o, bounds.set(
    cx + xmin,
    cy + ymin,
    cx + xmax,
    cy + ymax
  ));
}

function symbol(o, bounds) {
  var size = o.size != null ? o.size : 100,
      x = o.x || 0,
      y = o.y || 0,
      r, t, rx, ry;

  switch (o.shape) {
    case 'cross':
      t = 3 * Math.sqrt(size / 5) / 2;
      bounds.set(x-t, y-t, x+t, y+t);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      bounds.set(x-r, y-r, x+r, y+r);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    default:
      r = Math.sqrt(size/Math.PI);
      bounds.set(x-r, y-r, x+r, y+r);
  }

  return strokeBounds(o, bounds);
}

function textMark(o, bounds, noRotate) {
  var g = context(),
      h = text.size(o),
      a = o.align,
      r = o.radius || 0,
      x = (o.x || 0),
      y = (o.y || 0),
      dx = (o.dx || 0),
      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset
      w, t;

  if (r) {
    t = (o.theta || 0) - Math.PI/2;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  // horizontal alignment
  g.font = text.font(o);
  w = g.measureText(text.value(o.text)).width;
  if (a === 'center') {
    dx -= (w / 2);
  } else if (a === 'right') {
    dx -= w;
  } else {
    // left by default, do nothing
  }

  bounds.set(dx+=x, dy+=y, dx+w, dy+h);
  if (o.angle && !noRotate) {
    bounds.rotate(o.angle*Math.PI/180, x, y);
  }
  return bounds.expand(noRotate ? 0 : 1);
}

function group(g, bounds, includeLegends) {
  var axes = g.axisItems || [],
      items = g.items || [],
      legends = g.legendItems || [],
      j, m;

  if (!g.clip) {
    for (j=0, m=axes.length; j<m; ++j) {
      bounds.union(axes[j].bounds);
    }
    for (j=0, m=items.length; j<m; ++j) {
      bounds.union(items[j].bounds);
    }
    if (includeLegends) {
      for (j=0, m=legends.length; j<m; ++j) {
        bounds.union(legends[j].bounds);
      }
    }
  }
  if (g.clip || g.width || g.height) {
    strokeBounds(g, bounds
      .add(0, 0)
      .add(g.width || 0, g.height || 0));
  }
  return bounds.translate(g.x || 0, g.y || 0);
}

var methods = {
  group:  group,
  symbol: symbol,
  image:  image,
  rect:   rect,
  rule:   rule,
  arc:    arc,
  text:   textMark,
  path:   path,
  area:   area,
  line:   line
};
methods.area.nest = true;
methods.line.nest = true;

function itemBounds(item, func, opt) {
  var type = item.mark.marktype;
  func = func || methods[type];
  if (func.nest) item = item.mark;

  var curr = item.bounds,
      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());

  if (curr) {
    prev.clear().union(curr);
    curr.clear();
  } else {
    item.bounds = new Bounds();
  }
  func(item, item.bounds, opt);
  if (!curr) prev.clear().union(item.bounds);
  return item.bounds;
}

var DUMMY_ITEM = {mark: null};

function markBounds(mark, bounds, opt) {
  var type  = mark.marktype,
      func  = methods[type],
      items = mark.items,
      hasi  = items && items.length,
      i, n, o, b;

  if (func.nest) {
    o = hasi ? items[0]
      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it
    b = itemBounds(o, func, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasi) {  
    for (i=0, n=items.length; i<n; ++i) {
      bounds.union(itemBounds(items[i], func, opt));
    }
  }
  return (mark.bounds = bounds);
}

module.exports = {
  mark:  markBounds,
  item:  itemBounds,
  text:  textMark,
  group: group
};

},{"../path":150,"./Bounds":176,"./BoundsContext":177,"./canvas":182,"./svg":185,"./text":186}],182:[function(require,module,exports){
(function (global){
function instance(w, h) {
  w = w || 1;
  h = h || 1;
  var canvas;

  if (typeof document !== 'undefined' && document.createElement) {
    canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
  } else {
    var Canvas = (typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null);
    if (!Canvas.prototype) return null;
    canvas = new Canvas(w, h);
  }
  return lineDash(canvas);
}

function resize(canvas, w, h, p, retina) {
  var g = this._ctx = canvas.getContext('2d'), 
      s = 1;

  canvas.width = w + p.left + p.right;
  canvas.height = h + p.top + p.bottom;

  // if browser canvas, attempt to modify for retina display
  if (retina && typeof HTMLElement !== 'undefined' &&
      canvas instanceof HTMLElement)
  {
    g.pixelratio = (s = pixelRatio(canvas) || 1);
  }

  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);
  return canvas;
}

function pixelRatio(canvas) {
  var g = canvas.getContext('2d');

  // get canvas pixel data
  var devicePixelRatio = window && window.devicePixelRatio || 1,
      backingStoreRatio = (
        g.webkitBackingStorePixelRatio ||
        g.mozBackingStorePixelRatio ||
        g.msBackingStorePixelRatio ||
        g.oBackingStorePixelRatio ||
        g.backingStorePixelRatio) || 1,
      ratio = devicePixelRatio / backingStoreRatio;

  if (devicePixelRatio !== backingStoreRatio) {
    // set actual and visible canvas size
    var w = canvas.width,
        h = canvas.height;
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  return ratio;
}

function lineDash(canvas) {
  var g = canvas.getContext('2d');
  if (g.vgLineDash) return; // already initialized!

  var NOOP = function() {},
      NODASH = [];
  
  if (g.setLineDash) {
    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };
    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };
  } else if (g.webkitLineDash !== undefined) {
  	g.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };
    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };
  } else if (g.mozDash !== undefined) {
    g.vgLineDash = function(dash) { this.mozDash = dash; };
    g.vgLineDashOffset = NOOP;
  } else {
    g.vgLineDash = NOOP;
    g.vgLineDashOffset = NOOP;
  }
  return canvas;
}

module.exports = {
  instance:   instance,
  resize:     resize,
  lineDash:   lineDash
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],183:[function(require,module,exports){
// create a new DOM element
function create(doc, tag, ns) {
  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);
}

// remove element from DOM
// recursively remove parent elements if empty
function remove(el) {
  if (!el) return;
  var p = el.parentNode;
  if (p) {
    p.removeChild(el);
    if (!p.childNodes || !p.childNodes.length) remove(p);
  }
}

module.exports = {
  // find first child element with matching tag
  find: function(el, tag) {
    tag = tag.toLowerCase();
    for (var i=0, n=el.childNodes.length; i<n; ++i) {
      if (el.childNodes[i].tagName.toLowerCase() === tag) {
        return el.childNodes[i];
      }
    }
  },
  // retrieve child element at given index
  // create & insert if doesn't exist or if tag/className do not match
  child: function(el, index, tag, ns, className, insert) {
    var a, b;
    a = b = el.childNodes[index];
    if (!a || insert ||
        a.tagName.toLowerCase() !== tag.toLowerCase() ||
        className && a.getAttribute('class') != className) {
      a = create(el.ownerDocument, tag, ns);
      el.insertBefore(a, b);
      if (className) a.setAttribute('class', className);
    }
    return a;
  },
  // remove all child elements at or above the given index
  clear: function(el, index) {
    var curr = el.childNodes.length;
    while (curr > index) {
      el.removeChild(el.childNodes[--curr]);
    }
    return el;
  },
  remove: remove,
  // generate css class name for mark
  cssClass: function(mark) {
    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');
  },
  // generate string for an opening xml tag
  // tag: the name of the xml tag
  // attr: hash of attribute name-value pairs to include
  // raw: additional raw string to include in tag markup
  openTag: function(tag, attr, raw) {
    var s = '<' + tag, key, val;
    if (attr) {
      for (key in attr) {
        val = attr[key];
        if (val != null) {
          s += ' ' + key + '="' + val + '"';
        }
      }
    }
    if (raw) s += ' ' + raw;
    return s + '>';
  },
  // generate string for closing xml tag
  // tag: the name of the xml tag
  closeTag: function(tag) {
    return '</' + tag + '>';
  }
};

},{}],184:[function(require,module,exports){
var bound = require('../util/bound');

var sets = [
  'items',
  'axisItems',
  'legendItems'
];

var keys = [
  'marktype', 'name', 'interactive', 'clip',
  'items', 'axisItems', 'legendItems', 'layer',
  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout
  'fill', 'fillOpacity', 'opacity',                             // fill
  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke
  'strokeDash', 'strokeDashOffset',                             // stroke dash
  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc
  'interpolate', 'tension', 'orient',                           // area, line
  'url',                                                        // image
  'path',                                                       // path
  'x2', 'y2',                                                   // rule
  'size', 'shape',                                              // symbol
  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text
  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font
];

function toJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}

function fromJSON(json) {
  var scene = (typeof json === 'string' ? JSON.parse(json) : json);
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      i, n, s, m, items;

  for (s=0, m=sets.length; s<m; ++s) {
    if ((items = scene[sets[s]])) {
      for (i=0, n=items.length; i<n; ++i) {
        items[i][type ? 'mark' : 'group'] = scene;
        if (!type || type === 'group') {
          initialize(items[i]);
        }
      }
    }
  }

  if (type) bound.mark(scene);
  return scene;
}

module.exports = {
  toJSON:   toJSON,
  fromJSON: fromJSON
};
},{"../util/bound":181}],185:[function(require,module,exports){
(function (global){
var d3_svg = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null).svg;

function x(o)     { return o.x || 0; }
function y(o)     { return o.y || 0; }
function xw(o)    { return (o.x || 0) + (o.width || 0); }
function yh(o)    { return (o.y || 0) + (o.height || 0); }
function size(o)  { return o.size == null ? 100 : o.size; }
function shape(o) { return o.shape || 'circle'; }

var areav = d3_svg.area().x(x).y1(y).y0(yh),
    areah = d3_svg.area().y(y).x1(x).x0(xw),
    line  = d3_svg.line().x(x).y(y);

module.exports = {
  metadata: {
    'version': '1.1',
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink'
  },
  path: {
    arc: d3_svg.arc(),
    symbol: d3_svg.symbol().type(shape).size(size),
    area: function(items) {
      var o = items[0];
      return (o.orient === 'horizontal' ? areah : areav)
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    },
    line: function(items) {
      var o = items[0];
      return line
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    }
  },
  textAlign: {
    'left':   'start',
    'center': 'middle',
    'right':  'end'
  },
  textBaseline: {
    'top':    'before-edge',
    'bottom': 'after-edge',
    'middle': 'central'
  },
  styles: {
    'fill':             'fill',
    'fillOpacity':      'fill-opacity',
    'stroke':           'stroke',
    'strokeWidth':      'stroke-width',
    'strokeOpacity':    'stroke-opacity',
    'strokeCap':        'stroke-linecap',
    'strokeDash':       'stroke-dasharray',
    'strokeDashOffset': 'stroke-dashoffset',
    'opacity':          'opacity'
  },
  styleProperties: [
    'fill',
    'fillOpacity',
    'stroke',
    'strokeWidth',
    'strokeOpacity',
    'strokeCap',
    'strokeDash',
    'strokeDashOffset',
    'opacity'
  ]
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],186:[function(require,module,exports){
function size(item) {
  return item.fontSize != null ? item.fontSize : 11;
}

module.exports = {
  size: size,
  value: function(s) {
    return s != null ? String(s) : '';
  },
  font: function(item, quote) {
    var font = item.font;
    if (quote && font) {
      font = String(font).replace(/\"/g, '\'');
    }
    return '' +
      (item.fontStyle ? item.fontStyle + ' ' : '') +
      (item.fontVariant ? item.fontVariant + ' ' : '') +
      (item.fontWeight ? item.fontWeight + ' ' : '') +
      size(item) + 'px ' +
      (font || 'sans-serif');
  },
  offset: function(item) {
    // perform our own font baseline calculation
    // why? not all browsers support SVG 1.1 'alignment-baseline' :(
    var baseline = item.baseline,
        h = size(item);
    return Math.round(
      baseline === 'top'    ?  0.93*h :
      baseline === 'middle' ?  0.30*h :
      baseline === 'bottom' ? -0.21*h : 0
    );
  }
};

},{}],187:[function(require,module,exports){
module.exports = {
  version: '2.2.6',
  dataflow: require('vega-dataflow'),
  parse: require('./src/parse/'),
  scene: {
    Bounder: require('./src/scene/Bounder'),
    Builder: require('./src/scene/Builder'),
    Encoder: require('./src/scene/Encoder'),
    GroupBuilder: require('./src/scene/GroupBuilder'),
  },
  transforms: require('./src/transforms'),
  schema: require('./src/core/schema'),
  config: require('./src/core/config'),
  util:  require('datalib'),
  debug: require('vega-logging').debug
};
},{"./src/core/config":191,"./src/core/schema":192,"./src/parse/":198,"./src/scene/Bounder":210,"./src/scene/Builder":211,"./src/scene/Encoder":212,"./src/scene/GroupBuilder":213,"./src/transforms":242,"datalib":49,"vega-dataflow":141,"vega-logging":147}],188:[function(require,module,exports){
var sg = require('vega-scenegraph').render,
    canvas = sg.canvas,
    svg = sg.svg.string,
    View = require('./View');

function HeadlessView(width, height, model) {
  View.call(null, width, height, model);
  this._type = 'canvas';
  this._renderers = {canvas: canvas, svg: svg};
}

var prototype = (HeadlessView.prototype = new View());

prototype.renderer = function(type) {
  if(type) this._type = type;
  return View.prototype.renderer.apply(this, arguments);
};

prototype.canvas = function() {
  return (this._type === 'canvas') ? this._renderer.canvas() : null;
};

prototype.canvasAsync = function(callback) {
  var r = this._renderer, view = this;
  
  function wait() {
    if (r.pendingImages() === 0) {
      view.render(); // re-render with all images
      callback(view.canvas());
    } else {
      setTimeout(wait, 10);
    }
  }

  // if images loading, poll until ready
  if (this._type !== 'canvas') return null;
  if (r.pendingImages() > 0) { wait(); } else { callback(this.canvas()); }
};

prototype.svg = function() {
  return (this._type === 'svg') ? this._renderer.svg() : null;
};

prototype.initialize = function() {    
  var w = this._width,
      h = this._height,
      bg  = this._bgcolor,
      pad = this._padding,
      config = this.model().config();

  if (this._viewport) {
    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);
    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);
  }

  this._renderer = (this._renderer || new this._io.Renderer(config.load))
    .initialize(null, w, h, pad)
    .background(bg);
  
  return this;
};

module.exports = HeadlessView;
},{"./View":190,"vega-scenegraph":148}],189:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    ChangeSet = df.ChangeSet,
    Base = df.Graph.prototype,
    Node  = df.Node, // jshint ignore:line
    GroupBuilder = require('../scene/GroupBuilder'),
    visit = require('../scene/visit'),
    config = require('./config');

function Model(cfg) {
  this._defs = {};
  this._predicates = {};
  this._scene = null;

  this._node = null;
  this._builder = null; // Top-level scenegraph builder

  this._reset = {axes: false, legends: false};

  this.config(cfg);
  Base.init.call(this);
}

var prototype = (Model.prototype = Object.create(Base));
prototype.constructor = Model;

prototype.defs = function(defs) {
  if (!arguments.length) return this._defs;
  this._defs = defs;
  return this;
};

prototype.config = function(cfg) {
  if (!arguments.length) return this._config;
  this._config = Object.create(config);
  for (var name in cfg) {
    var x = cfg[name], y = this._config[name];
    if (dl.isObject(x) && dl.isObject(y)) {
      dl.extend(y, x);
    } else {
      this._config[name] = x;
    }
  }

  return this;
};

prototype.width = function(width) {
  if (this._defs) this._defs.width = width;
  if (this._defs && this._defs.marks) this._defs.marks.width = width;
  if (this._scene) {
    this._scene.items[0].width = width;
    this._scene.items[0]._dirty = true;
  }
  this._reset.axes = true;
  return this;
};

prototype.height = function(height) {
  if (this._defs) this._defs.height = height;
  if (this._defs && this._defs.marks) this._defs.marks.height = height;
  if (this._scene) {
    this._scene.items[0].height = height;
    this._scene.items[0]._dirty = true;
  }
  this._reset.axes = true;
  return this;
};

prototype.node = function() {
  return this._node || (this._node = new Node(this));
};

prototype.data = function() {
  var data = Base.data.apply(this, arguments);
  if (arguments.length > 1) {  // new Datasource
    this.node().addListener(data.pipeline()[0]);
  }
  return data;
};

function predicates(name) {
  var m = this, pred = {};
  if (!dl.isArray(name)) return this._predicates[name];
  name.forEach(function(n) { pred[n] = m._predicates[n]; });
  return pred;
}

prototype.predicate = function(name, predicate) {
  if (arguments.length === 1) return predicates.call(this, name);
  return (this._predicates[name] = predicate);
};

prototype.predicates = function() { return this._predicates; };

prototype.scene = function(renderer) {
  if (!arguments.length) return this._scene;
  if (this._builder) this.node().removeListener(this._builder.disconnect());
  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});
  this.node().addListener(this._builder.connect());
  var p = this._builder.pipeline();
  p[p.length-1].addListener(renderer);
  return this;
};

prototype.reset = function() {
  if (this._scene && this._reset.axes) {
    visit(this._scene, function(item) {
      if (item.axes) item.axes.forEach(function(axis) { axis.reset(); });
    });
    this._reset.axes = false;
  }
  if (this._scene && this._reset.legends) {
    visit(this._scene, function(item) {
      if (item.legends) item.legends.forEach(function(l) { l.reset(); });
    });
    this._reset.legends = false;
  }
  return this;
};

prototype.addListener = function(l) {
  this.node().addListener(l);
};

prototype.removeListener = function(l) {
  this.node().removeListener(l); 
};

prototype.fire = function(cs) {
  if (!cs) cs = ChangeSet.create();
  this.propagate(cs, this.node());
};

module.exports = Model;
},{"../scene/GroupBuilder":213,"../scene/visit":218,"./config":191,"datalib":49,"vega-dataflow":141}],190:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    sg = require('vega-scenegraph').render,
    log = require('vega-logging'),
    Deps = df.Dependencies,
    parseStreams = require('../parse/streams'),
    Encoder = require('../scene/Encoder'),
    Transition = require('../scene/Transition');

function View(el, width, height) {
  this._el    = null;
  this._model = null;
  this._width = this.__width = width || 500;
  this._height  = this.__height = height || 300;
  this._bgcolor = null;
  this._autopad = 1;
  this._padding = {top:0, left:0, bottom:0, right:0};
  this._viewport = null;
  this._renderer = null;
  this._handler  = null;
  this._streamer = null; // Targeted update for streaming changes
  this._changeset = null;
  this._repaint = true; // Full re-render on every re-init
  this._renderers = sg;
  this._io  = null;
  this._api = {}; // Stash streaming data API sandboxes.
}

var prototype = View.prototype;

prototype.model = function(model) {
  if (!arguments.length) return this._model;
  if (this._model !== model) {
    this._model = model;
    this._streamer = new df.Node(model);
    this._streamer._rank = -1;  // HACK: To reduce re-ranking churn.
    this._changeset = df.ChangeSet.create();
    if (this._handler) this._handler.model(model);
  }
  return this;
};

// Sandboxed streaming data API
function streaming(src) {
  var view = this,
      ds = this._model.data(src),
      name = ds.name(),
      listener = ds.pipeline()[0],
      streamer = this._streamer,
      api = {};

  // If we have it stashed, don't create a new closure. 
  if (this._api[src]) return this._api[src];

  api.insert = function(vals) {
    ds.insert(dl.duplicate(vals));  // Don't pollute the environment
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return api;
  };

  api.update = function() {
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return (ds.update.apply(ds, arguments), api);
  };

  api.remove = function() {
    streamer.addListener(listener);
    view._changeset.data[name] = 1;
    return (ds.remove.apply(ds, arguments), api);
  };

  api.values = function() { return ds.values(); };    

  return (this._api[src] = api);
}

prototype.data = function(data) {
  var v = this;
  if (!arguments.length) return v._model.values();
  else if (dl.isString(data)) return streaming.call(v, data);
  else if (dl.isObject(data)) {
    dl.keys(data).forEach(function(k) {
      var api = streaming.call(v, k);
      data[k](api);
    });
  }
  return this;
};

prototype.signal = function(name, value) {
  var m  = this._model,
      cs = this._changeset,
      streamer = this._streamer,
      setter = name; 

  if (!arguments.length) {
    return m.values(Deps.SIGNALS);
  } else if (arguments.length == 1 && dl.isString(name)) {
    return m.values(Deps.SIGNALS, name);
  }

  if (arguments.length == 2) {
    setter = {};
    setter[name] = value;
  }

  dl.keys(setter).forEach(function(k) {
    streamer.addListener(m.signal(k).value(setter[k]));
    cs.signals[k] = 1;
    cs.reflow = true;
  });

  return this;
};

prototype.width = function(width) {
  if (!arguments.length) return this.__width;
  if (this.__width !== width) {
    this._width = this.__width = width;
    this.model().width(width);
    this.initialize();
    if (this._strict) this._autopad = 1;
  }
  return this;
};

prototype.height = function(height) {
  if (!arguments.length) return this.__height;
  if (this.__height !== height) {
    this._height = this.__height = height;
    this.model().height(height);
    this.initialize();
    if (this._strict) this._autopad = 1;
  }
  return this;
};

prototype.background = function(bgcolor) {
  if (!arguments.length) return this._bgcolor;
  if (this._bgcolor !== bgcolor) {
    this._bgcolor = bgcolor;
    this.initialize();
  }
  return this;
};

prototype.padding = function(pad) {
  if (!arguments.length) return this._padding;
  if (this._padding !== pad) {
    if (dl.isString(pad)) {
      this._autopad = 1;
      this._padding = {top:0, left:0, bottom:0, right:0};
      this._strict = (pad === 'strict');
    } else {
      this._autopad = 0;
      this._padding = pad;
      this._strict = false;
    }
    if (this._renderer) this._renderer.resize(this._width, this._height, pad);
    if (this._handler)  this._handler.padding(pad);
  }
  return (this._repaint = true, this);
};

prototype.autopad = function(opt) {
  if (this._autopad < 1) return this;
  else this._autopad = 0;

  var b = this.model().scene().bounds,
      pad = this._padding,
      config = this.model().config(),
      inset = config.autopadInset,
      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,
      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,
      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0;
  b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;
  pad = {left:l, top:t, right:r, bottom:b};

  if (this._strict) {
    this._autopad = 0;
    this._padding = pad;
    this._width = Math.max(0, this.__width - (l+r));
    this._height = Math.max(0, this.__height - (t+b));

    this._model.width(this._width)
      .height(this._height).reset();

    this.initialize()
      .update({props:'enter'}).update({props:'update'});
  } else {
    this.padding(pad).update(opt);
  }
  return this;
};

prototype.viewport = function(size) {
  if (!arguments.length) return this._viewport;
  if (this._viewport !== size) {
    this._viewport = size;
    this.initialize();
  }
  return this;
};

prototype.renderer = function(type) {
  if (!arguments.length) return this._renderer;
  if (this._renderers[type]) type = this._renderers[type];
  else if (dl.isString(type)) throw new Error('Unknown renderer: ' + type);
  else if (!type) throw new Error('No renderer specified');

  if (this._io !== type) {
    this._io = type;
    this._renderer = null;
    this.initialize();
    if (this._build) this.render();
  }
  return this;
};

prototype.initialize = function(el) {
  var v = this, prevHandler,
      w = v._width, h = v._height, pad = v._padding, bg = v._bgcolor,
      config = this.model().config();

  if (!arguments.length || el === null) {
    el = this._el ? this._el.parentNode : null;
    if (!el) return this;  // This View cannot init w/o an
  }

  // clear pre-existing container
  d3.select(el).select('div.vega').remove();
  
  // add div container
  this._el = el = d3.select(el)
    .append('div')
    .attr('class', 'vega')
    .style('position', 'relative')
    .node();
  if (v._viewport) {
    d3.select(el)
      .style('width',  (v._viewport[0] || w)+'px')
      .style('height', (v._viewport[1] || h)+'px')
      .style('overflow', 'auto');
  }

  // renderer
  sg.canvas.Renderer.RETINA = config.render.retina;
  v._renderer = (v._renderer || new this._io.Renderer(config.load))
    .initialize(el, w, h, pad)
    .background(bg);
  
  // input handler
  prevHandler = v._handler;
  v._handler = new this._io.Handler()
    .initialize(el, pad, v);

  if (prevHandler) {
    prevHandler.handlers().forEach(function(h) {
      v._handler.on(h.type, h.handler);
    });
  } else {
    // Register event listeners for signal stream definitions.
    v._detach = parseStreams(this);
  }
  
  return (this._repaint = true, this);
};

prototype.destroy = function() {
  if (this._detach) this._detach();
};

function build() {
  var v = this;
  v._renderNode = new df.Node(v._model)
    .router(true);

  v._renderNode.evaluate = function(input) {
    log.debug(input, ['rendering']);

    var s = v._model.scene(),
        h = v._handler;

    if (h && h.scene) h.scene(s);

    if (input.trans) {
      input.trans.start(function(items) { v._renderer.render(s, items); });
    } else if (v._repaint) {
      v._renderer.render(s);
      v._repaint = false;
    } else if (input.dirty.length) {
      v._renderer.render(s, input.dirty);
    }

    if (input.dirty.length) {
      input.dirty.forEach(function(i) { i._dirty = false; });
      s.items[0]._dirty = false;
    }

    // For all updated datasources, clear their previous values.
    for (var d in input.data) { v._model.data(d).synchronize(); }
    return input;
  };

  return (v._model.scene(v._renderNode), true);  
}

prototype.update = function(opt) {
  opt = opt || {};
  var v = this,
      trans = opt.duration ? new Transition(opt.duration, opt.ease) : null;

  var cs = v._changeset;
  if (trans) cs.trans = trans;
  if (opt.props !== undefined) {
    if (dl.keys(cs.data).length > 0) {
      throw Error(
        'New data values are not reflected in the visualization.' +
        ' Please call view.update() before updating a specified property set.'
      );
    }

    cs.reflow  = true;
    cs.request = opt.props;
  }

  var built = v._build;
  v._build = v._build || build.call(this);

  // If specific items are specified, short-circuit dataflow graph.
  // Else-If there are streaming updates, perform a targeted propagation.
  // Otherwise, reevaluate the entire model (datasources + scene).
  if (opt.items && built) { 
    Encoder.update(this._model, opt.trans, opt.props, opt.items, cs.dirty);
    v._renderNode.evaluate(cs);
  } else if (v._streamer.listeners().length && built) {
    v._model.propagate(cs, v._streamer);
    v._streamer.disconnect();
  } else {
    v._model.fire(cs);
  }

  v._changeset = df.ChangeSet.create();

  return v.autopad(opt);
};

prototype.toImageURL = function(type) {
  var v = this, Renderer;

  // lookup appropriate renderer
  switch (type || 'png') {
    case 'canvas':
    case 'png':
      Renderer = sg.canvas.Renderer; break;
    case 'svg':
      Renderer = sg.svg.string.Renderer; break;
    default: throw Error('Unrecognized renderer type: ' + type);
  }

  var retina = sg.canvas.Renderer.RETINA;
  sg.canvas.Renderer.RETINA = false; // ignore retina screen

  // render the scenegraph
  var ren = new Renderer(v._model.config.load)
    .initialize(null, v._width, v._height, v._padding)
    .render(v._model.scene());

  sg.canvas.Renderer.RETINA = retina; // restore retina settings

  // return data url
  if (type === 'svg') {
    var blob = new Blob([ren.svg()], {type: 'image/svg+xml'});
    return window.URL.createObjectURL(blob);
  } else {
    return ren.canvas().toDataURL('image/png');
  }
};

prototype.render = function(items) {
  this._renderer.render(this._model.scene(), items);
  return this;
};

prototype.on = function() {
  this._handler.on.apply(this._handler, arguments);
  return this;
};

prototype.onSignal = function(name, handler) {
  this._model.signal(name).on(handler);
  return this;
};

prototype.off = function() {
  this._handler.off.apply(this._handler, arguments);
  return this;
};

prototype.offSignal = function(name, handler) {
  this._model.signal(name).off(handler);
  return this;
};

View.factory = function(model) {
  var HeadlessView = require('./HeadlessView');
  return function(opt) {
    opt = opt || {};
    var defs = model.defs();
    var v = (opt.el ? new View() : new HeadlessView())
      .model(model)
      .renderer(opt.renderer || 'canvas')
      .width(defs.width)
      .height(defs.height)
      .background(defs.background)
      .padding(defs.padding)
      .viewport(defs.viewport)
      .initialize(opt.el);

    if (opt.data) v.data(opt.data);

    if (opt.hover !== false && opt.el) {
      v.on('mouseover', function(evt, item) {
        if (item && item.hasPropertySet('hover')) {
          this.update({props:'hover', items:item});
        }
      })
      .on('mouseout', function(evt, item) {
        if (item && item.hasPropertySet('hover')) {
          this.update({props:'update', items:item});
        }
      });
    }
  
    return v;
  };    
};

module.exports = View;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../parse/streams":208,"../scene/Encoder":212,"../scene/Transition":215,"./HeadlessView":188,"datalib":49,"vega-dataflow":141,"vega-logging":147,"vega-scenegraph":148}],191:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    config = {};

config.load = {
  // base url for loading external data files
  // used only for server-side operation
  baseURL: '',
  // Allows domain restriction when using data loading via XHR.
  // To enable, set it to a list of allowed domains
  // e.g., ['wikipedia.org', 'eff.org']
  domainWhiteList: false
};

// inset padding for automatic padding calculation
config.autopadInset = 5;

// extensible scale lookup table
// all d3.scale.* instances also supported
config.scale = {
  time: d3.time.scale,
  utc:  d3.time.scale.utc
};

// default rendering settings
config.render = {
  retina: true
};

// default axis properties
config.axis = {
  orient: 'bottom',
  ticks: 10,
  padding: 3,
  axisColor: '#000',
  gridColor: '#000',
  gridOpacity: 0.15,
  tickColor: '#000',
  tickLabelColor: '#000',
  axisWidth: 1,
  tickWidth: 1,
  tickSize: 6,
  tickLabelFontSize: 11,
  tickLabelFont: 'sans-serif',
  titleColor: '#000',
  titleFont: 'sans-serif',
  titleFontSize: 11,
  titleFontWeight: 'bold',
  titleOffset: 35
};

// default legend properties
config.legend = {
  orient: 'right',
  offset: 20,
  padding: 3,
  gradientStrokeColor: '#888',
  gradientStrokeWidth: 1,
  gradientHeight: 16,
  gradientWidth: 100,
  labelColor: '#000',
  labelFontSize: 10,
  labelFont: 'sans-serif',
  labelAlign: 'left',
  labelBaseline: 'middle',
  labelOffset: 8,
  symbolShape: 'circle',
  symbolSize: 50,
  symbolColor: '#888',
  symbolStrokeWidth: 1,
  titleColor: '#000',
  titleFont: 'sans-serif',
  titleFontSize: 11,
  titleFontWeight: 'bold'
};

// default color values
config.color = {
  rgb: [128, 128, 128],
  lab: [50, 0, 0],
  hcl: [0, 0, 50],
  hsl: [0, 0, 0.5]
};

// default scale ranges
config.range = {
  category10:  d3.scale.category10().range(),
  category20:  d3.scale.category20().range(),
  category20b: d3.scale.category20b().range(),
  category20c: d3.scale.category20c().range(),
  shapes: [
    'circle',
    'cross',
    'diamond',
    'square',
    'triangle-down',
    'triangle-up'
  ]
};

module.exports = config;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],192:[function(require,module,exports){
var dl = require('datalib'),
    parse = require('../parse'),
    Scale = require('../scene/Scale'),
    config = require('./config');

function compile(module, opt, schema) {
  var s = module.schema;
  if (!s) return;
  if (s.refs) dl.extend(schema.refs, s.refs);
  if (s.defs) dl.extend(schema.defs, s.defs);
}

module.exports = function(opt) {
  var schema = null;
  opt = opt || {};

  // Compile if we're not loading the schema from a URL. 
  // Load from a URL to extend the existing base schema.
  if (opt.url) {
    schema = dl.json(dl.extend({url: opt.url}, config.load));
  } else {
    schema = {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "title": "Vega Visualization Specification Language",
      "defs": {}, 
      "refs": {}, 
      "$ref": "#/defs/spec"
    };

    dl.keys(parse).forEach(function(k) { compile(parse[k], opt, schema); });

    // Scales aren't in the parser, add schema manually
    compile(Scale, opt, schema);
  }

  // Extend schema to support custom mark properties or property sets.
  if (opt.properties) dl.keys(opt.properties).forEach(function(k) {
    schema.defs.propset.properties[k] = {"$ref": "#/refs/"+opt.properties[k]+"Value"};
  });

  if (opt.propertySets) dl.keys(opt.propertySets).forEach(function(k) {
    schema.defs.mark.properties.properties.properties[k] = {"$ref": "#/defs/propset"};
  });

  return schema;
};
},{"../parse":198,"../scene/Scale":214,"./config":191,"datalib":49}],193:[function(require,module,exports){
var dl = require('datalib'),
    axs = require('../scene/axis');

var ORIENT = {
  "x":      "bottom",
  "y":      "left",
  "top":    "top",
  "bottom": "bottom",
  "left":   "left",
  "right":  "right"
};

function parseAxes(model, spec, axes, group) {
  var config = model.config();
  (spec || []).forEach(function(def, index) {
    axes[index] = axes[index] || axs(model);
    parseAxis(config, def, index, axes[index], group);
  });
}

function parseAxis(config, def, index, axis, group) {
  // axis scale
  if (def.scale !== undefined) {
    axis.scale(group.scale(def.scale));
  }

  // axis orientation
  axis.orient(def.orient || ORIENT[def.type]);
  // axis offset
  axis.offset(def.offset || 0);
  // axis layer
  axis.layer(def.layer || "front");
  // axis grid lines
  axis.grid(def.grid || false);
  // axis title
  axis.title(def.title || null);
  // axis title offset
  axis.titleOffset(def.titleOffset != null ?
    def.titleOffset : config.axis.titleOffset);
  // axis values
  axis.tickValues(def.values || null);
  // axis label formatting
  axis.tickFormat(def.format || null);
  axis.tickFormatType(def.formatType || null);
  // axis tick subdivision
  axis.tickSubdivide(def.subdivide || 0);
  // axis tick padding
  axis.tickPadding(def.tickPadding || config.axis.padding);

  // axis tick size(s)
  var size = [];
  if (def.tickSize !== undefined) {
    for (var i=0; i<3; ++i) size.push(def.tickSize);
  } else {
    var ts = config.axis.tickSize;
    size = [ts, ts, ts];
  }
  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;
  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;
  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;
  if (size.length) {
    axis.tickSize.apply(axis, size);
  }

  // axis tick count
  axis.tickCount(def.ticks || config.axis.ticks);

  // style properties
  var p = def.properties;
  if (p && p.ticks) {
    axis.majorTickProperties(p.majorTicks ?
      dl.extend({}, p.ticks, p.majorTicks) : p.ticks);
    axis.minorTickProperties(p.minorTicks ?
      dl.extend({}, p.ticks, p.minorTicks) : p.ticks);
  } else {
    axis.majorTickProperties(p && p.majorTicks || {});
    axis.minorTickProperties(p && p.minorTicks || {});
  }
  axis.tickLabelProperties(p && p.labels || {});
  axis.titleProperties(p && p.title || {});
  axis.gridLineProperties(p && p.grid || {});
  axis.domainProperties(p && p.axis || {});
}

module.exports = parseAxes;
},{"../scene/axis":216,"datalib":49}],194:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null);

function parseBg(bg) {
  // return null if input is null or undefined
  if (bg == null) return null;
  // run through d3 rgb to sanity check
  return d3.rgb(bg) + "";  
}

module.exports = parseBg;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],195:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    parseTransforms = require('./transforms'),
    parseModify = require('./modify');

function parseData(model, spec, callback) {
  var config = model.config(),
      count = 0;

  function loaded(d) {
    return function(error, data) {
      if (error) {
        log.error('LOADING FAILED: ' + d.url + ' ' + error);
      } else {
        model.data(d.name).values(dl.read(data, d.format));
      }
      if (--count === 0) callback();
    };
  }

  // process each data set definition
  (spec || []).forEach(function(d) {
    if (d.url) {
      count += 1;
      dl.load(dl.extend({url: d.url}, config.load), loaded(d));
    }
    parseData.datasource(model, d);
  });

  if (count === 0) setTimeout(callback, 1);
  return spec;
}

parseData.datasource = function(model, d) {
  var transform = (d.transform || []).map(function(t) {
        return parseTransforms(model, t); 
      }),
      mod = (d.modify || []).map(function(m) {
        return parseModify(model, m, d);
      }),
      ds = model.data(d.name, mod.concat(transform));

  if (d.values) {
    ds.values(dl.read(d.values, d.format));
  } else if (d.source) {
    // Derived ds will be pulsed by its src rather than the model.
    ds.source(d.source).addListener(ds);  
    model.removeListener(ds.pipeline()[0]); 
  }

  return ds;    
};

module.exports = parseData;
},{"./modify":202,"./transforms":209,"datalib":49,"vega-logging":147}],196:[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = ",",
        peg$c2 = { type: "literal", value: ",", description: "\",\"" },
        peg$c3 = function(o, m) { return [o].concat(m); },
        peg$c4 = function(o) { return [o]; },
        peg$c5 = "[",
        peg$c6 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c7 = "]",
        peg$c8 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c9 = ">",
        peg$c10 = { type: "literal", value: ">", description: "\">\"" },
        peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}; },
        peg$c12 = [],
        peg$c13 = function(s, f) { return (s.filters = f, s); },
        peg$c14 = function(s) { return s; },
        peg$c15 = "(",
        peg$c16 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c17 = ")",
        peg$c18 = { type: "literal", value: ")", description: "\")\"" },
        peg$c19 = function(m) { return {stream: m}; },
        peg$c20 = "@",
        peg$c21 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(n, e) { return {event: e, name: n}; },
        peg$c25 = function(m, e) { return {event: e, mark: m}; },
        peg$c26 = function(t, e) { return {event: e, target: t}; },
        peg$c27 = function(e) { return {event: e}; },
        peg$c28 = function(s) { return {signal: s}; },
        peg$c29 = "rect",
        peg$c30 = { type: "literal", value: "rect", description: "\"rect\"" },
        peg$c31 = "symbol",
        peg$c32 = { type: "literal", value: "symbol", description: "\"symbol\"" },
        peg$c33 = "path",
        peg$c34 = { type: "literal", value: "path", description: "\"path\"" },
        peg$c35 = "arc",
        peg$c36 = { type: "literal", value: "arc", description: "\"arc\"" },
        peg$c37 = "area",
        peg$c38 = { type: "literal", value: "area", description: "\"area\"" },
        peg$c39 = "line",
        peg$c40 = { type: "literal", value: "line", description: "\"line\"" },
        peg$c41 = "rule",
        peg$c42 = { type: "literal", value: "rule", description: "\"rule\"" },
        peg$c43 = "image",
        peg$c44 = { type: "literal", value: "image", description: "\"image\"" },
        peg$c45 = "text",
        peg$c46 = { type: "literal", value: "text", description: "\"text\"" },
        peg$c47 = "group",
        peg$c48 = { type: "literal", value: "group", description: "\"group\"" },
        peg$c49 = "mousedown",
        peg$c50 = { type: "literal", value: "mousedown", description: "\"mousedown\"" },
        peg$c51 = "mouseup",
        peg$c52 = { type: "literal", value: "mouseup", description: "\"mouseup\"" },
        peg$c53 = "click",
        peg$c54 = { type: "literal", value: "click", description: "\"click\"" },
        peg$c55 = "dblclick",
        peg$c56 = { type: "literal", value: "dblclick", description: "\"dblclick\"" },
        peg$c57 = "wheel",
        peg$c58 = { type: "literal", value: "wheel", description: "\"wheel\"" },
        peg$c59 = "keydown",
        peg$c60 = { type: "literal", value: "keydown", description: "\"keydown\"" },
        peg$c61 = "keypress",
        peg$c62 = { type: "literal", value: "keypress", description: "\"keypress\"" },
        peg$c63 = "keyup",
        peg$c64 = { type: "literal", value: "keyup", description: "\"keyup\"" },
        peg$c65 = "mousewheel",
        peg$c66 = { type: "literal", value: "mousewheel", description: "\"mousewheel\"" },
        peg$c67 = "mousemove",
        peg$c68 = { type: "literal", value: "mousemove", description: "\"mousemove\"" },
        peg$c69 = "mouseout",
        peg$c70 = { type: "literal", value: "mouseout", description: "\"mouseout\"" },
        peg$c71 = "mouseover",
        peg$c72 = { type: "literal", value: "mouseover", description: "\"mouseover\"" },
        peg$c73 = "mouseenter",
        peg$c74 = { type: "literal", value: "mouseenter", description: "\"mouseenter\"" },
        peg$c75 = "touchstart",
        peg$c76 = { type: "literal", value: "touchstart", description: "\"touchstart\"" },
        peg$c77 = "touchmove",
        peg$c78 = { type: "literal", value: "touchmove", description: "\"touchmove\"" },
        peg$c79 = "touchend",
        peg$c80 = { type: "literal", value: "touchend", description: "\"touchend\"" },
        peg$c81 = function(e) { return e; },
        peg$c82 = /^[a-zA-Z0-9_\-]/,
        peg$c83 = { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
        peg$c84 = function(n) { return n.join(""); },
        peg$c85 = /^[a-zA-Z0-9\-_  #.>+~[\]=|\^$*]/,
        peg$c86 = { type: "class", value: "[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]", description: "[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]" },
        peg$c87 = function(c) { return c.join(""); },
        peg$c88 = /^['"a-zA-Z0-9_().><=! \t-&|~]/,
        peg$c89 = { type: "class", value: "['\"a-zA-Z0-9_().><=! \\t-&|~]", description: "['\"a-zA-Z0-9_().><=! \\t-&|~]" },
        peg$c90 = function(v) { return v.join(""); },
        peg$c91 = /^[ \t\r\n]/,
        peg$c92 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemerged();

      return s0;
    }

    function peg$parsemerged() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseordered();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesep();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c1;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c2); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsesep();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemerged();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c3(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseordered();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c4(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseordered() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesep();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefiltered();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsesep();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c2); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsesep();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsefiltered();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesep();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s9 = peg$c7;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c8); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesep();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 62) {
                            s11 = peg$c9;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c10); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parsesep();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseordered();
                              if (s13 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c11(s3, s7, s13);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsefiltered();
      }

      return s0;
    }

    function peg$parsefiltered() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsestream();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsefilter();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsefilter();
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c13(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsestream();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c14(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsestream() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemerged();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c19(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s1 = peg$c20;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s3 = peg$c22;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseeventType();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c24(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemarkType();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c22;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseeventType();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c25(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecss();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c22;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c23); }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseeventType();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseeventType();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c27(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsename();
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c28(s1);
                }
                s0 = s1;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsemarkType() {
      var s0;

      if (input.substr(peg$currPos, 4) === peg$c29) {
        s0 = peg$c29;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c31) {
          s0 = peg$c31;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s0 = peg$c33;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c35) {
              s0 = peg$c35;
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c37) {
                s0 = peg$c37;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c39) {
                  s0 = peg$c39;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c40); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c41) {
                    s0 = peg$c41;
                    peg$currPos += 4;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c42); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c43) {
                      s0 = peg$c43;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c44); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c45) {
                        s0 = peg$c45;
                        peg$currPos += 4;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c46); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c47) {
                          s0 = peg$c47;
                          peg$currPos += 5;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c48); }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseeventType() {
      var s0;

      if (input.substr(peg$currPos, 9) === peg$c49) {
        s0 = peg$c49;
        peg$currPos += 9;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c51) {
          s0 = peg$c51;
          peg$currPos += 7;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c53) {
            s0 = peg$c53;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c54); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c55) {
              s0 = peg$c55;
              peg$currPos += 8;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c57) {
                s0 = peg$c57;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c58); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c59) {
                  s0 = peg$c59;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c60); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c61) {
                    s0 = peg$c61;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c62); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c63) {
                      s0 = peg$c63;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c64); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 10) === peg$c65) {
                        s0 = peg$c65;
                        peg$currPos += 10;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c66); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c67) {
                          s0 = peg$c67;
                          peg$currPos += 9;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c68); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c69) {
                            s0 = peg$c69;
                            peg$currPos += 8;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c70); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c71) {
                              s0 = peg$c71;
                              peg$currPos += 9;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c72); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 10) === peg$c73) {
                                s0 = peg$c73;
                                peg$currPos += 10;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c74); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 10) === peg$c75) {
                                  s0 = peg$c75;
                                  peg$currPos += 10;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c76); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 9) === peg$c77) {
                                    s0 = peg$c77;
                                    peg$currPos += 9;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c78); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c79) {
                                      s0 = peg$c79;
                                      peg$currPos += 8;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c80); }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsefilter() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpr();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c81(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsename() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c82.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c82.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c83); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c84(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsecss() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c85.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c86); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c87(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseexpr() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c88.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c88.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c89); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c90(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsesep() {
      var s0, s1;

      s0 = [];
      if (peg$c91.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c91.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
},{}],197:[function(require,module,exports){
var expr = require('vega-expression'),
    args = ['datum', 'event', 'signals'];

module.exports = expr.compiler(args, {
  idWhiteList: args,
  fieldVar:    args[0],
  globalVar:   args[2],
  functions:   function(codegen) {
    var fn = expr.functions(codegen);
    fn.eventItem = function() { return 'event.vg.item'; };
    fn.eventGroup = 'event.vg.getGroup';
    fn.eventX = 'event.vg.getX';
    fn.eventY = 'event.vg.getY';
    fn.open = 'window.open';
    return fn;
  }
});
},{"vega-expression":145}],198:[function(require,module,exports){
module.exports = {
  axes: require('./axes'),
  background: require('./background'),
  data: require('./data'),
  events: require('./events'),
  expr: require('./expr'),
  legends: require('./legends'),
  mark: require('./mark'),
  marks: require('./marks'),
  modify: require('./modify'),
  padding: require('./padding'),
  predicates: require('./predicates'),
  properties: require('./properties'),
  signals: require('./signals'),
  spec: require('./spec'),
  streams: require('./streams'),
  transforms: require('./transforms')
};
},{"./axes":193,"./background":194,"./data":195,"./events":196,"./expr":197,"./legends":199,"./mark":200,"./marks":201,"./modify":202,"./padding":203,"./predicates":204,"./properties":205,"./signals":206,"./spec":207,"./streams":208,"./transforms":209}],199:[function(require,module,exports){
var lgnd = require('../scene/legend');

function parseLegends(model, spec, legends, group) {
  (spec || []).forEach(function(def, index) {
    legends[index] = legends[index] || lgnd(model);
    parseLegend(def, index, legends[index], group);
  });
}

function parseLegend(def, index, legend, group) {
  // legend scales
  legend.size  (def.size   ? group.scale(def.size)   : null);
  legend.shape (def.shape  ? group.scale(def.shape)  : null);
  legend.fill  (def.fill   ? group.scale(def.fill)   : null);
  legend.stroke(def.stroke ? group.scale(def.stroke) : null);

  // legend orientation
  if (def.orient) legend.orient(def.orient);

  // legend offset
  if (def.offset != null) legend.offset(def.offset);

  // legend title
  legend.title(def.title || null);

  // legend values
  legend.values(def.values || null);

  // legend label formatting
  legend.format(def.format !== undefined ? def.format : null);

  // style properties
  var p = def.properties;
  legend.titleProperties(p && p.title || {});
  legend.labelProperties(p && p.labels || {});
  legend.legendProperties(p && p.legend || {});
  legend.symbolProperties(p && p.symbols || {});
  legend.gradientProperties(p && p.gradient || {});
}

module.exports = parseLegends;
},{"../scene/legend":217}],200:[function(require,module,exports){
var dl = require('datalib'),
    parseProperties = require('./properties');

function parseMark(model, mark) {
  var props = mark.properties,
      group = mark.marks;

  // parse mark property definitions
  dl.keys(props).forEach(function(k) {
    props[k] = parseProperties(model, mark.type, props[k]);
  });

  // parse delay function
  if (mark.delay) {
    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});
  }

  // recurse if group type
  if (group) {
    mark.marks = group.map(function(g) { return parseMark(model, g); });
  }
    
  return mark;
}

module.exports = parseMark;
},{"./properties":205,"datalib":49}],201:[function(require,module,exports){
var parseMark = require('./mark');

function parseRootMark(model, spec, width, height) {
  return {
    type: "group",
    width: width,
    height: height,
    scales: spec.scales || [],
    axes: spec.axes || [],
    legends: spec.legends || [],
    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })
  };
}

module.exports = parseRootMark;
},{"./mark":200}],202:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Tuple = df.Tuple,
    Deps = df.Dependencies;

var Types = {
  INSERT: "insert",
  REMOVE: "remove",
  TOGGLE: "toggle",
  CLEAR:  "clear"
};

var EMPTY = [];

var filter = function(field, value, src, dest) {
  for(var i = src.length-1; i >= 0; --i) {
    if (src[i][field] == value)
      dest.push.apply(dest, src.splice(i, 1));
  }
};

function parseModify(model, def, ds) {
  var signal = def.signal ? dl.field(def.signal) : null, 
      signalName = signal ? signal[0] : null,
      predicate = def.predicate ? model.predicate(def.predicate.name || def.predicate) : null,
      reeval = (predicate === null),
      node = new Node(model).router(def.type === Types.CLEAR);

  node.evaluate = function(input) {
    if (predicate !== null) {  // TODO: predicate args
      var db = model.values(Deps.DATA, predicate.data || EMPTY),
          sg = model.values(Deps.SIGNALS, predicate.signals || EMPTY);
      reeval = predicate.call(predicate, {}, db, sg, model._predicates);
    }

    log.debug(input, [def.type+"ing", reeval]);
    if (!reeval) return input;

    var datum = {}, 
        value = signal ? model.signalRef(def.signal) : null,
        d = model.data(ds.name),
        t = null;

    datum[def.field] = value;

    // We have to modify ds._data so that subsequent pulses contain
    // our dynamic data. W/o modifying ds._data, only the output
    // collector will contain dynamic tuples. 
    if (def.type === Types.INSERT) {
      t = Tuple.ingest(datum);
      input.add.push(t);
      d._data.push(t);
    } else if (def.type === Types.REMOVE) {
      filter(def.field, value, input.add, input.rem);
      filter(def.field, value, input.mod, input.rem);
      d._data = d._data.filter(function(x) { return x[def.field] !== value; });
    } else if (def.type === Types.TOGGLE) {
      var add = [], rem = [];
      filter(def.field, value, input.rem, add);
      filter(def.field, value, input.add, rem);
      filter(def.field, value, input.mod, rem);
      if (!(add.length || rem.length)) add.push(Tuple.ingest(datum));

      input.add.push.apply(input.add, add);
      d._data.push.apply(d._data, add);
      input.rem.push.apply(input.rem, rem);
      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1; });
    } else if (def.type === Types.CLEAR) {
      input.rem.push.apply(input.rem, input.add);
      input.rem.push.apply(input.rem, input.mod);
      input.add = [];
      input.mod = [];
      d._data  = [];
    } 

    input.fields[def.field] = 1;
    return input;
  };

  if (signalName) node.dependency(Deps.SIGNALS, signalName);
  
  if (predicate) {
    node.dependency(Deps.DATA, predicate.data);
    node.dependency(Deps.SIGNALS, predicate.signals);
  }
  
  return node;
}

module.exports = parseModify;
},{"datalib":49,"vega-dataflow":141,"vega-logging":147}],203:[function(require,module,exports){
var dl = require('datalib');

function parsePadding(pad) {
  if (pad == null) return "auto";
  else if (dl.isString(pad)) return pad==="strict" ? "strict" : "auto";
  else if (dl.isObject(pad)) return pad;
  var p = dl.isNumber(pad) ? pad : 20;
  return {top:p, left:p, right:p, bottom:p};
}

module.exports = parsePadding;
},{"datalib":49}],204:[function(require,module,exports){
var dl = require('datalib');

var types = {
  '=':   parseComparator,
  '==':  parseComparator,
  '!=':  parseComparator,
  '>':   parseComparator,
  '>=':  parseComparator,
  '<':   parseComparator,
  '<=':  parseComparator,
  'and': parseLogical,
  '&&':  parseLogical,
  'or':  parseLogical,
  '||':  parseLogical,
  'in':  parseIn
};

var nullScale = function() { return 0; };
nullScale.invert = nullScale;

function parsePredicates(model, spec) {
  (spec || []).forEach(function(s) {
    var parse = types[s.type](model, s);
    
    /* jshint evil:true */
    var pred  = Function("args", "db", "signals", "predicates", parse.code);
    pred.root = function() { return model.scene().items[0]; }; // For global scales
    pred.nullScale = nullScale;
    pred.isFunction = dl.isFunction;
    pred.signals = parse.signals;
    pred.data = parse.data;

    model.predicate(s.name, pred);
  });

  return spec;
}

function parseSignal(signal, signals) {
  var s = dl.field(signal),
      code = "signals["+s.map(dl.str).join("][")+"]";
  signals[s[0]] = 1;
  return code;
}

function parseOperands(model, operands) {
  var decl = [], defs = [],
      signals = {}, db = {};

  function setSignal(s) { signals[s] = 1; }
  function setData(d) { db[d] = 1; }

  dl.array(operands).forEach(function(o, i) {
    var name = "o" + i,
        def = "";

    if (o.value !== undefined) {
      def = dl.str(o.value);
    } else if (o.arg) {
      def = "args["+dl.str(o.arg)+"]";
    } else if (o.signal) {
      def = parseSignal(o.signal, signals);
    } else if (o.predicate) {
      var ref = o.predicate,
          predName = ref && (ref.name || ref),
          pred = model.predicate(predName),
          p = "predicates["+dl.str(predName)+"]";

      pred.signals.forEach(setSignal);
      pred.data.forEach(setData);

      if (dl.isObject(ref)) {
        dl.keys(ref).forEach(function(k) {
          if (k === "name") return;
          var i = ref[k];
          def += "args["+dl.str(k)+"] = ";
          if (i.signal) {
            def += parseSignal(i.signal, signals);
          } else if (i.arg) {
            def += "args["+dl.str(i.arg)+"]";
          }
          def += ", ";
        });  
      } 

      def += p+".call("+p+", args, db, signals, predicates)";
    }

    decl.push(name);
    defs.push(name+"=("+def+")");
  });

  return {
    code: "var " + decl.join(", ") + ";\n" + defs.join(";\n") + ";\n",
    signals: dl.keys(signals),
    data: dl.keys(db)
  };
}

function parseComparator(model, spec) {
  var ops = parseOperands(model, spec.operands);
  if (spec.type === '=') spec.type = '==';

  ops.code += "o0 = o0 instanceof Date ? o0.getTime() : o0;\n" +
    "o1 = o1 instanceof Date ? o1.getTime() : o1;\n";

  return {
    code: ops.code + "return " + ["o0", "o1"].join(spec.type) + ";",
    signals: ops.signals,
    data: ops.data
  };
}

function parseLogical(model, spec) {
  var ops = parseOperands(model, spec.operands),
      o = [], i = 0, len = spec.operands.length;

  while (o.push("o"+i++) < len);
  if (spec.type === 'and') spec.type = '&&';
  else if (spec.type === 'or') spec.type = '||';

  return {
    code: ops.code + "return " + o.join(spec.type) + ";",
    signals: ops.signals,
    data: ops.data
  };
}

function parseIn(model, spec) {
  var o = [spec.item], code = "";
  if (spec.range) o.push.apply(o, spec.range);
  if (spec.scale) {
    code = parseScale(spec.scale, o);
  }

  var ops = parseOperands(model, o);
  code = ops.code + code + "\n  var ordSet = null;\n";

  if (spec.data) {
    var field = dl.field(spec.field).map(dl.str);
    code += "var where = function(d) { return d["+field.join("][")+"] == o0 };\n";
    code += "return db["+dl.str(spec.data)+"].filter(where).length > 0;";
  } else if (spec.range) {
    // TODO: inclusive/exclusive range?
    if (spec.scale) {
      code += "if (scale.length == 2) {\n" + // inverting ordinal scales
        "  ordSet = scale(o1, o2);\n" +
        "} else {\n" +
        "  o1 = scale(o1);\no2 = scale(o2);\n" +
        "}";
    }

    code += "return ordSet !== null ? ordSet.indexOf(o0) !== -1 :\n" + 
      "  o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1;";
  }

  return {
    code: code, 
    signals: ops.signals, 
    data: ops.data.concat(spec.data ? [spec.data] : [])
  };
}

// Populate ops such that ultimate scale/inversion function will be in `scale` var. 
function parseScale(spec, ops) {
  var code = "var scale = ", 
      idx  = ops.length;

  if (dl.isString(spec)) {
    ops.push({ value: spec });
    code += "this.root().scale(o"+idx+")";
  } else if (spec.arg) {  // Scale function is being passed as an arg
    ops.push(spec);
    code += "o"+idx;
  } else if (spec.name) { // Full scale parameter {name: ..}
    ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);
    code += "(this.isFunction(o"+idx+") ? o"+idx+" : ";
    if (spec.scope) {
      ops.push(spec.scope);
      code += "((o"+(idx+1)+".scale || this.root().scale)(o"+idx+") || this.nullScale)";
    } else {
      code += "this.root().scale(o"+idx+")";
    }
    code += ")";
  }

  if (spec.invert === true) {  // Allow spec.invert.arg?
    code += ".invert";
  }

  return code+";\n";
}

module.exports = parsePredicates;
},{"datalib":49}],205:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    log = require('vega-logging'),
    Tuple = require('vega-dataflow').Tuple;

var DEPS = ["signals", "scales", "data", "fields"];

function properties(model, mark, spec) {
  var config = model.config(),
      code = "",
      names = dl.keys(spec),
      i, len, name, ref, vars = {}, 
      deps = {
        signals: {},
        scales:  {},
        data:    {},
        fields:  {},
        nested:  [],
        _nRefs:  {},  // Temp stash to de-dupe nested refs.
        reflow:  false
      };
      
  code += "var o = trans ? {} : item, d=0, set=this.tpl.set, tmpl=signals||{}, t;\n" +
          // Stash for dl.template
          "tmpl.datum  = item.datum;\n" + 
          "tmpl.group  = group;\n" + 
          "tmpl.parent = group.datum;\n";

  function handleDep(p) {
    if (ref[p] == null) return;
    var k = dl.array(ref[p]), i, n;
    for (i=0, n=k.length; i<n; ++i) {
      deps[p][k[i]] = 1;
    }
  }

  function handleNestedRefs(r) {
    var k = (r.parent ? "parent_" : "group_")+r.level;
    deps._nRefs[k] = r;
  }

  for (i=0, len=names.length; i<len; ++i) {
    ref = spec[name = names[i]];
    code += (i > 0) ? "\n  " : "  ";
    if (ref.rule) {
      ref = rule(model, name, ref.rule);
      code += "\n  " + ref.code;
    } else {
      ref = valueRef(config, name, ref);
      code += "d += set(o, "+dl.str(name)+", "+ref.val+");";
    }

    vars[name] = true;
    DEPS.forEach(handleDep);
    deps.reflow = deps.reflow || ref.reflow;
    if (ref.nested.length) ref.nested.forEach(handleNestedRefs);
  }

  // If nested references are present, sort them based on their level
  // to speed up determination of whether encoders should be reeval'd.
  dl.keys(deps._nRefs).forEach(function(k) { deps.nested.push(deps._nRefs[k]); });
  deps.nested.sort(function(a, b) { 
    a = a.level;
    b = b.level;
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; 
  });

  if (vars.x2) {
    if (vars.x) {
      code += "\n  if (o.x > o.x2) { " +
              "\n    t = o.x;" +
              "\n    d += set(o, 'x', o.x2);" +
              "\n    d += set(o, 'x2', t); " +
              "\n  };";
      code += "\n  d += set(o, 'width', (o.x2 - o.x));";
    } else if (vars.width) {
      code += "\n  d += set(o, 'x', (o.x2 - o.width));";
    } else {
      code += "\n  d += set(o, 'x', o.x2);";
    }
  }

  if (vars.xc) {
    if (vars.width) {
      code += "\n  d += set(o, 'x', (o.xc - o.width/2));" ;
    } else {
      code += "\n  d += set(o, 'x', o.xc);" ;
    }
  }

  if (vars.y2) {
    if (vars.y) {
      code += "\n  if (o.y > o.y2) { " +
              "\n    t = o.y;" +
              "\n    d += set(o, 'y', o.y2);" +
              "\n    d += set(o, 'y2', t);" +
              "\n  };";
      code += "\n  d += set(o, 'height', (o.y2 - o.y));";
    } else if (vars.height) {
      code += "\n  d += set(o, 'y', (o.y2 - o.height));";
    } else {
      code += "\n  d += set(o, 'y', o.y2);";
    }
  }

  if (vars.yc) {
    if (vars.height) {
      code += "\n  d += set(o, 'y', (o.yc - o.height/2));" ;
    } else {
      code += "\n  d += set(o, 'y', o.yc);" ;
    }
  }
  
  if (hasPath(mark, vars)) code += "\n  d += (item.touch(), 1);";
  code += "\n  if (trans) trans.interpolate(item, o);";
  code += "\n  return d > 0;";

  try {
    /* jshint evil:true */
    var encoder = Function('item', 'group', 'trans', 'db', 
      'signals', 'predicates', code);
    encoder.tpl  = Tuple;
    encoder.util = dl;
    encoder.d3   = d3; // For color spaces
    dl.extend(encoder, dl.template.context);
    return {
      encode:  encoder,
      signals: dl.keys(deps.signals),
      scales:  dl.keys(deps.scales),
      data:    dl.keys(deps.data),
      fields:  dl.keys(deps.fields),
      nested:  deps.nested,
      reflow:  deps.reflow
    };
  } catch (e) {
    log.error(e);
    log.log(code);
  }
}

function dependencies(a, b) {
  if (!dl.isObject(a)) {
    a = {reflow: false, nested: []};
    DEPS.forEach(function(d) { a[d] = []; });
  }

  if (dl.isObject(b)) {
    a.reflow = a.reflow || b.reflow;
    a.nested.push.apply(a.nested, b.nested);
    DEPS.forEach(function(d) { a[d].push.apply(a[d], b[d]); });
  }

  return a;
}

function hasPath(mark, vars) {
  return vars.path ||
    ((mark==='area' || mark==='line') &&
      (vars.x || vars.x2 || vars.width ||
       vars.y || vars.y2 || vars.height ||
       vars.tension || vars.interpolate));
}

function rule(model, name, rules) {
  var config  = model.config(),
      deps = dependencies(),
      inputs  = [], code = '';

  (rules||[]).forEach(function(r, i) {
    var def = r.predicate,
        predName = def && (def.name || def),
        pred = model.predicate(predName),
        p = 'predicates['+dl.str(predName)+']',
        input = [], args = name+'_arg'+i,
        ref;

    if (dl.isObject(def)) {
      dl.keys(def).forEach(function(k) {
        if (k === 'name') return;
        var ref = valueRef(config, i, def[k]);
        input.push(dl.str(k)+': '+ref.val);
        dependencies(deps, ref);
      });
    }

    ref = valueRef(config, name, r);
    dependencies(deps, ref);

    if (predName) {
      deps.signals.push.apply(deps.signals, pred.signals);
      deps.data.push.apply(deps.data, pred.data);
      inputs.push(args+" = {\n    "+input.join(",\n    ")+"\n  }");
      code += "if ("+p+".call("+p+","+args+", db, signals, predicates)) {" +
        "\n    d += set(o, "+dl.str(name)+", "+ref.val+");";
      code += rules[i+1] ? "\n  } else " : "  }";
    } else {
      code += "{" + 
        "\n    d += set(o, "+dl.str(name)+", "+ref.val+");"+
        "\n  }\n";
    }
  });

  code = "var " + inputs.join(",\n      ") + ";\n  " + code;
  return (deps.code = code, deps);
}

function valueRef(config, name, ref) {
  if (ref == null) return null;

  if (name==='fill' || name==='stroke') {
    if (ref.c) {
      return colorRef(config, 'hcl', ref.h, ref.c, ref.l);
    } else if (ref.h || ref.s) {
      return colorRef(config, 'hsl', ref.h, ref.s, ref.l);
    } else if (ref.l || ref.a) {
      return colorRef(config, 'lab', ref.l, ref.a, ref.b);
    } else if (ref.r || ref.g || ref.b) {
      return colorRef(config, 'rgb', ref.r, ref.g, ref.b);
    }
  }

  // initialize value
  var val = null, scale = null, 
      deps = dependencies(),
      sgRef = null, fRef = null, sRef = null, tmpl = {};

  if (ref.template !== undefined) {
    val = dl.template.source(ref.template, 'tmpl', tmpl);
    dl.keys(tmpl).forEach(function(k) {
      var f = dl.field(k),
          a = f.shift();
      if (a === 'parent' || a === 'group') {
        deps.nested.push({ 
          parent: a === 'parent',
          group:  a === 'group', 
          level:  1
        });
      } else if (a === 'datum') {
        deps.fields.push(f[0]);
      } else {
        deps.signals.push(a);
      }
    });
  }

  if (ref.value !== undefined) {
    val = dl.str(ref.value);
  }

  if (ref.signal !== undefined) {
    sgRef = dl.field(ref.signal);
    val = 'signals['+sgRef.map(dl.str).join('][')+']'; 
    deps.signals.push(sgRef.shift());
  }

  if (ref.field !== undefined) {
    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;
    fRef = fieldRef(ref.field);
    val  = fRef.val;
    dependencies(deps, fRef);
  }

  if (ref.scale !== undefined) {
    sRef  = scaleRef(ref.scale);
    scale = sRef.val;
    dependencies(deps, sRef);
    deps.scales.push(ref.scale.name || ref.scale);

    // run through scale function if val specified.
    // if no val, scale function is predicate arg.
    if (val !== null || ref.band || ref.mult || ref.offset) {
      val = scale + (ref.band ? '.rangeBand()' : 
        '('+(val !== null ? val : 'item.datum.data')+')');
    } else {
      val = scale;
    }
  }
  
  // multiply, offset, return value
  val = '(' + (ref.mult?(dl.number(ref.mult)+' * '):'') + val + ')' +
        (ref.offset ? ' + ' + dl.number(ref.offset) : '');

  // Collate dependencies
  return (deps.val = val, deps);
}

function colorRef(config, type, x, y, z) {
  var xx = x ? valueRef(config, '', x) : config.color[type][0],
      yy = y ? valueRef(config, '', y) : config.color[type][1],
      zz = z ? valueRef(config, '', z) : config.color[type][2],
      deps = dependencies();

  [xx, yy, zz].forEach(function(v) {
    if (dl.isArray) return;
    dependencies(deps, v);
  });

  var val = '(this.d3.' + type + '(' + [xx.val, yy.val, zz.val].join(',') + ') + "")';
  return (deps.val = val, deps);
}

// {field: {datum: "foo"} }  -> item.datum.foo
// {field: {group: "foo"} }  -> group.foo
// {field: {parent: "foo"} } -> group.datum.foo
function fieldRef(ref) {
  if (dl.isString(ref)) {
    return {val: dl.field(ref).map(dl.str).join('][')};
  } 

  // Resolve nesting/parent lookups
  var l = ref.level || 1,
      nested = (ref.group || ref.parent) && l,
      scope = nested ? Array(l).join('group.mark.') : '',
      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),
      val = r.val,
      deps = dependencies(null, r);

  if (ref.datum) {
    val = 'item.datum['+val+']';
    deps.fields.push(ref.datum);
  } else if (ref.group) {
    val = scope+'group['+val+']';
    deps.nested.push({ level: l, group: true });
  } else if (ref.parent) {
    val = scope+'group.datum['+val+']';
    deps.nested.push({ level: l, parent: true });
  } else if (ref.signal) {
    val = 'signals['+val+']';
    deps.signals.push(dl.field(ref.signal)[0]);
    deps.reflow = true;
  }

  return (deps.val = val, deps);
}

// {scale: "x"}
// {scale: {name: "x"}},
// {scale: fieldRef}
function scaleRef(ref) {
  var scale = null,
      fr = null,
      deps = dependencies();

  if (dl.isString(ref)) {
    scale = dl.str(ref);
  } else if (ref.name) {
    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;
  } else {
    scale = (fr = fieldRef(ref)).val;
  }

  scale = '(item.mark._scaleRefs['+scale+'] = 1, group.scale('+scale+'))';
  if (ref.invert) scale += '.invert';

  // Mark scale refs as they're dealt with separately in mark._scaleRefs.
  if (fr) fr.nested.forEach(function(g) { g.scale = true; });
  return fr ? (fr.val = scale, fr) : (deps.val = scale, deps);
}

module.exports = properties;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"datalib":49,"vega-dataflow":141,"vega-logging":147}],206:[function(require,module,exports){
var dl = require('datalib'),
    SIGNALS = require('vega-dataflow').Dependencies.SIGNALS,
    expr = require('./expr');

var RESERVED = ['datum', 'event', 'signals']
  .concat(dl.keys(expr.codegen.functions));

function parseSignals(model, spec) {
  // process each signal definition
  (spec || []).forEach(function(s) {
    if (RESERVED.indexOf(s.name) !== -1) {
      throw Error('Signal name "'+s.name+'" is a '+
        'reserved keyword ('+RESERVED.join(', ')+').');
    }

    var signal = model.signal(s.name, s.init)
      .verbose(s.verbose);

    if (s.init && s.init.expr) {
      s.init.expr = expr(s.init.expr);
      signal.value(exprVal(model, s.init));
    }

    if (s.expr) {
      s.expr = expr(s.expr);
      signal.evaluate = function(input) {
        var val = exprVal(model, s);
        if (val !== signal.value() || signal.verbose()) {
          signal.value(val);
          input.signals[s.name] = 1;
          return input;
        }
        return model.doNotPropagate;        
      };
      signal.dependency(SIGNALS, s.expr.globals);
      s.expr.globals.forEach(function(dep) {
        model.signal(dep).addListener(signal);
      });
    }
  });

  return spec;
}

function exprVal(model, spec) {
  var e = spec.expr,
      val = e.fn(null, null, model.values(SIGNALS, e.globals));
  return spec.scale ? parseSignals.scale(model, spec, val) : val;
}

parseSignals.scale = function scale(model, spec, value, datum, evt) {
  var def = spec.scale,
      name  = def.name || def.signal || def,
      scope = def.scope, e;

  if (scope) {
    if (scope.signal) {
      scope = model.signalRef(scope.signal);
    } else if (dl.isString(scope)) { // Scope is an expression
      e = def._expr = (def._expr || expr(scope));
      scope = e.fn(datum, evt, model.values(SIGNALS, e.globals));
    }
  }

  if (!scope || !scope.scale) {
    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];
  }

  var s = scope.scale(name);
  return !s ? value : (def.invert ? s.invert(value) : s(value));
};

module.exports = parseSignals;
},{"./expr":197,"datalib":49,"vega-dataflow":141}],207:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    Model = require('../core/Model'),
    View = require('../core/View');

function parseSpec(spec, callback) {
  var vf = arguments[arguments.length-1],
      viewFactory = arguments.length > 2 && dl.isFunction(vf) ? vf : View.factory,
      config = arguments[2] !== viewFactory ? arguments[2] : {},
      model = new Model(config);

  function parse(spec) {
    // protect against subsequent spec modification
    spec = dl.duplicate(spec);

    var parsers = require('./'),
        width = spec.width || 500,
        height = spec.height || 500,
        viewport = spec.viewport || null;

    model.defs({
      width: width,
      height: height,
      viewport: viewport,
      background: parsers.background(spec.background),
      padding: parsers.padding(spec.padding),
      signals: parsers.signals(model, spec.signals),
      predicates: parsers.predicates(model, spec.predicates),
      marks: parsers.marks(model, spec, width, height),
      data: parsers.data(model, spec.data, function() {
        callback(viewFactory(model));
      })
    });    
  }

  if (dl.isObject(spec)) {
    parse(spec);
  } else if (dl.isString(spec)) {
    var opts = dl.extend({url: spec}, model.config().load);
    dl.load(opts, function(err, data) {
      if (err) {
        log.error('LOADING SPECIFICATION FAILED: ' + err.statusText);
      } else {
        try { 
          parse(JSON.parse(data)); 
        } catch (e) { 
          log.error('INVALID SPECIFICATION: Must be a valid JSON object. '+e); 
        }
      }
    });
  } else {
    log.error('INVALID SPECIFICATION: Must be a valid JSON object or URL.');
  }
}

module.exports = parseSpec;
},{"../core/Model":189,"../core/View":190,"./":198,"datalib":49,"vega-logging":147}],208:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    SIGNALS = df.Dependencies.SIGNALS,
    parseSignals = require('./signals'),
    selector = require('./events'),
    expr = require('./expr');

var GATEKEEPER = '_vgGATEKEEPER';

var vgEvent = {
  getGroup: function(name) { return name ? this.name[name] : this.group; },
  getXY: function(item) {
      var p = {x: this.x, y: this.y};
      if (typeof item === 'string') {
        item = this.name[item];
      }
      for (; item; item = item.mark && item.mark.group) {
        p.x -= item.x || 0;
        p.y -= item.y || 0;
      }
      return p;
    },
  getX: function(item) { return this.getXY(item).x; },
  getY: function(item) { return this.getXY(item).y; }
};

function parseStreams(view) {
  var model = view.model(),
      spec  = model.defs().signals,
      registry = {handlers: {}, nodes: {}},
      internal = dl.duplicate(registry),  // Internal event processing
      external = dl.duplicate(registry);  // External event processing

  (spec || []).forEach(function(sig) {
    var signal = model.signal(sig.name);
    if (sig.expr) return;  // Cannot have an expr and stream definition.

    (sig.streams || []).forEach(function(stream) {
      var sel = selector.parse(stream.type),
          exp = expr(stream.expr);
      mergedStream(signal, sel, exp, stream);
    });
  });

  // We register the event listeners all together so that if multiple
  // signals are registered on the same event, they will receive the
  // new value on the same pulse. 
  dl.keys(internal.handlers).forEach(function(type) {
    view.on(type, function(evt, item) {
      evt.preventDefault(); // stop text selection
      extendEvent(evt, item);
      fire(internal, type, (item && item.datum) || {}, evt);
    });
  });

  // add external event listeners
  dl.keys(external.handlers).forEach(function(type) {
    if (typeof window === 'undefined') return; // No external support

    var h = external.handlers[type],
        t = type.split(':'), // --> no element pseudo-selectors
        elt = (t[0] === 'window') ? [window] :
              window.document.querySelectorAll(t[0]);

    function handler(evt) {
      extendEvent(evt);
      fire(external, type, d3.select(this).datum(), evt);
    }

    for (var i=0; i<elt.length; ++i) {
      elt[i].addEventListener(t[1], handler);
    }

    h.elements = elt;
    h.listener = handler;
  });

  // remove external event listeners
  external.detach = function() {
    dl.keys(external.handlers).forEach(function(type) {
      var h = external.handlers[type],
          t = type.split(':'),
          elt = h.elements || [];

      for (var i=0; i<elt.length; ++i) {
        elt[i].removeEventListener(t[1], h.listener);
      }
    });
  };

  // export detach method
  return external.detach;

  // -- helper functions -----

  function extendEvent(evt, item) {
    var mouse = d3.mouse((d3.event=evt, view.renderer().scene())),
        pad = view.padding(),
        names = {}, mark, group, i;

    if (item) {
      mark = item.mark;
      group = mark.marktype === 'group' ? item : mark.group;
      for (i=item; i!=null; i=i.mark.group) {
        if (i.mark.def.name) {
          names[i.mark.def.name] = i;
        }
      }
    }
    names.root = view.model().scene().items[0];

    evt.vg = Object.create(vgEvent);
    evt.vg.group = group;
    evt.vg.item = item || {};
    evt.vg.name = names;
    evt.vg.x = mouse[0] - pad.left;
    evt.vg.y = mouse[1] - pad.top;
  }

  function fire(registry, type, datum, evt) {
    var handlers = registry.handlers[type],
        node = registry.nodes[type],
        cs = df.ChangeSet.create(null, true),
        filtered = false,
        val, i, n, h;

    function invoke(f) {
      return !f.fn(datum, evt, model.values(SIGNALS, f.globals));
    }

    for (i=0, n=handlers.length; i<n; ++i) {
      h = handlers[i];
      filtered = h.filters.some(invoke);
      if (filtered) continue;
      
      val = h.exp.fn(datum, evt, model.values(SIGNALS, h.exp.globals));
      if (h.spec.scale) {
        val = parseSignals.scale(model, h.spec, val, datum, evt);
      }

      if (val !== h.signal.value() || h.signal.verbose()) {
        h.signal.value(val);
        cs.signals[h.signal.name()] = 1;
      }
    }

    model.propagate(cs, node);
  }

  function mergedStream(sig, selector, exp, spec) {
    selector.forEach(function(s) {
      if (s.event)       domEvent(sig, s, exp, spec);
      else if (s.signal) signal(sig, s, exp, spec);
      else if (s.start)  orderedStream(sig, s, exp, spec);
      else if (s.stream) mergedStream(sig, s.stream, exp, spec);
    });
  }

  function domEvent(sig, selector, exp, spec) {
    var evt = selector.event,
        name = selector.name,
        mark = selector.mark,
        target   = selector.target,
        filters  = selector.filters || [],
        registry = target ? external : internal,
        type = target ? target+':'+evt : evt,
        node = registry.nodes[type] || (registry.nodes[type] = new df.Node(model)),
        handlers = registry.handlers[type] || (registry.handlers[type] = []);

    if (name) {
      filters.push('!!event.vg.name["' + name + '"]'); // Mimic event bubbling
    } else if (mark) {
      filters.push('event.vg.item.mark && event.vg.item.mark.marktype==='+dl.str(mark));
    }

    handlers.push({
      signal: sig,
      exp: exp,
      spec: spec,
      filters: filters.map(function(f) { return expr(f); })
    });

    node.addListener(sig);
  }

  function signal(sig, selector, exp, spec) {
    var n = new df.Node(model);
    n.evaluate = function(input) {
      if (!input.signals[selector.signal]) return model.doNotPropagate;
      var val = exp.fn(null, null, model.values(SIGNALS, exp.globals));
      if (spec.scale) {
        val = parseSignals.scale(model, spec, val);
      }

      if (val !== sig.value() || sig.verbose()) {
        sig.value(val);
        input.signals[sig.name()] = 1;
        input.reflow = true;        
      }

      return input;  
    };
    n.dependency(df.Dependencies.SIGNALS, selector.signal);
    n.addListener(sig);
    model.signal(selector.signal).addListener(n);
  }

  function orderedStream(sig, selector, exp, spec) {
    var name = sig.name(), 
        gk = name + GATEKEEPER, 
        trueFn  = expr('true'), 
        falseFn = expr('false'),
        middle  = selector.middle,
        filters = middle.filters || (middle.filters = []),
        gatekeeper = model.signal(gk) || model.signal(gk, false);

    // Register an anonymous signal to act as a gatekeeper. Its value is
    // true or false depending on whether the start or end streams occur. 
    // The middle signal then simply filters for the gatekeeper's value. 
    mergedStream(gatekeeper, [selector.start], trueFn, {});
    mergedStream(gatekeeper, [selector.end], falseFn, {});

    filters.push(gatekeeper.name());
    mergedStream(sig, [selector.middle], exp, spec);
  }
}

module.exports = parseStreams;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./events":196,"./expr":197,"./signals":206,"datalib":49,"vega-dataflow":141}],209:[function(require,module,exports){
var dl = require('datalib'),
    transforms = require('../transforms/index');

function parseTransforms(model, def) {
  var tx = new transforms[def.type](model);
  
  // We want to rename output fields before setting any other properties,
  // as subsequent properties may require output to be set (e.g. group by).
  if(def.output) tx.output(def.output);

  dl.keys(def).forEach(function(k) {
    if(k === 'type' || k === 'output') return;
    tx.param(k, def[k]);
  });

  return tx;
}

module.exports = parseTransforms;
},{"../transforms/index":242,"datalib":49}],210:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    log = require('vega-logging'),
    bound = require('vega-scenegraph').bound,
    Encoder = require('./Encoder');

function Bounder(graph, mark) {
  this._mark = mark;
  return Node.prototype.init.call(this, graph)
    .router(true)
    .reflows(true)
    .mutates(true);
}

var proto = (Bounder.prototype = new Node());

proto.evaluate = function(input) {
  log.debug(input, ['bounds', this._mark.marktype]);

  var type  = this._mark.marktype,
      isGrp = type === 'group',
      items = this._mark.items,
      hasLegends = dl.array(this._mark.def.legends).length > 0,
      i, ilen, j, jlen, group, legend;

  if (input.add.length || input.rem.length || !items.length || 
      input.mod.length === items.length ||
      type === 'area' || type === 'line') {
    bound.mark(this._mark, null, isGrp && !hasLegends);
  } else {
    input.mod.forEach(function(item) { bound.item(item); });
  }

  if (isGrp && hasLegends) {
    for (i=0, ilen=items.length; i<ilen; ++i) {
      group = items[i];
      group._legendPositions = null;
      for (j=0, jlen=group.legendItems.length; j<jlen; ++j) {
        legend = group.legendItems[j];
        Encoder.update(this._graph, input.trans, 'vg_legendPosition', legend.items, input.dirty);
        bound.mark(legend, null, false);
      }
    }

    bound.mark(this._mark, null, true);
  }

  return df.ChangeSet.create(input, true);
};

module.exports = Bounder;
},{"./Encoder":212,"datalib":49,"vega-dataflow":141,"vega-logging":147,"vega-scenegraph":148}],211:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    Item = require('vega-scenegraph').Item,
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Tuple = df.Tuple,
    ChangeSet = df.ChangeSet,
    Sentinel = {},
    Encoder  = require('./Encoder'),
    Bounder  = require('./Bounder'),
    parseData = require('../parse/data');

function Builder() {    
  return arguments.length ? this.init.apply(this, arguments) : this;
}

var Status = Builder.STATUS = {
  ENTER:  'enter',
  UPDATE: 'update',
  EXIT:   'exit'
};

var CONNECTED = 1, DISCONNECTED = 2;

var proto = (Builder.prototype = new Node());

proto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {
  Node.prototype.init.call(this, graph)
    .router(true)
    .collector(true);

  this._def   = def;
  this._mark  = mark;
  this._from  = (def.from ? def.from.data : null) || inheritFrom;
  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;
  this._map   = {};
  this._status = null; // Connected or disconnected?

  mark.def = def;
  mark.marktype = def.type;
  mark.interactive = (def.interactive !== false);
  mark.items = [];
  if (dl.isValid(def.name)) mark.name = def.name;

  this._parent = parent;
  this._parent_id = parent_id;

  if (def.from && (def.from.mark || def.from.transform || def.from.modify)) {
    inlineDs.call(this);
  }

  // Non-group mark builders are super nodes. Encoder and Bounder remain 
  // separate operators but are embedded and called by Builder.evaluate.
  this._isSuper = (this._def.type !== 'group'); 
  this._encoder = new Encoder(this._graph, this._mark, this);
  this._bounder = new Bounder(this._graph, this._mark);
  this._output  = null; // Output changeset for reactive geom as Bounder reflows

  if (this._ds) { this._encoder.dependency(Deps.DATA, this._from); }

  // Since Builders are super nodes, copy over encoder dependencies
  // (bounder has no registered dependencies).
  this.dependency(Deps.DATA, this._encoder.dependency(Deps.DATA));
  this.dependency(Deps.SCALES, this._encoder.dependency(Deps.SCALES));
  this.dependency(Deps.SIGNALS, this._encoder.dependency(Deps.SIGNALS));

  return this;
};

// Reactive geometry and mark-level transformations are handled here 
// because they need their group's data-joined context. 
function inlineDs() {
  var from = this._def.from,
      geom = from.mark,
      src, name, spec, sibling, output, input;

  if (geom) {
    name = ['vg', this._parent_id, geom].join('_');
    spec = {
      name: name,
      transform: from.transform, 
      modify: from.modify
    };
  } else {
    src = this._graph.data(this._from);
    name = ['vg', this._from, this._def.type, src.listeners(true).length].join('_');
    spec = {
      name: name,
      source: this._from,
      transform: from.transform,
      modify: from.modify
    };
  }

  this._from = name;
  this._ds = parseData.datasource(this._graph, spec);
  var node;

  if (geom) {
    sibling = this.sibling(geom);

    // Bounder reflows, so we need an intermediary node to propagate
    // the output constructed by the Builder.
    node = new Node(this._graph).addListener(this._ds.listener());
    node.evaluate = function() { return sibling._output; };

    if (sibling._isSuper) {
      sibling.addListener(node);
    } else {
      sibling._bounder.addListener(node);
    }
  } else {
    // At this point, we have a new datasource but it is empty as
    // the propagation cycle has already crossed the datasources. 
    // So, we repulse just this datasource. This should be safe
    // as the ds isn't connected to the scenegraph yet.
    output = this._ds.source().last();
    input  = ChangeSet.create(output);

    input.add = output.add;
    input.mod = output.mod;
    input.rem = output.rem;
    input.stamp = null;
    this._graph.propagate(input, this._ds.listener(), output.stamp);
  }
}

proto.ds = function() { return this._ds; };
proto.parent   = function() { return this._parent; };
proto.encoder  = function() { return this._encoder; };
proto.pipeline = function() { return [this]; };

proto.connect = function() {
  var builder = this;

  this._graph.connect(this.pipeline());
  this._encoder._scales.forEach(function(s) {
    if (!(s = builder._parent.scale(s))) return;
    s.addListener(builder);
  });

  if (this._parent) {
    if (this._isSuper) this.addListener(this._parent._collector);
    else this._bounder.addListener(this._parent._collector);
  }

  return (this._status = CONNECTED, this);
};

proto.disconnect = function() {
  var builder = this;
  if (!this._listeners.length) return this;

  function disconnectScales(scales) {
    for(var i=0, len=scales.length, s; i<len; ++i) {
      if (!(s = builder._parent.scale(scales[i]))) continue;
      s.removeListener(builder);
    }
  }

  Node.prototype.disconnect.call(this);
  this._graph.disconnect(this.pipeline());
  disconnectScales(this._encoder._scales);
  disconnectScales(dl.keys(this._mark._scaleRefs));
  
  return (this._status = DISCONNECTED, this);
};

proto.sibling = function(name) {
  return this._parent.child(name, this._parent_id);
};

proto.evaluate = function(input) {
  log.debug(input, ['building', (this._from || this._def.from), this._def.type]);

  var self = this,
      def = this._mark.def,
      props  = def.properties || {},
      update = props.update   || {},
      output, fullUpdate, fcs, data, name;

  if (this._ds) {
    output = ChangeSet.create(input);

    // We need to determine if any encoder dependencies have been updated.
    // However, the encoder's data source will likely be updated, and shouldn't
    // trigger all items to mod.
    data = output.data[(name=this._ds.name())];
    delete output.data[name];
    fullUpdate = this._encoder.reevaluate(output);
    output.data[name] = data;

    // If a scale or signal in the update propset has been updated, 
    // send forward all items for reencoding if we do an early return.
    if (fullUpdate) output.mod = this._mark.items.slice();

    fcs = this._ds.last();
    if (!fcs) throw Error('Builder evaluated before backing DataSource.');
    if (fcs.stamp > this._stamp) {
      output = join.call(this, fcs, this._ds.values(), true, fullUpdate);
    }
  } else {
    data = dl.isFunction(this._def.from) ? this._def.from() : [Sentinel];
    output = join.call(this, input, data);
  }

  // Stash output before Bounder for downstream reactive geometry.
  this._output = output = this._graph.evaluate(output, this._encoder);

  // Add any new scale references to the dependency list, and ensure
  // they're connected.
  if (update.nested && update.nested.length && this._status === CONNECTED) {
    dl.keys(this._mark._scaleRefs).forEach(function(s) {
      var scale = self._parent.scale(s);
      if (!scale) return;

      scale.addListener(self);
      self.dependency(Deps.SCALES, s);
      self._encoder.dependency(Deps.SCALES, s);
    });
  }

  // Supernodes calculate bounds too, but only on items marked dirty.
  if (this._isSuper) {
    output.mod = output.mod.filter(function(x) { return x._dirty; });
    output = this._graph.evaluate(output, this._bounder);
  }

  return output;
};

function newItem() {
  var item = Tuple.ingest(new Item(this._mark));

  // For the root node's item
  if (this._def.width)  Tuple.set(item, 'width',  this._def.width);
  if (this._def.height) Tuple.set(item, 'height', this._def.height);
  return item;
}

function join(input, data, ds, fullUpdate) {
  var output = ChangeSet.create(input),
      keyf = keyFunction(this._def.key || (ds ? '_id' : null)),
      prev = this._mark.items || [],
      rem  = ds ? input.rem : prev,
      mod  = Tuple.idMap((!ds || fullUpdate) ? data : input.mod),
      next = [],
      i, key, len, item, datum, enter, diff;

  // Only mark rems as exiting. Due to keyf, there may be an add/mod 
  // tuple that replaces it.
  for (i=0, len=rem.length; i<len; ++i) {
    item = (rem[i] === prev[i]) ? prev[i] :
      keyf ? this._map[keyf(rem[i])] : rem[i];
    item.status = Status.EXIT;
  }

  for(i=0, len=data.length; i<len; ++i) {
    datum = data[i];
    item  = keyf ? this._map[key = keyf(datum)] : prev[i];
    enter = item ? false : (item = newItem.call(this), true);
    item.status = enter ? Status.ENTER : Status.UPDATE;
    diff = !enter && item.datum !== datum;
    item.datum = datum;

    if (keyf) {
      Tuple.set(item, 'key', key);
      this._map[key] = item;
    }

    if (enter) {
      output.add.push(item);
    } else if (diff || mod[datum._id]) {
      output.mod.push(item);
    }

    next.push(item);
  }

  for (i=0, len=rem.length; i<len; ++i) {
    item = (rem[i] === prev[i]) ? prev[i] :
      keyf ? this._map[key = keyf(rem[i])] : rem[i];
    if (item.status === Status.EXIT) {
      item._dirty = true;
      input.dirty.push(item);
      next.push(item);
      output.rem.push(item);
      if (keyf) this._map[key] = null;
    }
  }

  return (this._mark.items = next, output);
}

function keyFunction(key) {
  if (key == null) return null;
  var f = dl.array(key).map(dl.accessor);
  return function(d) {
    for (var s='', i=0, n=f.length; i<n; ++i) {
      if (i>0) s += '|';
      s += String(f[i](d));
    }
    return s;
  };
}

module.exports = Builder;
},{"../parse/data":195,"./Bounder":210,"./Encoder":212,"datalib":49,"vega-dataflow":141,"vega-logging":147,"vega-scenegraph":148}],212:[function(require,module,exports){
var dl = require('datalib'),
    log = require('vega-logging'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    bound = require('vega-scenegraph').bound;

var EMPTY = {};

function Encoder(graph, mark, builder) {
  var props  = mark.def.properties || {},
      enter  = props.enter,
      update = props.update,
      exit   = props.exit;

  Node.prototype.init.call(this, graph);

  this._mark = mark;
  this._builder = builder;
  var s = this._scales = [];

  // Only scales used in the 'update' property set are set as
  // encoder depedencies to have targeted reevaluations. However,
  // we still want scales in 'enter' and 'exit' to be evaluated
  // before the encoder. 
  if (enter) s.push.apply(s, enter.scales);

  if (update) {
    this.dependency(Deps.DATA, update.data);
    this.dependency(Deps.SIGNALS, update.signals);
    this.dependency(Deps.FIELDS, update.fields);
    this.dependency(Deps.SCALES, update.scales);
    s.push.apply(s, update.scales);
  }

  if (exit) s.push.apply(s, exit.scales);

  return this.mutates(true);
}

var proto = (Encoder.prototype = new Node());

proto.evaluate = function(input) {
  log.debug(input, ['encoding', this._mark.def.type]);
  var graph = this._graph,
      props = this._mark.def.properties || {},
      items = this._mark.items,
      enter  = props.enter,
      update = props.update,
      exit   = props.exit,
      dirty  = input.dirty,
      preds  = graph.predicates(),
      req = input.request,
      group = this._mark.group,
      guide = group && (group.mark.axis || group.mark.legend),
      db = EMPTY, sg = EMPTY, i, len, item, prop;

  if (req && !guide) {
    if ((prop = props[req]) && input.mod.length) {
      db = prop.data ? graph.values(Deps.DATA, prop.data) : null;
      sg = prop.signals ? graph.values(Deps.SIGNALS, prop.signals) : null;

      for (i=0, len=input.mod.length; i<len; ++i) {
        item = input.mod[i];
        encode.call(this, prop, item, input.trans, db, sg, preds, dirty);
      }
    }

    return input; // exit early if given request
  }

  db = values(Deps.DATA, graph, input, props);
  sg = values(Deps.SIGNALS, graph, input, props);

  // Items marked for removal are at the tail of items. Process them first.
  for (i=0, len=input.rem.length; i<len; ++i) {
    item = input.rem[i];
    if (exit) encode.call(this, exit, item, input.trans, db, sg, preds, dirty); 
    if (input.trans && !exit) input.trans.interpolate(item, EMPTY);
    else if (!input.trans) items.pop();
  }

  var update_status = require('./Builder').STATUS.UPDATE;
  for (i=0, len=input.add.length; i<len; ++i) {
    item = input.add[i];
    if (enter)  encode.call(this, enter,  item, input.trans, db, sg, preds, dirty);
    if (update) encode.call(this, update, item, input.trans, db, sg, preds, dirty);
    item.status = update_status;
  }

  if (update) {
    for (i=0, len=input.mod.length; i<len; ++i) {
      item = input.mod[i];
      encode.call(this, update, item, input.trans, db, sg, preds, dirty);
    }
  }

  return input;
};

// Only marshal necessary data and signal values
function values(type, graph, input, props) {
  var p, x, o, add = input.add.length;
  if ((p=props.enter) && (x=p[type]).length && add) {
    o = graph.values(type, x, (o=o||{}));
  }
  if ((p=props.exit) && (x=p[type]).length && input.rem.length) {
    o = graph.values(type, x, (o=o||{})); 
  }
  if ((p=props.update) && (x=p[type]).length && (add || input.mod.length)) {
    o = graph.values(type, x, (o=o||{}));
  }
  return o || EMPTY;
}

function encode(prop, item, trans, db, sg, preds, dirty) {
  var enc = prop.encode,
      wasDirty = item._dirty,
      isDirty  = enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);

  item._dirty = isDirty || wasDirty;
  if (isDirty && !wasDirty) dirty.push(item);
}

// If a specified property set called, or update property set 
// uses nested fieldrefs, reevaluate all items.
proto.reevaluate = function(pulse) {
  var def = this._mark.def,
      props = def.properties || {},
      reeval = dl.isFunction(def.from) || def.orient || pulse.request || 
        Node.prototype.reevaluate.call(this, pulse);

  return reeval || (props.update ? nestedRefs.call(this) : false);
};

// Test if any nested refs trigger a reflow of mark items.
function nestedRefs() {
  var refs = this._mark.def.properties.update.nested,
      parent = this._builder,
      level = 0,
      i = 0, len = refs.length,
      ref, ds, stamp;

  for (; i<len; ++i) {
    ref = refs[i];

    // Scale references are resolved via this._mark._scaleRefs which are
    // added to dependency lists + connected in Builder.evaluate.
    if (ref.scale) continue;

    for (; level<ref.level; ++level) {
      parent = parent.parent();
      ds = parent.ds();
    }

    // Compare stamps to determine if a change in a group's properties
    // or data should trigger a reeval. We cannot check anything fancier
    // (e.g., pulse.fields) as the ref may use item.datum.
    stamp = (ref.group ? parent.encoder() : ds.last())._stamp;
    if (stamp > this._stamp) return true;
  }

  return false;
}

// Short-circuit encoder if user specifies items
Encoder.update = function(graph, trans, request, items, dirty) {
  items = dl.array(items);
  var preds = graph.predicates(), 
      db = graph.values(Deps.DATA),
      sg = graph.values(Deps.SIGNALS),
      i, len, item, props, prop;

  for (i=0, len=items.length; i<len; ++i) {
    item = items[i];
    props = item.mark.def.properties;
    prop = props && props[request];
    if (prop) {
      encode.call(null, prop, item, trans, db, sg, preds, dirty);
      bound.item(item);
    }
  }

};

module.exports = Encoder;
},{"./Builder":211,"datalib":49,"vega-dataflow":141,"vega-logging":147,"vega-scenegraph":148}],213:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Collector = df.Collector,
    log = require('vega-logging'),
    Builder = require('./Builder'),
    Scale = require('./Scale'),
    parseAxes = require('../parse/axes'),
    parseLegends = require('../parse/legends');

function GroupBuilder() {
  this._children = {};
  this._scaler = null;
  this._recursor = null;

  this._scales = {};
  this.scale = scale.bind(this);
  return arguments.length ? this.init.apply(this, arguments) : this;
}

var Types = GroupBuilder.TYPES = {
  GROUP:  "group",
  MARK:   "mark",
  AXIS:   "axis",
  LEGEND: "legend"
};

var proto = (GroupBuilder.prototype = new Builder());

proto.init = function(graph, def) {
  var builder = this, name;

  this._scaler = new Node(graph);

  (def.scales||[]).forEach(function(s) {
    s = builder.scale((name=s.name), new Scale(graph, s, builder));
    builder.scale(name+":prev", s);
    builder._scaler.addListener(s);  // Scales should be computed after group is encoded
  });

  this._recursor = new Node(graph);
  this._recursor.evaluate = recurse.bind(this);

  var scales = (def.axes||[]).reduce(function(acc, x) {
    return (acc[x.scale] = 1, acc);
  }, {});

  scales = (def.legends||[]).reduce(function(acc, x) {
    return (acc[x.size || x.shape || x.fill || x.stroke], acc);
  }, scales);

  this._recursor.dependency(Deps.SCALES, dl.keys(scales));

  // We only need a collector for up-propagation of bounds calculation,
  // so only GroupBuilders, and not regular Builders, have collectors.
  this._collector = new Collector(graph);

  return Builder.prototype.init.apply(this, arguments);
};

proto.evaluate = function() {
  var output = Builder.prototype.evaluate.apply(this, arguments),
      builder = this;

  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });
  return output;
};

proto.pipeline = function() {
  return [this, this._scaler, this._recursor, this._collector, this._bounder];
};

proto.disconnect = function() {
  var builder = this;
  dl.keys(builder._children).forEach(function(group_id) {
    builder._children[group_id].forEach(function(c) {
      builder._recursor.removeListener(c.builder);
      c.builder.disconnect();
    });
  });

  builder._children = {};
  return Builder.prototype.disconnect.call(this);
};

proto.child = function(name, group_id) {
  var children = this._children[group_id],
      i = 0, len = children.length,
      child;

  for (; i<len; ++i) {
    child = children[i];
    if (child.type == Types.MARK && child.builder._def.name == name) break;
  }

  return child.builder;
};

function recurse(input) {
  var builder = this,
      hasMarks = dl.array(this._def.marks).length > 0,
      hasAxes = dl.array(this._def.axes).length > 0,
      hasLegends = dl.array(this._def.legends).length > 0,
      i, j, c, len, group, pipeline, def, inline = false;

  for (i=0, len=input.add.length; i<len; ++i) {
    group = input.add[i];
    if (hasMarks) buildMarks.call(this, input, group);
    if (hasAxes)  buildAxes.call(this, input, group);
    if (hasLegends) buildLegends.call(this, input, group);
  }

  // Wire up new children builders in reverse to minimize graph rewrites.
  for (i=input.add.length-1; i>=0; --i) {
    group = input.add[i];
    for (j=this._children[group._id].length-1; j>=0; --j) {
      c = this._children[group._id][j];
      c.builder.connect();
      pipeline = c.builder.pipeline();
      def = c.builder._def;

      // This new child needs to be built during this propagation cycle.
      // We could add its builder as a listener off the _recursor node, 
      // but try to inline it if we can to minimize graph dispatches.
      inline = (def.type !== Types.GROUP);
      inline = inline && (this._graph.data(c.from) !== undefined); 
      inline = inline && (pipeline[pipeline.length-1].listeners().length === 1); // Reactive geom source
      inline = inline && (def.from && !def.from.mark); // Reactive geom target
      c.inline = inline;

      if (inline) this._graph.evaluate(input, c.builder);
      else this._recursor.addListener(c.builder);
    }
  }

  function removeTemp(c) {
    if (c.type == Types.MARK && !c.inline &&
        builder._graph.data(c.from) !== undefined) {
      builder._recursor.removeListener(c.builder);
    }
  }

  function updateAxis(a) { 
    var scale = a.scale();
    if (!input.scales[scale.scaleName]) return;
    a.reset().def();
  }
  
  function updateLegend(l) { 
    var scale = l.size() || l.shape() || l.fill() || l.stroke();
    if (!input.scales[scale.scaleName]) return;
    l.reset().def();
  }

  for (i=0, len=input.mod.length; i<len; ++i) {
    group = input.mod[i];

    // Remove temporary connection for marks that draw from a source
    if (hasMarks) builder._children[group._id].forEach(removeTemp);

    // Update axis data defs
    if (hasAxes) group.axes.forEach(updateAxis);

    // Update legend data defs
    if (hasLegends) group.legends.forEach(updateLegend);
  }

  function disconnectChildren(c) { 
    builder._recursor.removeListener(c.builder);
    c.builder.disconnect(); 
  }

  for (i=0, len=input.rem.length; i<len; ++i) {
    group = input.rem[i];
    // For deleted groups, disconnect their children
    builder._children[group._id].forEach(disconnectChildren);
    delete builder._children[group._id];
  }

  return input;
}

function scale(name, x) {
  var group = this, s = null;
  if (arguments.length === 2) return (group._scales[name] = x, x);
  while (s == null) {
    s = group._scales[name];
    group = group.mark ? group.mark.group : group._parent;
    if (!group) break;
  }
  return s;
}

function buildGroup(input, group) {
  log.debug(input, ["building group", group._id]);

  group._scales = group._scales || {};    
  group.scale = scale.bind(group);

  group.items = group.items || [];
  this._children[group._id] = this._children[group._id] || [];

  group.axes = group.axes || [];
  group.axisItems = group.axisItems || [];

  group.legends = group.legends || [];
  group.legendItems = group.legendItems || [];
}

function buildMarks(input, group) {
  log.debug(input, ["building children marks #"+group._id]);
  var marks = this._def.marks,
      mark, from, inherit, i, len, b;

  for (i=0, len=marks.length; i<len; ++i) {
    mark = marks[i];
    from = mark.from || {};
    inherit = group.datum._facetID;
    group.items[i] = {group: group, _scaleRefs: {}};
    b = (mark.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(this._graph, mark, group.items[i], this, group._id, inherit);
    this._children[group._id].push({ 
      builder: b, 
      from: from.data || (from.mark ? ("vg_" + group._id + "_" + from.mark) : inherit), 
      type: Types.MARK 
    });
  }
}

function buildAxes(input, group) {
  var axes = group.axes,
      axisItems = group.axisItems,
      builder = this;

  parseAxes(this._graph, this._def.axes, axes, group);
  axes.forEach(function(a, i) {
    var scale = builder._def.axes[i].scale,
        def = a.def(),
        b = null;

    axisItems[i] = {group: group, axis: true, layer: def.layer};
    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(builder._graph, def, axisItems[i], builder)
      .dependency(Deps.SCALES, scale);
    builder._children[group._id].push({ builder: b, type: Types.AXIS, scale: scale });
  });
}

function buildLegends(input, group) {
  var legends = group.legends,
      legendItems = group.legendItems,
      builder = this;

  parseLegends(this._graph, this._def.legends, legends, group);
  legends.forEach(function(l, i) {
    var scale = l.size() || l.shape() || l.fill() || l.stroke(),
        def = l.def(),
        b = null;

    legendItems[i] = {group: group, legend: true};
    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
    b.init(builder._graph, def, legendItems[i], builder)
      .dependency(Deps.SCALES, scale);
    builder._children[group._id].push({ builder: b, type: Types.LEGEND, scale: scale });
  });
}

module.exports = GroupBuilder;
},{"../parse/axes":193,"../parse/legends":199,"./Builder":211,"./Scale":214,"datalib":49,"vega-dataflow":141,"vega-logging":147}],214:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    df = require('vega-dataflow'),
    log = require('vega-logging'),
    Node = df.Node, // jshint ignore:line
    Deps = df.Dependencies,
    Aggregate = require('../transforms/Aggregate');

var Properties = {
  width: 1,
  height: 1
};

var Types = {
  LINEAR: 'linear',
  ORDINAL: 'ordinal',
  LOG: 'log',
  POWER: 'pow',
  SQRT: 'sqrt',
  TIME: 'time',
  TIME_UTC: 'utc',
  QUANTILE: 'quantile',
  QUANTIZE: 'quantize',
  THRESHOLD: 'threshold'
};

var DataRef = {
  DOMAIN: 'domain',
  RANGE: 'range',

  COUNT: 'count',
  GROUPBY: 'groupby',
  MIN: 'min',
  MAX: 'max',
  VALUE: 'value',

  ASC: 'asc',
  DESC: 'desc'
};

function Scale(graph, def, parent) {
  this._def     = def;
  this._parent  = parent;
  this._updated = false;
  return Node.prototype.init.call(this, graph).reflows(true);
}

var proto = (Scale.prototype = new Node());

proto.evaluate = function(input) {
  var self = this,
      fn = function(group) { scale.call(self, group); };

  this._updated = false;
  input.add.forEach(fn);
  input.mod.forEach(fn);

  // Scales are at the end of an encoding pipeline, so they should forward a
  // reflow pulse. Thus, if multiple scales update in the parent group, we don't
  // reevaluate child marks multiple times. 
  if (this._updated) {
    input.scales[this._def.name] = 1;
    log.debug(input, ["scale", this._def.name]);  
  } 
  return df.ChangeSet.create(input, true);
};

// All of a scale's dependencies are registered during propagation as we parse
// dataRefs. So a scale must be responsible for connecting itself to dependents.
proto.dependency = function(type, deps) {
  if (arguments.length == 2) {
    var method = (type === Deps.DATA ? 'data' : 'signal');
    deps = dl.array(deps);
    for (var i=0, len=deps.length; i<len; ++i) {
      this._graph[method](deps[i]).addListener(this._parent);
    }
  }

  return Node.prototype.dependency.call(this, type, deps);
};

function scale(group) {
  var name = this._def.name,
      prev = name + ':prev',
      s = instance.call(this, group.scale(name)),
      m = s.type===Types.ORDINAL ? ordinal : quantitative,
      rng = range.call(this, group);

  m.call(this, s, rng, group);

  group.scale(name, s);
  group.scale(prev, group.scale(prev) || s);

  return s;
}

function instance(scale) {
  var config = this._graph.config(),
      type = this._def.type || Types.LINEAR;
  if (!scale || type !== scale.type) {
    var ctor = config.scale[type] || d3.scale[type];
    if (!ctor) throw Error('Unrecognized scale type: ' + type);
    (scale = ctor()).type = scale.type || type;
    scale.scaleName = this._def.name;
    scale._prev = {};
  }
  return scale;
}

function ordinal(scale, rng, group) {
  var def = this._def,
      prev = scale._prev,
      dataDrivenRange = false,
      pad = signal.call(this, def.padding) || 0,
      outer = def.outerPadding == null ? pad : signal.call(this, def.outerPadding),
      points = def.points && signal.call(this, def.points),
      round = signal.call(this, def.round) || def.round == null,
      domain, str;
  
  // range pre-processing for data-driven ranges
  if (dl.isObject(def.range) && !dl.isArray(def.range)) {
    dataDrivenRange = true;
    rng = dataRef.call(this, DataRef.RANGE, def.range, scale, group);
  }
  
  // domain
  domain = dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
  if (domain && !dl.equal(prev.domain, domain)) {
    scale.domain(domain);
    prev.domain = domain;
    this._updated = true;
  } 

  // range
  if (dl.equal(prev.range, rng)) return;

  // width-defined range
  if (def.bandWidth) {
    var bw = signal.call(this, def.bandWidth),
        len = domain.length,
        space = def.points ? (pad*bw) : (pad*bw*(len-1) + 2*outer),
        start;
    if (rng[0] > rng[1]) {
      start = rng[1] || 0;
      rng = [start + (bw * len + space), start];
    } else {
      start = rng[0] || 0;
      rng = [start, start + (bw * len + space)];
    }
  }

  str = typeof rng[0] === 'string';
  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {
    scale.range(rng); // color or shape values
  } else if (points && round) {
    scale.rangeRoundPoints(rng, pad);
  } else if (points) {
    scale.rangePoints(rng, pad);
  } else if (round) {
    scale.rangeRoundBands(rng, pad, outer);
  } else {
    scale.rangeBands(rng, pad, outer);
  }

  if (!scale.invert) {
    scale.invert = function(x, y) {
      if (arguments.length === 1) {
        return scale.domain()[d3.bisect(scale.range(), x) - 1];
      } else if (arguments.length === 2) {  // Invert extents
        if (!dl.isNumber(x) || !dl.isNumber(y)) {
          throw Error('Extents to ordinal invert are not numbers ('+x+', '+y+').');
        }

        var points = [],
            rng = scale.range(),
            i = 0, len = rng.length, r;

        for(; i<len; ++i) {
          r = rng[i];
          if (x < y ? x <= r && r <= y : y <= r && r <= x) {
            points.push(r);
          }
        }

        return points.map(function(p) { return scale.invert(p); });
      }
    };
  }

  prev.range = rng;
  this._updated = true;
}

function quantitative(scale, rng, group) {
  var def = this._def,
      prev = scale._prev,
      round = signal.call(this, def.round),
      exponent = signal.call(this, def.exponent),
      clamp = signal.call(this, def.clamp),
      nice = signal.call(this, def.nice),
      domain, interval;

  // domain
  domain = (def.type === Types.QUANTILE) ?
    dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group) :
    domainMinMax.call(this, scale, group);
  if (domain && !dl.equal(prev.domain, domain)) {
    scale.domain(domain);
    prev.domain = domain;
    this._updated = true;
  } 

  // range
  // vertical scales should flip by default, so use XOR here
  if (signal.call(this, def.range) === 'height') rng = rng.reverse();
  if (dl.equal(prev.range, rng)) return;
  scale[round && scale.rangeRound ? 'rangeRound' : 'range'](rng);
  prev.range = rng;
  this._updated = true;

  // TODO: Support signals for these properties. Until then, only eval
  // them once.
  if (this._stamp > 0) return;
  if (exponent && def.type===Types.POWER) scale.exponent(exponent);
  if (clamp) scale.clamp(true);
  if (nice) {
    if (def.type === Types.TIME) {
      interval = d3.time[nice];
      if (!interval) log.error('Unrecognized interval: ' + interval);
      scale.nice(interval);
    } else {
      scale.nice();
    }
  }
}

function isUniques(scale) { 
  return scale.type === Types.ORDINAL || scale.type === Types.QUANTILE; 
}

function getRefs(def) { 
  return def.fields || dl.array(def);
}

function inherits(refs) {
  return refs.some(function(r) {
    if (!r.data) return true;
    return r.data && dl.array(r.field).some(function(f) {
      return f.parent;
    });
  });
}

function getFields(ref, group) {
  return dl.array(ref.field).map(function(f) {
    return f.parent ?
      dl.accessor(f.parent)(group.datum) :
      f; // String or {'signal'}
  });
}

// Scale datarefs can be computed over multiple schema types. 
// This function determines the type of aggregator created, and
// what data is sent to it: values, tuples, or multi-tuples that must
// be standardized into a consistent schema. 
function aggrType(def, scale) {
  var refs = getRefs(def);

  // If we're operating over only a single domain, send full tuples
  // through for efficiency (fewer accessor creations/calls)
  if (refs.length == 1 && dl.array(refs[0].field).length == 1) {
    return Aggregate.TYPES.TUPLE;
  }

  // With quantitative scales, we only care about min/max.
  if (!isUniques(scale)) return Aggregate.TYPES.VALUE;

  // If we don't sort, then we can send values directly to aggrs as well
  if (!dl.isObject(def.sort)) return Aggregate.TYPES.VALUE;

  return Aggregate.TYPES.MULTI;
}

function getCache(which, def, scale, group) {
  var refs = getRefs(def),
      inherit = inherits(refs),
      atype = aggrType(def, scale),
      uniques = isUniques(scale),
      sort = def.sort,
      ck = '_'+which,
      fields = getFields(refs[0], group);

  if (scale[ck] || this[ck]) return scale[ck] || this[ck];

  var cache = new Aggregate(this._graph).type(atype),
      groupby, summarize;

  // If a scale's dataref doesn't inherit data from the group, we can
  // store the dataref aggregator at the Scale (dataflow node) level. 
  if (inherit) {
    scale[ck] = cache;
  } else {
    this[ck]  = cache;
  }

  if (uniques) {
    if (atype === Aggregate.TYPES.VALUE) {
      groupby = [{ name: DataRef.GROUPBY, get: dl.identity }];
      summarize = {'*': DataRef.COUNT};
    } else if (atype === Aggregate.TYPES.TUPLE) {
      groupby = [{ name: DataRef.GROUPBY, get: dl.$(fields[0]) }];
      summarize = dl.isObject(sort) ? [{
        field: DataRef.VALUE,
        get:  dl.$(sort.field),
        ops: [sort.op]
      }] : {'*': DataRef.COUNT};
    } else {  // atype === Aggregate.TYPES.MULTI
      groupby   = DataRef.GROUPBY;
      summarize = [{ field: DataRef.VALUE, ops: [sort.op] }]; 
    }
  } else {
    groupby = [];
    summarize = [{
      field: DataRef.VALUE,
      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,
      ops: [DataRef.MIN, DataRef.MAX],
      as:  [DataRef.MIN, DataRef.MAX]
    }];
  }

  cache.param('groupby', groupby)
    .param('summarize', summarize);

  return (cache._lastUpdate = -1, cache);
}

function dataRef(which, def, scale, group) {
  if (def == null) { return []; }
  if (dl.isArray(def)) return def.map(signal.bind(this));

  var self = this, graph = this._graph,
      refs = getRefs(def),
      inherit = inherits(refs),
      atype = aggrType(def, scale),
      cache = getCache.apply(this, arguments),
      sort  = def.sort,
      uniques = isUniques(scale),
      i, rlen, j, flen, ref, fields, field, data, from, so, cmp;

  function addDep(s) {
    self.dependency(Deps.SIGNALS, s);
  }

  if (inherit || (!inherit && cache._lastUpdate < this._stamp)) {
    for (i=0, rlen=refs.length; i<rlen; ++i) {
      ref = refs[i];
      from = ref.data || group.datum._facetID;
      data = graph.data(from).last();

      if (data.stamp <= this._stamp) continue;

      fields = getFields(ref, group);
      for (j=0, flen=fields.length; j<flen; ++j) {
        field = fields[j];

        if (atype === Aggregate.TYPES.VALUE) {
          cache.accessors(null, field);
        } else if (atype === Aggregate.TYPES.MULTI) {
          cache.accessors(field, ref.sort || sort.field);
        } // Else (Tuple-case) is handled by the aggregator accessors by default

        cache.evaluate(data);
      }

      this.dependency(Deps.DATA, from);
      cache.dependency(Deps.SIGNALS).forEach(addDep);
    }

    cache._lastUpdate = this._stamp;

    data = cache.aggr().result();
    if (uniques) {
      if (dl.isObject(sort)) {
        cmp = (so = sort.order) && so.signal ? graph.signalRef(so.signal) : so;
        cmp = (cmp == DataRef.DESC ? '-' : '+') + sort.op + '_' + DataRef.VALUE;
        cmp = dl.comparator(cmp);
      } else if (sort === true) {
        cmp = dl.comparator(DataRef.GROUPBY);
      }

      if (cmp) data = data.sort(cmp);
      cache._values = data.map(function(d) { return d[DataRef.GROUPBY]; });
    } else {
      data = data[0];
      cache._values = !dl.isValid(data) ? [] : [data[DataRef.MIN], data[DataRef.MAX]];
    }
  }

  return cache._values;
}

function signal(v) {
  if (!v || !v.signal) return v;
  var s = v.signal, ref;
  this.dependency(Deps.SIGNALS, (ref = dl.field(s))[0]);
  return this._graph.signalRef(ref);
}

function domainMinMax(scale, group) {
  var def = this._def,
      domain = [null, null], s, z;

  if (def.domain !== undefined) {
    domain = (!dl.isObject(def.domain)) ? domain :
      dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
  }

  z = domain.length - 1;
  if (def.domainMin !== undefined) {
    if (dl.isObject(def.domainMin)) {
      if (def.domainMin.signal) {
        domain[0] = dl.isValid(s=signal.call(this, def.domainMin)) ? s : domain[0];
      } else {
        domain[0] = dataRef.call(this, DataRef.DOMAIN+DataRef.MIN, def.domainMin, scale, group)[0];
      }
    } else {
      domain[0] = def.domainMin;
    }
  }
  if (def.domainMax !== undefined) {
    if (dl.isObject(def.domainMax)) {
      if (def.domainMax.signal) {
        domain[z] = dl.isValid(s=signal.call(this, def.domainMax)) ? s : domain[z];
      } else {
        domain[z] = dataRef.call(this, DataRef.DOMAIN+DataRef.MAX, def.domainMax, scale, group)[1];
      }
    } else {
      domain[z] = def.domainMax;
    }
  }
  if (def.type !== Types.LOG && def.type !== Types.TIME && (def.zero || def.zero===undefined)) {
    domain[0] = Math.min(0, domain[0]);
    domain[z] = Math.max(0, domain[z]);
  }
  return domain;
}

function range(group) {
  var def = this._def,
      config = this._graph.config(),
      rangeVal = signal.call(this, def.range),
      rng = [null, null];

  if (rangeVal !== undefined) {
    if (typeof rangeVal === 'string') {
      if (Properties[rangeVal]) {
        rng = [0, group[rangeVal]];
      } else if (config.range[rangeVal]) {
        rng = config.range[rangeVal];
      } else {
        log.error('Unrecogized range: ' + rangeVal);
        return rng;
      }
    } else if (dl.isArray(rangeVal)) {
      rng = dl.duplicate(rangeVal).map(signal.bind(this));
    } else if (dl.isObject(rangeVal)) {
      return null; // early exit
    } else {
      rng = [0, rangeVal];
    }
  }
  if (def.rangeMin !== undefined) {
    rng[0] = def.rangeMin.signal ?
      signal.call(this, def.rangeMin) :
      def.rangeMin;
  }
  if (def.rangeMax !== undefined) {
    rng[rng.length-1] = def.rangeMax.signal ?
      signal.call(this, def.rangeMax) :
      def.rangeMax;
  }
  
  if (def.reverse !== undefined) {
    var rev = signal.call(this, def.reverse);
    if (dl.isObject(rev)) {
      rev = dl.accessor(rev.field)(group.datum);
    }
    if (rev) rng = rng.reverse();
  }
  
  return rng;
}

module.exports = Scale;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transforms/Aggregate":219,"datalib":49,"vega-dataflow":141,"vega-logging":147}],215:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    bound = require('vega-scenegraph').bound,
    Tuple = require('vega-dataflow').Tuple,
    Status = require('./Builder').STATUS;

function Transition(duration, ease) {
  this.duration = duration || 500;
  this.ease = ease && d3.ease(ease) || d3.ease('cubic-in-out');
  this.updates = {next: null};
}

var prototype = Transition.prototype;

var skip = {
  'text': 1,
  'url':  1
};

prototype.interpolate = function(item, values) {
  var key, curr, next, interp, list = null;

  for (key in values) {
    curr = item[key];
    next = values[key];      
    if (curr !== next) {
      if (skip[key] || curr === undefined) {
        // skip interpolation for specific keys or undefined start values
        Tuple.set(item, key, next);
      } else if (typeof curr === 'number' && !isFinite(curr)) {
        // for NaN or infinite numeric values, skip to final value
        Tuple.set(item, key, next);
      } else {
        // otherwise lookup interpolator
        interp = d3.interpolate(curr, next);
        interp.property = key;
        (list || (list=[])).push(interp);
      }
    }
  }

  if (list === null && item.status === Status.EXIT) {
    list = []; // ensure exiting items are included
  }

  if (list != null) {
    list.item = item;
    list.ease = item.mark.ease || this.ease;
    list.next = this.updates.next;
    this.updates.next = list;
  }
  return this;
};

prototype.start = function(callback) {
  var t = this, prev = t.updates, curr = prev.next;
  for (; curr!=null; prev=curr, curr=prev.next) {
    if (curr.item.status === Status.EXIT) {
      // Only mark item as exited when it is removed.
      curr.item.status = Status.UPDATE;
      curr.remove = true;
    }
  }
  t.callback = callback;
  d3.timer(function(elapsed) { return step.call(t, elapsed); });
};

function step(elapsed) {
  var list = this.updates, prev = list, curr = prev.next,
      duration = this.duration,
      item, delay, f, e, i, n, stop = true;

  for (; curr!=null; prev=curr, curr=prev.next) {
    item = curr.item;
    delay = item.delay || 0;

    f = (elapsed - delay) / duration;
    if (f < 0) { stop = false; continue; }
    if (f > 1) f = 1;
    e = curr.ease(f);

    for (i=0, n=curr.length; i<n; ++i) {
      item[curr[i].property] = curr[i](e);
    }
    item.touch();
    bound.item(item);

    if (f === 1) {
      if (curr.remove) {
        item.status = Status.EXIT;
        item.remove();
      }
      prev.next = curr.next;
      curr = prev;
    } else {
      stop = false;
    }
  }

  this.callback();
  return stop;
}

module.exports = Transition;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Builder":211,"vega-dataflow":141,"vega-scenegraph":148}],216:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    parseMark = require('../parse/mark');

var TIME    = 'time',
    UTC     = 'utc',
    STRING  = 'string',
    ORDINAL = 'ordinal',
    NUMBER  = 'number';

function axs(model) {
  var scale,
      config = model.config(),
      orient = config.axis.orient,
      offset = 0,
      titleOffset = config.axis.titleOffset,
      axisDef = {},
      layer = 'front',
      grid = false,
      title = null,
      tickMajorSize = config.axis.tickSize,
      tickMinorSize = config.axis.tickSize,
      tickEndSize = config.axis.tickSize,
      tickPadding = config.axis.padding,
      tickValues = null,
      tickFormatString = null,
      tickFormatType = null,
      tickSubdivide = 0,
      tickCount = config.axis.ticks,
      gridLineStyle = {},
      tickLabelStyle = {},
      majorTickStyle = {},
      minorTickStyle = {},
      titleStyle = {},
      domainStyle = {},
      m = { // Axis marks as references for updates
        gridLines:  {},
        majorTicks: {},
        minorTicks: {},
        tickLabels: {},
        domain: {},
        title:  {}
      };

  var axis = {};

  function reset() {
    axisDef.type = null;
  }

  function ingest(d) {
    return {data: d};
  }

  function getTickFormat() {
    var formatType = tickFormatType || inferFormatType();
    return getFormatter(formatType, tickFormatString);
  }

  function inferFormatType() {
    switch (scale.type) {
      case TIME:    return TIME;
      case UTC:     return UTC;
      case ORDINAL: return STRING;
      default:      return NUMBER;
    }
  }

  // Adapted from d3 log scale
  // TODO customize? replace with range-size-aware filtering?
  function logFilter(domain, count, f) {
    if (count == null) return f;
    var base = scale.base(),
        k = Math.min(base, scale.ticks().length / count),
        v = domain[0] > 0 ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
        e;
    function log(x) {
      return (domain[0] < 0 ?
        -Math.log(x > 0 ? 0 : -x) :
        Math.log(x < 0 ? 0 : x)) / Math.log(base);
    }
    function pow(x) {
      return domain[0] < 0 ? -Math.pow(base, -x) : Math.pow(base, x);
    }
    return function(d) {
      return pow(v(log(d) + e)) / d >= k ? f(d) : '';
    };
  }

  function getFormatter(formatType, str) {
    var fmt = dl.format,
        log = scale.type === 'log',
        domain, f;

    switch (formatType) {
      case NUMBER:
         domain = scale.domain();
         f = fmt.auto.number(domain, tickCount, str || (log ? '.1r' : null));
         return log ? logFilter(domain, tickCount, f) : f;
      case TIME: return (str ? fmt : fmt.auto).time(str);
      case UTC:  return (str ? fmt : fmt.auto).utc(str);
      default:   return String;
    }
  }
  
  function getTicks(format) {
    var major = tickValues || (scale.ticks ? scale.ticks(tickCount) : scale.domain()),
        minor = axisSubdivide(scale, major, tickSubdivide).map(ingest);
    major = major.map(function(d) { return (d = ingest(d), d.label = format(d.data), d); });
    return [major, minor];
  }

  axis.def = function() {
    if (!axisDef.type) axis_def(scale);

    var ticks = getTicks(getTickFormat());
    var tdata = title ? [title].map(ingest) : [];

    axisDef.marks[0].from = function() { return grid ? ticks[0] : []; };
    axisDef.marks[1].from = function() { return ticks[0]; };
    axisDef.marks[2].from = function() { return ticks[1]; };
    axisDef.marks[3].from = axisDef.marks[1].from;
    axisDef.marks[4].from = function() { return [1]; };
    axisDef.marks[5].from = function() { return tdata; };
    axisDef.offset = offset;
    axisDef.orient = orient;
    axisDef.layer = layer;

    return axisDef;
  };

  function axis_def(scale) {
    // setup scale mapping
    var newScale, oldScale, range;
    if (scale.type === ORDINAL) {
      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};
      oldScale = newScale;
    } else {
      newScale = {scale: scale.scaleName, offset: 0.5};
      oldScale = {scale: scale.scaleName+':prev', offset: 0.5};
    }
    range = axisScaleRange(scale);

    // setup axis marks
    dl.extend(m.gridLines, axisTicks(config));
    dl.extend(m.majorTicks, axisTicks(config));
    dl.extend(m.minorTicks, axisTicks(config));
    dl.extend(m.tickLabels, axisTickLabels(config));
    dl.extend(m.domain, axisDomain(config));
    dl.extend(m.title, axisTitle(config));
    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};
    m.gridLines.properties.enter.strokeOpacity = {value: config.axis.gridOpacity};

    // extend axis marks based on axis orientation
    axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);
    axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);
    axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);
    axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);

    axisDomainExtend(orient, m.domain, range, tickEndSize);
    axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset
    
    // add / override custom style properties
    dl.extend(m.gridLines.properties.update, gridLineStyle);
    dl.extend(m.majorTicks.properties.update, majorTickStyle);
    dl.extend(m.minorTicks.properties.update, minorTickStyle);
    dl.extend(m.tickLabels.properties.update, tickLabelStyle);
    dl.extend(m.domain.properties.update, domainStyle);
    dl.extend(m.title.properties.update, titleStyle);

    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];
    dl.extend(axisDef, {
      type: 'group',
      interactive: false,
      properties: { 
        enter: {
          encode: axisUpdate,
          scales: [scale.scaleName],
          signals: [], data: []
        },
        update: {
          encode: axisUpdate,
          scales: [scale.scaleName],
          signals: [], data: []
        }
      }
    });

    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    if (scale !== x) { scale = x; reset(); }
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    if (orient !== x) {
      orient = x in axisOrients ? x + '' : config.axis.orient;
      reset();
    }
    return axis;
  };

  axis.title = function(x) {
    if (!arguments.length) return title;
    if (title !== x) { title = x; reset(); }
    return axis;
  };

  axis.tickCount = function(x) {
    if (!arguments.length) return tickCount;
    tickCount = x;
    return axis;
  };

  axis.tickValues = function(x) {
    if (!arguments.length) return tickValues;
    tickValues = x;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormatString;
    if (tickFormatString !== x) {
      tickFormatString = x;
      reset();
    }
    return axis;
  };

  axis.tickFormatType = function(x) {
    if (!arguments.length) return tickFormatType;
    if (tickFormatType !== x) {
      tickFormatType = x;
      reset();
    }
    return axis;
  };

  axis.tickSize = function(x, y) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1,
        major = +x,
        minor = n > 1 ? +y : tickMajorSize,
        end   = n > 0 ? +arguments[n] : tickMajorSize;

    if (tickMajorSize !== major ||
        tickMinorSize !== minor ||
        tickEndSize !== end) {
      reset();
    }

    tickMajorSize = major;
    tickMinorSize = minor;
    tickEndSize = end;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };
  
  axis.offset = function(x) {
    if (!arguments.length) return offset;
    offset = dl.isObject(x) ? x : +x;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    if (tickPadding !== +x) { tickPadding = +x; reset(); }
    return axis;
  };

  axis.titleOffset = function(x) {
    if (!arguments.length) return titleOffset;
    if (titleOffset !== +x) { titleOffset = +x; reset(); }
    return axis;
  };

  axis.layer = function(x) {
    if (!arguments.length) return layer;
    if (layer !== x) { layer = x; reset(); }
    return axis;
  };

  axis.grid = function(x) {
    if (!arguments.length) return grid;
    if (grid !== x) { grid = x; reset(); }
    return axis;
  };

  axis.gridLineProperties = function(x) {
    if (!arguments.length) return gridLineStyle;
    if (gridLineStyle !== x) { gridLineStyle = x; }
    return axis;
  };

  axis.majorTickProperties = function(x) {
    if (!arguments.length) return majorTickStyle;
    if (majorTickStyle !== x) { majorTickStyle = x; }
    return axis;
  };

  axis.minorTickProperties = function(x) {
    if (!arguments.length) return minorTickStyle;
    if (minorTickStyle !== x) { minorTickStyle = x; }
    return axis;
  };

  axis.tickLabelProperties = function(x) {
    if (!arguments.length) return tickLabelStyle;
    if (tickLabelStyle !== x) { tickLabelStyle = x; }
    return axis;
  };

  axis.titleProperties = function(x) {
    if (!arguments.length) return titleStyle;
    if (titleStyle !== x) { titleStyle = x; }
    return axis;
  };

  axis.domainProperties = function(x) {
    if (!arguments.length) return domainStyle;
    if (domainStyle !== x) { domainStyle = x; }
    return axis;
  };
  
  axis.reset = function() { 
    reset(); 
    return axis; 
  };

  return axis;
}

var axisOrients = {top: 1, right: 1, bottom: 1, left: 1};

function axisSubdivide(scale, ticks, m) {
  var subticks = [];
  if (m && ticks.length > 1) {
    var extent = axisScaleExtent(scale.domain()),
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i < n) {
      for (j = m; --j > 0;) {
        if ((v = +ticks[i] - j * d) >= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}

function axisScaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function axisScaleRange(scale) {
  return scale.rangeExtent ?
    scale.rangeExtent() :
    axisScaleExtent(scale.range());
}

var axisAlign = {
  bottom: 'center',
  top: 'center',
  left: 'right',
  right: 'left'
};

var axisBaseline = {
  bottom: 'top',
  top: 'bottom',
  left: 'middle',
  right: 'middle'
};

function axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {
  size = Math.max(size, 0) + pad;
  if (orient === 'left' || orient === 'top') {
    size *= -1;
  }  
  if (orient === 'top' || orient === 'bottom') {
    dl.extend(labels.properties.enter, {
      x: oldScale,
      y: {value: size},
    });
    dl.extend(labels.properties.update, {
      x: newScale,
      y: {value: size},
      align: {value: 'center'},
      baseline: {value: axisBaseline[orient]}
    });
  } else {
    dl.extend(labels.properties.enter, {
      x: {value: size},
      y: oldScale,
    });
    dl.extend(labels.properties.update, {
      x: {value: size},
      y: newScale,
      align: {value: axisAlign[orient]},
      baseline: {value: 'middle'}
    });
  }
}

function axisTicksExtend(orient, ticks, oldScale, newScale, size) {
  var sign = (orient === 'left' || orient === 'top') ? -1 : 1;
  if (size === Infinity) {
    size = (orient === 'top' || orient === 'bottom') ?
      {field: {group: 'height', level: 2}, mult: -sign} :
      {field: {group: 'width',  level: 2}, mult: -sign};
  } else {
    size = {value: sign * size};
  }
  if (orient === 'top' || orient === 'bottom') {
    dl.extend(ticks.properties.enter, {
      x:  oldScale,
      y:  {value: 0},
      y2: size
    });
    dl.extend(ticks.properties.update, {
      x:  newScale,
      y:  {value: 0},
      y2: size
    });
    dl.extend(ticks.properties.exit, {
      x:  newScale,
    });        
  } else {
    dl.extend(ticks.properties.enter, {
      x:  {value: 0},
      x2: size,
      y:  oldScale
    });
    dl.extend(ticks.properties.update, {
      x:  {value: 0},
      x2: size,
      y:  newScale
    });
    dl.extend(ticks.properties.exit, {
      y:  newScale,
    });
  }
}

function axisTitleExtend(orient, title, range, offset) {
  var mid = ~~((range[0] + range[1]) / 2),
      sign = (orient === 'top' || orient === 'left') ? -1 : 1;
  
  if (orient === 'bottom' || orient === 'top') {
    dl.extend(title.properties.update, {
      x: {value: mid},
      y: {value: sign*offset},
      angle: {value: 0}
    });
  } else {
    dl.extend(title.properties.update, {
      x: {value: sign*offset},
      y: {value: mid},
      angle: {value: orient === 'left' ? -90 : 90}
    });
  }
}

function axisDomainExtend(orient, domain, range, size) {
  var path;
  if (orient === 'top' || orient === 'left') {
    size = -1 * size;
  }
  if (orient === 'bottom' || orient === 'top') {
    path = 'M' + range[0] + ',' + size + 'V0H' + range[1] + 'V' + size;
  } else {
    path = 'M' + size + ',' + range[0] + 'H0V' + range[1] + 'H' + size;
  }
  domain.properties.update.path = {value: path};
}

function axisUpdate(item, group, trans) {
  var o = trans ? {} : item,
      offset = item.mark.def.offset,
      orient = item.mark.def.orient,
      width  = group.width,
      height = group.height; // TODO fallback to global w,h?

  if (dl.isArray(offset)) {
    var ofx = offset[0],
        ofy = offset[1];

    switch (orient) {
      case 'left':   { Tuple.set(o, 'x', -ofx); Tuple.set(o, 'y', ofy); break; }
      case 'right':  { Tuple.set(o, 'x', width + ofx); Tuple.set(o, 'y', ofy); break; }
      case 'bottom': { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', height + ofy); break; }
      case 'top':    { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', -ofy); break; }
      default:       { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', ofy); }
    }
  } else {
    if (dl.isObject(offset)) {
      offset = -group.scale(offset.scale)(offset.value);
    }

    switch (orient) {
      case 'left':   { Tuple.set(o, 'x', -offset); Tuple.set(o, 'y', 0); break; }
      case 'right':  { Tuple.set(o, 'x', width + offset); Tuple.set(o, 'y', 0); break; }
      case 'bottom': { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', height + offset); break; }
      case 'top':    { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', -offset); break; }
      default:       { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', 0); }
    }
  }

  if (trans) trans.interpolate(item, o);
  return true;
}

function axisTicks(config) {
  return {
    type: 'rule',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        stroke: {value: config.axis.tickColor},
        strokeWidth: {value: config.axis.tickWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function axisTickLabels(config) {
  return {
    type: 'text',
    interactive: true,
    key: 'data',
    properties: {
      enter: {
        fill: {value: config.axis.tickLabelColor},
        font: {value: config.axis.tickLabelFont},
        fontSize: {value: config.axis.tickLabelFontSize},
        opacity: {value: 1e-6},
        text: {field: 'label'}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function axisTitle(config) {
  return {
    type: 'text',
    interactive: true,
    properties: {
      enter: {
        font: {value: config.axis.titleFont},
        fontSize: {value: config.axis.titleFontSize},
        fontWeight: {value: config.axis.titleFontWeight},
        fill: {value: config.axis.titleColor},
        align: {value: 'center'},
        baseline: {value: 'middle'},
        text: {field: 'data'}
      },
      update: {}
    }
  };
}

function axisDomain(config) {
  return {
    type: 'path',
    interactive: false,
    properties: {
      enter: {
        x: {value: 0.5},
        y: {value: 0.5},
        stroke: {value: config.axis.axisColor},
        strokeWidth: {value: config.axis.axisWidth}
      },
      update: {}
    }
  };
}

module.exports = axs;
},{"../parse/mark":200,"datalib":49,"vega-dataflow":141}],217:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Gradient = require('vega-scenegraph').Gradient,
    parseProperties = require('../parse/properties'),
    parseMark = require('../parse/mark');

function lgnd(model) {
  var size = null,
      shape = null,
      fill = null,
      stroke = null,
      spacing = null,
      values = null,
      format = null,
      formatString = null,
      config = model.config(),
      title,
      orient = 'right',
      offset = config.legend.offset,
      padding = config.legend.padding,
      tickArguments = [5],
      legendStyle = {},
      symbolStyle = {},
      gradientStyle = {},
      titleStyle = {},
      labelStyle = {},
      m = { // Legend marks as references for updates
        titles:  {},
        symbols: {},
        labels:  {},
        gradient: {}
      };

  var legend = {},
      legendDef = {};

  function reset() { legendDef.type = null; }
  function ingest(d, i) { return {data: d, index: i}; }

  legend.def = function() {
    var scale = size || shape || fill || stroke;
    
    format = !formatString ? null : ((scale.type === 'time') ?
      dl.format.time(formatString) : dl.format.number(formatString));
    
    if (!legendDef.type) {
      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type) ?
        quantDef(scale) : ordinalDef(scale);      
    }
    legendDef.orient = orient;
    legendDef.offset = offset;
    legendDef.padding = padding;
    return legendDef;
  };

  function discrete(type) {
    return type==='ordinal' || type==='quantize' ||
           type==='quantile' || type==='threshold';
  }

  function ordinalDef(scale) {
    var def = o_legend_def(size, shape, fill, stroke);

    // generate data
    var data = (values == null ?
      (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :
      values).map(ingest);
    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;
    
    // determine spacing between legend entries
    var fs, range, offset, pad=5, domain = d3.range(data.length);
    if (size) {
      range = data.map(function(x) { return Math.sqrt(size(x.data)); });
      offset = d3.max(range);
      range = range.reduce(function(a,b,i,z) {
          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;
          return (a[i] += b/2, a); }, [0]).map(Math.round);
    } else {
      offset = Math.round(Math.sqrt(config.legend.symbolSize));
      range = spacing ||
        (fs = labelStyle.fontSize) && (fs.value + pad) ||
        (config.legend.labelFontSize + pad);
      range = domain.map(function(d,i) {
        return Math.round(offset/2 + i*range);
      });
    }

    // account for padding and title size
    var sz = padding, ts;
    if (title) {
      ts = titleStyle.fontSize;
      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);
    }
    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;
    
    // build scale for label layout
    var scaleSpec = {
      name: 'legend',
      type: 'ordinal',
      points: true,
      domain: domain,
      range: range
    };
    
    // update legend def
    var tdata = (title ? [title] : []).map(ingest);
    data.forEach(function(d) {
      d.label = fmt(d.data);
      d.offset = offset;
    });
    def.scales = [ scaleSpec ];
    def.marks[0].from = function() { return tdata; };
    def.marks[1].from = function() { return data; };
    def.marks[2].from = def.marks[1].from;

    return def;
  }

  function o_legend_def(size, shape, fill, stroke) {
    // setup legend marks
    var titles  = dl.extend(m.titles, vg_legendTitle(config)),
        symbols = dl.extend(m.symbols, vg_legendSymbols(config)),
        labels  = dl.extend(m.labels, vg_vLegendLabels(config));

    // extend legend marks
    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);
    
    // add / override custom style properties
    dl.extend(titles.properties.update,  titleStyle);
    dl.extend(symbols.properties.update, symbolStyle);
    dl.extend(labels.properties.update,  labelStyle);

    // padding from legend border
    titles.properties.enter.x.value += padding;
    titles.properties.enter.y.value += padding;
    labels.properties.enter.x.offset += padding + 1;
    symbols.properties.enter.x.offset = padding + 1;
    labels.properties.update.x.offset += padding + 1;
    symbols.properties.update.x.offset = padding + 1;

    dl.extend(legendDef, {
      type: 'group',
      interactive: false,
      properties: {
        enter: parseProperties(model, 'group', legendStyle),
        vg_legendPosition: {
          encode: vg_legendPosition,
          signals: [], scales:[], data: [], fields: []
        }
      }
    });

    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });
    return legendDef;
  }

  function quantDef(scale) {
    var def = q_legend_def(scale),
        dom = scale.domain(),
        data = (values == null ?
          (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :
          values).map(ingest),
        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,
        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;

    // build scale for label layout
    var layoutSpec = {
      name: 'legend',
      type: scale.type,
      round: true,
      zero: false,
      domain: [dom[0], dom[dom.length-1]],
      range: [padding, width+padding]
    };
    if (scale.type==='pow') layoutSpec.exponent = scale.exponent();
    
    // update legend def
    var tdata = (title ? [title] : []).map(ingest);
    data.forEach(function(d,i) {
      d.label = fmt(d.data);
      d.align = i==(data.length-1) ? 'right' : i===0 ? 'left' : 'center';
    });
    def.scales = [ layoutSpec ];
    def.marks[0].from = function() { return tdata; };
    def.marks[1].from = function() { return [1]; };
    def.marks[2].from = function() { return data; };
    return def;
  }
  
  function q_legend_def(scale) {
    // setup legend marks
    var titles = dl.extend(m.titles, vg_legendTitle(config)),
        gradient = dl.extend(m.gradient, vg_legendGradient(config)),
        labels = dl.extend(m.labels, vg_hLegendLabels(config)),
        grad = new Gradient();

    // setup color gradient
    var dom = scale.domain(),
        min = dom[0],
        max = dom[dom.length-1],
        f = scale.copy().domain([min, max]).range([0,1]);
        
    var stops = (scale.type !== 'linear' && scale.ticks) ?
      scale.ticks.call(scale, 15) : dom;
    if (min !== stops[0]) stops.unshift(min);
    if (max !== stops[stops.length-1]) stops.push(max);

    for (var i=0, n=stops.length; i<n; ++i) {
      grad.stop(f(stops[i]), scale(stops[i]));
    }
    gradient.properties.enter.fill = {value: grad};

    // add / override custom style properties
    dl.extend(titles.properties.update, titleStyle);
    dl.extend(gradient.properties.update, gradientStyle);
    dl.extend(labels.properties.update, labelStyle);

    // account for gradient size
    var gp = gradient.properties, gh = gradientStyle.height,
        hh = (gh && gh.value) || gp.enter.height.value;
    labels.properties.enter.y.value = hh;
    labels.properties.update.y.value = hh;

    // account for title size as needed
    if (title) {
      var tp = titles.properties, fs = titleStyle.fontSize,
          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);
      gradient.properties.enter.y.value += sz;
      labels.properties.enter.y.value += sz;
      gradient.properties.update.y.value += sz;
      labels.properties.update.y.value += sz;
    }
    
    // padding from legend border
    titles.properties.enter.x.value += padding;
    titles.properties.enter.y.value += padding;
    gradient.properties.enter.x.value += padding;
    gradient.properties.enter.y.value += padding;
    labels.properties.enter.y.value += padding;
    gradient.properties.update.x.value += padding;
    gradient.properties.update.y.value += padding;
    labels.properties.update.y.value += padding;

    dl.extend(legendDef, {
      type: 'group',
      interactive: false,
      properties: {
        enter: parseProperties(model, 'group', legendStyle),
        vg_legendPosition: {
          encode: vg_legendPosition,
          signals: [], scales: [], data: [], fields: []
        }
      }
    });

    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });
    return legendDef;
  }

  legend.size = function(x) {
    if (!arguments.length) return size;
    if (size !== x) { size = x; reset(); }
    return legend;
  };

  legend.shape = function(x) {
    if (!arguments.length) return shape;
    if (shape !== x) { shape = x; reset(); }
    return legend;
  };

  legend.fill = function(x) {
    if (!arguments.length) return fill;
    if (fill !== x) { fill = x; reset(); }
    return legend;
  };
  
  legend.stroke = function(x) {
    if (!arguments.length) return stroke;
    if (stroke !== x) { stroke = x; reset(); }
    return legend;
  };

  legend.title = function(x) {
    if (!arguments.length) return title;
    if (title !== x) { title = x; reset(); }
    return legend;
  };

  legend.format = function(x) {
    if (!arguments.length) return formatString;
    if (formatString !== x) {
      formatString = x;
      reset();
    }
    return legend;
  };

  legend.spacing = function(x) {
    if (!arguments.length) return spacing;
    if (spacing !== +x) { spacing = +x; reset(); }
    return legend;
  };

  legend.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x in vg_legendOrients ? x + '' : config.legend.orient;
    return legend;
  };

  legend.offset = function(x) {
    if (!arguments.length) return offset;
    offset = +x;
    return legend;
  };

  legend.values = function(x) {
    if (!arguments.length) return values;
    values = x;
    return legend;
  };

  legend.legendProperties = function(x) {
    if (!arguments.length) return legendStyle;
    legendStyle = x;
    return legend;
  };

  legend.symbolProperties = function(x) {
    if (!arguments.length) return symbolStyle;
    symbolStyle = x;
    return legend;
  };

  legend.gradientProperties = function(x) {
    if (!arguments.length) return gradientStyle;
    gradientStyle = x;
    return legend;
  };

  legend.labelProperties = function(x) {
    if (!arguments.length) return labelStyle;
    labelStyle = x;
    return legend;
  };
  
  legend.titleProperties = function(x) {
    if (!arguments.length) return titleStyle;
    titleStyle = x;
    return legend;
  };

  legend.reset = function() { 
    reset(); 
    return legend;
  };

  return legend;
}

var vg_legendOrients = {right: 1, left: 1};

function vg_legendPosition(item, group, trans, db, signals, predicates) {
  var o = trans ? {} : item, gx,
      offset = item.mark.def.offset,
      orient = item.mark.def.orient,
      pad    = item.mark.def.padding * 2,
      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),
      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),
      pos = group._legendPositions || 
        (group._legendPositions = {right: 0.5, left: 0.5});

  o.x = 0.5;
  o.width = lw;
  o.y = pos[orient];
  pos[orient] += (o.height = lh);

  // HACK: use to estimate group bounds during animated transition
  if (!trans && group.bounds) {
    group.bounds.delta = group.bounds.x2 - group.width;
  }

  switch (orient) {
    case 'left':  {
      gx = group.bounds ? group.bounds.x1 : 0;
      o.x += gx - offset - lw;
      break;
    }
    case 'right': {
      gx = group.width + (group.bounds && trans ? group.bounds.delta : 0);
      o.x += gx + offset;
      break;
    }
  }
  
  if (trans) trans.interpolate(item, o);
  var enc = item.mark.def.properties.enter.encode;
  enc.call(enc, item, group, trans, db, signals, predicates);
  return true;
}

function vg_legendSymbolExtend(mark, size, shape, fill, stroke) {
  var e = mark.properties.enter,
      u = mark.properties.update;
  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: 'data'};
  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: 'data'};
  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: 'data'};
  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: 'data'};
}

function vg_legendTitle(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {value: 0},
        y: {value: 0},
        fill: {value: cfg.titleColor},
        font: {value: cfg.titleFont},
        fontSize: {value: cfg.titleFontSize},
        fontWeight: {value: cfg.titleFontWeight},
        baseline: {value: 'top'},
        text: {field: 'data'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: { opacity: {value: 1} }
    }
  };
}

function vg_legendSymbols(config) {
  var cfg = config.legend;
  return {
    type: 'symbol',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {field: 'offset', mult: 0.5},
        y: {scale: 'legend', field: 'index'},
        shape: {value: cfg.symbolShape},
        size: {value: cfg.symbolSize},
        stroke: {value: cfg.symbolColor},
        strokeWidth: {value: cfg.symbolStrokeWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {field: 'offset', mult: 0.5},
        y: {scale: 'legend', field: 'index'},
        opacity: {value: 1}
      }
    }
  };
}

function vg_vLegendLabels(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {field: 'offset', offset: 5},
        y: {scale: 'legend', field: 'index'},
        fill: {value: cfg.labelColor},
        font: {value: cfg.labelFont},
        fontSize: {value: cfg.labelFontSize},
        align: {value: cfg.labelAlign},
        baseline: {value: cfg.labelBaseline},
        text: {field: 'label'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        opacity: {value: 1},
        x: {field: 'offset', offset: 5},
        y: {scale: 'legend', field: 'index'},
      }
    }
  };
}

function vg_legendGradient(config) {
  var cfg = config.legend;
  return {
    type: 'rect',
    interactive: false,
    properties: {
      enter: {
        x: {value: 0},
        y: {value: 0},
        width: {value: cfg.gradientWidth},
        height: {value: cfg.gradientHeight},
        stroke: {value: cfg.gradientStrokeColor},
        strokeWidth: {value: cfg.gradientStrokeWidth},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {value: 0},
        y: {value: 0},
        opacity: {value: 1}
      }
    }
  };
}

function vg_hLegendLabels(config) {
  var cfg = config.legend;
  return {
    type: 'text',
    interactive: false,
    key: 'data',
    properties: {
      enter: {
        x: {scale: 'legend', field: 'data'},
        y: {value: 20},
        dy: {value: 2},
        fill: {value: cfg.labelColor},
        font: {value: cfg.labelFont},
        fontSize: {value: cfg.labelFontSize},
        align: {field: 'align'},
        baseline: {value: 'top'},
        text: {field: 'label'},
        opacity: {value: 1e-6}
      },
      exit: { opacity: {value: 1e-6} },
      update: {
        x: {scale: 'legend', field: 'data'},
        y: {value: 20},
        opacity: {value: 1}
      }
    }
  };
}

module.exports = lgnd;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../parse/mark":200,"../parse/properties":205,"datalib":49,"vega-scenegraph":148}],218:[function(require,module,exports){
module.exports = function visit(node, func) {
  var i, n, s, m, items;
  if (func(node)) return true;

  var sets = ['items', 'axisItems', 'legendItems'];
  for (s=0, m=sets.length; s<m; ++s) {
    if ((items = node[sets[s]])) {
      for (i=0, n=items.length; i<n; ++i) {
        if (visit(items[i], func)) return true;
      }
    }
  }
};
},{}],219:[function(require,module,exports){
var dl = require('datalib'),
    df = require('vega-dataflow'),
    log = require('vega-logging'),
    ChangeSet = df.ChangeSet,
    Tuple = df.Tuple,
    Deps = df.Dependencies,
    Transform = require('./Transform'),
    Facetor = require('./Facetor');

function Aggregate(graph) {
  Transform.prototype.init.call(this, graph);

  Transform.addParameters(this, {
    groupby: {type: 'array<field>'},
    summarize: {
      type: 'custom', 
      set: function(summarize) {
        var signalDeps = {},
            tx = this._transform,
            i, len, f, fields, name, ops;

        if (!dl.isArray(fields = summarize)) { // Object syntax from dl
          fields = [];
          for (name in summarize) {
            ops = dl.array(summarize[name]);
            fields.push({field: name, ops: ops});
          }
        }

        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }

        for (i=0, len=fields.length; i<len; ++i) {
          f = fields[i];
          if (f.field.signal) { signalDeps[f.field.signal] = 1; }
          dl.array(f.ops).forEach(sg);
          dl.array(f.as).forEach(sg);
        }

        tx._fields = fields;
        tx._aggr = null;
        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));
        return tx;
      }
    }
  });

  this._aggr  = null; // dl.Aggregator
  this._input = null; // Used by Facetor._on_keep.
  this._args  = null; // To cull re-computation.
  this._fields = [];
  this._out = [];

  this._type = TYPES.TUPLE; 
  this._acc = {groupby: dl.true, value: dl.true};

  return this.router(true).produces(true);
}

var prototype = (Aggregate.prototype = Object.create(Transform.prototype));
prototype.constructor = Aggregate;

var TYPES = Aggregate.TYPES = {
  VALUE: 1, 
  TUPLE: 2, 
  MULTI: 3
};

Aggregate.VALID_OPS = [
  'values', 'count', 'valid', 'missing', 'distinct', 
  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', 
  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', 
  'argmin', 'argmax'
];

prototype.type = function(type) { 
  return (this._type = type, this); 
};

prototype.accessors = function(groupby, value) {
  var acc = this._acc;
  acc.groupby = dl.$(groupby) || dl.true;
  acc.value = dl.$(value) || dl.true;
};

prototype.aggr = function() {
  if (this._aggr) return this._aggr;

  var g = this._graph,
      hasGetter = false,
      args = [],
      groupby = this.param('groupby').field,
      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };

  // Prepare summarize fields.
  var fields = this._fields.map(function(f) {
    var field = {
      name: value(f.field),
      as:   dl.array(f.as),
      ops:  dl.array(value(f.ops)).map(value),
      get:  f.get
    };
    hasGetter = hasGetter || field.get != null;
    args.push(field.name);
    return field;
  });

  // If there is an arbitrary getter, all bets are off.
  // Otherwise, we can check argument fields to cull re-computation.
  groupby.forEach(function(g) {
    if (g.get) hasGetter = true;
    args.push(g.name || g);
  });
  this._args = hasGetter || !fields.length ? null : args;

  if (!fields.length) fields = {'*': 'values'};

  // Instatiate our aggregator instance.
  // Facetor is a special subclass that can facet into data pipelines.
  var aggr = this._aggr = new Facetor()
    .groupby(groupby)
    .stream(true)
    .summarize(fields);

  // Collect output fields sets by this aggregate.
  this._out = getFields(aggr);

  // If we are processing tuples, key them by '_id'.
  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }

  return aggr;
};

function getFields(aggr) {
  // Collect the output fields set by this aggregate.
  var f = [], i, n, j, m, dims, vals, meas;

  dims = aggr._dims;
  for (i=0, n=dims.length; i<n; ++i) {
    f.push(dims[i].name);
  }

  vals = aggr._aggr;
  for (i=0, n=vals.length; i<n; ++i) {
    meas = vals[i].measures.fields;
    for (j=0, m=meas.length; j<m; ++j) {
      f.push(meas[j]);
    }
  }

  return f;
}

prototype.transform = function(input, reset) {
  log.debug(input, ['aggregate']);
  this._input = input; // Used by Facetor._on_keep.

  var output = ChangeSet.create(input),
      aggr = this.aggr(),
      out = this._out,
      args = this._args,
      reeval = true,
      p = Tuple.prev,
      add, rem, mod, i;

  // Upon reset, retract prior tuples and re-initialize.
  if (reset) {
    output.rem.push.apply(output.rem, aggr.result());
    aggr.clear();
    this._aggr = null;
    aggr = this.aggr();
  }

  // Get update methods according to input type.
  if (this._type === TYPES.TUPLE) {
    add = function(x) { aggr._add(x); Tuple.prev_init(x); };
    rem = function(x) { aggr._rem(p(x)); };
    mod = function(x) { aggr._mod(x, p(x)); };
  } else {
    var gby = this._acc.groupby,
        val = this._acc.value,
        get = this._type === TYPES.VALUE ? val : function(x) {
          return { _id: x._id, groupby: gby(x), value: val(x) };
        };
    add = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };
    rem = function(x) { aggr._rem(get(p(x))); };
    mod = function(x) { aggr._mod(get(x), get(p(x))); };
  }

  input.add.forEach(add);
  if (reset) {
    // A signal change triggered reflow. Add everything.
    // No need for rem, we cleared the aggregator.
    input.mod.forEach(add);
  } else {
    input.rem.forEach(rem);

    // If possible, check argument fields to see if we need to re-process mods.
    if (args) for (i=0, reeval=false; i<args.length; ++i) {
      if (input.fields[args[i]]) { reeval = true; break; }
    }
    if (reeval) input.mod.forEach(mod);
  }

  // Indicate output fields and return aggregate tuples.
  for (i=0; i<out.length; ++i) {
    output.fields[out[i]] = 1;
  }
  return aggr.changes(output);
};

module.exports = Aggregate;
},{"./Facetor":225,"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],220:[function(require,module,exports){
var Base = require('./Transform').prototype;

function BatchTransform() {
  // Nearest appropriate collector. 
  // Set by the dataflow Graph during connection.
  this._collector = null; 
}

var prototype = (BatchTransform.prototype = Object.create(Base));
prototype.constructor = BatchTransform;

prototype.init = function(graph) {
  Base.init.call(this, graph);
  return this.batch(true);
};

prototype.transform = function(input) {
  return this.batchTransform(input, this._collector.data());
};

prototype.batchTransform = function(/* input, data */) {
};

module.exports = BatchTransform;
},{"./Transform":238}],221:[function(require,module,exports){
var bins = require('datalib').bins,
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Bin(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field: {type: 'field'},
    min: {type: 'value'},
    max: {type: 'value'},
    base: {type: 'value', default: 10},
    maxbins: {type: 'value', default: 20},
    step: {type: 'value'},
    steps: {type: 'value'},
    minstep: {type: 'value'},
    div: {type: 'array<value>', default: [5, 2]}
  });

  this._output = {bin: 'bin'};
  return this.mutates(true);
}

var prototype = (Bin.prototype = Object.create(Transform.prototype));
prototype.constructor = Bin;

prototype.transform = function(input) {
  log.debug(input, ['binning']);

  var output  = this._output.bin,
      step    = this.param('step'),
      steps   = this.param('steps'),
      minstep = this.param('minstep'),
      get     = this.param('field').accessor,
      opt = {
        min: this.param('min'),
        max: this.param('max'),
        base: this.param('base'),
        maxbins: this.param('maxbins'),
        div: this.param('div')
      };

  if (step) opt.step = step;
  if (steps) opt.steps = steps;
  if (minstep) opt.minstep = minstep;
  var b = bins(opt);

  function update(d) {
    var v = get(d);
    v = v == null ? null
      : b.start + b.step * ~~((v - b.start) / b.step);
    Tuple.set(d, output, v);
  }
  input.add.forEach(update);
  input.mod.forEach(update);
  input.rem.forEach(update);

  input.fields[output] = 1;
  return input;
};

module.exports = Bin;
},{"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],222:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function CountPattern(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field:     {type: 'field', default: 'data'},
    pattern:   {type: 'value', default: '[\\w\']+'},
    case:      {type: 'value', default: 'lower'},
    stopwords: {type: 'value', default: ''}
  });

  this._output = {text: 'text', count: 'count'};

  return this.router(true).produces(true);
}

var prototype = (CountPattern.prototype = Object.create(Transform.prototype));
prototype.constructor = CountPattern;

prototype.transform = function(input, reset) {
  log.debug(input, ['countpattern']);

  var get = this.param('field').accessor,
      pattern = this.param('pattern'),
      stop = this.param('stopwords'),
      rem = false;

  // update parameters
  if (this._stop !== stop) {
    this._stop = stop;
    this._stop_re = new RegExp('^' + stop + '$', 'i');
    reset = true;
  }

  if (this._pattern !== pattern) {
    this._pattern = pattern;
    this._match = new RegExp(this._pattern, 'g');
    reset = true;
  }

  if (reset) this._counts = {};

  function curr(t) { return (Tuple.prev_init(t), get(t)); }
  function prev(t) { return get(Tuple.prev(t)); }

  this._add(input.add, curr);
  if (!reset) this._rem(input.rem, prev);
  if (reset || (rem = input.fields[get.field])) {
    if (rem) this._rem(input.mod, prev);
    this._add(input.mod, curr);
  }

  // generate output tuples
  return this._changeset(input);
};

prototype._changeset = function(input) {
  var counts = this._counts,
      tuples = this._tuples || (this._tuples = {}),
      change = df.ChangeSet.create(input),
      out = this._output, w, t, c;

  for (w in counts) {
    t = tuples[w];
    c = counts[w] || 0;
    if (!t && c) {
      tuples[w] = (t = Tuple.ingest({}));
      t[out.text] = w;
      t[out.count] = c;
      change.add.push(t);
    } else if (c === 0) {
      if (t) change.rem.push(t);
      delete counts[w];
      delete tuples[w];
    } else if (t[out.count] !== c) {
      Tuple.set(t, out.count, c);
      change.mod.push(t);
    }
  }
  return change;
};

prototype._tokenize = function(text) {
  switch (this.param('case')) {
    case 'upper': text = text.toUpperCase(); break;
    case 'lower': text = text.toLowerCase(); break;
  }
  return text.match(this._match);
};

prototype._add = function(tuples, get) {
  var counts = this._counts,
      stop = this._stop_re,
      tok, i, j, t;

  for (j=0; j<tuples.length; ++j) {
    tok = this._tokenize(get(tuples[j]));
    for (i=0; i<tok.length; ++i) {
      if (!stop.test(t=tok[i])) {
        counts[t] = 1 + (counts[t] || 0);
      }
    }
  }
};

prototype._rem = function(tuples, get) {
  var counts = this._counts,
      stop = this._stop_re,
      tok, i, j, t;

  for (j=0; j<tuples.length; ++j) {
    tok = this._tokenize(get(tuples[j]));
    for (i=0; i<tok.length; ++i) {
      if (!stop.test(t=tok[i])) {
        counts[t] -= 1;
      }
    }
  }
};

module.exports = CountPattern;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],223:[function(require,module,exports){
var df = require('vega-dataflow'),
    ChangeSet = df.ChangeSet,
    Tuple = df.Tuple,
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Cross(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    with: {type: 'data'},
    diagonal: {type: 'value', default: 'true'},
    filter: {type: 'expr'}
  });

  this._output = {'left': 'a', 'right': 'b'};
  this._lastRem  = null; // Most recent stamp that rem occured. 
  this._lastWith = null; // Last time we crossed w/withds.
  this._ids   = {};
  this._cache = {};

  return this.router(true).produces(true);
}

var prototype = (Cross.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Cross;

// Each cached incoming tuple also has a stamp to track if we need to do
// lazy filtering of removed tuples.
function cache(x, t) {
  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};
  c.c.push(t);
}

function add(output, left, data, diag, test, x) {
  var i = 0, len = data.length, t = {}, y, id;

  for (; i<len; ++i) {
    y = data[i];
    id = left ? x._id+'_'+y._id : y._id+'_'+x._id;
    if (this._ids[id]) continue;
    if (x._id == y._id && !diag) continue;

    t[this._output.left]  = left ? x : y;
    t[this._output.right] = left ? y : x;

    // Only ingest a tuple if we keep it around.
    if (!test || test(t)) {
      output.add.push(t=Tuple.ingest(t));
      cache.call(this, x, t);
      cache.call(this, y, t);
      this._ids[id] = 1;
      t = {};
    }    
  }
}

function mod(output, left, x) {
  var cross = this,
      c = this._cache[x._id];

  if (this._lastRem > c.s) {  // Removed tuples haven't been filtered yet
    c.c = c.c.filter(function(y) {
      var t = y[cross._output[left ? 'right' : 'left']];
      return cross._cache[t._id] !== null;
    });
    c.s = this._lastRem;
  }

  output.mod.push.apply(output.mod, c.c);
}

function rem(output, x) {
  output.rem.push.apply(output.rem, this._cache[x._id].c);
  this._cache[x._id] = null;
  this._lastRem = this._stamp;
}

function upFields(input, output) {
  if (input.add.length || input.rem.length) {
    output.fields[this._output.left]  = 1; 
    output.fields[this._output.right] = 1;
  }
}

prototype.batchTransform = function(input, data) {
  log.debug(input, ['crossing']);

  var w = this.param('with'),
      f = this.param('filter'),
      diag = this.param('diagonal'),
      graph = this._graph,
      signals = graph.values(SIGNALS, this.dependency(SIGNALS)),
      test = f ? function(x) {return f(x, null, signals); } : null,
      selfCross = (!w.name),
      woutput = selfCross ? input : w.source.last(),
      wdata   = selfCross ? data : w.source.values(),
      output  = ChangeSet.create(input),
      r = rem.bind(this, output);

  input.rem.forEach(r);
  input.add.forEach(add.bind(this, output, true, wdata, diag, test));

  if (!selfCross && woutput.stamp > this._lastWith) {
    woutput.rem.forEach(r);
    woutput.add.forEach(add.bind(this, output, false, data, diag, test));
    woutput.mod.forEach(mod.bind(this, output, false));
    upFields.call(this, woutput, output);
    this._lastWith = woutput.stamp;
  }

  // Mods need to come after all removals have been run.
  input.mod.forEach(mod.bind(this, output, true));
  upFields.call(this, input, output);

  return output;
};

module.exports = Cross;
},{"./BatchTransform":220,"./Transform":238,"vega-dataflow":141,"vega-logging":147}],224:[function(require,module,exports){
var Transform = require('./Transform'),
    Aggregate = require('./Aggregate');

function Facet(graph) {
  Transform.addParameters(this, {
    transform: {
      type: "custom",
      set: function(pipeline) {
        return (this._transform._pipeline = pipeline, this._transform);
      },
      get: function() {
        var parse = require('../parse/transforms'),
            facet = this._transform;
        return facet._pipeline.map(function(t) {
          return parse(facet._graph, t);
        });
      }      
    }
  });

  this._pipeline = [];
  return Aggregate.call(this, graph);
}

var prototype = (Facet.prototype = Object.create(Aggregate.prototype));
prototype.constructor = Facet;

prototype.aggr = function() {
  return Aggregate.prototype.aggr.call(this).facet(this);
};

module.exports = Facet;
},{"../parse/transforms":209,"./Aggregate":219,"./Transform":238}],225:[function(require,module,exports){
var dl = require('datalib'),
    Aggregator = dl.Aggregator,
    Base = Aggregator.prototype,
    df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    facetID = 0;

function Facetor() {
  Aggregator.call(this);
  this._facet = null;
  this._facetID = ++facetID;
}

var prototype = (Facetor.prototype = Object.create(Base));
prototype.constructor = Facetor;

prototype.facet = function(f) {
  return arguments.length ? (this._facet = f, this) : this._facet;
};

prototype._ingest = function(t) { 
  return Tuple.ingest(t, null);
};

prototype._assign = Tuple.set;

function disconnect_cell(facet) {
  log.debug({}, ['disconnecting cell', this.tuple._id]);
  var pipeline = this.ds.pipeline();
  facet.removeListener(pipeline[0]);
  facet._graph.removeListener(pipeline[0]);
  facet._graph.disconnect(pipeline);
}

prototype._newcell = function(x, key) {
  var cell  = Base._newcell.call(this, x, key),
      facet = this._facet;

  if (facet) {
    var graph = facet._graph,
        tuple = cell.tuple,
        pipeline = facet.param('transform');
    cell.ds = graph.data(tuple._facetID, pipeline, tuple);
    cell.disconnect = disconnect_cell;
    facet.addListener(pipeline[0]);
  }

  return cell;
};

prototype._newtuple = function(x, key) {
  var t = Base._newtuple.call(this, x);
  if (this._facet) {
    Tuple.set(t, 'key', key);
    Tuple.set(t, '_facetID', this._facetID + '_' + key);
  }
  return t;
};

prototype.clear = function() {
  if (this._facet) {
    for (var k in this._cells) {
      this._cells[k].disconnect(this._facet);
    }
  }
  return Base.clear.call(this);
};

prototype._on_add = function(x, cell) {
  if (this._facet) cell.ds._input.add.push(x);
};

prototype._on_rem = function(x, cell) {
  if (this._facet) cell.ds._input.rem.push(x);
};

prototype._on_mod = function(x, prev, cell0, cell1) {
  if (this._facet) { // Propagate tuples
    if (cell0 === cell1) {
      cell0.ds._input.mod.push(x);
    } else {
      cell0.ds._input.rem.push(x);
      cell1.ds._input.add.push(x);
    }
  }
};

prototype._on_drop = function(cell) {
  if (this._facet) cell.disconnect(this._facet);
};

prototype._on_keep = function(cell) {
  // propagate sort, signals, fields, etc.
  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);
};

module.exports = Facetor;
},{"datalib":49,"vega-dataflow":141,"vega-logging":147}],226:[function(require,module,exports){
var df = require('vega-dataflow'),
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Filter(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {test: {type: 'expr'}});

  this._skip = {};
  return this.router(true);
}

var prototype = (Filter.prototype = Object.create(Transform.prototype));
prototype.constructor = Filter;

prototype.transform = function(input) {
  log.debug(input, ['filtering']);

  var output = df.ChangeSet.create(input),
      graph = this._graph,
      skip = this._skip,
      test = this.param('test'),
      signals = graph.values(SIGNALS, this.dependency(SIGNALS));

  input.rem.forEach(function(x) {
    if (skip[x._id] !== 1) output.rem.push(x);
    else skip[x._id] = 0;
  });

  input.add.forEach(function(x) {
    if (test(x, null, signals)) output.add.push(x);
    else skip[x._id] = 1;
  });

  input.mod.forEach(function(x) {
    var b = test(x, null, signals),
        s = (skip[x._id] === 1);
    if (b && s) {
      skip[x._id] = 0;
      output.add.push(x);
    } else if (b && !s) {
      output.mod.push(x);
    } else if (!b && s) {
      // do nothing, keep skip true
    } else { // !b && !s
      output.rem.push(x);
      skip[x._id] = 1;
    }
  });

  return output;
};

module.exports = Filter;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],227:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Fold(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    fields: {type: 'array<field>'} 
  });

  this._output = {key: 'key', value: 'value'};
  this._cache = {};

  return this.router(true).produces(true);
}

var prototype = (Fold.prototype = Object.create(Transform.prototype));
prototype.constructor = Fold;

prototype._reset = function(input, output) { 
  for (var id in this._cache) {
    output.rem.push.apply(output.rem, this._cache[id]);
  }
  this._cache = {};
};

prototype._tuple = function(x, i, len) {
  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));
  return list[i] ? Tuple.rederive(x, list[i]) : (list[i] = Tuple.derive(x));
};

prototype._fn = function(data, on, out) {
  var i, j, n, m, d, t;
  for (i=0, n=data.length; i<n; ++i) {
    d = data[i];
    for (j=0, m=on.field.length; j<m; ++j) {
      t = this._tuple(d, j, m);  
      Tuple.set(t, this._output.key, on.field[j]);
      Tuple.set(t, this._output.value, on.accessor[j](d));
      out.push(t);
    }      
  }
};

prototype.transform = function(input, reset) {
  log.debug(input, ['folding']);

  var fold = this,
      on = this.param('fields'),
      output = df.ChangeSet.create(input);

  if (reset) this._reset(input, output);

  this._fn(input.add, on, output.add);
  this._fn(input.mod, on, reset ? output.add : output.mod);
  input.rem.forEach(function(x) {
    output.rem.push.apply(output.rem, fold._cache[x._id]);
    fold._cache[x._id] = null;
  });

  // If we're only propagating values, don't mark key/value as updated.
  if (input.add.length || input.rem.length || 
      on.field.some(function(f) { return !!input.fields[f]; })) {
    output.fields[this._output.key] = 1;
    output.fields[this._output.value] = 1;
  }
  return output;
};

module.exports = Fold;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],228:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    df = require('vega-dataflow'),
    Tuple = df.Tuple,
    ChangeSet = df.ChangeSet,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Force(graph) {
  Transform.prototype.init.call(this, graph);

  this._prev = null;
  this._interactive = false;
  this._setup = true;
  this._nodes  = [];
  this._links = [];
  this._layout = d3.layout.force();

  Transform.addParameters(this, {
    size: {type: 'array<value>', default: [500, 500]},
    bound: {type: 'value', default: true},
    links: {type: 'data'},

    // TODO: for now force these to be value params only (pun-intended)
    // Can update to include fields after Parameter refactoring.
    linkStrength: {type: 'value', default: 1},
    linkDistance: {type: 'value', default: 20},
    charge: {type: 'value', default: -30},

    chargeDistance: {type: 'value', default: Infinity},
    friction: {type: 'value', default: 0.9},
    theta: {type: 'value', default: 0.8},
    gravity: {type: 'value', default: 0.1},
    alpha: {type: 'value', default: 0.1},
    iterations: {type: 'value', default: 500},

    interactive: {type: 'value', default: this._interactive},    
    active: {type: 'value', default: this._prev},
    fixed: {type: 'data'}
  });

  this._output = {
    'x': 'layout_x',
    'y': 'layout_y'
  };

  return this.mutates(true);
}

var prototype = (Force.prototype = Object.create(Transform.prototype));
prototype.constructor = Force;

prototype.transform = function(nodeInput, reset) {
  log.debug(nodeInput, ['force']);
  reset = reset - (nodeInput.signals.active ? 1 : 0);

  // get variables
  var interactive = this.param('interactive'),
      linkSource = this.param('links').source,
      linkInput = linkSource.last(),
      active = this.param('active'),
      output = this._output,
      layout = this._layout,
      nodes = this._nodes,
      links = this._links;

  // configure nodes, links and layout
  if (linkInput.stamp < nodeInput.stamp) linkInput = null;
  this.configure(nodeInput, linkInput, interactive, reset);
  
  // run batch layout
  if (!interactive) {
    var iterations = this.param('iterations');
    for (var i=0; i<iterations; ++i) layout.tick();
    layout.stop();
  }

  // update node positions
  this.update(active);

  // re-up alpha on parameter change
  if (reset || active !== this._prev && active && active.update) {
    layout.alpha(this.param('alpha')); // re-start layout
  }

  // update active node status, 
  if (active !== this._prev) {
    this._prev = active;
  }

  // process removed nodes or edges
  if (nodeInput.rem.length) {
    layout.nodes(this._nodes = Tuple.idFilter(nodes, nodeInput.rem));
  }
  if (linkInput && linkInput.rem.length) {
    layout.links(this._links = Tuple.idFilter(links, linkInput.rem));
  }

  // return changeset
  nodeInput.fields[output.x] = 1;
  nodeInput.fields[output.y] = 1;
  return nodeInput;
};

prototype.configure = function(nodeInput, linkInput, interactive, reset) {
  // check if we need to run configuration
  var layout = this._layout,
      update = this._setup || nodeInput.add.length ||
            linkInput && linkInput.add.length ||
            interactive !== this._interactive ||
            this.param('charge') !== layout.charge() ||
            this.param('linkStrength') !== layout.linkStrength() ||
            this.param('linkDistance') !== layout.linkDistance();

  if (update || reset) {
    // a parameter changed, so update tick-only parameters
    layout
      .size(this.param('size'))
      .chargeDistance(this.param('chargeDistance'))
      .theta(this.param('theta'))
      .gravity(this.param('gravity'))
      .friction(this.param('friction'));
  }

  if (!update) return; // if no more updates needed, return now

  this._setup = false;
  this._interactive = interactive;

  var force = this,
      graph = this._graph,
      nodes = this._nodes,
      links = this._links, a, i;

  // process added nodes
  for (a=nodeInput.add, i=0; i<a.length; ++i) {
    nodes.push({tuple: a[i]});
  }

  // process added edges
  if (linkInput) for (a=linkInput.add, i=0; i<a.length; ++i) {
    // TODO add configurable source/target accessors
    // TODO support lookup by node id
    // TODO process 'mod' of edge source or target?
    links.push({
      tuple:  a[i],
      source: nodes[a[i].source],
      target: nodes[a[i].target]
    });
  }

  // setup handler for force layout tick events
  var tickHandler = !interactive ? null : function() {
    // re-schedule the transform, force reflow
    graph.propagate(ChangeSet.create(null, true), force);
  };

  // configure the rest of the layout
  layout
    .linkStrength(this.param('linkStrength'))
    .linkDistance(this.param('linkDistance'))
    .charge(this.param('charge'))
    .nodes(nodes)
    .links(links)
    .on('tick', tickHandler)
    .start().alpha(this.param('alpha'));
};

prototype.update = function(active) {
  var output = this._output,
      bound = this.param('bound'),
      fixed = this.param('fixed'),
      size = this.param('size'),
      nodes = this._nodes,
      lut = {}, id, i, n, t, x, y;

  if (fixed && fixed.source) {
    // TODO: could cache and update as needed?
    fixed = fixed.source.values();
    for (i=0, n=fixed.length; i<n; ++i) {
      lut[fixed[i].id] = 1;
    }
  }

  for (i=0; i<nodes.length; ++i) {
    n = nodes[i];
    t = n.tuple;
    id = t._id;

    if (active && active.id === id) {
      n.fixed = 1;
      if (active.update) {
        n.x = n.px = active.x;
        n.y = n.py = active.y;
      }
    } else {
      n.fixed = lut[id] || 0;
    }

    x = bound ? Math.max(0, Math.min(n.x, size[0])) : n.x;
    y = bound ? Math.max(0, Math.min(n.y, size[1])) : n.y;
    Tuple.set(t, output.x, x);
    Tuple.set(t, output.y, y);
  }
};

module.exports = Force;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],229:[function(require,module,exports){
var df = require('vega-dataflow'),
    Tuple = df.Tuple,
    SIGNALS = df.Dependencies.SIGNALS,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Formula(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field: {type: 'value'},
    expr:  {type: 'expr'}
  });

  return this.mutates(true);
}

var prototype = (Formula.prototype = Object.create(Transform.prototype));
prototype.constructor = Formula;

prototype.transform = function(input) {
  log.debug(input, ['formulating']);

  var g = this._graph,
      field = this.param('field'),
      expr = this.param('expr'),
      signals = g.values(SIGNALS, this.dependency(SIGNALS));

  function set(x) {
    Tuple.set(x, field, expr(x, null, signals));
  }

  input.add.forEach(set);
  
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
  }

  input.fields[field] = 1;
  return input;
};

module.exports = Formula;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],230:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Geo(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, Geo.Parameters);
  Transform.addParameters(this, {
    lon: {type: 'field'},
    lat: {type: 'field'}
  });

  this._output = {
    'x': 'layout_x',
    'y': 'layout_y'
  };
  return this.mutates(true);
}

Geo.Parameters = {
  projection: {type: 'value', default: 'mercator'},
  center:     {type: 'array<value>'},
  translate:  {type: 'array<value>'},
  rotate:     {type: 'array<value>'},
  scale:      {type: 'value'},
  precision:  {type: 'value'},
  clipAngle:  {type: 'value'},
  clipExtent: {type: 'value'}
};

Geo.d3Projection = function() {
  var p = this.param('projection'),
      param = Geo.Parameters,
      proj, name, value;

  if (p !== this._mode) {
    this._mode = p;
    this._projection = d3.geo[p]();
  }
  proj = this._projection;

  for (name in param) {
    if (name === 'projection' || !proj[name]) continue;
    value = this.param(name);
    if (value === undefined || (dl.isArray(value) && value.length === 0)) {
      continue;
    }
    if (value !== proj[name]()) {
      proj[name](value);
    }
  }

  return proj;
};

var prototype = (Geo.prototype = Object.create(Transform.prototype));
prototype.constructor = Geo;

prototype.transform = function(input) {
  log.debug(input, ['geo']);

  var output = this._output,
      lon = this.param('lon').accessor,
      lat = this.param('lat').accessor,
      proj = Geo.d3Projection.call(this);

  function set(t) {
    var ll = [lon(t), lat(t)];
    var xy = proj(ll) || [null, null];
    Tuple.set(t, output.x, xy[0]);
    Tuple.set(t, output.y, xy[1]);
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.x] = 1;
  input.fields[output.y] = 1;
  return input;
};

module.exports = Geo;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],231:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Geo = require('./Geo'),
    Transform = require('./Transform');

function GeoPath(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, Geo.Parameters);
  Transform.addParameters(this, {
    field: {type: 'field', default: null},
  });

  this._output = {
    'path': 'layout_path'
  };
  return this.mutates(true);
}

var prototype = (GeoPath.prototype = Object.create(Transform.prototype));
prototype.constructor = GeoPath;

prototype.transform = function(input) {
  log.debug(input, ['geopath']);

  var output = this._output,
      geojson = this.param('field').accessor || dl.identity,
      proj = Geo.d3Projection.call(this),
      path = d3.geo.path().projection(proj);

  function set(t) {
    Tuple.set(t, output.path, path(geojson(t)));
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.path] = 1;
  return input;
};

module.exports = GeoPath;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Geo":230,"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],232:[function(require,module,exports){
var Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function LinkPath(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    sourceX:  {type: 'field', default: '_source.layout_x'},
    sourceY:  {type: 'field', default: '_source.layout_y'},
    targetX:  {type: 'field', default: '_target.layout_x'},
    targetY:  {type: 'field', default: '_target.layout_y'},
    tension:  {type: 'value', default: 0.2},
    shape:    {type: 'value', default: 'line'}
  });

  this._output = {'path': 'layout_path'};
  return this.mutates(true);
}

var prototype = (LinkPath.prototype = Object.create(Transform.prototype));
prototype.constructor = LinkPath;

function line(sx, sy, tx, ty) {
  return 'M' + sx + ',' + sy +
         'L' + tx + ',' + ty;
}

function curve(sx, sy, tx, ty, tension) {
  var dx = tx - sx,
      dy = ty - sy,
      ix = tension * (dx + dy),
      iy = tension * (dy - dx);
  return 'M' + sx + ',' + sy +
         'C' + (sx+ix) + ',' + (sy+iy) +
         ' ' + (tx+iy) + ',' + (ty-ix) +
         ' ' + tx + ',' + ty;
}

function diagonalX(sx, sy, tx, ty) {
  var m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy +
         'C' + m  + ',' + sy +
         ' ' + m  + ',' + ty +
         ' ' + tx + ',' + ty;
}

function diagonalY(sx, sy, tx, ty) {
  var m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy +
         'C' + sx + ',' + m +
         ' ' + tx + ',' + m +
         ' ' + tx + ',' + ty;
}

var shapes = {
  line:      line,
  curve:     curve,
  diagonal:  diagonalX,
  diagonalX: diagonalX,
  diagonalY: diagonalY
};

prototype.transform = function(input) {
  log.debug(input, ['linkpath']);

  var output = this._output,
      shape = shapes[this.param('shape')] || shapes.line,
      sourceX = this.param('sourceX').accessor,
      sourceY = this.param('sourceY').accessor,
      targetX = this.param('targetX').accessor,
      targetY = this.param('targetY').accessor,
      tension = this.param('tension');

  function set(t) {
    var path = shape(sourceX(t), sourceY(t), targetX(t), targetY(t), tension);
    Tuple.set(t, output.path, path);
  }

  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
    input.rem.forEach(set);
  }

  input.fields[output.path] = 1;
  return input;
};

module.exports = LinkPath;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],233:[function(require,module,exports){
var Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform');

function Lookup(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    on:      {type: 'data'},
    onKey:   {type: 'field', default: null},
    as:      {type: 'array<value>'},
    keys:    {type: 'array<field>', default: ['data']},
    default: {type: 'value'}
  });

  return this.mutates(true);
}

var prototype = (Lookup.prototype = Object.create(Transform.prototype));
prototype.constructor = Lookup;

prototype.transform = function(input, reset) {
  log.debug(input, ['lookup']);

  var on = this.param('on'),
      onLast = on.source.last(),
      onData = on.source.values(),
      onKey = this.param('onKey'),
      onF = onKey.field,
      keys = this.param('keys'),
      get = keys.accessor,
      as = this.param('as'),
      defaultValue = this.param('default'),
      lut = this._lut,
      i, v;

  // build lookup table on init, withKey modified, or tuple add/rem
  if (lut == null || this._on !== onF || onF && onLast.fields[onF] ||
      onLast.add.length || onLast.rem.length)
  {
    if (onF) { // build hash from withKey field
      onKey = onKey.accessor;
      for (lut={}, i=0; i<onData.length; ++i) {
        lut[onKey(v = onData[i])] = v;
      }
    } else { // otherwise, use index-based lookup
      lut = onData;
    }
    this._lut = lut;
    this._on = onF;
    reset = true;
  }

  function set(t) {
    for (var i=0; i<get.length; ++i) {
      var v = lut[get[i](t)] || defaultValue;
      Tuple.set(t, as[i], v);
    }
  }

  input.add.forEach(set);
  var run = keys.field.some(function(f) { return input.fields[f]; });
  if (run || reset) {
    input.mod.forEach(set);
    input.rem.forEach(set); 
  }

  as.forEach(function(k) { input.fields[k] = 1; });
  return input;
};

module.exports = Lookup;
},{"./Transform":238,"vega-dataflow":141,"vega-logging":147}],234:[function(require,module,exports){
var dl = require('datalib'),
    Deps = require('vega-dataflow').Dependencies,
    expr = require('../parse/expr');

var arrayType = /array/i,
    dataType  = /data/i,
    fieldType = /field/i,
    exprType  = /expr/i,
    valType   = /value/i;

function Parameter(name, type, transform) {
  this._name = name;
  this._type = type;
  this._transform = transform;

  // If parameter is defined w/signals, it must be resolved
  // on every pulse.
  this._value = [];
  this._accessors = [];
  this._resolution = false;
  this._signals = {};
}

var prototype = Parameter.prototype;

function get() {
  var isArray = arrayType.test(this._type),
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type);

  var val = isArray ? this._value : this._value[0],
      acc = isArray ? this._accessors : this._accessors[0];

  if (!dl.isValid(acc) && valType.test(this._type)) {
    return val;
  } else {
    return isData ? { name: val, source: acc } :
    isField ? { field: val, accessor: acc } : val;
  }
}

prototype.get = function() {
  var graph = this._transform._graph, 
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type),
      s, idx, val;

  // If we don't require resolution, return the value immediately.
  if (!this._resolution) return get.call(this);

  if (isData) {
    this._accessors = this._value.map(function(v) { return graph.data(v); });
    return get.call(this); // TODO: support signal as dataTypes
  }

  for (s in this._signals) {
    idx = this._signals[s];
    val = graph.signalRef(s);

    if (isField) {
      this._accessors[idx] = this._value[idx] != val ? 
        dl.accessor(val) : this._accessors[idx];
    }

    this._value[idx] = val;
  }

  return get.call(this);
};

prototype.set = function(value) {
  var p = this,
      isExpr = exprType.test(this._type),
      isData  = dataType.test(this._type),
      isField = fieldType.test(this._type);

  this._value = dl.array(value).map(function(v, i) {
    if (dl.isString(v)) {
      if (isExpr) {
        var e = expr(v);
        p._transform.dependency(Deps.FIELDS,  e.fields);
        p._transform.dependency(Deps.SIGNALS, e.globals);
        return e.fn;
      } else if (isField) {  // Backwards compatibility
        p._accessors[i] = dl.accessor(v);
        p._transform.dependency(Deps.FIELDS, dl.field(v));
      } else if (isData) {
        p._resolution = true;
        p._transform.dependency(Deps.DATA, v);
      }
      return v;
    } else if (v.value !== undefined) {
      return v.value;
    } else if (v.field !== undefined) {
      p._accessors[i] = dl.accessor(v.field);
      p._transform.dependency(Deps.FIELDS, dl.field(v.field));
      return v.field;
    } else if (v.signal !== undefined) {
      p._resolution = true;
      p._signals[v.signal] = i;
      p._transform.dependency(Deps.SIGNALS, v.signal);
      return v.signal;
    }

    return v;
  });

  return p._transform;
};

module.exports = Parameter;
},{"../parse/expr":197,"datalib":49,"vega-dataflow":141}],235:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Pie(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    field:      {type: 'field', default: null},
    startAngle: {type: 'value', default: 0},
    endAngle:   {type: 'value', default: 2 * Math.PI},
    sort:       {type: 'value', default: false}
  });

  this._output = {
    'start': 'layout_start',
    'end':   'layout_end',
    'mid':   'layout_mid'
  };

  return this.mutates(true);
}

var prototype = (Pie.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Pie;

function ones() { return 1; }

prototype.batchTransform = function(input, data) {
  log.debug(input, ['pie']);

  var output = this._output,
      field = this.param('field').accessor || ones,
      start = this.param('startAngle'),
      stop = this.param('endAngle'),
      sort = this.param('sort');

  var values = data.map(field),
      a = start,
      k = (stop - start) / dl.sum(values),
      index = dl.range(data.length),
      i, t, v;

  if (sort) {
    index.sort(function(a, b) {
      return values[a] - values[b];
    });
  }

  for (i=0; i<index.length; ++i) {
    t = data[index[i]];
    v = values[index[i]];
    Tuple.set(t, output.start, a);
    Tuple.set(t, output.mid, (a + 0.5 * v * k));
    Tuple.set(t, output.end, (a += v * k));
  }

  input.fields[output.start] = 1;
  input.fields[output.end] = 1;
  input.fields[output.mid] = 1;
  return input;
};

module.exports = Pie;
},{"./BatchTransform":220,"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],236:[function(require,module,exports){
var dl = require('datalib'),
    log  = require('vega-logging'),
    Transform = require('./Transform');

function Sort(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {by: {type: 'array<field>'} });
  this.router(true);
}

var prototype = (Sort.prototype = Object.create(Transform.prototype));
prototype.constructor = Sort;

prototype.transform = function(input) {
  log.debug(input, ['sorting']);

  if (input.add.length || input.mod.length || input.rem.length) {
    input.sort = dl.comparator(this.param('by').field);
  }
  return input;
};

module.exports = Sort;
},{"./Transform":238,"datalib":49,"vega-logging":147}],237:[function(require,module,exports){
var dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Stack(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    groupby: {type: 'array<field>'},
    sortby: {type: 'array<field>'},
    field: {type: 'field'},
    offset: {type: 'value', default: 'zero'}
  });

  this._output = {
    'start': 'layout_start',
    'end':   'layout_end',
    'mid':   'layout_mid'
  };
  return this.mutates(true);
}

var prototype = (Stack.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Stack;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['stacking']);

  var groupby = this.param('groupby').accessor,
      sortby = dl.comparator(this.param('sortby').field),
      field = this.param('field').accessor,
      offset = this.param('offset'),
      output = this._output;

  // partition, sum, and sort the stack groups
  var groups = partition(data, groupby, sortby, field);

  // compute stack layouts per group
  for (var i=0, max=groups.max; i<groups.length; ++i) {
    var group = groups[i],
        sum = group.sum,
        off = offset==='center' ? (max - sum)/2 : 0,
        scale = offset==='normalize' ? (1/sum) : 1,
        j, x, a, b = off, v = 0;

    // set stack coordinates for each datum in group
    for (j=0; j<group.length; ++j) {
      x = group[j];
      a = b; // use previous value for start point
      v += field(x);
      b = scale * v + off; // compute end point
      Tuple.set(x, output.start, a);
      Tuple.set(x, output.end, b);
      Tuple.set(x, output.mid, 0.5 * (a + b));
    }
  }

  input.fields[output.start] = 1;
  input.fields[output.end] = 1;
  input.fields[output.mid] = 1;
  return input;
};

function partition(data, groupby, sortby, field) {
  var groups = [],
      get = function(f) { return f(x); },
      map, i, x, k, g, s, max;

  // partition data points into stack groups
  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map={}, i=0; i<data.length; ++i) {
      x = data[i];
      k = groupby.map(get);
      g = map[k] || (groups.push(map[k] = []), map[k]);
      g.push(x);
    }
  }

  // compute sums of groups, sort groups as needed
  for (k=0, max=0; k<groups.length; ++k) {
    g = groups[k];
    for (i=0, s=0; i<g.length; ++i) {
      s += field(g[i]);
    }
    g.sum = s;
    if (s > max) max = s;
    if (sortby != null) g.sort(sortby);
  }
  groups.max = max;

  return groups;
}

module.exports = Stack;
},{"./BatchTransform":220,"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],238:[function(require,module,exports){
var df = require('vega-dataflow'),
    Base = df.Node.prototype, // jshint ignore:line
    Deps = df.Dependencies,
    Parameter = require('./Parameter');

function Transform(graph) {
  if (graph) Base.init.call(this, graph);
}

Transform.addParameters = function(proto, params) {
  proto._parameters = proto._parameters || {};
  for (var name in params) {
    var p = params[name],
        param = new Parameter(name, p.type, proto);

    proto._parameters[name] = param;

    if (p.type === 'custom') {
      if (p.set) param.set = p.set.bind(param);
      if (p.get) param.get = p.get.bind(param);
    }

    if (p.hasOwnProperty('default')) param.set(p.default);
  }
};

var prototype = (Transform.prototype = Object.create(Base));
prototype.constructor = Transform;

prototype.param = function(name, value) {
  var param = this._parameters[name];
  return (param === undefined) ? this :
    (arguments.length === 1) ? param.get() : param.set(value);
};

// Perform transformation. Subclasses should override.
prototype.transform = function(input/*, reset */) {
  return input;
};

prototype.evaluate = function(input) {
  // Many transforms store caches that must be invalidated if
  // a signal value has changed. 
  var reset = this._stamp < input.stamp &&
    this.dependency(Deps.SIGNALS).reduce(function(c, s) {
      return c += input.signals[s] ? 1 : 0;
    }, 0);
  return this.transform(input, reset);
};

prototype.output = function(map) {
  for (var key in this._output) {
    if (map[key] !== undefined) {
      this._output[key] = map[key];
    }
  }
  return this;
};

module.exports = Transform;
},{"./Parameter":234,"vega-dataflow":141}],239:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    dl = require('datalib'),
    Tuple = require('vega-dataflow').Tuple,
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

var defaultRatio = 0.5 * (1 + Math.sqrt(5));

function Treemap(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    // hierarchy parameters
    sort: {type: 'array<field>', default: ['-value']},
    children: {type: 'field', default: 'children'},
    field: {type: 'field', default: 'value'},
    // treemap parameters
    size: {type: 'array<value>', default: [500, 500]},
    round: {type: 'value', default: true},
    sticky: {type: 'value', default: false},
    ratio: {type: 'value', default: defaultRatio},
    padding: {type: 'value', default: null},
    mode: {type: 'value', default: 'squarify'}
  });

  this._layout = d3.layout.treemap();

  this._output = {
    'x':      'layout_x',
    'y':      'layout_y',
    'width':  'layout_width',
    'height': 'layout_height',
    'depth':  'layout_depth',
  };
  return this.mutates(true);
}

var prototype = (Treemap.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Treemap;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['treemap']);

  // get variables
  var layout = this._layout,
      output = this._output;

  // configure layout
  layout
    .sort(dl.comparator(this.param('sort').field))
    .children(this.param('children').accessor)
    .value(this.param('field').accessor)
    .size(this.param('size'))
    .round(this.param('round'))
    .sticky(this.param('sticky'))
    .ratio(this.param('ratio'))
    .padding(this.param('padding'))
    .mode(this.param('mode'))
    .nodes(data[0]);

  // copy layout values to nodes
  data.forEach(function(n) {
    Tuple.set(n, output.x, n.x);
    Tuple.set(n, output.y, n.y);
    Tuple.set(n, output.width, n.dx);
    Tuple.set(n, output.height, n.dy);
    Tuple.set(n, output.depth, n.depth);
  });

  // return changeset
  input.fields[output.x] = 1;
  input.fields[output.y] = 1;
  input.fields[output.width] = 1;
  input.fields[output.height] = 1;
  return input;
};

module.exports = Treemap;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":220,"./Transform":238,"datalib":49,"vega-dataflow":141,"vega-logging":147}],240:[function(require,module,exports){
(function (global){
var d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    Tuple = require('vega-dataflow/src/Tuple'),
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Voronoi(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    clipExtent: {type: 'array<value>', default: [[-1e5,-1e5],[1e5,1e5]]},
    x: {type: 'field', default: 'layout_x'},
    y: {type: 'field', default: 'layout_y'}
  });

  this._layout = d3.geom.voronoi();
  this._output = {'path': 'layout_path'};

  return this.mutates(true);
}

var prototype = (Voronoi.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Voronoi;

prototype.batchTransform = function(input, data) {
  log.debug(input, ['voronoi']);

  // get variables
  var pathname = this._output.path;

  // configure layout
  var polygons = this._layout
    .clipExtent(this.param('clipExtent'))
    .x(this.param('x').accessor)
    .y(this.param('y').accessor)
    (data);

  // build and assign path strings
  for (var i=0; i<data.length; ++i) {
    Tuple.set(data[i], pathname, 'M' + polygons[i].join('L') + 'Z');
  }

  // return changeset
  input.fields[pathname] = 1;
  return input;
};

module.exports = Voronoi;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":220,"./Transform":238,"vega-dataflow/src/Tuple":140,"vega-logging":147}],241:[function(require,module,exports){
(function (global){
var dl = require('datalib'),
    d3 = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null),
    d3_cloud = (typeof window !== "undefined" ? window['d3']['layout']['cloud'] : typeof global !== "undefined" ? global['d3']['layout']['cloud'] : null),
    Tuple = require('vega-dataflow/src/Tuple'),
    log = require('vega-logging'),
    Transform = require('./Transform'),
    BatchTransform = require('./BatchTransform');

function Wordcloud(graph) {
  BatchTransform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    size: {type: 'array<value>', default: [900, 500]},
    text: {type: 'field', default: 'data'},
    rotate: {type: 'field|value', default: 0},
    font: {type: 'field|value', default: {value: 'sans-serif'}},
    fontSize: {type: 'field|value', default: 14},
    fontStyle: {type: 'field|value', default: {value: 'normal'}},
    fontWeight: {type: 'field|value', default: {value: 'normal'}},
    fontScale: {type: 'array<value>', default: [10, 50]},
    padding: {type: 'value', default: 1},
    spiral: {type: 'value', default: 'archimedean'}
  });

  this._layout = d3_cloud();

  this._output = {
    'x':          'layout_x',
    'y':          'layout_y',
    'font':       'layout_font',
    'fontSize':   'layout_fontSize',
    'fontStyle':  'layout_fontStyle',
    'fontWeight': 'layout_fontWeight',
    'rotate':     'layout_rotate',
  };

  return this.mutates(true);
}

var prototype = (Wordcloud.prototype = Object.create(BatchTransform.prototype));
prototype.constructor = Wordcloud;

function get(p) {
  return (p && p.accessor) || p;
}

function wrap(tuple) {
  var x = Object.create(tuple);
  x._tuple = tuple;
  return x;
}

prototype.batchTransform = function(input, data) {
  log.debug(input, ['wordcloud']);

  // get variables
  var layout = this._layout,
      output = this._output,
      fontSize = this.param('fontSize'),
      range = fontSize.accessor && this.param('fontScale'),
      size, scale;
  fontSize = fontSize.accessor || d3.functor(fontSize);
  
  // create font size scaling function as needed
  if (range.length) {
    scale = d3.scale.sqrt()
      .domain(dl.extent(data, size=fontSize))
      .range(range);
    fontSize = function(x) { return scale(size(x)); };
  }

  // configure layout
  layout
    .size(this.param('size'))
    .text(get(this.param('text')))
    .padding(this.param('padding'))
    .spiral(this.param('spiral'))
    .rotate(get(this.param('rotate')))
    .font(get(this.param('font')))
    .fontStyle(get(this.param('fontStyle')))
    .fontWeight(get(this.param('fontWeight')))
    .fontSize(fontSize)
    .words(data.map(wrap)) // wrap to avoid tuple writes
    .on('end', function(words) {
      var size = layout.size(),
          dx = size[0] >> 1,
          dy = size[1] >> 1,
          w, t, i, len;

      for (i=0, len=words.length; i<len; ++i) {
        w = words[i];
        t = w._tuple;
        Tuple.set(t, output.x, w.x + dx);
        Tuple.set(t, output.y, w.y + dy);
        Tuple.set(t, output.font, w.font);
        Tuple.set(t, output.fontSize, w.size);
        Tuple.set(t, output.fontStyle, w.style);
        Tuple.set(t, output.fontWeight, w.weight);
        Tuple.set(t, output.rotate, w.rotate);
      }
    })
    .start();

  // return changeset
  for (var key in output) input.fields[output[key]] = 1;
  return input;
};

module.exports = Wordcloud;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./BatchTransform":220,"./Transform":238,"datalib":49,"vega-dataflow/src/Tuple":140,"vega-logging":147}],242:[function(require,module,exports){
module.exports = {
  aggregate:    require('./Aggregate'),
  bin:          require('./Bin'),
  cross:        require('./Cross'),
  countpattern: require('./CountPattern'),
  linkpath:     require('./LinkPath'),
  facet:        require('./Facet'),
  filter:       require('./Filter'),
  fold:         require('./Fold'),
  force:        require('./Force'),
  formula:      require('./Formula'),
  geo:          require('./Geo'),
  geopath:      require('./GeoPath'),
  lookup:       require('./Lookup'),
  pie:          require('./Pie'),
  sort:         require('./Sort'),
  stack:        require('./Stack'),
  treemap:      require('./Treemap'),
  voronoi:      require('./Voronoi'),
  wordcloud:    require('./Wordcloud')
};
},{"./Aggregate":219,"./Bin":221,"./CountPattern":222,"./Cross":223,"./Facet":224,"./Filter":226,"./Fold":227,"./Force":228,"./Formula":229,"./Geo":230,"./GeoPath":231,"./LinkPath":232,"./Lookup":233,"./Pie":235,"./Sort":236,"./Stack":237,"./Treemap":239,"./Voronoi":240,"./Wordcloud":241}],243:[function(require,module,exports){
/* This module defines and exposes JS pseudo-classes to support a complex view
 * model for editing illustrations.
 */

var utils = require('./ti-utils.js'),
    stylist = require('./stylist.js');

//global.stylist = stylist;

var TreeIllustrator = function(window, document, $, ko, stylist) {

    // Explicitly check for dependencies by passing them as args to the module
    if (typeof($) !== 'function') {
        alert("TreeIllustrator module cancelled, needs jQuery (as '$')");
        return null;
    }
    if (!ko || typeof(ko) !== 'object') {
        alert("TreeIllustrator module cancelled, needs KnockoutJS (as 'ko')");
        return null;
    }
    if (!stylist || typeof(stylist) !== 'object') {
        alert("TreeIllustrator module cancelled, needs 'stylist' module (as 'stylist')");
        return null;
    }

    // define some simple enumerations (for legibility, and to avoid typos)
    var units = {
        INCHES: 'INCHES',
        CENTIMETERS: 'CENTIMETERS'
    };
    var colorDepths = {
        FULL_COLOR: 'FULL_COLOR',
        GRAYSCALE: 'GRAYSCALE',
        BLACK_AND_WHITE: 'BLACK_AND_WHITE'
    };
    var treeLayouts = {
        RECTANGLE: 'RECTANGLE',
        CIRCLE: 'CIRCLE',
        TRIANGLE: 'TRIANGLE'
    };
    var branchRotationMethods = {
        UNCHANGED: 'UNCHANGED',  // preserve the original sibling order
        ALPHABETICAL: 'ALPHABETICAL',  // also used as a tie-breaker for all methods
        LADDERIZE_RIGHT: 'LADDERIZE_RIGHT',
        LADDERIZE_LEFT: 'LADDERIZE_LEFT',
        ZIG_ZAG: 'ZIG_ZAG'
    };
    var alignments = {
        TOP: 'TOP',
        RIGHT: 'RIGHT',
        BOTTOM: 'BOTTOM',
        LEFT: 'LEFT',
        CENTER: 'CENTER'
    };
    var sweepDirections = {
        CLOCKWISE: 'CLOCKWISE',
        COUNTERCLOCKWISE: 'COUNTERCLOCKWISE'
    };
    var dataSourceTypes = {
        BUILT_IN: 'BUILT_IN',
        URL: 'URL',
        UPLOAD: 'UPLOAD'
    };
    var versionTypes = {
        CHECKSUM: 'CHECKSUM',   // e.g., a git SHA
        TIMESTAMP: 'TIMESTAMP', // e.g., a modification date
        SEMANTIC: 'SEMANTIC'    // a conventional version number, e.g., "3.2.0a"
    };
    var hostApplications = {
        JUPYTER_NOTEBOOK: 'JUPYTER_NOTEBOOK',    // a.k.a. IPython notebook
        //TODO: ARBOR_WORKFLOW: 'ARBOR_WORKFLOW' 
        //TODO: OPENTREE_TOOLS: 'OPENTREE_TOOLS'
        STANDALONE: 'STANDALONE'                 // "naked" stylist, perhaps from a static file
    };
    var storageBackends = {
        LOCAL_FILESYSTEM: 'LOCAL_FILESYSTEM',
        JUPYTER_NOTEBOOK: 'JUPYTER_NOTEBOOK',    // JSON storage in an IPython-style notebook file
        GITHUB_REPO: 'GITHUB_REPO'               // in our designated (public) repo
    }

    /* Here we can share information among all classes and instances */

    /* Cache data to improve performance or reduce network traffic: 
     *   - tree source loaded via AJAX
     *   - intermediate tree data (after one or more transforms)
     *   - supporting datasets
     *   - etc.
     * Note that initial use is by the 'stash' transform below.
     */
    var cache = { };
    var setCachedData = function(key, value, flush) {
        // add (or update) the cache for this key
        // N.B. we'll ignore the 'flush' boolean here, in favor of a checksum.
        cache[key] = value;
    }
    var getCachedData = function(key) {
        // retrieve this key's cache from the cache (or return null)
        return (key in cache) ? cache[key] : null;
    };
    var clearCachedData = function(key, options) {
        // clobber the data for this key, and possibly its dependents
        delete cache[key];
        if (options.DELETE_DEPENDENT_ITEMS) {  // TODO
            var dependents = $.filter(cache, function(cachePath, itemInfo) {
                return ($.inArray(key, itemInfo.dependencies) !== -1);
            });
            $.each(dependents, function(cachePath, itemInfo) {
                // ... and clobber *their* dependents in turn
                clearCachedData(cachePath, {DELETE_DEPENDENT_ITEMS: true}); 
            });
        }
    };
    var flushCache = function( newCacheData ) {
        // clear all keys and entries; replace with new data if found
        cache = { };
        exports.cache = cache;  // else it lags
        if (typeof newCacheData === 'object') {
            for (var key in newCacheData) {
                // Transfer each property in turn, just in case there's
                // internal housekeeping to do (checksums, timestamps, etc.)
                setCachedData( key, newCacheData[key] );
            }
        }
    };

    /* Gather various subsets (or all) of cached data in a temp object. */
    function gatherAllCachedData() {
        return $.extend({}, cache);
    }
    function gatherAllInputData() {
        // ie, everything cached under paths starting 'input/'
        return $.map(cache, function(itemInfo, cachePath) {
            if( cachePath.match(/^input\/.*/) ) {
                return { path: cachePath, value: itemInfo };
            }
            return null;
        });

        // MOOT
        var filtered = {};
        $.each(cache, function(cachePath, itemInfo) {
            if( cachePath.match(/^input\/.*/) ) {
                filtered[ cachePath ] = itemInfo;
            }
        });
        return filtered;
    }
    function gatherStaticInputData() {
        // ie, everything cached under paths starting 'input/' AND with no
        // clear provenance
        var filtered = {};
        $.each(cache, function(cachePath, itemInfo) {
            if(cachePath.match(/^input\/.*/) &&
               itemInfo.src === '') {
                filtered[ cachePath ] = itemInfo;
            }
        });
        return filtered;
    }
    function gatherAllTransformData() {
        // ie, everything cached under paths starting 'transform/'
        var filtered = {};
        $.each(cache, function(cachePath, itemInfo) {
            if( cachePath.match(/^transform\/.*/) ) {
                filtered[ cachePath ] = itemInfo;
            }
        });
        return filtered;
    }
    function gatherAllOutputData() {
        // ie, everything cached under paths starting 'output/'
        var filtered = {};
        $.each(cache, function(cachePath, itemInfo) {
            if( cachePath.match(/^output\/.*/) ) {
                filtered[ cachePath ] = itemInfo;
            }
        });
        return filtered;
    }

    /* Return the data model for a new illustration (our JSON representation) */
    var getNewIllustrationModel = function(options) {
        if (!options) options = {};
        var obj = {
            'metadata': {
                'name': "Untitled illustration",
                'url': "",  // source URL on GitHub (GitHub storage only)
                'sha': "",  // latest SHA on GitHub (GitHub storage only)
                'description': "",
                'authors': [ ],   // assign immediately to this user?
                'tags': [ ],
                'dois': [ ],
                'FOOFOO': "BARBAR",
                'date_created': new Date().toISOString()
            },
            'styleGuide': {
                // maybe the defaults here are "anything goes" (all options enabled)?
                // TODO: Explicitly list all options somewhere else? 
                // TODO: Filter styles if they fall out of conformance?
                'name': "Default styles",
                'description': "Style guides are used to suggest and constrain the overall look of your illustration for a particular publication or context. You can try different styles using the <strong>Load styles...</strong> button.", // captured when assigned
                'source': {'type': dataSourceTypes.BUILT_IN, 'value': "DEFAULT"},
                'version': {'type': versionTypes.SEMANTIC, 'value': "0.1"},
                'constraints': {
                    // list constrained labels and values, if any (items not listed are unconstrained)
                    'printSizes': [
                        {
                            'name': "Letter size (portrait)",
                            'width': 8.5, 
                            'height': 11, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Letter size (landscape)",
                            'width': 11, 
                            'height': 8.5, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Quarter-page (portrait)",
                            'width': 4.25, 
                            'height': 5.5, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Quarter-page (landscape)",
                            'width': 5.5, 
                            'height': 4.25, 
                            'units': units.INCHES 
                        },
                        {
                            'name': "Custom size"
                        }
                    ],
                    'fontFamilies': [
                        {
                            'name': "Times New Roman",
                            'value': "Times New Roman, Times, serif"
                        },
                        {
                            'name': "Helvetica",
                            'value': "Helvetica, Arial, sans"
                        },
                        {
                            'name': "Arial",
                            'value': "Arial, sans"
                        },
                        {
                            'name': "Something else"
                        }
                    ],
                    'colorDepths': [
                        {
                            'name': "Full color",
                            'value': colorDepths.FULL_COLOR
                        },
                        {
                            'name': "Grayscale",
                            'value': colorDepths.GRAYSCALE
                        },
                        {
                            'name': "Black and white (no gray)",
                            'value': colorDepths.BLACK_AND_WHITE
                        }
                    ],
                    'minimumTextSize': 12,  
                        // specified in pt, but echoed using physical units above
                    'minimumLineThickness': 2,  
                        // specified in pt, but echoed using physical units above
                    'backgroundColor': "#fdd",
                    'border': "none",
                    // add default line color, thickness, node shape/size, etc.
                    'edgeColor': "#777",
                    'edgeThickness': 0.8,
                    'nodeColor': "#339",
                    'nodeShape': 'circle'  // TODO: should be an enumerated  value
                }
            },
            'style': {
                // choices and overrides from the style guide above
                'printSize': {
                    'units': units.INCHES,  // OR units.CENTIMETERS
                    'width': 8.5,  // in physical units
                    'height': 11,   // in physical units
                },
                'fontFamily': "Times New Roman, Times, serif",
                'backgroundColor': "#fdd",
                'border': "none",
                // add default line color, thickness, node shape/size, etc.
                'edgeColor': "#777",
                'edgeThickness': 0.8,
                'nodeColor': "#339",
                'nodeShape': 'circle'  // TODO: should be an enumerated  value
            },
            'elements': [
            ],
            'vegaSpec': {
                'width': 800,
                'height': 900,
                'padding': {
                    'top': 0,
                    'left': 0,
                    'bottom': 0,
                    'right': 0
                },
                'data': [ ],
                'style': { }
            }
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new tree (our JSON representation) */
    var getNewIllustratedTreeModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('tree'); 
        var landmarks = stylist.getPrintAreaLandmarks();
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'IllustratedTree',
                'name': "Untitled ("+ newID +")",
                'source': {
                    'type': dataSourceTypes.BUILT_IN, 
                    'value': './placeholder-tree.json',
                    'phylesystemStudyID': '',
                    'phylesystemTreeID': ''
                },
                'description': "",
                'dois': [ ]
            },
            'data': { },
            'layout': treeLayouts.CIRCLE,
            /* Overload the model with all layout properties. We'll use the
             * ones that current apply *and* retain last-known values for
             * others, in case the user switches back to a prior layout
             */
            'branchRotation': branchRotationMethods.UNCHANGED,
            'width': landmarks.width * 0.4,
            'height': landmarks.height * 0.4,
            'radius': Math.min(landmarks.height, landmarks.width) * 0.3,
            'radialArc': [0, 350],
            'radialSweep': sweepDirections.CLOCKWISE,
            'tipsAlignment': alignments.RIGHT,
            'rootX': landmarks.centerX + utils.jiggle(5),   // TODO: use a bounding box instead?
            'rootY': landmarks.centerY + utils.jiggle(5),
            'nodeLabelField': 'ottTaxonName',         // matches the placeholder tree
            'style': {
                // incl. only deviations from the style guide above?
/*
                'edgeThickness': 1.0,  
                'edgeColor': '#999',
                'labelTextHeight': illustration.styleGuide.constraints.minimumTextSize()
*/
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new dataset (our JSON representation) */
    var getNewSupportingDatasetModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('dataset'); 
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'SupportingDataset',
                'name': "Untitled ("+ newID +")",
                'description': "",
                'dois': [ ]
            },
            'data': { },
            'style': {
                // incl. only deviations from the style guide above?
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Return the data model for a new ornament (our JSON representation) */
    var getNewOrnamentModel = function(illustration, options) {
        if (!options) options = {};
        var newID = illustration.getNextAvailableID('ornament'); 
        var obj = {
            'id': newID,
            'metadata': {
                'type': 'Ornament',
                'name': "Untitled ("+ newID +")",
                'description': ""
            },
            'data': { },
            'style': {
                // incl. only deviations from the style guide above?
            },
        };
        /* TODO: Apply optional modifications?
        if (options.BLAH) {
            obj.metadata.FOO = 'BAR';
        }
        */
        return obj;
    };

    /* Our principle view model [1] is a single illustration. This uses basic
     * Knockout observables as members, but adds custom behavior. We'll use a
     * family of pseudo-classes to define the main illustration and selected parts.
     *
     * [1] http://knockoutjs.com/documentation/observables.html
     */
    var Illustration = function(data) {
        if ( !(this instanceof Illustration) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new Illustration(data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" illustration object above
            data = getNewIllustrationModel();
        }

        // safely refer to this instance
        var self = this;

        /* define PRIVATE members (variables and methods)functions and with 'var' */

        /* We'll need to mint a unique, serial ID for each new illustration
         * element. Since we have a reasonable number of elements, we can
         * set the initial values for an illustration as it loads, by scanning
         * the existing elements of each type.
         */
        var nextAvailableID = {
            'tree': 0,
            'dataset': 0,
            'ornament': 0
        };
        // Each element nickname above is used in IDs, eg. 'tree-32'
        var initSerialElementIDs = function() {
            for (var aType in nextAvailableID) {
                nextAvailableID[ aType ] = 0;
            }
            var highestTreeIDFound = 0;
            var highestDatasetIDFound = 0;
            var highestOrnamentIDFound = 0;

            $.each(self.elements(), function(i, el) {
                var parts = el.id().split('-');
                var elementType = parts[0];
                var itsSerialID = parseInt(parts[1], 10);
                nextAvailableID[ elementType ] = Math.max( 
                    itsSerialID,
                    nextAvailableID[ elementType ] 
                );
            });
        }


        /* define PUBLIC variables (and privileged methods) with 'self' */

        self.getElementByID = function( elementID ) {
            // return an element (eg, an IllustratedTree), or null if not found
            var foundElement = null;
            $.each(self.elements(), function(i, el) {
                if (el.id() === elementID) {
                    foundElement = el;
                    return false;
                }
            });
            return foundElement;
        }

        self.getNextAvailableID = function( elementType ) {
            // creates a serial ID like 'dataset-4' or 'tree-12'
            var readyID = nextAvailableID[ elementType ];
            nextAvailableID[ elementType ] = readyID + 1;
            return (elementType +'-'+ nextAvailableID[ elementType ]);
        } 

        // REMINDER: computed observables should use 'deferEvaluation' in
        // case their dependencies will appear during ko.mapping
        self.styleGuideSourceHTML = ko.computed(function () {
            switch(self.styleGuide.source.type()) {
                case dataSourceTypes.URL:
                    var itsURL = self.styleGuide.source.value();
                    return '<a href='+ itsURL +' target="_blank">'+ itsURL +'</a>';
                case dataSourceTypes.BUILT_IN:
                    return "Built-in";
            }
            return "Undefined"; 
        }, self, {deferEvaluation:true});

        self.useChosenPrintSize = function() {
            var sizeName = $('#style-docsize-chooser').val();
            var selectedSize = getPrintSizeByName( sizeName );
            if (!selectedSize) {
                console.warn('useChosenPrintSize(): no matching size found!');
                return;
            }
            if (selectedSize.units) {
                // Custom size should retain current settings
                self.style.printSize.width( selectedSize.width() );
                self.style.printSize.height( selectedSize.height() );
                self.style.printSize.units( selectedSize.units() );
            }

            // update visible canvas and d3 viz
            stylist.refreshViz();
        };
        self.updatePrintSizeChooser = function() {
            // (de)select matching size after manual adjustments
            var matchingSize = $.grep(
                self.styleGuide.constraints.printSizes(), 
                function(o) {
                    if (!('units' in o)) return false; // 'Custom size' never matches
                    // NOTE use of != instead of !== below, because "11" == 11
                    if (o.units() != self.style.printSize.units()) return false;
                    if (o.width() != self.style.printSize.width()) return false;
                    if (o.height() != self.style.printSize.height()) return false;
                    return true;
                }
            )[0];
            var matchingSizeName = 'Custom size';
            if (matchingSize) {
                matchingSizeName = matchingSize.name();
            }
            $('#style-docsize-chooser').val(matchingSizeName);

            // update visible canvas and d3 viz
            stylist.refreshViz();
        };
        var getPrintSizeByName = function( name ) {
            var matchingSize = $.grep(
                self.styleGuide.constraints.printSizes(), function(o) {
                    return o.name() === name;
                }
            )[0];
            if (typeof matchingSize === 'undefined') {
                console.warn('getPrintSizeByname(): no such size as "'+ name +'"!');
            }
            return matchingSize;
        }
        self.unitsFullName = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "inches"
                case units.CENTIMETERS:
                    return "centimeters";
            }
        }, self, {deferEvaluation:true});
        self.unitsDisplayAbbreviation = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "in."
                case units.CENTIMETERS:
                    return "cm";
            }
        }, self, {deferEvaluation:true});
        self.unitsCssSuffix = ko.computed(function() {
            switch( self.style.printSize.units() ) {
                case units.INCHES:
                    return "in"
                case units.CENTIMETERS:
                    return "cm";
            }
        }, self, {deferEvaluation:true});

        self.useChosenFontFamily = function() {
            var fontName = $('#style-fontfamily-chooser').val();
            var selectedFont = getFontFamilyByName( fontName );
            if (!selectedFont) {
                console.warn('useChosenFontFamily(): no matching font found!');
                return;
            }
            if (selectedFont.value) {
                // Custom size should retain current settings
                self.style.fontFamily( selectedFont.value() );
            }
            if (fontName === 'Something else') {
                $('#style-fontfamily-options').show();
            } else {
                $('#style-fontfamily-options').hide();
            }
        };
        self.updateFontFamilyChooser = function() {
            // (de)select matching font after manual adjustments
            var matchingFont = $.grep(
                self.styleGuide.constraints.fontFamilies(), 
                function(o) {
                    if (!('value' in o)) return false; // 'Something else' never matches
                    if (o.value() !== self.style.fontFamily()) return false;
                    return true;
                }
            )[0];
            var matchingFontName = 'Something else';
            if (matchingFont) {
                matchingFontName = matchingFont.name();
                $('#style-fontfamily-options').hide();
            } else {
                $('#style-fontfamily-options').show();
            }
            $('#style-fontfamily-chooser').val(matchingFontName);
        };
        var getFontFamilyByName = function( name ) {
            var matchingFont = $.grep(
                self.styleGuide.constraints.fontFamilies(), function(o) {
                    return o.name() === name;
                }
            )[0];
            if (typeof matchingFont === 'undefined') {
                console.warn('getFontFamilyByname(): no such font as "'+ name +'"!');
            }
            return matchingFont;
        }

        self.minTextSizeHelper = ko.computed(function() {
            // explain this size in chosen units
            var html;
            var chosenSize = self.styleGuide.constraints.minimumTextSize();
            if (isNaN(chosenSize) || $.trim(chosenSize) === '') {
                // rejects any non-numeric chars, allows whitespace and decimal
                html = '<em>This value must be a number</em>';
            } else {
                // echo the new size (in pt) as inches/cm
                chosenSize = parseFloat(chosenSize);
                var convertedSize = self.style.printSize.units() === units.INCHES ?
                    stylist.pointsToInches( chosenSize ) :
                    stylist.pointsToCentimeters( chosenSize );
                convertedSize = convertedSize.toFixed(2);
                var unitSuffix = self.style.printSize.units() === units.INCHES ?
                    'inches' : 'cm';
                html = 'pt &nbsp;('+ convertedSize +' '+ unitSuffix +')';
            }
            return html;
        }, self, {deferEvaluation:true});

        self.minLineThicknessHelper = ko.computed(function() {
            // explain this size in chosen units
            var html;
            var chosenSize = self.styleGuide.constraints.minimumLineThickness();
            if (isNaN(chosenSize) || $.trim(chosenSize) === '') {
                // rejects any non-numeric chars, allows whitespace and decimal
                html = '<em>This value must be a number</em>';
            } else {
                // echo the new size (in pt) as inches/cm
                chosenSize = parseFloat(chosenSize);
                var convertedSize = self.style.printSize.units() === units.INCHES ?
                    stylist.pointsToInches( chosenSize ) :
                    stylist.pointsToCentimeters( chosenSize );
                convertedSize = convertedSize.toFixed(2);
                var unitSuffix = self.style.printSize.units() === units.INCHES ?
                    'inches' : 'cm';
                html = 'pt &nbsp;('+ convertedSize +' '+ unitSuffix +')';
            }
            return html;
        }, self, {deferEvaluation:true});

        self.moveElementUp = function(el) {
              var tempList = self.elements().slice(0);
              var currentPos = $.inArray(el, tempList);
              var previousPos = currentPos - 1;
              tempList[currentPos] = tempList[previousPos];
              tempList[previousPos] = el;
              self.elements(tempList);
        }
        self.moveElementDown = function(el) {
              var tempList = self.elements().slice(0);
              var currentPos = $.inArray(el, tempList);
              var nextPos = currentPos + 1;
              tempList[currentPos] = tempList[nextPos];
              tempList[nextPos] = el;
              self.elements(tempList);
        }
        self.confirmRemoveElement = function(el) {
            var displayName, removeMethod;
            if (el instanceof IllustratedTree) {
                if (confirm("Are you sure you want to remove this tree? This cannot be undone!")) {
                    self.removeIllustratedTree(el);
                }
            } else if (el instanceof SupportingDataset) {
                if (confirm("Are you sure you want to remove this dataset? This cannot be undone!")) {
                    self.removeSupportingDataset(el);
                }
            } else if (el instanceof Ornament) {
                if (confirm("Are you sure you want to remove this ornament? This cannot be undone!")) {
                    self.removeOrnament(el);
                }
            } else {
                console.error("confirmRemoveElement(): unexpected element type: '"+ el.metadata.type() +"'!");
                return;
            }
        }

        /* Instead of explicitly defining all possible members, let's
         * trust the ko.mapping plugin to handle loading and saving 
         * illustration data from JS(ON), with mapping options to handle
         * any exceptional stuff.
         */
        var mappingOptions = {
            /* Use to handle special cases:
             *  'ignore' to keep some clutter out of the saved model
             *  'include' to force view-model properties to be saved
             *  'copy' to keep simple values simple (vs. observable)
             *  'observe' ONLY if it's easier to whitelist the observables
             *  'create' map some elements to object classes
             *  'update'? convert Dates to ISO date-strings, ints to floats
             *  'key': pin elements to specified keys
             * See http://knockoutjs.com/documentation/plugins-mapping.html
             */
            'ignore': [ 'constructor' ],
            'include': [ ],
            'copy': [ 'vegaSpec' ],
            // 'observe': [ ], // WARNING: using this flips default mapping!
            'elements': {
                'create': function(options) {
                    // create these as object instances
                    var data = options.data;
                    var dataParent = options.parent;
                    var _illustration = self;
                    switch(data.metadata.type) {
                        // pass illustration to get IDs as needed
                        case 'IllustratedTree':
                            return new IllustratedTree(_illustration, data);
                        case 'SupportingDataset':
                            return new SupportingDataset(_illustration, data);
                        case 'Ornament':
                            return new Ornament(_illustration, data);
                    }
                    // keep it simple by default
                    console.warn("Unexpected element type '"+ data.metadata.type +"'! Creating a generic observable...");
                    return ko.observable(data);
                },
                'key': function(data) {
                    // use 'id' attribute to pin these
                    return ko.utils.unwrapObservable(data.id);
                }
            }
        };
        /* Map incoming data from a JS object. NOTE that we can also do 
         * this piecemeal to (for example) apply new styles to an illustration.
         *
         * TODO: Add some valication or other sanity checks after mapping, to
         * make sure we're not getting nonsense from the saved model?
         */
        ko.mapping.fromJS(data, mappingOptions, self);

        // Add validation for fields that need it
        self.metadata.name.extend({required: true});

        // Reset serial element IDs for this illustration
        initSerialElementIDs();

        self.exportModelAsObject = function() {
            var obj = ko.mapping.toJS(self);
            // TODO: any cleanup here?
            return obj;
        };

        self.exportModelAsJSON = function() {
            var json = ko.mapping.toJSON(self);
            // TODO: any cleanup here?
            return json;
        };

    }
    /* define PUBLIC methods (that don't need private data) in its prototype */
    Illustration.prototype = {
        constructor: Illustration,

        applyStyleGuide: function(data) {
            var self = this;
            ko.mapping.fromJS(data, Illustration.mappingOptions, self.styleGuide);

            /* Some properties are *forced* (rather then suggested) to comply
             * with the active style guide. 
             *
             * TODO: Reconsider this! Each field should probably be defined
             * either as a constraint OR a per-illustration * style assertion.
             */
            var forcedStyles = [
                'backgroundColor',
                'border',
                'edgeColor',
                'edgeThickness',
                'nodeColor',
                'nodeShape'
            ];
            $.each(forcedStyles, function(i, propName) {
                self.style[propName]( self.styleGuide.constraints[propName]() );
            });

            self.updatePrintSizeChooser();
            self.updateFontFamilyChooser();
            stylist.refreshViz();
        },

        addIllustratedTree: function() {
            var self = this;
            var tree = new IllustratedTree(self);
            self.elements.push(tree);
            stylist.refreshViz();
            return tree;
        },
        removeIllustratedTree: function(tree) {
            var self = this;
            self.elements.remove(tree);
            stylist.refreshViz();
            delete tree;
        },

        addSupportingDataset: function() {
            var self = this;
            var ds  = new SupportingDataset(self);
            self.elements.push(ds);
            stylist.refreshViz();
            return ds;
        },
        removeSupportingDataset: function(ds) {
            var self = this;
            self.elements.remove(ds);
            stylist.refreshViz();
            delete ds;
        },

        addOrnament: function() {
            var self = this;
            var obj  = new Ornament(self);
            self.elements.push(obj);
            stylist.refreshViz();
            return obj;
        },
        removeOrnament: function(obj) {
            var self = this;
            self.elements.remove(obj);
            stylist.refreshViz();
            delete obj;
        },

        /* For a given node, retrieve the best possible label field
         * (optionally from a ranked list of fields) or its text.
         *
         * This is CURRENTLY UNUSED, but may be useful if we want to support
         * fallback labeling based on a ranked list of sources, for example
         *   ['explicitLabel', 'ottTaxonName', 'originalLabel']
         */
        getPreferredLabelField: function(node, rankedFields) {
            if (!rankedFields) {
                rankedFields = ['explicitLabel','ottTaxonName','originalLabel','ottId'];
            }
            var foundNonEmptyLabel = 'explicitLabel';  // a harmless default
            $.each(rankedFields, function(i,fieldName) {
                if (node[fieldName]) {
                    foundNonEmptyLabel = fieldName;
                    return false;  // stop checking
                }
            });
            console.warn("Using label field '"+ foundNonEmptyLabel +"' for this node:");
            console.warn(node);
            return foundNonEmptyLabel;
        },
        getPreferredLabelText: function(node, rankedFields) {
            var self = this;
            var preferredField = self.getPreferredLabelField(node, rankedFields);
            var preferredText = node[preferredField];
            if (typeof preferredText === 'string') {
                return preferredText;
            }
            return '';
       },

        /* For a given element (eg, a tree, node, edge, ornament, or the
         * illustration itself), get the most "local" matching style value for
         * the specified property. By default, this should conform to the 
         * illustration itself, or its active style guide.
         */
        getEffectiveStyle: function(obj, propName) {
            var self = this;
            if ('style' in obj) {
                if (propName in obj.style) {
                    // handle observables or simple values
                    var rawValue = ko.utils.unwrapObservable(obj.style[propName]);
                    var constrainedValue = self.getConstrainedStyle(propName, rawValue);
                    return constrainedValue;
                }
            }
            // property wasn't found locally; check the next "innermost" context 
            if (obj instanceof IllustratedTree) {
                return self.getEffectiveStyle(self, propName);
            } else if (obj instanceof Illustration) {
                console.error("getEffectiveStyle(): style '"+ propName +"' not found in this tree's style:");
                console.error(obj.style);
                return;
            } else if (obj instanceof SupportingDataset) {
                console.error("getEffectiveStyle(): SupportingDataset is not yet supported!");
                return;
            } else if (obj instanceof Ornament) {
                console.error("getEffectiveStyle(): Ornament is not yet supported!");
                return;
            } else {
                console.error("getEffectiveStyle(): unexpected context object:");
                console.error(obj);
                return;
            }
        },
        getConstrainedStyle: function (propName, rawValue) {
            var self = this;
            switch(propName) {
                case 'edgeThickness':
                case 'borderThickness':
                    // assume these are in common units (pt?)
                    var thinnest = self.styleGuide.constraints.minimumLineThickness();
                    return Math.max(rawValue, thinnest);
                // TODO: add (many) more cases here, or constrain elsewhere..
                default:
                    // anything goes, return unchanged
                    return rawValue;
            }
        },

        updateVegaSpec: function(options) {
            /* Sweep the Illustration model and (re)generated a full Vega spec.
             * This drives the d3 visualization in the editor viewport.
             */
            var self = this;
            var spec = self.vegaSpec;

            // clear all groups and marks, and restore the empty illustration-elements group
            spec.marks = [ ];
            // reckon the current width and height as internal px
            var pxPrintWidth = stylist.physicalUnitsToPixels(self.style.printSize.width(), stylist.internal_ppi);
            var pxPrintHeight = stylist.physicalUnitsToPixels(self.style.printSize.height(), stylist.internal_ppi);
            var illustrationElementsGroup = {
                "type": "group",
                "name": "illustration-elements",  // becomes marker class .illustration-elements
                "properties": {
                    "enter": {
                        "x": {"value": 0},
                        "y": {"value": 0},
                        "height": {"value": pxPrintHeight },
                        "width": {"value": pxPrintWidth }
                    }
                },
                "scales": [ ],
                "axes": [ ],
                "marks": [ ]
            };
            spec.marks.push( illustrationElementsGroup );

            // clear and rebuild data based on current elements
            spec.data = [ ];

            $.each(self.elements(), function(i, el) {
                // Add appropriate data *and* marks as needed
                if (el instanceof IllustratedTree) {
                    var dataSourceName = el.id();  // "tree-3" or similar
                    var treeData = {
                        'name': dataSourceName,
                        'format': {"type":"treejson"},  // initial match for JSON object, vs. array
                         // TODO: support args for "treesCollectionPosition", "treePosition" or "treeID"?
                        'transform': [
                            // TODO: add all possible properties (common to by all formats?)
                            // TODO: merge supporting data from other files? or do that downstream?
                            // TODO: final tailoring to phylogram layout (one, or several?)
                        ]
                    }

                    /* Define data source for this element (allow for inline tree data? in 
                     * existing datasets? other kinds of sources?)
                     * NOTE that we should use cached data when possible, to avoid 
                     * an AJAX fetch each time we tweak the visual presentation of a tree!
                     */
                    var treeSourceCacheKey = 'input/ELEMENT-SOURCE-';
                    console.warn('=== source for element "'+ dataSourceName +'" ===');
                    console.warn('  type: '+ el.metadata.source.type());
                    console.warn('  value: '+ el.metadata.source.value());
                    switch (el.metadata.source.type()) { 
                        case dataSourceTypes.BUILT_IN:
                        case dataSourceTypes.URL:
                            treeSourceCacheKey += $.trim(el.metadata.source.value());
                            var cachedValue = getCachedData( treeSourceCacheKey );
                            if (cachedValue) {
                                // N.B. This data will be safely cloned by Vega when spec is parsed!
                                treeData.values = cachedValue;
                            } else {
                                treeData.url = el.metadata.source.value();
                            }
                            break;
                        case dataSourceTypes.UPLOAD:
                            var sourceValue = $.trim(el.metadata.source.value());
                            if (sourceValue === '') {
                                console.log("updateVegaSpec(): ignoring empty paste/uploads for now");
                                return;
                            }
                            //var treeSourceCacheKey = ('PASTED-SOURCE-' + sourceValue);
                            var treeSourceCacheKey = ('input/PASTED-TREE-' + sourceValue);

                            var cachedValue = getCachedData( treeSourceCacheKey );
                            if (cachedValue) {
                                // N.B. This data will be safely cloned by Vega when spec is parsed!
                                treeData.values = cachedValue;
                            } else {
                                console.warn("Still waiting for pasted text (Newick?) of '"+ el.metadata.name() +"'to be converted...");
                            }
                            break;
                        // TODO: add cases for other data sources
                        default:
                            console.error("Unknown source type for tree!");
                    }

                    /* Build an appropriate chain of data transforms */

                    // Cache the source data, if not already found
                    treeData.transform.push({
                        "type": "stash", 
                        "cacheSetter": 'TreeIllustrator.setCachedData',
                        "key": treeSourceCacheKey,
                        "flush": false
                    });

                    // Next transform imports data from its source format to our basic phyloTree
                    if (true) {   // TODO: Pivot to other importers (e.g. NEXUS), as appropriate
                        treeData.transform.push({
                            "type": "nexson", 
                            "treesCollectionPosition":0, 
                            "treePosition":0,
                            "branchRotation": el.branchRotation(),
                            "nodeLabelField": el.nodeLabelField()   // needed for alphabetical branch rotation!
                        });
                    }

                    // TODO: Shape the phyloTree using preferred tree layout and styles
                    var phylogramTransform = { 
                        "type": "phylogram", 
                        //"layout": "cartesian",
                        //"branchStyle": "diagonal",  // other options here?
                        "radialArc": el.radialArc(),
                        "radialSweep": el.radialSweep(),
                        "branchLengths": "",  // empty/false, or a property name to compare?
                        "width": el.width(),
                        "height": el.height(), 
                        "radius": el.radius(), 
                        "tipsAlignment": el.tipsAlignment()
                    };
                    treeData.transform.push( phylogramTransform );
                    switch (el.layout()) { 
                        case treeLayouts.RECTANGLE:
                            phylogramTransform.layout = 'cartesian';
                            break;
                        case treeLayouts.CIRCLE:
                            phylogramTransform.layout = 'radial';
                            break;
                        case treeLayouts.TRIANGLE:
                            phylogramTransform.layout = 'cladogram';
                            break;
                    }

                    spec.data.push(treeData);

                    // set label properties (esp. positioning) based on the chosen layout
                    var textHeight = self.styleGuide.constraints.minimumTextSize();   // TODO: adjustable font size (convert pt to px)
                    var halfTextHeight = textHeight * 0.4;   // TODO: adjustable font size (convert pt to px)
                    var initialLabelProperties = {
                        "fontSize": {"value": textHeight} 
                    };
                    switch (el.layout()) { 
                        case treeLayouts.RECTANGLE:
                        case treeLayouts.TRIANGLE:
                            // Label offsets depend on orientation
                            var labelNudgeX, labelNudgeY, labelAlign, labelRotation;
                            var nodeLabelGap = 6;  // TODO: base this on font size
                            switch (el.tipsAlignment()) {
                                case alignments.TOP:
                                    // NOTE the odd mapping of X and Y
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = -90;
                                    break;
                                case alignments.RIGHT:
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = 0;
                                    break;
                                case alignments.BOTTOM:
                                    labelNudgeX = nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'left';
                                    labelRotation = 90;
                                    break;
                                case alignments.LEFT:
                                    labelNudgeX = -nodeLabelGap;
                                    labelNudgeY = halfTextHeight;
                                    labelAlign = 'right';
                                    labelRotation = 0;
                                    break;
                            }
                            // Add simple properties for cartesian / rectangular layouts
                            $.extend(initialLabelProperties, {
                                "x": {"field": "x"},
                                "y": {"field": "y"},
                                "dx": {"value": labelNudgeX},
                                "dy": {"value": labelNudgeY},
                                "align": {"value": labelAlign},
                                "angle": {"value": labelRotation}
                            });
                            break;

                        case treeLayouts.CIRCLE:
                           /* Add properties for radial/polar layouts.
                            * Radius and theta (angle from origin, in radians) are the
                            * alternatives to X and Y for polar projection, and assume
                            * that the x and y properties represent the origin or center
                            * of the layout, ie, the root node. See discussion at
                            *  https://github.com/trifacta/vega/pull/187
                            */
                            $.extend(initialLabelProperties, {
                                "x": {"value": 0},  // this is origin for radial/polar projection
                                "y": {"value": 0},
                                "radius": {"field": "radius"},  // px from origin
                                "theta": {"field": "theta"},  // in radians (what direction from origin)
                                "align": {"field": 'align'},  // NOTE that some labels are flipped 180deg for legibility
                                "angle": {"field": "angle"}   // in degrees
                            });
                            break;
                    }

                    // place new trees in the center of the printable area (slightly staggered for clarity)
                    var treeMarks = { 
                        "type": "group",
                        "name": el.id(),  // becomes marker class .tree-3 or similar
                        "properties": {
                            "enter": {
                                "x": {"value": el.rootX()},
                                "y": {"value": el.rootY()}
                            },
                            "update": {
                                //"transform": {"value":"scale(800,300)"}
                                //"transform": {"value":"rotate(25) scale(20,20)"}
                            }
                        },
                        "marks": [
                            { /* pathsfor tree edges 
                                 N.B. This expects pre-existing links with 'source' and 'target' properties! The 'link' transform is 
                                 just to provide a rendered path of the desired type. */
                              "type": "path",
                              //"from": {"data": "phyloTree", "property": "links", "transform": [{"type": "link", "shape": "line"}]},
                              "from": {
                                "data": dataSourceName,
                                "transform": [
                                  {"type":"pluck", "field":"phyloEdges" }
                                // how do apply the 'time' scale here? TRY brute-forcing x and y properties
                                  //{"type":"formula", "field":"source.x", "expr":"d.source.y"},
                                  //{"type":"formula", "field":"target.x", "expr":"d.target.y"},
                                  // {"type":"link", "shape":"line" }  // line | curve | diagonal | diagonalX | diagonalY
                                  // {"type":"phylogramLink", "shape":"rightAngleDiagonal" }  // rightAngleDiagonal | radialRightAngleDiagonal
                                ]
                              },
                              "properties": {
                                "update": {
                                  "path": {"field": "path"}, // , "transform":{"scale":"x"}},
                                  "stroke": {"value": self.getEffectiveStyle(el, 'edgeColor')},
                                  "strokeWidth": {"value": self.getEffectiveStyle(el, 'edgeThickness')}
                                },
                                "hover": {
                                 // "stroke": {"value": "red"}
                                    }
                                  }
                                }
                                ,
                                {   /* group node/label pairs, for easier event binding later */
                                    "type":"group",
                                    "marks":[
                                        {
                                            "type": "symbol",
                                            "from": {"data": dataSourceName, "transform": [{"type":"pluck", "field":"phyloNodes" }] },
                                            "properties": {
                                                "enter": {
                                                    "x": {"XXscale": "x", "field": "x", "mult":1},
                                                    "y": {"XXscale": "y", "field": "y", "mult":1}
                                                },
                                                "update": {
                                                    "shape": {"value":"circle"},
                                                    "size": {"value": 8},
                                                    "fill": {"value": "black"}
                                                },
                                                "hover": {
                                                    // "fill": {"value": "red"}
                                                }
                                            }
                                        } /* end of node marks */
                                        ,
                                        {  // label marks
                                            "type": "text",
                                            "from": {"data": dataSourceName, "transform": [{"type":"pluck", "field":"phyloNodes" }] },
                                            "properties": {
                                                "enter": initialLabelProperties,
                                                "update": {
                                                    "text": {"field": el.nodeLabelField() },
                                                    "fill": {"value":"black"}
                                                },
                                                "hover": {
                                                    "fill": {"value": "red"}
                                                }
                                        }
                                    } /* end of label marks */
                                ]
                            } /* end of grouped node+label */ 
                            ,
                            {   /* group tree hotspot and handles */
                                "type":"group",
                                "name": "handles",
                                "marks":[
                                    {  /* hotspot for direct manipulation of the tree */
                                        "name": "tree-hotspot",
                                        "type": "path",
                                        "from": {
                                            "data": dataSourceName,
                                            "transform": [
                                                {"type":"pluck", "field":"hotspot" }
                                            ]
                                        },
                                        "properties": {
                                            "update": {
                                                "path": {"field": "path"},  // TODO: Can we make this dynamic, perhaps a callable?
                                                "stroke": {"value": "#0f0"},
                                                "strokeWidth": {"value": "1px"},
                                                "strokeOpacity": {"value": "0.0"},
                                                "fill": {"value": "#000"},  /* override this in CSS */
                                                "fillOpacity": {"value": "0.0"}
                                            },
                                            "hover": {
                                                //"opacity": {"value": "0.1"}
                                            }
                                        }
                                    },
                                    {  /* corner handles for size and angle adjustments */
                                        "name": "vertex-handle actual-size",
                                        "type": "symbol",
                                        "from": {
                                            "data": dataSourceName,
                                            "transform": [
                                              {"type":"pluck", "field":"vertexHandles" }
                                            ]
                                        },
                                        "properties": {
                                            "enter": {
                                                "name": {"field":"name"},  /* assigned to datum, not to mark! */
                                                "tooltip": {"field":"tooltip"},  /* assigned to datum, not to mark! */
                                                "shape": {"field": "shape"}, /* default shape is "circle" */
                                                "size": {"field": "size"},
                                                "fill": {"value": "#000"},  /* override this in CSS */
                                                "fillOpacity": {"value": "0.0"},
                                                "stroke": {"value": "#f00"},
                                                "strokeWidth": {"value": "6"},  /* hidden hit area */
                                                "strokeOpacity": {"value": "0.0"}
                                            },
                                            "update": {
                                                "x": {"field": "x"},
                                                "y": {"field": "y"},
                                            },
                                            "hover": {
                                                //"opacity": {"value": "0.1"}
                                            }
                                        }
                                    }
                                 ]
                            }
                        ] /* end of inner group marks */
                    }; /* end of inner group */

                    illustrationElementsGroup.marks.push( treeMarks );

                } else if (el instanceof SupportingDataset) {
                    console.log("updateVegaSpec(): ignoring datasets for now");

                } else if (el instanceof Ornament) {
                    console.log("updateVegaSpec(): ignoring ornaments for now");

                } else {
                    console.error("updateVegaSpec(): unexpected element type: '"+ el.metadata.type() +"'!");
                }
            });

        }
    };

    /* We need to be able to define custom styles for many different elements of
     * the scene graph, e.g., a tree, node, or caption.
     */
    var SceneGraph = function(data) {
        if ( !(this instanceof SceneGraph) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new SceneGraph(data);
        }
        // safely refer to this instance
        var self = this;

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }

    var IllustratedTree = function(illustration, data) {
        if ( !(this instanceof IllustratedTree) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new IllustratedTree(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" tree object above
            data = getNewIllustratedTreeModel(illustration);
        }

        // safely refer to this instance
        var self = this;

        // point back to my parent illustration?
        //self.illustration = illustration;

        /* Apply hard constraints to some properties and wrap their fields
         * accordingly. We do this by binding each basic property to a
         * writable computed observable that applies any constraints before
         * updating its value, protecting us from out-of-bounds or nonsensical
         * values.
         */
        var treeSizeConstraint = {
            'type': Number,
            'min': stylist.inchesToPixels( 0.25, stylist.internal_ppi),  // 1/4" tree seems like a reasonable minimum
            // TODO: Check for a minimum in the current style guide?
            'max': stylist.inchesToPixels( 1000, stylist.internal_ppi)  // stop at 1000 inches wide
        }
        self.constrainedWidth = wrapFieldWithConstraints(self, 'width', treeSizeConstraint);
        self.constrainedHeight = wrapFieldWithConstraints(self, 'height', treeSizeConstraint);
        self.constrainedRadius = wrapFieldWithConstraints(self, 'radius', treeSizeConstraint);

        // Bind some fields to writable computed observables, so users can "think in physical units"
        self.physicalWidth = wrapFieldWithPhysicalUnits(self, 'constrainedWidth');
        self.physicalHeight = wrapFieldWithPhysicalUnits(self, 'constrainedHeight');
        self.physicalRadius = wrapFieldWithPhysicalUnits(self, 'constrainedRadius');
        self.physicalRootX = wrapFieldWithPhysicalUnits(self, 'rootX');
        self.physicalRootY = wrapFieldWithPhysicalUnits(self, 'rootY');

        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // (Un)bundle 'startAngle' and 'endAngle' values used in radialArc
        self.startAngle = ko.computed({
            read: function() {
                return self.radialArc()[0];
            },
            write: function(value) {
                var arc = self.radialArc();
                arc[0] = Number(value);
                self.radialArc(arc);
            },
            deferEvaluation: true
        });
        self.endAngle = ko.computed({
            read: function() {
                return self.radialArc()[1];
            },
            write: function(value) {
                var arc = self.radialArc();
                arc[1] = Number(value);
                self.radialArc(arc);
            },
            deferEvaluation: true
        });

        // Add validation for fields that need it
        self.metadata.name.extend({required: true});

        // capture hotspot and handle logic?
        self.hotspot = data.hotspot;

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }
    IllustratedTree.prototype = {
        constructor: IllustratedTree,

        useChosenLayout: function(newValue) {
            var self = this;
            if (newValue in treeLayouts) {
                self.layout(newValue);
            } else {
                console.error("useChosenLayout(): Unknown tree layout '"+ newValue +"'!"); 
            }
            stylist.refreshViz();
        }
        ,
        useChosenTreeDataSource: function() {
            var self = this;
            // pick up latest data from bound widgets
            var $chooser = $('#'+ self.id() +'-datasource-chooser');
            var $opentreeIDsPanel = $('#'+ self.id() +'-datasource-opentreeids-panel');
            var $nexsonUrlPanel = $('#'+ self.id() +'-datasource-nexsonurl-panel');
            var $fileUploadPanel = $('#'+ self.id() +'-datasource-upload-panel');
            var $fileFormatChooser = $('#'+ self.id() +'-datasource-format');
            var chosenSource = $chooser.val();
            switch(chosenSource) {
                /* Match against strings defined in `stylist.js`. We'll start
                 * with some special cases that drive changes to the UI.
                 */
                case "Enter OpenTree study and tree ids":
                    $opentreeIDsPanel.show();
                    $nexsonUrlPanel.hide();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var studyID = self.metadata.source.phylesystemStudyID(); 
                    var treeID = self.metadata.source.phylesystemTreeID();
                    var treeNexsonURL = 'https://api.opentreeoflife.org/phylesystem/v1/study/'
                                      + studyID +'/tree/'+ treeID +'?output_nexml2json=1.0.0';
                    self.metadata.source.value( treeNexsonURL );
                    break;

                case "Enter URL to NexSON 1.0":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Enter URL to a GitHub gist":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                        // TODO: Use another field for Gist URLs?
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Enter or upload tree data":
                //case "Upload tree data":
                case "Newick string":
                case "Newick string with extra data":
                case "NEXUS":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.hide();
                    // enable "pasted text" field for this method
                    var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                    $pastedField.attr('disabled', false)
                                .css('color','#aaa');
                    $fileUploadPanel.show();

                    switch(chosenSource) {
                        case "Newick string":
                        case "Newick string with extra data":
                            $fileFormatChooser.val('newick');
                            break;
                        case "NEXUS":
                            $fileFormatChooser.val('nexus');
                            break;
                        case 'NeXML':
                            $fileFormatChooser.val('nexml');
                            break;
                        case 'phylo (R data frame)':
                            $fileFormatChooser.val('phylo');
                            break;
                        default:
                            $fileFormatChooser.val('');
                            break;
                    }
                    break;

                default:
                    /* Handle common cases for listed tree sources:
                     *  - explicit "fetch" URLs for data on the web
                     *  - Jupyter kernel values from a hosting notebook
                     */
                    // Look for the matching URL at any level of this tree of *observable* arrays
                    var testLists = [stylist.availableTrees()];
                    $.each(stylist.availableTrees(), function(i, testItem) {
                        if ('children' in testItem) {
                            testLists.push(testItem.children());
                        }
                    });
                    var treeInfo = null;
                    $.each(testLists, function(i, testList) {
                        // ASSUMES unique display text for all items in nested list!
                        var selectedTrees = $.grep(testList, function(o) {
                            return o.name() === chosenSource;
                        });
                        if (selectedTrees.length > 0) {
                            treeInfo = selectedTrees[0];
                        }
                    });
                    if (!treeInfo) {
                        console.warn("No tree found under '"+ chosenSource +"'!");
                        return;
                    }
                    if ('url' in treeInfo) {
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        $fileUploadPanel.hide();
                        self.metadata.source.type(dataSourceTypes.URL);
                        self.metadata.source.value( treeInfo.url() );
                    } else if ('kernel' in treeInfo) { // or 'kernel'? 'nbkernel'?
                        // assume this is 'python' for now
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        // Disable the format chooser while we try to guess
                        var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                        $inputFormatChooser.attr('disabled', true);
                        // disable "pasted text" field (display only)
                        var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                        $pastedField.attr('disabled', true)
                                    .css('color',''); // restore default text color
                        $fileUploadPanel.show();
                        // TODO: For a multi-kernel notebook, expect a specific kernel-id, eg 'python2'
                        var nbVarName = treeInfo.name().split(' ')[0];
                        stylist.storage[ storageBackends.JUPYTER_NOTEBOOK ].getTreeSourceData(nbVarName, function(response) {
                            console.warn('getTreeSourceData returning for tree "'+ treeInfo.name() +'"...');
                            if ('data' in response) {
                                var treeSourceData = response.data;
                                /* To interpret this as tree source data, we'll 
                                 * need to figure out its format. Pass it to a 
                                 * series of "sniffers" to identify Newick, Nexson, etc.
                                 */
                                // TODO: push this source into persistent storage?
                                ///self.metadata.source.value(treeSourceData);
                                var matchingFormat = mostLikelyDataFormat(treeSourceData);
                                $inputFormatChooser.val(matchingFormat);
                                // show something friendly in the (disabled) text field
                                var treeSourceAsText = (typeof treeSourceData === 'string') ?
                                    treeSourceData :
                                    JSON.stringify(treeSourceData);
                                $pastedField.val(treeSourceAsText);
                            } else {
                                var msg = response.error || "No data returned (unspecified error)!";
                                console.error(msg);
                                alert(msg);
                            }
                            $inputFormatChooser.attr('disabled', false);
                        });
                    } else {
                        // Maybe this string should be added to the special cases above!
                        console.warn("No URL or kernel found for '"+ chosenSource +"'!");
                        return;
                    }
            }
            stylist.refreshViz();
        }
        ,
        useChosenLabelField: function() {
            var self = this;
            // pick up latest data from bound widgets
            var $chooser = $('#'+ self.id() +'-labelfield-chooser');
            self.nodeLabelTextField = $chooser.val();
            stylist.refreshViz();
        }
        ,
        convertSourceDataToNexson: function(treeID, srcText) {
            // Convert pasted/uploaded source data to nexson, using the
            // conversion methods in the main open tree curation tool.  
            // N.B. This is used for newly pasted/uploaded text as well as for
            // source data loaded from an existing illustration.
            var self = this;  // the tree in question

        }
        ,
        convertPastedDataToTree: function(treeID) {
            // Try to convert pasted/uploaded text to nexson, using the conversion
            // methods in the main open tree curation tool.
            var self = this;  // the tree in question
            var $pastedField = $('#'+ self.id() +'-datasource-pasted');
            var pastedText = $.trim($pastedField.val());
            if (pastedText === '') {
                alert("Please paste Newick or other text into the text area provided, then try again.");
                // TODO: clear any cached and internal values regardless, to hide an old tree?
                return;
            }
            self.convertSourceDataToNexson(treeID, pastedText);

            // TODO
            self.metadata.source.value( pastedText );
            self.metadata.source.type(dataSourceTypes.UPLOAD);
            //var treeSourceCacheKey = ('PASTED-SOURCE-' + $.trim(self.metadata.source.value()));
            var treeSourceCacheKey = ('input/PASTED-TREE-' + $.trim(self.metadata.source.value()));
            console.warn('...converting pasted data to tree...');
            // TODO: build up cache key with format + content?
            var cachedValue = getCachedData( treeSourceCacheKey );
            if (cachedValue) {
                // N.B. This data will be safely cloned by Vega when spec is parsed!
                // NOTE that we should still refresh immediately, in case the cached tree data was loaded
                // created for another tree, or an earlier version of this one.
                self.nodeLabelField('explicitLabel');
                stylist.refreshViz();
            } else {
                // call opentree web services to convert to nexson
                //TODO: Apply other pasted formats (and REMEMBER THEM in the saved illustration!)
                var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                //$inputFormatChooser.attr('disabled', true);
                var inputFormat = $inputFormatChooser.val();
                if (inputFormat === '') {
                    alert("Please choose the format of this tree data, then try again.");
                    return;
                }
                $.ajax({
                    type: 'POST',
                    dataType: 'json',
                    // crossDomain: true,
                    contentType: "application/json; charset=utf-8",
                    url: 'https://devtree.opentreeoflife.org/curator/to_nexson',
                    /* NOTE that idPrefix and firstAvailable*ID args are
                     * currently required to get well-formed Nexson!
                     */
                    data: ('{"output": "ot:nexson", '+
                            '"auth_token": "ANONYMOUS", '+
                            '"idPrefix": "", ' +
                            '"firstAvailableEdgeID": "1", '+
                            '"firstAvailableNodeID": "1", '+
                            '"firstAvailableOTUID": "1", '+
                            '"firstAvailableOTUsID": "1", '+
                            '"firstAvailableTreeID": "1", '+
                            '"firstAvailableTreesID": "1", '+
                            '"firstAvailableAnnotationID": "1", '+
                            '"firstAvailableAgentID": "1", '+
                            '"firstAvailableMessageID": "1", '+
                            '"inputFormat": '+ JSON.stringify(inputFormat) +', '+
                            '"content": '+ JSON.stringify($.trim(self.metadata.source.value())) +
                           ' }'),
                    processData: false,
                    complete: function( jqXHR, textStatus ) {
                        // report errors or malformed data, if any
                        if (textStatus !== 'success') {
                            if (jqXHR.status >= 500) {
                                // major server-side error, just show raw response for tech support
                                var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                                alert(errMsg);
                                return;
                            }
                            // Server blocked the save due to major validation errors!
                            var data = $.parseJSON(jqXHR.responseText);
                            // TODO: This should be properly parsed JSON, show it more sensibly
                            // (but for now, repeat the crude feedback used above)
                            var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                            alert(errMsg);
                            return;
                        }
                        // Pasted tree was converted successfully; capture the Nexson as a string
                        var data = $.parseJSON(jqXHR.responseText);

                        // fix any quirks to conform to our expected Nexson structure
                        fixUpConvertedNexson(data);

                        // store it in the cache, at the key defined above
                        console.warn('...storing pasted data in cache... key='+ treeSourceCacheKey);
                        setCachedData( treeSourceCacheKey, data );
                        // force node-label field to show "explicit" labels (TODO: for Newick only?)
                        self.nodeLabelField('explicitLabel');
                        stylist.refreshViz();
                    }
                });
            }
        }
        ,
        useChosenTipsAlignment: function(newValue) {
            var self = this;
            if (newValue in alignments) {
                self.tipsAlignment(newValue);
            } else {
                console.error("useChosenTipsAlignment(): Unknown tips alignment '"+ newValue +"'!");
            }
            stylist.refreshViz();
        }
        ,
        useChosenRadialSweep: function(newValue) {
            var self = this;
            if (newValue in sweepDirections) {
                self.radialSweep(newValue);
            } else {
                console.error("useChosenRadialSweep(): Unknown sweep direction '"+ newValue +"'!");
            }
            stylist.refreshViz();
        }
    };

    var SupportingDataset = function(illustration, data) {
        if ( !(this instanceof SupportingDataset) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new SupportingDataset(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" dataset object above
            data = getNewSupportingDatasetModel(illustration);
        }

        // safely refer to this instance
        var self = this;
        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }
    SupportingDataset.prototype = {
        constructor: SupportingDataset,

        useChosenDataSource: function() {
            var self = this;
            // pick up latest data from bound widgets
            var $chooser = $('#'+ self.id() +'-datasource-chooser');
            var $opentreeIDsPanel = $('#'+ self.id() +'-datasource-opentreeids-panel');
            var $nexsonUrlPanel = $('#'+ self.id() +'-datasource-nexsonurl-panel');
            var $fileUploadPanel = $('#'+ self.id() +'-datasource-upload-panel');
            // TODO: Replace these with appropriate panels!?
            var chosenSource = $chooser.val();
            switch(chosenSource) {
                /* Match against strings defined in `stylist.js`. We'll start
                 * with some special cases that drive changes to the UI.
                 */
                /*
                case "Enter OpenTree study and tree ids":
                    $opentreeIDsPanel.show();
                    $nexsonUrlPanel.hide();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var studyID = self.metadata.source.phylesystemStudyID(); 
                    var treeID = self.metadata.source.phylesystemTreeID();
                    var treeNexsonURL = 'https://api.opentreeoflife.org/phylesystem/v1/study/'
                                      + studyID +'/tree/'+ treeID +'?output_nexml2json=1.0.0';
                    self.metadata.source.value( treeNexsonURL );
                    break;

                */
                case "Enter URL to data file":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Enter URL to a GitHub gist":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.show();
                    $fileUploadPanel.hide();
                    self.metadata.source.type(dataSourceTypes.URL);
                    var $otherField = $('#'+ self.id() +'-datasource-nexsonurl');
                        // TODO: Use another field for Gist URLs?
                    self.metadata.source.value( $.trim($otherField.val()) );
                    break;

                case "Enter or upload data":
                //case "Newick string":
                //case "Newick string with extra data":
                //case "NEXUS":
                    $opentreeIDsPanel.hide();
                    $nexsonUrlPanel.hide();
                    // enable "pasted text" field for this method
                    var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                    $pastedField.attr('disabled', false)
                                .css('color','#aaa');
                    $fileUploadPanel.show();
                    break;

                default:
                    /* Handle common cases for listed tree sources:
                     *  - explicit "fetch" URLs for data on the web
                     *  - Jupyter kernel values from a hosting notebook
                     */
                    // Look for the matching URL at any level of this tree of *observable* arrays
                    var testLists = [stylist.availableTrees()];
                    $.each(stylist.availableTrees(), function(i, testItem) {
                        if ('children' in testItem) {
                            testLists.push(testItem.children());
                        }
                    });
                    var treeInfo = null;
                    $.each(testLists, function(i, testList) {
                        // ASSUMES unique display text for all items in nested list!
                        var selectedTrees = $.grep(testList, function(o) {
                            return o.name() === chosenSource;
                        });
                        if (selectedTrees.length > 0) {
                            treeInfo = selectedTrees[0];
                        }
                    });
                    if (!treeInfo) {
                        console.warn("No data found under '"+ chosenSource +"'!");
                        return;
                    }
                    if ('url' in treeInfo) {
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        $fileUploadPanel.hide();
                        self.metadata.source.type(dataSourceTypes.URL);
                        self.metadata.source.value( treeInfo.url() );
                    } else if ('kernel' in treeInfo) { // or 'kernel'? 'nbkernel'?
                        // assume this is 'python' for now
                        $opentreeIDsPanel.hide();
                        $nexsonUrlPanel.hide();
                        // Disable the format chooser while we try to guess
                        var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                        $inputFormatChooser.attr('disabled', true);
                        // disable "pasted text" field (display only)
                        var $pastedField = $('#'+ self.id() +'-datasource-pasted');
                        $pastedField.attr('disabled', true)
                                    .css('color',''); // restore default text color
                        $fileUploadPanel.show();
                        // TODO: For a multi-kernel notebook, expect a specific kernel-id, eg 'python2'
                        var nbVarName = treeInfo.name().split(' ')[0];
                        stylist.storage[ storageBackends.JUPYTER_NOTEBOOK ].getTreeSourceData(nbVarName, function(response) {
                            console.warn('getTreeSourceData returning for tree "'+ treeInfo.name() +'"...');
                            if ('data' in response) {
                                var treeSourceData = response.data;
                                /* To interpret this as tree source data, we'll 
                                 * need to figure out its format. Pass it to a 
                                 * series of "sniffers" to identify Newick, Nexson, etc.
                                 */
                                // TODO: push this source into persistent storage?
                                ///self.metadata.source.value(treeSourceData);
                                var matchingFormat = mostLikelyDataFormat(treeSourceData);
                                $inputFormatChooser.val(matchingFormat);
                                // show something friendly in the (disabled) text field
                                var treeSourceAsText = (typeof treeSourceData === 'string') ?
                                    treeSourceData :
                                    JSON.stringify(treeSourceData);
                                $pastedField.val(treeSourceAsText);
                            } else {
                                var msg = response.error || "No data returned (unspecified error)!";
                                console.error(msg);
                                alert(msg);
                            }
                            $inputFormatChooser.attr('disabled', false);
                        });
                    } else {
                        // Maybe this string should be added to the special cases above!
                        console.warn("No URL or kernel found for '"+ chosenSource +"'!");
                        return;
                    }
            }
            stylist.refreshViz();
        }
        ,
        capturePastedData: function(datasetID) {
            // Try to convert pasted/uploaded text to nexson, using the conversion
            // methods in the main open tree curation tool.
            var self = this;  // the tree in question
            var $pastedField = $('#'+ self.id() +'-datasource-pasted');
            var pastedText = $.trim($pastedField.val());
            if (pastedText === '') {
                alert("Please paste Newick or other text into the text area provided, then try again.");
                // TODO: clear any cached and internal values regardless, to hide an old tree?
                return;
            }
            self.convertSourceDataToNexson(datasetID, pastedText);

            // TODO
            self.metadata.source.value( pastedText );
            self.metadata.source.type(dataSourceTypes.UPLOAD);
            //var treeSourceCacheKey = ('PASTED-SOURCE-' + $.trim(self.metadata.source.value()));
            var treeSourceCacheKey = ('input/PASTED-TREE-' + $.trim(self.metadata.source.value()));
            console.warn('...converting pasted data to tree...');
            // TODO: build up cache key with format + content?
            var cachedValue = getCachedData( treeSourceCacheKey );
            if (cachedValue) {
                // N.B. This data will be safely cloned by Vega when spec is parsed!
                // NOTE that we should still refresh immediately, in case the cached tree data was loaded
                // created for another tree, or an earlier version of this one.
                self.nodeLabelField('explicitLabel');
                stylist.refreshViz();
            } else {
                // call opentree web services to convert to nexson
                //TODO: Apply other pasted formats (and REMEMBER THEM in the saved illustration!)
                var $inputFormatChooser = $('#'+ self.id() +'-datasource-format');
                //$inputFormatChooser.attr('disabled', true);
                var inputFormat = $inputFormatChooser.val();
                if (inputFormat === '') {
                    alert("Please choose the format of this tree data, then try again.");
                    return;
                }
                $.ajax({
                    type: 'POST',
                    dataType: 'json',
                    // crossDomain: true,
                    contentType: "application/json; charset=utf-8",
                    url: 'https://devtree.opentreeoflife.org/curator/to_nexson',
                    /* NOTE that idPrefix and firstAvailable*ID args are
                     * currently required to get well-formed Nexson!
                     */
                    data: ('{"output": "ot:nexson", '+
                            '"auth_token": "ANONYMOUS", '+
                            '"idPrefix": "", ' +
                            '"firstAvailableEdgeID": "1", '+
                            '"firstAvailableNodeID": "1", '+
                            '"firstAvailableOTUID": "1", '+
                            '"firstAvailableOTUsID": "1", '+
                            '"firstAvailableTreeID": "1", '+
                            '"firstAvailableTreesID": "1", '+
                            '"firstAvailableAnnotationID": "1", '+
                            '"firstAvailableAgentID": "1", '+
                            '"firstAvailableMessageID": "1", '+
                            '"inputFormat": '+ JSON.stringify(inputFormat) +', '+
                            '"content": '+ JSON.stringify($.trim(self.metadata.source.value())) +
                           ' }'),
                    processData: false,
                    complete: function( jqXHR, textStatus ) {
                        // report errors or malformed data, if any
                        if (textStatus !== 'success') {
                            if (jqXHR.status >= 500) {
                                // major server-side error, just show raw response for tech support
                                var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                                alert(errMsg);
                                return;
                            }
                            // Server blocked the save due to major validation errors!
                            var data = $.parseJSON(jqXHR.responseText);
                            // TODO: This should be properly parsed JSON, show it more sensibly
                            // (but for now, repeat the crude feedback used above)
                            var errMsg = 'Sorry, there was an error ('+ jqXHR.status +') converting this tree to Nexson:\n\n'+ jqXHR.responseText;
                            alert(errMsg);
                            return;
                        }
                        // Pasted tree was converted successfully; capture the Nexson as a string
                        var data = $.parseJSON(jqXHR.responseText);

                        // fix any quirks to conform to our expected Nexson structure
                        fixUpConvertedNexson(data);

                        // store it in the cache, at the key defined above
                        console.warn('...storing pasted data in cache... key='+ treeSourceCacheKey);
                        setCachedData( treeSourceCacheKey, data );
                        // force node-label field to show "explicit" labels (TODO: for Newick only?)
                        self.nodeLabelField('explicitLabel');
                        stylist.refreshViz();
                    }
                });
            }
        }
    }
    var Ornament = function(illustration, data) {
        if ( !(this instanceof Ornament) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new Ornament(illustration, data);
        }

        if (!data || typeof(data) !== 'object') {
            // load the "empty" ornament object above
            data = getNewOrnamentModel(illustration);
        }

        // safely refer to this instance
        var self = this;
        ko.mapping.fromJS(data, Illustration.mappingOptions, self);

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }


    /* We need to be able to define custom styles for many different elements of
     * the scene graph, e.g., a tree, node, or caption.
     */
    var StyleOverrides = function(data) {
        if ( !(this instanceof StyleOverrides) ) {
            console.warn("MISSING 'new' keyword, patching this now");
            return new StyleOverrides(data);
        }
        // safely refer to this instance
        var self = this;

        // TODO: Based on the element type, offer appropriate styles and constraints
        // TODO: Include options to map selected data to visual style
        return self;
    }

    /* We'll often want to show values using the chosen physical units (inches
     * or cm), but store them as internal SVG pixels. This makes it easy to
     * declare these as computed properties, eg, wrap width => 'physicalWidth'
     */
    var wrapFieldWithPhysicalUnits = function(obj, fieldName, precision) {
        // Display using selected precision (number of places), with hundredths by default.
        // EXAMPLE: self.physicalWidth = wrapFieldWithPhysicalUnits(self, 'width');
        precision = precision || 2;
        return ko.computed({
            read: function() {
                var physicalValue = stylist.pixelsToPhysicalUnits(obj[ fieldName ](), stylist.internal_ppi);
                return Number(Math.round(physicalValue + "e+" + precision) + "e-" + precision);
            },
            write: function(value) {
                obj[ fieldName ]( stylist.physicalUnitsToPixels(value, stylist.internal_ppi));
            },
            owner: obj,
            deferEvaluation: true
        })
    }

    /* Apply hard constraints to proposed values. These might be universal
     * values (e.g. minimum legible text height = 5px), or set within an active
     * style guide (e.g., figures in _Systematic Biology_ must use font sizes
     * from 10px to 64px).
     *
     * NOTE that these wrappers can be nested like so;
     *   self.constrainedWidth = wrapFieldWithConstraints(self, 'width');
     *   self.physicalWidth = wrapFieldWithPhysicalUnits(self, 'constrainedWidth');
     * This lets us get/set with constraints, using either px or physical units.
     */
    var wrapFieldWithConstraints = function(obj, fieldName, constraints, precision) {
        // Display using selected precision (number of places), with hundredths by default.
        precision = precision || 2;
        if (!constraints) {
            console.error("wrapFieldWithConstraints() expects a constraints object!");
            return;
        };
        return ko.computed({
            read: function() {
                // nothing interesting here, just call the wrapped field
                ///console.log("READING from constrained '"+ fieldName +"'!");
                return obj[ fieldName ]();
            },
            write: function(value) {
                // Interpret and apply the specified constraints, perhaps signaling
                // whether the proposed value is allowed.
                ///console.log("WRITING to a constrained '"+ fieldName +"'!");
                var itsType = constraints.type;
                var newValue;

                // Check for a whitelist of acceptable values
                if ('whitelist' in constraints) {
                    var acceptableValues = constraints.whitelist;
                    var foundPosition = acceptableValues.indexOf(value);
                    // TODO: trim whitespace? force to upper case?
                    if (foundPosition === -1) {
                        // reject the proposed value; re-assert the old value for UI refresh
                        obj[ fieldName ].valueHasMutated();
                        return false;
                    }
                }

                if (itsType === Number) {
                    // look for minimum, maximum, precision? coerce and block NaN
                    newValue = Number(value);
                    if (isNaN( newValue )) {
                        // reject the proposed value; re-assert the old value for UI refresh
                        obj[ fieldName ].valueHasMutated();
                        return false;
                    }
                    if ('min' in constraints) {
                        var minValue = Number(constraints.min);
                        newValue = Math.max( minValue, newValue );
                    }
                    if ('max' in constraints) {
                        var maxValue = Number(constraints.max);
                        newValue = Math.min( maxValue, newValue );
                    }
                }
                if (itsType === String) {
                    // Add any string-specific constraints here (min. chars, etc.)
                }

                // Still here? Update the value (which may *not* have changed) and return true
                obj[ fieldName ]( newValue );
                return true;
            },
            owner: obj,
            deferEvaluation: true
        })
    }

    /* Newick (and other?) formats converted Nexson may be missing some
     * elements we expect. Add these now. */
    var fixUpConvertedNexson = function(data) {
        // 'data' is nexml in typical JSON wrapper
        var nexml = data.data.nexml;
        var nodeHasChildren = function(node, tree) {
            var childFound = false;
            $.each(tree.edge, function(i,edge) {
                if (edge['@source'] === node['@id']) {
                    childFound = true;
                }
            });
            return childFound;
        };
        $.each(nexml.trees, function(i,treeCollection) { // mark childless nodes with 'ot:isleaf'
            $.each(treeCollection.tree, function(i, tree) {
                var leafNodes = $.grep(tree.node, function(node) { 
                    if (nodeHasChildren(node,tree)) {
                        // modify internal nodes?
                    } else {
                        node['^ot:isLeaf'] = true;
                    }
                });
            });
        });
    }

    /* Use sniffers to determine the most likely format of input tree data */
    var mostLikelyDataFormat = function (data) {
        if (utils.isProbablyNewick(data)) { return  'newick'; }
        if (utils.isProbablyNEXUS(data))  { return  'nexus'; }
        if (utils.isProbablyRPhylo(data))  { return  'phylo'; }
        if (utils.isProbablyNeXML(data))  { return  'nexml'; }
        return '';  // format unknown
    }

    /* expose class constructors (and static methods) for instantiation */
    return {
        // expose enumerations
        units: units,
        colorDepths: colorDepths,
        treeLayouts: treeLayouts,
        branchRotationMethods: branchRotationMethods,
        alignments: alignments,
        sweepDirections: sweepDirections,
        dataSourceTypes: dataSourceTypes,
        versionTypes: versionTypes,
        hostApplications: hostApplications,
        storageBackends: storageBackends,
        cache: cache,
        setCachedData: setCachedData,
        getCachedData: getCachedData,
        clearCachedData: clearCachedData,
        flushCache: flushCache,
        gatherAllCachedData: gatherAllCachedData,
        gatherStaticInputData: gatherStaticInputData,
        gatherAllInputData: gatherAllInputData,
        gatherAllTransformData: gatherAllTransformData,
        gatherAllOutputData: gatherAllOutputData,

        // expose view-model classes
        Illustration: Illustration,
        SceneGraph: SceneGraph,
        IllustratedTree: IllustratedTree,
        SupportingDataset: SupportingDataset,
        Ornament: Ornament,
        StyleOverrides: StyleOverrides
    };
}(window, document, $, ko, stylist);

for (var name in TreeIllustrator) {
    exports[ name ] = TreeIllustrator[ name ];
}

},{"./stylist.js":249,"./ti-utils.js":250}],244:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*! jQuery v1.8.3 jquery.com | jquery.org/license */
(function(e,t){function _(e){var t=M[e]={};return v.each(e.split(y),function(e,n){t[n]=!0}),t}function H(e,n,r){if(r===t&&e.nodeType===1){var i="data-"+n.replace(P,"-$1").toLowerCase();r=e.getAttribute(i);if(typeof r=="string"){try{r=r==="true"?!0:r==="false"?!1:r==="null"?null:+r+""===r?+r:D.test(r)?v.parseJSON(r):r}catch(s){}v.data(e,n,r)}else r=t}return r}function B(e){var t;for(t in e){if(t==="data"&&v.isEmptyObject(e[t]))continue;if(t!=="toJSON")return!1}return!0}function et(){return!1}function tt(){return!0}function ut(e){return!e||!e.parentNode||e.parentNode.nodeType===11}function at(e,t){do e=e[t];while(e&&e.nodeType!==1);return e}function ft(e,t,n){t=t||0;if(v.isFunction(t))return v.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return v.grep(e,function(e,r){return e===t===n});if(typeof t=="string"){var r=v.grep(e,function(e){return e.nodeType===1});if(it.test(t))return v.filter(t,r,!n);t=v.filter(t,r)}return v.grep(e,function(e,r){return v.inArray(e,t)>=0===n})}function lt(e){var t=ct.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function At(e,t){if(t.nodeType!==1||!v.hasData(e))return;var n,r,i,s=v._data(e),o=v._data(t,s),u=s.events;if(u){delete o.handle,o.events={};for(n in u)for(r=0,i=u[n].length;r<i;r++)v.event.add(t,n,u[n][r])}o.data&&(o.data=v.extend({},o.data))}function Ot(e,t){var n;if(t.nodeType!==1)return;t.clearAttributes&&t.clearAttributes(),t.mergeAttributes&&t.mergeAttributes(e),n=t.nodeName.toLowerCase(),n==="object"?(t.parentNode&&(t.outerHTML=e.outerHTML),v.support.html5Clone&&e.innerHTML&&!v.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):n==="input"&&Et.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):n==="option"?t.selected=e.defaultSelected:n==="input"||n==="textarea"?t.defaultValue=e.defaultValue:n==="script"&&t.text!==e.text&&(t.text=e.text),t.removeAttribute(v.expando)}function Mt(e){return typeof e.getElementsByTagName!="undefined"?e.getElementsByTagName("*"):typeof e.querySelectorAll!="undefined"?e.querySelectorAll("*"):[]}function _t(e){Et.test(e.type)&&(e.defaultChecked=e.checked)}function Qt(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Jt.length;while(i--){t=Jt[i]+n;if(t in e)return t}return r}function Gt(e,t){return e=t||e,v.css(e,"display")==="none"||!v.contains(e.ownerDocument,e)}function Yt(e,t){var n,r,i=[],s=0,o=e.length;for(;s<o;s++){n=e[s];if(!n.style)continue;i[s]=v._data(n,"olddisplay"),t?(!i[s]&&n.style.display==="none"&&(n.style.display=""),n.style.display===""&&Gt(n)&&(i[s]=v._data(n,"olddisplay",nn(n.nodeName)))):(r=Dt(n,"display"),!i[s]&&r!=="none"&&v._data(n,"olddisplay",r))}for(s=0;s<o;s++){n=e[s];if(!n.style)continue;if(!t||n.style.display==="none"||n.style.display==="")n.style.display=t?i[s]||"":"none"}return e}function Zt(e,t,n){var r=Rt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function en(e,t,n,r){var i=n===(r?"border":"content")?4:t==="width"?1:0,s=0;for(;i<4;i+=2)n==="margin"&&(s+=v.css(e,n+$t[i],!0)),r?(n==="content"&&(s-=parseFloat(Dt(e,"padding"+$t[i]))||0),n!=="margin"&&(s-=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0)):(s+=parseFloat(Dt(e,"padding"+$t[i]))||0,n!=="padding"&&(s+=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0));return s}function tn(e,t,n){var r=t==="width"?e.offsetWidth:e.offsetHeight,i=!0,s=v.support.boxSizing&&v.css(e,"boxSizing")==="border-box";if(r<=0||r==null){r=Dt(e,t);if(r<0||r==null)r=e.style[t];if(Ut.test(r))return r;i=s&&(v.support.boxSizingReliable||r===e.style[t]),r=parseFloat(r)||0}return r+en(e,t,n||(s?"border":"content"),i)+"px"}function nn(e){if(Wt[e])return Wt[e];var t=v("<"+e+">").appendTo(i.body),n=t.css("display");t.remove();if(n==="none"||n===""){Pt=i.body.appendChild(Pt||v.extend(i.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!Ht||!Pt.createElement)Ht=(Pt.contentWindow||Pt.contentDocument).document,Ht.write("<!doctype html><html><body>"),Ht.close();t=Ht.body.appendChild(Ht.createElement(e)),n=Dt(t,"display"),i.body.removeChild(Pt)}return Wt[e]=n,n}function fn(e,t,n,r){var i;if(v.isArray(t))v.each(t,function(t,i){n||sn.test(e)?r(e,i):fn(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&v.type(t)==="object")for(i in t)fn(e+"["+i+"]",t[i],n,r);else r(e,t)}function Cn(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i,s,o=t.toLowerCase().split(y),u=0,a=o.length;if(v.isFunction(n))for(;u<a;u++)r=o[u],s=/^\+/.test(r),s&&(r=r.substr(1)||"*"),i=e[r]=e[r]||[],i[s?"unshift":"push"](n)}}function kn(e,n,r,i,s,o){s=s||n.dataTypes[0],o=o||{},o[s]=!0;var u,a=e[s],f=0,l=a?a.length:0,c=e===Sn;for(;f<l&&(c||!u);f++)u=a[f](n,r,i),typeof u=="string"&&(!c||o[u]?u=t:(n.dataTypes.unshift(u),u=kn(e,n,r,i,u,o)));return(c||!u)&&!o["*"]&&(u=kn(e,n,r,i,"*",o)),u}function Ln(e,n){var r,i,s=v.ajaxSettings.flatOptions||{};for(r in n)n[r]!==t&&((s[r]?e:i||(i={}))[r]=n[r]);i&&v.extend(!0,e,i)}function An(e,n,r){var i,s,o,u,a=e.contents,f=e.dataTypes,l=e.responseFields;for(s in l)s in r&&(n[l[s]]=r[s]);while(f[0]==="*")f.shift(),i===t&&(i=e.mimeType||n.getResponseHeader("content-type"));if(i)for(s in a)if(a[s]&&a[s].test(i)){f.unshift(s);break}if(f[0]in r)o=f[0];else{for(s in r){if(!f[0]||e.converters[s+" "+f[0]]){o=s;break}u||(u=s)}o=o||u}if(o)return o!==f[0]&&f.unshift(o),r[o]}function On(e,t){var n,r,i,s,o=e.dataTypes.slice(),u=o[0],a={},f=0;e.dataFilter&&(t=e.dataFilter(t,e.dataType));if(o[1])for(n in e.converters)a[n.toLowerCase()]=e.converters[n];for(;i=o[++f];)if(i!=="*"){if(u!=="*"&&u!==i){n=a[u+" "+i]||a["* "+i];if(!n)for(r in a){s=r.split(" ");if(s[1]===i){n=a[u+" "+s[0]]||a["* "+s[0]];if(n){n===!0?n=a[r]:a[r]!==!0&&(i=s[0],o.splice(f--,0,i));break}}}if(n!==!0)if(n&&e["throws"])t=n(t);else try{t=n(t)}catch(l){return{state:"parsererror",error:n?l:"No conversion from "+u+" to "+i}}}u=i}return{state:"success",data:t}}function Fn(){try{return new e.XMLHttpRequest}catch(t){}}function In(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function $n(){return setTimeout(function(){qn=t},0),qn=v.now()}function Jn(e,t){v.each(t,function(t,n){var r=(Vn[t]||[]).concat(Vn["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function Kn(e,t,n){var r,i=0,s=0,o=Xn.length,u=v.Deferred().always(function(){delete a.elem}),a=function(){var t=qn||$n(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,i=1-r,s=0,o=f.tweens.length;for(;s<o;s++)f.tweens[s].run(i);return u.notifyWith(e,[f,i,n]),i<1&&o?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:v.extend({},t),opts:v.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:qn||$n(),duration:n.duration,tweens:[],createTween:function(t,n,r){var i=v.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(i),i},stop:function(t){var n=0,r=t?f.tweens.length:0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;Qn(l,f.opts.specialEasing);for(;i<o;i++){r=Xn[i].call(f,e,l,f.opts);if(r)return r}return Jn(f,l),v.isFunction(f.opts.start)&&f.opts.start.call(e,f),v.fx.timer(v.extend(a,{anim:f,queue:f.opts.queue,elem:e})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function Qn(e,t){var n,r,i,s,o;for(n in e){r=v.camelCase(n),i=t[r],s=e[n],v.isArray(s)&&(i=s[1],s=e[n]=s[0]),n!==r&&(e[r]=s,delete e[n]),o=v.cssHooks[r];if(o&&"expand"in o){s=o.expand(s),delete e[r];for(n in s)n in e||(e[n]=s[n],t[n]=i)}else t[r]=i}}function Gn(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},m=[],g=e.nodeType&&Gt(e);n.queue||(l=v._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,v.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],v.css(e,"display")==="inline"&&v.css(e,"float")==="none"&&(!v.support.inlineBlockNeedsLayout||nn(e.nodeName)==="inline"?p.display="inline-block":p.zoom=1)),n.overflow&&(p.overflow="hidden",v.support.shrinkWrapBlocks||h.done(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t){s=t[r];if(Un.exec(s)){delete t[r],a=a||s==="toggle";if(s===(g?"hide":"show"))continue;m.push(r)}}o=m.length;if(o){u=v._data(e,"fxshow")||v._data(e,"fxshow",{}),"hidden"in u&&(g=u.hidden),a&&(u.hidden=!g),g?v(e).show():h.done(function(){v(e).hide()}),h.done(function(){var t;v.removeData(e,"fxshow",!0);for(t in d)v.style(e,t,d[t])});for(r=0;r<o;r++)i=m[r],f=h.createTween(i,g?u[i]:0),d[i]=u[i]||v.style(e,i),i in u||(u[i]=f.start,g&&(f.end=f.start,f.start=i==="width"||i==="height"?1:0))}}function Yn(e,t,n,r,i){return new Yn.prototype.init(e,t,n,r,i)}function Zn(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=$t[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function tr(e){return v.isWindow(e)?e:e.nodeType===9?e.defaultView||e.parentWindow:!1}var n,r,i=e.document,s=e.location,o=e.navigator,u=e.jQuery,a=e.$,f=Array.prototype.push,l=Array.prototype.slice,c=Array.prototype.indexOf,h=Object.prototype.toString,p=Object.prototype.hasOwnProperty,d=String.prototype.trim,v=function(e,t){return new v.fn.init(e,t,n)},m=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,g=/\S/,y=/\s+/,b=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,w=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,E=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,S=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,T=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,N=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,C=/^-ms-/,k=/-([\da-z])/gi,L=function(e,t){return(t+"").toUpperCase()},A=function(){i.addEventListener?(i.removeEventListener("DOMContentLoaded",A,!1),v.ready()):i.readyState==="complete"&&(i.detachEvent("onreadystatechange",A),v.ready())},O={};v.fn=v.prototype={constructor:v,init:function(e,n,r){var s,o,u,a;if(!e)return this;if(e.nodeType)return this.context=this[0]=e,this.length=1,this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?s=[null,e,null]:s=w.exec(e);if(s&&(s[1]||!n)){if(s[1])return n=n instanceof v?n[0]:n,a=n&&n.nodeType?n.ownerDocument||n:i,e=v.parseHTML(s[1],a,!0),E.test(s[1])&&v.isPlainObject(n)&&this.attr.call(e,n,!0),v.merge(this,e);o=i.getElementById(s[2]);if(o&&o.parentNode){if(o.id!==s[2])return r.find(e);this.length=1,this[0]=o}return this.context=i,this.selector=e,this}return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e)}return v.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),v.makeArray(e,this))},selector:"",jquery:"1.8.3",length:0,size:function(){return this.length},toArray:function(){return l.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e,t,n){var r=v.merge(this.constructor(),e);return r.prevObject=this,r.context=this.context,t==="find"?r.selector=this.selector+(this.selector?" ":"")+n:t&&(r.selector=this.selector+"."+t+"("+n+")"),r},each:function(e,t){return v.each(this,e,t)},ready:function(e){return v.ready.promise().done(e),this},eq:function(e){return e=+e,e===-1?this.slice(e):this.slice(e,e+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(l.apply(this,arguments),"slice",l.call(arguments).join(","))},map:function(e){return this.pushStack(v.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:[].sort,splice:[].splice},v.fn.init.prototype=v.fn,v.extend=v.fn.extend=function(){var e,n,r,i,s,o,u=arguments[0]||{},a=1,f=arguments.length,l=!1;typeof u=="boolean"&&(l=u,u=arguments[1]||{},a=2),typeof u!="object"&&!v.isFunction(u)&&(u={}),f===a&&(u=this,--a);for(;a<f;a++)if((e=arguments[a])!=null)for(n in e){r=u[n],i=e[n];if(u===i)continue;l&&i&&(v.isPlainObject(i)||(s=v.isArray(i)))?(s?(s=!1,o=r&&v.isArray(r)?r:[]):o=r&&v.isPlainObject(r)?r:{},u[n]=v.extend(l,o,i)):i!==t&&(u[n]=i)}return u},v.extend({noConflict:function(t){return e.$===v&&(e.$=a),t&&e.jQuery===v&&(e.jQuery=u),v},isReady:!1,readyWait:1,holdReady:function(e){e?v.readyWait++:v.ready(!0)},ready:function(e){if(e===!0?--v.readyWait:v.isReady)return;if(!i.body)return setTimeout(v.ready,1);v.isReady=!0;if(e!==!0&&--v.readyWait>0)return;r.resolveWith(i,[v]),v.fn.trigger&&v(i).trigger("ready").off("ready")},isFunction:function(e){return v.type(e)==="function"},isArray:Array.isArray||function(e){return v.type(e)==="array"},isWindow:function(e){return e!=null&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):O[h.call(e)]||"object"},isPlainObject:function(e){if(!e||v.type(e)!=="object"||e.nodeType||v.isWindow(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||p.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){var r;return!e||typeof e!="string"?null:(typeof t=="boolean"&&(n=t,t=0),t=t||i,(r=E.exec(e))?[t.createElement(r[1])]:(r=v.buildFragment([e],t,n?null:[]),v.merge([],(r.cacheable?v.clone(r.fragment):r.fragment).childNodes)))},parseJSON:function(t){if(!t||typeof t!="string")return null;t=v.trim(t);if(e.JSON&&e.JSON.parse)return e.JSON.parse(t);if(S.test(t.replace(T,"@").replace(N,"]").replace(x,"")))return(new Function("return "+t))();v.error("Invalid JSON: "+t)},parseXML:function(n){var r,i;if(!n||typeof n!="string")return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(s){r=t}return(!r||!r.documentElement||r.getElementsByTagName("parsererror").length)&&v.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&g.test(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(C,"ms-").replace(k,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,n,r){var i,s=0,o=e.length,u=o===t||v.isFunction(e);if(r){if(u){for(i in e)if(n.apply(e[i],r)===!1)break}else for(;s<o;)if(n.apply(e[s++],r)===!1)break}else if(u){for(i in e)if(n.call(e[i],i,e[i])===!1)break}else for(;s<o;)if(n.call(e[s],s,e[s++])===!1)break;return e},trim:d&&!d.call("\ufeff\u00a0")?function(e){return e==null?"":d.call(e)}:function(e){return e==null?"":(e+"").replace(b,"")},makeArray:function(e,t){var n,r=t||[];return e!=null&&(n=v.type(e),e.length==null||n==="string"||n==="function"||n==="regexp"||v.isWindow(e)?f.call(r,e):v.merge(r,e)),r},inArray:function(e,t,n){var r;if(t){if(c)return c.call(t,e,n);r=t.length,n=n?n<0?Math.max(0,r+n):n:0;for(;n<r;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,s=0;if(typeof r=="number")for(;s<r;s++)e[i++]=n[s];else while(n[s]!==t)e[i++]=n[s++];return e.length=i,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,n,r){var i,s,o=[],u=0,a=e.length,f=e instanceof v||a!==t&&typeof a=="number"&&(a>0&&e[0]&&e[a-1]||a===0||v.isArray(e));if(f)for(;u<a;u++)i=n(e[u],u,r),i!=null&&(o[o.length]=i);else for(s in e)i=n(e[s],s,r),i!=null&&(o[o.length]=i);return o.concat.apply([],o)},guid:1,proxy:function(e,n){var r,i,s;return typeof n=="string"&&(r=e[n],n=e,e=r),v.isFunction(e)?(i=l.call(arguments,2),s=function(){return e.apply(n,i.concat(l.call(arguments)))},s.guid=e.guid=e.guid||v.guid++,s):t},access:function(e,n,r,i,s,o,u){var a,f=r==null,l=0,c=e.length;if(r&&typeof r=="object"){for(l in r)v.access(e,n,l,r[l],1,o,i);s=1}else if(i!==t){a=u===t&&v.isFunction(i),f&&(a?(a=n,n=function(e,t,n){return a.call(v(e),n)}):(n.call(e,i),n=null));if(n)for(;l<c;l++)n(e[l],r,a?i.call(e[l],l,n(e[l],r)):i,u);s=1}return s?e:f?n.call(e):c?n(e[0],r):o},now:function(){return(new Date).getTime()}}),v.ready.promise=function(t){if(!r){r=v.Deferred();if(i.readyState==="complete")setTimeout(v.ready,1);else if(i.addEventListener)i.addEventListener("DOMContentLoaded",A,!1),e.addEventListener("load",v.ready,!1);else{i.attachEvent("onreadystatechange",A),e.attachEvent("onload",v.ready);var n=!1;try{n=e.frameElement==null&&i.documentElement}catch(s){}n&&n.doScroll&&function o(){if(!v.isReady){try{n.doScroll("left")}catch(e){return setTimeout(o,50)}v.ready()}}()}}return r.promise(t)},v.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(e,t){O["[object "+t+"]"]=t.toLowerCase()}),n=v(i);var M={};v.Callbacks=function(e){e=typeof e=="string"?M[e]||_(e):v.extend({},e);var n,r,i,s,o,u,a=[],f=!e.once&&[],l=function(t){n=e.memory&&t,r=!0,u=s||0,s=0,o=a.length,i=!0;for(;a&&u<o;u++)if(a[u].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}i=!1,a&&(f?f.length&&l(f.shift()):n?a=[]:c.disable())},c={add:function(){if(a){var t=a.length;(function r(t){v.each(t,function(t,n){var i=v.type(n);i==="function"?(!e.unique||!c.has(n))&&a.push(n):n&&n.length&&i!=="string"&&r(n)})})(arguments),i?o=a.length:n&&(s=t,l(n))}return this},remove:function(){return a&&v.each(arguments,function(e,t){var n;while((n=v.inArray(t,a,n))>-1)a.splice(n,1),i&&(n<=o&&o--,n<=u&&u--)}),this},has:function(e){return v.inArray(e,a)>-1},empty:function(){return a=[],this},disable:function(){return a=f=n=t,this},disabled:function(){return!a},lock:function(){return f=t,n||c.disable(),this},locked:function(){return!f},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],a&&(!r||f)&&(i?f.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},v.extend({Deferred:function(e){var t=[["resolve","done",v.Callbacks("once memory"),"resolved"],["reject","fail",v.Callbacks("once memory"),"rejected"],["notify","progress",v.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return v.Deferred(function(n){v.each(t,function(t,r){var s=r[0],o=e[t];i[r[1]](v.isFunction(o)?function(){var e=o.apply(this,arguments);e&&v.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===i?n:this,[e])}:n[s])}),e=null}).promise()},promise:function(e){return e!=null?v.extend(e,r):r}},i={};return r.pipe=r.then,v.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=o.fire,i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=l.call(arguments),r=n.length,i=r!==1||e&&v.isFunction(e.promise)?r:0,s=i===1?e:v.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?l.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&v.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),v.support=function(){var t,n,r,s,o,u,a,f,l,c,h,p=i.createElement("div");p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=p.getElementsByTagName("*"),r=p.getElementsByTagName("a")[0];if(!n||!r||!n.length)return{};s=i.createElement("select"),o=s.appendChild(i.createElement("option")),u=p.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:r.getAttribute("href")==="/a",opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:u.value==="on",optSelected:o.selected,getSetAttribute:p.className!=="t",enctype:!!i.createElement("form").enctype,html5Clone:i.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:i.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},u.checked=!0,t.noCloneChecked=u.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!o.disabled;try{delete p.test}catch(d){t.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",h=function(){t.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick"),p.detachEvent("onclick",h)),u=i.createElement("input"),u.value="t",u.setAttribute("type","radio"),t.radioValue=u.value==="t",u.setAttribute("checked","checked"),u.setAttribute("name","t"),p.appendChild(u),a=i.createDocumentFragment(),a.appendChild(p.lastChild),t.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,t.appendChecked=u.checked,a.removeChild(u),a.appendChild(p);if(p.attachEvent)for(l in{submit:!0,change:!0,focusin:!0})f="on"+l,c=f in p,c||(p.setAttribute(f,"return;"),c=typeof p[f]=="function"),t[l+"Bubbles"]=c;return v(function(){var n,r,s,o,u="padding:0;margin:0;border:0;display:block;overflow:hidden;",a=i.getElementsByTagName("body")[0];if(!a)return;n=i.createElement("div"),n.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",a.insertBefore(n,a.firstChild),r=i.createElement("div"),n.appendChild(r),r.innerHTML="<table><tr><td></td><td>t</td></tr></table>",s=r.getElementsByTagName("td"),s[0].style.cssText="padding:0;margin:0;border:0;display:none",c=s[0].offsetHeight===0,s[0].style.display="",s[1].style.display="none",t.reliableHiddenOffsets=c&&s[0].offsetHeight===0,r.innerHTML="",r.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=r.offsetWidth===4,t.doesNotIncludeMarginInBodyOffset=a.offsetTop!==1,e.getComputedStyle&&(t.pixelPosition=(e.getComputedStyle(r,null)||{}).top!=="1%",t.boxSizingReliable=(e.getComputedStyle(r,null)||{width:"4px"}).width==="4px",o=i.createElement("div"),o.style.cssText=r.style.cssText=u,o.style.marginRight=o.style.width="0",r.style.width="1px",r.appendChild(o),t.reliableMarginRight=!parseFloat((e.getComputedStyle(o,null)||{}).marginRight)),typeof r.style.zoom!="undefined"&&(r.innerHTML="",r.style.cssText=u+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=r.offsetWidth===3,r.style.display="block",r.style.overflow="visible",r.innerHTML="<div></div>",r.firstChild.style.width="5px",t.shrinkWrapBlocks=r.offsetWidth!==3,n.style.zoom=1),a.removeChild(n),n=r=s=o=null}),a.removeChild(p),n=r=s=o=u=a=p=null,t}();var D=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;v.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(v.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?v.cache[e[v.expando]]:e[v.expando],!!e&&!B(e)},data:function(e,n,r,i){if(!v.acceptData(e))return;var s,o,u=v.expando,a=typeof n=="string",f=e.nodeType,l=f?v.cache:e,c=f?e[u]:e[u]&&u;if((!c||!l[c]||!i&&!l[c].data)&&a&&r===t)return;c||(f?e[u]=c=v.deletedIds.pop()||v.guid++:c=u),l[c]||(l[c]={},f||(l[c].toJSON=v.noop));if(typeof n=="object"||typeof n=="function")i?l[c]=v.extend(l[c],n):l[c].data=v.extend(l[c].data,n);return s=l[c],i||(s.data||(s.data={}),s=s.data),r!==t&&(s[v.camelCase(n)]=r),a?(o=s[n],o==null&&(o=s[v.camelCase(n)])):o=s,o},removeData:function(e,t,n){if(!v.acceptData(e))return;var r,i,s,o=e.nodeType,u=o?v.cache:e,a=o?e[v.expando]:v.expando;if(!u[a])return;if(t){r=n?u[a]:u[a].data;if(r){v.isArray(t)||(t in r?t=[t]:(t=v.camelCase(t),t in r?t=[t]:t=t.split(" ")));for(i=0,s=t.length;i<s;i++)delete r[t[i]];if(!(n?B:v.isEmptyObject)(r))return}}if(!n){delete u[a].data;if(!B(u[a]))return}o?v.cleanData([e],!0):v.support.deleteExpando||u!=u.window?delete u[a]:u[a]=null},_data:function(e,t,n){return v.data(e,t,n,!0)},acceptData:function(e){var t=e.nodeName&&v.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),v.fn.extend({data:function(e,n){var r,i,s,o,u,a=this[0],f=0,l=null;if(e===t){if(this.length){l=v.data(a);if(a.nodeType===1&&!v._data(a,"parsedAttrs")){s=a.attributes;for(u=s.length;f<u;f++)o=s[f].name,o.indexOf("data-")||(o=v.camelCase(o.substring(5)),H(a,o,l[o]));v._data(a,"parsedAttrs",!0)}}return l}return typeof e=="object"?this.each(function(){v.data(this,e)}):(r=e.split(".",2),r[1]=r[1]?"."+r[1]:"",i=r[1]+"!",v.access(this,function(n){if(n===t)return l=this.triggerHandler("getData"+i,[r[0]]),l===t&&a&&(l=v.data(a,e),l=H(a,e,l)),l===t&&r[1]?this.data(r[0]):l;r[1]=n,this.each(function(){var t=v(this);t.triggerHandler("setData"+i,r),v.data(this,e,n),t.triggerHandler("changeData"+i,r)})},null,n,arguments.length>1,null,!1))},removeData:function(e){return this.each(function(){v.removeData(this,e)})}}),v.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=v._data(e,t),n&&(!r||v.isArray(n)?r=v._data(e,t,v.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=v.queue(e,t),r=n.length,i=n.shift(),s=v._queueHooks(e,t),o=function(){v.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return v._data(e,n)||v._data(e,n,{empty:v.Callbacks("once memory").add(function(){v.removeData(e,t+"queue",!0),v.removeData(e,n,!0)})})}}),v.fn.extend({queue:function(e,n){var r=2;return typeof e!="string"&&(n=e,e="fx",r--),arguments.length<r?v.queue(this[0],e):n===t?this:this.each(function(){var t=v.queue(this,e,n);v._queueHooks(this,e),e==="fx"&&t[0]!=="inprogress"&&v.dequeue(this,e)})},dequeue:function(e){return this.each(function(){v.dequeue(this,e)})},delay:function(e,t){return e=v.fx?v.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,s=v.Deferred(),o=this,u=this.length,a=function(){--i||s.resolveWith(o,[o])};typeof e!="string"&&(n=e,e=t),e=e||"fx";while(u--)r=v._data(o[u],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(a));return a(),s.promise(n)}});var j,F,I,q=/[\t\r\n]/g,R=/\r/g,U=/^(?:button|input)$/i,z=/^(?:button|input|object|select|textarea)$/i,W=/^a(?:rea|)$/i,X=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,V=v.support.getSetAttribute;v.fn.extend({attr:function(e,t){return v.access(this,v.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){v.removeAttr(this,e)})},prop:function(e,t){return v.access(this,v.prop,e,t,arguments.length>1)},removeProp:function(e){return e=v.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,s,o,u;if(v.isFunction(e))return this.each(function(t){v(this).addClass(e.call(this,t,this.className))});if(e&&typeof e=="string"){t=e.split(y);for(n=0,r=this.length;n<r;n++){i=this[n];if(i.nodeType===1)if(!i.className&&t.length===1)i.className=e;else{s=" "+i.className+" ";for(o=0,u=t.length;o<u;o++)s.indexOf(" "+t[o]+" ")<0&&(s+=t[o]+" ");i.className=v.trim(s)}}}return this},removeClass:function(e){var n,r,i,s,o,u,a;if(v.isFunction(e))return this.each(function(t){v(this).removeClass(e.call(this,t,this.className))});if(e&&typeof e=="string"||e===t){n=(e||"").split(y);for(u=0,a=this.length;u<a;u++){i=this[u];if(i.nodeType===1&&i.className){r=(" "+i.className+" ").replace(q," ");for(s=0,o=n.length;s<o;s++)while(r.indexOf(" "+n[s]+" ")>=0)r=r.replace(" "+n[s]+" "," ");i.className=e?v.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return v.isFunction(e)?this.each(function(n){v(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var i,s=0,o=v(this),u=t,a=e.split(y);while(i=a[s++])u=r?u:!o.hasClass(i),o[u?"addClass":"removeClass"](i)}else if(n==="undefined"||n==="boolean")this.className&&v._data(this,"__className__",this.className),this.className=this.className||e===!1?"":v._data(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(q," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,s=this[0];if(!arguments.length){if(s)return n=v.valHooks[s.type]||v.valHooks[s.nodeName.toLowerCase()],n&&"get"in n&&(r=n.get(s,"value"))!==t?r:(r=s.value,typeof r=="string"?r.replace(R,""):r==null?"":r);return}return i=v.isFunction(e),this.each(function(r){var s,o=v(this);if(this.nodeType!==1)return;i?s=e.call(this,r,o.val()):s=e,s==null?s="":typeof s=="number"?s+="":v.isArray(s)&&(s=v.map(s,function(e){return e==null?"":e+""})),n=v.valHooks[this.type]||v.valHooks[this.nodeName.toLowerCase()];if(!n||!("set"in n)||n.set(this,s,"value")===t)this.value=s})}}),v.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(v.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!v.nodeName(n.parentNode,"optgroup"))){t=v(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n=v.makeArray(t);return v(e).find("option").each(function(){this.selected=v.inArray(v(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attrFn:{},attr:function(e,n,r,i){var s,o,u,a=e.nodeType;if(!e||a===3||a===8||a===2)return;if(i&&v.isFunction(v.fn[n]))return v(e)[n](r);if(typeof e.getAttribute=="undefined")return v.prop(e,n,r);u=a!==1||!v.isXMLDoc(e),u&&(n=n.toLowerCase(),o=v.attrHooks[n]||(X.test(n)?F:j));if(r!==t){if(r===null){v.removeAttr(e,n);return}return o&&"set"in o&&u&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r)}return o&&"get"in o&&u&&(s=o.get(e,n))!==null?s:(s=e.getAttribute(n),s===null?t:s)},removeAttr:function(e,t){var n,r,i,s,o=0;if(t&&e.nodeType===1){r=t.split(y);for(;o<r.length;o++)i=r[o],i&&(n=v.propFix[i]||i,s=X.test(i),s||v.attr(e,i,""),e.removeAttribute(V?i:n),s&&n in e&&(e[n]=!1))}},attrHooks:{type:{set:function(e,t){if(U.test(e.nodeName)&&e.parentNode)v.error("type property can't be changed");else if(!v.support.radioValue&&t==="radio"&&v.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}},value:{get:function(e,t){return j&&v.nodeName(e,"button")?j.get(e,t):t in e?e.value:null},set:function(e,t,n){if(j&&v.nodeName(e,"button"))return j.set(e,t,n);e.value=t}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,s,o,u=e.nodeType;if(!e||u===3||u===8||u===2)return;return o=u!==1||!v.isXMLDoc(e),o&&(n=v.propFix[n]||n,s=v.propHooks[n]),r!==t?s&&"set"in s&&(i=s.set(e,r,n))!==t?i:e[n]=r:s&&"get"in s&&(i=s.get(e,n))!==null?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):z.test(e.nodeName)||W.test(e.nodeName)&&e.href?0:t}}}}),F={get:function(e,n){var r,i=v.prop(e,n);return i===!0||typeof i!="boolean"&&(r=e.getAttributeNode(n))&&r.nodeValue!==!1?n.toLowerCase():t},set:function(e,t,n){var r;return t===!1?v.removeAttr(e,n):(r=v.propFix[n]||n,r in e&&(e[r]=!0),e.setAttribute(n,n.toLowerCase())),n}},V||(I={name:!0,id:!0,coords:!0},j=v.valHooks.button={get:function(e,n){var r;return r=e.getAttributeNode(n),r&&(I[n]?r.value!=="":r.specified)?r.value:t},set:function(e,t,n){var r=e.getAttributeNode(n);return r||(r=i.createAttribute(n),e.setAttributeNode(r)),r.value=t+""}},v.each(["width","height"],function(e,t){v.attrHooks[t]=v.extend(v.attrHooks[t],{set:function(e,n){if(n==="")return e.setAttribute(t,"auto"),n}})}),v.attrHooks.contenteditable={get:j.get,set:function(e,t,n){t===""&&(t="false"),j.set(e,t,n)}}),v.support.hrefNormalized||v.each(["href","src","width","height"],function(e,n){v.attrHooks[n]=v.extend(v.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return r===null?t:r}})}),v.support.style||(v.attrHooks.style={get:function(e){return e.style.cssText.toLowerCase()||t},set:function(e,t){return e.style.cssText=t+""}}),v.support.optSelected||(v.propHooks.selected=v.extend(v.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),v.support.enctype||(v.propFix.enctype="encoding"),v.support.checkOn||v.each(["radio","checkbox"],function(){v.valHooks[this]={get:function(e){return e.getAttribute("value")===null?"on":e.value}}}),v.each(["radio","checkbox"],function(){v.valHooks[this]=v.extend(v.valHooks[this],{set:function(e,t){if(v.isArray(t))return e.checked=v.inArray(v(e).val(),t)>=0}})});var $=/^(?:textarea|input|select)$/i,J=/^([^\.]*|)(?:\.(.+)|)$/,K=/(?:^|\s)hover(\.\S+|)\b/,Q=/^key/,G=/^(?:mouse|contextmenu)|click/,Y=/^(?:focusinfocus|focusoutblur)$/,Z=function(e){return v.event.special.hover?e:e.replace(K,"mouseenter$1 mouseleave$1")};v.event={add:function(e,n,r,i,s){var o,u,a,f,l,c,h,p,d,m,g;if(e.nodeType===3||e.nodeType===8||!n||!r||!(o=v._data(e)))return;r.handler&&(d=r,r=d.handler,s=d.selector),r.guid||(r.guid=v.guid++),a=o.events,a||(o.events=a={}),u=o.handle,u||(o.handle=u=function(e){return typeof v=="undefined"||!!e&&v.event.triggered===e.type?t:v.event.dispatch.apply(u.elem,arguments)},u.elem=e),n=v.trim(Z(n)).split(" ");for(f=0;f<n.length;f++){l=J.exec(n[f])||[],c=l[1],h=(l[2]||"").split(".").sort(),g=v.event.special[c]||{},c=(s?g.delegateType:g.bindType)||c,g=v.event.special[c]||{},p=v.extend({type:c,origType:l[1],data:i,handler:r,guid:r.guid,selector:s,needsContext:s&&v.expr.match.needsContext.test(s),namespace:h.join(".")},d),m=a[c];if(!m){m=a[c]=[],m.delegateCount=0;if(!g.setup||g.setup.call(e,i,h,u)===!1)e.addEventListener?e.addEventListener(c,u,!1):e.attachEvent&&e.attachEvent("on"+c,u)}g.add&&(g.add.call(e,p),p.handler.guid||(p.handler.guid=r.guid)),s?m.splice(m.delegateCount++,0,p):m.push(p),v.event.global[c]=!0}e=null},global:{},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,m,g=v.hasData(e)&&v._data(e);if(!g||!(h=g.events))return;t=v.trim(Z(t||"")).split(" ");for(s=0;s<t.length;s++){o=J.exec(t[s])||[],u=a=o[1],f=o[2];if(!u){for(u in h)v.event.remove(e,u+t[s],n,r,!0);continue}p=v.event.special[u]||{},u=(r?p.delegateType:p.bindType)||u,d=h[u]||[],l=d.length,f=f?new RegExp("(^|\\.)"+f.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(c=0;c<d.length;c++)m=d[c],(i||a===m.origType)&&(!n||n.guid===m.guid)&&(!f||f.test(m.namespace))&&(!r||r===m.selector||r==="**"&&m.selector)&&(d.splice(c--,1),m.selector&&d.delegateCount--,p.remove&&p.remove.call(e,m));d.length===0&&l!==d.length&&((!p.teardown||p.teardown.call(e,f,g.handle)===!1)&&v.removeEvent(e,u,g.handle),delete h[u])}v.isEmptyObject(h)&&(delete g.handle,v.removeData(e,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(n,r,s,o){if(!s||s.nodeType!==3&&s.nodeType!==8){var u,a,f,l,c,h,p,d,m,g,y=n.type||n,b=[];if(Y.test(y+v.event.triggered))return;y.indexOf("!")>=0&&(y=y.slice(0,-1),a=!0),y.indexOf(".")>=0&&(b=y.split("."),y=b.shift(),b.sort());if((!s||v.event.customEvent[y])&&!v.event.global[y])return;n=typeof n=="object"?n[v.expando]?n:new v.Event(y,n):new v.Event(y),n.type=y,n.isTrigger=!0,n.exclusive=a,n.namespace=b.join("."),n.namespace_re=n.namespace?new RegExp("(^|\\.)"+b.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,h=y.indexOf(":")<0?"on"+y:"";if(!s){u=v.cache;for(f in u)u[f].events&&u[f].events[y]&&v.event.trigger(n,r,u[f].handle.elem,!0);return}n.result=t,n.target||(n.target=s),r=r!=null?v.makeArray(r):[],r.unshift(n),p=v.event.special[y]||{};if(p.trigger&&p.trigger.apply(s,r)===!1)return;m=[[s,p.bindType||y]];if(!o&&!p.noBubble&&!v.isWindow(s)){g=p.delegateType||y,l=Y.test(g+y)?s:s.parentNode;for(c=s;l;l=l.parentNode)m.push([l,g]),c=l;c===(s.ownerDocument||i)&&m.push([c.defaultView||c.parentWindow||e,g])}for(f=0;f<m.length&&!n.isPropagationStopped();f++)l=m[f][0],n.type=m[f][1],d=(v._data(l,"events")||{})[n.type]&&v._data(l,"handle"),d&&d.apply(l,r),d=h&&l[h],d&&v.acceptData(l)&&d.apply&&d.apply(l,r)===!1&&n.preventDefault();return n.type=y,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(s.ownerDocument,r)===!1)&&(y!=="click"||!v.nodeName(s,"a"))&&v.acceptData(s)&&h&&s[y]&&(y!=="focus"&&y!=="blur"||n.target.offsetWidth!==0)&&!v.isWindow(s)&&(c=s[h],c&&(s[h]=null),v.event.triggered=y,s[y](),v.event.triggered=t,c&&(s[h]=c)),n.result}return},dispatch:function(n){n=v.event.fix(n||e.event);var r,i,s,o,u,a,f,c,h,p,d=(v._data(this,"events")||{})[n.type]||[],m=d.delegateCount,g=l.call(arguments),y=!n.exclusive&&!n.namespace,b=v.event.special[n.type]||{},w=[];g[0]=n,n.delegateTarget=this;if(b.preDispatch&&b.preDispatch.call(this,n)===!1)return;if(m&&(!n.button||n.type!=="click"))for(s=n.target;s!=this;s=s.parentNode||this)if(s.disabled!==!0||n.type!=="click"){u={},f=[];for(r=0;r<m;r++)c=d[r],h=c.selector,u[h]===t&&(u[h]=c.needsContext?v(h,this).index(s)>=0:v.find(h,this,null,[s]).length),u[h]&&f.push(c);f.length&&w.push({elem:s,matches:f})}d.length>m&&w.push({elem:this,matches:d.slice(m)});for(r=0;r<w.length&&!n.isPropagationStopped();r++){a=w[r],n.currentTarget=a.elem;for(i=0;i<a.matches.length&&!n.isImmediatePropagationStopped();i++){c=a.matches[i];if(y||!n.namespace&&!c.namespace||n.namespace_re&&n.namespace_re.test(c.namespace))n.data=c.data,n.handleObj=c,o=((v.event.special[c.origType]||{}).handle||c.handler).apply(a.elem,g),o!==t&&(n.result=o,o===!1&&(n.preventDefault(),n.stopPropagation()))}}return b.postDispatch&&b.postDispatch.call(this,n),n.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,s,o,u=n.button,a=n.fromElement;return e.pageX==null&&n.clientX!=null&&(r=e.target.ownerDocument||i,s=r.documentElement,o=r.body,e.pageX=n.clientX+(s&&s.scrollLeft||o&&o.scrollLeft||0)-(s&&s.clientLeft||o&&o.clientLeft||0),e.pageY=n.clientY+(s&&s.scrollTop||o&&o.scrollTop||0)-(s&&s.clientTop||o&&o.clientTop||0)),!e.relatedTarget&&a&&(e.relatedTarget=a===e.target?n.toElement:a),!e.which&&u!==t&&(e.which=u&1?1:u&2?3:u&4?2:0),e}},fix:function(e){if(e[v.expando])return e;var t,n,r=e,s=v.event.fixHooks[e.type]||{},o=s.props?this.props.concat(s.props):this.props;e=v.Event(r);for(t=o.length;t;)n=o[--t],e[n]=r[n];return e.target||(e.target=r.srcElement||i),e.target.nodeType===3&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,r):e},special:{load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(e,t,n){v.isWindow(this)&&(this.onbeforeunload=n)},teardown:function(e,t){this.onbeforeunload===t&&(this.onbeforeunload=null)}}},simulate:function(e,t,n,r){var i=v.extend(new v.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?v.event.trigger(i,null,t):v.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},v.event.handle=v.event.dispatch,v.removeEvent=i.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]=="undefined"&&(e[r]=null),e.detachEvent(r,n))},v.Event=function(e,t){if(!(this instanceof v.Event))return new v.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?tt:et):this.type=e,t&&v.extend(this,t),this.timeStamp=e&&e.timeStamp||v.now(),this[v.expando]=!0},v.Event.prototype={preventDefault:function(){this.isDefaultPrevented=tt;var e=this.originalEvent;if(!e)return;e.preventDefault?e.preventDefault():e.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=tt;var e=this.originalEvent;if(!e)return;e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=tt,this.stopPropagation()},isDefaultPrevented:et,isPropagationStopped:et,isImmediatePropagationStopped:et},v.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){v.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj,o=s.selector;if(!i||i!==r&&!v.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),v.support.submitBubbles||(v.event.special.submit={setup:function(){if(v.nodeName(this,"form"))return!1;v.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=v.nodeName(n,"input")||v.nodeName(n,"button")?n.form:t;r&&!v._data(r,"_submit_attached")&&(v.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),v._data(r,"_submit_attached",!0))})},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&v.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){if(v.nodeName(this,"form"))return!1;v.event.remove(this,"._submit")}}),v.support.changeBubbles||(v.event.special.change={setup:function(){if($.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")v.event.add(this,"propertychange._change",function(e){e.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),v.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),v.event.simulate("change",this,e,!0)});return!1}v.event.add(this,"beforeactivate._change",function(e){var t=e.target;$.test(t.nodeName)&&!v._data(t,"_change_attached")&&(v.event.add(t,"change._change",function(e){this.parentNode&&!e.isSimulated&&!e.isTrigger&&v.event.simulate("change",this.parentNode,e,!0)}),v._data(t,"_change_attached",!0))})},handle:function(e){var t=e.target;if(this!==t||e.isSimulated||e.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return e.handleObj.handler.apply(this,arguments)},teardown:function(){return v.event.remove(this,"._change"),!$.test(this.nodeName)}}),v.support.focusinBubbles||v.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){v.event.simulate(t,e.target,v.event.fix(e),!0)};v.event.special[t]={setup:function(){n++===0&&i.addEventListener(e,r,!0)},teardown:function(){--n===0&&i.removeEventListener(e,r,!0)}}}),v.fn.extend({on:function(e,n,r,i,s){var o,u;if(typeof e=="object"){typeof n!="string"&&(r=r||n,n=t);for(u in e)this.on(u,n,r,e[u],s);return this}r==null&&i==null?(i=n,r=n=t):i==null&&(typeof n=="string"?(i=r,r=t):(i=r,r=n,n=t));if(i===!1)i=et;else if(!i)return this;return s===1&&(o=i,i=function(e){return v().off(e),o.apply(this,arguments)},i.guid=o.guid||(o.guid=v.guid++)),this.each(function(){v.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,s;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,v(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if(typeof e=="object"){for(s in e)this.off(s,n,e[s]);return this}if(n===!1||typeof n=="function")r=n,n=t;return r===!1&&(r=et),this.each(function(){v.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},live:function(e,t,n){return v(this.context).on(e,this.selector,t,n),this},die:function(e,t){return v(this.context).off(e,this.selector||"**",t),this},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){v.event.trigger(e,t,this)})},triggerHandler:function(e,t){if(this[0])return v.event.trigger(e,t,this[0],!0)},toggle:function(e){var t=arguments,n=e.guid||v.guid++,r=0,i=function(n){var i=(v._data(this,"lastToggle"+e.guid)||0)%r;return v._data(this,"lastToggle"+e.guid,i+1),n.preventDefault(),t[i].apply(this,arguments)||!1};i.guid=n;while(r<t.length)t[r++].guid=n;return this.click(i)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){v.fn[t]=function(e,n){return n==null&&(n=e,e=null),arguments.length>0?this.on(t,null,e,n):this.trigger(t)},Q.test(t)&&(v.event.fixHooks[t]=v.event.keyHooks),G.test(t)&&(v.event.fixHooks[t]=v.event.mouseHooks)}),function(e,t){function nt(e,t,n,r){n=n||[],t=t||g;var i,s,a,f,l=t.nodeType;if(!e||typeof e!="string")return n;if(l!==1&&l!==9)return[];a=o(t);if(!a&&!r)if(i=R.exec(e))if(f=i[1]){if(l===9){s=t.getElementById(f);if(!s||!s.parentNode)return n;if(s.id===f)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(f))&&u(t,s)&&s.id===f)return n.push(s),n}else{if(i[2])return S.apply(n,x.call(t.getElementsByTagName(e),0)),n;if((f=i[3])&&Z&&t.getElementsByClassName)return S.apply(n,x.call(t.getElementsByClassName(f),0)),n}return vt(e.replace(j,"$1"),t,n,r,a)}function rt(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function it(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function st(e){return N(function(t){return t=+t,N(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function ot(e,t,n){if(e===t)return n;var r=e.nextSibling;while(r){if(r===t)return-1;r=r.nextSibling}return 1}function ut(e,t){var n,r,s,o,u,a,f,l=L[d][e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=F.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=I.exec(u))s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=r[0].replace(j," ");for(o in i.filter)(r=J[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=o,n.matches=r);if(!n)break}return t?u.length:u?nt.error(e):L(e,a).slice(0)}function at(e,t,r){var i=t.dir,s=r&&t.dir==="parentNode",o=w++;return t.first?function(t,n,r){while(t=t[i])if(s||t.nodeType===1)return e(t,n,r)}:function(t,r,u){if(!u){var a,f=b+" "+o+" ",l=f+n;while(t=t[i])if(s||t.nodeType===1){if((a=t[d])===l)return t.sizset;if(typeof a=="string"&&a.indexOf(f)===0){if(t.sizset)return t}else{t[d]=l;if(e(t,r,u))return t.sizset=!0,t;t.sizset=!1}}}else while(t=t[i])if(s||t.nodeType===1)if(e(t,r,u))return t}}function ft(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function lt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function ct(e,t,n,r,i,s){return r&&!r[d]&&(r=ct(r)),i&&!i[d]&&(i=ct(i,s)),N(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||dt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?lt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=lt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?T.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=lt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):S.apply(o,g)})}function ht(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],a=o?1:0,f=at(function(e){return e===t},u,!0),l=at(function(e){return T.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==c)||((t=n).nodeType?f(e,n,r):l(e,n,r))}];for(;a<s;a++)if(n=i.relative[e[a].type])h=[at(ft(h),n)];else{n=i.filter[e[a].type].apply(null,e[a].matches);if(n[d]){r=++a;for(;r<s;r++)if(i.relative[e[r].type])break;return ct(a>1&&ft(h),a>1&&e.slice(0,a-1).join("").replace(j,"$1"),n,a<r&&ht(e.slice(a,r)),r<s&&ht(e=e.slice(r)),r<s&&e.join(""))}h.push(n)}return ft(h)}function pt(e,t){var r=t.length>0,s=e.length>0,o=function(u,a,f,l,h){var p,d,v,m=[],y=0,w="0",x=u&&[],T=h!=null,N=c,C=u||s&&i.find.TAG("*",h&&a.parentNode||a),k=b+=N==null?1:Math.E;T&&(c=a!==g&&a,n=o.el);for(;(p=C[w])!=null;w++){if(s&&p){for(d=0;v=e[d];d++)if(v(p,a,f)){l.push(p);break}T&&(b=k,n=++o.el)}r&&((p=!v&&p)&&y--,u&&x.push(p))}y+=w;if(r&&w!==y){for(d=0;v=t[d];d++)v(x,m,a,f);if(u){if(y>0)while(w--)!x[w]&&!m[w]&&(m[w]=E.call(l));m=lt(m)}S.apply(l,m),T&&!u&&m.length>0&&y+t.length>1&&nt.uniqueSort(l)}return T&&(b=k,c=N),x};return o.el=0,r?N(o):o}function dt(e,t,n){var r=0,i=t.length;for(;r<i;r++)nt(e,t[r],n);return n}function vt(e,t,n,r,s){var o,u,f,l,c,h=ut(e),p=h.length;if(!r&&h.length===1){u=h[0]=h[0].slice(0);if(u.length>2&&(f=u[0]).type==="ID"&&t.nodeType===9&&!s&&i.relative[u[1].type]){t=i.find.ID(f.matches[0].replace($,""),t,s)[0];if(!t)return n;e=e.slice(u.shift().length)}for(o=J.POS.test(e)?-1:u.length-1;o>=0;o--){f=u[o];if(i.relative[l=f.type])break;if(c=i.find[l])if(r=c(f.matches[0].replace($,""),z.test(u[0].type)&&t.parentNode||t,s)){u.splice(o,1),e=r.length&&u.join("");if(!e)return S.apply(n,x.call(r,0)),n;break}}}return a(e,h)(r,t,s,n,z.test(e)),n}function mt(){}var n,r,i,s,o,u,a,f,l,c,h=!0,p="undefined",d=("sizcache"+Math.random()).replace(".",""),m=String,g=e.document,y=g.documentElement,b=0,w=0,E=[].pop,S=[].push,x=[].slice,T=[].indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},N=function(e,t){return e[d]=t==null||t,e},C=function(){var e={},t=[];return N(function(n,r){return t.push(n)>i.cacheLength&&delete e[t.shift()],e[n+" "]=r},e)},k=C(),L=C(),A=C(),O="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",_=M.replace("w","w#"),D="([*^$|!~]?=)",P="\\["+O+"*("+M+")"+O+"*(?:"+D+O+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+_+")|)|)"+O+"*\\]",H=":("+M+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+P+")|[^:]|\\\\.)*|.*))\\)|)",B=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+O+"*((?:-\\d)?\\d*)"+O+"*\\)|)(?=[^-]|$)",j=new RegExp("^"+O+"+|((?:^|[^\\\\])(?:\\\\.)*)"+O+"+$","g"),F=new RegExp("^"+O+"*,"+O+"*"),I=new RegExp("^"+O+"*([\\x20\\t\\r\\n\\f>+~])"+O+"*"),q=new RegExp(H),R=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,U=/^:not/,z=/[\x20\t\r\n\f]*[+~]/,W=/:not\($/,X=/h\d/i,V=/input|select|textarea|button/i,$=/\\(?!\\)/g,J={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),NAME:new RegExp("^\\[name=['\"]?("+M+")['\"]?\\]"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+H),POS:new RegExp(B,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+O+"*(even|odd|(([+-]|)(\\d*)n|)"+O+"*(?:([+-]|)"+O+"*(\\d+)|))"+O+"*\\)|)","i"),needsContext:new RegExp("^"+O+"*[>+~]|"+B,"i")},K=function(e){var t=g.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}},Q=K(function(e){return e.appendChild(g.createComment("")),!e.getElementsByTagName("*").length}),G=K(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==p&&e.firstChild.getAttribute("href")==="#"}),Y=K(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),Z=K(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!e.getElementsByClassName||!e.getElementsByClassName("e").length?!1:(e.lastChild.className="e",e.getElementsByClassName("e").length===2)}),et=K(function(e){e.id=d+0,e.innerHTML="<a name='"+d+"'></a><div name='"+d+"'></div>",y.insertBefore(e,y.firstChild);var t=g.getElementsByName&&g.getElementsByName(d).length===2+g.getElementsByName(d+0).length;return r=!g.getElementById(d),y.removeChild(e),t});try{x.call(y.childNodes,0)[0].nodeType}catch(tt){x=function(e){var t,n=[];for(;t=this[e];e++)n.push(t);return n}}nt.matches=function(e,t){return nt(e,null,null,t)},nt.matchesSelector=function(e,t){return nt(t,null,null,[e]).length>0},s=nt.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue}else for(;t=e[r];r++)n+=s(t);return n},o=nt.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},u=nt.contains=y.contains?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!(r&&r.nodeType===1&&n.contains&&n.contains(r))}:y.compareDocumentPosition?function(e,t){return t&&!!(e.compareDocumentPosition(t)&16)}:function(e,t){while(t=t.parentNode)if(t===e)return!0;return!1},nt.attr=function(e,t){var n,r=o(e);return r||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):r||Y?e.getAttribute(t):(n=e.getAttributeNode(t),n?typeof e[t]=="boolean"?e[t]?t:null:n.specified?n.value:null:null)},i=nt.selectors={cacheLength:50,createPseudo:N,match:J,attrHandle:G?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},find:{ID:r?function(e,t,n){if(typeof t.getElementById!==p&&!n){var r=t.getElementById(e);return r&&r.parentNode?[r]:[]}}:function(e,n,r){if(typeof n.getElementById!==p&&!r){var i=n.getElementById(e);return i?i.id===e||typeof i.getAttributeNode!==p&&i.getAttributeNode("id").value===e?[i]:t:[]}},TAG:Q?function(e,t){if(typeof t.getElementsByTagName!==p)return t.getElementsByTagName(e)}:function(e,t){var n=t.getElementsByTagName(e);if(e==="*"){var r,i=[],s=0;for(;r=n[s];s++)r.nodeType===1&&i.push(r);return i}return n},NAME:et&&function(e,t){if(typeof t.getElementsByName!==p)return t.getElementsByName(name)},CLASS:Z&&function(e,t,n){if(typeof t.getElementsByClassName!==p&&!n)return t.getElementsByClassName(e)}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace($,""),e[3]=(e[4]||e[5]||"").replace($,""),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1]==="nth"?(e[2]||nt.error(e[0]),e[3]=+(e[3]?e[4]+(e[5]||1):2*(e[2]==="even"||e[2]==="odd")),e[4]=+(e[6]+e[7]||e[2]==="odd")):e[2]&&nt.error(e[0]),e},PSEUDO:function(e){var t,n;if(J.CHILD.test(e[0]))return null;if(e[3])e[2]=e[3];else if(t=e[4])q.test(t)&&(n=ut(t,!0))&&(n=t.indexOf(")",t.length-n)-t.length)&&(t=t.slice(0,n),e[0]=e[0].slice(0,n)),e[2]=t;return e.slice(0,3)}},filter:{ID:r?function(e){return e=e.replace($,""),function(t){return t.getAttribute("id")===e}}:function(e){return e=e.replace($,""),function(t){var n=typeof t.getAttributeNode!==p&&t.getAttributeNode("id");return n&&n.value===e}},TAG:function(e){return e==="*"?function(){return!0}:(e=e.replace($,"").toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[d][e+" "];return t||(t=new RegExp("(^|"+O+")"+e+"("+O+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==p&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r,i){var s=nt.attr(r,e);return s==null?t==="!=":t?(s+="",t==="="?s===n:t==="!="?s!==n:t==="^="?n&&s.indexOf(n)===0:t==="*="?n&&s.indexOf(n)>-1:t==="$="?n&&s.substr(s.length-n.length)===n:t==="~="?(" "+s+" ").indexOf(n)>-1:t==="|="?s===n||s.substr(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r){return e==="nth"?function(e){var t,i,s=e.parentNode;if(n===1&&r===0)return!0;if(s){i=0;for(t=s.firstChild;t;t=t.nextSibling)if(t.nodeType===1){i++;if(e===t)break}}return i-=r,i===n||i%n===0&&i/n>=0}:function(t){var n=t;switch(e){case"only":case"first":while(n=n.previousSibling)if(n.nodeType===1)return!1;if(e==="first")return!0;n=t;case"last":while(n=n.nextSibling)if(n.nodeType===1)return!1;return!0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||nt.error("unsupported pseudo: "+e);return r[d]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?N(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=T.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:N(function(e){var t=[],n=[],r=a(e.replace(j,"$1"));return r[d]?N(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:N(function(e){return function(t){return nt(e,t).length>0}}),contains:N(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},parent:function(e){return!i.pseudos.empty(e)},empty:function(e){var t;e=e.firstChild;while(e){if(e.nodeName>"@"||(t=e.nodeType)===3||t===4)return!1;e=e.nextSibling}return!0},header:function(e){return X.test(e.nodeName)},text:function(e){var t,n;return e.nodeName.toLowerCase()==="input"&&(t=e.type)==="text"&&((n=e.getAttribute("type"))==null||n.toLowerCase()===t)},radio:rt("radio"),checkbox:rt("checkbox"),file:rt("file"),password:rt("password"),image:rt("image"),submit:it("submit"),reset:it("reset"),button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},input:function(e){return V.test(e.nodeName)},focus:function(e){var t=e.ownerDocument;return e===t.activeElement&&(!t.hasFocus||t.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},active:function(e){return e===e.ownerDocument.activeElement},first:st(function(){return[0]}),last:st(function(e,t){return[t-1]}),eq:st(function(e,t,n){return[n<0?n+t:n]}),even:st(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:st(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:st(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:st(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},f=y.compareDocumentPosition?function(e,t){return e===t?(l=!0,0):(!e.compareDocumentPosition||!t.compareDocumentPosition?e.compareDocumentPosition:e.compareDocumentPosition(t)&4)?-1:1}:function(e,t){if(e===t)return l=!0,0;if(e.sourceIndex&&t.sourceIndex)return e.sourceIndex-t.sourceIndex;var n,r,i=[],s=[],o=e.parentNode,u=t.parentNode,a=o;if(o===u)return ot(e,t);if(!o)return-1;if(!u)return 1;while(a)i.unshift(a),a=a.parentNode;a=u;while(a)s.unshift(a),a=a.parentNode;n=i.length,r=s.length;for(var f=0;f<n&&f<r;f++)if(i[f]!==s[f])return ot(i[f],s[f]);return f===n?ot(e,s[f],-1):ot(i[f],t,1)},[0,0].sort(f),h=!l,nt.uniqueSort=function(e){var t,n=[],r=1,i=0;l=h,e.sort(f);if(l){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e},nt.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},a=nt.compile=function(e,t){var n,r=[],i=[],s=A[d][e+" "];if(!s){t||(t=ut(e)),n=t.length;while(n--)s=ht(t[n]),s[d]?r.push(s):i.push(s);s=A(e,pt(i,r))}return s},g.querySelectorAll&&function(){var e,t=vt,n=/'|\\/g,r=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,i=[":focus"],s=[":active"],u=y.matchesSelector||y.mozMatchesSelector||y.webkitMatchesSelector||y.oMatchesSelector||y.msMatchesSelector;K(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||i.push("\\["+O+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||i.push(":checked")}),K(function(e){e.innerHTML="<p test=''></p>",e.querySelectorAll("[test^='']").length&&i.push("[*^$]="+O+"*(?:\"\"|'')"),e.innerHTML="<input type='hidden'/>",e.querySelectorAll(":enabled").length||i.push(":enabled",":disabled")}),i=new RegExp(i.join("|")),vt=function(e,r,s,o,u){if(!o&&!u&&!i.test(e)){var a,f,l=!0,c=d,h=r,p=r.nodeType===9&&e;if(r.nodeType===1&&r.nodeName.toLowerCase()!=="object"){a=ut(e),(l=r.getAttribute("id"))?c=l.replace(n,"\\$&"):r.setAttribute("id",c),c="[id='"+c+"'] ",f=a.length;while(f--)a[f]=c+a[f].join("");h=z.test(e)&&r.parentNode||r,p=a.join(",")}if(p)try{return S.apply(s,x.call(h.querySelectorAll(p),0)),s}catch(v){}finally{l||r.removeAttribute("id")}}return t(e,r,s,o,u)},u&&(K(function(t){e=u.call(t,"div");try{u.call(t,"[test!='']:sizzle"),s.push("!=",H)}catch(n){}}),s=new RegExp(s.join("|")),nt.matchesSelector=function(t,n){n=n.replace(r,"='$1']");if(!o(t)&&!s.test(n)&&!i.test(n))try{var a=u.call(t,n);if(a||e||t.document&&t.document.nodeType!==11)return a}catch(f){}return nt(n,null,null,[t]).length>0})}(),i.pseudos.nth=i.pseudos.eq,i.filters=mt.prototype=i.pseudos,i.setFilters=new mt,nt.attr=v.attr,v.find=nt,v.expr=nt.selectors,v.expr[":"]=v.expr.pseudos,v.unique=nt.uniqueSort,v.text=nt.getText,v.isXMLDoc=nt.isXML,v.contains=nt.contains}(e);var nt=/Until$/,rt=/^(?:parents|prev(?:Until|All))/,it=/^.[^:#\[\.,]*$/,st=v.expr.match.needsContext,ot={children:!0,contents:!0,next:!0,prev:!0};v.fn.extend({find:function(e){var t,n,r,i,s,o,u=this;if(typeof e!="string")return v(e).filter(function(){for(t=0,n=u.length;t<n;t++)if(v.contains(u[t],this))return!0});o=this.pushStack("","find",e);for(t=0,n=this.length;t<n;t++){r=o.length,v.find(e,this[t],o);if(t>0)for(i=r;i<o.length;i++)for(s=0;s<r;s++)if(o[s]===o[i]){o.splice(i--,1);break}}return o},has:function(e){var t,n=v(e,this),r=n.length;return this.filter(function(){for(t=0;t<r;t++)if(v.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1),"not",e)},filter:function(e){return this.pushStack(ft(this,e,!0),"filter",e)},is:function(e){return!!e&&(typeof e=="string"?st.test(e)?v(e,this.context).index(this[0])>=0:v.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=st.test(e)||typeof e!="string"?v(e,t||this.context):0;for(;r<i;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&n.nodeType!==11){if(o?o.index(n)>-1:v.find.matchesSelector(n,e)){s.push(n);break}n=n.parentNode}}return s=s.length>1?v.unique(s):s,this.pushStack(s,"closest",e)},index:function(e){return e?typeof e=="string"?v.inArray(this[0],v(e)):v.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?v(e,t):v.makeArray(e&&e.nodeType?[e]:e),r=v.merge(this.get(),n);return this.pushStack(ut(n[0])||ut(r[0])?r:v.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),v.fn.andSelf=v.fn.addBack,v.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return v.dir(e,"parentNode")},parentsUntil:function(e,t,n){return v.dir(e,"parentNode",n)},next:function(e){return at(e,"nextSibling")},prev:function(e){return at(e,"previousSibling")},nextAll:function(e){return v.dir(e,"nextSibling")},prevAll:function(e){return v.dir(e,"previousSibling")},nextUntil:function(e,t,n){return v.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return v.dir(e,"previousSibling",n)},siblings:function(e){return v.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return v.sibling(e.firstChild)},contents:function(e){return v.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:v.merge([],e.childNodes)}},function(e,t){v.fn[e]=function(n,r){var i=v.map(this,t,n);return nt.test(e)||(r=n),r&&typeof r=="string"&&(i=v.filter(r,i)),i=this.length>1&&!ot[e]?v.unique(i):i,this.length>1&&rt.test(e)&&(i=i.reverse()),this.pushStack(i,e,l.call(arguments).join(","))}}),v.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),t.length===1?v.find.matchesSelector(t[0],e)?[t[0]]:[]:v.find.matches(e,t)},dir:function(e,n,r){var i=[],s=e[n];while(s&&s.nodeType!==9&&(r===t||s.nodeType!==1||!v(s).is(r)))s.nodeType===1&&i.push(s),s=s[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var ct="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",ht=/ jQuery\d+="(?:null|\d+)"/g,pt=/^\s+/,dt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,vt=/<([\w:]+)/,mt=/<tbody/i,gt=/<|&#?\w+;/,yt=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,wt=new RegExp("<(?:"+ct+")[\\s/>]","i"),Et=/^(?:checkbox|radio)$/,St=/checked\s*(?:[^=]|=\s*.checked.)/i,xt=/\/(java|ecma)script/i,Tt=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,Nt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},Ct=lt(i),kt=Ct.appendChild(i.createElement("div"));Nt.optgroup=Nt.option,Nt.tbody=Nt.tfoot=Nt.colgroup=Nt.caption=Nt.thead,Nt.th=Nt.td,v.support.htmlSerialize||(Nt._default=[1,"X<div>","</div>"]),v.fn.extend({text:function(e){return v.access(this,function(e){return e===t?v.text(this):this.empty().append((this[0]&&this[0].ownerDocument||i).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(v.isFunction(e))return this.each(function(t){v(this).wrapAll(e.call(this,t))});if(this[0]){var t=v(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&e.firstChild.nodeType===1)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return v.isFunction(e)?this.each(function(t){v(this).wrapInner(e.call(this,t))}):this.each(function(){var t=v(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=v.isFunction(e);return this.each(function(n){v(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){v.nodeName(this,"body")||v(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(e,this.firstChild)})},before:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(e,this),"before",this.selector)}},after:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this.nextSibling)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(this,e),"after",this.selector)}},remove:function(e,t){var n,r=0;for(;(n=this[r])!=null;r++)if(!e||v.filter(e,[n]).length)!t&&n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),v.cleanData([n])),n.parentNode&&n.parentNode.removeChild(n);return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++){e.nodeType===1&&v.cleanData(e.getElementsByTagName("*"));while(e.firstChild)e.removeChild(e.firstChild)}return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return v.clone(this,e,t)})},html:function(e){return v.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return n.nodeType===1?n.innerHTML.replace(ht,""):t;if(typeof e=="string"&&!yt.test(e)&&(v.support.htmlSerialize||!wt.test(e))&&(v.support.leadingWhitespace||!pt.test(e))&&!Nt[(vt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(dt,"<$1></$2>");try{for(;r<i;r++)n=this[r]||{},n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),n.innerHTML=e);n=0}catch(s){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){return ut(this[0])?this.length?this.pushStack(v(v.isFunction(e)?e():e),"replaceWith",e):this:v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.replaceWith(e.call(this,t,r))}):(typeof e!="string"&&(e=v(e).detach()),this.each(function(){var t=this.nextSibling,n=this.parentNode;v(this).remove(),t?v(t).before(e):v(n).append(e)}))},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=[].concat.apply([],e);var i,s,o,u,a=0,f=e[0],l=[],c=this.length;if(!v.support.checkClone&&c>1&&typeof f=="string"&&St.test(f))return this.each(function(){v(this).domManip(e,n,r)});if(v.isFunction(f))return this.each(function(i){var s=v(this);e[0]=f.call(this,i,n?s.html():t),s.domManip(e,n,r)});if(this[0]){i=v.buildFragment(e,this,l),o=i.fragment,s=o.firstChild,o.childNodes.length===1&&(o=s);if(s){n=n&&v.nodeName(s,"tr");for(u=i.cacheable||c-1;a<c;a++)r.call(n&&v.nodeName(this[a],"table")?Lt(this[a],"tbody"):this[a],a===u?o:v.clone(o,!0,!0))}o=s=null,l.length&&v.each(l,function(e,t){t.src?v.ajax?v.ajax({url:t.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):v.error("no ajax"):v.globalEval((t.text||t.textContent||t.innerHTML||"").replace(Tt,"")),t.parentNode&&t.parentNode.removeChild(t)})}return this}}),v.buildFragment=function(e,n,r){var s,o,u,a=e[0];return n=n||i,n=!n.nodeType&&n[0]||n,n=n.ownerDocument||n,e.length===1&&typeof a=="string"&&a.length<512&&n===i&&a.charAt(0)==="<"&&!bt.test(a)&&(v.support.checkClone||!St.test(a))&&(v.support.html5Clone||!wt.test(a))&&(o=!0,s=v.fragments[a],u=s!==t),s||(s=n.createDocumentFragment(),v.clean(e,n,s,r),o&&(v.fragments[a]=u&&s)),{fragment:s,cacheable:o}},v.fragments={},v.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){v.fn[e]=function(n){var r,i=0,s=[],o=v(n),u=o.length,a=this.length===1&&this[0].parentNode;if((a==null||a&&a.nodeType===11&&a.childNodes.length===1)&&u===1)return o[t](this[0]),this;for(;i<u;i++)r=(i>0?this.clone(!0):this).get(),v(o[i])[t](r),s=s.concat(r);return this.pushStack(s,e,o.selector)}}),v.extend({clone:function(e,t,n){var r,i,s,o;v.support.html5Clone||v.isXMLDoc(e)||!wt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(kt.innerHTML=e.outerHTML,kt.removeChild(o=kt.firstChild));if((!v.support.noCloneEvent||!v.support.noCloneChecked)&&(e.nodeType===1||e.nodeType===11)&&!v.isXMLDoc(e)){Ot(e,o),r=Mt(e),i=Mt(o);for(s=0;r[s];++s)i[s]&&Ot(r[s],i[s])}if(t){At(e,o);if(n){r=Mt(e),i=Mt(o);for(s=0;r[s];++s)At(r[s],i[s])}}return r=i=null,o},clean:function(e,t,n,r){var s,o,u,a,f,l,c,h,p,d,m,g,y=t===i&&Ct,b=[];if(!t||typeof t.createDocumentFragment=="undefined")t=i;for(s=0;(u=e[s])!=null;s++){typeof u=="number"&&(u+="");if(!u)continue;if(typeof u=="string")if(!gt.test(u))u=t.createTextNode(u);else{y=y||lt(t),c=t.createElement("div"),y.appendChild(c),u=u.replace(dt,"<$1></$2>"),a=(vt.exec(u)||["",""])[1].toLowerCase(),f=Nt[a]||Nt._default,l=f[0],c.innerHTML=f[1]+u+f[2];while(l--)c=c.lastChild;if(!v.support.tbody){h=mt.test(u),p=a==="table"&&!h?c.firstChild&&c.firstChild.childNodes:f[1]==="<table>"&&!h?c.childNodes:[];for(o=p.length-1;o>=0;--o)v.nodeName(p[o],"tbody")&&!p[o].childNodes.length&&p[o].parentNode.removeChild(p[o])}!v.support.leadingWhitespace&&pt.test(u)&&c.insertBefore(t.createTextNode(pt.exec(u)[0]),c.firstChild),u=c.childNodes,c.parentNode.removeChild(c)}u.nodeType?b.push(u):v.merge(b,u)}c&&(u=c=y=null);if(!v.support.appendChecked)for(s=0;(u=b[s])!=null;s++)v.nodeName(u,"input")?_t(u):typeof u.getElementsByTagName!="undefined"&&v.grep(u.getElementsByTagName("input"),_t);if(n){m=function(e){if(!e.type||xt.test(e.type))return r?r.push(e.parentNode?e.parentNode.removeChild(e):e):n.appendChild(e)};for(s=0;(u=b[s])!=null;s++)if(!v.nodeName(u,"script")||!m(u))n.appendChild(u),typeof u.getElementsByTagName!="undefined"&&(g=v.grep(v.merge([],u.getElementsByTagName("script")),m),b.splice.apply(b,[s+1,0].concat(g)),s+=g.length)}return b},cleanData:function(e,t){var n,r,i,s,o=0,u=v.expando,a=v.cache,f=v.support.deleteExpando,l=v.event.special;for(;(i=e[o])!=null;o++)if(t||v.acceptData(i)){r=i[u],n=r&&a[r];if(n){if(n.events)for(s in n.events)l[s]?v.event.remove(i,s):v.removeEvent(i,s,n.handle);a[r]&&(delete a[r],f?delete i[u]:i.removeAttribute?i.removeAttribute(u):i[u]=null,v.deletedIds.push(r))}}}}),function(){var e,t;v.uaMatch=function(e){e=e.toLowerCase();var t=/(chrome)[ \/]([\w.]+)/.exec(e)||/(webkit)[ \/]([\w.]+)/.exec(e)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e)||/(msie) ([\w.]+)/.exec(e)||e.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)||[];return{browser:t[1]||"",version:t[2]||"0"}},e=v.uaMatch(o.userAgent),t={},e.browser&&(t[e.browser]=!0,t.version=e.version),t.chrome?t.webkit=!0:t.webkit&&(t.safari=!0),v.browser=t,v.sub=function(){function e(t,n){return new e.fn.init(t,n)}v.extend(!0,e,this),e.superclass=this,e.fn=e.prototype=this(),e.fn.constructor=e,e.sub=this.sub,e.fn.init=function(r,i){return i&&i instanceof v&&!(i instanceof e)&&(i=e(i)),v.fn.init.call(this,r,i,t)},e.fn.init.prototype=e.fn;var t=e(i);return e}}();var Dt,Pt,Ht,Bt=/alpha\([^)]*\)/i,jt=/opacity=([^)]*)/,Ft=/^(top|right|bottom|left)$/,It=/^(none|table(?!-c[ea]).+)/,qt=/^margin/,Rt=new RegExp("^("+m+")(.*)$","i"),Ut=new RegExp("^("+m+")(?!px)[a-z%]+$","i"),zt=new RegExp("^([-+])=("+m+")","i"),Wt={BODY:"block"},Xt={position:"absolute",visibility:"hidden",display:"block"},Vt={letterSpacing:0,fontWeight:400},$t=["Top","Right","Bottom","Left"],Jt=["Webkit","O","Moz","ms"],Kt=v.fn.toggle;v.fn.extend({css:function(e,n){return v.access(this,function(e,n,r){return r!==t?v.style(e,n,r):v.css(e,n)},e,n,arguments.length>1)},show:function(){return Yt(this,!0)},hide:function(){return Yt(this)},toggle:function(e,t){var n=typeof e=="boolean";return v.isFunction(e)&&v.isFunction(t)?Kt.apply(this,arguments):this.each(function(){(n?e:Gt(this))?v(this).show():v(this).hide()})}}),v.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Dt(e,"opacity");return n===""?"1":n}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":v.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var s,o,u,a=v.camelCase(n),f=e.style;n=v.cssProps[a]||(v.cssProps[a]=Qt(f,a)),u=v.cssHooks[n]||v.cssHooks[a];if(r===t)return u&&"get"in u&&(s=u.get(e,!1,i))!==t?s:f[n];o=typeof r,o==="string"&&(s=zt.exec(r))&&(r=(s[1]+1)*s[2]+parseFloat(v.css(e,n)),o="number");if(r==null||o==="number"&&isNaN(r))return;o==="number"&&!v.cssNumber[a]&&(r+="px");if(!u||!("set"in u)||(r=u.set(e,r,i))!==t)try{f[n]=r}catch(l){}},css:function(e,n,r,i){var s,o,u,a=v.camelCase(n);return n=v.cssProps[a]||(v.cssProps[a]=Qt(e.style,a)),u=v.cssHooks[n]||v.cssHooks[a],u&&"get"in u&&(s=u.get(e,!0,i)),s===t&&(s=Dt(e,n)),s==="normal"&&n in Vt&&(s=Vt[n]),r||i!==t?(o=parseFloat(s),r||v.isNumeric(o)?o||0:s):s},swap:function(e,t,n){var r,i,s={};for(i in t)s[i]=e.style[i],e.style[i]=t[i];r=n.call(e);for(i in t)e.style[i]=s[i];return r}}),e.getComputedStyle?Dt=function(t,n){var r,i,s,o,u=e.getComputedStyle(t,null),a=t.style;return u&&(r=u.getPropertyValue(n)||u[n],r===""&&!v.contains(t.ownerDocument,t)&&(r=v.style(t,n)),Ut.test(r)&&qt.test(n)&&(i=a.width,s=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=r,r=u.width,a.width=i,a.minWidth=s,a.maxWidth=o)),r}:i.documentElement.currentStyle&&(Dt=function(e,t){var n,r,i=e.currentStyle&&e.currentStyle[t],s=e.style;return i==null&&s&&s[t]&&(i=s[t]),Ut.test(i)&&!Ft.test(t)&&(n=s.left,r=e.runtimeStyle&&e.runtimeStyle.left,r&&(e.runtimeStyle.left=e.currentStyle.left),s.left=t==="fontSize"?"1em":i,i=s.pixelLeft+"px",s.left=n,r&&(e.runtimeStyle.left=r)),i===""?"auto":i}),v.each(["height","width"],function(e,t){v.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&It.test(Dt(e,"display"))?v.swap(e,Xt,function(){return tn(e,t,r)}):tn(e,t,r)},set:function(e,n,r){return Zt(e,n,r?en(e,t,r,v.support.boxSizing&&v.css(e,"boxSizing")==="border-box"):0)}}}),v.support.opacity||(v.cssHooks.opacity={get:function(e,t){return jt.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=v.isNumeric(t)?"alpha(opacity="+t*100+")":"",s=r&&r.filter||n.filter||"";n.zoom=1;if(t>=1&&v.trim(s.replace(Bt,""))===""&&n.removeAttribute){n.removeAttribute("filter");if(r&&!r.filter)return}n.filter=Bt.test(s)?s.replace(Bt,i):s+" "+i}}),v(function(){v.support.reliableMarginRight||(v.cssHooks.marginRight={get:function(e,t){return v.swap(e,{display:"inline-block"},function(){if(t)return Dt(e,"marginRight")})}}),!v.support.pixelPosition&&v.fn.position&&v.each(["top","left"],function(e,t){v.cssHooks[t]={get:function(e,n){if(n){var r=Dt(e,t);return Ut.test(r)?v(e).position()[t]+"px":r}}}})}),v.expr&&v.expr.filters&&(v.expr.filters.hidden=function(e){return e.offsetWidth===0&&e.offsetHeight===0||!v.support.reliableHiddenOffsets&&(e.style&&e.style.display||Dt(e,"display"))==="none"},v.expr.filters.visible=function(e){return!v.expr.filters.hidden(e)}),v.each({margin:"",padding:"",border:"Width"},function(e,t){v.cssHooks[e+t]={expand:function(n){var r,i=typeof n=="string"?n.split(" "):[n],s={};for(r=0;r<4;r++)s[e+$t[r]+t]=i[r]||i[r-2]||i[0];return s}},qt.test(e)||(v.cssHooks[e+t].set=Zt)});var rn=/%20/g,sn=/\[\]$/,on=/\r?\n/g,un=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,an=/^(?:select|textarea)/i;v.fn.extend({serialize:function(){return v.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?v.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||an.test(this.nodeName)||un.test(this.type))}).map(function(e,t){var n=v(this).val();return n==null?null:v.isArray(n)?v.map(n,function(e,n){return{name:t.name,value:e.replace(on,"\r\n")}}):{name:t.name,value:n.replace(on,"\r\n")}}).get()}}),v.param=function(e,n){var r,i=[],s=function(e,t){t=v.isFunction(t)?t():t==null?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};n===t&&(n=v.ajaxSettings&&v.ajaxSettings.traditional);if(v.isArray(e)||e.jquery&&!v.isPlainObject(e))v.each(e,function(){s(this.name,this.value)});else for(r in e)fn(r,e[r],n,s);return i.join("&").replace(rn,"+")};var ln,cn,hn=/#.*$/,pn=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,dn=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,vn=/^(?:GET|HEAD)$/,mn=/^\/\//,gn=/\?/,yn=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bn=/([?&])_=[^&]*/,wn=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,En=v.fn.load,Sn={},xn={},Tn=["*/"]+["*"];try{cn=s.href}catch(Nn){cn=i.createElement("a"),cn.href="",cn=cn.href}ln=wn.exec(cn.toLowerCase())||[],v.fn.load=function(e,n,r){if(typeof e!="string"&&En)return En.apply(this,arguments);if(!this.length)return this;var i,s,o,u=this,a=e.indexOf(" ");return a>=0&&(i=e.slice(a,e.length),e=e.slice(0,a)),v.isFunction(n)?(r=n,n=t):n&&typeof n=="object"&&(s="POST"),v.ajax({url:e,type:s,dataType:"html",data:n,complete:function(e,t){r&&u.each(r,o||[e.responseText,t,e])}}).done(function(e){o=arguments,u.html(i?v("<div>").append(e.replace(yn,"")).find(i):e)}),this},v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(e,t){v.fn[t]=function(e){return this.on(t,e)}}),v.each(["get","post"],function(e,n){v[n]=function(e,r,i,s){return v.isFunction(r)&&(s=s||i,i=r,r=t),v.ajax({type:n,url:e,data:r,success:i,dataType:s})}}),v.extend({getScript:function(e,n){return v.get(e,t,n,"script")},getJSON:function(e,t,n){return v.get(e,t,n,"json")},ajaxSetup:function(e,t){return t?Ln(e,v.ajaxSettings):(t=e,e=v.ajaxSettings),Ln(e,t),e},ajaxSettings:{url:cn,isLocal:dn.test(ln[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":Tn},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":v.parseJSON,"text xml":v.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:Cn(Sn),ajaxTransport:Cn(xn),ajax:function(e,n){function T(e,n,s,a){var l,y,b,w,S,T=n;if(E===2)return;E=2,u&&clearTimeout(u),o=t,i=a||"",x.readyState=e>0?4:0,s&&(w=An(c,x,s));if(e>=200&&e<300||e===304)c.ifModified&&(S=x.getResponseHeader("Last-Modified"),S&&(v.lastModified[r]=S),S=x.getResponseHeader("Etag"),S&&(v.etag[r]=S)),e===304?(T="notmodified",l=!0):(l=On(c,w),T=l.state,y=l.data,b=l.error,l=!b);else{b=T;if(!T||e)T="error",e<0&&(e=0)}x.status=e,x.statusText=(n||T)+"",l?d.resolveWith(h,[y,T,x]):d.rejectWith(h,[x,T,b]),x.statusCode(g),g=t,f&&p.trigger("ajax"+(l?"Success":"Error"),[x,c,l?y:b]),m.fireWith(h,[x,T]),f&&(p.trigger("ajaxComplete",[x,c]),--v.active||v.event.trigger("ajaxStop"))}typeof e=="object"&&(n=e,e=t),n=n||{};var r,i,s,o,u,a,f,l,c=v.ajaxSetup({},n),h=c.context||c,p=h!==c&&(h.nodeType||h instanceof v)?v(h):v.event,d=v.Deferred(),m=v.Callbacks("once memory"),g=c.statusCode||{},b={},w={},E=0,S="canceled",x={readyState:0,setRequestHeader:function(e,t){if(!E){var n=e.toLowerCase();e=w[n]=w[n]||e,b[e]=t}return this},getAllResponseHeaders:function(){return E===2?i:null},getResponseHeader:function(e){var n;if(E===2){if(!s){s={};while(n=pn.exec(i))s[n[1].toLowerCase()]=n[2]}n=s[e.toLowerCase()]}return n===t?null:n},overrideMimeType:function(e){return E||(c.mimeType=e),this},abort:function(e){return e=e||S,o&&o.abort(e),T(0,e),this}};d.promise(x),x.success=x.done,x.error=x.fail,x.complete=m.add,x.statusCode=function(e){if(e){var t;if(E<2)for(t in e)g[t]=[g[t],e[t]];else t=e[x.status],x.always(t)}return this},c.url=((e||c.url)+"").replace(hn,"").replace(mn,ln[1]+"//"),c.dataTypes=v.trim(c.dataType||"*").toLowerCase().split(y),c.crossDomain==null&&(a=wn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===ln[1]&&a[2]===ln[2]&&(a[3]||(a[1]==="http:"?80:443))==(ln[3]||(ln[1]==="http:"?80:443)))),c.data&&c.processData&&typeof c.data!="string"&&(c.data=v.param(c.data,c.traditional)),kn(Sn,c,n,x);if(E===2)return x;f=c.global,c.type=c.type.toUpperCase(),c.hasContent=!vn.test(c.type),f&&v.active++===0&&v.event.trigger("ajaxStart");if(!c.hasContent){c.data&&(c.url+=(gn.test(c.url)?"&":"?")+c.data,delete c.data),r=c.url;if(c.cache===!1){var N=v.now(),C=c.url.replace(bn,"$1_="+N);c.url=C+(C===c.url?(gn.test(c.url)?"&":"?")+"_="+N:"")}}(c.data&&c.hasContent&&c.contentType!==!1||n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),c.ifModified&&(r=r||c.url,v.lastModified[r]&&x.setRequestHeader("If-Modified-Since",v.lastModified[r]),v.etag[r]&&x.setRequestHeader("If-None-Match",v.etag[r])),x.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+(c.dataTypes[0]!=="*"?", "+Tn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)x.setRequestHeader(l,c.headers[l]);if(!c.beforeSend||c.beforeSend.call(h,x,c)!==!1&&E!==2){S="abort";for(l in{success:1,error:1,complete:1})x[l](c[l]);o=kn(xn,c,n,x);if(!o)T(-1,"No Transport");else{x.readyState=1,f&&p.trigger("ajaxSend",[x,c]),c.async&&c.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},c.timeout));try{E=1,o.send(b,T)}catch(k){if(!(E<2))throw k;T(-1,k)}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var Mn=[],_n=/\?/,Dn=/(=)\?(?=&|$)|\?\?/,Pn=v.now();v.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Mn.pop()||v.expando+"_"+Pn++;return this[e]=!0,e}}),v.ajaxPrefilter("json jsonp",function(n,r,i){var s,o,u,a=n.data,f=n.url,l=n.jsonp!==!1,c=l&&Dn.test(f),h=l&&!c&&typeof a=="string"&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Dn.test(a);if(n.dataTypes[0]==="jsonp"||c||h)return s=n.jsonpCallback=v.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,o=e[s],c?n.url=f.replace(Dn,"$1"+s):h?n.data=a.replace(Dn,"$1"+s):l&&(n.url+=(_n.test(f)?"&":"?")+n.jsonp+"="+s),n.converters["script json"]=function(){return u||v.error(s+" was not called"),u[0]},n.dataTypes[0]="json",e[s]=function(){u=arguments},i.always(function(){e[s]=o,n[s]&&(n.jsonpCallback=r.jsonpCallback,Mn.push(s)),u&&v.isFunction(o)&&o(u[0]),u=o=t}),"script"}),v.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(e){return v.globalEval(e),e}}}),v.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),v.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=i.head||i.getElementsByTagName("head")[0]||i.documentElement;return{send:function(s,o){n=i.createElement("script"),n.async="async",e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,i){if(i||!n.readyState||/loaded|complete/.test(n.readyState))n.onload=n.onreadystatechange=null,r&&n.parentNode&&r.removeChild(n),n=t,i||o(200,"success")},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(0,1)}}}});var Hn,Bn=e.ActiveXObject?function(){for(var e in Hn)Hn[e](0,1)}:!1,jn=0;v.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&Fn()||In()}:Fn,function(e){v.extend(v.support,{ajax:!!e,cors:!!e&&"withCredentials"in e})}(v.ajaxSettings.xhr()),v.support.ajax&&v.ajaxTransport(function(n){if(!n.crossDomain||v.support.cors){var r;return{send:function(i,s){var o,u,a=n.xhr();n.username?a.open(n.type,n.url,n.async,n.username,n.password):a.open(n.type,n.url,n.async);if(n.xhrFields)for(u in n.xhrFields)a[u]=n.xhrFields[u];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),!n.crossDomain&&!i["X-Requested-With"]&&(i["X-Requested-With"]="XMLHttpRequest");try{for(u in i)a.setRequestHeader(u,i[u])}catch(f){}a.send(n.hasContent&&n.data||null),r=function(e,i){var u,f,l,c,h;try{if(r&&(i||a.readyState===4)){r=t,o&&(a.onreadystatechange=v.noop,Bn&&delete Hn[o]);if(i)a.readyState!==4&&a.abort();else{u=a.status,l=a.getAllResponseHeaders(),c={},h=a.responseXML,h&&h.documentElement&&(c.xml=h);try{c.text=a.responseText}catch(p){}try{f=a.statusText}catch(p){f=""}!u&&n.isLocal&&!n.crossDomain?u=c.text?200:404:u===1223&&(u=204)}}}catch(d){i||s(-1,d)}c&&s(u,f,c,l)},n.async?a.readyState===4?setTimeout(r,0):(o=++jn,Bn&&(Hn||(Hn={},v(e).unload(Bn)),Hn[o]=r),a.onreadystatechange=r):r()},abort:function(){r&&r(0,1)}}}});var qn,Rn,Un=/^(?:toggle|show|hide)$/,zn=new RegExp("^(?:([-+])=|)("+m+")([a-z%]*)$","i"),Wn=/queueHooks$/,Xn=[Gn],Vn={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=zn.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(v.cssNumber[e]?"":"px");if(r!=="px"&&u){u=v.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,v.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};v.Animation=v.extend(Kn,{tweener:function(e,t){v.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],Vn[n]=Vn[n]||[],Vn[n].unshift(t)},prefilter:function(e,t){t?Xn.unshift(e):Xn.push(e)}}),v.Tween=Yn,Yn.prototype={constructor:Yn,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(v.cssNumber[n]?"":"px")},cur:function(){var e=Yn.propHooks[this.prop];return e&&e.get?e.get(this):Yn.propHooks._default.get(this)},run:function(e){var t,n=Yn.propHooks[this.prop];return this.options.duration?this.pos=t=v.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Yn.propHooks._default.set(this),this}},Yn.prototype.init.prototype=Yn.prototype,Yn.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=v.css(e.elem,e.prop,!1,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){v.fx.step[e.prop]?v.fx.step[e.prop](e):e.elem.style&&(e.elem.style[v.cssProps[e.prop]]!=null||v.cssHooks[e.prop])?v.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Yn.propHooks.scrollTop=Yn.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},v.each(["toggle","show","hide"],function(e,t){var n=v.fn[t];v.fn[t]=function(r,i,s){return r==null||typeof r=="boolean"||!e&&v.isFunction(r)&&v.isFunction(i)?n.apply(this,arguments):this.animate(Zn(t,!0),r,i,s)}}),v.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Gt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=v.isEmptyObject(e),s=v.speed(t,n,r),o=function(){var t=Kn(this,v.extend({},e),s);i&&t.stop(!0)};return i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return typeof e!="string"&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=e!=null&&e+"queueHooks",s=v.timers,o=v._data(this);if(n)o[n]&&o[n].stop&&i(o[n]);else for(n in o)o[n]&&o[n].stop&&Wn.test(n)&&i(o[n]);for(n=s.length;n--;)s[n].elem===this&&(e==null||s[n].queue===e)&&(s[n].anim.stop(r),t=!1,s.splice(n,1));(t||!r)&&v.dequeue(this,e)})}}),v.each({slideDown:Zn("show"),slideUp:Zn("hide"),slideToggle:Zn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){v.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),v.speed=function(e,t,n){var r=e&&typeof e=="object"?v.extend({},e):{complete:n||!n&&t||v.isFunction(e)&&e,duration:e,easing:n&&t||t&&!v.isFunction(t)&&t};r.duration=v.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in v.fx.speeds?v.fx.speeds[r.duration]:v.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){v.isFunction(r.old)&&r.old.call(this),r.queue&&v.dequeue(this,r.queue)},r},v.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},v.timers=[],v.fx=Yn.prototype.init,v.fx.tick=function(){var e,n=v.timers,r=0;qn=v.now();for(;r<n.length;r++)e=n[r],!e()&&n[r]===e&&n.splice(r--,1);n.length||v.fx.stop(),qn=t},v.fx.timer=function(e){e()&&v.timers.push(e)&&!Rn&&(Rn=setInterval(v.fx.tick,v.fx.interval))},v.fx.interval=13,v.fx.stop=function(){clearInterval(Rn),Rn=null},v.fx.speeds={slow:600,fast:200,_default:400},v.fx.step={},v.expr&&v.expr.filters&&(v.expr.filters.animated=function(e){return v.grep(v.timers,function(t){return e===t.elem}).length});var er=/^(?:body|html)$/i;v.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){v.offset.setOffset(this,e,t)});var n,r,i,s,o,u,a,f={top:0,left:0},l=this[0],c=l&&l.ownerDocument;if(!c)return;return(r=c.body)===l?v.offset.bodyOffset(l):(n=c.documentElement,v.contains(n,l)?(typeof l.getBoundingClientRect!="undefined"&&(f=l.getBoundingClientRect()),i=tr(c),s=n.clientTop||r.clientTop||0,o=n.clientLeft||r.clientLeft||0,u=i.pageYOffset||n.scrollTop,a=i.pageXOffset||n.scrollLeft,{top:f.top+u-s,left:f.left+a-o}):f)},v.offset={bodyOffset:function(e){var t=e.offsetTop,n=e.offsetLeft;return v.support.doesNotIncludeMarginInBodyOffset&&(t+=parseFloat(v.css(e,"marginTop"))||0,n+=parseFloat(v.css(e,"marginLeft"))||0),{top:t,left:n}},setOffset:function(e,t,n){var r=v.css(e,"position");r==="static"&&(e.style.position="relative");var i=v(e),s=i.offset(),o=v.css(e,"top"),u=v.css(e,"left"),a=(r==="absolute"||r==="fixed")&&v.inArray("auto",[o,u])>-1,f={},l={},c,h;a?(l=i.position(),c=l.top,h=l.left):(c=parseFloat(o)||0,h=parseFloat(u)||0),v.isFunction(t)&&(t=t.call(e,n,s)),t.top!=null&&(f.top=t.top-s.top+c),t.left!=null&&(f.left=t.left-s.left+h),"using"in t?t.using.call(e,f):i.css(f)}},v.fn.extend({position:function(){if(!this[0])return;var e=this[0],t=this.offsetParent(),n=this.offset(),r=er.test(t[0].nodeName)?{top:0,left:0}:t.offset();return n.top-=parseFloat(v.css(e,"marginTop"))||0,n.left-=parseFloat(v.css(e,"marginLeft"))||0,r.top+=parseFloat(v.css(t[0],"borderTopWidth"))||0,r.left+=parseFloat(v.css(t[0],"borderLeftWidth"))||0,{top:n.top-r.top,left:n.left-r.left}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||i.body;while(e&&!er.test(e.nodeName)&&v.css(e,"position")==="static")e=e.offsetParent;return e||i.body})}}),v.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);v.fn[e]=function(i){return v.access(this,function(e,i,s){var o=tr(e);if(s===t)return o?n in o?o[n]:o.document.documentElement[i]:e[i];o?o.scrollTo(r?v(o).scrollLeft():s,r?s:v(o).scrollTop()):e[i]=s},e,i,arguments.length,null)}}),v.each({Height:"height",Width:"width"},function(e,n){v.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){v.fn[i]=function(i,s){var o=arguments.length&&(r||typeof i!="boolean"),u=r||(i===!0||s===!0?"margin":"border");return v.access(this,function(n,r,i){var s;return v.isWindow(n)?n.document.documentElement["client"+e]:n.nodeType===9?(s=n.documentElement,Math.max(n.body["scroll"+e],s["scroll"+e],n.body["offset"+e],s["offset"+e],s["client"+e])):i===t?v.css(n,r,i,u):v.style(n,r,i,u)},n,o?i:t,o,null)}})}),e.jQuery=e.$=v,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return v})})(window);
; browserify_shim__define__module__export__(typeof $ != "undefined" ? $ : window.$);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],245:[function(require,module,exports){
(function (factory) {
    if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals (with support for web workers)
        var glob;

        try {
            glob = window;
        } catch (e) {
            glob = self;
        }

        glob.SparkMD5 = factory();
    }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));

},{}],246:[function(require,module,exports){
/*
 * This script adds cross-document messaging (postMessage) support [1,2], to allow
 * embedding one or many instances of the Tree Illustrator UI in an
 * IPython notebook. This lets us provide tree data from the surrounding
 * IPython session, and save SVG output or complete illustration JSON from each
 * instance.
 *
 * This should be useful in pre-publication and exploratory scenarios for a
 * single user, or fairly easy collaboration, using Wakari or another notebook
 * server.
 *
 * [1] https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
 * [2] http://caniuse.com/#search=postMessage
 */

// notebook window is opener (for separate tab/window) or parent (for IFRAME)
var notebookWindow = window.opener || window.parent;

// TODO: set expected calling domain when instance is created?

function receiveMessage(e) {
    var msg = e.originalEvent;
    /* REMINDER: A message has three properties of interest:
     *   msg.origin is the domain that holds the surrounding IPython notebook
     *   msg.data is its payload
     *   msg.source is the window that sent the message (the notebook viewer)
     */
    if (msg.source !== notebookWindow) {
        console.warn("Expected this message from my notebookWindow (opener or parent)!\n"
                    +"  msg.source="+ msg.source +"\n"
                    +"  notebookWindow="+ notebookWindow
        );
        debugger;
        //return;
    }

    if (!msg.data['method']) {
        alert("Expected a named method in msg.data.method!");
        return;
    }

    if (!msg.data['response']) {
        alert("Expected an object in msg.data.response!");
        return;
    }

    switch(msg.data['method']) {
        case 'addTree':
            var treeData = msg.data['treeData'];
            if (!treeData) {
                alert("No tree data provided!");
                return;
            }
            // TODO
            break;

        case 'dumpCurrentIllustration':
            var targetCell = getTargetCell(msg);
            // TODO
            break;

        case 'dumpCurrentIllustrationSVG':
            var targetCell = getTargetCell(msg);
            // TODO
            break;

        /* Handle callbacks for messages FROM this window */

        case 'getIllustrationList_response':
            getIllustrationList_callback(msg.data.response);
            break;
        case 'loadIllustration_response':
            loadIllustration_callback(msg.data.response);
            break;
        case 'saveIllustration_response':
            saveIllustration_callback(msg.data.response);
            break;
        case 'deleteIllustration_response':
            deleteIllustration_callback(msg.data.response);
            break;

        case 'listAllNotebookVars_response':
            // N.B. the expected callback is named for a general API, not the
            // details of Jupyter notebook.
            getTreeSourceList_callback(msg.data.response);
            break;
        case 'getTreeSourceData_response':
            getTreeSourceData_callback(msg.data.response);
            break;

        default:
            alert("Unexpected method ["+ msg.data.method +"] in this message!");
            return;
    }
}

function getTargetCell(msg) {
    // Return the specified cell, or the next available
    // TODO: what kind of cell reference works for notebook JS?
    //  - nth cell?
    //  - by name or element ID?
    //  v a direct reference? NO, these are not shared across windows
}

console.warn("ADDING event listener (bridge JS) to this window: "+ window.location.href);
//window.addEventListener("message", receiveMessage, false);
$(window).off('message.TreeIllustrator')
         .on('message.TreeIllustrator', receiveMessage);

/* The methods below constitute a general API for the Tree Illustrator. 
 * These should support asynchronous operations via callbacks. When defining
 * function names and arguments, keep in mind that we expect to build parallel
 * implementations in other contexts (e.g., within a dedicated website or the
 * Tools tab of the OpenTree curation app).
 */

// Manage illustrations from the current docstore (in this case, the notebook metadata)

function userHasStorageAccess() {
    // If we're inside a running, editable notebook, anyone can save data.
    return true;
}
// stash callbacks for use by cross-window responses
var getIllustrationList_callback = null,
    loadIllustration_callback = null,
    saveIllustration_callback = null,
    deleteIllustration_callback = null;

function getIllustrationList(callback) {
    getIllustrationList_callback = callback;

    notebookWindow.postMessage({
        method: 'getIllustrationList'
    }, 
    '*');  // TODO: restrict to this particular notebook's domain?
}

function loadIllustration(id, callback) {
    loadIllustration_callback = callback;

    notebookWindow.postMessage({
        method: 'loadIllustration',
        uniqueID: id
    }, 
    '*');  // TODO: restrict to this particular notebook's domain?
}

function saveIllustration(forcePosition, callback) {
    // TODO: support save, save-as, copy?
    saveIllustration_callback = callback;

    // flatten the current illustration to simple JS using our 
    // Knockout mapping options
    var clonableIllustration = ko.mapping.toJS(stylist.ill);

    var msgInfo = {
        method: 'saveIllustration',
        illustration: clonableIllustration
    };
    // To re-save in the same slot, omit the uniqueID
    if (typeof(forcePosition) !== 'undefined') {
        msgInfo.uniqueID = forcePosition;
    }
    
    notebookWindow.postMessage(msgInfo, '*');  
    // TODO: restrict to this particular notebook's domain?
}

function deleteIllustration(slotPosition, callback) {
    deleteIllustration_callback = callback;

    if (typeof(slotPosition) === 'undefined') {
        console.error("deleteIllustration() REQUIRES a valid slot position, not "+ slotPosition +" <"+ typeof(slotPosition) +">");
        return;
    }

    var msgInfo = {
        method: 'deleteIllustration',
        illustration: clonableIllustration,
        uniqueID: slotPosition
    };

    notebookWindow.postMessage(msgInfo, '*');
    // TODO: restrict to this particular notebook's domain?
}

// Get user-friendly list of available source data for trees, etc.
// TODO: Include JS variables, from window scope (or scope provided)?
// TODO: Support multiple kernels (Python, Julia, etc) if available?
// TODO: Filter kernel vars (using regular expressions?) to show only suitable variables for each query?

// stash callbacks for use by cross-window responses
var getTreeSourceList_callback = null,
    getTreeSourceData_callback = null;

function getTreeSourceList(callback) {
    getTreeSourceList_callback = callback;

    notebookWindow.postMessage({
        method: 'listAllNotebookVars'
    }, 
    '*');  // TODO: restrict to this particular notebook's domain?
}

function getTreeSourceData(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    getTreeSourceData_callback = callback;

    notebookWindow.postMessage({
        method: 'getNotebookVar',
        varName: id
    }, 
    '*');  // TODO: restrict to this particular notebook's domain?
}

function getSupplementalDataSourceList(id, callback) {
    // TODO
}

function getOrnamentSourceList(id, callback) {
    // TODO
}

// Expose some members to outside code (eg, Knockout bindings, onClick
// attributes...)
var api = [
    // expected API for storage backend
    'getIllustrationList',
    'loadIllustration',
    'saveIllustration',
    'deleteIllustration',
    'userHasStorageAccess',
    // functions unique to an IPython notebook
    'getTreeSourceList',
    'getTreeSourceData'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});

},{}],247:[function(require,module,exports){
/*
 * This script adds storage on the local filesystem for modern browsers.
 * Illustrations are saved as ZIP archives, typically with internal copies of
 * input data, transformation results, and output files.
 *
 * This should be useful in pre-publication, exploratory scenarios, and private
 * collaboration via email. 
 */

var $ = require('jquery'),
    utils = require('../ti-utils'),
    JSZip = require('jszip'),
    md5 = require('spark-md5'),
    FileSaver = require('file-saver'),  // https://github.com/eligrey/FileSaver.js
    assert = require('assert');

// TODO: expose JSZip to JS in the main UI?
// global.JSZip = JSZip;

// N.B. Some globals are already visible from here
///var stylist;

function userHasStorageAccess() {
    // If we're inside a running, editable notebook, anyone can save data.
    return utils.browserSupportsFileAPI();
    //return stylist.utils.browserSupportsFileAPI();  // also works!
}

function getIllustrationList(callback) {
    // This is not really possible in the local filesystem; return an empty list for now.
    var resp = { data: [ ] };
    // 'callback' expects a single obj with 'data' or 'error' properties
    callback(resp);
}

function loadIllustration(id, callback) {
    // in the filesystem, 'id' is a full path? or ignore it here?
}

function saveIllustration(id, callback, options) {
    /* In the filesystem, 'id' is just a suggested filename. 
     * NOTE that we have no control over where the browser will save a
     * downloaded file, and we have no direct knowledge of the filesystem.
     * Furthermore, most browsers won't overwrite an existing file with this
     * path+name, and will instead increment the new file, e.g.
     * 'bee-trees-compared.zip' becomes '~/Downloads/bee-trees-compared (2).zip'.
     *
     * Can we support the expected behavior for... ?
     *  Save  (not really, since we can't overwrite a file)
     *  Save As...  (by default, with a possibly munged/incremented filename)
     *  Copy  (sure, that's easy if we just allow renaming)
     */
    options = options || {FULL_ARCHIVE: true};

    // TODO: add this user to the authors list, if not found?
    // (email and/or userid, so we can link to authors)
    /*
    var userDisplayName = ???
    var listPos = $.inArray( userDisplayName, stylist.ill.metadata.authors() );
    if (listPos === -1) {
        stylist.ill.metadata.authors.push( userDisplayName );
    }
    */

    // TODO: clear any existing URL? or keep last-known good one?
    //clonableIllustration.metadata.url = '';

    // TODO: add a "scrubber" as we do for OpenTree studies? 
    // scrubIllustrationForTransport(stylist.ill);

    // flatten the current illustration to simple JS using our 
    // Knockout mapping options
    var clonableIllustration = ko.mapping.toJS(stylist.ill);

    // create a Zip archive, add the core document
    var archive = new JSZip();
    archive.file("main.json", JSON.stringify(clonableIllustration));

    // Test all input for repeatable provenance info; if any are lacking a
    // clear source, we should embed the source data here.
    var staticInputs = TreeIllustrator.gatherStaticInputData();
    if (options.FULL_ARCHIVE || (staticInputs.length > 0)) {
        // add some or all input data for this illustration
        //var inputFolder = archive.folder('input');
        var inputsToStore = options.FULL_ARCHIVE ? TreeIllustrator.gatherAllInputData() : staticInputs;
        $.each(inputsToStore, function(i, inputData) {
            var itsPath = inputData.path;
            var serialized = utils.serializeDataForSavedFile( inputData.value );
            archive.file(itsPath, serialized.value, serialized.options);
        });
    }

    // add other cache entries (transformed data)
    if (options.FULL_ARCHIVE) {
        //var transformFolder = archive.folder('transform');
        var transformsToStore = TreeIllustrator.gatherAllTransformData();
        $.each(transformsToStore, function(i, transformData) {
            var itsPath = transformData.path;
            var serialized = utils.serializeDataForSavedFile( transformData.value );
            archive.file(itsPath, serialized.value, serialized.options);
        });
    }

    // add any output docs (SVG, PDF)
    var outputFolder = archive.folder('output');
    outputFolder.file('main.svg', "TODO\n", {TODO: "What are appropriate options for SVG?"});

    /* ASSUME we have no knowledge of the chosen save path, or the prior
     * existence of the specified filename in that location.
     */
    var suggestedFileName = stylist.getDefaultArchiveFileName( id );
    archive.generateAsync( {type:"blob"}, 
                           function updateCallback(metadata) {
                               // TODO: Show progress as demonstrated in
                               // https://stuk.github.io/jszip/documentation/examples/downloader.html
                               console.log( metadata.percent.toFixed(2) + " % complete" );
                           } )
           .then( function (blob) {   
                      // success callback
                      FileSaver.saveAs(blob, suggestedFileName);
                  },
                  function (err) {    
                      // failure callback
                      alert('ERROR saving this ZIP archive:\n'+ err);
                  } );
}

function deleteIllustration(id, callback) {
    // We really can't do this under current (2017) brower security rules!
    console.error("deleteIllustration() is not possible in local filesystem!");
    callback({error: "deleteIllustration() is not possible in local filesystem!"});
}


// Get user-friendly list of available source data for trees, etc.
// TODO: Include JS variables, from window scope (or scope provided)?
// TODO: Support multiple kernels (Python, Julia, etc) if available?
// TODO: Filter kernel vars (using regular expressions?) to show only suitable variables for each query?

// Expose some members to outside code (eg, Knockout bindings, onClick
// attributes...)
var api = [
    // expected API for storage backend
    'getIllustrationList',  // always returns an empty list
    'loadIllustration',
    'saveIllustration',
    'deleteIllustration',  // not really available, but required for standard backend API
    'userHasStorageAccess'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});

},{"../ti-utils":250,"assert":1,"file-saver":56,"jquery":244,"jszip":72,"spark-md5":245}],248:[function(require,module,exports){
/*
 * This is the default host adapter for a standalone web-app (all logic is
 * client-side JS) using web services from the OpenTree APIs. This includes a
 * storage backend based on peyotl[1] and phylesystem[2] conventions for a
 * "folderish" illustration type:
 *
 * Each object ID is unique, but this might be a subpath and web-slug[3]. So
 * there might be multiple illustrations called 'my-favorite', but they'd need
 * to be under different subpaths (per user, or based on some other grouping).
 *
 * [1] peyotl
 * [2] phylesystem
 * [3] web slug
 */

/* The methods below constitute a general API for the Tree Illustrator. 
 * These should support asynchronous operations via callbacks. When defining
 * function names and arguments, keep in mind that we expect to build parallel
 * implementations in other contexts (e.g., within a dedicated website or the
 * Tools tab of the OpenTree curation app).
 *
 * Generally speaking, each callback expets a single object with 'data' or
 * 'error' properties, but not both. Details for 'data' are specific to each
 * method.
 */
var utils = require('../ti-utils'),
    JSZip = require('jszip');

// Return a sensible error from placeholder methods
var notImplementedResponse = {
    error:"Not yet implemented in this storage backend!"
};

/* Manage illustrations from the current docstore (phylesystem via its API).
 * N.B. that these methods are used to manage a few subtypes (illustrations,
 * templates, style guides, etc.) in a uniform way.
 */
var illustrationAPIBaseURL = "https://devapi.opentreeoflife.org";
var listAllIllustrations_url = illustrationAPIBaseURL + '/v3/illustrations/list_all';
var createIllustration_POST_url = illustrationAPIBaseURL + '/v3/illustration';
var loadIllustration_GET_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}.zip';
var updateIllustration_PUT_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}';
var deleteIllustration_DELETE_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}';
/* Manage sub-resources (opaque files) within complex types, e.g. supporting
 * data for an illustration.
 *
 * N.B. We'll use PUT (vs. POST) for creation *and* updates, since we'll
 * specify the desired file-path in the URL. Any subsequent PUTs to this URL
 * will update the resource stored there.
 */
//var createFile_POST_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}/file';
var createOrUpdateFile_PUT_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}/{FILE_PATH}';
var loadFile_GET_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}/{FILE_PATH}';
var removeFile_DELETE_url = illustrationAPIBaseURL + '/v3/illustration/{DOC_ID}/{FILE_PATH}';

// Use a known-good URL fragment to extract an illustration ID from its API URL
var illustrationURLSplitterAPI = '/illustration/';
// Fall back to raw-data URL in some cases
var illustrationURLSplitterRaw = '/docs-by-owner/';  // or 'illustrations'?

function getIllustrationIDFromURL(url) {
    // anything after the known API endpoint is a illustration ID
    var fromAPI = url.split( illustrationURLSplitterAPI )[1];
    var fromRawData = url.split( illustrationURLSplitterRaw )[1];
    if (fromRawData) {
        // strip file extension
        fromRawData = fromRawData.split('.json')[0];
    }
    return fromAPI || fromRawData;
}

/* Most operations (beyond a simple fetch) will require the user to be logged
 * in via GitHub. Store their id, name, and credentials here.
 */
var githubAPIBaseURL = 'https://api.github.com';
var getGitHubToken_url = githubAPIBaseURL + '/authorizations';
var getGitHubUserInfo_url = githubAPIBaseURL + '/user';
var userDisplayName = ko.observable(),
    userLogin = ko.observable(),
    userEmail = ko.observable(),
    userAuthToken;
var githubTokenProps = {
    "scopes": ["public_repo"], 
    "note": "Tree Illustrator ("+ window.location.hostname +")",
    "fingerprint": "tree-illustrator-"+ window.location.hostname +"-one-time-token"
}
function userHasStorageAccess() {
    return userLogin() && (userLogin() !== 'LOGIN_NOT_FOUND');
}

function loginToGitHub() {
    // N.B. we need to encode credentials to Base64 for the Auth header
    var $popup = $('#storage-options-popup');
    var username = $.trim( $popup.find('#github-userid').val() );
    var password = $.trim( $popup.find('#github-password').val() );
    var b64credentials = btoa( username+':'+password );
    // N.B. atob(b64header) should cleanly restore the input values
    var basicAuthHeaders = {
        "Authorization": "Basic "+ b64credentials
    }
    var deletePriorAuthToken = function() {
        /* We call this if we're blocked (below) from creating a new OAuth
         * token by the presence of a stale one with the same properties.
         */
        $.ajax({
            type: 'GET',
            url: getGitHubToken_url,
            headers: basicAuthHeaders,
            //data: {},
            //crossdomain: true,
            //contentType: "application/json; charset=utf-8",
            success: function( data ) {  // success callback
                // TODO: Find the id of the existing token with my properties
                var staleTokenID = null;
                $.each(data, function(i, tokenInfo) {
                    //if ((tokenInfo.app.name === githubTokenProps.note) && ...
                    if (tokenInfo.fingerprint === githubTokenProps.fingerprint) {
                        staleTokenID = tokenInfo.id;
                        return false;
                    }
                });
                if (!staleTokenID) {
                    console.warn("Unknown error clearing old GitHub OAuth token. Probably just a 404 error, no need for action.");
                    return;
                }
                $.ajax({
                    type: 'DELETE',
                    url: (getGitHubToken_url +"/"+ staleTokenID),
                    headers: basicAuthHeaders,
                    // This really shouldn't go wrong..
                    complete: function( jqXHR, textStatus ) {
                        // Try again to create a new token
                        createNewAuthToken();
                    }
                });
                return;
            },
            error: function( jqXHR, textStatus, errorThrown ) {
                if (errorThrown == 'Unauthorized') {
                    alert("GitHub credentials not recognized! Please try again.");
                } else {
                    alert("Unknown error contacting GitHub. Please wait a moment and try again");
                }
            },
            // complete: function( jqXHR, textStatus ) { }
        });
    }
    var createNewAuthToken = function() {
        /* Call GitHub API to generate a new OAuth token for this user.  Note
         * that we're getting a general "personal access" token for this user,
         * not something application-specific since that would require exposing
         * its client secret, as described here:
         *   https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
         */
        $.ajax({
            type: 'POST',
            url: getGitHubToken_url,
            data: JSON.stringify( githubTokenProps ),
            /* NOTE that we can't use jQuery's newer `username` and `password` 
             * properties here, since the GitHub API won't present an auth
             * challenge. Instead, we'll need to pre-emptively send the user's
             * credentials in our first request.
             */
            headers: basicAuthHeaders,
            //crossdomain: true,
            //contentType: "application/json; charset=utf-8",
            success: function( data ) {  // success callback
                // raw response should be JSON
                userAuthToken = data.token;
                ///console.warn(">>> GitHub OAuth token: "+ userAuthToken);

                // Use the new token to fetch user id, display name, email(?)
                $.ajax({
                    type: 'GET',
                    url: getGitHubUserInfo_url,
                    headers: {
                        "Authorization": "Token "+ userAuthToken
                    },
                    success: function(data) {
                        // These should now have proper values
                        userDisplayName(data.name || "NAME_NOT_FOUND");
                        userLogin(data.login || "LOGIN_NOT_FOUND");
                        userEmail(data.email || "EMAIL_NOT_FOUND");
                        // clear the password-input field, hide login, show some contents
                        $popup.find('#github-password').val('');
                        $('#github-login-panel').hide();
                        $('#github-logged-in').show();
                    },
                    complete: function() {
                        // Anything else to do here?
                    }
                });
            },
            error: function( jqXHR, textStatus, errorThrown ) {
                switch (errorThrown) {
                    case 'Unauthorized':  // 401
                        alert("GitHub credentials not recognized! Please try again.");
                        break;
                    case 'Unprocessable Entity':  // 422
                        console.warn("This token already exists! Clobbering old token to retry...");
                        // NOTE that this will search-and-destroy the old token, then retry.
                        deletePriorAuthToken();
                        break;
                    default:
                        alert("Unknown error '"+ errorThrown +"' ("+ jqXHR.status +") contacting GitHub. Please wait a moment and try again");
                }
                return;
            }
        });
    };
    // Start the process, using local funcs and credentials
    createNewAuthToken();
}

function userIsLoggedIntoGitHub() {
    return !!userAuthToken;  // fails on "", null, undefined
}

function getDefaultGitHubIllustrationID( ) {
    // suggest an ID, based on prior storage *or* illustration name
    /* CURRENTLY UNUSED! but seems handy... */
    var priorStorageURL = stylist.ill.metadata.url();
    if (priorStorageURL) {
        return getIllustrationIDFromURL(priorStorageURL);
    }
    var nameSlug = slugify(stylist.ill.metadata.name());
    return (userLogin() +'/'+ nameSlug);
}

function slugify(str) {
    // Convert any string into a simplified "slug" suitable for use in URL or query-string
    return str.toLowerCase()
              .replace(/[^a-z0-9 -]/g, '')  // remove invalid chars
              .replace(/\s+/g, '-')         // collapse whitespace and replace by -
              .replace(/-+/g, '-');         // collapse dashes
}

function getIllustrationList(callback) {
    /* The 'data' (if successful) should be an array of objects, each with
     * 'name', 'description', and 'source' properties.
     */
    // Until we have a fast index, fetch the complete illustration list from the illustrations API
    // https://devapi.opentreeoflife.org/v3/illustrations/list_all
    // 'callback' expects a single obj with 'data' or 'error' properties
    var resp = {};
    $.ajax({
        type: 'GET',
        url: listAllIllustrations_url,
        //crossdomain: true,
        //contentType: "application/json; charset=utf-8",
        success: function( data ) {  // success callback
            // convert raw response to JSON
            var foundIllustrations = $.parseJSON(data);
            resp.data = [ ];
            if (foundIllustrations.length) {
                // TODO: Convert these properties to the more generic ones expected
                // by the Tree Illustrator (name, description, source)
                console.warn('=== found '+ foundIllustrations.length +' illustrations ===');
                $.each( foundIllustrations, function(i, illustrationInfo) {
                    // build a rich HTML description block
                    /* Skipping this for now (a general GitHub URL to its folder would be better!)
                    var srcURL = 'https://devapi.opentreeoflife.org/v3/illustration/{ID}'
                                   .replace('{ID}', illustrationInfo['id']);
                    // TODO: Adapt the URL above to use matching API domain!
                    var descHTML = '<a href="{URL}" target="_blank" title="Click to see source in a new window">{ID}</a></div>'
                                     .replace('{URL}', srcURL)
                                     .replace('{ID}', illustrationInfo['id']);
                   */
                    var descHTML = '';
                    if (illustrationInfo.metadata['description']) {
                        descHTML += '<div class="github-description">{DESC}</div>'
                                      .replace('{DESC}', illustrationInfo.metadata['description']);
                    }
                    resp.data.push({
                        // use the expected properties for simple-chooser
                        name: illustrationInfo.metadata['name'],
                        description: descHTML,
                        source: illustrationInfo['id']
                    });
                });
            } else if ($.isArray(foundIllustrations)) {
                console.warn('=== no illustrations found ===');
            } else {
                console.error('=== invalid response! ===');
                console.error(foundIllustrations);
                resp.error = "Invalid response (illustration list): "+ foundIllustrations;
            }
        },
        error: function( jqXHR, textStatus, errorThrown ) {
            resp.error = "Unable to load illustration list!";
        },
        complete: function( jqXHR, textStatus ) {
            callback(resp);
        }
    });
}

function loadIllustration(id, callback) {
    // 'callback' expects a single obj with 'data' or 'error' properties
    var resp = {};
    $.ajax({
        global: false,  // suppress web2py's aggressive error handling
        type: 'GET',
        cache: false,
        dataType: 'binary',     // now has a proper binary transport
        url: loadIllustration_GET_url.replace('{DOC_ID}', id),
        data: {
            // misc identifying information
            'author_name': (userDisplayName() || ""),
            'author_email': (userEmail() || ""),
            'auth_token': (userAuthToken || "")
        },
        success: function( data, textStatus, jqXHR ) {
            // fetch method should return either the new illustration as a ZIP archive, or an error
            //hideModalScreen();

            // TODO: Add version history or other metadata?
            /* The callback provided will replace stylist.ill and rebind UI
             * and the rendering pipeline. It expects a response object with
             * 'data' or 'error'.
             */
            var jsonData, ill, archive;
            try {
                jsonData = JSON.parse(data);
                console.log("loadIllustration(): Response parsed as JSON");
                ill = jsonData['data'];  // illustration as JS object 
            } catch(e) {
                console.warn("loadIllustration(): Response is not JSON, trying as a ZIP archive");
                var archive = new JSZip();
                var zipOptions = {
                    //base64: true,                 // nope, fails validation
                    //checkCRC32: true              // still reports missing bytes
                    //optimizedBinaryString: true   // still reports missing bytes
                }
                archive.loadAsync(data, zipOptions)
                       .then(function(zip) {
                            // find and parse the JSON core file in this archive
                            ///console.log(zip.files);
                            zip.file('main.json')
                                .async("string")
                                .then(function(data) {
                                    try {
                                        // no metadata wrapper here...
                                        ill = JSON.parse(data);
                                        console.warn("loadIllustration(): Response parsed as JSON");
                                        resp.data = ill;
                                    } catch(e) {
                                        resp.error = "Unable to parse 'main.json'!";
                                        console.error(resp.error);
                                    } finally {
                                        callback(resp);
                                    }
                                });
                        });
                return;  // bail out of outer function (we handle callbacks above)
            }

            if (!ill) {  // TODO
                resp.error = "No illustration data found!";
                console.error(resp.error);
            } else {
                if (typeof(ill) === 'undefined') {
                    resp.error = "No illustration '"+ id +"' found!";
                } else {
                    resp.data = ill;
                }
            }
            callback(resp);
        },
        error: function( data, textStatus, jqXHR ) {
            //hideModalScreen();
            if ((typeof(jqXHR.responseText) !== 'string') || jqXHR.responseText.length === 0) {
                resp.error = 'Sorry, there was an error loading this illustration. (No more information is available.)';
            } else {
                resp.error = 'Sorry, there was an error loading this illustration:\n\n '+ jqXHR.responseText;
            }
            callback(resp);
        }
    });
}

function saveIllustration(illustrationID, callback, options) {
    options = options || {FULL_ARCHIVE: true};
    // 'callback' expects a single obj with 'data' or 'error' properties
    var resp = {};
    // TODO: support save, save-as, copy?
    if (!userAuthToken) {
        // We can't save without a token; stop and prompt for login
        loginToGitHub();
        resp.error = "User not logged into GitHub! Prompting for login now."
        callback(resp);
        return;
    }
    // add this user to the authors list, if not found
    // TODO: add email or userid here, so we can link to authors?
    var listPos = $.inArray( userDisplayName(), stylist.ill.metadata.authors() );
    if (listPos === -1) {
        stylist.ill.metadata.authors.push( userDisplayName() );
    }

    // TODO: add a "scrubber" as we do for OpenTree studies? 
    // scrubIllustrationForTransport(stylist.ill);

    // flatten the current illustration to simple JS using our 
    // Knockout mapping options
    var clonableIllustration = ko.mapping.toJS(stylist.ill);

    // Are we creating a new one, or updating an existing one?
    var createOrUpdate;
    if (('sha' in stylist.ill.metadata) && stylist.ill.metadata.sha()) {
        // we're UPDATING an existing collection
        createOrUpdate = 'UPDATE';
    } else {
        // we're CREATING a new collection
        createOrUpdate = 'CREATE';
    }
    if (illustrationID && typeof(illustrationID) === 'string') {
        // update (or add) an internal URL with the specified ID, e.g. from Save As...
        clonableIllustration.metadata.url = illustrationURLSplitterAPI + illustrationID;
    } else if (clonableIllustration.metadata.url) {
        // we'll use the ID already stored in its URL
    } else {
        // we'll build a propsed url, based on the illustration's name
        var nameSlug = slugify(clonableIllustration.metadata.name);
        // build a fresh ID with current user as creator
        clonableIllustration.metadata.url = illustrationURLSplitterAPI + userLogin() +'/'+ nameSlug;
    }
    illustrationID = getIllustrationIDFromURL(clonableIllustration.metadata.url);

    // create a Zip archive, add the core document and static input data
    var archive = new JSZip();
    archive.file("main.json", JSON.stringify(clonableIllustration));
    // Test all input for repeatable provenance info; if any are lacking a
    // clear source, we should embed the source data here.
    var staticInputs = TreeIllustrator.gatherStaticInputData();
    if (options.FULL_ARCHIVE || (staticInputs.length > 0)) {
        // add some or all input data for this illustration
        var inputsToStore = options.FULL_ARCHIVE ? TreeIllustrator.gatherAllInputData() : staticInputs;
        $.each(inputsToStore, function(i, inputData) {
            var itsPath = inputData.path;
            var serialized = utils.serializeDataForSavedFile( inputData.value );
            archive.file(itsPath, serialized.value, serialized.options);
        });
    }
    if (options.FULL_ARCHIVE) {
        // add other cache entries (transformed data)
        ///var transformFolder = archive.folder('transform');
        var transformsToStore = TreeIllustrator.gatherAllTransformData();
        $.each(transformsToStore, function(i, transformData) {
            var itsPath = transformData.path;
            var serialized = utils.serializeDataForSavedFile( transformData.value );
            archive.file(itsPath, serialized.value, serialized.options);
        });
    }

    var uploadIllustrationBlob = function (blob) {
        // use FormData to send "pure" binary data
        var formData = new FormData();
        formData.append('archive', blob, 'update.zip');

        var saveURL;
        if (createOrUpdate === 'UPDATE') {
            // Update the existing illustration
            saveURL = updateIllustration_PUT_url.replace('{DOC_ID}', illustrationID);
            /* TODO? gather commit message (if any) from pre-save popup
            var commitMessage;
            var firstLine = $('#save-comment-first-line').val();
            var moreLines = $('#save-comment-more-lines').val();
            if ($.trim(firstLine) === '') {
                commitMessage = $.trim(moreLines);
            } else if ($.trim(moreLines) === ''){
                commitMessage = $.trim(firstLine);
            } else {
                commitMessage = $.trim(firstLine) +"\n\n"+ $.trim(moreLines);
            }
            */

            // add non-Nexson values to the query string
            var qsVars = $.param({
                author_name: userDisplayName(),
                author_email: userEmail(),
                auth_token: userAuthToken,
                starting_commit_SHA: stylist.ill.metadata.sha(),
                commit_msg: 'Saved from Tree Illustrator'       // add version?
            });
            saveURL += ('?'+ qsVars);

            $.ajax({
                global: false,  // suppress web2py's aggressive error handling
                type: 'PUT',
                dataType: 'json',
                // crossdomain: true,
                processData: false,
                contentType: false,   // FormData will send as 'multipart/form-data'
                url: saveURL,
                data: formData,
                complete: function( jqXHR, textStatus ) {
                    // report errors or malformed data, if any
                    if (textStatus !== 'success') {
                        if (jqXHR.status >= 500) {
                            // major server-side error, just show raw response for tech support
                            resp.error = "Sorry, there was an error saving this illustration:\n\n"+ jqXHR.responseText;
                            alert(resp.error);
                            callback(resp);
                            return;
                        }
                        // Server blocked the save, probably due to validation errors!
                        var data = $.parseJSON(jqXHR.responseText);
                        // TODO: this should be properly parsed JSON, show it more sensibly
                        // (but for now, repeat the crude feedback used above)
                        resp.error = "Sorry, there was an error in the illustration data:\n\n"+ jqXHR.responseText;
                        alert(resp.error);
                        callback(resp);
                        return;
                    }
                    var putResponse = $.parseJSON(jqXHR.responseText);
                    var newCommitSHA = putResponse['sha'];
                    if (newCommitSHA) {
                        stylist.ill.metadata.sha(newCommitSHA);
                    }
                    /* TODO: add 'versions' or 'metadata.versions' to record these commits?
                    if ('versionHistory' in putResponse) {
                        stylist.ill.metadata.versions(putResponse['versionHistory'] || [ ]);
                    }
                    */
                    if (putResponse['merge_needed']) {
                        var errMsg = 'Your changes were saved, but an edit by another user prevented your edit from merging to the publicly visible location. In the near future, we hope to take care of this automatically. In the meantime, please <a href="mailto:info@opentreeoflife.org?subject=Illustration%20merge%20needed%20-%20'+ newCommitSHA +'">report this error</a> to the Open Tree of Life software team';
                        /* TODO: make this a cleaner, more friendly display (with active mailto: hyperlink) */
                        alert(errMsg);
                        // NB, we treat this as a warning, but not a save error; return the data as expected!
                    }
                    // presume success from here on
                    //hideModalScreen();
                    //showSuccessMessage('Study saved to remote storage.');
                    /* TODO: Block page-exit on unsaved changes?
                    popPageExitWarning('UNSAVED_STUDY_CHANGES');
                    studyHasUnsavedChanges = false;
                    disableSaveButton();
                    */
                    // TODO: update viz?
                    resp.data = putResponse;
                    callback(resp);
                }
            });
        } else {  // i.e. createOrUpdate === 'CREATE'
            // Store the new illustration
            saveURL = createIllustration_POST_url;
            // add non-Nexson values to the query string
            var qsVars = $.param({
                author_name: userDisplayName(),
                author_email: userEmail(),
                auth_token: userAuthToken,
                commit_msg: 'Saved from Tree Illustrator'       // add version?
            });
            saveURL += ('?'+ qsVars);

            $.ajax({
                global: false,  // suppress web2py's aggressive error handling
                type: 'POST',
                dataType: 'json',
                // crossdomain: true,
                processData: false,
                contentType: false,   // FormData will send as 'multipart/form-data'
                url: saveURL,
                /*
                data: {
                    // misc identifying information
                    'author_name': (userDisplayName() || ""),
                    'author_email': (userEmail() || ""),
                    'auth_token': (userAuthToken || ""),
                    'json': JSON.stringify(clonableIllustration)
                },
                 */
                data: formData,
                success: function( data, textStatus, jqXHR ) {
                    // creation method should return either a redirect URL to the new illustration, or an error
                    //hideModalScreen();
                    console.log('saveIllustration(): done! textStatus = '+ textStatus);
                    // report errors or malformed data, if any
                    if (textStatus !== 'success') {
                        resp.error = 'Sorry, there was an error creating this illustration.';
                        alert(resp.error);
                        callback(resp);
                        return;
                    }

                    // update the internal 'url' of the live illustration to match what was assigned
                    // (API ensures uniqueness, typically by incrementing duplicate ids)
                    // EXAMPLE:  https://api.opentreeoflife.org/v3/illustration/jimallman/my-illustration
                    var assignedURL = data.resource_url;
                    stylist.ill.metadata.url( assignedURL );
                    var newCommitSHA = data['sha'];
                    if (newCommitSHA) {
                        stylist.ill.metadata.sha(newCommitSHA);
                    }
                    // TODO: add 'versions' or 'metadata.versions' to record these commits?
                },
                error: function( data, textStatus, jqXHR ) {
                    //hideModalScreen();
                    if ((typeof(jqXHR.responseText) !== 'string') || jqXHR.responseText.length === 0) {
                        resp.error = 'Sorry, there was an error creating this illustration. (No more information is available.)';
                    } else {
                        resp.error = 'Sorry, there was an error creating this illustration:\n\n '+ jqXHR.responseText;
                    }
                    alert(resp.error);
                },
                complete: function( data, textStatus, jqXHR ) {
                    callback(resp);
                }
            });
        } // end of if/else (CREATE vs. UPDATE)
    };

    archive.generateAsync( {type:"blob"},
                           function updateCallback(metadata) {
                               // TODO: Show progress as demonstrated in
                               // https://stuk.github.io/jszip/documentation/examples/downloader.html
                               console.log( metadata.percent.toFixed(2) + " % complete" );
                           } )
           .then( uploadIllustrationBlob,   // success callback
                  function (err) {
                      // failure callback
                      alert('ERROR generating this ZIP archive:\n'+ err);
                  } );
}


function deleteIllustration(illustrationID, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    var resp = {};

    if (!userAuthToken) {
        // We can't save without a token; stop and prompt for login
        loginToGitHub();
        resp.error = "User not logged into GitHub! Prompting for login now."
        callback(resp);
        return;
    }

    if (!illustrationID || typeof(illustrationID) !== 'string') {
        // we need this to clobber anything on GitHub
        resp.error = "deleteIllustration() needs a proper location string, not "+ illustrationID +" <"+ typeof(illustrationID) +">!";
        callback(resp);
        return;
    }

    // Delete the chosen illustration
    var deleteURL = deleteIllustration_DELETE_url.replace('{DOC_ID}', illustrationID);
    $.ajax({
        global: false,  // suppress web2py's aggressive error handling
        type: 'DELETE',
        dataType: 'json',
        // crossdomain: true,
        // contentType: "application/json; charset=utf-8",
        url: deleteURL,
        data: {
            // misc identifying information (for auth)
            'author_name': (userDisplayName() || ""),
            'author_email': (userEmail() || ""),
            'auth_token': (userAuthToken || ""),
        },
        success: function( data, textStatus, jqXHR ) {
            // TODO: creation method should return ??? on success, or an error message
            //hideModalScreen();
            console.log('deleteIllustration(): done! textStatus = '+ textStatus);
            // report errors or malformed data, if any
            if (textStatus === 'success') {
                /* NB the callback (below) should handle any cleanup, if e.g. we just
                 * deleted the currently loaded illustration.
                 */
            } else {
                resp.error = "Sorry, there was an error deleting this illustration.";
                alert(resp.error);
            }
        },
        error: function( data, textStatus, jqXHR ) {
            //hideModalScreen();
            if ((typeof(jqXHR.responseText) !== 'string') || jqXHR.responseText.length === 0) {
                resp.error = 'Sorry, there was an error deleting this illustration. (No more information is available.)';
            } else {
                resp.error = 'Sorry, there was an error deleting this illustration:\n\n '+ jqXHR.responseText;
            }
            alert(resp.error);
        },
        complete: function( jqXHR, textStatus ) {
            callback(resp);
        }
    });
}

// Get user-friendly list of available source data for trees, etc.?

function getTreeSourceList(callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}
function getTreeSourceData(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}

function getSupplementalDataSourceList(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}
function getSupplementalDataSourceValue(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}

function getOrnamentSourceList(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}
function getOrnamentSourceValue(id, callback) {
    // 'callback' should expect a single obj with 'data' or 'error' properties)
    callback(notImplementedResponse);
}

// Expose some members to outside code (eg, Knockout bindings, onClick
// attributes...)
var api = [
    // expected API for storage backend
    'getIllustrationList',
    'loadIllustration',
    'saveIllustration',
    'deleteIllustration',
    'getDefaultGitHubIllustrationID',
    'getIllustrationIDFromURL',
    'userHasStorageAccess',
    // auth information (specific to this backend?)
    'userDisplayName',
    'userLogin',
    'userEmail',
    //'userAuthToken'
    'loginToGitHub',
    'userIsLoggedIntoGitHub'
    /* TODO: Add providers for minor types?
    'getTreeSourceList',
    'getTreeSourceData',
    'getSupplementalDataSourceList',
    'getSupplementalDataSourceData',
    'getOrnamentSourceList',
    'getOrnamentSourceData',
     */
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});

},{"../ti-utils":250,"jszip":72}],249:[function(require,module,exports){
(function (global){
/*
 * In this editor, we generate a declarative Vega spec (and its downstream d3
 * visualization) from a more descriptive scene-graph model. This corresponds
 * closely with a web UI that's bound and enabled using KnockoutJS.
 */

var $ = require('jquery'),
    utils = require('./ti-utils'),
    jszip = require('jszip'),
    FileSaver = require('file-saver'),
    Blob = require('blob-polyfill'),
    md5 = require('spark-md5'),
    vg = require('vega'),
    TreeIllustrator = require('./TreeIllustrator.js'),
    stashTransform = require('./vg.data.stash.js');
    pluckTransform = require('./vg.data.pluck.js');
    nexsonTransform = require('./vg.data.nexson.js');
    phylogramTransform = require('./vg.data.phylogram.js');
    assert = require('assert');

// expose TreeIllustrator to JS in the main UI 
global.TreeIllustrator = TreeIllustrator;
global.$ = $;

// register custom transforms with the installed vega
vg.transforms['stash'] = stashTransform;
vg.transforms['pluck'] = pluckTransform;
vg.transforms['nexson'] = nexsonTransform;
vg.transforms['phylogram'] = phylogramTransform;

// patch missing JS console on some (very) old browsers
if (typeof console == 'undefined') console = {
    log: function(msg) {},
    warn: function(msg) {},
    error: window.alert
}

// Test query-string variables, from http://stackoverflow.com/a/5158301
function getParameterByName(name) {
    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

/* Determine the current host application, so we can adapt to the advantages
 * and limitations of each:
 *  - storage options and requirements
 *      - slot- vs. URL-based storage
 *      - naming restrictions (uniqueness, etc)
 *  - data sources and formats, e.g.
 *      - values from a server-side kernel in Jupyter
 *      - user's resources in OpenTree repository
 *      - special adapters/validators for tree data
 *  - optional features and UI
 *  - adjustments to layout and style
 *
 * The host application should be specified on the query-string of
 * 'stylist.html', for example 
 *      .../stylist.html?hostApplication=JUPYTER_NOTEBOOK
 * The default value is a standalone page, which depends entirely on outside
 * web services for data and storage.
 */
var hostApplication = TreeIllustrator.hostApplications.STANDALONE;
// Validate received host-app string against enumerated values
$.each(TreeIllustrator.hostApplications, function(i, testValue) {
    if (getParameterByName('hostApplication') == testValue) {
        hostApplication = testValue;
    }
});
console.log("Tree Illustrator host application: "+ hostApplication);

// We'll attempt to dynamically load appropriate storage backends and other components
var LOCAL_FILESYSTEM = TreeIllustrator.storageBackends.LOCAL_FILESYSTEM,
    JUPYTER_NOTEBOOK = TreeIllustrator.storageBackends.JUPYTER_NOTEBOOK,
    GITHUB_REPO = TreeIllustrator.storageBackends.GITHUB_REPO;
var storage = {};
storage[ LOCAL_FILESYSTEM ] = require('./storage/local-filesystem.js');
storage[ JUPYTER_NOTEBOOK ] = require('./storage/ipython-notebook-bridge.js');
storage[ GITHUB_REPO ]      = require('./storage/namespaced-urls.js');

storage.lastSave = {
    backend: ko.observable(null),
    location: ko.observable(null)
};
/* Each time the user sucessfully saves the current illustration, stash the
 * storage backend and any location information. NOTE that location values
 * are different for each storage backend.
 *
 * LOCAL_FILESYSTEM only knows the proposed filename, *not* the one
 * actually applied or its location in the filesystem:
 *      backend: TreeIllustrator.storageBackends.LOCAL_FILESYSTEM,
 *      location: 'trees-about-bees-LATEST.zip'
 *     OR if that proposed name is moot, empty or unreliable:
 *      location: 'UNKNOWN'
 *
 * JUPYTER_NOTEBOOK is simply an integer pointing to the n-th storage slot:
 *      backend: TreeIllustrator.storageBackends.JUPYTER_NOTEBOOK,
 *      location: 4
 *
 * GITHUB_REPO knows the final assigned Illustration ID assigned by the
 * phylesystem API:
 *      backend: TreeIllustrator.storageBackends.GITHUB_REPO,
 *      location: '/jimallman/trees-about-bees'
 *
 * Both should reset to null if we abandon an illustration or open a new one
 * (or if an attempted save fails?):
 *      backend = null;
 *      location = null;
 */
function updateLastSavedInfo( backend, location ) {
    storage.lastSave.backend(backend);
    storage.lastSave.location(location);
    console.warn('UPDATED lastSave, backend: '+ storage.lastSave.backend() +', location: '+ storage.lastSave.location());
}
function clearLastSavedInfo() {
    storage.lastSave.backend(null);
    storage.lastSave.location(null);
    console.warn('CLEARED lastSave, backend: '+ storage.lastSave.backend() +', location: '+ storage.lastSave.location());
}

/* Offer all studies and trees from the Open Tree of Life repository,
 * plus other sources and tree formats. We'll make a tree of Knockout
 * observables, so we can update them (and the UI) on-the-fly.
 *
 * This should adapt to the current host application, for example:
 *  - "local" variables from an iPython notebook (incl. server-side kernel)
 *  - similar "local" data in an Arbor workflow
 *  - the current user's studies/trees/favorites in OpenTree
 *
 * N.B. The current display logic will hide any group that has no children.
 */
var availableTrees = ko.mapping.fromJS([
    {
        name: "Placeholder tree", 
        url: './placeholder-tree.json'
    },
    {
        name: "Data used in this illustration",
        children: [
            /* A list of "friendly" labels identifying existing source data
             * already found in this illustration. Filter by type/format, based
             * on the current context (e.g. trees vs. traits)?
             * Examples would look something like this:
            {
                name: "Trait data 1.2e",
                url: './inputs/Trait data 1.2e'
            },
            {
                name: "Second (sparse) parsimony trees",
                url: './inputs/Second (sparse) parsimony trees'
            }
             */
            {
                name: "Trait data 1.2e",
                url: './inputs/Trait data 1.2e'
            },
            {
                name: "Second (sparse) parsimony trees",
                url: './inputs/Second (sparse) parsimony trees'
            }
        ]
    },
    {
        name: "From notebook kernel",
        children: [
            /* A list of variables, each marked with its language/kernel */
        ]
    },
    {
        name: "Examples",
        children: [
            {
                name: "Tuovila, 2013", 
                url: buildStudyFetchURL( '2380' )
                /* NOTE that this one has two trees!
                treeID: 'tree4999',
                otusID: 'tree5000'
                */ 
            },
            {
                name: "Jansen, 2007", 
                url: buildStudyFetchURL( 'pg_10' )
            },
            {
                name: "Drew BT, 2014", 
                url: buildStudyFetchURL( 'pg_2821' )
            }
        ]
    },
    {
        name: "Enter or upload tree data",
        /*
        name: "Enter or upload tree data as...",
        */
        children: [
            {
                name: "Newick string"
            },
            {
                name: "Newick string with extra data"
            },
            {
                name: "NEXUS"
            }
        ]
    },
    {
        name: "On the web",
        children: [
            {
                name: "Enter OpenTree study and tree ids"
            },
            {
                name: "Enter URL to NexSON 1.0"
            },
            {
                name: "Enter URL to a GitHub gist"
            }
        ]
    }
]);

var availableDataSources = ko.mapping.fromJS([
    {
        name: "Placeholder dataset", 
        url: './placeholder-dataset.json'
    },
    {
        name: "Data used in this illustration",
        children: [
            /* A list of "friendly" labels identifying existing source data
             * already found in this illustration. Filter by type/format, based
             * on the current context (e.g. trees vs. traits)?
             */
            {
                name: "FOO"
            },
            {
                name: "BAR"
            }
        ]
    },
    {
        name: "From notebook kernel",
        children: [
            /* A list of variables, each marked with its language/kernel */
        ]
    },
    {
        name: "Enter or upload data"
        /*
        name: "Enter or upload data as...",
        children: [
            {
                name: "Comma-separated values"
            },
            {
                name: "Tab-separated values"
            }
            // etc.
        ]
        */
    },
    {
        name: "On the web",
        children: [
            {
                name: "Enter URL to data file"
            },
            {
                name: "Enter URL to a GitHub gist"
            }
        ]
    }
]);

function updateAvailableTrees() {
    /* Build an appropriate (nested) list of choices, based on the current host
     * application.
     *
     * N.B. this should be repeatable to update tree sources as they come and go.
     */
    switch(hostApplication) {
        case TreeIllustrator.hostApplications.JUPYTER_NOTEBOOK:
            /* Fetch notebook variables from the server-side kernel, via
             * Jupyter's JS API.
             * TODO: Can we deal with multiple kernels in the newest notebooks?
             * TODO: Can we distinguish R-via-Python from the Python kernel?
             */
            storage[ JUPYTER_NOTEBOOK ].getTreeSourceList(function(response) {
                var notebookSourceList = ko.utils.arrayFirst(availableTrees(), function(item) {
                    return item.name() === 'From notebook kernel';
                });
                notebookSourceList.children.removeAll();
                if ('data' in response) {
                    var data = response.data;
                    if (data.length === 0) {
                        // explain the empty list, suggest a remedy
                        notebookSourceList.children.push({
                            name: ko.observable("No variables found! Run code cells and try again."),
                            disabled: ko.observable(true)  // info-only (not clickable)
                        });
                    } else {
                        // show any variables returned and their source kernel/lang
                        $.each(data, function(i, nbVar) {
                            // nbVar is a two-item list like ['Hi mom', 'str']
                            var nbVarName = nbVar[0],
                                nbVarType = nbVar[1],
                                nbVarLanguage = nbVar[2];
                            notebookSourceList.children.push({
                                name: ko.observable(nbVarName +" ("+ nbVarLanguage +" "+ nbVarType +")"),
                                kernel: ko.observable(nbVarLanguage)  
                                  // TODO: refers to kernel-id vs. language? eg 'python2'
                            });
                        });
                    }
                } else {
                    console.error(response.error || "No data returned (unspecified error)!");
                    // show the error in the source-list, and suggest a remedy
                    notebookSourceList.children.push({
                        name: ko.observable("ERROR loading notebook values. Run code cells and try again."),
                        disabled: ko.observable(true)  // info-only (not clickable)
                    });
                }
            })
            
            break;

        case TreeIllustrator.hostApplications.STANDALONE:
            // nothing to do here
            break;
    }
}

/* Conversion utilities for physical units
 */
var cm_per_inch = 2.54;
function inchesToCentimeters( inches ) {
    return inches * cm_per_inch;
}
function centimetersToInches( cm ) {
    return cm / cm_per_inch;
}

var pt_per_inch = 72.0;
function inchesToPoints( inches, ppi ) {
    return inches * pt_per_inch;
}
function pointsToInches( pt, ppi ) {
    return pt / pt_per_inch;
}

var pt_per_cm = pt_per_inch / cm_per_inch;
function centimetersToPoints( cm, ppi ) {
    return cm * pt_per_cm;
}
function pointsToCentimeters( pt, ppi ) {
    return pt / pt_per_cm;
}

function pixelsToInches( px, ppi ) {
    return px / ppi;
}
function inchesToPixels( inches, ppi ) {
    return inches * ppi;
}
function pixelsToCentimeters( px, ppi ) {
    return inchesToCentimeters(px / ppi);
}
function centimetersToPixels( cm, ppi ) {
    return centimetersToInches( cm ) * ppi;
}

function pixelsToPhysicalUnits( px, ppi ) {
    if (ill.style.printSize.units() === TreeIllustrator.units.INCHES) {
        return pixelsToInches( px, ppi );
    } else {
        return pixelsToCentimeters( px, ppi );
    }
}
function physicalUnitsToPixels( units, ppi ) {
    if (ill.style.printSize.units() === TreeIllustrator.units.INCHES) {
        return inchesToPixels( units, ppi );
    } else {
        return centimetersToPixels( units, ppi );
    }
}

function getPhysicalUnitSuffix() {
    if (physicalUnits === 'INCHES') {
        return 'in';
    } else {
        return 'cm';
    }
}

// ruler metrics (adjust for legibility)
var rulerWidth = 25;  // px

/* Maintain a few independent scales (in pixels/inch) to support the
 * illustration editor. These will sometimes align, but it's vital that we can
 * discriminate between them as each is suited for a different purposes.
 */
var browser_ppi;  // SVG resolution in current browser (not reliable!)
var internal_ppi = 90;  // SVG default pixels per inch (can be modified to suit printing device)
var display_ppi = internal_ppi;  // pixels per inch at current magnification (zoom level)

/* Track the values used for our viewport (overall size, margins vs. illustration)
 * for easy re-use in rulers, etc. For background, see SVG's viewBox docs: 
 * http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
 */
var viewbox = {
    'x': 0,
    'y': 0,
    'width': 0,
    'height': 0,
}
function updateViewportViewbox($viewport) {
    /* Adjust the main VG viewBox as needed to match the current illustration
     * size and chosen magnification. The result should be that scrollbars offer 
     * access to all SVG elements (in or out of the printed area), while the user
     * is free to choose arbitrary levels of magnification.
     */
    // TODO: maintain the current center point, but surrender empty territory
    if (!$viewport) {
        $viewport = $("#viz-outer-frame div.vega");
    }

    /* Make sure we have latest DIV size+proportions. (These can change if the
     * user toggles scrollbars or resizes the surrounding page.) This is the
     * new *minimum* size for our SVG element, to avoid gaps in the viewport!
     */
    var vpDiv = $viewport[0];
    var divWidth = vpDiv.clientWidth;
    var divHeight = vpDiv.clientHeight;
    var divProportions = divWidth / divHeight;

    /* What must be in the viewbox? All illustration elements (so we can scroll
     * to them), plus any padding needed (at current magnification) to fill the
     * viewport.
     */
    var ebox = getInclusiveIllustrationBoundingBox();
    // this is the area with all illustration elements
    var center = {
        x: ebox.x + (ebox.width / 2),
        y: ebox.y + (ebox.height / 2)
    };

    // copy to our persistent viewbox
    for (var prop in ebox) {
        viewbox[prop] = ebox[prop];
    }

    var proportionalWidth = Math.round(viewbox.width * viewportMagnification);
    var proportionalHeight = Math.round(viewbox.height * viewportMagnification);

    // compare its proportions to our *new* viewport; pad as needed to fill space
    var bbox = viewbox;
    if (proportionalWidth < divWidth) {
        // div is wider, pad viewbox width to match
        var adjustedWidth = divWidth / viewportMagnification;
        var extraWidth = adjustedWidth - viewbox.width;
        viewbox.width = adjustedWidth;
        viewbox.x -= (extraWidth / 2);
    } 
    if (proportionalHeight < divHeight) {
        // div is taller, pad viewbox height to match
        var adjustedHeight = divHeight / viewportMagnification;
        var extraHeight = adjustedHeight - viewbox.height;
        viewbox.height = adjustedHeight;
        viewbox.y -= (extraHeight / 2);
    }

    // move our background to the new viewport top-left corner
    d3.selectAll('#viewport-background, #viewport-bounds')
        .attr('x', viewbox.x)
        .attr('y', viewbox.y);

    // Update physical size of SVG element based on new viewbox and magnification
    proportionalWidth = Math.round(viewbox.width * viewportMagnification);
    proportionalHeight = Math.round(viewbox.height * viewportMagnification);
    var svgWidth = proportionalWidth;
    var svgHeight = proportionalHeight;

    // NOTE that we need to use el.setAttribute to keep mixed-case attribute names
    var svg = $viewport.find('svg')[0];

    // make sure we're at least filling the available viewport DIV
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);

    // TODO: nudge scrollbars to hold a steady view?

    svg.setAttribute('viewBox', (viewbox.x +' '+ viewbox.y +' '+ viewbox.width +' '+viewbox.height));
    $('#viewbox-indicator').html(svg.getAttribute('viewBox'));
    $('#mag-indicator').html(viewportMagnification);
    $('#svg-width-indicator').html(svg.getAttribute('width'));
    $('#svg-height-indicator').html(svg.getAttribute('height'));

    /*
    console.log('OLD div w: '+ svg.getAttribute('width'));
    console.log('  viewbox.width: '+ viewbox.width);
    console.log('  * magnification: '+ viewportMagnification);
    console.log('  NEW div w: '+ viewbox.width * viewportMagnification);
    console.log('  INT div w: '+ Math.round(viewbox.width * viewportMagnification));
    console.log('OLD div h: '+ svg.getAttribute('height'));
    console.log('  viewbox.height: '+ viewbox.height);
    console.log('  * magnification: '+ viewportMagnification);
    console.log('  NEW div h: '+ viewbox.height * viewportMagnification);
    console.log('  INT div h: '+ Math.round(viewbox.height * viewportMagnification));
    */
}

/* TODO: Load available styles from an external source or store. These might be
 * shared or private. Styles should include name and description, defaults for
 * most visual properties, and constraints (soft or hard) that we can test
 * against.
 */
var availableStyleGuides = null;
function showStyleGuidePicker() {
    // for now, load from a static JSON file 
    var lookupURL = './style-guides.json';

    //showModalScreen("Gathering style guides...", {SHOW_BUSY_BAR:true});
    $.ajax({
        global: false,  // suppress web2py's aggressive error handling?
        type: 'GET',
        dataType: 'json',
        // crossdomain: true,
        // contentType: "application/json; charset=utf-8",
        url: lookupURL,
        complete: function( jqXHR, textStatus ) {
            //hideModalScreen();
            if ((textStatus !== 'success') && (textStatus !== 'parsererror')) {
                var errMsg = 'Sorry, there was an error looking up the available style guides. (See JS console for details.)';
                alert(errMsg); 
                console.warn(errMsg +'\n\ntextStatus='+ textStatus +'\n\n'+ jqXHR.responseText);
                //showErrorMessage(errMsg);
                return;
            }
            // convert raw response to JSON
            var resultsJSON = $.parseJSON(jqXHR.responseText);
            if (resultsJSON.length === 0) {
                alert('No style guides found!');
            } else {
                availableStyleGuides = resultsJSON;
                var $chooser = $('#styleguide-chooser');
                $chooser.find('.found-matches').empty();
                var $currentNameDisplay = $chooser.find('#current-styleguide-name');
                $currentNameDisplay.html( ill.styleGuide.name() );
                if (ill.styleGuide.version) {
                    // pivot based on version type
                    switch(ill.styleGuide.version.type()) {
                        case TreeIllustrator.versionTypes.CHECKSUM:
                            $currentNameDisplay.append('<em class="version">&nbsp; &lt;'+ ill.styleGuide.version.value() +'&gt;</em>');
                            break;
                        case TreeIllustrator.versionTypes.TIMESTAMP:
                            $currentNameDisplay.append('<em class="version">&nbsp;  as of '+ ill.styleGuide.version.value() +'</em>');
                            break;
                        case TreeIllustrator.versionTypes.SEMANTIC:
                            $currentNameDisplay.append('<em class="version">&nbsp; v'+ ill.styleGuide.version.value() +'</em>');
                            break;
                        default:
                            $currentNameDisplay.append('<em class="version">Unknown version type: '+ ill.styleGuide.version.value() +'</em>');
                    }
                }
                $chooser.find('#current-styleguide-source').html( ill.styleGuideSourceHTML() );
                $.each(availableStyleGuides, function(i, match) {
                    // is this the illlustration's current style guide? compare name, source, version
                    var isAssignedStyleGuide = false;
                    var isPreviousVersionOfAssignedStyleGuide = false;
                    if ((match.name === ill.styleGuide.name()) && (match.source.value === ill.styleGuide.source.value())) {
                        isAssignedStyleGuide = true;
                        if (match.version.value !== ill.styleGuide.version.value()) {
                            isPreviousVersionOfAssignedStyleGuide = true;
                        }
                    }
                    var $matchInfo = $('<div class="match"><img class="thumbnail"></img><div class="name"></div><div>Source: <span class="source"></span></div><div class="description"></div></div>');
                    var $thumb = $matchInfo.find('.thumbnail');
                    if (isAssignedStyleGuide) {
                        $matchInfo.addClass('assigned');
                        if (isPreviousVersionOfAssignedStyleGuide) {
                            $matchInfo.addClass('previous-version');
                            $thumb.after('<a class="btn btn-small" href="#" onclick="stylist.applyChosenStyleGuide(this); return false;">Update</a>');
                        } else {
                            $thumb.after('<a class="btn btn-small disabled" href="#" onclick="alert(\'This style guide is already applied to the current illustration.\'); return false;">Assigned</a>');
                        }
                    } else if (match.constraints) {
                        $thumb.after('<a class="btn btn-small" href="#" onclick="stylist.applyChosenStyleGuide(this); return false;">Apply</a>');
                    } else {
                        $thumb.after('<a class="btn btn-small disabled" href="#" onclick="alert(\'Sorry, this is just an empty example.\'); return false;">Example</a>');
                    }
                    $matchInfo.find('.thumbnail').attr('src', match.thumbnailSrc || './broken.png');
                    var $nameDisplay = $matchInfo.find('.name');
                    $nameDisplay.html(match.name || '<em>No name found</em>');
                    if (match.version) {
                        // pivot based on version type
                        switch(match.version.type) {
                            case TreeIllustrator.versionTypes.CHECKSUM:
                                $nameDisplay.append('<em class="version">&nbsp; &lt;'+ match.version.value +'&gt;</em>');
                                break;
                            case TreeIllustrator.versionTypes.TIMESTAMP:
                                $nameDisplay.append('<em class="version">&nbsp;  as of '+ match.version.value +'</em>');
                                break;
                            case TreeIllustrator.versionTypes.SEMANTIC:
                                $nameDisplay.append('<em class="version">&nbsp; v'+ match.version.value +'</em>');
                                break;
                            default:
                                $nameDisplay.append('<em class="version">Unknown version type: '+ match.source.type +'</em>');
                        }
                    }
                    var $sourceDisplay = $matchInfo.find('.source');
                    if (match.source) {
                        // pivot based on source type
                        switch(match.source.type) {
                            case TreeIllustrator.dataSourceTypes.BUILT_IN:
                                $sourceDisplay.html('<strong>Built-in</em>');
                                break;
                            case TreeIllustrator.dataSourceTypes.URL:
                                $sourceDisplay.html('<a target="_blank" href="'+ match.source.value +'">'+ match.source.value +'</a>');
                                break;
                            default:
                                $sourceDisplay.html('<em>Unknown source type: '+ match.source.type +'</em>');
                        }
                    } else {
                        $sourceDisplay.html('<em>No source found</em>');
                    }
                    $matchInfo.find('.description').html( match.description || '<em>No description found</em>');
                    // add a unique key to determine the chosen style guide later
                    var sgKey = match.name +'|'+ (match.version ? match.version.value : "") +'|'+ (match.source ? match.source.value : "");
                    $matchInfo.append('<input type="hidden" class="match-key" value="'+ sgKey +'" />');
                    $chooser.find('.found-matches').append($matchInfo);
                });
                $chooser.off('shown').on('shown', function() {
                    // size scrolling list to fit in the current DOI-lookup popup window
                    var $chooser = $('#styleguide-chooser');
                    var resultsListHeight = $chooser.find('.modal-body').height() - $chooser.find('.before-matches').height();
                    $chooser.find('.found-matches')
                        .outerHeight(resultsListHeight)
                        .css('visibility','visible');
                });
                $chooser.find('.found-matches').css('visibility','hidden');
                $chooser.modal('show');
            }
        }
    });
}

/* General support for direct-manipulation ops (esp. to track dragging with the mouse) */
var dragHandle = null,  // the handle (HTML/SVG element) being dragged, if any
    dragHandleName = null;
    dragStartHandleLoc = null,  // replace with {x:<Number>, y:<Number>}, in screen px; reset to null when done
    dragElement = null, // the Illustration element (eg, IllustratedTree) affected, if any
    dragStartElementProps = null, // related properties of the target element (XY coords, angles, etc.)
    dragCurrentHandleDelta = null;  // cumulative change in X/Y, in screen px; same format as dragStartHandleLoc above

function startDragging( event ) {
    /* Initiate sensible dragging behavior for the current handle and target
     * element.  See *which* hotspot this is to determine correct behavior with
     * the current tree. Key decisions will persist in the vars defined above.
     */
    var $hotspot = $(this).is('path') ? $(this) : $(this).find('path');
    dragHandle = $hotspot[0];
    dragHandleName = $(this).is('.tree-hotspot') ? 'hotspot' : d3.select(this).datum().name;
    // Fetch and examine the related illustration element
    var $elementGroup = $hotspot.closest('g.mark-group[class*=tree-], g.mark-group[class*=dataset-], g.mark-group[class*=ornament-]');
    var elementID = $elementGroup.attr('class').split(/\s+/)[1];
    showAccordionPanelForElement( elementID );
    dragElement = stylist.ill.getElementByID( elementID );
    // On the first mousemove, we'll stash the element's starting properties (in illustration units)
    ///console.log(">> START DRAGGING handle ["+ dragHandleName +"]...");
    // Track locations *relative* to the viewport, so we can drag *and* scroll as needed.
    var $scrollingViewport = $("#viz-outer-frame").find('div.vega');
    dragStartHandleLoc = getIllustrationMouseLoc(event, $scrollingViewport);

    /* TEST updating handles from stored generators
    if (dragHandle) {
        if (dragHandleName === 'hotspot') {
            // update the entire hotspot shape
            console.log("hotspot d BEFORE:"+ d3.select(dragHandle).attr('d'));
            d3.select(dragHandle).attr('d', phylogramTransform.hotspotGenerator());
            console.log("hotspot d AFTER:"+ d3.select(dragHandle).attr('d'));
        } else {
            // update just the positions of all 
        }
    } else {
        console.error("No dragHandle found! How can this be?");
        debugger;
    }
     */
}

function stopDragging( callback ) {
    if (typeof(callback) === 'function') {
        //callback(dragHandle, dragElement, ... );
        callback();
    }
    dragHandle = null;
    dragHandleName = null;
    dragElement = null;
    dragStartHandleLoc = null;
    dragStartElementProps = null;
    dragCurrentHandleDelta = null;
}

$(document).ready(function() {
    $('body').on("mouseup click mouseleave", function ( event ) {
        if (dragHandle) {
            stopDragging(refreshViz);
        }
    });
    $('body').on("mousemove", function ( event ) {
        if (dragHandle) {
            /* Check target element's type and sub-type (eg, a circular tree) and
             * the active handle name. These will dictate the dragging behavior
             * and initialize dragStartElementProps if it's null or empty.
             */
            var $handle = $(dragHandle);
            var $handlesGroup = $handle.closest('g.mark-group.handles');
            // Track locations *relative* to the viewport, so we can drag *and* scroll as needed.
            var $scrollingViewport = $("#viz-outer-frame").find('div.vega');
            var mouseLoc = getIllustrationMouseLoc(event, $scrollingViewport);
            dragCurrentHandleDelta = {
                x: (mouseLoc.x - dragStartHandleLoc.x),
                y: (mouseLoc.y - dragStartHandleLoc.y)
            }

            if (dragElement instanceof TreeIllustrator.IllustratedTree) {
                // determine behavior by specific handles and (perhaps) tree layouts
                switch(dragHandleName) {
                    case 'center':
                    case 'hotspot':
                        // drag to move (translate) the entire tree on the page
                        if (!dragStartElementProps) {
                            dragStartElementProps = { x: dragElement.rootX(), y: dragElement.rootY() };
                        }
                        /* Update the element's rootX and rootY properties.
                         * N.B. this will update the visible UI, but not the viewport!
                         *
                         * For now, this is a direct translation of handle motion to element motion.
                         * TODO: Use constraints to enforce min. sizes, etc. (by tweaking its physicalRootX/Y instead?)
                         */
                        var dragElementToX = dragStartElementProps.x + dragCurrentHandleDelta.x;
                        var dragElementToY = dragStartElementProps.y + dragCurrentHandleDelta.y;
                        //var physicalX = stylist.pixelsToPhysicalUnits(dragToX, stylist.display_ppi);
                        dragElement.rootX( dragElementToX );
                        dragElement.rootY( dragElementToY );
                        // Move *all* handles, not just the main hotspot (no need to redraw or further adjust these)
                        $handlesGroup.attr('transform', "translate("+ dragCurrentHandleDelta.x +","+ dragCurrentHandleDelta.y +")");
                        break;

                    default:
                        // other handles have different behavior based on tree layout
                        switch(dragElement.layout()) {
                            case TreeIllustrator.treeLayouts.TRIANGLE:
                            case TreeIllustrator.treeLayouts.RECTANGLE:
                                /* All vertex handles scale the tree (relative to the root node)
                                 * N.B. that we pay close attention to the *current* extents in the
                                 * viewport, since the rectangular layout has a bounding box that
                                 * depends on the structure and branching patterns of each tree
                                 */
                                if (!dragStartElementProps) {
                                    dragStartElementProps = { rootX: dragElement.rootX(), rootY: dragElement.rootY(),
                                                              width: dragElement.width(), height: dragElement.height() };
                                }
                                // Reckon new width and height as a ratio vs. the original.
                                var newPartialWidth,
                                    oldPartialWidth,
                                    xScale,
                                    newPartialHeight,
                                    oldPartialHeight,
                                    yscale,
                                    newTotalWidth,
                                    newTotalHeight;
                                newPartialWidth = Math.abs(mouseLoc.x - dragStartElementProps.rootX);
                                oldPartialWidth = Math.abs(dragStartHandleLoc.x - dragStartElementProps.rootX);
                                xScale = newPartialWidth / oldPartialWidth;
                                newTotalWidth = dragStartElementProps.width * xScale;

                                // reckon proportional share of width for this handle
                                newPartialHeight = Math.abs(mouseLoc.y - dragStartElementProps.rootY);
                                oldPartialHeight = Math.abs(dragStartHandleLoc.y - dragStartElementProps.rootY);
                                yScale = newPartialHeight / oldPartialHeight;
                                newTotalHeight = dragStartElementProps.height * yScale;

                                /* TODO: Restrict to min. dimensions, OR handle crossing the origin by
                                 *      - if they swap the two vertex handles, they should switch proportions
                                 *      - if they pass the root node, "flip" the tree's tipsAlignment
                                 *
                                console.warn(">>> tips on the "+ dragElement.tipsAlignment());
                                switch(dragElement.tipsAlignment) {
                                    case 'TOP':
                                        break;
                                    case 'RIGHT':
                                        break;
                                    case 'BOTTOM':
                                        break;
                                    case 'LEFT':
                                        break;
                                }
                                */

                                // Update the tree, subject to any constraints
                                dragElement.constrainedWidth( newTotalWidth );
                                dragElement.constrainedHeight( newTotalHeight );
                                // Were the new values accepted? (Allow for minor slippage here.)
                                var inBounds = (Math.abs(dragElement.width() - newTotalWidth) < 2) &&
                                               (Math.abs(dragElement.height() - newTotalHeight) < 2);

                                // Scales used for the hotspot should reflect any active constraints
                                var constrainedXScale = dragElement.width() / dragStartElementProps.width;
                                var constrainedYScale = dragElement.height() / dragStartElementProps.height;

                                /* Update hotspot and handle positions */
                                // Scale the main hotspot to match the ratios of old vs. new...
                                var $hotspot = $handlesGroup.find('.tree-hotspot path');
                                $hotspot.attr('transform', "scale("+ constrainedXScale +","+ constrainedYScale +")");
                                // ... hide its border (beause scaling stroke-width is ugly)
                                $hotspot.css('stroke-opacity', '0');
                                if (inBounds) {
                                    $hotspot.removeAttr('class');
                                } else {
                                    $hotspot.attr('class', 'out-of-bounds');
                                }

                                // ... and move the vertex handles to match ("push" from origin) by 
                                // modifying the datum for each, then *carefully* updating its transforms.
                                var $vertexHandles = $handlesGroup.find('.vertex-handle path');
                                if (inBounds) {
                                    $vertexHandles.removeAttr('class');
                                } else {
                                    $vertexHandles.attr('class', 'out-of-bounds');
                                }
                                $vertexHandles.each(function(i, path) {
                                    var d3el = d3.select(path);
                                    var itsDatum = d3el.datum().datum;
                                    if (!('old_x' in itsDatum)) {
                                        // stash original value (once only)
                                        itsDatum.old_x = itsDatum.x || 0;
                                        itsDatum.old_y = itsDatum.y || 0;
                                    }
                                    itsDatum.x = itsDatum.old_x * constrainedXScale;
                                    itsDatum.y = itsDatum.old_y * constrainedYScale;
                                });
                                resetActualSizeElements();

                                break;

                            case TreeIllustrator.treeLayouts.CIRCLE:
                                // Track the same properties for all remaining handles
                                if (!dragStartElementProps) {
                                    dragStartElementProps = { rootX: dragElement.rootX(), rootY: dragElement.rootY(), 
                                                              radius: dragElement.radius(),
                                                              startAngle: dragElement.startAngle(), endAngle: dragElement.endAngle() };
                                }
                                // Track original and new radius
                                /* Ignore dragCurrentHandleDelta; just reckon current mouseLoc in viewport
                                 * (illustration) coordinates and measure the distance from the root node.
                                 */
                                var xDistance = mouseLoc.x - dragStartElementProps.rootX;
                                var yDistance = mouseLoc.y - dragStartElementProps.rootY;
                                var hypotenuse = Math.sqrt( Math.pow(xDistance, 2) + Math.pow(yDistance, 2) );
                                dragElement.constrainedRadius( hypotenuse );

                                switch(dragHandleName) {
                                    case 'radius':
                                        /* Update hotspot and handle positions */
                                        // Scale the main hotspot to match the ratio of old vs. new...
                                        var oldRadius = dragStartElementProps.radius,
                                            pendingRadius = dragElement.radius(),  // reflect active constraints!
                                            sizeChangeRatio = pendingRadius / oldRadius;
                                        var $hotspot = $handlesGroup.find('.tree-hotspot path');
                                        var inBounds = (pendingRadius === hypotenuse);
                                        if (inBounds) {
                                            $hotspot.removeAttr('class');
                                        } else {
                                            $hotspot.attr('class', 'out-of-bounds');
                                        }
                                        $hotspot.attr('transform', "scale("+ sizeChangeRatio +")");
                                        // ... hide its border (beause scaling stroke-width is ugly)
                                        $hotspot.css('stroke-opacity', '0');
                                        // ... and move the vertex handles to match ("push" from origin) by 
                                        // modifying the datum for each, then *carefully* updating its transforms.
                                        var $vertexHandles = $handlesGroup.find('.vertex-handle path');
                                        if (inBounds) {
                                            $vertexHandles.removeAttr('class');
                                        } else {
                                            $vertexHandles.attr('class', 'out-of-bounds');
                                        }
                                        $vertexHandles.each(function(i, path) {
                                            var d3el = d3.select(path);
                                            var itsDatum = d3el.datum().datum;
                                            if (!('old_x' in itsDatum)) {
                                                // stash original value (once only)
                                                itsDatum.old_x = itsDatum.x || 0;
                                                itsDatum.old_y = itsDatum.y || 0;
                                            }
                                            itsDatum.x = itsDatum.old_x * sizeChangeRatio;
                                            itsDatum.y = itsDatum.old_y * sizeChangeRatio;
                                        });
                                        resetActualSizeElements();

                                        break;

                                    case 'start-angle':
                                    case 'end-angle':
                                        // These should change radius *and* arc angles
                                        var handleInfo = d3.select(dragHandle).datum().datum; // includes .angle, .theta, etc
                                        ///console.log(handleInfo);
                                        var newAngleInRadians = Math.atan2( yDistance, xDistance );
                                        // convert from radians to degrees and force to range from 0-360
                                        var newAngleInDegrees = utils.normalizeDegrees( utils.radiansToDegrees( newAngleInRadians ) );
                                        dragElement[ dragHandleName === 'start-angle' ? 'startAngle' : 'endAngle' ]( newAngleInDegrees );

                                        /* Update hotspot and handle positions */
                                        var isClockwise = (dragElement.radialSweep() === TreeIllustrator.sweepDirections.CLOCKWISE),
                                            pendingRadius = dragElement.radius(),  // reflect active constraints!
                                            pendingStartAngle = dragElement.startAngle(),
                                            pendingEndAngle = dragElement.endAngle(),
                                            totalArcDegrees = isClockwise ?
                                                utils.normalizeDegrees(pendingEndAngle - pendingStartAngle) :
                                                utils.normalizeDegrees(pendingStartAngle - pendingEndAngle),
                                            usingLargeArc = (totalArcDegrees >= 180),
                                            pendingStartAngleVertex = {
                                                // Reckon this from the angle and radius (hypotenuse)
                                                x: pendingRadius * Math.cos( utils.degreesToRadians(pendingStartAngle) ), // Fx = F cos(a)
                                                y: pendingRadius * Math.sin( utils.degreesToRadians(pendingStartAngle) )  // Fy = F sin(a)
                                            },
                                            pendingEndAngleVertex = {
                                                x: pendingRadius * Math.cos( utils.degreesToRadians(pendingEndAngle) ),
                                                y: pendingRadius * Math.sin( utils.degreesToRadians(pendingEndAngle) )
                                            },
                                            midArcAngle = isClockwise ?
                                                utils.normalizeDegrees(pendingStartAngle + (totalArcDegrees/2)) :
                                                utils.normalizeDegrees(pendingStartAngle - (totalArcDegrees/2)),
                                            pendingRadiusControlVertex = {
                                                x: pendingRadius * Math.cos( utils.degreesToRadians(midArcAngle) ),
                                                y: pendingRadius * Math.sin( utils.degreesToRadians(midArcAngle) )
                                            };
                                        var $hotspot = $handlesGroup.find('.tree-hotspot path');
                                        var newAngle = dragElement[ dragHandleName === 'start-angle' ? 'startAngle' : 'endAngle' ]();
                                        var inBounds = (pendingRadius === hypotenuse) &&
                                                       (newAngle === newAngleInDegrees);
                                        if (inBounds) {
                                            $hotspot.removeAttr('class');
                                        } else {
                                            $hotspot.attr('class', 'out-of-bounds');
                                        }

                                        $hotspot.attr('d', generateRadialHotspotPath(
                                            usingLargeArc,
                                            isClockwise,
                                            pendingRadius,
                                            pendingStartAngleVertex,
                                            pendingEndAngleVertex
                                        ));
                                        // ... hide its border (beause scaling stroke-width is ugly)
                                        $hotspot.css('stroke-opacity', '0');
                                        // ... and move the vertex handles to match ("push" from origin) by
                                        // modifying the datum for each, then *carefully* updating its transforms.
                                        var $vertexHandles = $handlesGroup.find('.vertex-handle path');
                                        if (inBounds) {
                                            $vertexHandles.removeAttr('class');
                                        } else {
                                            $vertexHandles.attr('class', 'out-of-bounds');
                                        }
                                        $vertexHandles.each(function(i, path) {
                                            var d3el = d3.select(path);
                                            var itsDatum = d3el.datum().datum;
                                            switch( itsDatum.name ) {
                                                case 'center':
                                                    // this never moves
                                                    break;
                                                case 'start-angle':
                                                    itsDatum.x = pendingStartAngleVertex.x;
                                                    itsDatum.y = pendingStartAngleVertex.y;
                                                    break;
                                                case 'end-angle':
                                                    itsDatum.x = pendingEndAngleVertex.x;
                                                    itsDatum.y = pendingEndAngleVertex.y;
                                                    break;
                                                case 'radius':
                                                    itsDatum.x = pendingRadiusControlVertex.x;
                                                    itsDatum.y = pendingRadiusControlVertex.y;
                                                    break;
                                            }
                                        });
                                        resetActualSizeElements();
                                        break;

                                    default:
                                        console.error('Unknown drag handle ['+ dragHandleName +']');
                                        return;
                                }
                                break;
                        }
                }
            /*
            ... else if (dragElement instanceof TreeIllustrator.SupportingDataset) {
                // TODO
            } else if (dragElement instanceof TreeIllustrator.Ornament) {
                // TODO
            */
            } else {
                console.error("drag logic: unexpected element type: '"+ dragElement.metadata.type() +"'!");
                return;
            }

        }
    });
});

function generateRadialHotspotPath( largeArc, sweepValue, radius, startPoint, endPoint ) {
    /* Return a path that sweeps an arc around origin 0,0
     *  EXAMPLE: "M0,0 L36.79,231.24 A234.14,234.14 0 0,1 -209.42,104.73 Z"
     * ASSUMES that angles are in radians!
     * Adapted from `vg.data.phylogram.js`, see also:
     *  https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Arcs
     *  http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
     */
    var rotation = 0,  // this is moot for a circle
        //clockwise = Math.abs(midAngle - srcAngle) > Math.PI ? midAngle <= srcAngle : midAngle > srcAngle,
        largeArc = Number(largeArc),
        sweepValue = Number(sweepValue);
    var path = "M0,0" +
      " L"+ [startPoint.x,startPoint.y] +
      " A" + [radius,radius] +' '+ rotation +' '+ largeArc +','+ sweepValue +' '+ [endPoint.x,endPoint.y] +
      " Z";
    return path;
}

function getViewportMouseLoc(event, $scrollingViewport) {
    // Reckon mouse position as display px, relative to the SVG viewport
    var vpOffset = $scrollingViewport.offset();
    return {
        x: (event.pageX - vpOffset.left + $scrollingViewport.scrollLeft()),
        y: (event.pageY - vpOffset.top + $scrollingViewport.scrollTop())
    };
}
function getIllustrationMouseLoc(event, $scrollingViewport) {
    /* Reckon mouse position in the illustration's SVG coordinates.
     * N.B. that d3 provides an easy method for this, but it can't be called
     * except within a (d3) event handler on the SVG element itself.
     *   https://github.com/mbostock/d3/blob/master/src/event/mouse.js
     *   http://stackoverflow.com/a/27434285
     * FAILS HERE: console.error( d3.mouse(d3.select('div.vega > svg')) );
     */
    /* This code invokes the d3 location test, but can't return a value directly.
       To see it in action, uncomment both blocks marked D3_MOUSE_SENSING
    var evt = document.createEvent ("MouseEvent");
    evt.initMouseEvent("mousetest", true, true, window, 0,
                       event.screenX, event.screenY, event.clientX, event.clientY,
                       event.ctrlKey, event.altKey, event.shiftKey, event.metaKey,
                       0, null);
    $('div.vega > svg')[0].dispatchEvent(evt);
    */

    var viewportLoc = getViewportMouseLoc(event, $scrollingViewport);
    // Reverse the current magnification and allow for padded viewport
    return {
        x: (viewportLoc.x / viewportMagnification) + viewbox.x,
        y: (viewportLoc.y / viewportMagnification) + viewbox.y
    };
}

/* The current Vega spec is generated using the chosen style (above) and 
 * the illustration source and decisions made in the web UI. When the
 * illustration is saved, the latest can also be embedded. Or perhaps we should
 * always generate it fresh from the source data and scene graph whenn
 * (re)loading the illustration?
 */
var vegaSpec;
var view; // a Vega ViewComponent (use to set signals, updates, etc.)
function refreshViz(options) {
    var startTime = new Date();
    console.warn('refreshViz() STARTING');
    if (!options) options = {}; 

    ill.updateVegaSpec();  // TODO: trigger updates on a more sensible basis

    vg.parse.spec(ill.vegaSpec, function(chart) {
        view = chart({el:"#viz-outer-frame", renderer:"svg"});
        // export the new view
        exports.view = view;
        view.update();

        if (options.SHOW_ALL) {
            resizeViewportToShowAll();
        } else {
            initTreeIllustratorWindow();
        }

        /* (Re)bind event handlers for element hotspots */
        // N.B. jQuery event delegation doesn't seem to work with SVG elements!
        var $scrollingViewport = $("#viz-outer-frame").find('div.vega');
        //$scrollingViewport.delegate(".tree-hotspot", "click hover mouseover mouseout mouseenter mouseleave", function ...
        $scrollingViewport.find('g.handles')
            .off('.hotspot')  // remove any prior bindings
            .on("mouseenter.hotspot", function ( event ) {
                if (!dragElement) {
                    var el = getIllustrationElementFromHandle(this);
                    showElementHandles(el);
                }
            })
            .on("mouseleave.hotspot", function ( event ) {
                var el = getIllustrationElementFromHandle(this);
                if (dragElement !== el) {
                    hideElementHandles(el);
                }
            });

        // We can't add proper IDs for vertex handles, but startDragging will adapt
        var allHandles = $scrollingViewport.find('.tree-hotspot, .handles .vertex-handle path')
            .css('cursor','move')
            .off('.hotspot')  // remove any prior bindings
            //.on("mouseenter.hotspot mouseleave.hotspot mousedown.hotspot mouseup.hotspot click.hotspot mousemove.hotspot", function ( event ) {
            .on("mousedown.hotspot", startDragging);

        // Add SVG 'title' elements to provide tool-tips for all hotspots
        $.each(allHandles, function(i, h) {
            // extract and display its description as a tooltip
            var $handle = $(this);
            var d3handle = d3.select(this);
            var tooltip = "TODO: Add a tooltip for this handle!";
            if (d3handle.datum()) {
                tooltip = d3handle.datum().tooltip;
            } else {
                // Some handles (esp. hotspots) don't have data
                if ($handle.is('.tree-hotspot')) {
                    tooltip = "Drag to move this tree on the page.";
                }
            }
            d3handle.append("svg:title")
                    .text(tooltip);
        });

    /* This code activates a d3 location test in response to a custom event,
     * but it can't return a value directly. To see this in action, uncomment
     * both blocks marked D3_MOUSE_SENSING
        d3.select('div.vega > svg').on('mousetest', function () {
            console.warn( d3.mouse(this) );
        });
     */

    });
    console.warn("refreshViz() took "+ (new Date() - startTime) +" ms to complete");
}
function getIllustrationElementFromHandle( handle ) {
    // Should this use assigned datum instead?
    var $elementGroup = $(handle).closest('g.mark-group[class*=tree-], g.mark-group[class*=dataset-], g.mark-group[class*=ornament-]');
    var elementID = $elementGroup.attr('class').split(/\s+/)[1];
    // ASSUMES a predictable class attribute, e.g. 'group-marks tree-3'
    return stylist.ill.getElementByID( elementID );
}
function getElementHandlesGroup( illElement ) {
    // Find the SVG group holding all handles for a given IllustratedTree/etc.
    var $elementGroup = $('div.vega svg g.illustration-elements g.mark-group[class*='+ illElement.id() +']');
    var $handlesGroup = $elementGroup.find('g.mark-group.handles');
    return $handlesGroup;
}
function showElementHandles( illElement ) {
    // Show all handles for a given IllustratedTree/etc.
    var $handlesGroup = getElementHandlesGroup( illElement );
    var $hotspot = $handlesGroup.find('.tree-hotspot path');
    $hotspot.css({
        'fillOpacity': "0.2",
        'strokeOpacity': "0.6"
    });
    var $handles = $handlesGroup.find('.vertex-handle path');
    $handles.css({
        'fillOpacity': "1.0",
    });
}
function hideElementHandles( illElement ) {
    // Hide all handles for a given IllustratedTree/etc.
    var $handlesGroup = getElementHandlesGroup( illElement );
    var $hotspot = $handlesGroup.find('.tree-hotspot path');
    $hotspot.css({
        'fillOpacity': "0",
        'strokeOpacity': "0"
    });
    var $handles = $handlesGroup.find('.vertex-handle path');
    $handles.css({
        'fillOpacity': "0",
    });
}


var ill;  

// Keep safe copy of list-containing markup for re-use as a Knockout template (see below)
var $stashedEditArea = null;

// Load an illustration from JS/JSON data (usu. called by convenience functions below)
function loadIllustrationData( data, initialCache, newOrExisting ) {
    // Use an Illustration object as our primary view model for KnockoutJS
    // (by convention, it's usually named 'viewModel')
    ill = new TreeIllustrator.Illustration( data );
    // export the new illustration
    exports.ill = ill;

    // Clear any existing cached data from the illustration rendering pipeline;
    // use initial data if provided by the caller.
    if (typeof initialCache === 'object') {
        TreeIllustrator.flushCache( initialCache );
    } else {
        TreeIllustrator.flushCache( );
    }

    /* TODO: handle the newOrExisting storage info? or maybe this is
     * handled by the storage backend...
     */

    // add a single placeholder tree
    if (!data) {
        ill.addIllustratedTree();
    }

    if ($stashedEditArea === null) {
        // Stash the pristine markup before binding this popup for the first time
        $stashedEditArea = $('#ti-main-accordion').clone();
        /*
        $stashedCollectionDecisionElement = $('#tree-collection-viewer')
            .find('#tree-collection-decisions > tr.single-tree-row').eq(0).clone();
        */
    } else {
        // Replace with pristine markup to avoid weird results when loading a new illustration
        $('#ti-main-accordion').contents().replaceWith(
            $stashedEditArea.clone().contents()
        );
    }

    // (re)bind to editor UI with Knockout
    var $boundElements = $('#editor'); // add other elements?
    $.each($boundElements, function(i, el) {
        ko.cleanNode(el);
        ko.applyBindings(ill,el);
    });

    refreshViz( {SHOW_ALL: true} );
}
function loadEmptyIllustration() {
    /* Load an empty illustration with a placeholder tree, with
     * no ID or slot assigned (i.e., treat this as a new illustration).
     *
     * TODO: Replace this with a simple template?
     */
    loadIllustrationData( null, {}, 'NEW' );
    clearLastSavedInfo();
}
// N.B. There should be additional convenience functions in the storage backend
//  - fetchAndLoadExistingIllustration( docID )
//  - fetchAndLoadIllustrationTemplate( templateID )

function fetchAndLoadExistingIllustration( backend, docID ) {
    /* Load the JS (or JSON?) data provided, and keep track of its original ID/slot.
     */
    storage[ backend ].loadIllustration(docID, function(response) {
        if ('data' in response) {
            var data = response.data;
            loadIllustrationData( data, {}, 'EXISTING' );
            // update last-saved info
            updateLastSavedInfo(backend, docID);
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}
function fetchAndLoadIllustrationTemplate( backend, templateID ) {
    /* Load the JS (or JSON) data provided, but treat this as a new illustration.
     *
     * N.B. A template is basically an existing illustration document, with
     * internal prompts and placeholder trees/data, but we'll treat it as new.
     */
    // TODO: fetch using storage backend
    storage[ backend ].loadIllustration(docID, function(response) {
        if ('data' in response) {
            var template = response.data;
            loadIllustrationData( template, {}, 'NEW' );
            clearLastSavedInfo();  // so we don't overwrite the template!
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}

$(document).ready(function() {
    // test for the preset ppi (pixels / inch) in this browser
    browser_ppi = $('#svg-toolbox').width() / 10.0;
    $('#svg-toolbox').hide();  // to avoid crazy page width in Firefox
    // NOTE that this is still unlikely to match the physical size of any particular monitor!
    // If that's important, we might want to let the user tweak this value.
    $('#browser-ppi-indicator').text(browser_ppi);
    $('#display-ppi-indicator').text(display_ppi);

    // show or disable the full-screen widgets
    var $fullScreenToggle = $('button#enter-full-screen');
    if ($.fullscreen.isNativelySupported()) {
        // ie, the current browser supports full-screen APIs
        $fullScreenToggle.show();
        $(document).bind('fscreenchange', function(e, state, elem) {
            // if we currently in fullscreen mode
            if ($.fullscreen.isFullScreen()) {
                $('#enter-full-screen').hide();
                $('#exit-full-screen').show();
            } else {
                $('#enter-full-screen').show();
                $('#exit-full-screen').hide();
            }
        });
    } else {
        // dim and disable the full-screen toggle
        $fullScreenToggle.css("opacity", "0.5")
                         .click(function() {
                            alert("This browser does not support full-screen display.");
                            return false;
                         })
                         .show();
    }

    // TODO: Add "safety net" if there are unsaved changes
    // TODO: Add JSON support for older IE?

    // Update the list with initial values
    updateAvailableTrees();

    // Has my opener provided an initial illustration or template? If so, load it now
    var startingID = getParameterByName('startingID');
    console.log(">> startingID: "+ startingID +" <"+ typeof(startingID) +">");
    var startingType = getParameterByName('startingType');
    console.log(">> startingType: "+ startingType +" <"+ typeof(startingType) +">");
    // N.B. This should be a string, so '0' is a valid slot identifier!
    if (startingID) {
        // Which storage backend should we use? Depends on the host app
        var backend;
        switch (hostApplication) {
            case (TreeIllustrator.hostApplications.JUPYTER_NOTEBOOK):
                // ASSUME we're being passed a storage slot number
                backend = TreeIllustrator.storageBackends.JUPYTER_NOTEBOOK;
                break;
            case (TreeIllustrator.hostApplications.STANDALONE):
                // ASSUME we're being passed a phylesystem id (stored on GitHub)
                backend = TreeIllustrator.storageBackends.GITHUB_REPO;
                break;
            default:
                console.error("Unexpected hostApplication found ('"+ hostApplication +"')!");
                return;
        }

        switch (startingType) {
            case 'ILLUSTRATION':
                fetchAndLoadExistingIllustration( backend, startingID );
                break;
            case 'TEMPLATE':
                fetchAndLoadIllustrationTemplate( backend, startingID );
                break;
            default:
                console.error("No startingType provided (expected 'ILLUSTRATION' or 'TEMPLATE')!");
                return;
        }
    } else {
        loadEmptyIllustration();
    }

    matchViewportToWindowSize();

    // enable hiding/showing the "sidecar" UI
    $('.sidecar-toggle')  // ie, the splitter and all pull tabs
        // change color (of *all* toggling elements) on mouseover
        .unbind('hover').hover(function() {
            $('.sidecar-toggle').addClass('hovering');
        }, function() {
            $('.sidecar-toggle').removeClass('hovering');
        })
        // hide/show (based on current position)
        .unbind('click').click(function(e) {
            e.stopPropagation();  // don't trigger my parent elements!
            var currentlyVisible = $('#sidecar').css('right') === '0px';
            var hiddenX = -( $('#sidecar').width() );
            var visibleX = 0;
            if (currentlyVisible) {
                $('#sidecar').css('right', hiddenX);
                $('#sidecar-pulltab a').removeClass('icon-chevron-right')
                                       .addClass('icon-chevron-left');
            } else {
                $('#sidecar').css('right', visibleX);
                $('#sidecar-pulltab a').removeClass('icon-chevron-left')
                                       .addClass('icon-chevron-right');
            }
            matchViewportToWindowSize();
            zoomViewport('REFRESH');
        });

    // resizing the window should refresh/resize the viewport
    $(window).resize(function() {
        try {
            matchViewportToWindowSize();
            zoomViewport('REFRESH');
        } catch(e) {
            console.warn("Unable to complete resize:");
            console.warn(e);
        }
    });
});

function buildStudyFetchURL( studyID ) {
    // ASSUMES we're using the phylesystem API to load studies from the OpenTree dev site
    var template = "https://api.opentreeoflife.org/phylesystem/v1/study/{STUDY_ID}?output_nexml2json=1.0.0&auth_token=ANONYMOUS"
    return template.replace('{STUDY_ID}', studyID);
}

/*
function useChosenStyle() {
    viewModel.style = getChosenStyle();
    refreshViz();
}
function getChosenStyle() {
    var styleName = $('#style-chooser').val();
    return getStyleByName( styleName );
}
function getStyleByName( styleName ) {
    var selectedStyles = $.grep(availableStyles, function(o) {return o.name === styleName;});
    var styleInfo = null;
    if (selectedStyles.length > 0) {
        styleInfo = selectedStyles[0];
    }
    if (!styleName || !styleInfo) {
        console.warn("No style found under '"+ styleName +"'!");
        return null;
    }
    return styleInfo.style;
}
*/

function toggleFixedRulers(toggle) {
    var rulersAreHidden = $('#viz-outer-frame').hasClass('hide-rulers');
    var $toggleBtn = $(toggle);
    if (rulersAreHidden) {
        // show them now
        $('#viz-outer-frame').removeClass('hide-rulers');
        $toggleBtn.text('Hide rulers');
    } else {
        // hide them now
        $('#viz-outer-frame').addClass('hide-rulers');
        $toggleBtn.text('Show rulers');
    }
    updateViewportViewbox();
    zoomViewport('REFRESH');
}

function initTreeIllustratorWindow() {
    var $outerFrame = $("#viz-outer-frame");
    var $scrollingViewport = $outerFrame.find('div.vega');
    var $rulerUnitsDisplay = $outerFrame.find('#fixed-ruler-units');
    var $topRuler = $outerFrame.find('#fixed-ruler-top');
    var $leftRuler = $outerFrame.find('#fixed-ruler-left');
    var viewportElement = $scrollingViewport[0];
    //var scrollbarWidth = .offsetWidth - viewportElement.clientWidth;
    var topRulerAdjustedWidth = viewportElement ? viewportElement.clientWidth : $topRuler.width();
    var leftRulerAdjustedHeight = viewportElement ? viewportElement.clientHeight : $topRuler.height();

    $rulerUnitsDisplay.css({
        'width': rulerWidth +"px",
        'height': rulerWidth +"px",
        'line-height': rulerWidth +"px",
        'font-size': Math.floor(rulerWidth / 2.5) +"px"
    });
    $topRuler.css({
        'height': rulerWidth+"px",
        // adjust width since there's no scrollbar here
        'width': topRulerAdjustedWidth +'px',
        'margin-right': -rulerWidth+"px"
    });
    $leftRuler.css({
        'width': rulerWidth+"px",
        // adjust height since there's no scrollbar here
        'height': leftRulerAdjustedHeight +'px',
        'margin-bottom': -rulerWidth+"px"
    });
    $scrollingViewport.css('margin-right', -(rulerWidth+1)+"px");

    // reset units display; clear old rulers
    $rulerUnitsDisplay.text( ill.style.printSize.units() === TreeIllustrator.units.INCHES ? "in" : "cm" );

    // adjust viewport/viewbox to reflect current magnification (display_ppi)
    updateViewportViewbox( $scrollingViewport );

    resetActualSizeElements();

    // sync scrolling of rulers to viewport
    //TODO: delegate these for one-time call!
    $scrollingViewport.off('scroll').on('scroll', function() {
        $topRuler.scrollLeft($scrollingViewport.scrollLeft());
        $leftRuler.scrollTop($scrollingViewport.scrollTop());
    });

    // sync resizing of rulers to viewport
    // (no event for this except on the window, it's an on-demand thing)
    var viewportWidth = $scrollingViewport[0].scrollWidth;
    var viewportHeight = $scrollingViewport[0].scrollHeight;
    var topRulerScale = d3.scale.linear()
        .domain([
            pixelsToPhysicalUnits(viewbox.x, internal_ppi),
            pixelsToPhysicalUnits(viewbox.x + viewbox.width, internal_ppi)
        ])
        .range([
            0,
            viewportWidth
        ]);
    var topRuler = d3.select("#fixed-ruler-top svg")
        .attr("width", viewportWidth+"px")
        .attr("height", rulerWidth+"px");
    drawRuler(topRuler, 'HORIZONTAL', ill.style.printSize.units(), topRulerScale);

    var leftRulerScale = d3.scale.linear()
        .domain([
            pixelsToPhysicalUnits(viewbox.y, internal_ppi),
            pixelsToPhysicalUnits(viewbox.y + viewbox.height, internal_ppi)
        ])
        .range([
            0,
            viewportHeight
        ]);
    var leftRuler = d3.select("#fixed-ruler-left svg")
        .attr("width", rulerWidth+"px")
        .attr("height", viewportHeight+"px");
    drawRuler(leftRuler, 'VERTICAL', ill.style.printSize.units(), leftRulerScale);

    enableViewportMask();
}

function resetActualSizeElements() {
    /* Resize any actual-sizes elements (e.g. manipulation handles) in the viewport.
     * N.B. We do this by inverting the current viewport magnification. Sneaky!
     */
    var actualSizeElements = d3.selectAll('#viz-outer-frame .actual-size path');
    actualSizeElements.attr("transform", function(d) {
        // We use the datum from phylogram model, e.g. vertexHandles[0]
        return "translate("+ (d.datum.x || 0) +","+ (d.datum.y || 0) +") scale("+ (1 / viewportMagnification) +")";
    });
}

function roundToNearest( interval, input ) {
    // round to something more interesting than "any integer"
    // EXAMPLE: roundToNearest( 0.125, -0.52 ) ==>  -0.5
    // EXAMPLE: roundToNearest( 7, 46 ) ==>  49
    return Math.round(input / interval) * interval;
}

function drawRuler( svgParent, orientation, units, scale ) {
    /* Draw a ruler in the chosen context (assumes SVG or child of an SVG), with
        - appropriate units
        - sensible/legible subticks (eg, millimeters or sixteenths of an inch) 
        - size and adjust based on orientation (HORIZONTAL | VERTICAL)
     */
    // clear any prior ruler group
    svgParent.selectAll('*').remove();
    var nudgeTop = orientation === 'VERTICAL' ? 0 : rulerWidth - 1;
    var nudgeLeft = orientation === 'VERTICAL' ? rulerWidth - 1 : 0;

    var rulerAxis = d3.svg.axis()
        .scale(scale)
        .tickValues(d3.range(
            roundToNearest(1.0, scale.domain()[0]), 
            roundToNearest(1.0, scale.domain()[1] + 1), 
            1))
        .tickFormat(d3.format('d'))  // whole numbers
        .orient( orientation === 'VERTICAL' ? 'left' : 'top' );

    svgParent
        .append("g")
        .attr("class",'outer-axis')
        .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
        .call(rulerAxis);

    if (units === 'INCHES') {
        // trying subticks, using additional axes on the same scale
        var inchWidth = inchesToPixels(1, display_ppi);
        subticksAxis = d3.svg.axis()
            .scale(scale)
            .tickValues(d3.range(
                roundToNearest(0.5, scale.domain()[0]), 
                roundToNearest(0.5, scale.domain()[1]), 
                0.5))
            .tickFormat('') // unlabeled
            .tickSize(6)
            .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
        svgParent
            .append("g")
            .attr("class",'outer-axis')
            .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
            .call(subticksAxis);

        subticksAxis = d3.svg.axis()
            .scale(scale)
            .tickValues(d3.range(
                roundToNearest(0.25, scale.domain()[0]), 
                roundToNearest(0.25, scale.domain()[1]), 
                0.25))
            .tickFormat('') // unlabeled
            .tickSize(4)
            .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
        svgParent
            .append("g")
            .attr("class",'outer-axis subticks')
            .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
            .call(subticksAxis);

        if (inchWidth > 20) {
            subticksAxis = d3.svg.axis()
                .scale(scale)
                .tickValues(d3.range(
                    roundToNearest(0.125, scale.domain()[0]), 
                    roundToNearest(0.125, scale.domain()[1]), 
                    0.125))
                .tickFormat('') // unlabeled
                .tickSize(2)
                .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
            svgParent
                .append("g")
                .attr("class",'outer-axis subticks')
                .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
                .call(subticksAxis);
        }
    } else {
        // draw ticks for millimeters
        var cmWidth = centimetersToPixels(1, display_ppi);
        if (cmWidth > 30) {
            subticksAxis = d3.svg.axis()
                .scale(scale)
                .tickValues(d3.range(
                    roundToNearest(0.1, scale.domain()[0]), 
                    roundToNearest(0.1, scale.domain()[1]), 
                    0.1))
                .tickFormat('') // unlabeled
                .tickSize(3)
                .orient( orientation === 'VERTICAL' ? 'left' : 'top' );
            svgParent
                .append("g")
                .attr("class",'outer-axis subticks')
                .attr("transform", "translate("+ nudgeLeft +", "+ nudgeTop +")")
                .call(subticksAxis);
        }
    }
}

var topBarHeight;
function matchViewportToWindowSize() {
    if (!topBarHeight) {
        topBarHeight = $('#top-bar').height();
        // freeze the control bar at its current height        
        $('#top-bar').height(topBarHeight);
    }
    var columnHeight = $('#sticky-viewer-frame').height();
    var availableHeight = columnHeight - topBarHeight;
    var $outerFrame = $("#viz-outer-frame");
    var nudge = -36;  // allow for scrollbars, etc.
    $outerFrame.height(availableHeight + nudge);

    // adjust width based on position of sidecar
    var availableWidth = $('#sidecar').offset().left;
    nudge = -28;  // allow for scrollbars, etc.
    $outerFrame.width(availableWidth + nudge);
}

var viewportMagnification = 1.0;
function zoomViewport( directionOrZoomLevel ) {
    // let's use simple, proportional steps up and down
    var stepUp = 1.25;
    var stepDown = 0.8;  // should be inverse of stepUp
    var previousMagnification = viewportMagnification;

    switch(directionOrZoomLevel) {
        case 'REFRESH':
            // just update at the current magnification (e.g. when window is resized)
            break;
        case 'IN':
            viewportMagnification *= stepUp;
            break;
        case 'OUT':
            viewportMagnification *= stepDown;
            break;
        default: 
            // assume it's an explicit zoom level, where 1.0 means "actual size"
            viewportMagnification = directionOrZoomLevel;
            break;
    }
    display_ppi = internal_ppi * viewportMagnification;
    $('#display-ppi-indicator').text(display_ppi);

    // TODO: reset center point of viewbox? based on click XY, or current center?
    // TODO: update scrollTop, scrollLeft to stay in place?

    initTreeIllustratorWindow();
}

/* Manage handles (embed/remove SVG) for direct manipulation of trees, etc.
 * CURRENTLY UNUSED! in favor of "inline" handles for each element.
 */
function addElementHandles() {
    // CURRENTLY UNUSED
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("addElementHandles(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#handles").empty()) {
        // create a linked instance of handles
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'handles')
                .attr('xlink:href', '#manipulation-handles');
    }
    // TODO: clear and (re)build handles for all active elements?
}
function removeElementHandles() {
    // CURRENTLY UNUSED
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#handles").remove();
}

/* Convert between internal viewport coordinates and handle overlay (a second
 * SVG with UI for direct manipulation of trees, etc.)
 */
function internalUnitsToOverlayPixels( coords ) {
    console.log("display_ppi: "+ display_ppi);
    assert((('x' in coords) && ('y' in coords)),
           "Incoming object should include 'x' and 'y' properties.");
    return {
        x: coords.x * display_ppi,
        y: coords.y * display_ppi 
    };
}
function overlayPixelsToInternalUnits(coords) {
    console.log("display_ppi: "+ display_ppi);
    assert((('x' in coords) && ('y' in coords)),
           "Incoming object should include 'x' and 'y' properties.");
    return {
        x: coords.x / display_ppi,
        y: coords.y / display_ppi 
    };
}

function resizeViewportToShowAll() {
    // show full illustration bounds (and all SVG elements!) in the viewport
    var bbox = getInclusiveIllustrationBoundingBox();

    // match the viewport's proportions (width/height)
    var $viewport = $("#viz-outer-frame div.vega");
    // NOTE that we want to match its *inner* size, not incl. scrollbars!
    var divWidth = $viewport[0].clientWidth;
    var divHeight = $viewport[0].clientHeight;
    // compare its proportions to our bounding box; pad as needed to match
    // TODO: this is duplicate code! refactor to DRY
    var divProportions = divWidth / divHeight;
    var bboxProportions = bbox.width / bbox.height;
    if (divProportions > bboxProportions) {
        // div is wider, pad bbox width to match
        var adjustedWidth = divProportions * bbox.height;
        var extraWidth = adjustedWidth - bbox.width;
        bbox.width = adjustedWidth;
        bbox.x -= (extraWidth / 2);
    } else {
        // div is taller (or equal), pad bbox height to match
        var flippedDivProportions = divHeight / divWidth;
        var adjustedHeight = flippedDivProportions * bbox.width;
        var extraHeight = adjustedHeight - bbox.height;
        bbox.height = adjustedHeight;
        bbox.x -= (extraHeight / 2);
    }

    // copy to our persistent viewbox
    for (var prop in bbox) {
        viewbox[prop] = bbox[prop];
    }

    // TODO: match the viewport's final size (disabled scrollbars)?
    
    /* Scale the proportional SVG to fit the viewport DIV. To do this, we
     * determine how big the new viewbox would be in pixels (using default_ppi)
     * and magnify this to fit the viewportDIV.
     */
    var newMagnification = divWidth / viewbox.width;
    // update the display
    zoomViewport( newMagnification );  // calls initTreeIllustratorWindow();
}
function getMinimalIllustrationBoundingBox() {
    // Return just the region defined for printing (copying its properties
    // to a simple Object, to prevent NoModificationAllowedError in IE)
    var bbox = $('#illustration-background')[0].getBBox();
    return $.extend({}, bbox);
}
function getInclusiveIllustrationBoundingBox() {
    // Fetch the region defined for printing, PLUS any "out of bounds" SVG
    // elements. Again, we'll copying its properties to a simple Object, to
    // prevent NoModificationAllowedError in IE.
    var bbox = d3.select('g.illustration-elements').node().getBBox();
    /* REMINDER: This designated group should contain all illustration elements
       and an invisible box matching the printed area. */
    return $.extend({}, bbox);
}
function getDiagnosticBoundingBox() {
    // gather outermost bounds based on diagnostic elements found
    var bbox = getMinimalIllustrationBoundingBox();
    var viewportSVG = d3.select("#viz-outer-frame div.vega svg");
    var rulers = viewportSVG.select("#rulers").node();
    if (rulers) {
        bbox = getCombinedBoundingBox( bbox, rulers.getBBox() );
    }
    var cropmarks = viewportSVG.select("#crop-marks").node();
    if (cropmarks) {
        bbox = getCombinedBoundingBox( bbox, cropmarks.getBBox() );
    }
    var description = viewportSVG.select("#description").node();
    if (description) {
        bbox = getCombinedBoundingBox( bbox, description.getBBox() );
    }
    return $.extend({}, bbox);
}
function getCombinedBoundingBox( box1, box2 ) {
    // reckon the "union" of two bounding boxes
    var bbox = $.extend({}, box1);
    // compare (obvious) left and top extents
    var bboxLeft = bbox.x;
    var box2Left = box2.x;
    if (box2Left < bboxLeft) {
        // increase width, then reset left edge
        bbox.width = bbox.width + (bboxLeft - box2Left);
        bbox.x = box2Left;
    }
    var bboxTop = bbox.y;
    var box2Top = box2.y;
    if (box2Top < bboxTop) {
        // increase height, then reset top edge
        bbox.height = bbox.height + (bboxTop - box2Top);
        bbox.y = box2Top;
    }
    // compare (implicit) right and bottom extents
    var bboxRight = bbox.x + bbox.width;
    var box2Right = box2.x + box2.width;
    if (box2Right > bboxRight) {
        bbox.width = box2Right - bbox.x;
    }
    var bboxBottom = bbox.y + bbox.height;
    var box2Bottom = box2.y + box2.height;
    if (box2Bottom > bboxBottom) {
        bbox.height = box2Bottom - bbox.y;
    }
    return bbox;
}

/* Annoying browser quirk! Firefox/Mac (and possibly others?) have different SVG
 * masking behavior, where the mask itself must transform along with the SVG it is
 * masking. In these cases, we need to match scale and "invert" X and Y
 * position of the mask.
 */
var svgMaskRequiresTransform = $.browser.mozilla;  //  && $.browser.version < "35";
/* NOTE that test this will fail when we upgrade to jQuery 1.9+! In that case, consider:
    * the jQuery Migrate plugin or this snippet:
      https://github.com/jquery/jquery-migrate/blob/e6bda6a84c294eb1319fceb48c09f51042c80892/src/core.js#L50
    * Modernizr (though it doesn't seem to detect this particular quirk)
    * sniffing the JS 'navigator' object for more information  
 */

/* Manage re-usable SVG elements in the viewport. These are typically defined
   in a persistent SVG defs element, where they can be modified and re-used
   (including multiple instances) for masking, clipping, and optional printed
   output like crop marks and diagnostic rulers.

   NOTE that we need to use d3 to create SVG elements. jQuery flubs the
   namespaces!
*/
function enableViewportMask() {
    //var toolboxSVG = d3.selectAll("#svg-toolbox");
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("enableViewportMask(): viewport SVG not found!");
        return null;
    }
    var mask = d3.select('#viewport-mask');

    if (svgMaskRequiresTransform) {
        // set explicit size and scale for the viewport mask itself
        d3.select("#viewport-mask")
            .attr('maskUnits', 'userSpaceOnUse')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', viewbox.width * viewportMagnification)
            .attr('height', viewbox.height * viewportMagnification);
        // scale the mask !? seems to be required for FF/Mac, at least
        var maskGroupTransform = 'translate('+ -(viewbox.x * viewportMagnification) +','+ -(viewbox.y * viewportMagnification) +') scale('+ viewportMagnification +')';
        //console.log(maskGroupTransform);
        d3.select("#mask-shapes")
            .attr('transform', maskGroupTransform);
    }

    // match the mask's viewport-bounds to the current viewport size
    d3.select("#viewport-bounds")
        .attr('x', viewbox.x)
        .attr('y', viewbox.y)
        .attr('width', viewbox.width)
        .attr('height', viewbox.height);
    // match the mask's illustration-bounds to the current illustration size
    d3.select("#illustration-bounds")
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi))
        .attr('height', physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi));

    // assign the mask to the main viewport (fades stuff outside the print area)
    viewportSVG.attr('mask', 'url(#viewport-mask)');

    if (viewportSVG.selectAll("#viewport-background").empty()) {
        // add milder backdrop for work area (outside the print area)
        viewportSVG.insert('rect', 'svg > g')
                .attr('id', 'viewport-background')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('fill', '#ccc');
        // add a white background for the print area
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'illustration-background')
                .attr('xlink:href', '#illustration-bounds')
                .style('stroke','#bbb');
    }
    d3.select('#viewport-background')
        .attr('x', viewbox.x)
        .attr('y', viewbox.y);
    viewportSVG.selectAll("#viewport-background, #illustration-background")
        .style("visibility", "visible");
}
function disableViewportMask() {
    // remove and clean up masking stuff (prior to printing?)
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.attr('mask', null);
/*
    viewportSVG.selectAll("#viewport-background").remove();
    viewportSVG.selectAll("#illustration-background").remove();
*/
    viewportSVG.selectAll("#viewport-background, #illustration-background")
        .style("visibility", "hidden");
}

function enablePrintingCropArea() {
    d3.select('div.vega svg g.illustration-elements')
        .style('clip-path','url(#printing-clip-path)');
}
function disablePrintingCropArea() {
    d3.select('div.vega svg g.illustration-elements')
        .style('clip-path','none');
}

/* Manage diagnostic markings (crop marks, description, rulers) for printed output */
function showPrintingDiagnostics() {
    showPrintingCropMarks();
    showPrintingDescription();
    showPrintingRulers();
}
function hidePrintingDiagnostics() {
    hidePrintingCropMarks();
    hidePrintingDescription();
    hidePrintingRulers();
}
function showPrintingCropMarks() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingCropMarks(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#crop-marks").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'crop-marks')
                .attr('xlink:href', '#printing-crop-marks');
    }
    // adjust placement of marks to match for illustration size
    var printTopEdge = 0;  // no need to set these
    var printLeftEdge = 0;
    var printBottomEdge = physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi);
    var printRightEdge = physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi);
    d3.select('#crop-mark-top-right')
        .attr('transform', "translate("+ printRightEdge +", 0)");
    d3.select('#crop-mark-bottom-left')
        .attr('transform', "translate(0, "+ printBottomEdge +")");
    d3.select('#crop-mark-bottom-right')
        .attr('transform', "translate("+ printRightEdge +", "+ printBottomEdge +")");
}
function hidePrintingCropMarks() {
    // remove all crop-mark instances
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#crop-marks").remove();
}
function showPrintingDescription() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingDescription(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#description").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'description')
                .attr('xlink:href', '#printing-description');
    }
    // NOTE that we need to move the *original* text element to get its proper bounding box!
    d3.select('#printing-description-name')
        .attr('x', -50)
        .attr('y', -110)
        .text("TODO: Add the actual illustration name, or 'Untitled'");
    var rightNow = new Date();
    var displayDateTime = "Generated "+ rightNow.toLocaleDateString() +" - "+ rightNow.toLocaleTimeString();
    d3.select('#printing-description-datetime')
        .attr('x', -50)
        .attr('y', -94)
        .text(displayDateTime);
}
function hidePrintingDescription() {
    // remove description instance
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#description").remove();
}
function showPrintingRulers() {
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    if (viewportSVG.empty()) {
        console.warn("showPrintingDescription(): viewport SVG not found!");
        return null;
    }
    if (viewportSVG.selectAll("#rulers").empty()) {
        // create instance of crop marks and 
        viewportSVG.insert('use', 'svg > g')
                .attr('id', 'rulers')
                .attr('xlink:href', '#printing-rulers')
                .attr('x', 0)
                .attr('y', -60);
    }
    // set scale for inch ruler
    var unitWidth = inchesToPixels(1.0, internal_ppi);
    d3.select('#ruler-inches line')
        .attr('x2', 6 * unitWidth);
    d3.selectAll('#ruler-inches rect')
        .each(function(d,i) {
            d3.select(this)
                .attr('width', unitWidth)
                .attr('x', (i * 2 * unitWidth) + unitWidth)
        });
    // set scale for cm ruler
    unitWidth = centimetersToPixels(1.0, internal_ppi);
    d3.select('#ruler-cm line')
        .attr('x2', 16 * unitWidth);
    d3.selectAll('#ruler-cm rect')
        .each(function(d,i) {
            d3.select(this)
                .attr('width', unitWidth)
                .attr('x', (i * 2 * unitWidth) + unitWidth)
        });
}
function hidePrintingRulers() {
    // remove description instance
    var viewportSVG = d3.selectAll("#viz-outer-frame div.vega svg");
    viewportSVG.selectAll("#rulers").remove();
}

function getPrintableSVG( options ) {
    // TODO: Add an option to generate standalone SVG, vs. inline for HTML5
    if (!options) options = {};

    // shift SVG from editing to printing
    disableViewportMask();
    enablePrintingCropArea();
    if (options.INCLUDE_DIAGNOSTICS) {
        showPrintingDiagnostics();
    }

    // capture the viewbox and pixel dimensions of the current working view
    var illustration = d3.select('#viz-outer-frame div.vega svg');
    var workingView = {
        'width': illustration.attr("width"),
        'height': illustration.attr("height"),
        'viewBox': illustration.attr("viewBox")
    }

    // modify the viewbox to capture just the illustration elements (and possibly diagnostic stuff)
    var printViewBox = (options.INCLUDE_DIAGNOSTICS) ?
        getDiagnosticBoundingBox() : 
        getMinimalIllustrationBoundingBox();

    /*
    console.log("printViewBox: ");
    console.log(printViewBox);
    */

    // shift the main SVG dimensions to physical units (for more accurate print size)
    var unitSuffix = ill.unitsCssSuffix();
    // reckon physical size in default (print-ready) ppi to "freeze" the pixel size of the top-level SVG
    illustration
        /* N.B. Relying on "natural" SVG res (90 ppi) prints not-quite to scale!
        .attr("width", printViewBox.width)   // rely on built-in ?
        .attr("height", printViewBox.height)
        */
        // Explicitly state WRONG physical size, using browser PPI; prints correctly, but gives me a migraine
        .attr("width", pixelsToPhysicalUnits(printViewBox.width, browser_ppi) + unitSuffix)
        .attr("height", pixelsToPhysicalUnits(printViewBox.height, browser_ppi) + unitSuffix)
        .attr("viewBox", (printViewBox.x +' '+ printViewBox.y +' '+ printViewBox.width +' '+printViewBox.height));

    /*
    console.log( "w: "+ illustration.attr('width') );
    console.log( "h: "+ illustration.attr('height') );
    console.log( "v: "+ illustration.attr('viewBox') );
    console.log("display_ppi: "+ display_ppi);
    console.log("internal_ppi: "+ internal_ppi);
    console.log("browser_ppi: "+ internal_ppi);
    console.log("viewportMagnification: "+ viewportMagnification);
    */

    // momentarily "splice" persistent defs into the illustration, capture the result
    var toolbox = d3.select('#svg-toolbox');
    var defs = toolbox.select('defs');
    $(illustration.node()).prepend(defs);

    /*
     * Capture the resulting SVG (ie, The Moment of Truth)... 
     */
    var combinedSVG = $('#viz-outer-frame div.vega').html();

    // Replace Safari's weird namespace prefixes (NS1:, NS2:, etc) with the real deal
    combinedSVG = combinedSVG.replace(/NS\d+:/gi, 'xlink:');

    /*
     * ... then unwind all these changes to restore our normal working view. 
     */

    // replace the persistent defs
    $(toolbox.node()).prepend(defs);

    // restore pixel dimensions (in deference to Vega)
    illustration
        .attr("width", workingView.width)
        .attr("height", workingView.height)
        .attr("viewBox", workingView.viewBox);

    // reverse all the previous steps
    if (options.INCLUDE_DIAGNOSTICS) {
        hidePrintingDiagnostics();
    }
    disablePrintingCropArea();
    enableViewportMask();

    return combinedSVG;
}

function printIllustration(options) {
    /* Print standalone SVG as a simple document, or display its current output SVG.
     *   EXAMPLE: printIllustration();
     *   EXAMPLE: printIllustration({INCLUDE_DIAGNOSTICS: true});
     *   EXAMPLE: printIllustration({INCLUDE_DIAGNOSTICS: true, SHOW_SVG: true});
     */
    if (!options) options = {};
    var showDiagnostics = options.INCLUDE_DIAGNOSTICS || false;
    var leaveWindowOpen = options.SHOW_SVG || false;

    var w=window.open();
    if (!w) {
        alert("Please allow popups for this domain.");
        return;
    }

    // generate a simple HTML5 page with inline SVG
    // TODO: generate standalone SVG document (to save or share) instead?
    var doc = w.document;
    doc.open("text/html", "replace");
    doc.write('<!DOCTYPE html><HTML><HEAD><TITLE>Tree Illustrator - SVG for printing</TITLE></HEAD><BODY></BODY></HTML>');
    doc.close();
    var outputSVG = getPrintableSVG( {INCLUDE_DIAGNOSTICS: showDiagnostics} );
    // let the browser render the new window so we can use its height
    setTimeout(function() {
        if (leaveWindowOpen) {
            // write just the SVG to the new window, to be copied to clipboard
            var itsClientHeight = $('html', doc)[0].clientHeight - 50;
            doc.body.innerHTML = '<textarea style="width: 95%; height: '+ itsClientHeight +'px;">'+ outputSVG +'</textarea>';
        } else {
            // normal print+close behavior
            doc.body.innerHTML = outputSVG;
            w.print();
            w.close();
        }
    }, 500);
}

/* Accordion UI helpers */
function accordionPanelShown(e) {
    var $heading = $(e.target).prev('.panel-heading');
    $heading.find("i.help-rollover")
        .text('Click to close this panel');
}
function accordionPanelHidden(e) {
    var $heading = $(e.target).prev('.panel-heading');
    $heading.find("i.help-rollover")
        .text('Click to open this panel');
}
function showAccordionHint(e) {
    $(e.target)
        .find("i.help-rollover")
        .show();
}
function hideAccordionHint(e) {
    $(e.target)
        .find("i.help-rollover")
        .hide();
}
function showAccordionPanel( panelID ) {
    /* Drive the sidebar UI to show a particular section on demand, 
     * e.g. show a tree's properties when user clicks on it in viz.
     */
    var $chosenPanel = $(panelID);
    if ($chosenPanel.length === 0) {
        console.error('showAccordionPanel(): No such panel as '+ panelID);
        return;
    }
    if ($chosenPanel.hasClass('in')) {
        // It's already open; don't toggle it shut!
    } else {
        // Toggle to show this panel; use API vs. a simulated click, which can stop dragging!
        // Close other panels (these are "sticky" for some reason)
        $chosenPanel.closest('.accordion').find('.collapse.in')
            .collapse('hide');
        $chosenPanel.collapse('show');
    }
    // TODO: show sidecar in all cases?
}
function showAccordionPanelForElement( elementID ) {
    var panelID = '#ti-panel-'+ elementID;
    showAccordionPanel( panelID );
}
function getAccordionPanelForElement( illElement ) {
    var panelID = '#ti-panel-'+ illElement.id();
    return $(panelID);
}

$(document).ready(function() {
    $('#ti-main-accordion .panel-body').on('shown', accordionPanelShown);
    $('#ti-main-accordion .panel-body').on('hidden', accordionPanelHidden);

    $('#ti-main-accordion .panel-heading').on('mouseenter', showAccordionHint);
    $('#ti-main-accordion .panel-heading').on('mouseleave', hideAccordionHint);
});

function doNothing() {
    // occasionally useful in Knockout.js click bindings
    return;
}

function getPrintAreaLandmarks() {
    // gather interesting coordinates in internal pixels
    if (ill) {
        return {
            width: physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi),
            height: physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi),
            leftX: 0,
            centerX: physicalUnitsToPixels(ill.style.printSize.width() / 2.0, internal_ppi),
            rightX: physicalUnitsToPixels(ill.style.printSize.width(), internal_ppi),
            topY: 0,
            centerY: physicalUnitsToPixels(ill.style.printSize.height() / 2.0, internal_ppi),
            bottomY: physicalUnitsToPixels(ill.style.printSize.height(), internal_ppi)
        };
    }
    // return placeholder values
    return {
        width:   1.0,
        height:  1.0,
        leftX:   0.0,
        centerX: 0.5,
        rightX:  1.0,
        topY:    0.0,
        centerY: 0.5,
        bottomY: 1.0
    };
}
 
function enterFullScreen() {
    var test = $('#full-screen-area').fullscreen();
    return false;
}
function exitFullScreen() {
    $.fullscreen.exit();
    return false;
}

/* Test regexps for MIME-type (content-type) of a File or Blob */
var allTypes = /.*/;
var textTypes = /text.*/; // TODO: add 'application/json', etc?
var imageTypes = /image.*/;

// What do we expect (or forbid) for different illustration elements?
var expectedMIMETypes = {
    'IllustratedTree': textTypes,
    'SupportingDataset': textTypes,
    'Ornament': imageTypes
};
var disallowedMIMETypes = {
    'IllustratedTree': imageTypes,
    'SupportingDataset': imageTypes,
    'Ornament': allTypes
};

function handleChosenLocalFile( illElement, event ) {
    console.log('handleChosenLocalFile STARTING...');
    var fileList = event.target.files;      // a FileList
    // For now, we expect just one file!
    var chosenFile = fileList[0];           // a File

    // Warn/reject if not an appropriate MIME-type for this element?
    var expectedTypes = expectedMIMETypes[ illElement.metadata.type() ];
    var disallowedTypes = disallowedMIMETypes[ illElement.metadata.type() ];
    if (chosenFile.type.match(expectedTypes)) {
        // This is an expected content type, carry on...
    } else if (chosenFile.type.match(disallowedTypes)) {
        alert("Files of MIME-type '"+ chosenFile.type +"' are not allowed for "+ illElement.metadata.type() +" elements.");
        return;
    } else {
        // This content type is not in either list. Accept for now?
        console.warn("Tentatively allowing MIME-type '"+ chosenFile.type +"' for this "+ illElement.metadata.type());
    }

    // Show file information in its accordion element
    var $panel = getAccordionPanelForElement( illElement );
    $panel.find('.chosen-file-name').text(chosenFile.name);
    $panel.find('.chosen-file-type').html(chosenFile.type || '<em>Unknown</em>');
    $panel.find('.chosen-file-size').text(chosenFile.size);
    $panel.find('.chosen-file-last-mod-date').text(chosenFile.lastModifiedDate.toLocaleString());

    // create a URL to this File
    var reader = new FileReader();
    // closure to capture the file information.
    reader.onload = (function(theFile) {
        return function(e) {
            var r = e.target;  // i.e., this FileReader
            console.log("FileReadr result for '"+ escape(theFile.name) +"':\n"+ r.result);
            //debugger;
        };
    })(chosenFile);
    //reader.readAsDataURL(chosenFile);       // result is 'data:;base64,KEEsKEIsKEMsRCkpKTs='
    //reader.readAsBinaryString(chosenFile);  // result is '(A,(B,(C,D)));'
    //reader.readAsText(chosenFile);          // result is '(A,(B,(C,D)));'
    reader.readAsArrayBuffer(chosenFile);     // result is '[object ArrayBuffer]', more to do here obviously
}

function applyChosenStyleGuide(clicked) {
    var $clicked = $(clicked);
    var $sgBlock = $clicked.closest('.match');
    // TODO: replace this dumb matching with KO binding to actual data
    var matchKey = $sgBlock.find('.match-key').val();
    console.log("> Looking for matchKey: "+ matchKey);
    var chosenStyleGuide = null;
    $.each(availableStyleGuides, function(i, sg) {
        // is this the illlustration's current style guide? compare name, source, version
        var testKey  = sg.name +'|'+ sg.version.value +'|'+ sg.source.value;
        console.log(">> comparing testKey: "+ testKey);
        if (testKey === matchKey) {
            chosenStyleGuide = sg;
            return false;
        }
    });
    if (!chosenStyleGuide) {
        alert('Unable to match the chosen style guide!');
        return;
    }
    // TODO: apply / merge this style guide into the current illustration
    ill.applyStyleGuide(chosenStyleGuide);
    // close the modal chooser
    $sgBlock.closest('.modal-styleguide-chooser').find('.modal-header .close').click();
}

// reflect the current user's identity, or null for an anonymous user
function userLogin() {
    return storage.userLogin();
}
function userDisplayName() {
    return storage.userDisplayName();
}
function userEmail() {
    return storage.getUserEmail();
}
function userHasStorageAccess() {
    //return userLogin() && (userLogin() !== 'LOGIN_NOT_FOUND');
    return storage.userHasStorageAccess();
}
function userIsLoggedIn(callback) {
    if (storage.userAuthToken) {
        // asynchronous, since it may require an AJAX roundtrip...
        if (typeof(callback) !== 'function') {
            alert('stylist.userIsLoggedIn() - requires a callback function!')
            return;
        }
        // return true if OAuth still recognizes this token
        callback(storage.userIsLoggedIn());
        return;
    }
    // no callback required!
    return true;  // treat as "true" by default, e.g. Jupyter notebook
}

// manage illustrations (using an adapter with API methods, already loaded)
var currentIllustrationList = null;
    // keep the latest ordered array (with positions, names, descriptions)
function loadIllustrationList(backend, callback) {
    console.log("loadIllustrationList() STARTING...");
    storage[ backend ].getIllustrationList(function(response) {
        // show the returned list (or report any error) from the upstream response
        if ('data' in response) {
            // expect an ordered array with names and descriptions
            currentIllustrationList = response.data;
            if (callback) {
                callback(backend);
            }
        } else {
            console.error(response.error || "No data returned (unspecified error)!");
        }
    });
}
function showIllustrationList( backend, currentOperation, options ) {
    options = options || {FLUSH_CACHE: false};
    if (options.FLUSH_CACHE) {
        currentIllustrationList = null;
    }
    if (currentIllustrationList) {
        // Show names and descriptions in a simple, general chooser
        var $chooser = $('#simple-chooser');
        // Show appropriate UI and behavior for the desired operation (eg, SAVING_ILLUSTRATION)
        $chooser.find('[class^=if-]').hide();
        $chooser.find('.if-'+ currentOperation).show();  // eg, '.if-SAVING_ILLUSTRATION'
        $chooser.find('.if-'+ backend).show();  // eg, '.if-GITHUB_REPO'
        switch (currentOperation) {
            case ('LOADING_ILLUSTRATION'):
            //case ('LOADING_TEMPLATE'):
                $chooser.find('.dialog-heading').html('Load an existing illustration');
                break;
            case ('SAVING_ILLUSTRATION'):
                // adjust display and behavior in the shared popup
                /* Check for a prior storage location (lastSave); if found,
                 * explain what happens next and offer alternative save-as
                 * behavior, i.e. make a copy instead.
                 */
                $chooser.find('.dialog-heading').html('Save (or update) your illustration');
                if ((storage.lastSave.backend() === 'GITHUB_REPO') && storage.lastSave.location()) {
                    // a simple update is the path of least resistance, but offer other options
                    $('#not-replacing-on-github').hide();
                    $('#if-replacing-on-github').show();
                } else {
                    // recognize an implicit match, based on name=>slug conversion?
                    $('#not-replacing-on-github').show();
                    $('#if-replacing-on-github').hide();
                }
                /*
                $('#suggested-storage-name').val( ill.metadata.name() );
                $('#suggested-storage-name').unbind('change')
                                            .bind('propertychange change click keyup input paste', function() {
                                                // N.B. lots of bound events, to catch any change in modern browsers
                                                console.log("...checking for potential save conflicts...");
                                                switch(backend) {
                                                    case 'GITHUB_REPO':
                                                        // test new slug/id (or stored prior id) against our illustration list, warn if it's a duplicate!
                                                        var proposedID = storage.GITHUB_REPO.getDefaultGitHubIllustrationID();
                                                        // TODO: compare all ids/urls with this!
                                                        $.each(currentIllustrationList, function(i, match) {
                                                            console.log(proposedID);
                                                            console.warn(match.source);
                                                            if (match.source === proposedID) {
                                                                console.warn("THIS WILL OVERWRITE AN EXISTING ILLUSTRATION!");
                                                                $('#github-storage-dupe-warning').show();
                                                                return false;
                                                            }
                                                        });
                                                        console.log(currentIllustrationList);
                                                        break;
                                                    case 'JUPYTER_NOTEBOOK':
                                                    default:
                                                        console.error("#suggested-storage-name should not be changing!");
                                                        return;
                                                }
                                            })
                                            .change();
                */
                break;
            default:
                console.error("MISSING/UNKNOWN storage operation: '"+ 
                    currentOperation +"' <"+ typeof(currentOperation) +">");
                return;
        }

        $chooser.find('.found-matches').empty();
        if (currentIllustrationList.length === 0) {
            $chooser.find('.found-matches').append('<div>'+
              '<em>No illustrations found in storage.</em>'+
            '</div>');
        } else {
            $.each(currentIllustrationList, function(i, match) {
                /* List item should include these properties
                 *  - name
                 *  - description
                 *  - source
                 * N.B. In slot-based storage, `i` is the only source information
                 */
                var storageLocation = match.source || i;
                var $matchInfo = $('<div class="match"><div><span class="name"></span><span class="storage-location"></span></div><div class="description"></div></div>');
                $matchInfo.find('.name').html(match.name || '<em>No name found</em>')
                $matchInfo.find('.storage-location').html(' ('+ storageLocation +')');
                $matchInfo.find('.description').html(match.description || '');
                var $loadButton, $deleteButton, $replaceButton;
                switch (currentOperation) {
                    case 'LOADING_ILLUSTRATION':
                    //case 'LOADING_TEMPLATE':
                        $loadButton = $('<button class="btn btn-primary btn-mini pull-right"'
                                       +' style="margin-top: 6px; margin-left: 8px;"'
                                       +'>Load</button>');
                        $loadButton.click(function() {
                            fetchAndLoadExistingIllustration( backend, storageLocation);
                            // close the modal chooser
                            $(this).closest('.modal-simple-chooser').find('.modal-header .close').click();
                        });
                        $matchInfo.prepend($loadButton);
                        $deleteButton = $('<button class="btn btn-danger btn-mini pull-right"'
                                         +' style="margin-top: 6px; margin-left: 8px;"'
                                         +'><i class="icon-white icon-remove"></i</button>');
                        $deleteButton.click(function() {
                            if (confirm("This will delete ALL information about this illustration. Are you sure?")) {
                                deleteIllustration( backend, storageLocation, function() {
                                    showIllustrationList( backend, currentOperation, {FLUSH_CACHE: true} );
                                });
                            }
                        });
                        $matchInfo.prepend($deleteButton);
                        break;
                    case 'SAVING_ILLUSTRATION':
                    //case 'SAVING_TEMPLATE':
                        $replaceButton = $('<button class="btn btn-primary btn-mini pull-right"'
                                          +' style="margin-top: 6px; margin-left: 8px;"'
                                          +'>Replace</button>');
                        $replaceButton.click(function() {
                            saveCurrentIllustration( backend, storageLocation, {REFRESH_LIST: true} );
                        });
                        $matchInfo.prepend($replaceButton);
                        $deleteButton = $('<button class="btn btn-danger btn-mini pull-right"'
                                         +' style="margin-top: 6px; margin-left: 8px;"'
                                         +'><i class="icon-white icon-remove"></i</button>');
                        $deleteButton.click(function() {
                            if (confirm("This will delete ALL information about this illustration. Are you sure?")) {
                                deleteIllustration( backend, storageLocation, function() {
                                    showIllustrationList( backend, currentOperation, {FLUSH_CACHE: true} );
                                });
                            }
                        });
                        $matchInfo.prepend($deleteButton);
                        break;
                }
                $chooser.find('.found-matches').append($matchInfo);
            });
        }
        $chooser.off('shown').on('shown', resizeIllustrationList);
        ///USEFUL? $chooser.find('.found-matches').css('visibility','visible');
        //$chooser.find('.found-matches').css('visibility','hidden');
        // (re)bind UI with Knockout
        var $boundElements = $chooser.find('.modal-body'); // add other elements?
        $.each($boundElements, function(i, el) {
            ko.cleanNode(el);
            ko.applyBindings({},el);
        });
        $chooser.modal('show');
        resizeIllustrationList();
    } else {
        // load the initial list, then return here
        loadIllustrationList(backend, function() {
            showIllustrationList( backend, currentOperation );
        });
    }
}
function resizeIllustrationList() {
/* N.B. this doesn't really apply unless we've locked the popup's height!
    // size scrolling list to fit in the current DOI-lookup popup window
    var $chooser = $('#simple-chooser');
    var $matchListHolder = $chooser.find('.found-matches');
    $matchListHolder
        .css('visibility','hidden');
    var resultsListHeight = $chooser.find('.modal-body').height() - $chooser.find('.before-matches').height();
    $matchListHolder
        .outerHeight(resultsListHeight);
        .css('visibility','visible');
*/
}
function saveCurrentIllustration(backend, saveToLocation, options) {
    options = options || {FORCE_NEW_DOC: false, REFRESH_LIST: false};
    console.log("saveCurrentIllustration() CHECKING FOR SPECIFIED BACKEND+LOCATION...");
    if (!backend || (saveToLocation === null)) {
        // not specified (e.g., we haven't saved the current illustration in this session)
        showStorageOptions('SAVING_ILLUSTRATION');  // defer to the Save As... behavior
        return;
    }
    if ((backend === 'LOCAL_FILESYSTEM') && (saveToLocation === 'UNKNOWN')) {
        // propose an appropriate filename based on its internal name
        saveToLocation = getDefaultArchiveFileName();
    }

    if (options.FORCE_NEW_DOC) {
        switch (backend) {
            case 'GITHUB_REPO':
                if (('sha' in ill.metadata) && (typeof(ill.metadata.sha) === 'function')) {
                    ill.metadata.sha('');  // this forces new doc on GitHub
                }
                break;
        }
    }

    console.log("saveCurrentIllustration() STARTING simple (re)save...");
    // TODO: How should this ID be determined?
    //  - unique/serialized slug, ala tree collections?
    //  - if provided as incoming arg, use to Save As
    //  - add an explicit arg for SAVE, SAVE_AS, DUPLICATE
    //  - should these details be delegated to the storage adapter?
    //  - OR should we rely entirely on (and possibly modify) its internal metadata?
    // Current behavior (in IPython notebook) is to assume the current (nth)
    // storage slot, unless 'NEW' or another integer is asserted here.
    storage[ backend ].saveIllustration(saveToLocation, function(response) {
        // (re)load the saved illustration (or report any error)
        if (response.error) {
            console.error( response.error );
        } else {
            //currentIllustrationList = response.data;
            // update last-saved info
            /* Confirm that the saveToLocation wasn't changed by the storage backend!
             * This probably means checking the illustration's returned metadata (if any).
             */
            switch (backend) {
                case 'GITHUB_REPO':
                    // check for new id assigned by backend (already changed in the illustration)
                    var newMetadataLocation = ill.metadata.url();
                    var assignedID = storage.GITHUB_REPO.getIllustrationIDFromURL(newMetadataLocation);
                    // keep track of this *assigned* location, vs. what we intended
                    updateLastSavedInfo(backend, assignedID);
                    break;
                case 'JUPYTER_NOTEBOOK':
                    // Test saves to Jupyter notebook, so we can translate 'NEW' (stated intent) to an actual slot number!
                    if (saveToLocation === 'NEW') {
                        // N.B. response.data is the *new* illustration list
                        var howManyIllustrations = response.data.length;
                        var newSlotPosition = howManyIllustrations - 1;
                        updateLastSavedInfo(backend, newSlotPosition);
                    } else {
                        updateLastSavedInfo(backend, saveToLocation);
                    }
                    break;
                case 'LOCAL_FILESYSTEM':
                    // Nothing to do here. We can't see the new local filename!
                    break;
            }

            // update the illustration list
            if (options.REFRESH_LIST) {
                showIllustrationList( backend, 'SAVING_ILLUSTRATION', {FLUSH_CACHE: true} );
            }
        }
    });
}
function deleteIllustration(backend, deleteLocation, callback) {
    /* N.B. We generally assume this is NOT the current (live) illustration,
     * but another chosen from a storage popup!
     */
    console.log("deleteIllustration() CHECKING FOR SPECIFIED BACKEND+LOCATION...");
    if (!backend || !deleteLocation) {
        console.error("deleteIllustration() requires a storage backend and location!");
        console.error("  backend: "+ backend +" <"+ typeof(backend) +">");
        console.error("  location: "+ deleteLocation +" <"+ typeof(deleteLocation) +">");
        return;
    }

    console.log("deleteIllustration() STARTING simple deletion...");
    storage[ backend ].deleteIllustration(deleteLocation, function(response) {
        // (re)load the saved illustration (or report any error)
        if (response.error) {
            console.error( response.error );
        } else {
            // update the list in UI, to show that it's really gone
            console.log("deleteIllustration() gave this response (new illustration list? or simpler result?)");
            console.log( response );
            //currentIllustrationList = response.data;
            // any cleanup?
            switch (backend) {
                case 'GITHUB_REPO':
                    // Did we just delete the currently loaded illustration!?
                    if (('url' in ill.metadata) && (ill.metadata.url().endsWith( '/'+ deleteLocation ))) {
                        // Clear its internal 'url' and 'sha', to force 'Save As' behavior next time
                        console.log("stylist.deleteIllustration(): clobbered live illustration! so clearing its SHA and URL...");
                        ill.metadata.url('');
                        ill.metadata.sha('');
                        clearLastSavedInfo();
                    }
                    break;
            }
        }
        if (typeof callback === 'function') {
            // typically reloading an illustration list
            callback();
        }
    });
}

function showStorageOptions( currentOperation ) {
    // Show all storage backends, incl. disabled / not available.
    var $popup = $('#storage-options-popup');
    // TODO: $popup.find(':input').val('');  // clear any old values?

    // Show appropriate UI and behavior for the desired operation (eg, SAVING_ILLUSTRATION)
    $popup.find('[class^=if-]').hide();
    $popup.find('.if-'+ currentOperation).show();  // eg, '.if-SAVING_ILLUSTRATION'
    switch (currentOperation) {
        case ('LOADING_ILLUSTRATION'):
        case ('SAVING_ILLUSTRATION'):
        //case ('LOADING_TEMPLATE'):
        //case ('LOADING_TEMPLATE'):
            // adjust display and behavior in the shared popup
            break;
        default:
            console.error("MISSING/UNKNOWN storage operation: '"+ 
                currentOperation +"' <"+ typeof(currentOperation) +">");
            return;
    }

    // Display should reflect the availability of each storage backend (check
    // here, so we don't keep testing)
    if (stylist.utils.browserSupportsFileAPI()) {
        $popup.find('.file-api-supported').show();
        $popup.find('.file-api-NOT-supported').hide();
    } else {
        $popup.find('.file-api-supported').hide();
        $popup.find('.file-api-NOT-supported').show();
    }
    if (hostApplication === TreeIllustrator.hostApplications.JUPYTER_NOTEBOOK) {
        $popup.find('.notebook-storage-supported').show();
        $popup.find('.notebook-storage-NOT-supported').hide();
    } else {
        $popup.find('.notebook-storage-supported').hide();
        $popup.find('.notebook-storage-NOT-supported').show();
    }

    if (storage.GITHUB_REPO.userIsLoggedIntoGitHub()) {
        $('#github-login-panel').hide();
        $('#github-logged-in').show();
    } else {
        $('#github-login-panel').show();
        $('#github-logged-in').hide();
    }

    $popup.modal('show');
    //$popup.find('#github-authorize').unbind('click').click(loginToGitHub);

    // (re)bind UI with Knockout
    var $boundElements = $('#storage-options-popup .modal-body'); // add other elements?
    $.each($boundElements, function(i, el) {
        ko.cleanNode(el);
        ko.applyBindings({},el);
    });
}
function toggleSaveOptionDetails(clicked) {
    var $clicked = $(clicked);
    var $currentOptionPanel = $clicked.closest('.modal-body');
    var $otherOptionPanels = $clicked.closest('.modal').find('.modal-body').not($currentOptionPanel);
    $otherOptionPanels.find('.option-details').hide();
    $currentOptionPanel.find('.option-details').toggle();
}

/*
function gatherStaticInputData() {
    // TODO: Return an array of objects with .path, .value, other sensible properties
    return [ ];
}

function gatherAllInputData() {
    // TODO: Return an array of objects with .path, .value, other sensible properties
    return [ ];
}

function gatherAllTransformData() {
    // TODO: Return an array of objects with .path, .value, other sensible properties
    return [ ];
}
*/

function loadArchiveFromChosenFile( vm, evt ) {
    // First param (corresponding view-model data) is probably empty; focus on the event!
    // ASSUME we're in the storage-options popup.
    var $hintArea = $('#local-filesystem-warning').eq(0);
    $hintArea.html("");  // clear for new results
    switch(evt.srcElement.files.length) {
        case (0):
            console.warn('No file(s) selected!');
            return;
        case (1):
        default:  // ignore multiple files for now, just load the first
            var fileInfo = evt.srcElement.files[0];
            console.warn("fileInfo.name = "+ fileInfo.name);
            console.warn("fileInfo.type = "+ fileInfo.type);
            var isValidArchive = false;
            switch (fileInfo.type) {
                case 'application/zip':
                    isValidArchive = true;
                    break;
                case '':
                    // check file extension
                    if (fileInfo.name.match('.(zip|ill)$')) {
                        isValidArchive = true;
                    }
                    break;
            }
            if (!isValidArchive) {
                var msg = "Archived illustrations should end in <code>.zip</code> or <code>.ill</code>. Choose another file?";
                $hintArea.html(msg).show();
                return;
            }
            // Still here? try to read and unzip this archive!
            jszip.loadAsync(fileInfo)   // read the Blob
                 .then(function(zip) {  // success callback
                     console.log('reading ZIP contents...');
                     var msg = "Reading illustration contents...";
                     $hintArea.html(msg).show();
                     // How will we know when it's all (async) loaded? Count down as each entry is read!
                     var zipEntriesToLoad = 0;
                     var initialCache = {};
                     for (var p in zip.files) { zipEntriesToLoad++; }
                     // Stash most found data in the cache, but main JSON should be parsed
                     var mainIllustrationJSON = null;
                     zip.forEach(function (relativePath, zipEntry) {  // 2) print entries
                         console.log('  '+ zipEntry.name);
                         console.log(zipEntry);
                         // skip directories (nothing to do here)
                         if (zipEntry.dir) {
                             //console.warn("SKIPPING directory "+ zipEntry.name +"...");
                             zipEntriesToLoad--;
                             return;
                         }
                         // read and store files
                         zipEntry.async('text', function(metadata) {
                                    // report progress?
                                    var msg = "Reading illustration contents ("+ zipEntry.name +"): "+ metadata.percent.toFixed(2) +" %";
                                    $hintArea.html(msg).show();
                                 })
                                 .then(function success(data) {
                                           console.log("Success unzipping "+ zipEntry.name +":\n"+ data);
                                           zipEntriesToLoad--;
                                           // parse and stash the main JSON data; cache the rest
                                           switch (zipEntry.name) {
                                               case 'main.json':
                                                   mainIllustrationJSON = JSON.parse(data);
                                                   break;
                                               default:
                                                   // copy to our initial cache
                                                   initialCache[ zipEntry.name ] = data;
                                           }
                                           if (zipEntriesToLoad === 0) {
                                               // we've read in all the ZIP data! open this illustration
                                               // (setting its initial cache) and close this popup
                                               loadIllustrationData( mainIllustrationJSON, initialCache, 'EXISTING');
                                               // update last-saved info
                                               //updateLastSavedInfo('LOCAL_FILESYSTEM', 'UNKNOWN');
                                               updateLastSavedInfo('LOCAL_FILESYSTEM', fileInfo.name);
                                               // N.B. the File API *always* downloads to an unused path+filename
                                               $('#storage-options-popup').modal('hide');
                                           }
                                       },
                                       function error(e) {
                                           var msg = "Problem unzipping "+ zipEntry.name +":\n"+ e.message;
                                           $hintArea.html(msg).show();
                                       });
                     });
                 }, 
                 function (e) {         // failure callback
                     var msg = "Error reading <strong>" + fileInfo.name + "</strong>! Is this a proper zip file?";
                     $hintArea.html(msg).show();
                 });
    }
}

function getDefaultArchiveFileName( candidateFileName ) {
    // try to use a candidate name, if provided
    var suggestedFileName = $.trim(candidateFileName) || 
        stylist.ill.metadata.name() || 
        "UNTITLED_ILLUSTRATION";
    if (!suggestedFileName.toLowerCase().endsWith('.zip')) {
        suggestedFileName += '.zip';
    }
    return suggestedFileName;
}
function saveArchiveWithSuggestedName() {
    var $filenameField = $('input#suggested-archive-filename');
    var suggestedFileName = $.trim($filenameField.val());
    if (suggestedFileName) {
        suggestedFileName = getDefaultArchiveFileName(suggestedFileName);
        stylist.storage[ LOCAL_FILESYSTEM ].saveIllustration(suggestedFileName);
    } else {
        stylist.storage[ LOCAL_FILESYSTEM ].saveIllustration();
    }
    updateLastSavedInfo('LOCAL_FILESYSTEM', suggestedFileName || 'UNKNOWN');
    $('#local-filesystem-warning').slideDown();
}

// Expose some members to outside code (eg, Knockout bindings, onClick
// attributes...)
var api = [
    'TreeIllustrator',
    'userLogin',
    'userDisplayName',
    'userEmail',
    'showStorageOptions',
    'toggleSaveOptionDetails',
    'userHasStorageAccess',
    'userIsLoggedIn',
    'showIllustrationList',
    'loadIllustrationList',
    'fetchAndLoadExistingIllustration',
    'fetchAndLoadIllustrationTemplate',
    'saveCurrentIllustration',
    'inchesToCentimeters',
    'centimetersToInches',
    'inchesToPoints',
    'pointsToInches',
    'centimetersToPoints',
    'pointsToCentimeters',
    'pixelsToInches',
    'inchesToPixels',
    'pixelsToCentimeters',
    'centimetersToPixels',
    'pixelsToPhysicalUnits',
    'physicalUnitsToPixels',
    'pointsToCentimeters',
    'getPrintAreaLandmarks',
    'toggleFixedRulers',
    'refreshViz',
    'doNothing',
    'browser_ppi',
    'internal_ppi',
    'display_ppi',
    'internalUnitsToOverlayPixels',
    'overlayPixelsToInternalUnits',
    'availableTrees',
    'availableDataSources',
    'zoomViewport',
    'printIllustration',
    'resizeViewportToShowAll',
    'availableStyleGuides',
    'showStyleGuidePicker',
    'showAccordionPanel',
    'showAccordionPanelForElement',
    'applyChosenStyleGuide',
    'handleChosenLocalFile',
    'enterFullScreen',
    'exitFullScreen',
    'ill',
    //'gatherStaticInputData',
    //'gatherAllInputData',
    //'gatherAllTransformData',
    'loadArchiveFromChosenFile',
    'getDefaultArchiveFileName',
    'saveArchiveWithSuggestedName',
    'clearLastSavedInfo',
    'view',
    //'jszip',
    //'FileSaver',
    'utils',
    'storage'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TreeIllustrator.js":243,"./storage/ipython-notebook-bridge.js":246,"./storage/local-filesystem.js":247,"./storage/namespaced-urls.js":248,"./ti-utils":250,"./vg.data.nexson.js":251,"./vg.data.phylogram.js":252,"./vg.data.pluck.js":253,"./vg.data.stash.js":254,"assert":1,"blob-polyfill":3,"file-saver":56,"jquery":244,"jszip":72,"spark-md5":245,"vega":187}],250:[function(require,module,exports){
/* 
 * Generally useful tools for modules in Tree Illustrator. They might be
 * concerned with display logic, geometry and transformation, text formatting;
 * anything that spans our normal lines of responsibility.
 */

function jiggle( range ) {
    // Return a number +- zero, within this range
    return Math.round(Math.random() * range * 2) - range; 
}

/*
 * Prepare data from rendering pipeline for storage in ZIP archive or similar.
 */
function serializeDataForSavedFile( data ) {
    // TODO: Test data for other suitable options like {base64: true}
    var serialized = {};
    switch (typeof data) {
        case 'object':
            try {
                serialized.value = JSON.stringify(data);
            } catch (e) {
                console.error("Trouble converting object to JSON! Try another approach?");
                serialized.value = data.toString();
            }
            break;
        case 'string':
            serialized.value = data;
            break;
        default:
            serialized.value = data.toString();
    }
    serialized.options = {};
    return serialized;
}

/* "Sniffers" to guess the format of user-entered tree data. 
 * N.B. these don't need to be fool-proof; they're just used to pre-select
 * the most likely format. 
 */
function isProbablyNewick(data) {
    if (typeof(data) !== 'string') {
        return false;
    }
    data = $.trim(data);
    // Look for expected start and end marks
    // N.B. this will reject a valid (but trivial) string like 'A;'
    if (data.startsWith('(') && data.endsWith(');')) {
        return true;
    }
    return false;
}

var matchesNEXUSBlockStarter = new RegExp('begin \\w+;', 'i');
function isProbablyNEXUS(data) {
    if (typeof(data) !== 'string') {
        return false;
    }
    // Look for required(?) first line
    if ($.trim(data).startsWith("#nexus") || $.trim(data).startsWith("#NEXUS")) {
        return true;
    }
    // ... or accept typical NEXUS block starter
    if (matchesNEXUSBlockStarter.test(data)) {
        return true;
    }
    return false;
}

function isProbablyNeXML(data) {
    /* NOTE that this is the most "expensive" sniffer, so it's probably
     * best to check the others first.
     */
    var testXML;
    if (data instanceof XMLDocument) {
        testXML = data;
    } else {
        try {
            testXML = $.parseXML(data);
            if (!testXML) {
                // if data is not a string, result is null 
                return false;
            }
        } catch (err) {
            // var failed to parse as XML
            ///console.error(err);
            return false;
        }
    }
    if ($(testXML).children().length === 0) {
        // XML is strangely empty
        return false;
    }
    var rootNodeName = $(testXML).children()[0].nodeName;
    switch( rootNodeName ) {
        case 'nex:nexml':
            break;
        case 'nexml':
            break;
        default:
            return false;
    }
    return true;
}

function isProbablyRPhylo(data) {
    // test for valid JSON/JS nested array, then examine its structure
    var testObj = coerceToJSObject(data);
    if (!testObj) return false;
    // check for basic phylo fields
    return ('edge' in testObj) && ('tip.label' in testObj) && ('Nnode' in testObj);
    // TODO: Is tip.label an optional element? Choose something else instead?
}

function isProbablyNexson(data) {
    // test for valid JSON/JS nested array, then examine its structure
    var testObj = coerceToJSObject(data);
    if (!testObj) return false;
    // check for basic nexson structure
    return ('data' in testObj) && ('nexml' in testObj.data);
}

function coerceToJSObject(data) {
    // return a proper JS object (or null if coercion fails)
    if ($.isPlainObject(data)) {
        // this is fine as-is
        return data;
    }
    try {
        var jsObject = eval(data);
        if (!jsObject) {
            // if data is not a string, result is null
            return null;
        }
    } catch (err) {
        // var failed to evaluate to a JS object
        console.error("Coercion to JS object failed!");
        console.error(err);
        return null;
    }
    return jsObject;
}

/* Detect browser capabilities */
function browserSupportsFileAPI() {
    // Can load and manipulate local files in this browser?
    return (window.File && window.FileReader && window.FileList && window.Blob) ? true : false;
}

/* Copied from vg.data.phylogram.js, for wider use (but keeping the code in
 * both places, to minimize dependencies in the Vega transform).
 */
function radiansToDegrees(r) {
    return (r * 180 / Math.PI);
}
function degreesToRadians(d) {
    return (d * Math.PI / 180);
}
function normalizeDegrees(d) {
    // convert to positive integer, e.g. -90 ==> 270
    return (d + (360 * 3)) % 360;
}

// export some members as a simple API
var api = [
    'jiggle',
    'serializeDataForSavedFile',
    'isProbablyNewick',
    'isProbablyNEXUS',
    'isProbablyNeXML',
    'isProbablyRPhylo',
    'browserSupportsFileAPI',
    'radiansToDegrees',
    'degreesToRadians',
    'normalizeDegrees'
];
$.each(api, function(i, methodName) {
    // populate the default 'module.exports' object
    exports[ methodName ] = eval( methodName );
});


},{}],251:[function(require,module,exports){
/* 
 * Transform NEXson data into a form suitable for use in the Tree Illustrator
 * and d3.phylogram.js. This extends the Vega's vg.data space so we can take
 * advantage of its pipeline and other features. It's patterned after the 
 * project's treemap.js, which also does transformation tied to a specific 
 * d3 representation.
 * 
 * Anticipate other importers like this one for NEXML, etc. (assumes JSON? or
 * can we parse free-form text? YES, since vega handles CSV, etc.). Each one 
 * should produce the same output: a uniform JS object representing a
 * d3-ready tree (see https://github.com/OpenTreeOfLife/tree-illustrator/wiki/Building-on-D3-and-Vega#data-importers)
 *
 * NOTE that this output creates a basic layout with X and Y position for each
 * node, so any branch-rotation scheme (e.g. ladderized right) must be applied
 * here rather than downstream!
 */
var vg  = require('vega'),
    //d3  = require('d3'),
    log  = require('vega-logging'),
    Transform = require('vega/src/transforms/Transform');

function Nexson(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      treeID: {type: 'value'},
      treesCollectionPosition: {type: 'value', default: 0},
      treePosition: {type: 'value', default: 0},
      branchRotation: {type: 'value', default: 'UNCHANGED'},
      nodeLabelField: {type: 'value', default: 'originalLabel'}
  });
  return this.produces(true)
             .mutates(true);
}

var prototype = (Nexson.prototype = Object.create(Transform.prototype));
prototype.constructor = Nexson;

prototype.transform = function(input) {
  log.debug(input, ['converting to nexson']);

  var treeID = this.param('treeID'),
      treesCollectionPosition = this.param('treesCollectionPosition'),
      treePosition = this.param('treePosition'),
      branchRotation = this.param('branchRotation'),
      nodeLabelField = this.param('nodeLabelField'),
      nexml = null;

  /*
   * NEXson-specific logic, encapsulated for easy access to nexml, etc.
   *
   * Adapted from https://github.com/OpenTreeOfLife/opentree/blob/79aa1f4f72940c0f5708fd2ced56190d8c34ad9a/curator/static/js/study-editor.js
   */
  var fastLookups = {
      'NODES_BY_ID': null,
      'OTUS_BY_ID': null,
      'EDGES_BY_SOURCE_ID': null,
      'EDGES_BY_TARGET_ID': null
  };
  function getFastLookup( lookupName ) {
      // return (or build) a flat list of Nexson elements by ID
      if (lookupName in fastLookups) {
          if (fastLookups[ lookupName ] === null) {
              buildFastLookup( lookupName );
          }
          return fastLookups[ lookupName ];
      }
      console.error("No such lookup as '"+ lookupName +"'!");
      return null;
  }
  function buildFastLookup( lookupName ) {
      // (re)build and store a flat list of Nexson elements by ID
      if (lookupName in fastLookups) {
          clearFastLookup( lookupName );
          var newLookup = {};
          switch( lookupName ) {

              case 'NODES_BY_ID':
                  // assumes that all node ids are unique, across all trees
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.node, function( i, node ) {
                          var itsID = node['@id'];
                          if (itsID in newLookup) {
                              console.warn("Duplicate node ID '"+ itsID +"' found!");
                          }
                          newLookup[ itsID ] = node;
                      });
                  });
                  break;

              case 'OTUS_BY_ID':
                  // assumes that all node ids are unique, across all trees
                  // AND 'otus' collections!
                  $.each(nexml.otus, function( i, otusCollection ) {
                      $.each(otusCollection.otu, function( i, otu ) {
                          var itsID = otu['@id'];
                          if (itsID in newLookup) {
                              console.warn("Duplicate otu ID '"+ itsID +"' found!");
                          }
                          newLookup[ itsID ] = otu;
                      });
                  });
                  break;

              case 'EDGES_BY_SOURCE_ID':
                  // allow multiple values for each source (ie, multiple children)
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.edge, function( i, edge ) {
                          var sourceID = edge['@source'];
                          if (sourceID in newLookup) {
                              newLookup[ sourceID ].push( edge );
                          } else {
                              // create the array, if not found
                              newLookup[ sourceID ] = [ edge ];
                          }
                      });
                  });
                  break;

              case 'EDGES_BY_TARGET_ID':
                  // allow multiple values for each target (for conflicted trees)
                  var allTrees = [];
                  $.each(nexml.trees, function(i, treesCollection) {
                      $.each(treesCollection.tree, function(i, tree) {
                          allTrees.push( tree );
                      });
                  });
                  $.each(allTrees, function( i, tree ) {
                      $.each(tree.edge, function( i, edge ) {
                          var targetID = edge['@target'];
                          if (targetID in newLookup) {
                              newLookup[ targetID ].push( edge );
                          } else {
                              // create the array, if not found
                              newLookup[ targetID ] = [ edge ];
                          }
                      });
                  });
                  break;

          }
          fastLookups[ lookupName ] = newLookup;
      } else {
          console.error("No such lookup as '"+ lookupName +"'!");
      }
  }
  function clearFastLookup( lookupName ) {
      // clear chosen lookup, on demand (eg, after merging in new OTUs)
      if (lookupName === 'ALL') {
          for (var aName in fastLookups) {
              fastLookups[ aName ] = null;
          }
          return;
      } else if (lookupName in fastLookups) {
          fastLookups[ lookupName ] = null;
          return;
      }
      console.error("No such lookup as '"+ lookupName +"'!");
  }
  function getNexsonChildren(d) {
      var parentID = d['@id'];
      var itsChildren = [];
      var childEdges = getTreeEdgesByID(null, parentID, 'SOURCE');

      // If this node has one child, it's probably a latent root-node that
      // should be hidden in the tree view.
      if (childEdges.length === 1) {
          // treat ITS child node as my immediate child in the displayed tree
          var onlyChildNodeID = childEdges[0]['@target'];
          childEdges = getTreeEdgesByID(null, onlyChildNodeID, 'SOURCE');
      }

      $.each(childEdges, function(index, edge) {
          var childID = edge['@target'];
          var childNode = getTreeNodeByID(childID);
          if (!('@id' in childNode)) {
              console.error(">>>>>>> childNode is a <"+ typeof(childNode) +">");
              console.error(childNode);
          }
          itsChildren.push( childNode );
      });
      // N.B. D3 layouts expect null, instead of an empty array
      ///return (itsChildren.length === 0) ? null: itsChildren;
      return itsChildren;
  }
  function countDescendantTips( node ) {
      /* Recurse through all descendants of this node and count the tips,
       * adding the total as an ad-hoc property of the node.
       *
       * Since these totals are often used in for branch rotation, we should be
       * able to pre-process nodes as needed, then run a final sweep that
       * only processes un-modified nodes.
       *
       * TODO: Count just tips? or all descendants?
       */
      if ('descendantTipCount' in node) {   // do this once only!
          return;
      }
      var children = getNexsonChildren(node);
      if (children.length === 0) {
          // this node is a leaf and should "count itself"
          node.descendantTipCount = 1;
      } else {
          var tipCount = 0;
          $.each(children, function(i, child) {
              countDescendantTips(child);
              tipCount += child.descendantTipCount;
          });
          node.descendantTipCount = tipCount;
      }
  }
  function assignNodeLabels( node ) {
      /* Add the various properties that might be shown as labels. Since these
       * can also be used in an alphabetical sort (for branch rotation), we
       * should be able to pre-process these as needed, followed by a final
       * sweep that just processes any un-modified nodes.
       */
      if ('originalLabel' in node) {   // do this once only!
          return;
      }
      /* N.B. It's best to provide at least an empty string for all
       * properties, to avoid showing 'undefined' labels in some browsers.
       */
      node.explicitLabel = '';
      node.originalLabel = '';
      node.ottTaxonName = '';
      node.ottId = '';
      if ('label' in node) {
        console.log(">> this node has 'label'");
        node.explicitLabel = node['label'];
      }
      if ('@label' in node) {
        console.log(">> this node has '@label'");
        node.explicitLabel = node['@label'];
      }
      if ('@otu' in node) {
        var itsOTU = getOTUByID( node['@otu'] );
        // attach OTU with possible label(s) here
        if (itsOTU) {
          // nudge the relevant properties into a generic form
          if ('^ot:originalLabel' in itsOTU) {
            node.originalLabel = itsOTU['^ot:originalLabel'];
          }
          if ('^ot:ottTaxonName' in itsOTU) {
            node.ottTaxonName = itsOTU['^ot:ottTaxonName'];
          }
          if ('^ot:ottId' in itsOTU) {
            node.ottId = itsOTU['^ot:ottId'];
          }
          if ('@label' in itsOTU) {
            // This is uncommon, but appears in our converted Newick.
            // Yield to an explicit label on the node itself!
            console.log(">> stealing otu label '"+ itsOTU['@label'] +"' for this node");
            if ($.trim(node.explicitLabel) === '') {
              node.explicitLabel = itsOTU['@label'];
            }
          }
        }
      }
  };

  function getTreeNodeByID(id) {
      // There should be only one matching (or none) within a tree
      // (NOTE that we now use a flat collection across all trees, so there's no 'tree' argument)
      var lookup = getFastLookup('NODES_BY_ID');
      return lookup[ id ] || null;
  }
  function getOTUByID(id) {
      // There should be only one matching (or none) in this study
      var lookup = getFastLookup('OTUS_BY_ID');
      return lookup[ id ] || null;
  }
  function getTreeEdgesByID(tree, id, sourceOrTarget) {
      // look for any edges associated with the specified *node* ID; return
      // an array of 0, 1, or more matching edges within a tree
      //
      // 'sourceOrTarget' lets us filter, should be 'SOURCE', 'TARGET', 'ANY'
      var foundEdges = [];
      var matchingEdges = null;

      if ((sourceOrTarget === 'SOURCE') || (sourceOrTarget === 'ANY')) {
          // fetch and add edges with this source node
          var sourceLookup = getFastLookup('EDGES_BY_SOURCE_ID');
          matchingEdges = sourceLookup[ id ];
          if (matchingEdges) {
              foundEdges = foundEdges.concat( matchingEdges );
          }
      }

      if ((sourceOrTarget === 'TARGET') || (sourceOrTarget === 'ANY')) {
          // fetch and add edges with this target node
          var targetLookup = getFastLookup('EDGES_BY_TARGET_ID');
          matchingEdges = targetLookup[ id ];
          if (matchingEdges) {
              foundEdges = foundEdges.concat( matchingEdges );
          }
      }

      return foundEdges;
  }
  function getSpecifiedTree() {
    var tree = null;
    // try all incoming options to locate this tree
    if ($.trim(treeID) !== '') {
        tree = getTreeByID(treeID);
    } else {
        tree = getTreeByPosition(treesCollectionPosition, treePosition);
    }
    return tree;
  }
  function getTreeByID(id) {
      var allTrees = [];
      if (!nexml) {
          return null;
      }
      $.each(nexml.trees, function(i, treesCollection) {
          $.each(treesCollection.tree, function(i, tree) {
              allTrees.push( tree );
          });
      });
      var foundTree = null;
      $.each( allTrees, function(i, tree) {
          if (tree['@id'] === id) {
              foundTree = tree;
              return false;
          }
      });
      return foundTree;
  }
  function getTreeByPosition(collectionPos, treePos) {
    var collection = nexml.trees[collectionPos];
    var tree = collection.tree[treePos];
    return tree;
  }
  function getRootNode() {
    // use options to find the root node, or return null
    var foundRoot = null;
    var tree = getSpecifiedTree();
    if (!tree) {
        return null;
    }
    var specifiedRoot = tree['^ot:specifiedRoot'] || null;
    var rootNodeID = specifiedRoot ? specifiedRoot : tree.node[0]['@id'];
    $.each(tree.node, function(i, node) {
        // Find the node with this ID and see if it has an assigned OTU
        if (node['@id'] === rootNodeID) {
            foundRoot = node;
            return false;
        }
    });
    return foundRoot;
  }
  /* END of 'NEXson-specific logic' */

  function convert(fullNexson) {
    // convert a new (or changed?) tree to Tree Illustrator's preferred format
    nexml = fullNexson.data.nexml;

    /* Apply the chosen branch-rotation method, i.e. how child nodes are
     * ordered within the tree. Note that all options here should be
     * deterministic; the same input tree and rotation method should *always*
     * produce the same output. We'll accomplish this by using d3's
     * alphabetical sort as the tie-breaker.
     *
     * Some of these methods introduce new burdens:
     *  - Sorting by clade size means we need to recurse and count children for
     *    all nodes ahead of time.
     *  - Alpha-sorting uses active node labels, so we need to know them.
     *
     * The method choices below are enumerated in TreeIllustrator.js, so any
     * changes should be shared in both places.
     */
    var branchRotator;
    switch(branchRotation) {
        case 'UNCHANGED':
            branchRotator = null;
            break;
        case 'ALPHABETICAL':
            branchRotator = function(a,b) {
                // sort based on the user's chosen field (passed as param)
                assignNodeLabels(a);
                assignNodeLabels(b);
                return d3.descending(a[ nodeLabelField ], b[ nodeLabelField ]);
            };
            break;
        case 'LADDERIZE_RIGHT':
            branchRotator = function(a,b) {
                countDescendantTips(a);
                countDescendantTips(b);
                if (a.descendantTipCount > b.descendantTipCount) return -1;
                if (b.descendantTipCount > a.descendantTipCount) return 1;
                // Still here? Fall back to alphabetic sort
                assignNodeLabels(a);
                assignNodeLabels(b);
                return d3.descending(a[ nodeLabelField ], b[ nodeLabelField ]);
            };
            break;
        case 'LADDERIZE_LEFT':
            branchRotator = function(a,b) {
                countDescendantTips(a);
                countDescendantTips(b);
                if (a.descendantTipCount > b.descendantTipCount) return 1;
                if (b.descendantTipCount > a.descendantTipCount) return -1;
                // Still here? Fall back to alphabetic sort
                assignNodeLabels(a);
                assignNodeLabels(b);
                return d3.descending(a[ nodeLabelField ], b[ nodeLabelField ]);
            };
            break;
        case 'ZIG_ZAG':
            // Mimic the ladderize options above, but alternate left and right each time
            var leftOrRight = 'LEFT';
            branchRotator = function(a,b) {
                countDescendantTips(a);
                countDescendantTips(b);
                if (leftOrRight === 'LEFT') {
                    leftOrRight = 'RIGHT';
                    if (a.descendantTipCount > b.descendantTipCount) return 1;
                    if (b.descendantTipCount > a.descendantTipCount) return -1;
                } else {  // presumably it's 'RIGHT'
                    leftOrRight = 'LEFT';
                    if (a.descendantTipCount > b.descendantTipCount) return -1;
                    if (b.descendantTipCount > a.descendantTipCount) return 1;
                }
                // Still here? Fall back to alphabetic sort
                assignNodeLabels(a);
                assignNodeLabels(b);
                return d3.descending(a[ nodeLabelField ], b[ nodeLabelField ]);
            };
            break;
        default:
            console.error("No such branch-rotation method: '"+ branchRotation +"'!");
    }

    var layout = d3.layout.cluster()  // or tree (seems most basic)
                          .size([1.0, 1.0])  // just making the default size explicit
                          .separation(function(a,b) {
                               /* We want all tips (leaves) to be evenly spaced, whether or
                                * not they are siblings:
                                *   https://github.com/mbostock/d3/wiki/Cluster-Layout#separation
                                */
                               // return (a.parent == b.parent) ? 1 : 2;
                               return 1;
                           })
                           .children(getNexsonChildren)   // defined below
                           .sort(branchRotator),   // defined above
        params = [ 'size' ],  // ["round", "sticky", "ratio", "padding"],
        output = {
          //"x": "x",
          //"y": "y",
          //"dx": "width",
          //"dy": "height"
        };

    var rootNode = getRootNode();  // defined below
    if (!rootNode) {
      console.warn("No root node found!");
      console.warn("  treeID: "+ treeID);
      console.warn("  treesCollectionPosition: "+ treesCollectionPosition);
      console.warn("  treePosition: "+ treePosition);
      return false;
    }

    data = {
        // copy _id of source data
        '_id': fullNexson._id
    };

    data.phyloNodes = layout
      //.size(vg.data.size(size, group))
      //.value(value)
        .nodes(rootNode);

    /* Normalize the node locations to fill the specified area. This will
     * ensure that the rendered tree matches our user's chosen size, and that
     * radial trees don't have weird gaps.
     */
    var minX = Number.POSITIVE_INFINITY,
        minY = Number.POSITIVE_INFINITY,
        maxX = Number.NEGATIVE_INFINITY,
        maxY = Number.NEGATIVE_INFINITY;
    $.each(data.phyloNodes, function(i, node) {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
    });
    var xScale = 1.0 / (maxX - minX);
    var yScale = 1.0 / (maxY - minY);
    $.each(data.phyloNodes, function(i, node) {
        node.x = (node.x - minX) * xScale;
        node.y = (node.y - minY) * yScale;
    });

    // add all possible labels to each node
    var tree = getSpecifiedTree();
    $.each(data.phyloNodes, function(i, node) {
        assignNodeLabels(node);
    });

    data.phyloEdges = layout.links(data.phyloNodes);
/* translate incoming keys to their output names?
    var keys = vg.keys(output),
        len = keys.length;

    data.forEach(function(d) {
      var key, val;
      for (var i=0; i<len; ++i) {
        key = keys[i];
        if (key !== output[key]) {
          val = d[key];
          delete d[key];
          d[output[key]] = val;
        }
      }
      //d.children = getChildren(d);
    });
*/

/*
    console.log("OUTGOING data from nexson transform:");
    console.log(data);
*/
    return data;
  }
  
  //input.add.forEach(convert);
  for (var i = 0; i < input.add.length; i++) {
    // actually replace each item with the new stucture
    input.add[i] = convert(input.add[i]);
  }
  if (this.reevaluate(input)) {
    //input.mod.forEach(convert);
    for (var i = 0; i < input.mod.length; i++) {
      // actually replace each item with the new stucture
      input.mod[i] = convert(input.mod[i]);
    }
  }
  // return the modified ChangeSet
  return input;
};

module.exports = Nexson;

Nexson.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Nexson transform",
  "description": "Transforms NEXson data into a form suitable for use in the Tree Illustrator"
               + " and d3.phylogram.js.",
  "type": "object",
  "properties": {
    "type": {"enum": ["nexson"]},
    "treeID": {
      "description": "An explicit tree ID (should be definitive)",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    },
    "treesCollectionPosition": {
      "description": "Look in the nth 'trees' element (collection of 'tree')",
      "oneOf": [{"type": "integer"}, {"$ref": "#/refs/signal"}],  // TODO: signal?
      "default": 0
    },
    "treePosition": {
      "description": "Convert the nth 'tree' found in this collection", // TODO: confirm
      "oneOf": [{"type": "integer"}, {"$ref": "#/refs/signal"}],
      "default": 0
    }
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type"]  // TODO: add required params
};

},{"vega":187,"vega-logging":147,"vega/src/transforms/Transform":238}],252:[function(require,module,exports){
/*
  (Heavily) adapted from Ken-ichi Ueda's 'd3.phylogram.js'

  Wrapper around a d3-based phylogram (tree where branch lengths are scaled),
  refactored into a Vega transform. What does this change?
    - Returns transformed data (an object with nodes and links, projected to
      the coordinate space based on the chosen layout).
    - Assumes all incoming data has proportional x/y values (0.0 to 1.0).
    - Doesn't render anything! Just passes the projected data for downstream
      rendering.

  This includes new and modified layouts, including
    - radial (circular) layout with *scaled* branch lengths
    - a traditional cladogram with straight, diagonal edges

  Copyright (c) 2014, Jim Allman
  Copyright (c) 2013, Ken-ichi Ueda

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer. Redistributions in binary
  form must reproduce the above copyright notice, this list of conditions and
  the following disclaimer in the documentation and/or other materials
  provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

  DOCUMENTATION

  buildCartesian(nodes, links, options)
    Creates a phylogram.
    Arguments:
      nodes: JS array of nodes
      links: JS array of links
    Options:
      tree
        Pre-constructed d3 tree layout.
      diagonal
        Function that creates the d attribute for an svg:path. Defaults to a
        right-angle diagonal.
      skipTicks
        Skip the tick rule.
      skipBranchLengthScaling
        Make a dendrogram instead of a phylogram.
  
  buildRadial(nodes, links, options)
    Creates a radial dendrogram.
    Options: same as build, but without diagonal, skipTicks, and
      skipBranchLengthScaling
  
  buildCladogram(nodes, links, options)
    Creates a "triangular" dendrogram
    Options: TODO

  rightAngleDiagonal()
    Similar to d3.diagonal except it create an orthogonal crook instead of a
    smooth Bezier curve.
    
  radialRightAngleDiagonal()
    d3.phylogram.rightAngleDiagonal for radial layouts.
*/
var vg  = require('vega'),
    log  = require('vega-logging'),
    Transform = require('vega/src/transforms/Transform');

function Phylogram(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
    layout: {type: 'value', default: 'cartesian'},
    width: {type: 'value', default: 1.0},
    height: {type: 'value', default: 1.0},
    // some are only used in radial layout, ignored in others
    radius: {type: 'value', default: 0.5},
    radialArc: {type: 'array<value>', default: [0, 350]},
    radialSweep: {type: 'value', default: 'CLOCKWISE'},  // 'CLOCKWISE' | 'COUNTERCLOCKWISE'
    // others are used only in non-radial layouts
    tipsAlignment: {type: 'value', default: 'RIGHT'},
    branchStyle: {type: 'value', default: ''}, // usu. determined by layout
    branchLengths: {type: 'value', default: ''},
    nodeLabelSource: {type: 'value', default: 'MAPPED'}, // 'ORIGINAL' | 'MAPPED'
    showFallbackLabels: {type: 'value', default: true}
    // some are reckoned internally (not available to the caller)
    //descentAxis: {type: 'value', default: 'x'}, // 'x' | 'y'
    //orientation: {type: 'value', default: -90},
  });
  return this.produces(true)
             .mutates(true);
}

var prototype = (Phylogram.prototype = Object.create(Transform.prototype));
prototype.constructor = Phylogram;

prototype.transform = function(input) {
  log.debug(input, ['making a phylogram']);

  for (var i = 0; i < input.add.length; i++) {
    this.buildPhylogram(input.add[i]);
  }
  if (this.reevaluate(input)) {
    for (var i = 0; i < input.mod.length; i++) {
      this.buildPhylogram(input.mod[i]);
    }
  }
  /* N.B. Typical notation doesn't work here ('this' is not defined in the called func)
  input.add.forEach();
  if (this.reevaluate(input)) {
    input.mod.forEach(this.buildPhylogram);
  }
  */

  return input;
};

prototype.buildPhylogram = function(data) {
    // read in params
    var layout = this.param('layout');  // 'cartesian' | 'radial' | 'cladogram' | ???

    // NOTE that width and height refer to the final display, so these might
    // map to X or Y coordinates depending on orientation
    var width = this.param('width');
    var height = this.param('height');
    var radius = this.param('radius');  // for radial layout
    var radialArc = this.param('radialArc');  // angles of arc (radial layout only)
    var radialSweep = this.param('radialSweep');  // 'CLOCKWISE' or 'COUNTERCLOCKWISE'
    var branchStyle = this.param('branchStyle');
        // 'rightAngleDiagonal', 'radialRightAngleDiagonal', or a standard
        // D3 diagonal; by default, this will be based on the chosen layout
    var branchLengths = this.param('branchLengths');
    var tipsAlignment = this.param('tipsAlignment');
        // disregard for radial layouts?
    var orientation; // this.param('orientation');
        // degrees of rotation from default (0, -90, 90, 180)
        // NOTE that this is not set directly (from vega spec) but from within
    var descentAxis; // this.param('descentAxis');
        // needed to render paths correctly
        // TODO: add more from options below
    var nodeLabelSource = this.param('nodeLabelSource');  // 'ORIGINAL' or 'MAPPED'
        // choose preferred source for labels; fall back as needed and use marker classes
        // to distinguish these in display
    var showFallbackLabels = this.param('showFallbackLabels');  // boolean

    /* apply some internal constraints (formerly in param setters) */

    if (layout === 'radial') {
      // N.B. radial layout needs fixed (-90) orientation
      orientation = -90;
      descentAxis = 'x';
    } else {
      switch(tipsAlignment) {
        case 'TOP':
          orientation = 180;
          descentAxis = 'y';
          break;
        case 'RIGHT':
          orientation = -90;
          descentAxis = 'x';
          break;
        case 'BOTTOM':
          orientation = 0;
          descentAxis = 'y';
          break;
        case 'LEFT':
          orientation = 90;
          descentAxis = 'x';
          break;
      }
    }

    function phylogram(data) {
      // Expecting incoming data in the 'phylotree' format described here:
      //  https://github.com/OpenTreeOfLife/tree-illustrator/wiki/Building-on-D3-and-Vega

      //console.log('STARTING phylogram transform...');

      // scale all coordinates as directed
      if ((width !== 1.0) || (height !== 1.0)) {
          data.phyloNodes.map(scalePoint);
      }

      if (orientation !== 0) {
          // rotate all nodes by n degrees
          data.phyloNodes.map(rotatePointByOrientation);
      }

      // apply the chosen layout, in a 1x1 "virtual space"..?
      var layoutGenerator;
      switch(layout) {
          case 'radial':
              layoutGenerator = radialLayout;
              break;
          case 'cladogram':
              layoutGenerator = cladogramLayout;
              break;
          case 'cartesian':
          default:
              layoutGenerator = cartesianLayout;
      }
      layoutGenerator(data);

      // set (or revise) paths for all links
      var pathGenerator;
      switch(branchStyle) {
        case '':
            // if none specified, match the layout
            switch(layout) {
                case 'radial':
                    pathGenerator = radialRightAngleDiagonal();
                    break;
                case 'cladogram':
                    pathGenerator = straightLineDiagonal();
                    break;
                case 'cartesian':
                    pathGenerator = rightAngleDiagonal();
                    break;
                default:
                    // allow for moretraditional paths
                    pathGenerator = d3.svg[branchStyle]();
            }
            break;
        case 'straightLineDiagonal':
            pathGenerator = straightLineDiagonal();
            break;
        case 'radialRightAngleDiagonal':
            pathGenerator = radialRightAngleDiagonal();
            break;
        case 'rightAngleDiagonal':
            pathGenerator = rightAngleDiagonal();
            break;
        case 'diagonal':
            // intercept and switch its x/y bias
            if (descentAxis === 'x') {
                pathGenerator = function(d) {
                    // copied from vg.data.link > diagonalX
                    var s = d.source,
                        t = d.target,
                        m = (s.x + t.x) / 2;
                    return "M" + s.x + "," + s.y
                         + "C" + m   + "," + s.y
                         + " " + m   + "," + t.y
                         + " " + t.x + "," + t.y;
                }
            } else {
                pathGenerator = function(d) {
                    // copied from vg.data.link > diagonalY
                    var s = d.source,
                        t = d.target,
                        m = (s.y + t.y) / 2;
                    return "M" + s.x + "," + s.y
                         + "C" + s.x + "," + m
                         + " " + t.x + "," + m
                         + " " + t.x + "," + t.y;
                }
            }
            break;
        case 'radial':
            // intercept and switch its x/y bias
            pathGenerator = d3.svg.diagonal.radial();
                //.projection(function (d) { return [d.y, d.x]; });
            break;
        default:
            pathGenerator = d3.svg[branchStyle]();
            break;
      }

      data.phyloEdges.forEach(function(d, i) {
        d.path = pathGenerator(d);
      });

      /* Generate a "hotspot" path based on layout and dimensions. 
       * (This is used to respond to mouse actions, etc. while editing.) 
       */
      var hotspotGenerator = function() {
          // "M 200 175 A 25 25 0 1 0 217.678 217.678"
          switch(layout) {
              case 'cartesian':
                  // Use the final bounding box of all nodes
                  var extents = getBoundingBoxFromPoints( data.phyloNodes );
                  // rename for clarity
                  var top =     extents.minY,
                      right =   extents.maxX,
                      bottom =  extents.maxY,
                      left =    extents.minX;
                  return "M "+ left +","+ top
                       +" L "+ right +","+ top
                       +" L "+ right +","+ bottom
                       +" L "+ left +","+ bottom
                       +" Z";
              case 'cladogram':
                  var extents = getBoundingBoxFromPoints( data.phyloNodes );
                  var path = "M 0,0";   // start and end at root node
                  switch(tipsAlignment) {
                    case 'TOP':
                      return path
                            +" L "+ extents.minX +","+ extents.minY
                            +" L "+ extents.maxX +","+ extents.minY
                            +" Z";
                    case 'RIGHT':
                      return path
                            +" L "+ extents.maxX +","+ extents.minY
                            +" L "+ extents.maxX +","+ extents.maxY
                            +" Z";
                    case 'BOTTOM':
                      return path
                            +" L "+ extents.minX +","+ extents.maxY
                            +" L "+ extents.maxX +","+ extents.maxY
                            +" Z";
                    case 'LEFT':
                      return path
                            +" L "+ extents.minX +","+ extents.minY
                            +" L "+ extents.minX +","+ extents.maxY
                            +" Z";
                  }
              case 'radial':
                  // sweep out the entire area of the graph
                  var path = "M0,0 L";   // start at root node, begin first line
                  // create a fake "edge" to discern the full arc
                  var extents =  getBoundingBoxFromPoints( data.phyloNodes, {useCoordinates: 'CARTESIAN'} );
                  var fullWidthEdge = {
                      source: {cartesian_x: extents.maxX, cartesian_y: extents.minY},
                      target: {cartesian_x: extents.maxX, cartesian_y: extents.maxY}
                  };
                  // get the full arc as a path string
                  var pathGenerator = radialRightAngleDiagonal();
                  // prepend root node position and close the final shape
                  // EXAMPLE output: 'M-228,19 A229,229 0 0,0 -227,26L-227,26'
                  //    BECOMES 'M0,0 L-228,19 A229,229 0 1,1 -227,26L-227,26 Z'
                  path += pathGenerator(fullWidthEdge).slice(1); // trim initial 'M'
                  path += " Z";
                  // Flip the large-arc and sweep flags for "outer sweep"; see
                  //  https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Arcs
                  //  http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
                  path = path.replace("0 0,0 ", "0 1,1 "); 
                  return path;

              default:
                  console.error("Unknown tree layout for bounding box!");
                  return "M -50,-50 L -50,50, L 50,50, L 50,-50 Z";
          }
      }
      /* Generate a series of vertex handles based on layout and dimensions.
       * (These are also used to respond to mouse actions, etc. while editing.)
       */
      var handleGenerator = function() {
          var handles = [ ];
          var moveHandleTip = "Drag to move this tree on the page.";
          var resizeHandleTip = "Drag to change width and height";
          switch(layout) {
              case 'cartesian':
              case 'cladogram':
                  // These use just two handles on "opposite" corners from the root node.
                  handles.push({ name: 'center', x: 0, y: 0, shape: 'diamond', size: 120,
                                 tooltip: moveHandleTip });
                  var extents = getBoundingBoxFromPoints( data.phyloNodes );
                  switch(tipsAlignment) {
                    case 'TOP':
                      handles.push({ name: 'top-left', x: extents.minX, y: extents.minY,
                                     tooltip: resizeHandleTip });
                      handles.push({ name: 'top-right', x: extents.maxX, y: extents.minY,
                                     tooltip: resizeHandleTip });
                      break;
                    case 'RIGHT':
                      handles.push({ name: 'top-right', x: extents.maxX, y: extents.minY,
                                     tooltip: resizeHandleTip });
                      handles.push({ name: 'bottom-right', x: extents.maxX, y: extents.maxY,
                                     tooltip: resizeHandleTip });

                      break;
                    case 'BOTTOM':
                      handles.push({ name: 'bottom-left', x: extents.minX, y: extents.maxY,
                                     tooltip: resizeHandleTip });
                      handles.push({ name: 'bottom-right', x: extents.maxX, y: extents.maxY,
                                     tooltip: resizeHandleTip });
                      break;
                    case 'LEFT':
                      handles.push({ name: 'top-left', x: extents.minX, y: extents.minY,
                                     tooltip: resizeHandleTip });
                      handles.push({ name: 'bottom-left', x: extents.minX, y: extents.maxY,
                                     tooltip: resizeHandleTip });
                      break;
                  }
                  break;

              case 'radial':
                  handles.push({ name: 'center', x: 0, y: 0, shape: 'diamond', size: 120,
                                 tooltip: moveHandleTip });
                  // Reckon three handle positions (on perimeter) in Cartesian coordinates...
                  var extents = getBoundingBoxFromPoints( data.phyloNodes, {useCoordinates: 'CARTESIAN'} );
                  var startPoint = {x: extents.maxX, y: (radialSweep === 'CLOCKWISE') ? extents.minY : extents.maxY},
                      midPoint =   {x: extents.maxX, y: (extents.maxY + extents.minY) / 2},
                      endPoint =   {x: extents.maxX, y: (radialSweep === 'CLOCKWISE') ? extents.maxY : extents.minY};
                  // ... then convert to polar coordinates (simple arrays)
                  startPoint = cartesianToPolarProjection( startPoint, {returnType: 'POLAR_COORDS'} );
                  midPoint = cartesianToPolarProjection( midPoint, {returnType: 'POLAR_COORDS'} );
                  endPoint = cartesianToPolarProjection( endPoint, {returnType: 'POLAR_COORDS'} );

                  // pass all polar properties (angle, radius, theta) plus a descriptive name
                  handles.push( $.extend(startPoint, {name: 'start-angle',
                                                      tooltip: "Drag to change radius and starting angle"}) );
                  handles.push( $.extend(midPoint, {name: 'radius',
                                                    tooltip: "Drag to change this tree's radius" }) );
                  handles.push( $.extend(endPoint, {name: 'end-angle',
                                                    tooltip: "Drag to change radius and ending angle"}) );
                  break;
          }
          // merge in default properties as needed
          $.each(handles, function(i,h) {
              handles[i] = $.extend({ shape:'circle', size:80, rotate:0 }, handles[i]);
          });
          return handles;
      }

      data.hotspot = [  // emulate a tuple
          {
              "path": hotspotGenerator()
          }
      ];
      data.vertexHandles = handleGenerator(); // returns an array

      // copy layout properties to the phylotree, for possible use downstream
      data.layout = layout;
      data.tipsAlignment = tipsAlignment;
      data.descentAxis = descentAxis;  // implicit in tipsAlignment?
      data.orientation = orientation;  // implicit in tipsAlignment?
      data.width = width;
      data.height = height;
      data.radius = radius;
      data.branchStyle = branchStyle;
      data.branchLengths = branchLengths;
      data.nodeLabelSource = nodeLabelSource;
      data.showFallbackLabels = showFallbackLabels;

      // copy generators for hotspot and other handles
      //data.hotspotGenerator = hotspotGenerator;
      //data.handleGenerator = handleGenerator;
      Phylogram.hotspotGenerator = hotspotGenerator;
      Phylogram.handleGenerator = handleGenerator;

      return data;
    }
      
    var displacePoint = function(point, delta) {
        // where 'delta' is an object with x and y properties
        point.x += delta.x;
        point.y += delta.y;
        return point;
    }

    // Return width *or* height, as appropriate for the current orientation
    var getOuterDimensionForX = function() {
        switch(orientation) {
            case 0:
            case 180:
            case -180:
                return width;

            case 90:
            case -90:
            case 270:
            case -270:
                return height;
        }
        console.error("getOuterDimensionForX(): Unexpected value for orientation: '"+ orientation +"'");
    }
    var getOuterDimensionForY = function() {
        switch(orientation) {
            case 0:
            case 180:
            case -180:
                return height;
            case 90:
            case -90:
            case 270:
            case -270:
                return width;
        }
        console.error("getOuterDimensionForY(): Unexpected value for orientation: '"+ orientation +"'");
    }

    var scalePoint = function(point) {
        // where point is any object having x and y properties
        // NOTE that we're scaling up from fractional values (0.0 - 1.0), so
        // the nominal width+height are also our scaling multipliers
        point.x *= getOuterDimensionForX();
        if (layout === 'radial') {
            point.y *= radius;
        } else {
            point.y *= getOuterDimensionForY();
        }
        // scale cartesian_x and y, if stored
        if ('cartesian_x' in point) {
            point.cartesian_x *= getOuterDimensionForX();
            point.cartesian_y *= getOuterDimensionForY();
        }
        return point;
    }

    var rotatePointByOrientation = function(point) {
        // use the vega input 'orientation' value to spin the tree
        return rotatePoint(point, orientation);
    }
    var rotatePointByY = function(point) {
        // Y coordinate should be between 0.0 and 1.0
        var yAngle = 360.0 * point.x;
        return rotatePoint(point, yAngle);
    }

    var rotatePoint = function(point, angle, pivot) {
        // where point is any object having x and y properties, and 'pivot'
        // is an optional second point
        var cos = Math.cos,
            sin = Math.sin,
            angle = degreesToRadians(angle || orientation), // convert to radians
            // default midpoint is origin (0,0)
            xm = (pivot && 'x' in pivot) ? pivot.x : 0,
            ym = (pivot && 'y' in pivot) ? pivot.y : 0,
            x = point.x,    // capture old x and y for this point
            y = point.y;

        // subtract midpoints, rotate from origin, then restore them
        point.x = (x - xm) * cos(angle) - (y - ym) * sin(angle) + xm;
        point.y = (x - xm) * sin(angle) + (y - ym) * cos(angle) + ym;
        if ('cartesian_x' in point) {
            cx = point.cartesian_x,    // capture old coords
            cy = point.cartesian_y;
            point.cartesian_x = (cx - xm) * cos(angle) - (cy - ym) * sin(angle) + xm;
            point.cartesian_y = (cx - xm) * sin(angle) + (cy - ym) * cos(angle) + ym;
        }
        return point;
    }

    function radiansToDegrees(r) {
        return (r * 180 / Math.PI);
    }
    function degreesToRadians(d) {
        return (d * Math.PI / 180);
    }
    function normalizeDegrees(d) {
        // convert to positive integer, e.g. -90 ==> 270
        return (d + (360 * 3)) % 360;
    }

  // Convert XY and radius to angle of a circle centered at 0,0
  var coordinateToAngle = function(coord, radius) {
    var wholeAngle = 2 * Math.PI,
        quarterAngle = wholeAngle / 4;
    
    var coordQuad = coord[0] >= 0 ?
            (coord[1] >= 0 ? 1 : 2) :
            (coord[1] >= 0 ? 4 : 3),
        coordBaseAngle = Math.abs(Math.asin(coord[1] / radius));
    
    // Since this is just based on the angle of the right triangle formed
    // by the coordinate and the origin, each quad will have different
    // offsets
    switch (coordQuad) {
      case 1:
        coordAngle = quarterAngle - coordBaseAngle;
        break;
      case 2:
        coordAngle = quarterAngle + coordBaseAngle;
        break;
      case 3:
        coordAngle = 2*quarterAngle + quarterAngle - coordBaseAngle;
        break
      case 4:
        coordAngle = 3*quarterAngle + coordBaseAngle;
    }
    return coordAngle;
  }

  /* path generators */

  var straightLineDiagonal = function(d) {
    // do-nothing projection (just isolates x and y)
    var projection = function(d) { return [d.x, d.y]; }
    
    var path = function(pathData) {
      return "M" + pathData[0] + ' ' + pathData[1];
    }
    
    function diagonal(d) {
      var pathData = [d.source, d.target];
      pathData = pathData.map(projection);
      return path(pathData);
    }
    
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    
    diagonal.path = function(x) {
      if (!arguments.length) return path;
      path = x;
      return diagonal;
    };
    
    return diagonal;
  }

  var rightAngleDiagonal = function(d) {
    // do-nothing projection (just isolates x and y)
    var projection = function(d) { return [d.x, d.y]; }
    
    var path = function(pathData) {
      return "M" + pathData[0] + ' ' + pathData[1] + " " + pathData[2];
    }
    
    function diagonal(d) {
      var midpointX = (d.source.x + d.target.x) / 2,
          midpointY = (d.source.y + d.target.y) / 2,
          pathData = (descentAxis === 'x') ?
                    [d.source, {x: d.source.x, y: d.target.y}, d.target] :
                    [d.source, {x: d.target.x, y: d.source.y}, d.target];
      pathData = pathData.map(projection);
      return path(pathData)
    }
    
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    
    diagonal.path = function(x) {
      if (!arguments.length) return path;
      path = x;
      return diagonal;
    };
    
    return diagonal;
  }
  
  var cartesianToPolarProjection = function(d, options) {
    options = options || {returnType: 'XY-ARRAY'}; // or 'POLAR-COORDS'
    // radius is simply the x coordinate
    var r = d.x;

    // Angle is influenced by the specified size, arc and sweep.
    // map Y coordinate to total specified width
    var totalArcDegrees;
    // force both angles to positive numbers
    var startAngle = normalizeDegrees(radialArc[0]);
    var endAngle = normalizeDegrees(radialArc[1]);
    // check for arcs that cross the zero line
    var shiftAngle;  // plot the active arc starting here
    if (radialSweep === 'CLOCKWISE') {
        totalArcDegrees = normalizeDegrees(endAngle - startAngle);
        shiftAngle = startAngle;
    } else { // assumes 'COUNTERCLOCKWISE')
        totalArcDegrees = normalizeDegrees(startAngle - endAngle);
        shiftAngle = endAngle;
    }
    // Remap Y to the tree's bounding dimension to plot its angle correctly 
    var angleWithinArc = ((d.y / getOuterDimensionForX()) * totalArcDegrees);
    // This gives us the angle starting from one end of the arc; place this!
    var angleFromOrigin = normalizeDegrees(angleWithinArc + shiftAngle);

    var a = degreesToRadians( angleFromOrigin);  ///  / 180 * Math.PI;
    // remap angle to the specified arc, in the sweep direction

    // TODO: reckon angle based on height/width and sweep
    if (options.returnType === 'POLAR_COORDS') {
        // add radius and angle (theta) for label display in vega
        var labelAngle = normalizeDegrees(radiansToDegrees(a));
        var labelAlignment = 'left';
        // TODO: adjustable nudge separates label text from drawn node
        var nudgeRadius = 4; // px?
        // TODO: adjustable nudge (should vary with text size) shifts angle
        // from the label's baseline to the middle of its x-height
        var nudgeTheta = degreesToRadians(0.6);

        // test for upside-down labels (assuming 0 deg = due right)
        if ((labelAngle > 90) && (labelAngle < 270)) {
            // left-side labels should be flipped and aligned right
            labelAlignment = 'right';
            labelAngle = normalizeDegrees(labelAngle + 180);
            nudgeTheta = -(nudgeTheta);
        }
        var nodeAndLabelProperties = {
            // X, Y coordinates for the node itself
            'x': r * Math.cos(a),
            'y': r * Math.sin(a),
            // additional properties for placing the label
            'radius': r + nudgeRadius,
            'theta': a - degreesToRadians(orientation) + nudgeTheta, // in radians!
            'angle': labelAngle,
            'align': labelAlignment
        };
        return nodeAndLabelProperties;
    } else {
        // return XY-COORDS by default
        return [r * Math.cos(a), r * Math.sin(a)];
    }
  }

  var radialRightAngleDiagonal = function(d) {
    // We need a standalone version of this, since we're mapping (preserved)
    // cartesian_x and cartesian_y to polar coordinates.

    // translate from cartesian to polar coordinates
    var projection = cartesianToPolarProjection;
            
    var path = function(pathData) {
        var src = pathData[0],
            mid = pathData[1],
            dst = pathData[2],
            radius = Math.sqrt(src[0]*src[0] + src[1]*src[1]),
            srcAngle = coordinateToAngle(src, radius),
            midAngle = coordinateToAngle(mid, radius),
            clockwise = Math.abs(midAngle - srcAngle) > Math.PI ? midAngle <= srcAngle : midAngle > srcAngle,
            rotation = 0,  // this is moot for a circle
            largeArc = 0,
            sweep = clockwise ? 0 : 1;
        var pathString = 'M' + src + ' ' +
          "A" + [radius,radius] + ' ' + rotation + ' ' + largeArc+','+sweep + ' ' + mid +
          'L' + dst;
        return pathString;
    }
            
    function diagonal(d) {
      var midpointX = (d.source.cartesian_x + d.target.cartesian_x) / 2,
          midpointY = (d.source.cartesian_y + d.target.cartesian_y) / 2,
          pathData = (descentAxis === 'x') ?
                    [
                        {x: d.source.cartesian_x, y: d.source.cartesian_y},
                        {x: d.source.cartesian_x, y: d.target.cartesian_y},
                        {x: d.target.cartesian_x, y: d.target.cartesian_y}
                    ] :
                    [
                        {x: d.source.cartesian_x, y: d.source.cartesian_y},
                        {x: d.target.cartesian_x, y: d.source.cartesian_y},
                        {x: d.target.cartesian_x, y: d.target.cartesian_y}
                    ];
      pathData = pathData.map(projection);
      return path(pathData)
    }
            
    return diagonal;
  }
  
    /* layout generators (position points in 1.0, 1.0 space) */
    var cartesianLayout = function(data) {
        // place all nodes for the radial layout (already done)

        // just nudge all points to put the root node at 0,0
        moveRootToOrigin(data);
    }

    var moveRootToOrigin = function (data) {
        // move all points to put the root node at origin (0.0)
        var rootNode = data.phyloNodes[0];  // I believe this is always true
        var nudgeRootToOrigin = {x: -(rootNode.x), y: -(rootNode.y)};
        var alignPointsToOrigin = function(point) {
            return displacePoint(point, nudgeRootToOrigin);
        };
        data.phyloNodes.map(alignPointsToOrigin);
    }

    var getBoundingBoxFromPoints = function( points, options ) {
        // get X/Y bounds from a list of point-like objects
        options = options || {useCoordinates: 'DISPLAY'};
        var extents = {
            minX:  Number.MAX_VALUE,
            maxX: -Number.MAX_VALUE,
            minY:  Number.MAX_VALUE,
            maxY: -Number.MAX_VALUE
        };
        if (options.useCoordinates === 'CARTESIAN') {
            points.map(function(n) {
                extents.minX = Math.min(n.cartesian_x, extents.minX);
                extents.minY = Math.min(n.cartesian_y, extents.minY);
                extents.maxX = Math.max(n.cartesian_x, extents.maxX);
                extents.maxY = Math.max(n.cartesian_y, extents.maxY);
            });
        } else {
            points.map(function(n) {
                extents.minX = Math.min(n.x, extents.minX);
                extents.minY = Math.min(n.y, extents.minY);
                extents.maxX = Math.max(n.x, extents.maxX);
                extents.maxY = Math.max(n.y, extents.maxY);
            });
        }
        return extents;
    }

    var radialLayout = function(data) {
        // place all nodes for the radial layout

        // Project points (nodes) to radiate out from center.
        moveRootToOrigin(data);
        
        /* Adjust the layout to place Y coordinates from 1.0 to 1.0,
         * otherwise the tree will "bend over backwards" and its gap
         * will appear randomly on the circumference.
         */
        var extents = getBoundingBoxFromPoints( data.phyloNodes );
        var yOffset = extents.minY;
        if (yOffset !== 0) {
            $.each( data.phyloNodes, function( i, node ) {
                node.y -= yOffset;   // undo the offset
            });
        }

        var preserveCartesianCoordinates = function(point) {
            point.cartesian_x = point.x;
            point.cartesian_y = point.y;
        }
        data.phyloNodes.map(preserveCartesianCoordinates);

        data.phyloNodes.map(function(d) {
            pcoords = cartesianToPolarProjection(d, {returnType:'POLAR_COORDS'});
            d.radius  = pcoords.radius;
            d.theta  = pcoords.theta;
            d.angle  = pcoords.angle;
            d.align  = pcoords.align;
            d.x = pcoords.x;
            d.y = pcoords.y;
        });
    }
    var cladogramLayout = function(data) {
        // place all nodes for the "triangular" cladogram layout
        // TODO: support branch lengths?

        // project points (nodes) to radiate out from center
        moveRootToOrigin(data);
        
        /* Precalculate available leaf-node positions (based on number of
         * leaves, final width & height, and tip alignment). Then do
         * depth-first traversal from the root to assign the leaves to these
         * positions, placing all ancestors along the way.
         */
        var leafNodes = $.grep(data.phyloNodes, function(n) {
            return n['^ot:isLeaf'] === true;
        });

        var nLeaves = leafNodes.length;

        /* How far should we move on the descent axis for each step in depth?
         * NOTE that we'll normalize this to match the original width or height
         * later; for now, let's match the distance between leaf nodes.
         */
        var depthStep;

        var leafPositions = [ ];
        var startingLeafX, leafXstep,
            startingLeafY, leafYstep;
        switch(tipsAlignment) {
            case 'TOP':
                startingLeafX = -(width / 2.0);
                leafXstep = width / (nLeaves-1);
                startingLeafY = -height;
                leafYstep = 0;
                depthStep = -leafXstep;
                break;
            case 'RIGHT':
                startingLeafX = width;
                leafXstep = 0;
                startingLeafY = -(height / 2.0);
                leafYstep = height / (nLeaves-1);
                depthStep = leafYstep;
                break;
            case 'BOTTOM':
                startingLeafX = -(width / 2.0);
                leafXstep = width / (nLeaves-1);
                startingLeafY = height;
                leafYstep = 0;
                depthStep = leafXstep;
                break;
            case 'LEFT':
                startingLeafX = -width;
                leafXstep = 0;
                startingLeafY = -(height / 2.0);
                leafYstep = height / (nLeaves-1);
                depthStep = -leafYstep;
                break;
        }

        leafNodes.map(function(n, i) {
            leafPositions.push({
                'x': startingLeafX + (leafXstep * i),
                'y': startingLeafY + (leafYstep * i)
            });
        });

        var rootNode = data.phyloNodes[0];  // I believe this is always true
        var fullExtents = distributeChildrenAsCladogram(rootNode, leafPositions, depthStep);

        // realign root node to origin (it gets "pushed" far away by complex trees)
        moveRootToOrigin(data);

        // Scale the resulting layout to match the desired width (or height)
        switch(tipsAlignment) {
            case 'TOP':
            case 'BOTTOM':
                // width is already good; height should be squeezed (or stretched)
                var squeeze = height / (fullExtents.maxY - fullExtents.minY);
                var fitToHeight = function(point) {
                    point.y *= squeeze;
                    return point;
                }
                data.phyloNodes.map(fitToHeight);
                break;
            case 'RIGHT':
            case 'LEFT':
                // height is already good; width should be squeezed (or stretched)
                var squeeze = width / (fullExtents.maxX - fullExtents.minX);
                var fitToWidth = function(point) {
                    point.x *= squeeze;
                    return point;
                }
                data.phyloNodes.map(fitToWidth);
                break;
        }
    }
   
    var distributeChildrenAsCladogram = function(node, leafPositions, depthStep) {
        if (!node.children || node.children.length === 0) { return; }
        var extents = {
            minX:  Number.MAX_VALUE,
            maxX: -Number.MAX_VALUE,
            minY:  Number.MAX_VALUE,
            maxY: -Number.MAX_VALUE,
            descendantLeafCount: 0
        };
        node.children.map(function(n, i) {
            if ((n['^ot:isLeaf'] === true) ||
               // Use additional tests for badly-formed Nexson, where
               // a "knuckle" can appear as a non-leaf node with no children!)
               !(n.children) ||
               (n.children.length === 0)) {
                // capture the next available leaf position
                var leafPos = leafPositions.shift();
                n.x = leafPos.x;
                n.y = leafPos.y;

                extents.minX = Math.min(n.x, extents.minX);
                extents.minY = Math.min(n.y, extents.minY);
                extents.maxX = Math.max(n.x, extents.maxX);
                extents.maxY = Math.max(n.y, extents.maxY);
                extents.descendantLeafCount += 1;
            } else {
                var childExtents = distributeChildrenAsCladogram(n, leafPositions, depthStep);
                extents.minX = Math.min(n.x, childExtents.minX, extents.minX);
                extents.minY = Math.min(n.y, childExtents.minY, extents.minY);
                extents.maxX = Math.max(n.x, childExtents.maxX, extents.maxX);
                extents.maxY = Math.max(n.y, childExtents.maxY, extents.maxY);
                extents.descendantLeafCount += childExtents.descendantLeafCount;
            }
        });

        /* Position this node based on its depth and children's positions.
         * Note that we need to place it on the descent axis so that it
         * maintains (if possible) the proper angled edges for the
         * cladogram layout. This sometimes means we need to force
         * longer edges between this node and its children.
         */
        switch(tipsAlignment) {
            case 'TOP':
                node.y = Math.max(
                    extents.maxY - depthStep,  // one step closer to root
                    extents.minY - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // x should be midpoint of all descendants' x
                node.x = (extents.maxX + extents.minX) / 2.0;
                break;
            case 'BOTTOM':
                node.y = Math.min(
                    extents.minY - depthStep,  // one step closer to root
                    extents.maxY - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // x should be midpoint of all descendants' x
                node.x = (extents.maxX + extents.minX) / 2.0;
                break;
            case 'RIGHT':
                node.x = Math.min(
                    extents.minX - depthStep,  // one step closer to root
                    extents.maxX - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // y should be midpoint of all descendants' y
                node.y = (extents.maxY + extents.minY) / 2.0;
                break;
            case 'LEFT':
                node.x = Math.max(
                    extents.maxX - depthStep,  // one step closer to root
                    extents.minX - ((extents.descendantLeafCount - 1) * depthStep)
                );
                // y should be midpoint of all descendants' y
                node.y = (extents.maxY + extents.minY) / 2.0;
                break;
        }

        // update extents and return to parent
        extents.minX = Math.min(node.x, extents.minX);
        extents.minY = Math.min(node.y, extents.minY);
        extents.maxX = Math.max(node.x, extents.maxX);
        extents.maxY = Math.max(node.y, extents.maxY);

        return extents;
    }

    return phylogram(data);
}



/***** SCRAP AREA *****/

/*
  styleTreeNodes = function(vis) {

    vis.selectAll('g.node circle')
        .attr("r", 2.5);

    vis.selectAll('g.leaf.node circle')
        .attr("r", 4.5);
    
    vis.selectAll('g.root.node circle')
        .attr("r", 4.5);
  }
*/
  
  function scaleBranchLengths(nodes, w) {
    // Visit all nodes and adjust y pos width distance metric
    var visitPreOrder = function(root, callback) {
      callback(root)
      if (root.children) {
        for (var i = root.children.length - 1; i >= 0; i--){
          visitPreOrder(root.children[i], callback)
        };
      }
    }
    visitPreOrder(nodes[0], function(node) {
      // TODO: if we have mixed trees (some edges with lengths), consider 1
      // as default length versus 0?
      node.rootDist = (node.parent ? node.parent.rootDist : 0) + (node.length || 0)
    })
    var rootDists = nodes.map(function(n) { return n.rootDist; });
    var yscale = d3.scale.linear()
      .domain([0, d3.max(rootDists)])
      .range([0, w]);
    visitPreOrder(nodes[0], function(node) {
      node.y = yscale(node.rootDist)
    })
    return yscale
  }
  
  
  var buildCartesian = function(selector, nodes, options) {
    options = options || {}
    var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
        h = options.height || d3.select(selector).style('height') || d3.select(selector).attr('height'),
        w = parseInt(w),
        h = parseInt(h);
    var tree = options.tree || d3.layout.cluster()
      .size([h, w])
      .sort(function(node) { return node.children ? node.children.length : -1; })
    var diagonal = options.diagonal || rightAngleDiagonal();
    var vis = options.vis || d3.select(selector).append("svg:svg")
        .attr("width", w + 300)
        .attr("height", h + 30)
      .append("svg:g")
        .attr("transform", "translate(120, 20)");

    if (!options.vis) {
      // add any special filters (once only)
      d3.select(selector).selectAll('svg')
       .append('defs')
         .append("svg:filter")
           .attr("id", "highlight")
           .each(function(d) {
               // add multiple elements to this parent
               d3.select(this).append("svg:feFlood")
                 //.attr("flood-color", "#ffeedd")  // matches .help-box bg color!
                 .attr("flood-color", "#ffb265")    // darkened to allow tint
                 .attr("flood-opacity", "0.5")
                 .attr("result", "tint");
               d3.select(this).append("svg:feBlend")
                 .attr("mode", "multiply")
                 .attr("in", "SourceGraphic")
                 .attr("in2", "tint")
                 .attr("in3", "BackgroundImage");
               /* ALTERNATIVE SOLUTION, using feComposite
               d3.select(this).append("svg:feComposite")
                 .attr("in", "SourceGraphic");
                */
           });
    }

    var nodes = tree(nodes);
    
    if (options.skipBranchLengthScaling) {
      var yscale = d3.scale.linear()
        .domain([0, w])
        .range([0, w]);
    } else {
      var yscale = scaleBranchLengths(nodes, w)
    }
    
    if (!options.skipTicks) {
      var lines = vis.selectAll('line')
          .data(yscale.ticks(10));
      
      lines
        .enter().append('svg:line')
          .attr('y1', 0)
          .attr('y2', h)
          .attr('x1', yscale)
          .attr('x2', yscale)
          .attr("stroke", "#eee");

      lines
        .exit().remove();

      var text_rules = vis.selectAll("text.rule")
          .data(yscale.ticks(10));

      text_rules
        .enter().append("svg:text")
          .attr("class", "rule")
          .attr("x", yscale)
          .attr("y", 0)
          .attr("dy", -3)
          .attr("text-anchor", "middle")
          .attr('font-size', '8px')
          .attr('fill', '#ccc')
          .text(function(d) { return Math.round(d*100) / 100; });

      text_rules
        .exit().remove();
    }
        
    
    // DATA JOIN
    /* more interactions and styles on final marks
    var path_links = vis.selectAll("path.link")
        .data(tree.links(nodes), function(d) { return d.source['@id'] +'_'+ d.target['@id']; });

    var path_link_triggers = vis.selectAll("path.link-trigger")
        .data(tree.links(nodes), function(d) { return d.source['@id'] +'_'+ d.target['@id'] +'_trigger'; });

    var g_nodes = vis.selectAll("g.node")
        .data(nodes, function(d) { return d['@id']; });

    // UPDATE (only affects existing links)
    path_links
        .attr("stroke", "#aaa");
    
    path_link_triggers
        .attr("stroke", "orange");

    
    // ENTER (only affects new links; do one-time initialization here)
    path_links
      .enter()
          .append("svg:path")                   // styled (visible) edge
            .attr("class", "link")
            .attr("fill", "none")
            .attr("stroke", "#f33")
            .attr("stroke-width", "4px");
    
    path_link_triggers
      .enter()
          .append("svg:path")                   // "hit area" for clicking edge
            .attr("class", "link-trigger")
            .attr("fill", "none")
            .attr("stroke", "red")
            .attr("stroke-width", "4px")
            //.attr('pointer-events', 'all')

    g_nodes
      .enter()
        .append("svg:g")
          .append("svg:circle")
            .attr("r", 2.5)
            .attr('stroke', 'red')
            .attr('pointer-events', 'all')      // detect on invisible stuff
            .attr('stroke-opacity', '0.0')
            .attr('stroke-width', '8px');

    // ENTER + UPDATE (affects all new AND existing links)
    path_links
        .attr("d", diagonal)
        .attr("class", function(d) { return "link "+ (d.source.ingroup ? "ingroup" : "outgroup"); });
        
    path_link_triggers
        .attr("d", diagonal)
        .attr("class", function(d) { return "link-trigger "+ (d.source.ingroup ? "ingroup" : "outgroup"); });

    g_nodes
        .attr("class", function(n) {
          // N.B. These classes are overridden by study-editor.js!
          if (n.children) {
            if (n.depth == 0) {
              return "root node";
            } else {
              return "inner node";
            }
          } else {
            return "leaf node";
          }
        })
        .attr("id", function(d) { return ("nodebox-"+ d['@id']); })
        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

    // EXIT
    path_links
      .exit()
        .remove();

    path_link_triggers
      .exit()
        .remove();

    g_nodes
      .exit().remove();

    */
    // any dynamic readjustments of non-CSS attributes
    ///styleTreeNodes(vis);
    
    /* node labeling
    // TODO: why is this SUPER-SLOW with large trees? like MINUTES to run...
    // Is there a faster/cruder way to clear the decks?
    vis.selectAll('g.node text').remove();

    // provide an empty label as last resort, so we can see highlights
    var defaultNodeLabel = "unnamed";

    if (!options.skipLabels) {
      // refresh all labels based on tree position
      vis.selectAll('g.node')
        .append("svg:text")
          .attr('font-family', 'Helvetica Neue, Helvetica, sans-serif')
          .attr("dx", -6)
          .attr("dy", -6)
          .attr("text-anchor", 'end')
          .attr('font-size', '10px')
          .attr('fill', function(d) {
              switch(d.labelType) {
                  case ('mapped label'):
                      return '#000';
                  case ('node id'):
                      if (d.ambiguousLabel) {
                          return '#b94a48';  // show ambiguous labels, match red prompts
                      } else if (d.adjacentEdgeLabel) {
                          return '#888';
                      } else {
                          return '#888';
                      }
                  default:
                      return '#888';
              }
          })
          ///.text(function(d) { return d.length; });
          .attr('font-style', function(d) {
              return (d.labelType === 'mapped label' ? 'inherit' : 'italic');
          })
          .text(function(d) {
              // return (d.name + ' ('+d.length+')');
              var nodeLabel = '';
              if (d.labelType === 'node id') {
                  nodeLabel = '';  // hide these
              } else {
                  nodeLabel = d.name || defaultNodeLabel;
              }
              var supplementalLabel = d.ambiguousLabel || d.adjacentEdgeLabel;
              if (supplementalLabel) {
                  if (nodeLabel === '') {
                      nodeLabel = supplementalLabel;
                  } else {
                      nodeLabel = nodeLabel +" ["+ supplementalLabel +"]";
                  }
              }
              return nodeLabel;
          });

      vis.selectAll('g.root.node text')
          .attr("dx", -8)
          .attr("dy", 3);

      vis.selectAll('g.leaf.node text')
        .attr("dx", 8)
        .attr("dy", 3)
        .attr("text-anchor", "start");
    }
    
    */

    return {tree: tree, vis: vis}
  }
  
  var buildRadial = function(nodes, links, options) {
    options = options || {}
    /* set width, radius, space for edge labels
    var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
        r = w / 2,
        // NOTE the fudge factor here; longer labels will be clipped!
        labelWidth = options.skipLabels ? 10 : options.labelWidth || 120;
    */
    
    /* build SVG, set size and offet (center is 0,0)
    var vis = d3.select(selector).append("svg:svg")
        .attr("width", r * 2)
        .attr("height", r * 2)
      .append("svg:g")
        .attr("transform", "translate(" + r + "," + r + ")");
    */
        
    /* set space with x as polar coordinates (360 degrees), y = 1.0 */
    var tree = d3.layout.tree()  // TODO: use cluster here?
      .size([360, 500])   // WAS ([360, r - labelWidth])
      // sort populous to sparse branches
      .sort(function(node) { return node.children ? node.children.length : -1; })
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
    
    var phylogram = buildCartesian(selector, nodes, {
      vis: vis,
      tree: tree,
      skipBranchLengthScaling: true,
      skipTicks: true,
      skipLabels: options.skipLabels,
      diagonal: radialRightAngleDiagonal()
    })
    vis.selectAll('g.node')
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
    
    if (!options.skipLabels) {
      vis.selectAll('g.leaf.node text')
        .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
        .attr("dy", ".31em")
        .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
        .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
        .attr('font-family', 'Helvetica Neue, Helvetica, sans-serif')
        .attr('font-size', '10px')
        .attr('fill', 'black');

      vis.selectAll('g.inner.node text')
        .attr("dx", function(d) { return d.x < 180 ? -6 : 6; })
        .attr("text-anchor", function(d) { return d.x < 180 ? "end" : "start"; })
        .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; });
    }
    
    return {tree: tree, vis: vis}
  }

module.exports = Phylogram;

Phylogram.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Phylogram transform",
  "description": "Projects hierarchical data (presumably a tree) into one of several layouts "+
                 "and passes the results for downstream rendering.",
  "type": "object",
  "properties": {
    "type": {"enum": ["phylogram"]},
    "layout": {
      "description": "Should be 'radial', 'cladogram', or 'cartesian'.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "default": 'cartesian'
    },
    "width": {
      "description": "Width of overall phylogram, in chosen physical units", // TODO: CONFIRM
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 1.0
    },
    "height": {
      "description": "Height of overall phylogram, in chosen physical units", // TODO: CONFIRM
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 1.0
    },
    "radius": {
      "description": "Radius (from center to edge) of a radial layout, in arbitrary units.",
      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
      "default": 0.5
    },
    "radialArc": {
      "description": "Angles of arc [start, end] for a circular layout.",
      "oneOf": [
          {
            "type": "array",
            "items": {"type": "number"},
            "minItems": 2,
            "maxItems": 2
          },
          {"$ref": "#/refs/signal"}
      ],
      "default": [0, 350]
    },
    "radialSweep": {
      "description": "Direction of arc, CLOCKWISE or COUNTERCLOCKWISE.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["CLOCKWISE", "COUNTERCLOCKWISE"],
      "default": 'CLOCKWISE'
    },
    "tipsAlignment": {
      "description": "Which edge will show the labeled tips.",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["TOP", "RIGHT", "BOTTOM", "LEFT"],
      "default": 'right'
    },
    "branchStyle": {
      "description": "Override the layout's style (rarely used).",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
      "enum": ["rightAngleDiagonal", "radialRightAngleDiagonal",
               "straightLineDiagonal", "diagonal", "radial"],
      "default": ''
    },
    "branchLengths": {
      "description": "Map a data field to branch lengths (NOT YET IMPLEMENTED).",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],  // is this type "field"?
      "default": ''
    },
    "nodeLabelSource": {
      "description": "Look for tip labels in a data field.",
      "oneOf": [{"type": "XXXXXXXXXXX"}, {"$ref": "#/refs/signal"}],
      "enum": ["XXXXXXXXXXX", "XXXXXXXXXXX"],
      "default": ''
    },
    "showFallbackLabels": {
      "description": "If primary label is not found, show alternatives.",
      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
      "default": true
    },
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type"]  // TODO: review params!
};

},{"vega":187,"vega-logging":147,"vega/src/transforms/Transform":238}],253:[function(require,module,exports){
/* 
 * A simple transform to grab the named property from a JS object (not an
 * array). This makes it easier to deal with hierarchical data with 
 * multiple "inner" datasets (eg, nodes and edges) and complex upstream
 * transforms.
 *
 * EXAMPLE:
 *    "from": {
 *      "data": "phyloTree", 
 *      "transform": [
 *          {"type":"pluck", "field":"phyloNodes" }
 *      ] 
 *  },
 */
var vg  = require('vega'),
    log  = require('vega-logging'),
    assert = require('assert'),
    Transform = require('vega/src/transforms/Transform');

function Pluck(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      field: {type: 'field'}
  });
  // TODO: confirm that this is appropriate here
  return this.produces(true)
             .mutates(true);
}

var prototype = (Pluck.prototype = Object.create(Transform.prototype));
prototype.constructor = Pluck;

prototype.transform = function(input) {
  log.debug(input, ['plucking']);

  var g = this._graph,
      field = this.param('field');

  // For now, this transform ASSUMES just one incoming tuple, which will be
  // completely replaced by the plucked values.
  assert(input.add.length < 2, 
         "The pluck transform can only replace a single added datum.");
  var pluckedValues = field.accessor(input.add[0]); // returns plucked array
  // add _id properties? not clear if this is needed
  var nextAvailableID = 1000000;
  var assignUniqueID = function(obj) {
    if (!('_id' in obj)) {
      obj._id = ('_'+ ++nextAvailableID);
    }
  }
  pluckedValues.forEach(assignUniqueID);
  input.add = pluckedValues;    // replace the incoming tuple

  if (this.reevaluate(input)) {
    // Actually, we can also replace just one modified tuple, if found
    assert(input.mod.length < 2, 
           "The pluck transform can only replace a single modified datum.");
    pluckedValues = field.accessor(input.mod[0]);
    pluckedValues.forEach(assignUniqueID);
    input.mod = pluckedValues;
  }
  // return the modified ChangeSet
  return input;
};

module.exports = Pluck;

Pluck.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Pluck transform",
  "description": "Grabs a property (or deeper path) from a hierarchy.",
  "type": "object",
  "properties": {
    "type": {"enum": ["pluck"]},
    "field": {
      "description": "Which field of the data you want to select.",
      "oneOf": [{"type": "field"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    }
  },
  "additionalProperties": false,
  "required": ["type", "field"]
};

/*
vg.transforms.pluck = function() {

  var field = null;

  function pluck(data) {    
    var result = field(data);
    return result;
  }
  
  pluck.field = function(f) {
    field = vg.accessor(f);
    return pluck;
  };

  return pluck;
};
*/

},{"assert":1,"vega":187,"vega-logging":147,"vega/src/transforms/Transform":238}],254:[function(require,module,exports){
/* 
 * Store the incoming data (if it's not already found) using the specified
 * function and key, then pass it along unchanged.
 *
 * This is a "do-nothing" data transform to allow caching of intermediate results
 * from within a Vega pipeline (a series of transforms). The intent is to
 * support a much faster pipeline for frequently modified visualizations, as
 * used in the Tree Illustrator project:
 *   https://github.com/OpenTreeOfLife/tree-illustrator
 * 
 * Note that this transform doesn't concern itself with the details of the caching 
 * mechanism; it's assumed to be an existing key/value store, perhaps a simple
 * associative array or something smarter. Similarly, the host application is
 * responsible for defining idempotent keys for cached data.
 * 
 * Also, note that this doesn't *retrieve* cached data or speed things up on
 * its own! Instead, by feeding a cache it enables the host application to
 * construct a simpler pipeline by providing cached data instead of URLs,
 * omitting unneeded transforms, etc.
 */
var vg  = require('vega'),
    log  = require('vega-logging'),
    assert = require('assert'),
    dl = require('datalib'),
    Transform = require('vega/src/transforms/Transform');

function Stash(graph) {
  Transform.prototype.init.call(this, graph);
  Transform.addParameters(this, {
      cacheSetter: {type: 'value'},
      key: {type: 'value'},
      flush: {type: 'value', default: false}
  });

  return this;
  // TODO: add calls to mutates(), router()?
}

var prototype = (Stash.prototype = Object.create(Transform.prototype));
prototype.constructor = Stash;

prototype.transform = function(input) {
  log.debug(input, ['stashing']);

  var cacheSetter = this.param('cacheSetter'),
      setCacheItem = eval(cacheSetter),
      key = this.param('key'),
      flush = this.param('flush');

  if (!setCacheItem || (typeof setCacheItem !== 'function')) {
    // if an invalid cache setter is submitted, treat this as a no-op
    console.warn('stash transform: no callable/function found in eval('+ cacheSetter +')! skipping this data');
    return input;
  }

  // For now, this transform ASSUMES just one incoming tuple.
  assert(input.add.length > 0,
         "The stash transform expects an added datum (none found).");
  assert((input.add.length < 2 &&
          input.mod.length === 0 &&
          input.rem.length === 0),
         "The stash transform only stores a single added datum.");

  /* Stash a single incoming datum. Note that we actually store a *copy* of
   * the data, since Vega always clones data in a spec (see comment above).
   * Be sure to cache the "raw" data as returned from source!
   */
  var rawValue = dl.duplicate(input.add[0]);
  // N.B. dl.duplicate cleans up any weird methods and circular references
  setCacheItem( key, rawValue, flush);

/* OR should we stash all data piecemeal, based on state??
  // move new (and possibly changed) data to the cache
  function set(x) {
    //move one datum (tuple?) into the cache
    console.log("setting '"+ x +"'...");
    //Tuple.set(x, field, expr(x, null, signals));
  }
  input.add.forEach(set);
  if (this.reevaluate(input)) {
    input.mod.forEach(set);
  }
*/
  return input;
};

module.exports = Stash;

Stash.schema = {
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Stash transform",
  "description": "Stores the incoming data (if it's not already found) in the" +
    " specified object using the specified key, then passes it along unchanged.",
  "type": "object",
  "properties": {
    "type": {"enum": ["stash"]},
    "cacheSetter": {
      "description": "The (full, global) name of a cache's setter function",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]  // TODO: signal?
    },
    "key": {
      "description": "A unique key for this data in the stash",
      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
    },
    "flush": {
      "description": "If true, will replace any existing stashed data.",
      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
      "default": false
    }
  },
  "additionalProperties": false,  // TODO: confirm this
  "required": ["type", "key", "cacheSetter"]
};

},{"assert":1,"datalib":49,"vega":187,"vega-logging":147,"vega/src/transforms/Transform":238}]},{},[249])(249)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9ibG9iLXBvbHlmaWxsL0Jsb2IuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kc3YvYnVpbGQvZHN2LmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2FnZ3JlZ2F0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2NvbGxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9hZ2dyZWdhdGUvZ3JvdXBieS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9hZ2dyZWdhdGUvbWVhc3VyZXMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYmlucy9iaW5zLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvaGlzdG9ncmFtLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90aW1lLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9maWxlLXNhdmVyL0ZpbGVTYXZlci5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRhYmxlLXN0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9saWUvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9DaGFuZ2VTZXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvQ29sbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0RhdGFTb3VyY2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvRGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0dyYXBoLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0hlYXAuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9TaWduYWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvVHVwbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9jb2RlZ2VuLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1sb2dnaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9wYXRoL2FyYy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3BhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9wYXRoL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcGF0aC9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvQ2FudmFzSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9hcmMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL2FyZWEuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL2dyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9pbWFnZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL2xpbmUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL3BhdGguanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL3JlY3QuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL3J1bGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvY2FudmFzL21hcmtzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9jYW52YXMvbWFya3MvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9zdmcvU1ZHSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9zdmcvU1ZHUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy9yZW5kZXIvc3ZnL1NWR1N0cmluZ1JlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvcmVuZGVyL3N2Zy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3JlbmRlci9zdmcvbWFya3MuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL0JvdW5kcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvQm91bmRzQ29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvR3JhZGllbnQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL0ltYWdlTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9JdGVtLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9ib3VuZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvc3JjL3V0aWwvY2FudmFzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9kb20uanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL3NjZW5lLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9zcmMvdXRpbC9zdmcuanMiLCJub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL3NyYy91dGlsL3RleHQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9jb3JlL0hlYWRsZXNzVmlldy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9jb3JlL01vZGVsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL2NvcmUvVmlldy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9jb3JlL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9jb3JlL3NjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9heGVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL2JhY2tncm91bmQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvZXhwci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9sZWdlbmRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL21hcmsuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvbWFya3MuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvbW9kaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL3BhZGRpbmcuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvcHJlZGljYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL3NpZ25hbHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2Uvc3BlYy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9wYXJzZS9zdHJlYW1zLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3BhcnNlL3RyYW5zZm9ybXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvQm91bmRlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS9CdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3NjZW5lL0VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvR3JvdXBCdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3NjZW5lL1NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3NjZW5lL1RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvYXhpcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy9zY2VuZS9sZWdlbmQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvc2NlbmUvdmlzaXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9BZ2dyZWdhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9CYXRjaFRyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0Jpbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0NvdW50UGF0dGVybi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0Nyb3NzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvRmFjZXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9GYWNldG9yLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvRm9sZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0ZvcmNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvRm9ybXVsYS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0dlby5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0dlb1BhdGguanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9MaW5rUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1BhcmFtZXRlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1BpZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1NvcnQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL1RyZWVtYXAuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9Wb3Jvbm9pLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvV29yZGNsb3VkLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evc3JjL3RyYW5zZm9ybXMvaW5kZXguanMiLCJzcmMvVHJlZUlsbHVzdHJhdG9yLmpzIiwic3JjL2pxdWVyeS0xLjguMy5qcyIsInNyYy9zcGFyay1tZDUuanMiLCJzcmMvc3RvcmFnZS9pcHl0aG9uLW5vdGVib29rLWJyaWRnZS5qcyIsInNyYy9zdG9yYWdlL2xvY2FsLWZpbGVzeXN0ZW0uanMiLCJzcmMvc3RvcmFnZS9uYW1lc3BhY2VkLXVybHMuanMiLCJzcmMvc3R5bGlzdC5qcyIsInNyYy90aS11dGlscy5qcyIsInNyYy92Zy5kYXRhLm5leHNvbi5qcyIsInNyYy92Zy5kYXRhLnBoeWxvZ3JhbS5qcyIsInNyYy92Zy5kYXRhLnBsdWNrLmpzIiwic3JjL3ZnLmRhdGEuc3Rhc2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4Z0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Z0JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0eEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzloQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMW1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5dUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3o1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCIvKiBCbG9iLmpzXG4gKiBBIEJsb2IgaW1wbGVtZW50YXRpb24uXG4gKiAyMDE0LTA3LTI0XG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogQnkgRGV2aW4gU2FtYXJpbiwgaHR0cHM6Ly9naXRodWIuY29tL2RzYW1hcmluXG4gKiBMaWNlbnNlOiBYMTEvTUlUXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9CbG9iLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmLCB1bmVzY2FwZSAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBjb25mdXNpb246IHRydWUsIGVzNTogdHJ1ZSwgdmFyczogdHJ1ZSwgd2hpdGU6IHRydWUsXG4gIHBsdXNwbHVzOiB0cnVlICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9CbG9iLmpzL2Jsb2IvbWFzdGVyL0Jsb2IuanMgKi9cblxuKGZ1bmN0aW9uICh2aWV3KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZpZXcuVVJMID0gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkw7XG5cblx0aWYgKHZpZXcuQmxvYiAmJiB2aWV3LlVSTCkge1xuXHRcdHRyeSB7XG5cdFx0XHRuZXcgQmxvYjtcblx0XHRcdHJldHVybjtcblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0Ly8gSW50ZXJuYWxseSB3ZSB1c2UgYSBCbG9iQnVpbGRlciBpbXBsZW1lbnRhdGlvbiB0byBiYXNlIEJsb2Igb2ZmIG9mXG5cdC8vIGluIG9yZGVyIHRvIHN1cHBvcnQgb2xkZXIgYnJvd3NlcnMgdGhhdCBvbmx5IGhhdmUgQmxvYkJ1aWxkZXJcblx0dmFyIEJsb2JCdWlsZGVyID0gdmlldy5CbG9iQnVpbGRlciB8fCB2aWV3LldlYktpdEJsb2JCdWlsZGVyIHx8IHZpZXcuTW96QmxvYkJ1aWxkZXIgfHwgKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHR2YXJcblx0XHRcdCAgZ2V0X2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXlxcW29iamVjdFxccyguKilcXF0kLylbMV07XG5cdFx0XHR9XG5cdFx0XHQsIEZha2VCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIEJsb2JCdWlsZGVyKCkge1xuXHRcdFx0XHR0aGlzLmRhdGEgPSBbXTtcblx0XHRcdH1cblx0XHRcdCwgRmFrZUJsb2IgPSBmdW5jdGlvbiBCbG9iKGRhdGEsIHR5cGUsIGVuY29kaW5nKSB7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuc2l6ZSA9IGRhdGEubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0XHR0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG5cdFx0XHR9XG5cdFx0XHQsIEZCQl9wcm90byA9IEZha2VCbG9iQnVpbGRlci5wcm90b3R5cGVcblx0XHRcdCwgRkJfcHJvdG8gPSBGYWtlQmxvYi5wcm90b3R5cGVcblx0XHRcdCwgRmlsZVJlYWRlclN5bmMgPSB2aWV3LkZpbGVSZWFkZXJTeW5jXG5cdFx0XHQsIEZpbGVFeGNlcHRpb24gPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHRoaXMuY29kZSA9IHRoaXNbdGhpcy5uYW1lID0gdHlwZV07XG5cdFx0XHR9XG5cdFx0XHQsIGZpbGVfZXhfY29kZXMgPSAoXG5cdFx0XHRcdCAgXCJOT1RfRk9VTkRfRVJSIFNFQ1VSSVRZX0VSUiBBQk9SVF9FUlIgTk9UX1JFQURBQkxFX0VSUiBFTkNPRElOR19FUlIgXCJcblx0XHRcdFx0KyBcIk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiBJTlZBTElEX1NUQVRFX0VSUiBTWU5UQVhfRVJSXCJcblx0XHRcdCkuc3BsaXQoXCIgXCIpXG5cdFx0XHQsIGZpbGVfZXhfY29kZSA9IGZpbGVfZXhfY29kZXMubGVuZ3RoXG5cdFx0XHQsIHJlYWxfVVJMID0gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkwgfHwgdmlld1xuXHRcdFx0LCByZWFsX2NyZWF0ZV9vYmplY3RfVVJMID0gcmVhbF9VUkwuY3JlYXRlT2JqZWN0VVJMXG5cdFx0XHQsIHJlYWxfcmV2b2tlX29iamVjdF9VUkwgPSByZWFsX1VSTC5yZXZva2VPYmplY3RVUkxcblx0XHRcdCwgVVJMID0gcmVhbF9VUkxcblx0XHRcdCwgYnRvYSA9IHZpZXcuYnRvYVxuXHRcdFx0LCBhdG9iID0gdmlldy5hdG9iXG5cblx0XHRcdCwgQXJyYXlCdWZmZXIgPSB2aWV3LkFycmF5QnVmZmVyXG5cdFx0XHQsIFVpbnQ4QXJyYXkgPSB2aWV3LlVpbnQ4QXJyYXlcblxuXHRcdFx0LCBvcmlnaW4gPSAvXltcXHctXSs6XFwvKlxcWz9bXFx3XFwuOi1dK1xcXT8oPzo6WzAtOV0rKT8vXG5cdFx0O1xuXHRcdEZha2VCbG9iLmZha2UgPSBGQl9wcm90by5mYWtlID0gdHJ1ZTtcblx0XHR3aGlsZSAoZmlsZV9leF9jb2RlLS0pIHtcblx0XHRcdEZpbGVFeGNlcHRpb24ucHJvdG90eXBlW2ZpbGVfZXhfY29kZXNbZmlsZV9leF9jb2RlXV0gPSBmaWxlX2V4X2NvZGUgKyAxO1xuXHRcdH1cblx0XHQvLyBQb2x5ZmlsbCBVUkxcblx0XHRpZiAoIXJlYWxfVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xuXHRcdFx0VVJMID0gdmlldy5VUkwgPSBmdW5jdGlvbih1cmkpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICB1cmlfaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG5cdFx0XHRcdFx0LCB1cmlfb3JpZ2luXG5cdFx0XHRcdDtcblx0XHRcdFx0dXJpX2luZm8uaHJlZiA9IHVyaTtcblx0XHRcdFx0aWYgKCEoXCJvcmlnaW5cIiBpbiB1cmlfaW5mbykpIHtcblx0XHRcdFx0XHRpZiAodXJpX2luZm8ucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiKSB7XG5cdFx0XHRcdFx0XHR1cmlfaW5mby5vcmlnaW4gPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR1cmlfb3JpZ2luID0gdXJpLm1hdGNoKG9yaWdpbik7XG5cdFx0XHRcdFx0XHR1cmlfaW5mby5vcmlnaW4gPSB1cmlfb3JpZ2luICYmIHVyaV9vcmlnaW5bMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB1cmlfaW5mbztcblx0XHRcdH07XG5cdFx0fVxuXHRcdFVSTC5jcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0ICB0eXBlID0gYmxvYi50eXBlXG5cdFx0XHRcdCwgZGF0YV9VUklfaGVhZGVyXG5cdFx0XHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcblx0XHRcdH1cblx0XHRcdGlmIChibG9iIGluc3RhbmNlb2YgRmFrZUJsb2IpIHtcblx0XHRcdFx0ZGF0YV9VUklfaGVhZGVyID0gXCJkYXRhOlwiICsgdHlwZTtcblx0XHRcdFx0aWYgKGJsb2IuZW5jb2RpbmcgPT09IFwiYmFzZTY0XCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YV9VUklfaGVhZGVyICsgXCI7YmFzZTY0LFwiICsgYmxvYi5kYXRhO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGJsb2IuZW5jb2RpbmcgPT09IFwiVVJJXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YV9VUklfaGVhZGVyICsgXCIsXCIgKyBkZWNvZGVVUklDb21wb25lbnQoYmxvYi5kYXRhKTtcblx0XHRcdFx0fSBpZiAoYnRvYSkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhX1VSSV9oZWFkZXIgKyBcIjtiYXNlNjQsXCIgKyBidG9hKGJsb2IuZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFfVVJJX2hlYWRlciArIFwiLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGJsb2IuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocmVhbF9jcmVhdGVfb2JqZWN0X1VSTCkge1xuXHRcdFx0XHRyZXR1cm4gcmVhbF9jcmVhdGVfb2JqZWN0X1VSTC5jYWxsKHJlYWxfVVJMLCBibG9iKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwgPSBmdW5jdGlvbihvYmplY3RfVVJMKSB7XG5cdFx0XHRpZiAob2JqZWN0X1VSTC5zdWJzdHJpbmcoMCwgNSkgIT09IFwiZGF0YTpcIiAmJiByZWFsX3Jldm9rZV9vYmplY3RfVVJMKSB7XG5cdFx0XHRcdHJlYWxfcmV2b2tlX29iamVjdF9VUkwuY2FsbChyZWFsX1VSTCwgb2JqZWN0X1VSTCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRGQkJfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24oZGF0YS8qLCBlbmRpbmdzKi8pIHtcblx0XHRcdHZhciBiYiA9IHRoaXMuZGF0YTtcblx0XHRcdC8vIGRlY29kZSBkYXRhIHRvIGEgYmluYXJ5IHN0cmluZ1xuXHRcdFx0aWYgKFVpbnQ4QXJyYXkgJiYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICBzdHIgPSBcIlwiXG5cdFx0XHRcdFx0LCBidWYgPSBuZXcgVWludDhBcnJheShkYXRhKVxuXHRcdFx0XHRcdCwgaSA9IDBcblx0XHRcdFx0XHQsIGJ1Zl9sZW4gPSBidWYubGVuZ3RoXG5cdFx0XHRcdDtcblx0XHRcdFx0Zm9yICg7IGkgPCBidWZfbGVuOyBpKyspIHtcblx0XHRcdFx0XHRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJiLnB1c2goc3RyKTtcblx0XHRcdH0gZWxzZSBpZiAoZ2V0X2NsYXNzKGRhdGEpID09PSBcIkJsb2JcIiB8fCBnZXRfY2xhc3MoZGF0YSkgPT09IFwiRmlsZVwiKSB7XG5cdFx0XHRcdGlmIChGaWxlUmVhZGVyU3luYykge1xuXHRcdFx0XHRcdHZhciBmciA9IG5ldyBGaWxlUmVhZGVyU3luYztcblx0XHRcdFx0XHRiYi5wdXNoKGZyLnJlYWRBc0JpbmFyeVN0cmluZyhkYXRhKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYXN5bmMgRmlsZVJlYWRlciB3b24ndCB3b3JrIGFzIEJsb2JCdWlsZGVyIGlzIHN5bmNcblx0XHRcdFx0XHR0aHJvdyBuZXcgRmlsZUV4Y2VwdGlvbihcIk5PVF9SRUFEQUJMRV9FUlJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZha2VCbG9iKSB7XG5cdFx0XHRcdGlmIChkYXRhLmVuY29kaW5nID09PSBcImJhc2U2NFwiICYmIGF0b2IpIHtcblx0XHRcdFx0XHRiYi5wdXNoKGF0b2IoZGF0YS5kYXRhKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5lbmNvZGluZyA9PT0gXCJVUklcIikge1xuXHRcdFx0XHRcdGJiLnB1c2goZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEuZGF0YSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEuZW5jb2RpbmcgPT09IFwicmF3XCIpIHtcblx0XHRcdFx0XHRiYi5wdXNoKGRhdGEuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdGRhdGEgKz0gXCJcIjsgLy8gY29udmVydCB1bnN1cHBvcnRlZCB0eXBlcyB0byBzdHJpbmdzXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZGVjb2RlIFVURi0xNiB0byBiaW5hcnkgc3RyaW5nXG5cdFx0XHRcdGJiLnB1c2godW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRGQkJfcHJvdG8uZ2V0QmxvYiA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR0eXBlID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgRmFrZUJsb2IodGhpcy5kYXRhLmpvaW4oXCJcIiksIHR5cGUsIFwicmF3XCIpO1xuXHRcdH07XG5cdFx0RkJCX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXCJbb2JqZWN0IEJsb2JCdWlsZGVyXVwiO1xuXHRcdH07XG5cdFx0RkJfcHJvdG8uc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0eXBlKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRpZiAoYXJncyA8IDMpIHtcblx0XHRcdFx0dHlwZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IEZha2VCbG9iKFxuXHRcdFx0XHQgIHRoaXMuZGF0YS5zbGljZShzdGFydCwgYXJncyA+IDEgPyBlbmQgOiB0aGlzLmRhdGEubGVuZ3RoKVxuXHRcdFx0XHQsIHR5cGVcblx0XHRcdFx0LCB0aGlzLmVuY29kaW5nXG5cdFx0XHQpO1xuXHRcdH07XG5cdFx0RkJfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBcIltvYmplY3QgQmxvYl1cIjtcblx0XHR9O1xuXHRcdEZCX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNpemUgPSAwO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZGF0YTtcblx0XHR9O1xuXHRcdHJldHVybiBGYWtlQmxvYkJ1aWxkZXI7XG5cdH0odmlldykpO1xuXG5cdHZpZXcuQmxvYiA9IGZ1bmN0aW9uKGJsb2JQYXJ0cywgb3B0aW9ucykge1xuXHRcdHZhciB0eXBlID0gb3B0aW9ucyA/IChvcHRpb25zLnR5cGUgfHwgXCJcIikgOiBcIlwiO1xuXHRcdHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdFx0aWYgKGJsb2JQYXJ0cykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGJsb2JQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoVWludDhBcnJheSAmJiBibG9iUGFydHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0XHRcdFx0YnVpbGRlci5hcHBlbmQoYmxvYlBhcnRzW2ldLmJ1ZmZlcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YnVpbGRlci5hcHBlbmQoYmxvYlBhcnRzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgYmxvYiA9IGJ1aWxkZXIuZ2V0QmxvYih0eXBlKTtcblx0XHRpZiAoIWJsb2Iuc2xpY2UgJiYgYmxvYi53ZWJraXRTbGljZSkge1xuXHRcdFx0YmxvYi5zbGljZSA9IGJsb2Iud2Via2l0U2xpY2U7XG5cdFx0fVxuXHRcdHJldHVybiBibG9iO1xuXHR9O1xuXG5cdHZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihvYmplY3QpIHtcblx0XHRyZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXztcblx0fTtcblx0dmlldy5CbG9iLnByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKG5ldyB2aWV3LkJsb2IoKSk7XG59KHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdGhpcy5jb250ZW50IHx8IHRoaXMpKTtcbiIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5zZXRJbW1lZGlhdGU7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjMuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pOyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdGFzayAgID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5kc3YgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICAgIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLFxuICAgICAgICBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgIGlmIChvKSByZXR1cm4gbyhyb3csIGkgLSAxKTtcbiAgICAgICAgdmFyIGEgPSBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIHJvdy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbiAgICAgICAgbyA9IGYgPyBmdW5jdGlvbihyb3csIGkpIHsgcmV0dXJuIGYoYShyb3cpLCBpKTsgfSA6IGE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCAvLyBzZW50aW5lbCB2YWx1ZSBmb3IgZW5kLW9mLWxpbmVcbiAgICAgICAgICBFT0YgPSB7fSwgLy8gc2VudGluZWwgdmFsdWUgZm9yIGVuZC1vZi1maWxlXG4gICAgICAgICAgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgICBuID0gMCwgLy8gdGhlIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgICB0LCAvLyB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgIGVvbDsgLy8gaXMgdGhlIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgaWYgKEkgPj0gTikgcmV0dXJuIEVPRjsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgZmlsZVxuICAgICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgbGluZVxuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogcXVvdGVzXG4gICAgICAgIHZhciBqID0gSTtcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gMzQpIHtcbiAgICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgICAgd2hpbGUgKGkrKyA8IE4pIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDM0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSSA9IGkgKyAyO1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSA9PT0gMTApICsrSTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDEwKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tb24gY2FzZTogZmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lXG4gICAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KEkrKyksIGsgPSAxO1xuICAgICAgICAgIGlmIChjID09PSAxMCkgZW9sID0gdHJ1ZTsgLy8gXFxuXG4gICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMTMpIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gMTApICsrSSwgKytrOyB9IC8vIFxccnxcXHJcXG5cbiAgICAgICAgICBlbHNlIGlmIChjICE9PSBkZWxpbWl0ZXJDb2RlKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBJIC0gayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGxhc3QgdG9rZW4gYmVmb3JlIEVPRlxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikge1xuICAgICAgICAgIGEucHVzaCh0KTtcbiAgICAgICAgICB0ID0gdG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAmJiAoYSA9IGYoYSwgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIHJvd3MucHVzaChhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHJvd3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3NbMF0pKSByZXR1cm4gZm9ybWF0Um93cyhyb3dzKTsgLy8gZGVwcmVjYXRlZDsgdXNlIGZvcm1hdFJvd3NcbiAgICAgIHZhciBmaWVsZFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksIGZpZWxkcyA9IFtdO1xuXG4gICAgICAvLyBDb21wdXRlIHVuaXF1ZSBmaWVsZHMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiByb3cpIHtcbiAgICAgICAgICBpZiAoISgoZmllbGQgKz0gXCJcIikgaW4gZmllbGRTZXQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldFtmaWVsZF0gPSBmaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFtmaWVsZHMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2ZpZWxkXSk7XG4gICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICAgIHJldHVybiByZUZvcm1hdC50ZXN0KHRleHQpID8gXCJcXFwiXCIgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiIDogdGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3NcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5jc3YgPSBkc3YoXCIsXCIpO1xuICBleHBvcnRzLnRzdiA9IGRzdihcIlxcdFwiKTtcblxuICBleHBvcnRzLmRzdiA9IGRzdjtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmZvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgemhDbiA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIsKlXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIHJ1UnUgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDRgNGD0LEuXCJdXG4gIH07XG5cbiAgdmFyIHB0QnIgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJSJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBwbFBsID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiesWCXCJdXG4gIH07XG5cbiAgdmFyIG5sTmwgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqxcXHhhMFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBta01rID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDQtNC10L0uXCJdXG4gIH07XG5cbiAgdmFyIGphSnAgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCLlhoZcIl1cbiAgfTtcblxuICB2YXIgaXRJdCA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCrFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBoZUlsID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wi4oKqXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGZyRnIgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBmckNhID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIiRcIl1cbiAgfTtcblxuICB2YXIgZmlGaSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBlc0VzID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuICB2YXIgZW5VcyA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZW5HYiA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIsKjXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGVuQ2EgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGRlRGUgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBjYUVzID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuXG4gIC8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbiAgLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4gIC8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuICBmdW5jdGlvbiBmb3JtYXREZWNpbWFsKHgsIHApIHtcbiAgICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gICAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAgIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gICAgcmV0dXJuIFtcbiAgICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgICAreC5zbGljZShpICsgMSlcbiAgICBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICAgIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xuICB9XG5cbiAgdmFyIHByZWZpeEV4cG9uZW50O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBwICsgaSAtIDEpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICAgIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0KHgsIHApIHtcbiAgICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICAgIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN3aXRjaCAoeFtpXSkge1xuICAgICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiBicmVhayBvdXQ7XG4gICAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlcyA9IHtcbiAgICBcIlwiOiBmb3JtYXREZWZhdWx0LFxuICAgIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgICBcImNcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4geCArIFwiXCI7IH0sXG4gICAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICAgIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gICAgXCJmXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9GaXhlZChwKTsgfSxcbiAgICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgICBcInBcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKTsgfSxcbiAgICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgICBcIlhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSxcbiAgICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbiAgfTtcblxuXG4gIC8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bdHlwZV1cbiAgdmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyhbYS16JV0pPyQvaTtcblxuICBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG5cbiAgICB2YXIgbWF0Y2gsXG4gICAgICAgIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIixcbiAgICAgICAgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIixcbiAgICAgICAgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLFxuICAgICAgICBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLFxuICAgICAgICB6ZXJvID0gISFtYXRjaFs1XSxcbiAgICAgICAgd2lkdGggPSBtYXRjaFs2XSAmJiArbWF0Y2hbNl0sXG4gICAgICAgIGNvbW1hID0gISFtYXRjaFs3XSxcbiAgICAgICAgcHJlY2lzaW9uID0gbWF0Y2hbOF0gJiYgK21hdGNoWzhdLnNsaWNlKDEpLFxuICAgICAgICB0eXBlID0gbWF0Y2hbOV0gfHwgXCJcIjtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIE1hcCBpbnZhbGlkIHR5cGVzIHRvIHRoZSBkZWZhdWx0IGZvcm1hdC5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHR5cGUgPSBcIlwiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnNpZ24gPSBzaWduO1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuemVybyA9IHplcm87XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY29tbWEgPSBjb21tYTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICAgKyB0aGlzLmFsaWduXG4gICAgICAgICsgdGhpcy5zaWduXG4gICAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLndpZHRoID09IG51bGwgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLnByZWNpc2lvbiA9PSBudWxsID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICAgKyB0aGlzLnR5cGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHQgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSxcbiAgICAgICAgY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksXG4gICAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbDtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdChzcGVjaWZpZXIpIHtcbiAgICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMF0gOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzFdIDogL1slcF0vLnRlc3QodHlwZSkgPyBcIiVcIiA6IFwiXCI7XG5cbiAgICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICAgIG1heWJlU3VmZml4ID0gIXR5cGUgfHwgL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/ICh0eXBlID8gNiA6IDEyKVxuICAgICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXg7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbmVnYXRpdmUgdG8gcG9zaXRpdmUsIGFuZCBjb21wdXRlIHRoZSBwcmVmaXguXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9ICh2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMCkgJiYgKHZhbHVlICo9IC0xLCB0cnVlKTtcblxuICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSB2YWx1ZVN1ZmZpeCArICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aCwgYztcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZztcbiAgICAgICAgICBjYXNlIFwiPVwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICBjYXNlIFwiXlwiOiByZXR1cm4gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICAgIHZhciBmID0gZm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KE1hdGguYWJzKG1heCkpIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uRml4ZWQoc3RlcCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVEZWZpbml0aW9ucyA9IHtcbiAgICBcImNhLUVTXCI6IGNhRXMsXG4gICAgXCJkZS1ERVwiOiBkZURlLFxuICAgIFwiZW4tQ0FcIjogZW5DYSxcbiAgICBcImVuLUdCXCI6IGVuR2IsXG4gICAgXCJlbi1VU1wiOiBlblVzLFxuICAgIFwiZXMtRVNcIjogZXNFcyxcbiAgICBcImZpLUZJXCI6IGZpRmksXG4gICAgXCJmci1DQVwiOiBmckNhLFxuICAgIFwiZnItRlJcIjogZnJGcixcbiAgICBcImhlLUlMXCI6IGhlSWwsXG4gICAgXCJpdC1JVFwiOiBpdEl0LFxuICAgIFwiamEtSlBcIjogamFKcCxcbiAgICBcIm1rLU1LXCI6IG1rTWssXG4gICAgXCJubC1OTFwiOiBubE5sLFxuICAgIFwicGwtUExcIjogcGxQbCxcbiAgICBcInB0LUJSXCI6IHB0QnIsXG4gICAgXCJydS1SVVwiOiBydVJ1LFxuICAgIFwiemgtQ05cIjogemhDblxuICB9O1xuXG4gIHZhciBkZWZhdWx0TG9jYWxlID0gbG9jYWxlKGVuVXMpO1xuICBleHBvcnRzLmZvcm1hdCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0UHJlZml4O1xuXG4gIGZ1bmN0aW9uIGxvY2FsZUZvcm1hdChkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIWxvY2FsZURlZmluaXRpb25zLmhhc093blByb3BlcnR5KGRlZmluaXRpb24pKSByZXR1cm4gbnVsbDtcbiAgICAgIGRlZmluaXRpb24gPSBsb2NhbGVEZWZpbml0aW9uc1tkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZShkZWZpbml0aW9uKTtcbiAgfVxuICA7XG5cbiAgZXhwb3J0cy5sb2NhbGVGb3JtYXQgPSBsb2NhbGVGb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuICBleHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG4gIGV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuICBleHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lRm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB6aENuID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS8lLW0vJS1kXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIuS4iuWNiFwiLCBcIuS4i+WNiFwiXSxcbiAgICBkYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgc2hvcnREYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgbW9udGhzOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXVxuICB9O1xuXG4gIHZhciBydVJ1ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi0LLQvtGB0LrRgNC10YHQtdC90YzQtVwiLCBcItC/0L7QvdC10LTQtdC70YzQvdC40LpcIiwgXCLQstGC0L7RgNC90LjQulwiLCBcItGB0YDQtdC00LBcIiwgXCLRh9C10YLQstC10YDQs1wiLCBcItC/0Y/RgtC90LjRhtCwXCIsIFwi0YHRg9Cx0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQstGBXCIsIFwi0L/QvVwiLCBcItCy0YJcIiwgXCLRgdGAXCIsIFwi0YfRglwiLCBcItC/0YJcIiwgXCLRgdCxXCJdLFxuICAgIG1vbnRoczogW1wi0Y/QvdCy0LDRgNGPXCIsIFwi0YTQtdCy0YDQsNC70Y9cIiwgXCLQvNCw0YDRgtCwXCIsIFwi0LDQv9GA0LXQu9GPXCIsIFwi0LzQsNGPXCIsIFwi0LjRjtC90Y9cIiwgXCLQuNGO0LvRj1wiLCBcItCw0LLQs9GD0YHRgtCwXCIsIFwi0YHQtdC90YLRj9Cx0YDRj1wiLCBcItC+0LrRgtGP0LHRgNGPXCIsIFwi0L3QvtGP0LHRgNGPXCIsIFwi0LTQtdC60LDQsdGA0Y9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcItGP0L3QslwiLCBcItGE0LXQslwiLCBcItC80LDRgFwiLCBcItCw0L/RgFwiLCBcItC80LDQuVwiLCBcItC40Y7QvVwiLCBcItC40Y7Qu1wiLCBcItCw0LLQs1wiLCBcItGB0LXQvVwiLCBcItC+0LrRglwiLCBcItC90L7Rj1wiLCBcItC00LXQulwiXVxuICB9O1xuXG4gIHZhciBwdEJyID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWS4gJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiRG9taW5nb1wiLCBcIlNlZ3VuZGFcIiwgXCJUZXLDp2FcIiwgXCJRdWFydGFcIiwgXCJRdWludGFcIiwgXCJTZXh0YVwiLCBcIlPDoWJhZG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJEb21cIiwgXCJTZWdcIiwgXCJUZXJcIiwgXCJRdWFcIiwgXCJRdWlcIiwgXCJTZXhcIiwgXCJTw6FiXCJdLFxuICAgIG1vbnRoczogW1wiSmFuZWlyb1wiLCBcIkZldmVyZWlyb1wiLCBcIk1hcsOnb1wiLCBcIkFicmlsXCIsIFwiTWFpb1wiLCBcIkp1bmhvXCIsIFwiSnVsaG9cIiwgXCJBZ29zdG9cIiwgXCJTZXRlbWJyb1wiLCBcIk91dHVicm9cIiwgXCJOb3ZlbWJyb1wiLCBcIkRlemVtYnJvXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZXZcIiwgXCJNYXJcIiwgXCJBYnJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdXRcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfTtcblxuICB2YXIgcGxQbCA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJOaWVkemllbGFcIiwgXCJQb25pZWR6aWHFgmVrXCIsIFwiV3RvcmVrXCIsIFwixZpyb2RhXCIsIFwiQ3p3YXJ0ZWtcIiwgXCJQacSFdGVrXCIsIFwiU29ib3RhXCJdLFxuICAgIHNob3J0RGF5czogW1wiTmllZHouXCIsIFwiUG9uLlwiLCBcIld0LlwiLCBcIsWaci5cIiwgXCJDencuXCIsIFwiUHQuXCIsIFwiU29iLlwiXSxcbiAgICBtb250aHM6IFtcIlN0eWN6ZcWEXCIsIFwiTHV0eVwiLCBcIk1hcnplY1wiLCBcIkt3aWVjaWXFhFwiLCBcIk1halwiLCBcIkN6ZXJ3aWVjXCIsIFwiTGlwaWVjXCIsIFwiU2llcnBpZcWEXCIsIFwiV3J6ZXNpZcWEXCIsIFwiUGHFumR6aWVybmlrXCIsIFwiTGlzdG9wYWRcIiwgXCJHcnVkemllxYRcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIlN0eWN6LlwiLCBcIkx1dHlcIiwgXCJNYXJ6LlwiLCBcIkt3aWUuXCIsIFwiTWFqXCIsIFwiQ3plcncuXCIsIFwiTGlwYy5cIiwgXCJTaWVycC5cIiwgXCJXcnouXCIsIFwiUGHFumR6LlwiLCBcIkxpc3RvcC5cIiwgXCJHcnVkei5cIl0vKiBJbiBQb2xpc2ggbGFuZ3VhZ2UgYWJicmF2aWF0ZWQgbW9udGhzIGFyZSBub3QgY29tbW9ubHkgdXNlZCBzbyB0aGVyZSBpcyBhIGRpc3B1dGUgYWJvdXQgdGhlIHByb3BlciBhYmJyYXZpYXRpb25zLiAqL1xuICB9O1xuXG4gIHZhciBubE5sID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICVCICVZICVUXCIsXG4gICAgZGF0ZTogXCIlZC0lbS0lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJ6b25kYWdcIiwgXCJtYWFuZGFnXCIsIFwiZGluc2RhZ1wiLCBcIndvZW5zZGFnXCIsIFwiZG9uZGVyZGFnXCIsIFwidnJpamRhZ1wiLCBcInphdGVyZGFnXCJdLFxuICAgIHNob3J0RGF5czogW1wiem9cIiwgXCJtYVwiLCBcImRpXCIsIFwid29cIiwgXCJkb1wiLCBcInZyXCIsIFwiemFcIl0sXG4gICAgbW9udGhzOiBbXCJqYW51YXJpXCIsIFwiZmVicnVhcmlcIiwgXCJtYWFydFwiLCBcImFwcmlsXCIsIFwibWVpXCIsIFwianVuaVwiLCBcImp1bGlcIiwgXCJhdWd1c3R1c1wiLCBcInNlcHRlbWJlclwiLCBcIm9rdG9iZXJcIiwgXCJub3ZlbWJlclwiLCBcImRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmZWJcIiwgXCJtcnRcIiwgXCJhcHJcIiwgXCJtZWlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhdWdcIiwgXCJzZXBcIiwgXCJva3RcIiwgXCJub3ZcIiwgXCJkZWNcIl1cbiAgfTtcblxuICB2YXIgbWtNayA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItC90LXQtNC10LvQsFwiLCBcItC/0L7QvdC10LTQtdC70L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLRgNGC0L7QulwiLCBcItC/0LXRgtC+0LpcIiwgXCLRgdCw0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQvdC10LRcIiwgXCLQv9C+0L1cIiwgXCLQstGC0L5cIiwgXCLRgdGA0LVcIiwgXCLRh9C10YJcIiwgXCLQv9C10YJcIiwgXCLRgdCw0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRmNCw0L3Rg9Cw0YDQuFwiLCBcItGE0LXQstGA0YPQsNGA0LhcIiwgXCLQvNCw0YDRglwiLCBcItCw0L/RgNC40LtcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L3QuFwiLCBcItGY0YPQu9C4XCIsIFwi0LDQstCz0YPRgdGCXCIsIFwi0YHQtdC/0YLQtdC80LLRgNC4XCIsIFwi0L7QutGC0L7QvNCy0YDQuFwiLCBcItC90L7QtdC80LLRgNC4XCIsIFwi0LTQtdC60LXQvNCy0YDQuFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0ZjQsNC9XCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C9XCIsIFwi0ZjRg9C7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC/XCIsIFwi0L7QutGCXCIsIFwi0L3QvtC1XCIsIFwi0LTQtdC6XCJdXG4gIH07XG5cbiAgdmFyIGphSnAgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJVkgJWIgJWUgJWEgJVhcIixcbiAgICBkYXRlOiBcIiVZLyVtLyVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi5pel5puc5pelXCIsIFwi5pyI5puc5pelXCIsIFwi54Gr5puc5pelXCIsIFwi5rC05puc5pelXCIsIFwi5pyo5puc5pelXCIsIFwi6YeR5puc5pelXCIsIFwi5Zyf5puc5pelXCJdLFxuICAgIHNob3J0RGF5czogW1wi5pelXCIsIFwi5pyIXCIsIFwi54GrXCIsIFwi5rC0XCIsIFwi5pyoXCIsIFwi6YeRXCIsIFwi5ZyfXCJdLFxuICAgIG1vbnRoczogW1wi552m5pyIXCIsIFwi5aaC5pyIXCIsIFwi5byl55SfXCIsIFwi5Y2v5pyIXCIsIFwi55qQ5pyIXCIsIFwi5rC054Sh5pyIXCIsIFwi5paH5pyIXCIsIFwi6JGJ5pyIXCIsIFwi6ZW35pyIXCIsIFwi56We54Sh5pyIXCIsIFwi6Zyc5pyIXCIsIFwi5bir6LWwXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl1cbiAgfTtcblxuICB2YXIgaXRJdCA9IHtcbiAgICBkYXRlVGltZTogXCIlQSAlZSAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcIkRvbWVuaWNhXCIsIFwiTHVuZWTDrFwiLCBcIk1hcnRlZMOsXCIsIFwiTWVyY29sZWTDrFwiLCBcIkdpb3ZlZMOsXCIsIFwiVmVuZXJkw6xcIiwgXCJTYWJhdG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJEb21cIiwgXCJMdW5cIiwgXCJNYXJcIiwgXCJNZXJcIiwgXCJHaW9cIiwgXCJWZW5cIiwgXCJTYWJcIl0sXG4gICAgbW9udGhzOiBbXCJHZW5uYWlvXCIsIFwiRmViYnJhaW9cIiwgXCJNYXJ6b1wiLCBcIkFwcmlsZVwiLCBcIk1hZ2dpb1wiLCBcIkdpdWdub1wiLCBcIkx1Z2xpb1wiLCBcIkFnb3N0b1wiLCBcIlNldHRlbWJyZVwiLCBcIk90dG9icmVcIiwgXCJOb3ZlbWJyZVwiLCBcIkRpY2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJHZW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYWdcIiwgXCJHaXVcIiwgXCJMdWdcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdHRcIiwgXCJOb3ZcIiwgXCJEaWNcIl1cbiAgfTtcblxuICB2YXIgaGVJbCA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUg15ElQiAlWSAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLXqNeQ16nXldefXCIsIFwi16nXoNeZXCIsIFwi16nXnNeZ16nXmVwiLCBcIteo15HXmdei15lcIiwgXCLXl9ee15nXqdeZXCIsIFwi16nXmdep15lcIiwgXCLXqdeR16pcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLXkNezXCIsIFwi15HXs1wiLCBcIteS17NcIiwgXCLXk9ezXCIsIFwi15TXs1wiLCBcIteV17NcIiwgXCLXqdezXCJdLFxuICAgIG1vbnRoczogW1wi15nXoNeV15DXqFwiLCBcItek15HXqNeV15DXqFwiLCBcItee16jXpVwiLCBcIteQ16TXqNeZ15xcIiwgXCLXnteQ15lcIiwgXCLXmdeV16DXmVwiLCBcIteZ15XXnNeZXCIsIFwi15DXldeS15XXodeYXCIsIFwi16HXpNeY157XkdeoXCIsIFwi15DXlden15jXldeR16hcIiwgXCLXoNeV15HXnteR16hcIiwgXCLXk9em157XkdeoXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLXmdeg15XXs1wiLCBcItek15HXqNezXCIsIFwi157XqNelXCIsIFwi15DXpNeo17NcIiwgXCLXnteQ15lcIiwgXCLXmdeV16DXmVwiLCBcIteZ15XXnNeZXCIsIFwi15DXldeS17NcIiwgXCLXodek15jXs1wiLCBcIteQ15XXp9ezXCIsIFwi16DXldeR17NcIiwgXCLXk9em157Xs1wiXVxuICB9O1xuXG4gIHZhciBmckZyID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCBsZSAlZSAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcImRpbWFuY2hlXCIsIFwibHVuZGlcIiwgXCJtYXJkaVwiLCBcIm1lcmNyZWRpXCIsIFwiamV1ZGlcIiwgXCJ2ZW5kcmVkaVwiLCBcInNhbWVkaVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRpbS5cIiwgXCJsdW4uXCIsIFwibWFyLlwiLCBcIm1lci5cIiwgXCJqZXUuXCIsIFwidmVuLlwiLCBcInNhbS5cIl0sXG4gICAgbW9udGhzOiBbXCJqYW52aWVyXCIsIFwiZsOpdnJpZXJcIiwgXCJtYXJzXCIsIFwiYXZyaWxcIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbGxldFwiLCBcImFvw7t0XCIsIFwic2VwdGVtYnJlXCIsIFwib2N0b2JyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZMOpY2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW52LlwiLCBcImbDqXZyLlwiLCBcIm1hcnNcIiwgXCJhdnIuXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWwuXCIsIFwiYW/Du3RcIiwgXCJzZXB0LlwiLCBcIm9jdC5cIiwgXCJub3YuXCIsIFwiZMOpYy5cIl1cbiAgfTtcblxuICB2YXIgZnJDYSA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlZSAlYiAlWSAlWFwiLFxuICAgIGRhdGU6IFwiJVktJW0tJWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiXCIsIFwiXCJdLFxuICAgIGRheXM6IFtcImRpbWFuY2hlXCIsIFwibHVuZGlcIiwgXCJtYXJkaVwiLCBcIm1lcmNyZWRpXCIsIFwiamV1ZGlcIiwgXCJ2ZW5kcmVkaVwiLCBcInNhbWVkaVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRpbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1lclwiLCBcImpldVwiLCBcInZlblwiLCBcInNhbVwiXSxcbiAgICBtb250aHM6IFtcImphbnZpZXJcIiwgXCJmw6l2cmllclwiLCBcIm1hcnNcIiwgXCJhdnJpbFwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsbGV0XCIsIFwiYW/Du3RcIiwgXCJzZXB0ZW1icmVcIiwgXCJvY3RvYnJlXCIsIFwibm92ZW1icmVcIiwgXCJkw6ljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphblwiLCBcImbDqXZcIiwgXCJtYXJcIiwgXCJhdnJcIiwgXCJtYWlcIiwgXCJqdWlcIiwgXCJqdWxcIiwgXCJhb8O7XCIsIFwic2VwXCIsIFwib2N0XCIsIFwibm92XCIsIFwiZMOpY1wiXVxuICB9O1xuXG4gIHZhciBmaUZpID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlLWQuICVCdGEgJVkga2xvICVYXCIsXG4gICAgZGF0ZTogXCIlLWQuJS1tLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcImEubS5cIiwgXCJwLm0uXCJdLFxuICAgIGRheXM6IFtcInN1bm51bnRhaVwiLCBcIm1hYW5hbnRhaVwiLCBcInRpaXN0YWlcIiwgXCJrZXNraXZpaWtrb1wiLCBcInRvcnN0YWlcIiwgXCJwZXJqYW50YWlcIiwgXCJsYXVhbnRhaVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1XCIsIFwiTWFcIiwgXCJUaVwiLCBcIktlXCIsIFwiVG9cIiwgXCJQZVwiLCBcIkxhXCJdLFxuICAgIG1vbnRoczogW1widGFtbWlrdXVcIiwgXCJoZWxtaWt1dVwiLCBcIm1hYWxpc2t1dVwiLCBcImh1aHRpa3V1XCIsIFwidG91a29rdXVcIiwgXCJrZXPDpGt1dVwiLCBcImhlaW7DpGt1dVwiLCBcImVsb2t1dVwiLCBcInN5eXNrdXVcIiwgXCJsb2tha3V1XCIsIFwibWFycmFza3V1XCIsIFwiam91bHVrdXVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIlRhbW1pXCIsIFwiSGVsbWlcIiwgXCJNYWFsaXNcIiwgXCJIdWh0aVwiLCBcIlRvdWtvXCIsIFwiS2Vzw6RcIiwgXCJIZWluw6RcIiwgXCJFbG9cIiwgXCJTeXlzXCIsIFwiTG9rYVwiLCBcIk1hcnJhc1wiLCBcIkpvdWx1XCJdXG4gIH07XG5cbiAgdmFyIGVzRXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJkb21pbmdvXCIsIFwibHVuZXNcIiwgXCJtYXJ0ZXNcIiwgXCJtacOpcmNvbGVzXCIsIFwianVldmVzXCIsIFwidmllcm5lc1wiLCBcInPDoWJhZG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkb21cIiwgXCJsdW5cIiwgXCJtYXJcIiwgXCJtacOpXCIsIFwianVlXCIsIFwidmllXCIsIFwic8OhYlwiXSxcbiAgICBtb250aHM6IFtcImVuZXJvXCIsIFwiZmVicmVyb1wiLCBcIm1hcnpvXCIsIFwiYWJyaWxcIiwgXCJtYXlvXCIsIFwianVuaW9cIiwgXCJqdWxpb1wiLCBcImFnb3N0b1wiLCBcInNlcHRpZW1icmVcIiwgXCJvY3R1YnJlXCIsIFwibm92aWVtYnJlXCIsIFwiZGljaWVtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJlbmVcIiwgXCJmZWJcIiwgXCJtYXJcIiwgXCJhYnJcIiwgXCJtYXlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhZ29cIiwgXCJzZXBcIiwgXCJvY3RcIiwgXCJub3ZcIiwgXCJkaWNcIl1cbiAgfTtcblxuICB2YXIgZW5VcyA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJW0vJWQvJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgfTtcblxuICB2YXIgZW5HYiA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlZSAlYiAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgfTtcblxuICB2YXIgZW5DYSA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJVktJW0tJWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgfTtcblxuICB2YXIgZGVEZSA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgZGVyICVlLiAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcIlNvbm50YWdcIiwgXCJNb250YWdcIiwgXCJEaWVuc3RhZ1wiLCBcIk1pdHR3b2NoXCIsIFwiRG9ubmVyc3RhZ1wiLCBcIkZyZWl0YWdcIiwgXCJTYW1zdGFnXCJdLFxuICAgIHNob3J0RGF5czogW1wiU29cIiwgXCJNb1wiLCBcIkRpXCIsIFwiTWlcIiwgXCJEb1wiLCBcIkZyXCIsIFwiU2FcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJcIiwgXCJGZWJydWFyXCIsIFwiTcOkcnpcIiwgXCJBcHJpbFwiLCBcIk1haVwiLCBcIkp1bmlcIiwgXCJKdWxpXCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2t0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGV6ZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1yelwiLCBcIkFwclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9rdFwiLCBcIk5vdlwiLCBcIkRlelwiXVxuICB9O1xuXG4gIHZhciBjYUVzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiZGl1bWVuZ2VcIiwgXCJkaWxsdW5zXCIsIFwiZGltYXJ0c1wiLCBcImRpbWVjcmVzXCIsIFwiZGlqb3VzXCIsIFwiZGl2ZW5kcmVzXCIsIFwiZGlzc2FidGVcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkZy5cIiwgXCJkbC5cIiwgXCJkdC5cIiwgXCJkYy5cIiwgXCJkai5cIiwgXCJkdi5cIiwgXCJkcy5cIl0sXG4gICAgbW9udGhzOiBbXCJnZW5lclwiLCBcImZlYnJlclwiLCBcIm1hcsOnXCIsIFwiYWJyaWxcIiwgXCJtYWlnXCIsIFwianVueVwiLCBcImp1bGlvbFwiLCBcImFnb3N0XCIsIFwic2V0ZW1icmVcIiwgXCJvY3R1YnJlXCIsIFwibm92ZW1icmVcIiwgXCJkZXNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiZ2VuLlwiLCBcImZlYnIuXCIsIFwibWFyw6dcIiwgXCJhYnIuXCIsIFwibWFpZ1wiLCBcImp1bnlcIiwgXCJqdWwuXCIsIFwiYWcuXCIsIFwic2V0LlwiLCBcIm9jdC5cIiwgXCJub3YuXCIsIFwiZGVzLlwiXVxuICB9O1xuXG4gIHZhciB0MCA9IG5ldyBEYXRlO1xuICB2YXIgdDEgPSBuZXcgRGF0ZTtcblxuICBmdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50KSB7XG5cbiAgICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICAgIH1cblxuICAgIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IG5ldyBEYXRlKCtkYXRlKSxcbiAgICAgICAgICBkMSA9IG5ldyBEYXRlKGRhdGUgLSAxKTtcbiAgICAgIGZsb29yaShkMCksIGZsb29yaShkMSksIG9mZnNldGkoZDEsIDEpO1xuICAgICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gICAgfTtcblxuICAgIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCAtIDEpO1xuICAgICAgc3RvcCA9IG5ldyBEYXRlKCtzdG9wKTtcbiAgICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgICAgb2Zmc2V0aShzdGFydCwgMSksIGZsb29yaShzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgd2hpbGUgKG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpLCBzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuICAgIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgICB3aGlsZSAoLS1zdGVwID49IDApIHdoaWxlIChvZmZzZXRpKGRhdGUsIDEpLCAhdGVzdChkYXRlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGNvdW50KSBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwLnNldFRpbWUoK3N0YXJ0KSwgdDEuc2V0VGltZSgrZW5kKTtcbiAgICAgIGZsb29yaSh0MCksIGZsb29yaSh0MSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9XG5cbiAgdmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xuICB2YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcblxuICB2YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgdmFyIHV0Y0RheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDg2NGU1O1xuICB9KTtcblxuICBmdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIChkYXRlLmdldFVUQ0RheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG4gIHZhciB1dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xuICB9KTtcblxuICBmdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXRjRGF0ZShkKSB7XG4gICAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkLnkpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1llYXIoeSkge1xuICAgIHJldHVybiB7eTogeSwgbTogMCwgZDogMSwgSDogMCwgTTogMCwgUzogMCwgTDogMH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbGUobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSxcbiAgICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgICAgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcyxcbiAgICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgICAgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsXG4gICAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICAgIHZhciBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgICB3ZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgICBtb250aFJlID0gZm9ybWF0UmUobG9jYWxlX21vbnRocyksXG4gICAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgICBzaG9ydE1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG5cbiAgICB2YXIgZm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0V2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFpvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHV0Y0Zvcm1hdHMgPSB7XG4gICAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgICBcImJcIjogZm9ybWF0VVRDU2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICAgIFwiY1wiOiBudWxsLFxuICAgICAgXCJkXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcbiAgICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcbiAgICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgICBcIlNcIjogZm9ybWF0VVRDU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogZm9ybWF0VVRDV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBudWxsLFxuICAgICAgXCJYXCI6IG51bGwsXG4gICAgICBcInlcIjogZm9ybWF0VVRDWWVhcixcbiAgICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIHZhciBwYXJzZXMgPSB7XG4gICAgICBcImFcIjogcGFyc2VTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogcGFyc2VXZWVrZGF5LFxuICAgICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBwYXJzZU1vbnRoLFxuICAgICAgXCJjXCI6IHBhcnNlTG9jYWxlRGF0ZVRpbWUsXG4gICAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICAgIFwialwiOiBwYXJzZURheU9mWWVhcixcbiAgICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IHBhcnNlTWludXRlcyxcbiAgICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gICAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICAgIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgcGFkLFxuICAgICAgICAgICAgZm9ybWF0O1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCA9PSBudWxsID8gKGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIikgOiBwYWQpO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSBuZXdZZWFyKDE5MDApLFxuICAgICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICBpZiAoXCJ3XCIgaW4gZCAmJiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSkge1xuICAgICAgICAgICAgdmFyIGRheSA9IHV0Y0RhdGUobmV3WWVhcihkLnkpKS5nZXRVVENEYXkoKTtcbiAgICAgICAgICAgIGlmIChcIldcIiBpbiBkKSBkLlUgPSBkLlcsIGQudyA9IChkLncgKyA2KSAlIDcsIC0tZGF5O1xuICAgICAgICAgICAgZC5tID0gMDtcbiAgICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgICBpZiAoXCJ3XCIgaW4gZCAmJiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSkge1xuICAgICAgICAgIHZhciBkYXkgPSBuZXdEYXRlKG5ld1llYXIoZC55KSkuZ2V0RGF5KCk7XG4gICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgZC5tID0gMDtcbiAgICAgICAgICBkLmQgPSBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhcnNlO1xuXG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gcGVyaW9kTG9va3VwW3N0cmluZy5zbGljZShpLCBpICs9IDIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IC0xIDogKGQucCA9IG4sIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICAgIGYucGFyc2UgPSBuZXdQYXJzZShzcGVjaWZpZXIsIGxvY2FsRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcbiAgdmFyIG51bWJlclJlID0gL15cXHMqXFxkKy87XG4gIHZhciBwZXJjZW50UmUgPSAvXiUvO1xuICB2YXIgcmVxdW90ZVJlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG4gIGZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXBbbmFtZXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86XFw6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGQuWiA9IG5bMV0gPyAwICAgICAgICAgICAgICAvLyAnWicgZm9yIFVUQ1xuICAgICAgICAgIDogblszXSA/IC0oblsyXSArIG5bM10pIC8vIHNpZ24gZGlmZmVycyBmcm9tIGdldFRpbWV6b25lT2Zmc2V0IVxuICAgICAgICAgICAgICAgICA6IC1uWzJdICogMTAwO1xuICAgICAgcmV0dXJuIGkgKyBuWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIGRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHN1bmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQobW9uZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyB1dGNEYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNTdW5kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y01vbmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICAgIHJldHVybiBcIiswMDAwXCI7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgICByZXR1cm4gXCIlXCI7XG4gIH1cblxuICB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuICBmdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cblxuICBmb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzb1NwZWNpZmllcjtcbiAgfTtcblxuICB2YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgICAgOiBlblVzLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG4gIHZhciBpc29Gb3JtYXQgPSBmb3JtYXRJc287XG5cbiAgdmFyIGxvY2FsZURlZmluaXRpb25zID0ge1xuICAgIFwiY2EtRVNcIjogY2FFcyxcbiAgICBcImRlLURFXCI6IGRlRGUsXG4gICAgXCJlbi1DQVwiOiBlbkNhLFxuICAgIFwiZW4tR0JcIjogZW5HYixcbiAgICBcImVuLVVTXCI6IGVuVXMsXG4gICAgXCJlcy1FU1wiOiBlc0VzLFxuICAgIFwiZmktRklcIjogZmlGaSxcbiAgICBcImZyLUNBXCI6IGZyQ2EsXG4gICAgXCJmci1GUlwiOiBmckZyLFxuICAgIFwiaGUtSUxcIjogaGVJbCxcbiAgICBcIml0LUlUXCI6IGl0SXQsXG4gICAgXCJqYS1KUFwiOiBqYUpwLFxuICAgIFwibWstTUtcIjogbWtNayxcbiAgICBcIm5sLU5MXCI6IG5sTmwsXG4gICAgXCJwbC1QTFwiOiBwbFBsLFxuICAgIFwicHQtQlJcIjogcHRCcixcbiAgICBcInJ1LVJVXCI6IHJ1UnUsXG4gICAgXCJ6aC1DTlwiOiB6aENuXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGUoZW5Vcyk7XG4gIGV4cG9ydHMuZm9ybWF0ID0gZGVmYXVsdExvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudXRjRm9ybWF0ID0gZGVmYXVsdExvY2FsZS51dGNGb3JtYXQ7XG5cbiAgZnVuY3Rpb24gbG9jYWxlRm9ybWF0KGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghbG9jYWxlRGVmaW5pdGlvbnMuaGFzT3duUHJvcGVydHkoZGVmaW5pdGlvbikpIHJldHVybiBudWxsO1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlKGRlZmluaXRpb24pO1xuICB9XG4gIDtcblxuICBleHBvcnRzLmxvY2FsZUZvcm1hdCA9IGxvY2FsZUZvcm1hdDtcbiAgZXhwb3J0cy5pc29Gb3JtYXQgPSBpc29Gb3JtYXQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIHZhciB0MCA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDFlMztcbiAgfSk7XG5cbiAgZXhwb3J0cy5zZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG4gIHZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRTZWNvbmRzKDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDZlNDtcbiAgfSk7XG5cbiAgZXhwb3J0cy5taW51dGVzID0gbWludXRlLnJhbmdlO1xuXG4gIHZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5ob3VycyA9IGhvdXIucmFuZ2U7XG5cbiAgdmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMuZGF5cyA9IGRheS5yYW5nZTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnN1bmRheSA9IHdlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy5zdW5kYXlzID0gZXhwb3J0cy5zdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5tb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMubW9uZGF5cyA9IGV4cG9ydHMubW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudHVlc2RheSA9IHdlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy50dWVzZGF5cyA9IGV4cG9ydHMudHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLndlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy53ZWRuZXNkYXlzID0gZXhwb3J0cy53ZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50aHVyc2RheSA9IHdlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy50aHVyc2RheXMgPSBleHBvcnRzLnRodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuZnJpZGF5ID0gd2Vla2RheSg1KTtcblxuICBleHBvcnRzLmZyaWRheXMgPSBleHBvcnRzLmZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxuICBleHBvcnRzLnNhdHVyZGF5cyA9IGV4cG9ydHMuc2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHdlZWsgPSBleHBvcnRzLnN1bmRheTtcblxuICBleHBvcnRzLndlZWtzID0gd2Vlay5yYW5nZTtcblxuICB2YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMubW9udGhzID0gbW9udGgucmFuZ2U7XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMueWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG4gIHZhciB1dGNTZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1NlY29uZHMgPSB1dGNTZWNvbmQucmFuZ2U7XG5cbiAgdmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbiAgdmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuICBmdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIChkYXRlLmdldFVUQ0RheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuXG4gIGV4cG9ydHMudXRjU3VuZGF5cyA9IGV4cG9ydHMudXRjU3VuZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICBleHBvcnRzLnV0Y01vbmRheXMgPSBleHBvcnRzLnV0Y01vbmRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheXMgPSBleHBvcnRzLnV0Y1R1ZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuXG4gIGV4cG9ydHMudXRjV2VkbmVzZGF5cyA9IGV4cG9ydHMudXRjV2VkbmVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXlzID0gZXhwb3J0cy51dGNUaHVyc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5cbiAgZXhwb3J0cy51dGNGcmlkYXlzID0gZXhwb3J0cy51dGNGcmlkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheXMgPSBleHBvcnRzLnV0Y1NhdHVyZGF5LnJhbmdlO1xuXG4gIHZhciB1dGNXZWVrID0gZXhwb3J0cy51dGNTdW5kYXk7XG5cbiAgZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1dlZWsucmFuZ2U7XG5cbiAgdmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuICBleHBvcnRzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XG4gIGV4cG9ydHMuc2Vjb25kID0gc2Vjb25kO1xuICBleHBvcnRzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgZXhwb3J0cy5ob3VyID0gaG91cjtcbiAgZXhwb3J0cy5kYXkgPSBkYXk7XG4gIGV4cG9ydHMud2VlayA9IHdlZWs7XG4gIGV4cG9ydHMubW9udGggPSBtb250aDtcbiAgZXhwb3J0cy55ZWFyID0geWVhcjtcbiAgZXhwb3J0cy51dGNTZWNvbmQgPSB1dGNTZWNvbmQ7XG4gIGV4cG9ydHMudXRjTWludXRlID0gdXRjTWludXRlO1xuICBleHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuICBleHBvcnRzLnV0Y0RheSA9IHV0Y0RheTtcbiAgZXhwb3J0cy51dGNXZWVrID0gdXRjV2VlaztcbiAgZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuICBleHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuXG59KSk7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgTWVhc3VyZXMgPSByZXF1aXJlKCcuL21lYXN1cmVzJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9jb2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQWdncmVnYXRvcigpIHtcbiAgdGhpcy5fY2VsbHMgPSB7fTtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICB0aGlzLl9zdHJlYW0gPSBmYWxzZTtcbn1cblxudmFyIEZsYWdzID0gQWdncmVnYXRvci5GbGFncyA9IHtcbiAgQUREX0NFTEw6IDEsXG4gIE1PRF9DRUxMOiAyXG59O1xuXG52YXIgcHJvdG8gPSBBZ2dyZWdhdG9yLnByb3RvdHlwZTtcblxuLy8gUGFyYW1ldGVyc1xuXG5wcm90by5zdHJlYW0gPSBmdW5jdGlvbih2KSB7XG4gIGlmICh2ID09IG51bGwpIHJldHVybiB0aGlzLl9zdHJlYW07XG4gIHRoaXMuX3N0cmVhbSA9ICEhdjtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGtleSBhY2Nlc3NvciB0byB1c2UgZm9yIHN0cmVhbWluZyByZW1vdmVzXG5wcm90by5rZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcy5fa2V5O1xuICB0aGlzLl9rZXkgPSB1dGlsLiQoa2V5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgZ2V0OiBmdW5jdGlvbn1cbnByb3RvLmdyb3VwYnkgPSBmdW5jdGlvbihkaW1zKSB7XG4gIHRoaXMuX2RpbXMgPSB1dGlsLmFycmF5KGRpbXMpLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgZCA9IHV0aWwuaXNTdHJpbmcoZCkgPyB7bmFtZTogZCwgZ2V0OiB1dGlsLiQoZCl9XG4gICAgICA6IHV0aWwuaXNGdW5jdGlvbihkKSA/IHtuYW1lOiB1dGlsLm5hbWUoZCkgfHwgZC5uYW1lIHx8ICgnXycgKyBpKSwgZ2V0OiBkfVxuICAgICAgOiAoZC5uYW1lICYmIHV0aWwuaXNGdW5jdGlvbihkLmdldCkpID8gZCA6IG51bGw7XG4gICAgaWYgKGQgPT0gbnVsbCkgdGhyb3cgJ0ludmFsaWQgZ3JvdXBieSBhcmd1bWVudDogJyArIGQ7XG4gICAgcmV0dXJuIGQ7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gSW5wdXQ6IGFycmF5IG9mIG9iamVjdHMgb2YgdGhlIGZvcm1cbi8vIHtuYW1lOiBzdHJpbmcsIG9wczogW3N0cmluZywgLi4uXX1cbnByb3RvLnN1bW1hcml6ZSA9IGZ1bmN0aW9uKGZpZWxkcykge1xuICBmaWVsZHMgPSBzdW1tYXJpemVfYXJncyhmaWVsZHMpO1xuICB0aGlzLl9jb3VudCA9IHRydWU7XG4gIHZhciBhZ2dyID0gKHRoaXMuX2FnZ3IgPSBbXSksXG4gICAgICBtLCBmLCBpLCBqLCBvcCwgYXMsIGdldDtcblxuICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGo9MCwgbT1bXSwgZj1maWVsZHNbaV07IGo8Zi5vcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIG9wID0gZi5vcHNbal07XG4gICAgICBpZiAob3AgIT09ICdjb3VudCcpIHRoaXMuX2NvdW50ID0gZmFsc2U7XG4gICAgICBhcyA9IChmLmFzICYmIGYuYXNbal0pIHx8IChvcCArIChmLm5hbWU9PT0nKicgPyAnJyA6ICdfJytmLm5hbWUpKTtcbiAgICAgIG0ucHVzaChNZWFzdXJlc1tvcF0oYXMpKTtcbiAgICB9XG4gICAgZ2V0ID0gZi5nZXQgJiYgdXRpbC4kKGYuZ2V0KSB8fFxuICAgICAgKGYubmFtZSA9PT0gJyonID8gdXRpbC5pZGVudGl0eSA6IHV0aWwuJChmLm5hbWUpKTtcbiAgICBhZ2dyLnB1c2goe1xuICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgbWVhc3VyZXM6IE1lYXN1cmVzLmNyZWF0ZShcbiAgICAgICAgbSxcbiAgICAgICAgdGhpcy5fc3RyZWFtLCAvLyBzdHJlYW1pbmcgcmVtb3ZlIGZsYWdcbiAgICAgICAgZ2V0LCAgICAgICAgICAvLyBpbnB1dCB0dXBsZSBnZXR0ZXJcbiAgICAgICAgdGhpcy5fYXNzaWduKSAvLyBvdXRwdXQgdHVwbGUgc2V0dGVyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byBzdW1tYXJpemUgYnkgY291bnRcbnByb3RvLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN1bW1hcml6ZSh7JyonOidjb3VudCd9KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIHZhbHVlIGFzc2lnbm1lbnRcbnByb3RvLl9hc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gc3VtbWFyaXplX2FyZ3MoZmllbGRzKSB7XG4gIGlmICh1dGlsLmlzQXJyYXkoZmllbGRzKSkgeyByZXR1cm4gZmllbGRzOyB9XG4gIGlmIChmaWVsZHMgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgdmFyIGEgPSBbXSwgbmFtZSwgb3BzO1xuICBmb3IgKG5hbWUgaW4gZmllbGRzKSB7XG4gICAgb3BzID0gdXRpbC5hcnJheShmaWVsZHNbbmFtZV0pO1xuICAgIGEucHVzaCh7bmFtZTogbmFtZSwgb3BzOiBvcHN9KTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy8gQ2VsbCBNYW5hZ2VtZW50XG5cbnByb3RvLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fY2VsbHMgPSB7fSwgdGhpcyk7XG59O1xuXG5wcm90by5fY2VsbGtleSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGQgPSB0aGlzLl9kaW1zLFxuICAgICAgbiA9IGQubGVuZ3RoLCBpLFxuICAgICAgayA9IFN0cmluZyhkWzBdLmdldCh4KSk7XG4gIGZvciAoaT0xOyBpPG47ICsraSkge1xuICAgIGsgKz0gJ3wnICsgZFtpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIGs7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleSA9IHRoaXMuX2RpbXMubGVuZ3RoID8gdGhpcy5fY2VsbGtleSh4KSA6ICcnO1xuICByZXR1cm4gdGhpcy5fY2VsbHNba2V5XSB8fCAodGhpcy5fY2VsbHNba2V5XSA9IHRoaXMuX25ld2NlbGwoeCwga2V5KSk7XG59O1xuXG5wcm90by5fbmV3Y2VsbCA9IGZ1bmN0aW9uKHgsIGtleSkge1xuICB2YXIgY2VsbCA9IHtcbiAgICBudW06ICAgMCxcbiAgICB0dXBsZTogdGhpcy5fbmV3dHVwbGUoeCwga2V5KSxcbiAgICBmbGFnOiAgRmxhZ3MuQUREX0NFTEwsXG4gICAgYWdnczogIHt9XG4gIH07XG5cbiAgdmFyIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0gPSBuZXcgYWdncltpXS5tZWFzdXJlcyhjZWxsLCBjZWxsLnR1cGxlKTtcbiAgfVxuICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgY2VsbC5kYXRhID0gbmV3IENvbGxlY3Rvcih0aGlzLl9rZXkpO1xuICB9XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX25ld3R1cGxlID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICB0ID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPWRpbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHRbZGltc1tpXS5uYW1lXSA9IGRpbXNbaV0uZ2V0KHgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbmdlc3QodCk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSBpbmdlc3Rpb25cbnByb3RvLl9pbmdlc3QgPSB1dGlsLmlkZW50aXR5O1xuXG4vLyBQcm9jZXNzIFR1cGxlc1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSArPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5hZGQoeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uYWRkKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG4gIGlmICh0aGlzLl9vbl9hZGQpIHRoaXMuX29uX2FkZCh4LCBjZWxsKTtcbn07XG5cbnByb3RvLl9yZW0gPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtIC09IDE7XG4gIGlmICghdGhpcy5fY291bnQpIHsgLy8gc2tpcCBpZiBjb3VudC1vbmx5XG4gICAgaWYgKGNlbGwuY29sbGVjdCkgY2VsbC5kYXRhLnJlbSh4KTtcbiAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0oeCk7XG4gICAgfVxuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbiAgaWYgKHRoaXMuX29uX3JlbSkgdGhpcy5fb25fcmVtKHgsIGNlbGwpO1xufTtcblxucHJvdG8uX21vZCA9IGZ1bmN0aW9uKGN1cnIsIHByZXYpIHtcbiAgdmFyIGNlbGwwID0gdGhpcy5fY2VsbChwcmV2KSxcbiAgICAgIGNlbGwxID0gdGhpcy5fY2VsbChjdXJyKSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGlmIChjZWxsMCAhPT0gY2VsbDEpIHtcbiAgICBjZWxsMC5udW0gLT0gMTtcbiAgICBjZWxsMS5udW0gKz0gMTtcbiAgICBpZiAoY2VsbDAuY29sbGVjdCkgY2VsbDAuZGF0YS5yZW0ocHJldik7XG4gICAgaWYgKGNlbGwxLmNvbGxlY3QpIGNlbGwxLmRhdGEuYWRkKGN1cnIpO1xuICB9IGVsc2UgaWYgKGNlbGwwLmNvbGxlY3QgJiYgIXV0aWwuaXNPYmplY3QoY3VycikpIHtcbiAgICBjZWxsMC5kYXRhLnJlbShwcmV2KTtcbiAgICBjZWxsMC5kYXRhLmFkZChjdXJyKTtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsMC5hZ2dzW2FnZ3JbaV0ubmFtZV0ucmVtKHByZXYpO1xuICAgIGNlbGwxLmFnZ3NbYWdncltpXS5uYW1lXS5hZGQoY3Vycik7XG4gIH1cbiAgY2VsbDAuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbiAgY2VsbDEuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbiAgaWYgKHRoaXMuX29uX21vZCkgdGhpcy5fb25fbW9kKGN1cnIsIHByZXYsIGNlbGwwLCBjZWxsMSk7XG59O1xuXG5wcm90by5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZiAoY2VsbC5udW0gPiAwKSB7XG4gICAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIG91dHB1dCB0dXBsZVxuICAgICAgcmVzdWx0LnB1c2goY2VsbC50dXBsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trXTtcbiAgICB9XG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnByb3RvLmNoYW5nZXMgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgdmFyIGNoYW5nZXMgPSBvdXRwdXQgfHwge2FkZDpbXSwgcmVtOltdLCBtb2Q6W119LFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBmbGFnLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBmbGFnID0gY2VsbC5mbGFnO1xuXG4gICAgLy8gY29uc29saWRhdGUgY29sbGVjdG9yIHZhbHVlc1xuICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgIH1cblxuICAgIC8vIG9yZ2FuaXplIG91dHB1dCB0dXBsZXNcbiAgICBpZiAoY2VsbC5udW0gPD0gMCkge1xuICAgICAgY2hhbmdlcy5yZW0ucHVzaChjZWxsLnR1cGxlKTsgLy8gaWYgKGZsYWcgPT09IEZsYWdzLk1PRF9DRUxMKSB7ID8/XG4gICAgICBkZWxldGUgdGhpcy5fY2VsbHNba107XG4gICAgICBpZiAodGhpcy5fb25fZHJvcCkgdGhpcy5fb25fZHJvcChjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX29uX2tlZXApIHRoaXMuX29uX2tlZXAoY2VsbCk7XG4gICAgICBpZiAoZmxhZyAmIEZsYWdzLkFERF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMuYWRkLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWcgJiBGbGFncy5NT0RfQ0VMTCkge1xuICAgICAgICBjaGFuZ2VzLm1vZC5wdXNoKGNlbGwudHVwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNlbGwuZmxhZyA9IDA7XG4gIH1cblxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG4gIHJldHVybiBjaGFuZ2VzO1xufTtcblxucHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiB0aGlzLmNsZWFyKCkuaW5zZXJ0KGlucHV0KS5yZXN1bHQoKTtcbn07XG5cbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHRoaXMuX2NvbnNvbGlkYXRlKCk7XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX2FkZChpbnB1dFtpXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoIXRoaXMuX3N0cmVhbSkge1xuICAgIHRocm93ICdBZ2dyZWdhdG9yIG5vdCBjb25maWd1cmVkIGZvciBzdHJlYW1pbmcgcmVtb3Zlcy4nICtcbiAgICAgICcgQ2FsbCBzdHJlYW0odHJ1ZSkgcHJpb3IgdG8gY2FsbGluZyBzdW1tYXJpemUuJztcbiAgfVxuICBmb3IgKHZhciBpPTA7IGk8aW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9yZW0oaW5wdXRbaV0pO1xuICB9XG4gIHRoaXMuX3JlbXMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGNvbnNvbGlkYXRlIHJlbW92YWxzXG5wcm90by5fY29uc29saWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZW1zKSByZXR1cm47XG4gIGZvciAodmFyIGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBpZiAodGhpcy5fY2VsbHNba10uY29sbGVjdCkge1xuICAgICAgdGhpcy5fY2VsbHNba10uZGF0YS52YWx1ZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHN0YXRzID0gcmVxdWlyZSgnLi4vc3RhdHMnKTtcblxudmFyIFJFTSA9ICdfX2RsX3JlbV9fJztcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGtleSkge1xuICB0aGlzLl9hZGQgPSBbXTtcbiAgdGhpcy5fcmVtID0gW107XG4gIHRoaXMuX2tleSA9IGtleSB8fCBudWxsO1xuICB0aGlzLl9sYXN0ID0gbnVsbDtcbn1cblxudmFyIHByb3RvID0gQ29sbGVjdG9yLnByb3RvdHlwZTtcblxucHJvdG8uYWRkID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9hZGQucHVzaCh2KTtcbn07XG5cbnByb3RvLnJlbSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fcmVtLnB1c2godik7XG59O1xuXG5wcm90by52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZ2V0ID0gbnVsbDtcbiAgaWYgKHRoaXMuX3JlbS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9hZGQ7XG5cbiAgdmFyIGEgPSB0aGlzLl9hZGQsXG4gICAgICByID0gdGhpcy5fcmVtLFxuICAgICAgayA9IHRoaXMuX2tleSxcbiAgICAgIHggPSBBcnJheShhLmxlbmd0aCAtIHIubGVuZ3RoKSxcbiAgICAgIGksIGosIG4sIG07XG5cbiAgaWYgKCF1dGlsLmlzT2JqZWN0KHJbMF0pKSB7XG4gICAgLy8gcHJvY2Vzc2luZyByYXcgdmFsdWVzXG4gICAgbSA9IHN0YXRzLmNvdW50Lm1hcChyKTtcbiAgICBmb3IgKGk9MCwgaj0wLCBuPWEubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKG1bYVtpXV0gPiAwKSB7XG4gICAgICAgIG1bYVtpXV0gLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhbaisrXSA9IGFbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGspIHtcbiAgICAvLyBoYXMgdW5pcXVlIGtleSBmaWVsZCwgc28gdXNlIHRoYXRcbiAgICBtID0gdXRpbC50b01hcChyLCBrKTtcbiAgICBmb3IgKGk9MCwgaj0wLCBuPWEubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKCFtLmhhc093blByb3BlcnR5KGsoYVtpXSkpKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdW5pcXVlIGtleSwgbWFyayB0dXBsZXMgZGlyZWN0bHlcbiAgICBmb3IgKGk9MCwgbj1yLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIHJbaV1bUkVNXSA9IDE7XG4gICAgfVxuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIWFbaV1bUkVNXSkgeyB4W2orK10gPSBhW2ldOyB9XG4gICAgfVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZGVsZXRlIHJbaV1bUkVNXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9yZW0gPSBbXTtcbiAgcmV0dXJuICh0aGlzLl9hZGQgPSB4KTtcbn07XG5cbi8vIG1lbW9pemluZyBzdGF0aXN0aWNzIG1ldGhvZHNcblxucHJvdG8uZXh0ZW50ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fZXh0KSB7XG4gICAgdmFyIHYgPSB0aGlzLnZhbHVlcygpLFxuICAgICAgICBpID0gc3RhdHMuZXh0ZW50LmluZGV4KHYsIGdldCk7XG4gICAgdGhpcy5fZXh0ID0gW3ZbaVswXV0sIHZbaVsxXV1dO1xuICAgIHRoaXMuX2dldCA9IGdldDsgICAgXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V4dDtcbn07XG5cbnByb3RvLmFyZ21pbiA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5leHRlbnQoZ2V0KVswXTtcbn07XG5cbnByb3RvLmFyZ21heCA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbn07XG5cbnByb3RvLm1pbiA9IGZ1bmN0aW9uKGdldCkge1xuICB2YXIgbSA9IHRoaXMuZXh0ZW50KGdldClbMF07XG4gIHJldHVybiBtID8gZ2V0KG0pIDogK0luZmluaXR5O1xufTtcblxucHJvdG8ubWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiAtSW5maW5pdHk7XG59O1xuXG5wcm90by5xdWFydGlsZSA9IGZ1bmN0aW9uKGdldCkge1xuICBpZiAodGhpcy5fZ2V0ICE9PSBnZXQgfHwgIXRoaXMuX3EpIHtcbiAgICB0aGlzLl9xID0gc3RhdHMucXVhcnRpbGUodGhpcy52YWx1ZXMoKSwgZ2V0KTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7ICAgIFxuICB9XG4gIHJldHVybiB0aGlzLl9xO1xufTtcblxucHJvdG8ucTEgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVswXTtcbn07XG5cbnByb3RvLnEyID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMV07XG59O1xuXG5wcm90by5xMyA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzJdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9hZ2dyZWdhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGZsYXR0ZW4gYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXlcbiAgdmFyIGFyZ3MgPSBbXS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIHgpIHtcbiAgICByZXR1cm4gYS5jb25jYXQodXRpbC5hcnJheSh4KSk7XG4gIH0sIFtdKTtcbiAgLy8gY3JlYXRlIGFuZCByZXR1cm4gYW4gYWdncmVnYXRvclxuICByZXR1cm4gbmV3IEFnZ3JlZ2F0b3IoKVxuICAgIC5ncm91cGJ5KGFyZ3MpXG4gICAgLnN1bW1hcml6ZSh7JyonOid2YWx1ZXMnfSk7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciB0eXBlcyA9IHtcbiAgJ3ZhbHVlcyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YWx1ZXMnLFxuICAgIGluaXQ6ICdjZWxsLmNvbGxlY3QgPSB0cnVlOycsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS52YWx1ZXMoKScsIGlkeDogLTFcbiAgfSksXG4gICdjb3VudCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdjb3VudCcsXG4gICAgc2V0OiAgJ2NlbGwubnVtJ1xuICB9KSxcbiAgJ21pc3NpbmcnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWlzc2luZycsXG4gICAgc2V0OiAgJ3RoaXMubWlzc2luZydcbiAgfSksXG4gICd2YWxpZCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YWxpZCcsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQnXG4gIH0pLFxuICAnc3VtJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N1bScsXG4gICAgaW5pdDogJ3RoaXMuc3VtID0gMDsnLFxuICAgIGFkZDogICd0aGlzLnN1bSArPSB2OycsXG4gICAgcmVtOiAgJ3RoaXMuc3VtIC09IHY7JyxcbiAgICBzZXQ6ICAndGhpcy5zdW0nXG4gIH0pLFxuICAnbWVhbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtZWFuJyxcbiAgICBpbml0OiAndGhpcy5tZWFuID0gMDsnLFxuICAgIGFkZDogICd2YXIgZCA9IHYgLSB0aGlzLm1lYW47IHRoaXMubWVhbiArPSBkIC8gdGhpcy52YWxpZDsnLFxuICAgIHJlbTogICd2YXIgZCA9IHYgLSB0aGlzLm1lYW47IHRoaXMubWVhbiAtPSB0aGlzLnZhbGlkID8gZCAvIHRoaXMudmFsaWQgOiB0aGlzLm1lYW47JyxcbiAgICBzZXQ6ICAndGhpcy5tZWFuJ1xuICB9KSxcbiAgJ2F2ZXJhZ2UnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXZlcmFnZScsXG4gICAgc2V0OiAgJ3RoaXMubWVhbicsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlJyxcbiAgICBpbml0OiAndGhpcy5kZXYgPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuZGV2ICs9IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICByZW06ICAndGhpcy5kZXYgLT0gZCAqICh2IC0gdGhpcy5tZWFuKTsnLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IHRoaXMuZGV2IC8gKHRoaXMudmFsaWQtMSkgOiAwJyxcbiAgICByZXE6ICBbJ21lYW4nXSwgaWR4OiAxXG4gIH0pLFxuICAndmFyaWFuY2VwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlcCcsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQgPiAxID8gdGhpcy5kZXYgLyB0aGlzLnZhbGlkIDogMCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRldicsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQgPiAxID8gTWF0aC5zcXJ0KHRoaXMuZGV2IC8gKHRoaXMudmFsaWQtMSkpIDogMCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldnAnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXZwJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyBNYXRoLnNxcnQodGhpcy5kZXYgLyB0aGlzLnZhbGlkKSA6IDAnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnbWVkaWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lZGlhbicsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMih0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3ExJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ExJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnExKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTMnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTModGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdkaXN0aW5jdCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdkaXN0aW5jdCcsXG4gICAgc2V0OiAgJ3RoaXMuZGlzdGluY3QoY2VsbC5kYXRhLnZhbHVlcygpLCB0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtaW4nLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLmFyZ21pbiA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMuYXJnbWluID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21pbiA9IHRoaXMuYXJnbWluIHx8IGNlbGwuZGF0YS5hcmdtaW4odGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21pbiddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtYXgnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLmFyZ21heCA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21heCA9IHRoaXMuYXJnbWF4IHx8IGNlbGwuZGF0YS5hcmdtYXgodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21heCddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaW4nLFxuICAgIGluaXQ6ICd0aGlzLm1pbiA9ICtJbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLm1pbiA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMubWluID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWluID0gKGlzTmFOKHRoaXMubWluKSA/IGNlbGwuZGF0YS5taW4odGhpcy5nZXQpIDogdGhpcy5taW4pJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWF4JyxcbiAgICBpbml0OiAndGhpcy5tYXggPSAtSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5tYXggPSB2OycsXG4gICAgcmVtOiAgJ2lmICh2ID49IHRoaXMubWF4KSB0aGlzLm1heCA9IE5hTjsnLFxuICAgIHNldDogICd0aGlzLm1heCA9IChpc05hTih0aGlzLm1heCkgPyBjZWxsLmRhdGEubWF4KHRoaXMuZ2V0KSA6IHRoaXMubWF4KScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbW9kZXNrZXcnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbW9kZXNrZXcnLFxuICAgIHNldDogICd0aGlzLmRldj09PTAgPyAwIDogKHRoaXMubWVhbiAtIGNlbGwuZGF0YS5xMih0aGlzLmdldCkpIC8gTWF0aC5zcXJ0KHRoaXMuZGV2Lyh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWydtZWFuJywgJ3N0ZGV2JywgJ21lZGlhbiddLCBpZHg6IDVcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIG1lYXN1cmUoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG0gPSB1dGlsLmV4dGVuZCh7aW5pdDonJywgYWRkOicnLCByZW06JycsIGlkeDowfSwgYmFzZSk7XG4gICAgbS5vdXQgPSBvdXQgfHwgYmFzZS5uYW1lO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZywgc3RyZWFtKSB7XG4gIGZ1bmN0aW9uIGNvbGxlY3QobSwgYSkge1xuICAgIGZ1bmN0aW9uIGhlbHBlcihyKSB7IGlmICghbVtyXSkgY29sbGVjdChtLCBtW3JdID0gdHlwZXNbcl0oKSk7IH1cbiAgICBpZiAoYS5yZXEpIGEucmVxLmZvckVhY2goaGVscGVyKTtcbiAgICBpZiAoc3RyZWFtICYmIGEuc3RyKSBhLnN0ci5mb3JFYWNoKGhlbHBlcik7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgdmFyIG1hcCA9IGFnZy5yZWR1Y2UoXG4gICAgY29sbGVjdCxcbiAgICBhZ2cucmVkdWNlKGZ1bmN0aW9uKG0sIGEpIHsgcmV0dXJuIChtW2EubmFtZV0gPSBhLCBtKTsgfSwge30pXG4gICk7XG4gIHJldHVybiB1dGlsLnZhbHMobWFwKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoYWdnLCBzdHJlYW0sIGFjY2Vzc29yLCBtdXRhdG9yKSB7XG4gIHZhciBhbGwgPSByZXNvbHZlKGFnZywgc3RyZWFtKSxcbiAgICAgIGN0ciA9ICd0aGlzLmNlbGwgPSBjZWxsOyB0aGlzLnR1cGxlID0gdDsgdGhpcy52YWxpZCA9IDA7IHRoaXMubWlzc2luZyA9IDA7JyxcbiAgICAgIGFkZCA9ICdpZiAodj09bnVsbCkgdGhpcy5taXNzaW5nKys7IGlmICghdGhpcy5pc1ZhbGlkKHYpKSByZXR1cm47ICsrdGhpcy52YWxpZDsnLFxuICAgICAgcmVtID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmctLTsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgLS10aGlzLnZhbGlkOycsXG4gICAgICBzZXQgPSAndmFyIHQgPSB0aGlzLnR1cGxlOyB2YXIgY2VsbCA9IHRoaXMuY2VsbDsnO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYS5pZHggPCAwKSB7XG4gICAgICBjdHIgPSBhLmluaXQgKyBjdHI7XG4gICAgICBhZGQgPSBhLmFkZCArIGFkZDtcbiAgICAgIHJlbSA9IGEucmVtICsgcmVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHIgKz0gYS5pbml0O1xuICAgICAgYWRkICs9IGEuYWRkO1xuICAgICAgcmVtICs9IGEucmVtO1xuICAgIH1cbiAgfSk7XG4gIGFnZy5zbGljZSgpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBzZXQgKz0gJ3RoaXMuYXNzaWduKHQsXFwnJythLm91dCsnXFwnLCcrYS5zZXQrJyk7JztcbiAgICB9KTtcbiAgc2V0ICs9ICdyZXR1cm4gdDsnO1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIGN0ciA9IEZ1bmN0aW9uKCdjZWxsJywgJ3QnLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFzc2lnbiA9IG11dGF0b3I7XG4gIGN0ci5wcm90b3R5cGUuYWRkID0gRnVuY3Rpb24oJ3QnLCAndmFyIHYgPSB0aGlzLmdldCh0KTsnICsgYWRkKTtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKHNldCk7XG4gIGN0ci5wcm90b3R5cGUuZ2V0ID0gYWNjZXNzb3I7XG4gIGN0ci5wcm90b3R5cGUuZGlzdGluY3QgPSByZXF1aXJlKCcuLi9zdGF0cycpLmNvdW50LmRpc3RpbmN0O1xuICBjdHIucHJvdG90eXBlLmlzVmFsaWQgPSB1dGlsLmlzVmFsaWQ7XG4gIGN0ci5maWVsZHMgPSBhZ2cubWFwKHV0aWwuJCgnb3V0JykpO1xuICByZXR1cm4gY3RyO1xufVxuXG50eXBlcy5jcmVhdGUgPSBjcmVhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIHRpbWUgPSByZXF1aXJlKCcuLi90aW1lJyksXG4gICAgRVBTSUxPTiA9IDFlLTE1O1xuXG5mdW5jdGlvbiBiaW5zKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgYmlubmluZyBvcHRpb25zLlwiKTsgfVxuXG4gIC8vIGRldGVybWluZSByYW5nZVxuICB2YXIgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDE1LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sICAgICAgXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwLCBsZXZlbCwgbWluc3RlcCwgcHJlY2lzaW9uLCB2LCBpLCBlcHM7XG5cbiAgaWYgKG9wdC5zdGVwKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgIG9wdC5zdGVwcy5sZW5ndGggLSAxLFxuICAgICAgYmlzZWN0KG9wdC5zdGVwcywgc3Bhbi9tYXhiLCAwLCBvcHQuc3RlcHMubGVuZ3RoKVxuICAgICldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IG9wdC5taW5zdGVwIHx8IDA7XG4gICAgc3RlcCA9IE1hdGgubWF4KFxuICAgICAgbWluc3RlcCxcbiAgICAgIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coc3BhbikgLyBsb2diKSAtIGxldmVsKVxuICAgICk7XG4gICAgXG4gICAgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcbiAgICBkbyB7IHN0ZXAgKj0gYmFzZTsgfSB3aGlsZSAoTWF0aC5jZWlsKHNwYW4vc3RlcCkgPiBtYXhiKTtcblxuICAgIC8vIGRlY3JlYXNlIHN0ZXAgc2l6ZSBpZiBhbGxvd2VkXG4gICAgZm9yIChpPTA7IGk8ZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcCk7XG4gIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbWluLFxuICAgIHN0b3A6ICBtYXgsXG4gICAgc3RlcDogIHN0ZXAsXG4gICAgdW5pdDogIHtwcmVjaXNpb246IHByZWNpc2lvbn0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGluZGV4OiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdmFsdWUodikge1xuICByZXR1cm4gdGhpcy5zdGVwICogTWF0aC5mbG9vcih2IC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHYpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHYgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBkYXRlX3ZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMudW5pdC5kYXRlKHZhbHVlLmNhbGwodGhpcywgdikpO1xufVxuXG5mdW5jdGlvbiBkYXRlX2luZGV4KHYpIHtcbiAgcmV0dXJuIGluZGV4LmNhbGwodGhpcywgdGhpcy51bml0LnVuaXQodikpO1xufVxuXG5iaW5zLmRhdGUgPSBmdW5jdGlvbihvcHQpIHtcbiAgaWYgKCFvcHQpIHsgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGRhdGUgYmlubmluZyBvcHRpb25zLlwiKTsgfVxuXG4gIC8vIGZpbmQgdGltZSBzdGVwLCB0aGVuIGJpblxuICB2YXIgdW5pdHMgPSBvcHQudXRjID8gdGltZS51dGMgOiB0aW1lLFxuICAgICAgZG1pbiA9IG9wdC5taW4sXG4gICAgICBkbWF4ID0gb3B0Lm1heCxcbiAgICAgIG1heGIgPSBvcHQubWF4YmlucyB8fCAyMCxcbiAgICAgIG1pbmIgPSBvcHQubWluYmlucyB8fCA0LFxuICAgICAgc3BhbiA9ICgrZG1heCkgLSAoK2RtaW4pLFxuICAgICAgdW5pdCA9IG9wdC51bml0ID8gdW5pdHNbb3B0LnVuaXRdIDogdW5pdHMuZmluZChzcGFuLCBtaW5iLCBtYXhiKSxcbiAgICAgIHNwZWMgPSBiaW5zKHtcbiAgICAgICAgbWluOiAgICAgdW5pdC5taW4gIT0gbnVsbCA/IHVuaXQubWluIDogdW5pdC51bml0KGRtaW4pLFxuICAgICAgICBtYXg6ICAgICB1bml0Lm1heCAhPSBudWxsID8gdW5pdC5tYXggOiB1bml0LnVuaXQoZG1heCksXG4gICAgICAgIG1heGJpbnM6IG1heGIsXG4gICAgICAgIG1pbnN0ZXA6IHVuaXQubWluc3RlcCxcbiAgICAgICAgc3RlcHM6ICAgdW5pdC5zdGVwXG4gICAgICB9KTtcblxuICBzcGVjLnVuaXQgPSB1bml0O1xuICBzcGVjLmluZGV4ID0gZGF0ZV9pbmRleDtcbiAgaWYgKCFvcHQucmF3KSBzcGVjLnZhbHVlID0gZGF0ZV92YWx1ZTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbnM7XG4iLCJ2YXIgYmlucyA9IHJlcXVpcmUoJy4vYmlucycpLFxuICAgIGdlbiAgPSByZXF1aXJlKCcuLi9nZW5lcmF0ZScpLFxuICAgIHR5cGUgPSByZXF1aXJlKCcuLi9pbXBvcnQvdHlwZScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgcXR5cGUgPSB7XG4gICdpbnRlZ2VyJzogMSxcbiAgJ251bWJlcic6IDEsXG4gICdkYXRlJzogMVxufTtcblxuZnVuY3Rpb24gJGJpbih2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiAhYiA/IChvcHQuYWNjZXNzb3IgfHwgdXRpbC5pZGVudGl0eSkgOlxuICAgIHV0aWwuJGZ1bmMoJ2JpbicsIGIudW5pdC51bml0ID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoYi51bml0LnVuaXQoeCkpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoeCk7IH1cbiAgICApKG9wdC5hY2Nlc3Nvcik7XG59XG5cbmZ1bmN0aW9uIGhpc3RvZ3JhbSh2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiBiID9cbiAgICBudW1lcmljYWwodmFsdWVzLCBvcHQuYWNjZXNzb3IsIGIpIDpcbiAgICBjYXRlZ29yaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3Nvciwgb3B0ICYmIG9wdC5zb3J0KTtcbn1cblxuZnVuY3Rpb24gc3BlYyhvcHQpIHtcbiAgdmFyIHQgPSBvcHQudHlwZSwgYiA9IG51bGw7XG4gIGlmICh0ID09IG51bGwgfHwgcXR5cGVbdF0pIHtcbiAgICBpZiAodCA9PT0gJ2ludGVnZXInICYmIG9wdC5taW5zdGVwID09IG51bGwpIG9wdC5taW5zdGVwID0gMTtcbiAgICBiID0gKHQgPT09ICdkYXRlJykgPyBiaW5zLmRhdGUob3B0KSA6IGJpbnMob3B0KTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICBpID0gMCxcbiAgICAgIHZhbHVlcyA9IHV0aWwuaXNBcnJheShhW2ldKSA/IGFbaSsrXSA6IG51bGwsXG4gICAgICBmID0gdXRpbC5pc0Z1bmN0aW9uKGFbaV0pIHx8IHV0aWwuaXNTdHJpbmcoYVtpXSkgPyB1dGlsLiQoYVtpKytdKSA6IG51bGwsXG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7fSwgYVtpXSk7XG4gIFxuICBpZiAodmFsdWVzKSB7XG4gICAgb3B0LnR5cGUgPSBvcHQudHlwZSB8fCB0eXBlKHZhbHVlcywgZik7XG4gICAgaWYgKHF0eXBlW29wdC50eXBlXSkge1xuICAgICAgdmFyIGV4dCA9IHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpO1xuICAgICAgb3B0ID0gdXRpbC5leHRlbmQoe21pbjogZXh0WzBdLCBtYXg6IGV4dFsxXX0sIG9wdCk7XG4gICAgfVxuICB9XG4gIGlmIChmKSB7IG9wdC5hY2Nlc3NvciA9IGY7IH1cbiAgcmV0dXJuIG9wdDtcbn1cblxuZnVuY3Rpb24gbnVtZXJpY2FsKHZhbHVlcywgZiwgYikge1xuICB2YXIgaCA9IGdlbi5yYW5nZShiLnN0YXJ0LCBiLnN0b3AgKyBiLnN0ZXAvMiwgYi5zdGVwKVxuICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4ge3ZhbHVlOiBiLnZhbHVlKHYpLCBjb3VudDogMH07IH0pO1xuXG4gIGZvciAodmFyIGk9MCwgdiwgajsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBqID0gYi5pbmRleCh2KTtcbiAgICAgIGlmIChqIDwgMCB8fCBqID49IGgubGVuZ3RoIHx8ICFpc0Zpbml0ZShqKSkgY29udGludWU7XG4gICAgICBoW2pdLmNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIGguYmlucyA9IGI7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBjYXRlZ29yaWNhbCh2YWx1ZXMsIGYsIHNvcnQpIHtcbiAgdmFyIHUgPSBzdGF0cy51bmlxdWUodmFsdWVzLCBmKSxcbiAgICAgIGMgPSBzdGF0cy5jb3VudC5tYXAodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHUubWFwKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHt2YWx1ZTogaywgY291bnQ6IGNba119OyB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcihzb3J0ID8gJy1jb3VudCcgOiAnK3ZhbHVlJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJGJpbjogJGJpbixcbiAgaGlzdG9ncmFtOiBoaXN0b2dyYW1cbn07IiwidmFyIGQzX3RpbWUgPSByZXF1aXJlKCdkMy10aW1lJyksXG4gICAgZDNfdGltZUYgPSByZXF1aXJlKCdkMy10aW1lLWZvcm1hdCcpLFxuICAgIGQzX251bWJlckYgPSByZXF1aXJlKCdkMy1mb3JtYXQnKSxcbiAgICBudW1iZXJGID0gZDNfbnVtYmVyRiwgLy8gZGVmYXVsdHMgdG8gRU4tVVNcbiAgICB0aW1lRiA9IGQzX3RpbWVGOyAgICAgLy8gZGVmYXVsdHMgdG8gRU4tVVNcblxuZnVuY3Rpb24gbnVtYmVyTG9jYWxlKGwpIHtcbiAgdmFyIGYgPSBkM19udW1iZXJGLmxvY2FsZUZvcm1hdChsKTtcbiAgaWYgKGYgPT0gbnVsbCkgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCBsb2NhbGU6ICcgKyBsKTtcbiAgbnVtYmVyRiA9IGY7XG59XG5cbmZ1bmN0aW9uIHRpbWVMb2NhbGUobCkge1xuICB2YXIgZiA9IGQzX3RpbWVGLmxvY2FsZUZvcm1hdChsKTtcbiAgaWYgKGYgPT0gbnVsbCkgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCBsb2NhbGU6ICcgKyBsKTtcbiAgdGltZUYgPSBmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVXBkYXRlIG51bWJlciBmb3JtYXR0ZXIgdG8gdXNlIHByb3ZpZGVkIGxvY2FsZSBjb25maWd1cmF0aW9uLlxuICAvLyBGb3IgbW9yZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWZvcm1hdFxuICBudW1iZXJMb2NhbGU6IG51bWJlckxvY2FsZSxcbiAgbnVtYmVyOiAgICAgICBmdW5jdGlvbihmKSB7IHJldHVybiBudW1iZXJGLmZvcm1hdChmKTsgfSxcbiAgbnVtYmVyUHJlZml4OiBmdW5jdGlvbihmLCB2KSB7IHJldHVybiBudW1iZXJGLmZvcm1hdFByZWZpeChmLCB2KTsgfSxcblxuICAvLyBVcGRhdGUgdGltZSBmb3JtYXR0ZXIgdG8gdXNlIHByb3ZpZGVkIGxvY2FsZSBjb25maWd1cmF0aW9uLlxuICAvLyBGb3IgbW9yZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0XG4gIHRpbWVMb2NhbGU6ICAgdGltZUxvY2FsZSxcbiAgdGltZTogICAgICAgICBmdW5jdGlvbihmKSB7IHJldHVybiB0aW1lRi5mb3JtYXQoZik7IH0sICBcbiAgdXRjOiAgICAgICAgICBmdW5jdGlvbihmKSB7IHJldHVybiB0aW1lRi51dGNGb3JtYXQoZik7IH0sXG5cbiAgLy8gU2V0IG51bWJlciBhbmQgdGltZSBsb2NhbGUgc2ltdWx0YW5lb3VzbHkuXG4gIGxvY2FsZTogICAgICAgZnVuY3Rpb24obCkgeyBudW1iZXJMb2NhbGUobCk7IHRpbWVMb2NhbGUobCk7IH0sXG5cbiAgLy8gYXV0b21hdGljIGZvcm1hdHRpbmcgZnVuY3Rpb25zXG4gIGF1dG86IHtcbiAgICBudW1iZXI6ICAgbnVtYmVyQXV0b0Zvcm1hdCxcbiAgICB0aW1lOiAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aW1lQXV0b0Zvcm1hdCgpOyB9LFxuICAgIHV0YzogICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHV0Y0F1dG9Gb3JtYXQoKTsgfVxuICB9XG59O1xuXG52YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIGludGVydmFscyhkb21haW4sIGNvdW50KSB7XG4gIGlmICghZG9tYWluLmxlbmd0aCkgZG9tYWluID0gWzBdO1xuICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sXG4gICAgICBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcblxuICBpZiAoc3RvcCA8IHN0YXJ0KSB7IGVycm9yID0gc3RvcDsgc3RvcCA9IHN0YXJ0OyBzdGFydCA9IGVycm9yOyB9XG5cbiAgdmFyIHNwYW4gPSAoc3RvcCAtIHN0YXJ0KSB8fCAoY291bnQgPSAxLCBzdGFydCB8fCBzdG9wIHx8IDEpLFxuICAgICAgc3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHNwYW4gLyBjb3VudCkgLyBNYXRoLkxOMTApKSxcbiAgICAgIGVycm9yID0gc3BhbiAvIGNvdW50IC8gc3RlcDtcblxuICAvLyBGaWx0ZXIgdGlja3MgdG8gZ2V0IGNsb3NlciB0byB0aGUgZGVzaXJlZCBjb3VudC5cbiAgaWYgKGVycm9yID49IGUxMCkgc3RlcCAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAgKj0gMjtcblxuICAvLyBSb3VuZCBzdGFydCBhbmQgc3RvcCB2YWx1ZXMgdG8gc3RlcCBpbnRlcnZhbC5cbiAgcmV0dXJuIFtcbiAgICBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXAsXG4gICAgTWF0aC5mbG9vcihzdG9wIC8gc3RlcCkgKiBzdGVwICsgc3RlcCAvIDIsIC8vIGluY2x1c2l2ZVxuICAgIHN0ZXBcbiAgXTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyQXV0b0Zvcm1hdChkb21haW4sIGNvdW50LCBmKSB7XG4gIHZhciByYW5nZSA9IGludGVydmFscyhkb21haW4sIGNvdW50KTtcbiAgaWYgKGYgPT0gbnVsbCkge1xuICAgIGYgPSAnLC4nICsgZDNfbnVtYmVyRi5wcmVjaXNpb25GaXhlZChyYW5nZVsyXSkgKyAnZic7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChmID0gZDNfbnVtYmVyRi5mb3JtYXRTcGVjaWZpZXIoZiksIGYudHlwZSkge1xuICAgICAgY2FzZSAncyc6IHtcbiAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMocmFuZ2VbMF0pLCBNYXRoLmFicyhyYW5nZVsxXSkpO1xuICAgICAgICBpZiAoZi5wcmVjaXNpb24gPT0gbnVsbCkgZi5wcmVjaXNpb24gPSBkM19udW1iZXJGLnByZWNpc2lvblByZWZpeChyYW5nZVsyXSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbnVtYmVyRi5mb3JtYXRQcmVmaXgoZiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgY2FzZSAnJzpcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgY2FzZSAnZyc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3InOiB7XG4gICAgICAgIGlmIChmLnByZWNpc2lvbiA9PSBudWxsKSBmLnByZWNpc2lvbiA9IGQzX251bWJlckYucHJlY2lzaW9uUm91bmQocmFuZ2VbMl0sIE1hdGgubWF4KE1hdGguYWJzKHJhbmdlWzBdKSwgTWF0aC5hYnMocmFuZ2VbMV0pKSkgLSAoZi50eXBlID09PSAnZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2YnOlxuICAgICAgY2FzZSAnJSc6IHtcbiAgICAgICAgaWYgKGYucHJlY2lzaW9uID09IG51bGwpIGYucHJlY2lzaW9uID0gZDNfbnVtYmVyRi5wcmVjaXNpb25GaXhlZChyYW5nZVsyXSkgLSAoZi50eXBlID09PSAnJScpICogMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudW1iZXJGLmZvcm1hdChmKTtcbn1cblxuZnVuY3Rpb24gdGltZUF1dG9Gb3JtYXQoKSB7XG4gIHZhciBmID0gdGltZUYuZm9ybWF0LFxuICAgICAgZm9ybWF0TWlsbGlzZWNvbmQgPSBmKCcuJUwnKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGYoJzolUycpLFxuICAgICAgZm9ybWF0TWludXRlID0gZignJUk6JU0nKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmKCclSSAlcCcpLFxuICAgICAgZm9ybWF0RGF5ID0gZignJWEgJWQnKSxcbiAgICAgIGZvcm1hdFdlZWsgPSBmKCclYiAlZCcpLFxuICAgICAgZm9ybWF0TW9udGggPSBmKCclQicpLFxuICAgICAgZm9ybWF0WWVhciA9IGYoJyVZJyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZCA9ICtkYXRlO1xuICAgIHJldHVybiAoZDNfdGltZS5zZWNvbmQoZGF0ZSkgPCBkID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBkM190aW1lLm1pbnV0ZShkYXRlKSA8IGQgPyBmb3JtYXRTZWNvbmRcbiAgICAgICAgOiBkM190aW1lLmhvdXIoZGF0ZSkgPCBkID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZDNfdGltZS5kYXkoZGF0ZSkgPCBkID8gZm9ybWF0SG91clxuICAgICAgICA6IGQzX3RpbWUubW9udGgoZGF0ZSkgPCBkID9cbiAgICAgICAgICAoZDNfdGltZS53ZWVrKGRhdGUpIDwgZCA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogZDNfdGltZS55ZWFyKGRhdGUpIDwgZCA/IGZvcm1hdE1vbnRoXG4gICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHV0Y0F1dG9Gb3JtYXQoKSB7XG4gIHZhciBmID0gdGltZUYudXRjRm9ybWF0LFxuICAgICAgZm9ybWF0TWlsbGlzZWNvbmQgPSBmKCcuJUwnKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGYoJzolUycpLFxuICAgICAgZm9ybWF0TWludXRlID0gZignJUk6JU0nKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmKCclSSAlcCcpLFxuICAgICAgZm9ybWF0RGF5ID0gZignJWEgJWQnKSxcbiAgICAgIGZvcm1hdFdlZWsgPSBmKCclYiAlZCcpLFxuICAgICAgZm9ybWF0TW9udGggPSBmKCclQicpLFxuICAgICAgZm9ybWF0WWVhciA9IGYoJyVZJyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZCA9ICtkYXRlO1xuICAgIHJldHVybiAoZDNfdGltZS51dGNTZWNvbmQoZGF0ZSkgPCBkID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBkM190aW1lLnV0Y01pbnV0ZShkYXRlKSA8IGQgPyBmb3JtYXRTZWNvbmRcbiAgICAgICAgOiBkM190aW1lLnV0Y0hvdXIoZGF0ZSkgPCBkID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZDNfdGltZS51dGNEYXkoZGF0ZSkgPCBkID8gZm9ybWF0SG91clxuICAgICAgICA6IGQzX3RpbWUudXRjTW9udGgoZGF0ZSkgPCBkID9cbiAgICAgICAgICAoZDNfdGltZS51dGNXZWVrKGRhdGUpIDwgZCA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogZDNfdGltZS51dGNZZWFyKGRhdGUpIDwgZCA/IGZvcm1hdE1vbnRoXG4gICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gIH07XG59XG4iLCJ2YXIgZ2VuID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuZ2VuLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbCwgbikge1xuICB2YXIgYSA9IEFycmF5KG4pLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIGFbaV0gPSB2YWw7XG4gIHJldHVybiBhO1xufTtcblxuZ2VuLnplcm9zID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gZ2VuLnJlcGVhdCgwLCBuKTtcbn07XG5cbmdlbi5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHN0ZXAgPSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHJhbmdlJyk7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbmdlbi5yYW5kb20gPSB7fTtcblxuZ2VuLnJhbmRvbS51bmlmb3JtID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4ID0gbWluID09PSB1bmRlZmluZWQgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgdmFyIGQgPSBtYXggLSBtaW47XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1pbiArIGQgKiBNYXRoLnJhbmRvbSgpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20uaW50ZWdlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgIGIgPSBhO1xuICAgIGEgPSAwO1xuICB9XG4gIHZhciBkID0gYiAtIGE7XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEgKyBNYXRoLmZsb29yKGQgKiBNYXRoLnJhbmRvbSgpKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgfHwgMTtcbiAgdmFyIG5leHQ7XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSAwLCB5ID0gMCwgcmRzLCBjO1xuICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHggPSBuZXh0O1xuICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBkbyB7XG4gICAgICB4ID0gTWF0aC5yYW5kb20oKSoyLTE7XG4gICAgICB5ID0gTWF0aC5yYW5kb20oKSoyLTE7XG4gICAgICByZHMgPSB4KnggKyB5Knk7XG4gICAgfSB3aGlsZSAocmRzID09PSAwIHx8IHJkcyA+IDEpO1xuICAgIGMgPSBNYXRoLnNxcnQoLTIqTWF0aC5sb2cocmRzKS9yZHMpOyAvLyBCb3gtTXVsbGVyIHRyYW5zZm9ybVxuICAgIG5leHQgPSBtZWFuICsgeSpjKnN0ZGV2O1xuICAgIHJldHVybiBtZWFuICsgeCpjKnN0ZGV2O1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgZDNfZHN2ID0gcmVxdWlyZSgnZDMtZHN2Jyk7XG5cbmZ1bmN0aW9uIGRzdihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICB2YXIgaCA9IGZvcm1hdC5oZWFkZXI7XG4gICAgZGF0YSA9IChoID8gaC5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgOiAnJykgKyBkYXRhO1xuICB9XG4gIHJldHVybiBkM19kc3YuZHN2KGZvcm1hdC5kZWxpbWl0ZXIpLnBhcnNlKGRhdGEpO1xufVxuXG5kc3YuZGVsaW1pdGVyID0gZnVuY3Rpb24oZGVsaW0pIHtcbiAgdmFyIGZtdCA9IHtkZWxpbWl0ZXI6IGRlbGltfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gdXRpbC5leHRlbmQoZm9ybWF0LCBmbXQpIDogZm10KTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZHN2OyIsInZhciBkc3YgPSByZXF1aXJlKCcuL2RzdicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganNvbjogcmVxdWlyZSgnLi9qc29uJyksXG4gIHRvcG9qc29uOiByZXF1aXJlKCcuL3RvcG9qc29uJyksXG4gIHRyZWVqc29uOiByZXF1aXJlKCcuL3RyZWVqc29uJyksXG4gIGRzdjogZHN2LFxuICBjc3Y6IGRzdi5kZWxpbWl0ZXIoJywnKSxcbiAgdHN2OiBkc3YuZGVsaW1pdGVyKCdcXHQnKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSB1dGlsLmlzT2JqZWN0KGRhdGEpICYmICF1dGlsLmlzQnVmZmVyKGRhdGEpID9cbiAgICBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkpIHtcbiAgICBkID0gdXRpbC5hY2Nlc3Nvcihmb3JtYXQucHJvcGVydHkpKGQpO1xuICB9XG4gIHJldHVybiBkO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG5cbnZhciByZWFkZXIgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHRvcG9qc29uID0gcmVhZGVyLnRvcG9qc29uO1xuICBpZiAodG9wb2pzb24gPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignVG9wb0pTT04gbGlicmFyeSBub3QgbG9hZGVkLicpOyB9XG5cbiAgdmFyIHQgPSBqc29uKGRhdGEsIGZvcm1hdCksIG9iajtcblxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5mZWF0dXJlKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0LmZlYXR1cmVdKSkge1xuICAgICAgcmV0dXJuIHRvcG9qc29uLmZlYXR1cmUodCwgb2JqKS5mZWF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnICsgZm9ybWF0LmZlYXR1cmUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmb3JtYXQgJiYgZm9ybWF0Lm1lc2gpIHtcbiAgICBpZiAoKG9iaiA9IHQub2JqZWN0c1tmb3JtYXQubWVzaF0pKSB7XG4gICAgICByZXR1cm4gW3RvcG9qc29uLm1lc2godCwgdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6ICcgKyBmb3JtYXQubWVzaCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdNaXNzaW5nIFRvcG9KU09OIGZlYXR1cmUgb3IgbWVzaCBwYXJhbWV0ZXIuJyk7XG4gIH1cbn07XG5cbnJlYWRlci50b3BvanNvbiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd0b3BvanNvbiddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndG9wb2pzb24nXSA6IG51bGwpO1xubW9kdWxlLmV4cG9ydHMgPSByZWFkZXI7IiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgZGF0YSA9IGpzb24oZGF0YSwgZm9ybWF0KTtcbiAgcmV0dXJuIHRvVGFibGUoZGF0YSwgKGZvcm1hdCAmJiBmb3JtYXQuY2hpbGRyZW4pKTtcbn07XG5cbmZ1bmN0aW9uIHRvVGFibGUocm9vdCwgY2hpbGRyZW5GaWVsZCkge1xuICBjaGlsZHJlbkZpZWxkID0gY2hpbGRyZW5GaWVsZCB8fCAnY2hpbGRyZW4nO1xuICB2YXIgdGFibGUgPSBbXTtcbiAgXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICB0YWJsZS5wdXNoKG5vZGUpO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGVbY2hpbGRyZW5GaWVsZF07XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmlzaXQoY2hpbGRyZW5baV0sIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgdmlzaXQocm9vdCwgbnVsbCk7XG4gIHJldHVybiAodGFibGUucm9vdCA9IHJvb3QsIHRhYmxlKTtcbn0iLCIvLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG52YXIgcHJvdG9jb2xfcmUgPSAvXihbQS1aYS16XSs6KT9cXC9cXC8vO1xuXG4vLyBTcGVjaWFsIHRyZWF0bWVudCBpbiBub2RlLmpzIGZvciB0aGUgZmlsZTogcHJvdG9jb2xcbnZhciBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8vIFZhbGlkYXRlIGFuZCBjbGVhbnVwIFVSTCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGJlIGFjY2Vzc2VkXG4vLyBSZXR1cm5zIGNsZWFuZWQgdXAgVVJMLCBvciBmYWxzZSBpZiBhY2Nlc3MgaXMgbm90IGFsbG93ZWRcbmZ1bmN0aW9uIHNhbml0aXplVXJsKG9wdCkge1xuICB2YXIgdXJsID0gb3B0LnVybDtcbiAgaWYgKCF1cmwgJiYgb3B0LmZpbGUpIHsgcmV0dXJuIGZpbGVQcm90b2NvbCArIG9wdC5maWxlOyB9XG5cbiAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVsYXRpdmUgdXJsIChoYXMgbm8gaG9zdCksIHByZXBlbmQgb3B0LmJhc2VVUkxcbiAgaWYgKG9wdC5iYXNlVVJMICYmICFwcm90b2NvbF9yZS50ZXN0KHVybCkpIHtcbiAgICBpZiAoIXN0YXJ0c1dpdGgodXJsLCAnLycpICYmIG9wdC5iYXNlVVJMW29wdC5iYXNlVVJMLmxlbmd0aC0xXSAhPT0gJy8nKSB7XG4gICAgICB1cmwgPSAnLycgKyB1cmw7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIH1cbiAgICB1cmwgPSBvcHQuYmFzZVVSTCArIHVybDtcbiAgfVxuICAvLyByZWxhdGl2ZSBwcm90b2NvbCwgc3RhcnRzIHdpdGggJy8vJ1xuICBpZiAoIWxvYWQudXNlWEhSICYmIHN0YXJ0c1dpdGgodXJsLCAnLy8nKSkge1xuICAgIHVybCA9IChvcHQuZGVmYXVsdFByb3RvY29sIHx8ICdodHRwJykgKyAnOicgKyB1cmw7XG4gIH1cbiAgLy8gSWYgb3B0LmRvbWFpbldoaXRlTGlzdCBpcyBzZXQsIG9ubHkgYWxsb3dzIHVybCwgd2hvc2UgaG9zdG5hbWVcbiAgLy8gKiBJcyB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpXG4gIC8vICogRXF1YWxzIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgLy8gKiBJcyBhIHByb3BlciBzdWJkb21haW4gb2Ygb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICBpZiAob3B0LmRvbWFpbldoaXRlTGlzdCkge1xuICAgIHZhciBkb21haW4sIG9yaWdpbjtcbiAgICBpZiAobG9hZC51c2VYSFIpIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNjUxMy9ob3ctZG8taS1wYXJzZS1hLXVybC1pbnRvLWhvc3RuYW1lLWFuZC1wYXRoLWluLWphdmFzY3JpcHRcbiAgICAgIC8vIElFIGRvZXNuJ3QgcG9wdWxhdGUgYWxsIGxpbmsgcHJvcGVydGllcyB3aGVuIHNldHRpbmcgLmhyZWYgd2l0aCBhIHJlbGF0aXZlIFVSTCxcbiAgICAgIC8vIGhvd2V2ZXIgLmhyZWYgd2lsbCByZXR1cm4gYW4gYWJzb2x1dGUgVVJMIHdoaWNoIHRoZW4gY2FuIGJlIHVzZWQgb24gaXRzZWxmXG4gICAgICAvLyB0byBwb3B1bGF0ZSB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICAgIGlmIChhLmhvc3QgPT09ICcnKSB7XG4gICAgICAgIGEuaHJlZiA9IGEuaHJlZjtcbiAgICAgIH1cbiAgICAgIGRvbWFpbiA9IGEuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVsYXRpdmUgcHJvdG9jb2wgaXMgYnJva2VuOiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXVybC9pc3N1ZXMvNVxuICAgICAgdmFyIHBhcnRzID0gcmVxdWlyZSgndXJsJykucGFyc2UodXJsKTtcbiAgICAgIGRvbWFpbiA9IHBhcnRzLmhvc3RuYW1lO1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3JpZ2luICE9PSBkb21haW4pIHtcbiAgICAgIHZhciB3aGl0ZUxpc3RlZCA9IG9wdC5kb21haW5XaGl0ZUxpc3Quc29tZShmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZSkgeyB0aHJvdyBlOyB9LCB1cmw7XG5cbiAgdHJ5IHtcbiAgICB1cmwgPSBsb2FkLnNhbml0aXplVXJsKG9wdCk7IC8vIGVuYWJsZSBvdmVycmlkZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcihlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgVVJMOiAnICsgb3B0LnVybCk7XG4gIH0gZWxzZSBpZiAobG9hZC51c2VYSFIpIHtcbiAgICAvLyBvbiBjbGllbnQsIHVzZSB4aHJcbiAgICByZXR1cm4geGhyKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodXJsLCBmaWxlUHJvdG9jb2wpKSB7XG4gICAgLy8gb24gc2VydmVyLCBpZiB1cmwgc3RhcnRzIHdpdGggJ2ZpbGU6Ly8nLCBzdHJpcCBpdCBhbmQgbG9hZCBmcm9tIGZpbGVcbiAgICByZXR1cm4gZmlsZSh1cmwuc2xpY2UoZmlsZVByb3RvY29sLmxlbmd0aCksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1cmwuaW5kZXhPZignOi8vJykgPCAwKSB7IC8vIFRPRE8gYmV0dGVyIHByb3RvY29sIGNoZWNrP1xuICAgIC8vIG9uIHNlcnZlciwgaWYgbm8gcHJvdG9jb2wgYXNzdW1lIGZpbGVcbiAgICByZXR1cm4gZmlsZSh1cmwsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmb3IgcmVndWxhciBVUkxzIG9uIHNlcnZlclxuICAgIHJldHVybiBodHRwKHVybCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gJ3RleHQnID9cbiAgICByZXF1ZXN0LnJlc3BvbnNlIDogLy8gbnVsbCBvbiBlcnJvclxuICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyAnJyBvbiBlcnJvclxufVxuXG5mdW5jdGlvbiB4aHIodXJsLCBjYWxsYmFjaykge1xuICB2YXIgYXN5bmMgPSAhIWNhbGxiYWNrO1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdCAoY29waWVkIGZyb20gZDMueGhyKVxuICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdCAmJlxuICAgICAgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzO1xuICAgIGlmICghc3RhdHVzICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlcXVlc3QsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3luYykge1xuICAgIGlmICgnb25sb2FkJyBpbiByZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPiAzKSByZXNwb25kKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcbiAgcmVxdWVzdC5zZW5kKCk7XG4gIFxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpO1xuICB9XG4gIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGh0dHAodXJsLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3N5bmMtcmVxdWVzdCcpKCdHRVQnLCB1cmwpLmdldEJvZHkoKTtcbiAgfVxuICBcbiAgdmFyIG9wdGlvbnMgPSB7dXJsOiB1cmwsIGVuY29kaW5nOiBudWxsLCBnemlwOiB0cnVlfTtcbiAgcmVxdWlyZSgncmVxdWVzdCcpKG9wdGlvbnMsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBlcnJvciB8fFxuICAgICAgICAnTG9hZCBmYWlsZWQgd2l0aCByZXNwb25zZSBjb2RlICcgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJy4nO1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gZmFsc2UgOiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbn1cblxubG9hZC5zYW5pdGl6ZVVybCA9IHNhbml0aXplVXJsO1xuXG5sb2FkLnVzZVhIUiA9ICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxuZnVuY3Rpb24gcmVhZChkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHR5cGUgPSAoZm9ybWF0ICYmIGZvcm1hdC50eXBlKSB8fCAnanNvbic7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIHR5cGVzID0gKHR5cGVzPT09J2F1dG8nKSA/IHR5cGUuaW5mZXJBbGwoZGF0YSkgOiB1dGlsLmR1cGxpY2F0ZSh0eXBlcyk7XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gdHlwZS5wYXJzZXJzW3R5cGVzW2NdXTsgfSk7XG5cbiAgZm9yIChpPTAsIGNsZW49Y29scy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3IgKGo9MDsgajxjbGVuOyArK2opIHtcbiAgICAgIGRbY29sc1tqXV0gPSBwYXJzZXJzW2pdKGRbY29sc1tqXV0pO1xuICAgIH1cbiAgfVxuICB0eXBlLmFubm90YXRpb24oZGF0YSwgdHlwZXMpO1xufVxuXG5yZWFkLmZvcm1hdHMgPSBmb3JtYXRzO1xubW9kdWxlLmV4cG9ydHMgPSByZWFkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbG9hZCA9IHJlcXVpcmUoJy4vbG9hZCcpO1xudmFyIHJlYWQgPSByZXF1aXJlKCcuL3JlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsXG4gIC5rZXlzKHJlYWQuZm9ybWF0cylcbiAgLnJlZHVjZShmdW5jdGlvbihvdXQsIHR5cGUpIHtcbiAgICBvdXRbdHlwZV0gPSBmdW5jdGlvbihvcHQsIGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIHByb2Nlc3MgYXJndW1lbnRzXG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhvcHQpKSB7IG9wdCA9IHt1cmw6IG9wdH07IH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHV0aWwuaXNGdW5jdGlvbihmb3JtYXQpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB1cCByZWFkIGZvcm1hdFxuICAgICAgZm9ybWF0ID0gdXRpbC5leHRlbmQoe3BhcnNlOiAnYXV0byd9LCBmb3JtYXQpO1xuICAgICAgZm9ybWF0LnR5cGUgPSB0eXBlO1xuXG4gICAgICAvLyBsb2FkIGRhdGFcbiAgICAgIHZhciBkYXRhID0gbG9hZChvcHQsIGNhbGxiYWNrID8gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7IGNhbGxiYWNrKGVycm9yLCBudWxsKTsgcmV0dXJuOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoYXN5bmMpXG4gICAgICAgICAgZGF0YSA9IHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoc3luYylcbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiByZWFkKGRhdGEsIGZvcm1hdCk7XG4gICAgfTtcbiAgICByZXR1cm4gb3V0O1xuICB9LCB7fSk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIFRZUEVTID0gJ19fdHlwZXNfXyc7XG5cbnZhciBQQVJTRVJTID0ge1xuICBib29sZWFuOiB1dGlsLmJvb2xlYW4sXG4gIGludGVnZXI6IHV0aWwubnVtYmVyLFxuICBudW1iZXI6ICB1dGlsLm51bWJlcixcbiAgZGF0ZTogICAgdXRpbC5kYXRlLFxuICBzdHJpbmc6ICBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09JycgPyBudWxsIDogeDsgfVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09J3RydWUnIHx8IHg9PT0nZmFsc2UnIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbihkYXRhLCB0eXBlcykge1xuICBpZiAoIXR5cGVzKSByZXR1cm4gZGF0YSAmJiBkYXRhW1RZUEVTXSB8fCBudWxsO1xuICBkYXRhW1RZUEVTXSA9IHR5cGVzO1xufVxuXG5mdW5jdGlvbiB0eXBlKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbjtcblxuICAvLyBpZiBkYXRhIGFycmF5IGhhcyB0eXBlIGFubm90YXRpb25zLCB1c2UgdGhlbVxuICBpZiAodmFsdWVzW1RZUEVTXSkge1xuICAgIHYgPSBmKHZhbHVlc1tUWVBFU10pO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHYpKSByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7ICF1dGlsLmlzVmFsaWQodikgJiYgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiB1dGlsLmlzRGF0ZSh2KSA/ICdkYXRlJyA6XG4gICAgdXRpbC5pc051bWJlcih2KSAgICA/ICdudW1iZXInIDpcbiAgICB1dGlsLmlzQm9vbGVhbih2KSAgID8gJ2Jvb2xlYW4nIDpcbiAgICB1dGlsLmlzU3RyaW5nKHYpICAgID8gJ3N0cmluZycgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0eXBlQWxsKGRhdGEsIGZpZWxkcykge1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm47XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgcmV0dXJuICh0eXBlc1tmXSA9IHR5cGUoZGF0YSwgZiksIHR5cGVzKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBpbmZlcih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIGosIHY7XG5cbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3IsIGluIHByZWNlZGVuY2Ugb3JkZXJcbiAgdmFyIHR5cGVzID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgbmV4dCB2YWx1ZSB0byB0ZXN0XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgLy8gdGVzdCB2YWx1ZSBhZ2FpbnN0IHJlbWFpbmluZyB0eXBlc1xuICAgIGZvciAoaj0wOyBqPHR5cGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodXRpbC5pc1ZhbGlkKHYpICYmICFURVNUU1t0eXBlc1tqXV0odikpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBqIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vIHR5cGVzIGxlZnQsIHJldHVybiAnc3RyaW5nJ1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHJldHVybiAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiB0eXBlc1swXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgdHlwZXNbZl0gPSBpbmZlcihkYXRhLCBmKTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxudHlwZS5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcbnR5cGUuYWxsID0gdHlwZUFsbDtcbnR5cGUuaW5mZXIgPSBpbmZlcjtcbnR5cGUuaW5mZXJBbGwgPSBpbmZlckFsbDtcbnR5cGUucGFyc2VycyA9IFBBUlNFUlM7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRsID0ge1xuICB2ZXJzaW9uOiAgICAnMS40LjYnLFxuICBsb2FkOiAgICAgICByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyksXG4gIHJlYWQ6ICAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L3JlYWQnKSxcbiAgdHlwZTogICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpLFxuICBBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yJyksXG4gIGdyb3VwYnk6ICAgIHJlcXVpcmUoJy4vYWdncmVnYXRlL2dyb3VwYnknKSxcbiAgYmluczogICAgICAgcmVxdWlyZSgnLi9iaW5zL2JpbnMnKSxcbiAgJGJpbjogICAgICAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLiRiaW4sXG4gIGhpc3RvZ3JhbTogIHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS5oaXN0b2dyYW0sXG4gIGZvcm1hdDogICAgIHJlcXVpcmUoJy4vZm9ybWF0JyksXG4gIHByaW50OiAgICAgIHJlcXVpcmUoJy4vcHJpbnQnKSxcbiAgdGVtcGxhdGU6ICAgcmVxdWlyZSgnLi90ZW1wbGF0ZScpLFxuICB0aW1lOiAgICAgICByZXF1aXJlKCcuL3RpbWUnKVxufTtcblxudXRpbC5leHRlbmQoZGwsIHV0aWwpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9zdGF0cycpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2ltcG9ydC9yZWFkZXJzJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRsOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxudmFyIEZNVCA9IHtcbiAgJ2RhdGUnOiAgICAnfHRpbWU6XCIlbS8lZC8lWSAlSDolTTolU1wiJyxcbiAgJ251bWJlcic6ICAnfG51bWJlcjpcIi40ZlwiJyxcbiAgJ2ludGVnZXInOiAnfG51bWJlcjpcImRcIidcbn07XG5cbnZhciBQT1MgPSB7XG4gICdudW1iZXInOiAgJ2xlZnQnLFxuICAnaW50ZWdlcic6ICdsZWZ0J1xufTtcblxubW9kdWxlLmV4cG9ydHMudGFibGUgPSBmdW5jdGlvbihkYXRhLCBvcHQpIHtcbiAgb3B0ID0gdXRpbC5leHRlbmQoe3NlcGFyYXRvcjonICcsIG1pbndpZHRoOiA4LCBtYXh3aWR0aDogMTV9LCBvcHQpO1xuICB2YXIgZmllbGRzID0gb3B0LmZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSksXG4gICAgICB0eXBlcyA9IHR5cGUuYWxsKGRhdGEpO1xuXG4gIGlmIChvcHQuc3RhcnQgfHwgb3B0LmxpbWl0KSB7XG4gICAgdmFyIGEgPSBvcHQuc3RhcnQgfHwgMCxcbiAgICAgICAgYiA9IG9wdC5saW1pdCA/IGEgKyBvcHQubGltaXQgOiBkYXRhLmxlbmd0aDtcbiAgICBkYXRhID0gZGF0YS5zbGljZShhLCBiKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBjaGFyIHdpZHRoIG9mIGZpZWxkc1xuICB2YXIgbGVucyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmb3JtYXQgPSBGTVRbdHlwZXNbbmFtZV1dIHx8ICcnLFxuICAgICAgICB0ID0gdGVtcGxhdGUoJ3t7JyArIG5hbWUgKyBmb3JtYXQgKyAnfX0nKSxcbiAgICAgICAgbCA9IHN0YXRzLm1heChkYXRhLCBmdW5jdGlvbih4KSB7IHJldHVybiB0KHgpLmxlbmd0aDsgfSk7XG4gICAgbCA9IE1hdGgubWF4KE1hdGgubWluKG5hbWUubGVuZ3RoLCBvcHQubWlud2lkdGgpLCBsKTtcbiAgICByZXR1cm4gb3B0Lm1heHdpZHRoID4gMCA/IE1hdGgubWluKGwsIG9wdC5tYXh3aWR0aCkgOiBsO1xuICB9KTtcblxuICAvLyBwcmludCBoZWFkZXIgcm93XG4gIHZhciBoZWFkID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIHV0aWwudHJ1bmNhdGUodXRpbC5wYWQobmFtZSwgbGVuc1tpXSwgJ2NlbnRlcicpLCBsZW5zW2ldKTtcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKTtcblxuICAvLyBidWlsZCB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgZWFjaCByb3dcbiAgdmFyIHRtcGwgPSB0ZW1wbGF0ZShmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gJ3t7JyArXG4gICAgICBuYW1lICtcbiAgICAgIChGTVRbdHlwZXNbbmFtZV1dIHx8ICcnKSArXG4gICAgICAoJ3xwYWQ6JyArIGxlbnNbaV0gKyAnLCcgKyAoUE9TW3R5cGVzW25hbWVdXSB8fCAncmlnaHQnKSkgK1xuICAgICAgKCd8dHJ1bmNhdGU6JyArIGxlbnNbaV0pICtcbiAgICAnfX0nO1xuICB9KS5qb2luKG9wdC5zZXBhcmF0b3IpKTtcblxuICAvLyBwcmludCB0YWJsZVxuICByZXR1cm4gaGVhZCArIFwiXFxuXCIgKyBkYXRhLm1hcCh0bXBsKS5qb2luKCdcXG4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN1bW1hcnkgPSBmdW5jdGlvbihzKSB7XG4gIHMgPSBzID8gcy5fX3N1bW1hcnlfXyA/IHMgOiBzdGF0cy5zdW1tYXJ5KHMpIDogdGhpcztcbiAgdmFyIHN0ciA9IFtdLCBpLCBuO1xuICBmb3IgKGk9MCwgbj1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBzdHIucHVzaCgnLS0gJyArIHNbaV0uZmllbGQgKyAnIC0tJyk7XG4gICAgaWYgKHNbaV0udHlwZSA9PT0gJ3N0cmluZycgfHwgc1tpXS5kaXN0aW5jdCA8IDEwKSB7XG4gICAgICBzdHIucHVzaChwcmludENhdGVnb3JpY2FsUHJvZmlsZShzW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ci5wdXNoKHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShzW2ldKSk7XG4gICAgfVxuICAgIHN0ci5wdXNoKCcnKTtcbiAgfVxuICByZXR1cm4gc3RyLmpvaW4oJ1xcbicpO1xufTtcblxuZnVuY3Rpb24gcHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHApIHtcbiAgcmV0dXJuIFtcbiAgICAndmFsaWQ6ICAgICcgKyBwLnZhbGlkLFxuICAgICdtaXNzaW5nOiAgJyArIHAubWlzc2luZyxcbiAgICAnZGlzdGluY3Q6ICcgKyBwLmRpc3RpbmN0LFxuICAgICdtaW46ICAgICAgJyArIHAubWluLFxuICAgICdtYXg6ICAgICAgJyArIHAubWF4LFxuICAgICdtZWRpYW46ICAgJyArIHAubWVkaWFuLFxuICAgICdtZWFuOiAgICAgJyArIHAubWVhbixcbiAgICAnc3RkZXY6ICAgICcgKyBwLnN0ZGV2LFxuICAgICdtb2Rlc2tldzogJyArIHAubW9kZXNrZXdcbiAgXS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUocCkge1xuICB2YXIgbGlzdCA9IFtcbiAgICAndmFsaWQ6ICAgICcgKyBwLnZhbGlkLFxuICAgICdtaXNzaW5nOiAgJyArIHAubWlzc2luZyxcbiAgICAnZGlzdGluY3Q6ICcgKyBwLmRpc3RpbmN0LFxuICAgICd0b3AgdmFsdWVzOiAnXG4gIF07XG4gIHZhciB1ID0gcC51bmlxdWU7XG4gIHZhciB0b3AgPSB1dGlsLmtleXModSlcbiAgICAuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIHVbYl0gLSB1W2FdOyB9KVxuICAgIC5zbGljZSgwLCA2KVxuICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gJyBcXCcnICsgdiArICdcXCcgKCcgKyB1W3ZdICsgJyknOyB9KTtcbiAgcmV0dXJuIGxpc3QuY29uY2F0KHRvcCkuam9pbignXFxuJyk7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcbnZhciBzdGF0cyA9IHt9O1xuXG4vLyBDb2xsZWN0IHVuaXF1ZSB2YWx1ZXMuXG4vLyBPdXRwdXQ6IGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIGZpcnN0LW9ic2VydmVkIG9yZGVyXG5zdGF0cy51bmlxdWUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHJlc3VsdHMpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgcmVzdWx0cy5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IGFycmF5Llxuc3RhdHMuY291bnQgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoIHx8IDA7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG5vbi1udWxsLCBub24tdW5kZWZpbmVkLCBub24tTmFOIHZhbHVlcy5cbnN0YXRzLmNvdW50LnZhbGlkID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCB2YWxpZCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgdmFsaWQgKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcy5cbnN0YXRzLmNvdW50Lm1pc3NpbmcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiA9PSBudWxsKSBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgZGlzdGluY3QgdmFsdWVzLlxuLy8gTnVsbCwgdW5kZWZpbmVkIGFuZCBOYU4gYXJlIGVhY2ggY29uc2lkZXJlZCBkaXN0aW5jdCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtYXAgZnJvbSBkaXN0aW5jdCB2YWx1ZXMgdG8gb2NjdXJyZW5jZSBjb3VudHMuXG5zdGF0cy5jb3VudC5tYXAgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1hcCA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIG1hcFt2XSA9ICh2IGluIG1hcCkgPyBtYXBbdl0gKyAxIDogMTtcbiAgfVxuICByZXR1cm4gbWFwO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICByZXR1cm4gc3RhdHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHF1YXJ0aWxlIGJvdW5kYXJpZXMgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnF1YXJ0aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIHEgPSBzdGF0cy5xdWFudGlsZTtcbiAgcmV0dXJuIFtxKHZhbHVlcywgMC4yNSksIHEodmFsdWVzLCAwLjUwKSwgcSh2YWx1ZXMsIDAuNzUpXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzdW0gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBmb3IgKHZhciBzdW09MCwgaT0wLCBuPXZhbHVlcy5sZW5ndGgsIHY7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgc3VtICs9IHY7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtZWFuID0gMCwgZGVsdGEsIGksIG4sIGMsIHY7XG4gIGZvciAoaT0wLCBjPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgTTIgPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBQZWFyc29uIG1vZGUgc2tld25lc3MgKChtZWRpYW4tbWVhbikvc3RkZXYpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tb2Rlc2tldyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYXZnID0gc3RhdHMubWVhbih2YWx1ZXMsIGYpLFxuICAgICAgbWVkID0gc3RhdHMubWVkaWFuKHZhbHVlcywgZiksXG4gICAgICBzdGQgPSBzdGF0cy5zdGRldih2YWx1ZXMsIGYpO1xuICByZXR1cm4gc3RkID09PSAwID8gMCA6IChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1pbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMF07XG59O1xuXG4vLyBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWF4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVsxXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gb2YgYW4gYXJyYXkgb2YgdmFsdWVzLlxuc3RhdHMuZXh0ZW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSBhID0gdjtcbiAgICAgIGlmICh2ID4gYikgYiA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYSwgYl07XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlZ2VyIGluZGljZXMgb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLlxuc3RhdHMuZXh0ZW50LmluZGV4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB4ID0gLTEsIHkgPSAtMSwgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyB4ID0geSA9IGk7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSB7IGEgPSB2OyB4ID0gaTsgfVxuICAgICAgaWYgKHYgPiBiKSB7IGIgPSB2OyB5ID0gaTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3gsIHldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuZG90ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBzdW0gPSAwLCBpLCB2O1xuICBpZiAoIWIpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKCdBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guJyk7XG4gICAgfVxuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHZhbHVlc1tpXSAqIGFbaV07XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBhKHZhbHVlc1tpXSkgKiBiKHZhbHVlc1tpXSk7XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZikgfHwgdXRpbC5pZGVudGl0eTtcbiAgdmFyIGEgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHJldHVybiB7aWR4OiBpLCB2YWw6IGYodil9O1xuICAgIH0pXG4gICAgLnNvcnQodXRpbC5jb21wYXJhdG9yKCd2YWwnKSk7XG5cbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgciA9IEFycmF5KG4pLFxuICAgICAgdGllID0gLTEsIHAgPSB7fSwgaSwgdiwgbXU7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGFbaV0udmFsO1xuICAgIGlmICh0aWUgPCAwICYmIHAgPT09IHYpIHtcbiAgICAgIHRpZSA9IGkgLSAxO1xuICAgIH0gZWxzZSBpZiAodGllID4gLTEgJiYgcCAhPT0gdikge1xuICAgICAgbXUgPSAxICsgKGktMSArIHRpZSkgLyAyO1xuICAgICAgZm9yICg7IHRpZTxpOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICAgICAgdGllID0gLTE7XG4gICAgfVxuICAgIHJbYVtpXS5pZHhdID0gaSArIDE7XG4gICAgcCA9IHY7XG4gIH1cblxuICBpZiAodGllID4gLTEpIHtcbiAgICBtdSA9IDEgKyAobi0xICsgdGllKSAvIDI7XG4gICAgZm9yICg7IHRpZTxuOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgUGVhcnNvbiBwcm9kdWN0LW1vbWVudCBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5jb3IgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIGZuID0gYjtcbiAgYiA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcbiAgYSA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGEpKSA6IHN0YXRzLnJhbmsodmFsdWVzKSxcbiAgICAgIHJiID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYikpIDogc3RhdHMucmFuayhhKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBpLCBzLCBkO1xuXG4gIGZvciAoaT0wLCBzPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IHJhW2ldIC0gcmJbaV07XG4gICAgcyArPSBkICogZDtcbiAgfVxuXG4gIHJldHVybiAxIC0gNipzIC8gKG4gKiAobipuLTEpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfY29ycmVsYXRpb25cbnN0YXRzLmNvci5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcblxuICB2YXIgQSA9IHN0YXRzLmRpc3QubWF0KFgpLFxuICAgICAgQiA9IHN0YXRzLmRpc3QubWF0KFkpLFxuICAgICAgbiA9IEEubGVuZ3RoLFxuICAgICAgaSwgYWEsIGJiLCBhYjtcblxuICBmb3IgKGk9MCwgYWE9MCwgYmI9MCwgYWI9MDsgaTxuOyArK2kpIHtcbiAgICBhYSArPSBBW2ldKkFbaV07XG4gICAgYmIgKz0gQltpXSpCW2ldO1xuICAgIGFiICs9IEFbaV0qQltpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoYWIgLyBNYXRoLnNxcnQoYWEqYmIpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHZlY3RvciBkaXN0YW5jZSBiZXR3ZWVuIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIERlZmF1bHQgaXMgRXVjbGlkZWFuIChleHA9MikgZGlzdGFuY2UsIGNvbmZpZ3VyYWJsZSB2aWEgZXhwIGFyZ3VtZW50Llxuc3RhdHMuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgZXhwKSB7XG4gIHZhciBmID0gdXRpbC5pc0Z1bmN0aW9uKGIpIHx8IHV0aWwuaXNTdHJpbmcoYiksXG4gICAgICBYID0gdmFsdWVzLFxuICAgICAgWSA9IGYgPyB2YWx1ZXMgOiBhLFxuICAgICAgZSA9IGYgPyBleHAgOiBiLFxuICAgICAgTDIgPSBlID09PSAyIHx8IGUgPT0gbnVsbCxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBzID0gMCwgZCwgaTtcbiAgaWYgKGYpIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gIH1cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IGYgPyAoYShYW2ldKS1iKFlbaV0pKSA6IChYW2ldLVlbaV0pO1xuICAgIHMgKz0gTDIgPyBkKmQgOiBNYXRoLnBvdyhNYXRoLmFicyhkKSwgZSk7XG4gIH1cbiAgcmV0dXJuIEwyID8gTWF0aC5zcXJ0KHMpIDogTWF0aC5wb3cocywgMS9lKTtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1lYW4tY2VudGVyZWQgZGlzdGFuY2UgbWF0cml4IGZvciBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuZGlzdC5tYXQgPSBmdW5jdGlvbihYKSB7XG4gIHZhciBuID0gWC5sZW5ndGgsXG4gICAgICBtID0gbipuLFxuICAgICAgQSA9IEFycmF5KG0pLFxuICAgICAgUiA9IGdlbi56ZXJvcyhuKSxcbiAgICAgIE0gPSAwLCB2LCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIEFbaSpuK2ldID0gMDtcbiAgICBmb3IgKGo9aSsxOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gPSAodiA9IE1hdGguYWJzKFhbaV0gLSBYW2pdKSk7XG4gICAgICBBW2oqbitpXSA9IHY7XG4gICAgICBSW2ldICs9IHY7XG4gICAgICBSW2pdICs9IHY7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgTSArPSBSW2ldO1xuICAgIFJbaV0gLz0gbjtcbiAgfVxuICBNIC89IG07XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZm9yIChqPWk7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSArPSBNIC0gUltpXSAtIFJbal07XG4gICAgICBBW2oqbitpXSA9IEFbaSpuK2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5ID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBwLCBzID0gMCwgSCA9IDAsIG4gPSBjb3VudHMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBzICs9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHAgPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSkgLyBzO1xuICAgIGlmIChwKSBIICs9IHAgKiBNYXRoLmxvZyhwKTtcbiAgfVxuICByZXR1cm4gLUggLyBNYXRoLkxOMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBmb3JtIFtNSSwgTUlfZGlzdGFuY2VdIFxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NdXR1YWxfaW5mb3JtYXRpb25cbnN0YXRzLm11dHVhbCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHZhciB4ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgeSA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGEsXG4gICAgICB6ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoY291bnRzKSkgOiBiO1xuXG4gIHZhciBweCA9IHt9LFxuICAgICAgcHkgPSB7fSxcbiAgICAgIG4gPSB6Lmxlbmd0aCxcbiAgICAgIHMgPSAwLCBJID0gMCwgSCA9IDAsIHAsIHQsIGk7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gPSAwO1xuICAgIHB5W3lbaV1dID0gMDtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dICs9IHpbaV07XG4gICAgcHlbeVtpXV0gKz0geltpXTtcbiAgICBzICs9IHpbaV07XG4gIH1cblxuICB0ID0gMSAvIChzICogTWF0aC5MTjIpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZiAoeltpXSA9PT0gMCkgY29udGludWU7XG4gICAgcCA9IChzICogeltpXSkgLyAocHhbeFtpXV0gKiBweVt5W2ldXSk7XG4gICAgSSArPSB6W2ldICogdCAqIE1hdGgubG9nKHApO1xuICAgIEggKz0geltpXSAqIHQgKiBNYXRoLmxvZyh6W2ldL3MpO1xuICB9XG5cbiAgcmV0dXJuIFtJLCAxICsgSS9IXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG5zdGF0cy5tdXR1YWwuaW5mbyA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzBdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGRpc3RhbmNlIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbnN0YXRzLm11dHVhbC5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMV07XG59O1xuXG4vLyBDb21wdXRlIGEgcHJvZmlsZSBvZiBzdW1tYXJ5IHN0YXRpc3RpY3MgZm9yIGEgdmFyaWFibGUuXG5zdGF0cy5wcm9maWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBtZWFuID0gMCxcbiAgICAgIHZhbGlkID0gMCxcbiAgICAgIG1pc3NpbmcgPSAwLFxuICAgICAgZGlzdGluY3QgPSAwLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBNMiA9IDAsXG4gICAgICB2YWxzID0gW10sXG4gICAgICB1ID0ge30sIGRlbHRhLCBzZCwgaSwgdiwgeDtcblxuICAvLyBjb21wdXRlIHN1bW1hcnkgc3RhdHNcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG5cbiAgICAvLyB1cGRhdGUgdW5pcXVlIHZhbHVlc1xuICAgIHVbdl0gPSAodiBpbiB1KSA/IHVbdl0gKyAxIDogKGRpc3RpbmN0ICs9IDEsIDEpO1xuXG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgKyttaXNzaW5nO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICAvLyB1cGRhdGUgc3RhdHNcbiAgICAgIHggPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/IHYubGVuZ3RoIDogdjtcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHggPCBtaW4pIG1pbiA9IHg7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB4ID4gbWF4KSBtYXggPSB4O1xuICAgICAgZGVsdGEgPSB4IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKyt2YWxpZCk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAoeCAtIG1lYW4pO1xuICAgICAgdmFscy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKHZhbGlkIC0gMSk7XG4gIHNkID0gTWF0aC5zcXJ0KE0yKTtcblxuICAvLyBzb3J0IHZhbHVlcyBmb3IgbWVkaWFuIGFuZCBpcXJcbiAgdmFscy5zb3J0KHV0aWwuY21wKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICAgICB0eXBlKHZhbHVlcywgZiksXG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIHZhbHVlcy5sZW5ndGgsXG4gICAgdmFsaWQ6ICAgIHZhbGlkLFxuICAgIG1pc3Npbmc6ICBtaXNzaW5nLFxuICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICBtaW46ICAgICAgbWluLFxuICAgIG1heDogICAgICBtYXgsXG4gICAgbWVhbjogICAgIG1lYW4sXG4gICAgc3RkZXY6ICAgIHNkLFxuICAgIG1lZGlhbjogICAodiA9IHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNSkpLFxuICAgIHExOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjI1KSxcbiAgICBxMzogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC43NSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZFxuICB9O1xufTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0Llxuc3RhdHMuc3VtbWFyeSA9IGZ1bmN0aW9uKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICB2YXIgcyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBwID0gc3RhdHMucHJvZmlsZShkYXRhLCB1dGlsLiQoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgcmV0dXJuIChzLl9fc3VtbWFyeV9fID0gdHJ1ZSwgcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXRzOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcblxudmFyIGNvbnRleHQgPSB7XG4gIGZvcm1hdHM6ICAgIFtdLFxuICBmb3JtYXRfbWFwOiB7fSxcbiAgdHJ1bmNhdGU6ICAgdXRpbC50cnVuY2F0ZSxcbiAgcGFkOiAgICAgICAgdXRpbC5wYWRcbn07XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKHRleHQpIHtcbiAgdmFyIHNyYyA9IHNvdXJjZSh0ZXh0LCAnZCcpO1xuICBzcmMgPSAndmFyIF9fdDsgcmV0dXJuICcgKyBzcmMgKyAnOyc7XG5cbiAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ2QnLCBzcmMpKS5iaW5kKGNvbnRleHQpO1xufVxuXG50ZW1wbGF0ZS5zb3VyY2UgPSBzb3VyY2U7XG50ZW1wbGF0ZS5jb250ZXh0ID0gY29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbi8vIENsZWFyIGNhY2hlIG9mIGZvcm1hdCBvYmplY3RzLlxuLy8gVGhpcyBjYW4gKmJyZWFrKiBwcmlvciB0ZW1wbGF0ZSBmdW5jdGlvbnMsIHNvIGludm9rZSB3aXRoIGNhcmUhXG50ZW1wbGF0ZS5jbGVhckZvcm1hdENhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnRleHQuZm9ybWF0cyA9IFtdO1xuICBjb250ZXh0LmZvcm1hdF9tYXAgPSB7fTtcbn07XG5cbi8vIEdlbmVyYXRlIHByb3BlcnR5IGFjY2VzcyBjb2RlIGZvciB1c2Ugd2l0aGluIHRlbXBsYXRlIHNvdXJjZS5cbi8vIG9iamVjdDogdGhlIG5hbWUgb2YgdGhlIG9iamVjdCAodmFyaWFibGUpIGNvbnRhaW5pbmcgdGVtcGxhdGUgZGF0YVxuLy8gcHJvcGVydHk6IHRoZSBwcm9wZXJ0eSBhY2Nlc3Mgc3RyaW5nLCB2ZXJiYXRpbSBmcm9tIHRlbXBsYXRlIHRhZ1xudGVtcGxhdGUucHJvcGVydHkgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gIHZhciBzcmMgPSB1dGlsLmZpZWxkKHByb3BlcnR5KS5tYXAodXRpbC5zdHIpLmpvaW4oJ11bJyk7XG4gIHJldHVybiBvYmplY3QgKyAnWycgKyBzcmMgKyAnXSc7XG59O1xuXG4vLyBHZW5lcmF0ZSBzb3VyY2UgY29kZSBmb3IgYSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbi8vIHRleHQ6IHRoZSB0ZW1wbGF0ZSB0ZXh0XG4vLyB2YXJpYWJsZTogdGhlIG5hbWUgb2YgdGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlICgnb2JqJyBieSBkZWZhdWx0KVxuLy8gcHJvcGVydGllczogb3B0aW9uYWwgaGFzaCBmb3IgY29sbGVjdGluZyBhbGwgYWNjZXNzZWQgcHJvcGVydGllc1xuZnVuY3Rpb24gc291cmNlKHRleHQsIHZhcmlhYmxlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgJ29iaic7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzcmMgPSAnXFwnJztcbiAgdmFyIHJlZ2V4ID0gdGVtcGxhdGVfcmU7XG5cbiAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgdGV4dC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihtYXRjaCwgaW50ZXJwb2xhdGUsIG9mZnNldCkge1xuICAgIHNyYyArPSB0ZXh0XG4gICAgICAuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICAgIC5yZXBsYWNlKHRlbXBsYXRlX2VzY2FwZXIsIHRlbXBsYXRlX2VzY2FwZUNoYXIpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBzcmMgKz0gJ1xcJ1xcbisoKF9fdD0oJyArXG4gICAgICAgIHRlbXBsYXRlX3ZhcihpbnRlcnBvbGF0ZSwgdmFyaWFibGUsIHByb3BlcnRpZXMpICtcbiAgICAgICAgJykpPT1udWxsP1xcJ1xcJzpfX3QpK1xcblxcJyc7XG4gICAgfVxuXG4gICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBzcmMgKyAnXFwnJztcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfdmFyKHRleHQsIHZhcmlhYmxlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBmaWx0ZXJzID0gdGV4dC5tYXRjaChmaWx0ZXJfcmUpO1xuICB2YXIgcHJvcCA9IGZpbHRlcnMuc2hpZnQoKS50cmltKCk7XG4gIHZhciBzdHJpbmdDYXN0ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBzdHJjYWxsKGZuKSB7XG4gICAgZm4gPSBmbiB8fCAnJztcbiAgICBpZiAoc3RyaW5nQ2FzdCkge1xuICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgc3JjID0gJ1N0cmluZygnICsgc3JjICsgJyknICsgZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyArPSBmbjtcbiAgICB9XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGUoKSB7XG4gICAgcmV0dXJuICcodHlwZW9mICcgKyBzcmMgKyAnPT09XCJudW1iZXJcIj9uZXcgRGF0ZSgnK3NyYysnKTonK3NyYysnKSc7XG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXJfZm9ybWF0KGZtdCwga2V5KSB7XG4gICAgYSA9IHRlbXBsYXRlX2Zvcm1hdChhcmdzWzBdLCBrZXksIGZtdCk7XG4gICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrc3JjKycpJztcbiAgfVxuICBcbiAgZnVuY3Rpb24gdGltZV9mb3JtYXQoZm10LCBrZXkpIHtcbiAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGtleSwgZm10KTtcbiAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytkYXRlKCkrJyknO1xuICB9XG5cbiAgaWYgKHByb3BlcnRpZXMpIHByb3BlcnRpZXNbcHJvcF0gPSAxO1xuICB2YXIgc3JjID0gdGVtcGxhdGUucHJvcGVydHkodmFyaWFibGUsIHByb3ApO1xuXG4gIGZvciAodmFyIGk9MDsgaTxmaWx0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBmaWx0ZXJzW2ldLCBhcmdzID0gbnVsbCwgcGlkeCwgYSwgYjtcblxuICAgIGlmICgocGlkeD1mLmluZGV4T2YoJzonKSkgPiAwKSB7XG4gICAgICBmID0gZi5zbGljZSgwLCBwaWR4KTtcbiAgICAgIGFyZ3MgPSBmaWx0ZXJzW2ldLnNsaWNlKHBpZHgrMSlcbiAgICAgICAgLm1hdGNoKGFyZ3NfcmUpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH0pO1xuICAgIH1cbiAgICBmID0gZi50cmltKCk7XG5cbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgIHN0cmNhbGwoJy5sZW5ndGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9VcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZUxvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cmltJzpcbiAgICAgICAgc3RyY2FsbCgnLnRyaW0oKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgwLCcgKyBhICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKC0nICsgYSArJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhICsgdXRpbC5udW1iZXIoYXJnc1sxXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgrJythKycsJytiKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgnKyBhICtcbiAgICAgICAgICAoYXJncy5sZW5ndGggPiAxID8gJywnICsgdXRpbC5udW1iZXIoYXJnc1sxXSkgOiAnJykgK1xuICAgICAgICAgICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMudHJ1bmNhdGUoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PSdsZWZ0JyAmJiBiIT09J21pZGRsZScgJiYgYiE9PSdjZW50ZXInKSA/ICdyaWdodCcgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy5wYWQoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIG51bWJlcl9mb3JtYXQoZm9ybWF0Lm51bWJlciwgJ251bWJlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICB0aW1lX2Zvcm1hdChmb3JtYXQudGltZSwgJ3RpbWUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aW1lLXV0Yyc6XG4gICAgICAgIHRpbWVfZm9ybWF0KGZvcm1hdC51dGMsICd0aW1lLXV0YycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdVbnJlY29nbml6ZWQgdGVtcGxhdGUgZmlsdGVyOiAnICsgZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNyYztcbn1cblxudmFyIHRlbXBsYXRlX3JlID0gL1xce1xceyguKz8pXFx9XFx9fCQvZyxcbiAgICBmaWx0ZXJfcmUgPSAvKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFteXFx8XCJdK3xbXlxcfFxcJ10rKSsvZyxcbiAgICBhcmdzX3JlID0gLyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xbXixcIl0rfFteLFxcJ10rKSsvZztcblxuLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbi8vIHN0cmluZyBsaXRlcmFsLlxudmFyIHRlbXBsYXRlX2VzY2FwZXMgPSB7XG4gICdcXCcnOiAgICAgJ1xcJycsXG4gICdcXFxcJzogICAgICdcXFxcJyxcbiAgJ1xccic6ICAgICAncicsXG4gICdcXG4nOiAgICAgJ24nLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxudmFyIHRlbXBsYXRlX2VzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2VzY2FwZUNoYXIobWF0Y2gpIHtcbiAgcmV0dXJuICdcXFxcJyArIHRlbXBsYXRlX2VzY2FwZXNbbWF0Y2hdO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9mb3JtYXQocGF0dGVybiwga2V5LCBmbXQpIHtcbiAgaWYgKChwYXR0ZXJuWzBdID09PSAnXFwnJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXFwnJykgfHxcbiAgICAgIChwYXR0ZXJuWzBdID09PSAnXCInICAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXCInKSkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignRm9ybWF0IHBhdHRlcm4gbXVzdCBiZSBxdW90ZWQ6ICcgKyBwYXR0ZXJuKTtcbiAgfVxuICBrZXkgPSBrZXkgKyAnOicgKyBwYXR0ZXJuO1xuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtrZXldKSB7XG4gICAgdmFyIGYgPSBmbXQocGF0dGVybik7XG4gICAgdmFyIGkgPSBjb250ZXh0LmZvcm1hdHMubGVuZ3RoO1xuICAgIGNvbnRleHQuZm9ybWF0cy5wdXNoKGYpO1xuICAgIGNvbnRleHQuZm9ybWF0X21hcFtrZXldID0gaTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5mb3JtYXRfbWFwW2tleV07XG59XG4iLCJ2YXIgZDNfdGltZSA9IHJlcXVpcmUoJ2QzLXRpbWUnKTtcblxudmFyIHRlbXBEYXRlID0gbmV3IERhdGUoKSxcbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKDAsIDAsIDEpLnNldEZ1bGxZZWFyKDApLCAvLyBKYW4gMSwgMCBBRFxuICAgIHV0Y0Jhc2VEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMCwgMCwgMSkpLnNldFVUQ0Z1bGxZZWFyKDApO1xuXG5mdW5jdGlvbiBkYXRlKGQpIHtcbiAgcmV0dXJuICh0ZW1wRGF0ZS5zZXRUaW1lKCtkKSwgdGVtcERhdGUpO1xufVxuXG4vLyBjcmVhdGUgYSB0aW1lIHVuaXQgZW50cnlcbmZ1bmN0aW9uIGVudHJ5KHR5cGUsIGRhdGUsIHVuaXQsIHN0ZXAsIG1pbiwgbWF4KSB7XG4gIHZhciBlID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0ZTogZGF0ZSxcbiAgICB1bml0OiB1bml0XG4gIH07XG4gIGlmIChzdGVwKSB7XG4gICAgZS5zdGVwID0gc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBlLm1pbnN0ZXAgPSAxO1xuICB9XG4gIGlmIChtaW4gIT0gbnVsbCkgZS5taW4gPSBtaW47XG4gIGlmIChtYXggIT0gbnVsbCkgZS5tYXggPSBtYXg7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgdW5pdCwgYmFzZSwgc3RlcCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIGVudHJ5KHR5cGUsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5vZmZzZXQoYmFzZSwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5jb3VudChiYXNlLCBkKTsgfSxcbiAgICBzdGVwLCBtaW4sIG1heCk7XG59XG5cbnZhciBsb2NhbGUgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS5zZWNvbmQsIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLm1pbnV0ZSwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUuaG91ciwgICBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS5kYXksICAgIGJhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUubW9udGgsICBiYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnllYXIsICAgYmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFNlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNaW51dGVzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ2hvdXJzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldEhvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCA0K2QpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0RGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXRlKCk7IH0sXG4gICAgWzFdLCAxLCAzMVxuICApLFxuICBlbnRyeSgnbW9udGhzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCBkICUgMTIsIDEpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0TW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciB1dGMgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS51dGNTZWNvbmQsIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLnV0Y01pbnV0ZSwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUudXRjSG91ciwgICB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS51dGNEYXksICAgIHV0Y0Jhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUudXRjTW9udGgsICB1dGNCYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnV0Y1llYXIsICAgdXRjQmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCAwLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENTZWNvbmRzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ21pbnV0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ01pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0hvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0K2QpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RheSgpOyB9LFxuICAgIFsxXSwgMCwgNlxuICApLFxuICBlbnRyeSgnZGF0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG5mdW5jdGlvbiBmaW5kKHVuaXRzLCBzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBzdGVwID0gU1RFUFNbMF0sIGksIG4sIGJpbnM7XG5cbiAgZm9yIChpPTEsIG49U1RFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gdW5pdHNbU1RFUFNbaS0xXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuaXRzW1NURVBTW24tMV1bMV1dO1xufVxuXG5mdW5jdGlvbiB0b1VuaXRNYXAodW5pdHMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj11bml0cy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgbWFwW3VuaXRzW2ldLnR5cGVdID0gdW5pdHNbaV07XG4gIH1cbiAgbWFwLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gICAgcmV0dXJuIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpO1xuICB9O1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvVW5pdE1hcChsb2NhbGUpO1xubW9kdWxlLmV4cG9ydHMudXRjID0gdG9Vbml0TWFwKHV0Yyk7XG4iLCJ2YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICAgIHV0YyA9IHRpbWUudXRjO1xuXG52YXIgdSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBGTkFNRSA9ICdfX25hbWVfXyc7XG5cbnUubmFtZWRmdW5jID0gZnVuY3Rpb24obmFtZSwgZikgeyByZXR1cm4gKGZbRk5BTUVdID0gbmFtZSwgZik7IH07XG5cbnUubmFtZSA9IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGY9PW51bGwgPyBudWxsIDogZltGTkFNRV07IH07XG5cbnUuaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuXG51LnRydWUgPSB1Lm5hbWVkZnVuYygndHJ1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cbnUuZmFsc2UgPSB1Lm5hbWVkZnVuYygnZmFsc2UnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51Lmxlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB4Lmxlbmd0aCAhPSBudWxsID8geC5sZW5ndGggOiBudWxsO1xufTtcblxudS5rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5cyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkga2V5cy5wdXNoKGspO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnUudmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHZhbHMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIHZhbHMucHVzaCh4W2tdKTtcbiAgcmV0dXJuIHZhbHM7XG59O1xuXG51LnRvTWFwID0gZnVuY3Rpb24obGlzdCwgZikge1xuICByZXR1cm4gKGYgPSB1LiQoZikpID9cbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbZih4KV0gPSAxLCBvYmopOyB9LCB7fSkgOlxuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7IH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGlmICghbikgcmV0dXJuICcnO1xuICBmb3IgKHZhciBzPVN0cmluZyh2YWx1ZXNbMF0pLCBpPTE7IGk8bjsgKytpKSB7XG4gICAgcyArPSAnfCcgKyBTdHJpbmcodmFsdWVzW2ldKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnUuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnUuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG51LmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxudS5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG59O1xuXG51LmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzVmFsaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqO1xufTtcblxudS5pc0J1ZmZlciA9IChidWZmZXIuQnVmZmVyICYmIGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIpIHx8IHUuZmFsc2U7XG5cbi8vIHR5cGUgY29lcmNpb24gZnVuY3Rpb25zXG5cbnUubnVtYmVyID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6ICtzO1xufTtcblxudS5ib29sZWFuID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IHM9PT0nZmFsc2UnID8gZmFsc2UgOiAhIXM7XG59O1xuXG51LmRhdGUgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogRGF0ZS5wYXJzZShzKTtcbn07XG5cbnUuYXJyYXkgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgPyAodS5pc0FycmF5KHgpID8geCA6IFt4XSkgOiBbXTtcbn07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodS5zdHIpICsgJ10nXG4gICAgOiB1LmlzT2JqZWN0KHgpID8gSlNPTi5zdHJpbmdpZnkoeClcbiAgICA6IHUuaXNTdHJpbmcoeCkgPyAoJ1xcJycrdXRpbF9lc2NhcGVfc3RyKHgpKydcXCcnKSA6IHg7XG59O1xuXG52YXIgZXNjYXBlX3N0cl9yZSA9IC8oXnxbXlxcXFxdKScvZztcblxuZnVuY3Rpb24gdXRpbF9lc2NhcGVfc3RyKHgpIHtcbiAgcmV0dXJuIHgucmVwbGFjZShlc2NhcGVfc3RyX3JlLCAnJDFcXFxcXFwnJyk7XG59XG5cbi8vIGRhdGEgYWNjZXNzIGZ1bmN0aW9uc1xuXG52YXIgZmllbGRfcmUgPSAvXFxbKC4qPylcXF18W14uXFxbXSsvZztcblxudS5maWVsZCA9IGZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIFN0cmluZyhmKS5tYXRjaChmaWVsZF9yZSkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZFswXSAhPT0gJ1snID8gZCA6XG4gICAgICBkWzFdICE9PSBcIidcIiAmJiBkWzFdICE9PSAnXCInID8gZC5zbGljZSgxLCAtMSkgOlxuICAgICAgZC5zbGljZSgyLCAtMikucmVwbGFjZSgvXFxcXChbXCInXSkvZywgJyQxJyk7XG4gIH0pO1xufTtcblxudS5hY2Nlc3NvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIChzID0gdS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBzLnJlZHVjZShmdW5jdGlvbih4LGYpIHsgcmV0dXJuIHhbZl07IH0sIHgpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH1cbiAgICApO1xufTtcblxuLy8gc2hvcnQtY3V0IGZvciBhY2Nlc3NvclxudS4kID0gdS5hY2Nlc3NvcjtcblxudS5tdXRhdG9yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgZnVuY3Rpb24oeCwgdikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICB4W3NbaV1dID0gdjtcbiAgICB9IDpcbiAgICBmdW5jdGlvbih4LCB2KSB7IHhbZl0gPSB2OyB9O1xufTtcblxuXG51LiRmdW5jID0gZnVuY3Rpb24obmFtZSwgb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICBmID0gdS4kKGYpIHx8IHUuaWRlbnRpdHk7XG4gICAgdmFyIG4gPSBuYW1lICsgKHUubmFtZShmKSA/ICdfJyt1Lm5hbWUoZikgOiAnJyk7XG4gICAgcmV0dXJuIHUubmFtZWRmdW5jKG4sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG9wKGYoZCkpOyB9KTtcbiAgfTtcbn07XG5cbnUuJHZhbGlkICA9IHUuJGZ1bmMoJ3ZhbGlkJywgdS5pc1ZhbGlkKTtcbnUuJGxlbmd0aCA9IHUuJGZ1bmMoJ2xlbmd0aCcsIHUubGVuZ3RoKTtcblxudS4kaW4gPSBmdW5jdGlvbihmLCB2YWx1ZXMpIHtcbiAgZiA9IHUuJChmKTtcbiAgdmFyIG1hcCA9IHUuaXNBcnJheSh2YWx1ZXMpID8gdS50b01hcCh2YWx1ZXMpIDogdmFsdWVzO1xuICByZXR1cm4gZnVuY3Rpb24oZCkgeyByZXR1cm4gISFtYXBbZihkKV07IH07XG59O1xuXG51LiR5ZWFyICAgPSB1LiRmdW5jKCd5ZWFyJywgdGltZS55ZWFyLnVuaXQpO1xudS4kbW9udGggID0gdS4kZnVuYygnbW9udGgnLCB0aW1lLm1vbnRocy51bml0KTtcbnUuJGRhdGUgICA9IHUuJGZ1bmMoJ2RhdGUnLCB0aW1lLmRhdGVzLnVuaXQpO1xudS4kZGF5ICAgID0gdS4kZnVuYygnZGF5JywgdGltZS53ZWVrZGF5cy51bml0KTtcbnUuJGhvdXIgICA9IHUuJGZ1bmMoJ2hvdXInLCB0aW1lLmhvdXJzLnVuaXQpO1xudS4kbWludXRlID0gdS4kZnVuYygnbWludXRlJywgdGltZS5taW51dGVzLnVuaXQpO1xudS4kc2Vjb25kID0gdS4kZnVuYygnc2Vjb25kJywgdGltZS5zZWNvbmRzLnVuaXQpO1xuXG51LiR1dGNZZWFyICAgPSB1LiRmdW5jKCd1dGNZZWFyJywgdXRjLnllYXIudW5pdCk7XG51LiR1dGNNb250aCAgPSB1LiRmdW5jKCd1dGNNb250aCcsIHV0Yy5tb250aHMudW5pdCk7XG51LiR1dGNEYXRlICAgPSB1LiRmdW5jKCd1dGNEYXRlJywgdXRjLmRhdGVzLnVuaXQpO1xudS4kdXRjRGF5ICAgID0gdS4kZnVuYygndXRjRGF5JywgdXRjLndlZWtkYXlzLnVuaXQpO1xudS4kdXRjSG91ciAgID0gdS4kZnVuYygndXRjSG91cicsIHV0Yy5ob3Vycy51bml0KTtcbnUuJHV0Y01pbnV0ZSA9IHUuJGZ1bmMoJ3V0Y01pbnV0ZScsIHV0Yy5taW51dGVzLnVuaXQpO1xudS4kdXRjU2Vjb25kID0gdS4kZnVuYygndXRjU2Vjb25kJywgdXRjLnNlY29uZHMudW5pdCk7XG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gJy0nKSB7IHMgPSAtMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBlbHNlIGlmIChmWzBdID09PSAnKycpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbnUucGFkID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHBhZGNoYXIpIHtcbiAgcGFkY2hhciA9IHBhZGNoYXIgfHwgXCIgXCI7XG4gIHZhciBkID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIGlmIChkIDw9IDApIHJldHVybiBzO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHN0cnJlcChkLCBwYWRjaGFyKSArIHM7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHN0cnJlcChNYXRoLmZsb29yKGQvMiksIHBhZGNoYXIpICtcbiAgICAgICAgIHMgKyBzdHJyZXAoTWF0aC5jZWlsKGQvMiksIHBhZGNoYXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcyArIHN0cnJlcChkLCBwYWRjaGFyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RycmVwKG4sIHN0cikge1xuICB2YXIgcyA9IFwiXCIsIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG51LnRydW5jYXRlID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHdvcmQsIGVsbGlwc2lzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBsZW5ndGgpIHJldHVybiBzO1xuICBlbGxpcHNpcyA9IGVsbGlwc2lzICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZWxsaXBzaXMpIDogJ1xcdTIwMjYnO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgK1xuICAgICAgICBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKCcnKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHRydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qIEZpbGVTYXZlci5qc1xuICogQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKiAxLjMuMlxuICogMjAxNi0wNi0xNiAxODoyNToxOVxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IE1JVFxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlLCBpbmRlbnQ6IDQsIGxheGJyZWFrOiB0cnVlLCBsYXhjb21tYTogdHJ1ZSwgc21hcnR0YWJzOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0ZpbGVTYXZlci5qcyAqL1xuXG52YXIgc2F2ZUFzID0gc2F2ZUFzIHx8IChmdW5jdGlvbih2aWV3KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvLyBJRSA8MTAgaXMgZXhwbGljaXRseSB1bnN1cHBvcnRlZFxuXHRpZiAodHlwZW9mIHZpZXcgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXJcblx0XHQgIGRvYyA9IHZpZXcuZG9jdW1lbnRcblx0XHQgIC8vIG9ubHkgZ2V0IFVSTCB3aGVuIG5lY2Vzc2FyeSBpbiBjYXNlIEJsb2IuanMgaGFzbid0IG92ZXJyaWRkZW4gaXQgeWV0XG5cdFx0LCBnZXRfVVJMID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkwgfHwgdmlldztcblx0XHR9XG5cdFx0LCBzYXZlX2xpbmsgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcblx0XHQsIGNhbl91c2Vfc2F2ZV9saW5rID0gXCJkb3dubG9hZFwiIGluIHNhdmVfbGlua1xuXHRcdCwgY2xpY2sgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpO1xuXHRcdFx0bm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0LCBpc19zYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHZpZXcuSFRNTEVsZW1lbnQpIHx8IHZpZXcuc2FmYXJpXG5cdFx0LCBpc19jaHJvbWVfaW9zID0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcblx0XHQsIHRocm93X291dHNpZGUgPSBmdW5jdGlvbihleCkge1xuXHRcdFx0KHZpZXcuc2V0SW1tZWRpYXRlIHx8IHZpZXcuc2V0VGltZW91dCkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IGV4O1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHRcdCwgZm9yY2Vfc2F2ZWFibGVfdHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcblx0XHQvLyB0aGUgQmxvYiBBUEkgaXMgZnVuZGFtZW50YWxseSBicm9rZW4gYXMgdGhlcmUgaXMgbm8gXCJkb3dubG9hZGZpbmlzaGVkXCIgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG5cdFx0LCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSAxMDAwICogNDAgLy8gaW4gbXNcblx0XHQsIHJldm9rZSA9IGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdHZhciByZXZva2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikgeyAvLyBmaWxlIGlzIGFuIG9iamVjdCBVUkxcblx0XHRcdFx0XHRnZXRfVVJMKCkucmV2b2tlT2JqZWN0VVJMKGZpbGUpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBmaWxlIGlzIGEgRmlsZVxuXHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRzZXRUaW1lb3V0KHJldm9rZXIsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCk7XG5cdFx0fVxuXHRcdCwgZGlzcGF0Y2ggPSBmdW5jdGlvbihmaWxlc2F2ZXIsIGV2ZW50X3R5cGVzLCBldmVudCkge1xuXHRcdFx0ZXZlbnRfdHlwZXMgPSBbXS5jb25jYXQoZXZlbnRfdHlwZXMpO1xuXHRcdFx0dmFyIGkgPSBldmVudF90eXBlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHZhciBsaXN0ZW5lciA9IGZpbGVzYXZlcltcIm9uXCIgKyBldmVudF90eXBlc1tpXV07XG5cdFx0XHRcdGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsKGZpbGVzYXZlciwgZXZlbnQgfHwgZmlsZXNhdmVyKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0dGhyb3dfb3V0c2lkZShleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdCwgYXV0b19ib20gPSBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHQvLyBwcmVwZW5kIEJPTSBmb3IgVVRGLTggWE1MIGFuZCB0ZXh0LyogdHlwZXMgKGluY2x1ZGluZyBIVE1MKVxuXHRcdFx0Ly8gbm90ZTogeW91ciBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBjb252ZXJ0IFVURi0xNiBVK0ZFRkYgdG8gRUYgQkIgQkZcblx0XHRcdGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwge3R5cGU6IGJsb2IudHlwZX0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0fVxuXHRcdCwgRmlsZVNhdmVyID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdGlmICghbm9fYXV0b19ib20pIHtcblx0XHRcdFx0YmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QgdHJ5IGEuZG93bmxvYWQsIHRoZW4gd2ViIGZpbGVzeXN0ZW0sIHRoZW4gb2JqZWN0IFVSTHNcblx0XHRcdHZhclxuXHRcdFx0XHQgIGZpbGVzYXZlciA9IHRoaXNcblx0XHRcdFx0LCB0eXBlID0gYmxvYi50eXBlXG5cdFx0XHRcdCwgZm9yY2UgPSB0eXBlID09PSBmb3JjZV9zYXZlYWJsZV90eXBlXG5cdFx0XHRcdCwgb2JqZWN0X3VybFxuXHRcdFx0XHQsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG5cdFx0XHRcdCwgZnNfZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoKGlzX2Nocm9tZV9pb3MgfHwgKGZvcmNlICYmIGlzX3NhZmFyaSkpICYmIHZpZXcuRmlsZVJlYWRlcikge1xuXHRcdFx0XHRcdFx0Ly8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG5cdFx0XHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHVybCA9IGlzX2Nocm9tZV9pb3MgPyByZWFkZXIucmVzdWx0IDogcmVhZGVyLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG5cdFx0XHRcdFx0XHRcdHZhciBwb3B1cCA9IHZpZXcub3Blbih1cmwsICdfYmxhbmsnKTtcblx0XHRcdFx0XHRcdFx0aWYoIXBvcHVwKSB2aWV3LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cdFx0XHRcdFx0XHRcdHVybD11bmRlZmluZWQ7IC8vIHJlbGVhc2UgcmVmZXJlbmNlIGJlZm9yZSBkaXNwYXRjaGluZ1xuXHRcdFx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcblx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGRvbid0IGNyZWF0ZSBtb3JlIG9iamVjdCBVUkxzIHRoYW4gbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCFvYmplY3RfdXJsKSB7XG5cdFx0XHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHR2aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgb3BlbmVkID0gdmlldy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCFvcGVuZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXBwbGUgZG9lcyBub3QgYWxsb3cgd2luZG93Lm9wZW4sIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9Ub29scy9Db25jZXB0dWFsL1NhZmFyaUV4dGVuc2lvbkd1aWRlL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy5odG1sXG5cdFx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0cmV2b2tlKG9iamVjdF91cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHQ7XG5cdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXG5cdFx0XHRpZiAoY2FuX3VzZV9zYXZlX2xpbmspIHtcblx0XHRcdFx0b2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG5cdFx0XHRcdFx0Y2xpY2soc2F2ZV9saW5rKTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZnNfZXJyb3IoKTtcblx0XHR9XG5cdFx0LCBGU19wcm90byA9IEZpbGVTYXZlci5wcm90b3R5cGVcblx0XHQsIHNhdmVBcyA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcblx0XHR9XG5cdDtcblx0Ly8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuXHRcdHJldHVybiBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0bmFtZSA9IG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIjtcblxuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSk7XG5cdFx0fTtcblx0fVxuXG5cdEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24oKXt9O1xuXHRGU19wcm90by5yZWFkeVN0YXRlID0gRlNfcHJvdG8uSU5JVCA9IDA7XG5cdEZTX3Byb3RvLldSSVRJTkcgPSAxO1xuXHRGU19wcm90by5ET05FID0gMjtcblxuXHRGU19wcm90by5lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG5cdEZTX3Byb3RvLm9ucHJvZ3Jlc3MgPVxuXHRGU19wcm90by5vbndyaXRlID1cblx0RlNfcHJvdG8ub25hYm9ydCA9XG5cdEZTX3Byb3RvLm9uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlZW5kID1cblx0XHRudWxsO1xuXG5cdHJldHVybiBzYXZlQXM7XG59KFxuXHQgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG5cdHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG5cdHx8IHRoaXMuY29udGVudFxuKSk7XG4vLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnNhdmVBcyA9IHNhdmVBcztcbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVmaW5lICE9PSBudWxsKSAmJiAoZGVmaW5lLmFtZCAhPT0gbnVsbCkpIHtcbiAgZGVmaW5lKFwiRmlsZVNhdmVyLmpzXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzYXZlQXM7XG4gIH0pO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgQnVmZmVyXG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIGlzLWJ1ZmZlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG4gICAgKG9iai5faXNCdWZmZXIgfHwgLy8gRm9yIFNhZmFyaSA1LTcgKG1pc3NpbmcgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgIChvYmouY29uc3RydWN0b3IgJiZcbiAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKVxuICAgICkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzaW9uLlxuICogQHBhcmFtIHtHZW5lcmljV29ya2VyfSB1bmNvbXByZXNzZWRXb3JrZXIgdGhlIHdvcmtlciB0byBwaXBlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb25PcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGNvbXByZXNzaW5nLlxuICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIG5ldyB3b3JrZXIgY29tcHJlc3NpbmcgdGhlIGNvbnRlbnQuXG4gKi9cbkNvbXByZXNzZWRPYmplY3QuY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uICh1bmNvbXByZXNzZWRXb3JrZXIsIGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdW5jb21wcmVzc2VkV29ya2VyXG4gICAgLnBpcGUobmV3IENyYzMyUHJvYmUoKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwidW5jb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAucGlwZShjb21wcmVzc2lvbi5jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbk9wdGlvbnMpKVxuICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJjb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCBjb21wcmVzc2lvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbmV4cG9ydHMuU1RPUkUgPSB7XG4gICAgbWFnaWM6IFwiXFx4MDBcXHgwMFwiLFxuICAgIGNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBjb21wcmVzc2lvblwiKTtcbiAgICB9LFxuICAgIHVuY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGRlY29tcHJlc3Npb25cIik7XG4gICAgfVxufTtcbmV4cG9ydHMuREVGTEFURSA9IHJlcXVpcmUoJy4vZmxhdGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3psaWIvY3JjMzIuanNcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY3JjMzIgb2YgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgZnVuY3Rpb24gY3JjMzIsIGJ1dCBmb3Igc3RyaW5ncy4gVXNpbmcgdGhlXG4gKiBzYW1lIGZ1bmN0aW9uIGZvciB0aGUgdHdvIHVzZSBjYXNlcyBsZWFkcyB0byBob3JyaWJsZSBwZXJmb3JtYW5jZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY3JjIHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgY3JjLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSBjcmMzMiBjb21wdXRhdGlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbXB1dGVkIGNyYzMyLlxuICovXG5mdW5jdGlvbiBjcmMzMnN0cihjcmMsIHN0ciwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyYzMyd3JhcHBlcihpbnB1dCwgY3JjKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcblxuICAgIGlmKGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JjMzJzdHIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH1cbn07XG4vLyB2aW06IHNldCBzaGlmdHdpZHRoPTQgc29mdHRhYnN0b3A9NDpcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuYmFzZTY0ID0gZmFsc2U7XG5leHBvcnRzLmJpbmFyeSA9IGZhbHNlO1xuZXhwb3J0cy5kaXIgPSBmYWxzZTtcbmV4cG9ydHMuY3JlYXRlRm9sZGVycyA9IHRydWU7XG5leHBvcnRzLmRhdGUgPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbiA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uT3B0aW9ucyA9IG51bGw7XG5leHBvcnRzLmNvbW1lbnQgPSBudWxsO1xuZXhwb3J0cy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuZXhwb3J0cy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4iLCIvKiBnbG9iYWwgUHJvbWlzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBsb2FkIHRoZSBnbG9iYWwgb2JqZWN0IGZpcnN0OlxuLy8gLSBpdCBzaG91bGQgYmUgYmV0dGVyIGludGVncmF0ZWQgaW4gdGhlIHN5c3RlbSAodW5oYW5kbGVkUmVqZWN0aW9uIGluIG5vZGUpXG4vLyAtIHRoZSBlbnZpcm9ubWVudCBtYXkgaGF2ZSBhIGN1c3RvbSBQcm9taXNlIGltcGxlbWVudGF0aW9uIChzZWUgem9uZS5qcylcbnZhciBFUzZQcm9taXNlID0gbnVsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVTNlByb21pc2UgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBFUzZQcm9taXNlID0gcmVxdWlyZShcImxpZVwiKTtcbn1cblxuLyoqXG4gKiBMZXQgdGhlIHVzZXIgdXNlL2NoYW5nZSBzb21lIGltcGxlbWVudGF0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJvbWlzZTogRVM2UHJvbWlzZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBVU0VfVFlQRURBUlJBWSA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBwYWtvID0gcmVxdWlyZShcInBha29cIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbnZhciBBUlJBWV9UWVBFID0gVVNFX1RZUEVEQVJSQVkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcblxuZXhwb3J0cy5tYWdpYyA9IFwiXFx4MDhcXHgwMFwiO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0aGF0IHVzZXMgcGFrbyB0byBpbmZsYXRlL2RlZmxhdGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdGhlIG5hbWUgb2YgdGhlIHBha28gZnVuY3Rpb24gdG8gY2FsbCA6IGVpdGhlciBcIkRlZmxhdGVcIiBvciBcIkluZmxhdGVcIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIChkZSljb21wcmVzc2luZy5cbiAqL1xuZnVuY3Rpb24gRmxhdGVXb3JrZXIoYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRmxhdGVXb3JrZXIvXCIgKyBhY3Rpb24pO1xuXG4gICAgdGhpcy5fcGFrbyA9IG5ldyBwYWtvW2FjdGlvbl0oe1xuICAgICAgICByYXc6dHJ1ZSxcbiAgICAgICAgbGV2ZWwgOiBvcHRpb25zLmxldmVsIHx8IC0xIC8vIGRlZmF1bHQgY29tcHJlc3Npb25cbiAgICB9KTtcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbnV0aWxzLmluaGVyaXRzKEZsYXRlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLm1ldGEgPSBjaHVuay5tZXRhO1xuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTtcbn07XG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbn07XG5cbmV4cG9ydHMuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkRlZmxhdGVcIiwgY29tcHJlc3Npb25PcHRpb25zKTtcbn07XG5leHBvcnRzLnVuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkluZmxhdGVcIiwge30pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi4vdXRmOCcpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciBzaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWMgdGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG52YXIgZGVjVG9IZXggPSBmdW5jdGlvbihkZWMsIGJ5dGVzKSB7XG4gICAgdmFyIGhleCA9IFwiXCIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjICYgMHhmZik7XG4gICAgICAgIGRlYyA9IGRlYyA+Pj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVOSVggcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHVuaXhQZXJtaXNzaW9ucyB0aGUgdW5peCBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTQ3MDUvdGhlLXppcC1mb3JtYXRzLWV4dGVybmFsLWZpbGUtYXR0cmlidXRlIDpcbiAqXG4gKiBUVFRUc3N0cnd4cnd4cnd4MDAwMDAwMDAwMEFEVlNIUlxuICogXl5eXl9fX19fX19fX19fX19fX19fX19fX19fX19fX18gZmlsZSB0eXBlLCBzZWUgemlwaW5mby5jIChVTlhfKilcbiAqICAgICBeXl5fX19fX19fX19fX19fX19fX19fX19fX19fIHNldHVpZCwgc2V0Z2lkLCBzdGlja3lcbiAqICAgICAgICBeXl5eXl5eXl5fX19fX19fX19fX19fX19fIHBlcm1pc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl9fX19fXyBub3QgdXNlZCA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXiBET1MgYXR0cmlidXRlIGJpdHMgOiBBcmNoaXZlLCBEaXJlY3RvcnksIFZvbHVtZSBsYWJlbCwgU3lzdGVtIGZpbGUsIEhpZGRlbiwgUmVhZCBvbmx5XG4gKi9cbnZhciBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKHVuaXhQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIHZhciByZXN1bHQgPSB1bml4UGVybWlzc2lvbnM7XG4gICAgaWYgKCF1bml4UGVybWlzc2lvbnMpIHtcbiAgICAgICAgLy8gSSBjYW4ndCB1c2Ugb2N0YWwgdmFsdWVzIGluIHN0cmljdCBtb2RlLCBoZW5jZSB0aGUgaGV4YS5cbiAgICAgICAgLy8gIDA0MDc3NSA9PiAweDQxZmRcbiAgICAgICAgLy8gMDEwMDY2NCA9PiAweDgxYjRcbiAgICAgICAgcmVzdWx0ID0gaXNEaXIgPyAweDQxZmQgOiAweDgxYjQ7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gKGRvc1Blcm1pc3Npb25zIHx8IDApICAmIDB4M0Y7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB2YXJpb3VzIHBhcnRzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmluYWwgemlwIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCB3aXRoIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvbnNcbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY3JjMzInXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY29tcHJlc3NlZFNpemUnXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy4xLjNcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG51dGlsLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBuZXdCdWZmZXIgOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZyl7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoJy4vemlwT2JqZWN0Jyk7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSAndW5kZWZpbmVkJykgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgemlwIGZpbGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmZWQgaW5kZXggd2lsbCBub3QgYmUgdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3SW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja0luZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLnplcm8gKyBuZXdJbmRleCB8fCBuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZCBvZiBkYXRhIHJlYWNoZWQgKGRhdGEgbGVuZ3RoID0gXCIgKyB0aGlzLmxlbmd0aCArIFwiLCBhc2tlZCBpbmRleCA9IFwiICsgKG5ld0luZGV4KSArIFwiKS4gQ29ycnVwdGVkIHppcCA/XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCBUaGUgbmV3IGluZGV4LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBzZXRJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KG5ld0luZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ld0luZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGUgbmV4dCBuIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2tpcDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuaW5kZXggKyBuKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIHRoZSBpbmRleCB0byB1c2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhIGJ5dGUuXG4gICAgICovXG4gICAgYnl0ZUF0OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBudW1iZXIgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIuXG4gICAgICovXG4gICAgcmVhZEludDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuaW5kZXggKyBzaXplIC0gMTsgaSA+PSB0aGlzLmluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgKyB0aGlzLmJ5dGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgc3RyaW5nIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nLlxuICAgICAqL1xuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMucmVhZERhdGEoc2l6ZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIHdpdGhvdXQgY29udmVyc2lvbiwgPHNpemU+IGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSByYXcgZGF0YSwgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICovXG4gICAgcmVhZERhdGE6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCBvY2N1cmVuY2Ugb2YgYSB6aXAgc2lnbmF0dXJlICg0IGJ5dGVzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBzaWduYXR1cmUgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcblxuLy8gdmltOiBzZXQgc2hpZnR3aWR0aD00IHNvZnR0YWJzdG9wPTQ6XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAnZGF0YSc6W10sXG4gICAgICAgICdlbmQnOltdLFxuICAgICAgICAnZXJyb3InOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoJy4vQ29udmVydFdvcmtlcicpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuLi9iYXNlNjQnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZSgnLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXInKTtcbiAgICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXN1bHRUeXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2h1bmtUeXBlIHRoZSB0eXBlIG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFBcnJheSB0aGUgYXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBjaHVua3MgdG8gY29uY2F0ZW5hdGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHJlc3VsdFR5cGUsIGNodW5rVHlwZSwgZGF0YUFycmF5LCBtaW1lVHlwZSkge1xuICAgIHZhciBjb250ZW50ID0gbnVsbDtcbiAgICBzd2l0Y2gocmVzdWx0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiIDpcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5uZXdCbG9iKGRhdGFBcnJheSwgbWltZVR5cGUpO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgY29udGVudCA9IGNvbmNhdChjaHVua1R5cGUsIGRhdGFBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICBjb250ZW50ID0gY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhyZXN1bHRUeXBlLCBjb250ZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgZGF0YSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFBcnJheSB0aGUgYXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBjaHVua3MgdG8gY29uY2F0ZW5hdGVcbiAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIGNvbmNhdGVuYXRlZCBkYXRhXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBhc2tlZCB0eXBlIGlzIHVuc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAodHlwZSwgZGF0YUFycmF5KSB7XG4gICAgdmFyIGksIGluZGV4ID0gMCwgcmVzID0gbnVsbCwgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbExlbmd0aCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gZGF0YUFycmF5LmpvaW4oXCJcIik7XG4gICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgZGF0YUFycmF5KTtcbiAgICAgICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgICAgIHJlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQoZGF0YUFycmF5W2ldLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChkYXRhQXJyYXkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IDogdW5zdXBwb3J0ZWQgdHlwZSAnXCIgICsgdHlwZSArIFwiJ1wiKTtcbiAgICB9XG59XG5cbi8qKlxuICogTGlzdGVuIGEgU3RyZWFtSGVscGVyLCBhY2N1bXVsYXRlIGl0cyBjb250ZW50IGFuZCBjb25jYXRlbmF0ZSBpdCBpbnRvIGFcbiAqIGNvbXBsZXRlIGJsb2NrLlxuICogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHRvIHVzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNhbGxiYWNrIGEgY2FsbGJhY2sgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLiBDYWxsZWRcbiAqIHdpdGggb25lIGFyZyA6XG4gKiAtIHRoZSBtZXRhZGF0YSBsaW5rZWQgdG8gdGhlIHVwZGF0ZSByZWNlaXZlZC5cbiAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgdGhlIGFjY3VtdWxhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShoZWxwZXIsIHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgIHZhciBjaHVua1R5cGUgPSBoZWxwZXIuX2ludGVybmFsVHlwZSxcbiAgICAgICAgICAgIHJlc3VsdFR5cGUgPSBoZWxwZXIuX291dHB1dFR5cGUsXG4gICAgICAgICAgICBtaW1lVHlwZSA9IGhlbHBlci5fbWltZVR5cGU7XG4gICAgICAgIGhlbHBlclxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih1cGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhbGxiYWNrKG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtWmlwT3V0cHV0KHJlc3VsdFR5cGUsIGNodW5rVHlwZSwgZGF0YUFycmF5LCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyKHN0ciwgXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nMmJ1ZihzdHIpO1xufTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGJ5dGVzIGFycmF5IChvciBhIHJlcHJlc2VudGF0aW9uKSByZXByZXNlbnRpbmcgYW4gVVRGLTggZW5jb2RlZFxuICogc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IGJ1ZiB0aGUgZGF0YSBkZSBkZWNvZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhkZWNvZGUgPSBmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ1Zikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwibm9kZWJ1ZmZlclwiLCBidWYpLnRvU3RyaW5nKFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgYnVmID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGJ1Zik7XG5cbiAgICByZXR1cm4gYnVmMnN0cmluZyhidWYpO1xufTtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBkZWNvZGUgdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MgaW50byBzdHJpbmcgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhEZWNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZGVjb2RlXCIpO1xuICAgIC8vIHRoZSBsYXN0IGJ5dGVzIGlmIGEgY2h1bmsgZGlkbid0IGVuZCB3aXRoIGEgY29tcGxldGUgY29kZXBvaW50LlxuICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOERlY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIHZhciBkYXRhID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGNodW5rLmRhdGEpO1xuXG4gICAgLy8gMXN0IHN0ZXAsIHJlLXVzZSB3aGF0J3MgbGVmdCBvZiB0aGUgcHJldmlvdXMgY2h1bmtcbiAgICBpZiAodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICBpZihzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHByZXZpb3VzRGF0YS5sZW5ndGggKyB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhLnNldCh0aGlzLmxlZnRPdmVyLCAwKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHByZXZpb3VzRGF0YSwgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMubGVmdE92ZXIuY29uY2F0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBuZXh0Qm91bmRhcnkgPSB1dGY4Ym9yZGVyKGRhdGEpO1xuICAgIHZhciB1c2FibGVEYXRhID0gZGF0YTtcbiAgICBpZiAobmV4dEJvdW5kYXJ5ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zdWJhcnJheSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc3ViYXJyYXkobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zbGljZSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc2xpY2UobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHVzYWJsZURhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh0aGlzLmxlZnRPdmVyKSxcbiAgICAgICAgICAgIG1ldGEgOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxufTtcbmV4cG9ydHMuVXRmOERlY29kZVdvcmtlciA9IFV0ZjhEZWNvZGVXb3JrZXI7XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZW5kY29kZSBzdHJpbmcgY2h1bmtzIGludG8gdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOEVuY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBlbmNvZGVcIik7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RW5jb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhFbmNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhlbmNvZGUoY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuZXhwb3J0cy5VdGY4RW5jb2RlV29ya2VyID0gVXRmOEVuY29kZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZSgnLi9ub2RlanNVdGlscycpO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2NvcmUtanMvbGlicmFyeS9mbi9zZXQtaW1tZWRpYXRlJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGhhdCBwYXNzIGFzIGEgXCJiaW5hcnkgc3RyaW5nXCI6IGl0IHNob3VsZCByZXByZXNlbnQgYSBieXRlXG4gKiBhcnJheSBidXQgbWF5IGhhdmUgPiAyNTUgY2hhciBjb2Rlcy4gQmUgc3VyZSB0byB0YWtlIG9ubHkgdGhlIGZpcnN0IGJ5dGVcbiAqIGFuZCByZXR1cm5zIHRoZSBieXRlIGFycmF5LlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9IHRoZSBzdHJpbmcgaW4gYSBiaW5hcnkgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBzdHJpbmcyYmluYXJ5KHN0cikge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJsb2Igd2l0aCB0aGUgZ2l2ZW4gY29udGVudCBhbmQgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge0FycmF5W1N0cmluZ3xBcnJheUJ1ZmZlcl19IHBhcnRzIHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnRzLCB0eXBlKSB7XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQoXCJibG9iXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmxvYiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IEJsb2IocGFydHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIHdlbGwsIGZ1Y2sgPyFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNhbWUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG4vKipcbiAqIEZpbGwgaW4gYW4gYXJyYXkgd2l0aCBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsbCBpbiAod2lsbCBiZSBtdXRhdGVkKS5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycmF5W2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIGZvciB0aGUgZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gKiBUaGlzIGNvbnRhaW5zIHN0YXRpYyBpbmZvcm1hdGlvbnMgYW5kIGZ1bmN0aW9ucyB0aGF0XG4gKiBjYW4gYmUgb3B0aW1pemVkIGJ5IHRoZSBicm93c2VyIEpJVCBjb21waWxlci5cbiAqL1xudmFyIGFycmF5VG9TdHJpbmdIZWxwZXIgPSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGFuIGFycmF5IG9mIGludCBpbnRvIGEgc3RyaW5nLCBjaHVuayBieSBjaHVuay5cbiAgICAgKiBTZWUgdGhlIHBlcmZvcm1hbmNlcyBub3RlcyBvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGNodW5rIHRoZSBjaHVuayBzaXplLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgY2h1bmsgaXMgdG9vIGJpZyBmb3IgdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2h1bms6IGZ1bmN0aW9uKGFycmF5LCB0eXBlLCBjaHVuaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGsgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIC8vIHNob3J0Y3V0XG4gICAgICAgIGlmIChsZW4gPD0gY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc2xpY2UoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zdWJhcnJheShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IGNodW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGwgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBldmVyeSBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggZ2VuZXJhdGUgQSBMT1Qgb2YgaW50ZXJtZWRpYXRlIHN0cmluZy5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gZXZlcnl0aGluZyBlbHNlIGZhaWwuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaGFyOiBmdW5jdGlvbihhcnJheSl7XG4gICAgICAgIHZhciByZXN1bHRTdHIgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyO1xuICAgIH0sXG4gICAgYXBwbHlDYW5CZVVzZWQgOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gVWludDhBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdWludDhhcnJheSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSkubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBub2RlanMgQnVmZmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZWJ1ZmZlciA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0Lm5vZGVidWZmZXIgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBub2RlanNVdGlscy5uZXdCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMubmV3QnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlcihpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXIobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICB9XG59O1xuXG4vLyB1aW50OGFycmF5IHRvID9cbnRyYW5zZm9ybVtcInVpbnQ4YXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgLy8gY29weSB0aGUgdWludDhhcnJheTogRE8gTk9UIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIsIGl0XG4gICAgICAgIC8vIGNhbiBiZSB3YXkgbGFyZ2VyICh0aGUgd2hvbGUgemlwIGZpbGUgZm9yIGV4YW1wbGUpLlxuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvcHkuc2V0KGlucHV0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXIoaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIG5vZGVidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGlkZW50aXR5XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBpbnB1dCBpbnRvIGFueSB0eXBlLlxuICogVGhlIHN1cHBvcnRlZCBvdXRwdXQgdHlwZSBhcmUgOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgbm9kZWJ1ZmZlci5cbiAqIElmIG5vIG91dHB1dCB0eXBlIGlzIHNwZWNpZmllZCwgdGhlIHVubW9kaWZpZWQgaW5wdXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSBvdXRwdXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBpbnB1dCB0aGUgaW5wdXQgdG8gY29udmVydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBvdXRwdXQgdHlwZS5cbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uKG91dHB1dFR5cGUsIGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAvLyB1bmRlZmluZWQsIG51bGwsIGV0Y1xuICAgICAgICAvLyBhbiBlbXB0eSBzdHJpbmcgd29uJ3QgaGFybS5cbiAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoIW91dHB1dFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChvdXRwdXRUeXBlKTtcbiAgICB2YXIgaW5wdXRUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoaW5wdXQpO1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1baW5wdXRUeXBlXVtvdXRwdXRUeXBlXShpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIFRoZSB0eXBlIHdpbGwgYmUgaW4gYSBmb3JtYXQgdmFsaWQgZm9yIEpTWmlwLnV0aWxzLnRyYW5zZm9ybVRvIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0IHRvIGlkZW50aWZ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgKGxvd2VyY2FzZSkgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydHMuZ2V0VHlwZU9mID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIgJiYgbm9kZWpzVXRpbHMuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcIm5vZGVidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSAmJiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDhhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5hcnJheWJ1ZmZlciAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHR5cGUuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0W3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxufTtcblxuZXhwb3J0cy5NQVhfVkFMVUVfMTZCSVRTID0gNjU1MzU7XG5leHBvcnRzLk1BWF9WQUxVRV8zMkJJVFMgPSAtMTsgLy8gd2VsbCwgXCJcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXCIgaXMgcGFyc2VkIGFzIC0xXG5cbi8qKlxuICogUHJldHRpZnkgYSBzdHJpbmcgcmVhZCBhcyBiaW5hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gcHJldHRpZnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgcHJldHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgcmVzID0gJycsXG4gICAgICAgIGNvZGUsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IChzdHIgfHwgXCJcIikubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXMgKz0gJ1xcXFx4JyArIChjb2RlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGNhbGwgb2YgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBjYWxsIGFzeW5jaHJvbm91c2x5LlxuICogQHBhcmFtIHtBcnJheX0gYXJncyB0aGUgYXJndW1lbnRzIHRvIGdpdmUgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5leHBvcnRzLmRlbGF5ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIHNlbGYpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmIHx8IG51bGwsIGFyZ3MgfHwgW10pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIGEgcHJvdG90eXBlIHdpdGggYW4gb3RoZXIsIHdpdGhvdXQgY2FsbGluZyBhIGNvbnN0cnVjdG9yIHdpdGhcbiAqIHNpZGUgZWZmZWN0cy4gSW5zcGlyZWQgYnkgbm9kZWpzJyBgdXRpbHMuaW5oZXJpdHNgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIHRoZSBjb25zdHJ1Y3RvciB0byBhdWdtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlckN0b3IgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciB0byB1c2VcbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICB2YXIgT2JqID0gZnVuY3Rpb24oKSB7fTtcbiAgICBPYmoucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBPYmooKTtcbn07XG5cbi8qKlxuICogTWVyZ2UgdGhlIG9iamVjdHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMgaW50byBhIG5ldyBvbmUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIEFsbCBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgZGF0YSBvZiB0aGUgb3RoZXJzLlxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaSwgYXR0cjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IC8vIGFyZ3VtZW50cyBpcyBub3QgZW51bWVyYWJsZSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIGZvciAoYXR0ciBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoYXR0cikgJiYgdHlwZW9mIHJlc3VsdFthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthdHRyXSA9IGFyZ3VtZW50c1tpXVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYXJiaXRyYXJ5IGNvbnRlbnQgaW50byBhIFByb21pc2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBjb250ZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGEgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgdHJ1ZSBpZiB0aGUgY29udGVudCBpcyBub3QgYW4gdW5pY29kZSBzdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgb25seSBoYXMgb25lIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYXNlNjQgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgaXMgZW5jb2RlZCB3aXRoIGJhc2U2NC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSBpbiBhIGZvcm1hdCB1c2FibGUgYnkgSlNaaXAuXG4gKi9cbmV4cG9ydHMucHJlcGFyZUNvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBpbnB1dERhdGEsIGlzQmluYXJ5LCBpc09wdGltaXplZEJpbmFyeVN0cmluZywgaXNCYXNlNjQpIHtcblxuICAgIC8vIGlmIGlucHV0RGF0YSBpcyBhbHJlYWR5IGEgcHJvbWlzZSwgdGhpcyBmbGF0dGVuIGl0LlxuICAgIHZhciBwcm9taXNlID0gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKGlucHV0RGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGlzQmxvYiA9IHN1cHBvcnQuYmxvYiAmJiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IgfHwgWydbb2JqZWN0IEZpbGVdJywgJ1tvYmplY3QgQmxvYl0nXS5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkgIT09IC0xKTtcblxuICAgICAgICBpZiAoaXNCbG9iICYmIHR5cGVvZiBGaWxlUmVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoZGF0YSk7XG5cbiAgICAgICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIlRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicgaXMgaW4gYW4gdW5zdXBwb3J0ZWQgZm9ybWF0ICFcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlZmljaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnIDogdW5leHBlY3RlZCBzaWduYXR1cmUgXCIgKyBcIihcIiArIHV0aWxzLnByZXR0eShzaWduYXR1cmUpICsgXCIsIGV4cGVjdGVkIFwiICsgdXRpbHMucHJldHR5KGV4cGVjdGVkU2lnbmF0dXJlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHNpZ25hdHVyZSBpcyBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFza2VkSW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIGV4cGVjdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgaGVyZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzU2lnbmF0dXJlOiBmdW5jdGlvbihhc2tlZEluZGV4LCBleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5yZWFkZXIuaW5kZXg7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGFza2VkSW5kZXgpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNpZ25hdHVyZSA9PT0gZXhwZWN0ZWRTaWduYXR1cmU7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGN1cnJlbnRJbmRleCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRCbG9ja0VuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICB0aGlzLnppcENvbW1lbnRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAvLyB3YXJuaW5nIDogdGhlIGVuY29kaW5nIGRlcGVuZHMgb2YgdGhlIHN5c3RlbSBsb2NhbGVcbiAgICAgICAgLy8gT24gYSBsaW51eCBtYWNoaW5lIHdpdGggTEFORz1lbl9VUy51dGY4LCB0aGlzIGZpZWxkIGlzIHV0ZjggZW5jb2RlZC5cbiAgICAgICAgLy8gT24gYSB3aW5kb3dzIG1hY2hpbmUsIHRoaXMgZmllbGQgaXMgZW5jb2RlZCB3aXRoIHRoZSBsb2NhbGl6ZWQgd2luZG93cyBjb2RlIHBhZ2UuXG4gICAgICAgIHZhciB6aXBDb21tZW50ID0gdGhpcy5yZWFkZXIucmVhZERhdGEodGhpcy56aXBDb21tZW50TGVuZ3RoKTtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICAvLyBUbyBnZXQgY29uc2lzdGVudCBiZWhhdmlvciB3aXRoIHRoZSBnZW5lcmF0aW9uIHBhcnQsIHdlIHdpbGwgYXNzdW1lIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyB1dGY4IGVuY29kZWQgdW5sZXNzIHNwZWNpZmllZCBvdGhlcndpc2UuXG4gICAgICAgIHZhciBkZWNvZGVDb250ZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB6aXBDb21tZW50KTtcbiAgICAgICAgdGhpcy56aXBDb21tZW50ID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShkZWNvZGVDb250ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqIE5vdCBtZXJnZWQgd2l0aCB0aGUgbWV0aG9kIHJlYWRFbmRPZkNlbnRyYWwgOlxuICAgICAqIFRoZSBlbmQgb2YgY2VudHJhbCBjYW4gY29leGlzdCB3aXRoIGl0cyBaaXA2NCBicm90aGVyLFxuICAgICAqIEkgZG9uJ3Qgd2FudCB0byByZWFkIHRoZSB3cm9uZyBudW1iZXIgb2YgYnl0ZXMgIVxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLnJlYWRlci5za2lwKDQpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25NYWRlQnkgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG5cbiAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhID0ge307XG4gICAgICAgIHZhciBleHRyYURhdGFTaXplID0gdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgLSA0NCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGV4dHJhRGF0YVNpemUpIHtcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHRoaXMucmVhZGVyLnJlYWREYXRhKGV4dHJhRmllbGRMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvci5cbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmRpc2tzQ291bnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICBpZiAodGhpcy5kaXNrc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIGZpbGVzLCBiYXNlZCBvbiB0aGUgb2Zmc2V0IHJlYWQgaW4gdGhlIGNlbnRyYWwgcGFydC5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBmaWxlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbaV07XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChmaWxlLmxvY2FsSGVhZGVyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcbiAgICAgICAgICAgIGZpbGUucmVhZExvY2FsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZVVURjgoKTtcbiAgICAgICAgICAgIGZpbGUucHJvY2Vzc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxEaXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlsZTtcblxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLmNlbnRyYWxEaXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgZmlsZSA9IG5ldyBaaXBFbnRyeSh7XG4gICAgICAgICAgICAgICAgemlwNjQ6IHRoaXMuemlwNjRcbiAgICAgICAgICAgIH0sIHRoaXMubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgZmlsZS5yZWFkQ2VudHJhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IHRoaXMuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gMCAmJiB0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGV4cGVjdGVkIHNvbWUgcmVjb3JkcyBidXQgY291bGRuJ3QgZmluZCBBTlkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgc3VzcGljaW91cywgYXMgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IGV4cGVjdGVkIFwiICsgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyArIFwiIHJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdCBcIiArIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgc29tZSByZWNvcmRzIGJ1dCBub3QgYWxsLlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZyBidXQgd2UgZ290IHNvbWV0aGluZyBmb3IgdGhlIHVzZXI6IG5vIGVycm9yIGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiZXhwZWN0ZWRcIiwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcywgXCJyZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3RcIiwgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50IGlzIGEgdHJ1bmNhdGVkIHppcCBvciBjb21wbGV0ZSBnYXJiYWdlLlxuICAgICAgICAgICAgLy8gQSBcIkxPQ0FMX0ZJTEVfSEVBREVSXCIgaXMgbm90IHJlcXVpcmVkIGF0IHRoZSBiZWdpbm5pbmcgKGF1dG9cbiAgICAgICAgICAgIC8vIGV4dHJhY3RpYmxlIHppcCBmb3IgZXhhbXBsZSkgYnV0IGl0IGNhbiBnaXZlIGEgZ29vZCBoaW50LlxuICAgICAgICAgICAgLy8gSWYgYW4gYWpheCByZXF1ZXN0IHdhcyB1c2VkIHdpdGhvdXQgcmVzcG9uc2VUeXBlLCB3ZSB3aWxsIGFsc29cbiAgICAgICAgICAgIC8vIGdldCB1bnJlYWRhYmxlIGRhdGEuXG4gICAgICAgICAgICB2YXIgaXNHYXJiYWdlID0gIXRoaXMuaXNTaWduYXR1cmUoMCwgc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcblxuICAgICAgICAgICAgaWYgKGlzR2FyYmFnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IDogaXMgdGhpcyBhIHppcCBmaWxlID8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklmIGl0IGlzLCBzZWUgaHR0cDovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdmFyIGVuZE9mQ2VudHJhbERpck9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgdGhpcy5yZWFkQmxvY2tFbmRPZkNlbnRyYWwoKTtcblxuXG4gICAgICAgIC8qIGV4dHJhY3QgZnJvbSB0aGUgemlwIHNwZWMgOlxuICAgICAgICAgICAgNCkgIElmIG9uZSBvZiB0aGUgZmllbGRzIGluIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICByZWNvcmQgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVxdWlyZWQgZGF0YSwgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgc2hvdWxkIGJlIHNldCB0byAtMSAoMHhGRkZGIG9yIDB4RkZGRkZGRkYpIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaSVA2NCBmb3JtYXQgcmVjb3JkIHNob3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgNSkgIFRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaaXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvciByZWNvcmQgbXVzdFxuICAgICAgICAgICAgICAgIHJlc2lkZSBvbiB0aGUgc2FtZSBkaXNrIHdoZW4gc3BsaXR0aW5nIG9yIHNwYW5uaW5nXG4gICAgICAgICAgICAgICAgYW4gYXJjaGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXIgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnppcDY0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFdhcm5pbmcgOiB0aGUgemlwNjQgZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZCwgYnV0IE9OTFkgaWYgdGhlIDY0Yml0cyBpbnRlZ2VyIHJlYWQgZnJvbVxuICAgICAgICAgICAgdGhlIHppcCBmaWxlIGNhbiBmaXQgaW50byBhIDMyYml0cyBpbnRlZ2VyLiBUaGlzIGNhbm5vdCBiZSBzb2x2ZWQgOiBKYXZhc2NyaXB0IHJlcHJlc2VudHNcbiAgICAgICAgICAgIGFsbCBudW1iZXJzIGFzIDY0LWJpdCBkb3VibGUgcHJlY2lzaW9uIElFRUUgNzU0IGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gICAgICAgICAgICBTbywgd2UgaGF2ZSA1M2JpdHMgZm9yIGludGVnZXJzIGFuZCBiaXR3aXNlIG9wZXJhdGlvbnMgdHJlYXQgZXZlcnl0aGluZyBhcyAzMmJpdHMuXG4gICAgICAgICAgICBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnNcbiAgICAgICAgICAgIGFuZCBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL2ZpbGVzL0VDTUEtU1QvRUNNQS0yNjIucGRmIHNlY3Rpb24gOC41XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgbG9vayBmb3IgYSB6aXA2NCBFT0NEIGxvY2F0b3JcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXByZXNzaW9uID0gZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpO1xuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IG51bGwpIHsgLy8gbm8gY29tcHJlc3Npb24gZm91bmRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHV0aWxzLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSArIFwiIHVua25vd24gKGlubmVyIGZpbGUgOiBcIiArIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMuZmlsZU5hbWUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IENvbXByZXNzZWRPYmplY3QodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCBjb21wcmVzc2lvbiwgcmVhZGVyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB0aGlzLnZlcnNpb25NYWRlQnkgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgcmVhZGVyLnNraXAoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmJpdEZsYWcgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICB0aGlzLmRhdGUgPSByZWFkZXIucmVhZERhdGUoKTtcbiAgICAgICAgdGhpcy5jcmMzMiA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IHJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIGJlIHJlYWQgaW4gdGhlIGxvY2FsIHBhcnQsIHNlZSB0aGUgY29tbWVudHMgdGhlcmVcbiAgICAgICAgcmVhZGVyLnNraXAoZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICB0aGlzLnJlYWRFeHRyYUZpZWxkcyhyZWFkZXIpO1xuICAgICAgICB0aGlzLnBhcnNlWklQNjRFeHRyYUZpZWxkKHJlYWRlcik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnQgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgYW5kIGdldCB0aGUgdW5peC9kb3MgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdmFyIG1hZGVCeSA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIERPUyBkaXJlY3RvcnkgZmxhZyBzZXQuXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGl0IGluIHRoZSBET1MgYW5kIFVOSVggcGVybWlzc2lvbnNcbiAgICAgICAgLy8gYnV0IHNvbWUgdW5rbm93biBwbGF0Zm9ybSBjb3VsZCBzZXQgaXQgYXMgYSBjb21wYXRpYmlsaXR5IGZsYWcuXG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgwMDEwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9ET1MpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IDYgYml0cyAoMCB0byA1KVxuICAgICAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4M0Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfVU5JWCkge1xuICAgICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSAodGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAgICAgICAgIC8vIHRoZSBvY3RhbCBwZXJtaXNzaW9ucyBhcmUgaW4gKHRoaXMudW5peFBlcm1pc3Npb25zICYgMHgwMUZGKS50b1N0cmluZyg4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWwgc2FmZSA6IGlmIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC8gaXQgcHJvYmFibHkgbWVhbnMgYSBmb2xkZXJcbiAgICAgICAgaWYgKCF0aGlzLmRpciAmJiB0aGlzLmZpbGVOYW1lU3RyLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIFpJUDY0IGV4dHJhIGZpZWxkIGFuZCBtZXJnZSB0aGUgaW5mbyBpbiB0aGUgY3VycmVudCBaaXBFbnRyeS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwYXJzZVpJUDY0RXh0cmFGaWVsZDogZnVuY3Rpb24ocmVhZGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcsIHByZXBhcmluZyB0aGUgZXh0cmEgcmVhZGVyXG4gICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5pbmRleCArIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlYWRlci5pbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgaWYgKG91dHB1dFR5cGUgPT09IFwiYmluYXJ5c3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgdmFyIGlzVW5pY29kZVN0cmluZyA9ICF0aGlzLl9kYXRhQmluYXJ5O1xuXG4gICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFuc2ggWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFuc2ggWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcbiAgdmFyIGRpY3Q7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSBkaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcnlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgIGNhc2UgSEVBRDpcbiAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuXG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4gICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZMQUdTOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUSU1FOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgIC8vPT09XG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE9TOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYTEVOOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWFRSQTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE5BTUU6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPTU1FTlQ6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgSENSQzpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zZGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xuXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpe3RyeXtcbiAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbn1jYXRjaChfKXt9ZmluYWxseXtcbiAgaWYgKCFTdHJlYW0pXG4gICAgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xufX0oKSlcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpXG4gICAgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgJiZcbiAgICAgIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9OyB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpe3RyeXtcbiAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbn1jYXRjaChfKXt9ZmluYWxseXtcbiAgaWYgKCFTdHJlYW0pXG4gICAgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xufX0oKSlcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCl7dHJ5IHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgZ2V0OiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSAnICtcbiAgICAgICdfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKSBpbnN0ZWFkLicpXG59KTtcbn1jYXRjaChfKXt9fSgpKTtcblxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcblxuICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSAmJlxuICAgICAgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KVxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJylcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsXG4ndWNzMicsICd1Y3MtMicsJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J11cbi5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBjYnMgPSBbXTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGNicy5wdXNoKGVudHJ5LmNhbGxiYWNrKTtcbiAgICAgIGJ1ZmZlci5wdXNoKGVudHJ5KTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG5cbiAgICAvLyBjb3VudCB0aGUgb25lIHdlIGFyZSBhZGRpbmcsIGFzIHdlbGwuXG4gICAgLy8gVE9ETyhpc2FhY3MpIGNsZWFuIHRoaXMgdXBcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2JzW2ldKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhciBidWZmZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKVxuICAgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3NOZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsInZhciBERVBTID0gcmVxdWlyZSgnLi9EZXBlbmRlbmNpZXMnKS5BTEw7XG5cbmZ1bmN0aW9uIGNyZWF0ZShjcywgcmVmbG93KSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgY29weShjcywgb3V0KTtcblxuICBvdXQuYWRkID0gW107XG4gIG91dC5tb2QgPSBbXTtcbiAgb3V0LnJlbSA9IFtdO1xuXG4gIG91dC5yZWZsb3cgPSByZWZsb3c7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weShhLCBiKSB7XG4gIGIuc3RhbXAgPSBhID8gYS5zdGFtcCA6IDA7XG4gIGIuc29ydCAgPSBhID8gYS5zb3J0ICA6IG51bGw7XG4gIGIuZmFjZXQgPSBhID8gYS5mYWNldCA6IG51bGw7XG4gIGIudHJhbnMgPSBhID8gYS50cmFucyA6IG51bGw7XG4gIGIuZGlydHkgPSBhID8gYS5kaXJ0eSA6IFtdO1xuICBiLnJlcXVlc3QgPSBhID8gYS5yZXF1ZXN0IDogbnVsbDtcbiAgZm9yICh2YXIgZCwgaT0wLCBuPURFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGJbZD1ERVBTW2ldXSA9IGEgPyBhW2RdIDoge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjb3B5OiBjb3B5XG59OyIsInZhciBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgICBCYXNlID0gcmVxdWlyZSgnLi9Ob2RlJykucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3IoZ3JhcGgpIHtcbiAgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMucm91dGVyKHRydWUpLmNvbGxlY3Rvcih0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChDb2xsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0b3I7XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhO1xufTtcblxucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbXCJjb2xsZWN0aW5nXCJdKTtcblxuICBpZiAoaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIHRoaXMuX2RhdGEgPSBUdXBsZS5pZEZpbHRlcih0aGlzLl9kYXRhLCBpbnB1dC5yZW0pO1xuICB9XG5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGgpIHtcbiAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5sZW5ndGggPyB0aGlzLl9kYXRhLmNvbmNhdChpbnB1dC5hZGQpIDogaW5wdXQuYWRkO1xuICB9XG5cbiAgaWYgKGlucHV0LnNvcnQpIHtcbiAgICB0aGlzLl9kYXRhLnNvcnQoaW5wdXQuc29ydCk7XG4gIH1cblxuICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgaW5wdXQubW9kID0gaW5wdXQubW9kLmNvbmNhdChcbiAgICAgIFR1cGxlLmlkRmlsdGVyKHRoaXMuX2RhdGEsIGlucHV0LmFkZCwgaW5wdXQubW9kLCBpbnB1dC5yZW0pKTtcbiAgICBpbnB1dC5yZWZsb3cgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdG9yOyIsInZhciBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBDaGFuZ2VTZXQgPSByZXF1aXJlKCcuL0NoYW5nZVNldCcpLCBcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL0NvbGxlY3RvcicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgnLi9UdXBsZScpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbmZ1bmN0aW9uIERhdGFTb3VyY2UoZ3JhcGgsIG5hbWUsIGZhY2V0KSB7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2ZhY2V0ICA9IGZhY2V0O1xuICB0aGlzLl9pbnB1dCAgPSBDaGFuZ2VTZXQuY3JlYXRlKCk7XG4gIHRoaXMuX291dHB1dCA9IG51bGw7IC8vIE91dHB1dCBjaGFuZ2VzZXRcblxuICB0aGlzLl9pbnB1dE5vZGUgID0gbnVsbDtcbiAgdGhpcy5fb3V0cHV0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX3BpcGVsaW5lICA9IG51bGw7IC8vIFBpcGVsaW5lIG9mIHRyYW5zZm9ybWF0aW9ucy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbnVsbDsgLy8gQ29sbGVjdG9yIHRvIG1hdGVyaWFsaXplIG91dHB1dCBvZiBwaXBlbGluZS5cbiAgdGhpcy5fbXV0YXRlcyA9IGZhbHNlOyAgLy8gRG9lcyBhbnkgcGlwZWxpbmUgb3BlcmF0b3IgbXV0YXRlIHR1cGxlcz9cbn1cblxudmFyIHByb3RvdHlwZSA9IERhdGFTb3VyY2UucHJvdG90eXBlO1xuXG5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbmFtZTtcbiAgcmV0dXJuICh0aGlzLl9uYW1lID0gbmFtZSwgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgcmV0dXJuICh0aGlzLl9zb3VyY2UgPSB0aGlzLl9ncmFwaC5kYXRhKHNyYykpO1xufTtcblxucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHR1cGxlcykge1xuICB0aGlzLl9pbnB1dC5hZGQgPSB0aGlzLl9pbnB1dC5hZGQuY29uY2F0KHR1cGxlcy5tYXAoVHVwbGUuaW5nZXN0KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gIHZhciByZW1vdmUgPSB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSk7XG4gIHRoaXMuX2lucHV0LnJlbSA9IHRoaXMuX2lucHV0LnJlbS5jb25jYXQocmVtb3ZlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24od2hlcmUsIGZpZWxkLCBmdW5jKSB7XG4gIHZhciBtb2QgPSB0aGlzLl9pbnB1dC5tb2QsXG4gICAgICBpZHMgPSBUdXBsZS5pZE1hcChtb2QpO1xuXG4gIHRoaXMuX2lucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuXG4gIHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcHJldiA9IHhbZmllbGRdLFxuICAgICAgICBuZXh0ID0gZnVuYyh4KTtcbiAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgVHVwbGUuc2V0KHgsIGZpZWxkLCBuZXh0KTtcbiAgICAgIGlmIChpZHNbeC5faWRdICE9PSAxKSB7XG4gICAgICAgIG1vZC5wdXNoKHgpO1xuICAgICAgICBpZHNbeC5faWRdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcblxuICAvLyBSZXBsYWNlIGJhY2tpbmcgZGF0YVxuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gIGlmIChkYXRhKSB7IHRoaXMuaW5zZXJ0KGRhdGEpOyB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm11dGF0ZXMgPSBmdW5jdGlvbihtKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX211dGF0ZXM7XG4gIHRoaXMuX211dGF0ZXMgPSB0aGlzLl9tdXRhdGVzIHx8IG07XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dDtcbn07XG5cbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYgKGlucHV0KSB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUodGhpcy5faW5wdXQsIHRoaXMuX3BpcGVsaW5lWzBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGlwZWxpbmUgPSBmdW5jdGlvbihwaXBlbGluZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9waXBlbGluZTtcblxuICB2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHN0YXR1cztcblxuICBwaXBlbGluZS51bnNoaWZ0KHRoaXMuX2lucHV0Tm9kZSA9IERhdGFTb3VyY2VJbnB1dCh0aGlzKSk7XG4gIHN0YXR1cyA9IGdyYXBoLnByZXByb2Nlc3MocGlwZWxpbmUpO1xuXG4gIGlmIChzdGF0dXMucm91dGVyKSB7XG4gICAgcGlwZWxpbmUucHVzaChzdGF0dXMuY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCkpO1xuICB9XG5cbiAgcGlwZWxpbmUucHVzaCh0aGlzLl9vdXRwdXROb2RlID0gRGF0YVNvdXJjZU91dHB1dCh0aGlzKSk7XG4gIHRoaXMuX2NvbGxlY3RvciA9IHN0YXR1cy5jb2xsZWN0b3I7XG4gIHRoaXMuX211dGF0ZXMgPSAhIXN0YXR1cy5tdXRhdGVzO1xuICBncmFwaC5jb25uZWN0KHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dyYXBoLnN5bmNocm9uaXplKHRoaXMuX3BpcGVsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUubGlzdGVuZXIgPSBmdW5jdGlvbigpIHsgXG4gIHJldHVybiBEYXRhU291cmNlTGlzdGVuZXIodGhpcykuYWRkTGlzdGVuZXIodGhpcy5faW5wdXROb2RlKTtcbn07XG5cbnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKGwgaW5zdGFuY2VvZiBEYXRhU291cmNlKSB7XG4gICAgdGhpcy5fY29sbGVjdG9yLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3V0cHV0Tm9kZS5hZGRMaXN0ZW5lcihsKTsgICAgICBcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgdGhpcy5fb3V0cHV0Tm9kZS5yZW1vdmVMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihkcykge1xuICByZXR1cm4gKGRzID8gdGhpcy5fY29sbGVjdG9yIDogdGhpcy5fb3V0cHV0Tm9kZSkubGlzdGVuZXJzKCk7XG59O1xuXG4vLyBJbnB1dCBub2RlIGFwcGxpZXMgdGhlIGRhdGFzb3VyY2UncyBkZWx0YSwgYW5kIHByb3BhZ2F0ZXMgaXQgdG8gXG4vLyB0aGUgcmVzdCBvZiB0aGUgcGlwZWxpbmUuIEl0IHJlY2VpdmVzIHRvdWNoZXMgdG8gcmVmbG93IGRhdGEuXG5mdW5jdGlvbiBEYXRhU291cmNlSW5wdXQoZHMpIHtcbiAgdmFyIGlucHV0ID0gbmV3IE5vZGUoZHMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIGlucHV0LmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHMuX2RhdGE7XG4gIH07XG5cbiAgaW5wdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGxvZy5kZWJ1ZyhpbnB1dCwgWydpbnB1dCcsIGRzLl9uYW1lXSk7XG5cbiAgICB2YXIgZGVsdGEgPSBkcy5faW5wdXQsIFxuICAgICAgICBvdXQgPSBDaGFuZ2VTZXQuY3JlYXRlKGlucHV0KSwgZjtcblxuICAgIC8vIERlbHRhIG1pZ2h0IGNvbnRhaW4gZmllbGRzIHVwZGF0ZWQgdGhyb3VnaCBBUElcbiAgICBmb3IgKGYgaW4gZGVsdGEuZmllbGRzKSB7XG4gICAgICBvdXQuZmllbGRzW2ZdID0gMTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF0YVxuICAgIGlmIChkZWx0YS5yZW0ubGVuZ3RoKSB7XG4gICAgICBkcy5fZGF0YSA9IFR1cGxlLmlkRmlsdGVyKGRzLl9kYXRhLCBkZWx0YS5yZW0pO1xuICAgIH1cblxuICAgIGlmIChkZWx0YS5hZGQubGVuZ3RoKSB7XG4gICAgICBkcy5fZGF0YSA9IGRzLl9kYXRhLmNvbmNhdChkZWx0YS5hZGQpO1xuICAgIH1cblxuICAgIC8vIGlmIHJlZmxvd2luZywgYWRkIGFueSBvdGhlciB0dXBsZXMgbm90IGN1cnJlbnRseSBpbiBjaGFuZ2VzZXRcbiAgICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgICBkZWx0YS5tb2QgPSBkZWx0YS5tb2QuY29uY2F0KFxuICAgICAgICBUdXBsZS5pZEZpbHRlcihkcy5fZGF0YSwgZGVsdGEuYWRkLCBkZWx0YS5tb2QsIGRlbHRhLnJlbSkpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGNoYW5nZSBsaXN0XG4gICAgZHMuX2lucHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZSgpO1xuXG4gICAgb3V0LmFkZCA9IGRlbHRhLmFkZDsgXG4gICAgb3V0Lm1vZCA9IGRlbHRhLm1vZDtcbiAgICBvdXQucmVtID0gZGVsdGEucmVtO1xuICAgIG91dC5mYWNldCA9IGRzLl9mYWNldDtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gT3V0cHV0IG5vZGUgY2FwdHVyZXMgdGhlIGxhc3QgY2hhbmdlc2V0IHNlZW4gYnkgdGhpcyBkYXRhc291cmNlXG4vLyAobmVlZGVkIGZvciBqb2lucyBhbmQgYnVpbGRzKSBhbmQgbWF0ZXJpYWxpemVzIGFueSBuZXN0ZWQgZGF0YS5cbi8vIElmIHRoaXMgZGF0YXNvdXJjZSBpcyBmYWNldGVkLCBtYXRlcmlhbGl6ZXMgdGhlIHZhbHVlcyBpbiB0aGUgZmFjZXQuXG5mdW5jdGlvbiBEYXRhU291cmNlT3V0cHV0KGRzKSB7XG4gIHZhciBvdXRwdXQgPSBuZXcgTm9kZShkcy5fZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKVxuICAgIC5yZWZsb3dzKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBvdXRwdXQuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkcy5fY29sbGVjdG9yID8gZHMuX2NvbGxlY3Rvci5kYXRhKCkgOiBkcy5fZGF0YTtcbiAgfTtcblxuICBvdXRwdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGxvZy5kZWJ1ZyhpbnB1dCwgWydvdXRwdXQnLCBkcy5fbmFtZV0pO1xuXG4gICAgdmFyIG91dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xuXG4gICAgaWYgKGRzLl9mYWNldCkge1xuICAgICAgZHMuX2ZhY2V0LnZhbHVlcyA9IGRzLnZhbHVlcygpO1xuICAgICAgaW5wdXQuZmFjZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGRzLl9vdXRwdXQgPSBpbnB1dDtcbiAgICBvdXQuZGF0YVtkcy5fbmFtZV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gRGF0YVNvdXJjZUxpc3RlbmVyKGRzKSB7XG4gIHZhciBsID0gbmV3IE5vZGUoZHMuX2dyYXBoKS5yb3V0ZXIodHJ1ZSk7XG5cbiAgbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgLy8gVHVwbGUgZGVyaXZhdGlvbiBjYXJyaWVzIGEgY29zdC4gU28gb25seSBkZXJpdmUgaWYgdGhlIHBpcGVsaW5lIGhhc1xuICAgIC8vIG9wZXJhdG9ycyB0aGF0IG11dGF0ZSwgYW5kIHRodXMgd291bGQgb3ZlcnJpZGUgdGhlIHNvdXJjZSBkYXRhLlxuICAgIGlmIChkcy5tdXRhdGVzKCkpIHsgIFxuICAgICAgdmFyIG1hcCA9IGRzLl9zcmNNYXAgfHwgKGRzLl9zcmNNYXAgPSB7fSksIC8vIHRvIHByb3BhZ2F0ZSB0dXBsZXMgY29ycmVjdGx5XG4gICAgICAgICAgb3V0cHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgICAgIG91dHB1dC5hZGQgPSBpbnB1dC5hZGQubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIChtYXBbdC5faWRdID0gVHVwbGUuZGVyaXZlKHQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBvdXRwdXQubW9kID0gaW5wdXQubW9kLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBUdXBsZS5yZWRlcml2ZSh0LCBtYXBbdC5faWRdKTtcbiAgICAgIH0pO1xuXG4gICAgICBvdXRwdXQucmVtID0gaW5wdXQucmVtLm1hcChmdW5jdGlvbih0KSB7IFxuICAgICAgICB2YXIgbyA9IG1hcFt0Ll9pZF07XG4gICAgICAgIHJldHVybiAobWFwW3QuX2lkXSA9IG51bGwsIG8pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiAoZHMuX2lucHV0ID0gb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChkcy5faW5wdXQgPSBpbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2U7XG4iLCJ2YXIgZGVwcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBBTEw6IFsnZGF0YScsICdmaWVsZHMnLCAnc2NhbGVzJywgJ3NpZ25hbHMnXVxufTtcbmRlcHMuQUxMLmZvckVhY2goZnVuY3Rpb24oaykgeyBkZXBzW2sudG9VcHBlckNhc2UoKV0gPSBrOyB9KTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyksXG4gICAgQ2hhbmdlU2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSxcbiAgICBEYXRhU291cmNlID0gcmVxdWlyZSgnLi9EYXRhU291cmNlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgICBTaWduYWwgPSByZXF1aXJlKCcuL1NpZ25hbCcpLFxuICAgIERlcHMgPSByZXF1aXJlKCcuL0RlcGVuZGVuY2llcycpO1xuXG5mdW5jdGlvbiBHcmFwaCgpIHtcbn1cblxudmFyIHByb3RvdHlwZSA9IEdyYXBoLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhbXAgPSAwO1xuICB0aGlzLl9yYW5rICA9IDA7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuICB0aGlzLl9zaWduYWxzID0ge307XG5cbiAgdGhpcy5kb05vdFByb3BhZ2F0ZSA9IHt9O1xufTtcblxucHJvdG90eXBlLnJhbmsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICsrdGhpcy5fcmFuaztcbn07XG5cbnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbih0eXBlLCBuYW1lcywgaGFzaCkge1xuICB2YXIgZGF0YSA9ICh0eXBlID09PSBEZXBzLlNJR05BTFMgPyB0aGlzLl9zaWduYWxzIDogdGhpcy5fZGF0YSksXG4gICAgICBuID0gKG5hbWVzICE9PSB1bmRlZmluZWQgPyBuYW1lcyA6IGRsLmtleXMoZGF0YSkpLFxuICAgICAgdmFscywgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShuKSkge1xuICAgIHZhbHMgPSBoYXNoIHx8IHt9O1xuICAgIGZvciAoaT0wOyBpPG4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhbHNbbltpXV0gPSBkYXRhW25baV1dLnZhbHVlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YVtuXS52YWx1ZXMoKTtcbiAgfVxufTtcblxuLy8gUmV0YWluIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxucHJvdG90eXBlLmRhdGFWYWx1ZXMgPSBmdW5jdGlvbihuYW1lcykge1xuICByZXR1cm4gdGhpcy52YWx1ZXMoRGVwcy5EQVRBLCBuYW1lcyk7XG59O1xuXG4vLyBSZXRhaW4gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG5wcm90b3R5cGUuc2lnbmFsVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKERlcHMuU0lHTkFMUywgbmFtZXMpO1xufTtcblxucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbihuYW1lLCBwaXBlbGluZSwgZmFjZXQpIHtcbiAgdmFyIGRiID0gdGhpcy5fZGF0YTtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFyIGFsbCA9IFtdLCBrZXk7XG4gICAgZm9yIChrZXkgaW4gZGIpIHsgYWxsLnB1c2goZGJba2V5XSk7IH1cbiAgICByZXR1cm4gYWxsO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGJbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChkYltuYW1lXSA9IG5ldyBEYXRhU291cmNlKHRoaXMsIG5hbWUsIGZhY2V0KS5waXBlbGluZShwaXBlbGluZSkpO1xuICB9XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaW5pdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuYW1lKSA/XG4gICAgICBuYW1lLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBtLl9zaWduYWxzW25dOyB9KSA6XG4gICAgICB0aGlzLl9zaWduYWxzW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodGhpcy5fc2lnbmFsc1tuYW1lXSA9IG5ldyBTaWduYWwodGhpcywgbmFtZSwgaW5pdCkpO1xuICB9XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZWYpKSB7XG4gICAgcmVmID0gZGwuZmllbGQocmVmKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHRoaXMuc2lnbmFsKHJlZlswXSkudmFsdWUoKTtcbiAgaWYgKHJlZi5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaT0xLCBuPXJlZi5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW3JlZltpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIFN0YW1wIHNob3VsZCBiZSBzcGVjaWZpZWQgd2l0aCBjYXV0aW9uLiBJdCBpcyBuZWNlc3NhcnkgZm9yIGlubGluZSBkYXRhc291cmNlcyxcbi8vIHdoaWNoIG5lZWQgdG8gYmUgcG9wdWxhdGVkIGR1cmluZyB0aGUgc2FtZSBjeWNsZSBldmVuIHRob3VnaCBwcm9wYWdhdGlvbiBoYXNcbi8vIHBhc3NlZCB0aGF0IHBhcnQgb2YgdGhlIGRhdGFmbG93IGdyYXBoLiAgXG5wcm90b3R5cGUucHJvcGFnYXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUsIHN0YW1wKSB7XG4gIHZhciBwdWxzZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycywgbmV4dCwgbnBsc2UsIHRwbHMsIG50cGxzLCBpLCBsZW47XG5cbiAgLy8gbmV3IFBRIHdpdGggZWFjaCBwcm9wYWdhdGlvbiBjeWNsZSBzbyB0aGF0IHdlIGNhbiBwdWxzZSBicmFuY2hlc1xuICAvLyBvZiB0aGUgZGF0YWZsb3cgZ3JhcGggZHVyaW5nIGEgcHJvcGFnYXRpb24gKGUuZy4sIHdoZW4gY3JlYXRpbmdcbiAgLy8gYSBuZXcgaW5saW5lIGRhdGFzb3VyY2UpLlxuICB2YXIgcHEgPSBuZXcgSGVhcChmdW5jdGlvbihhLCBiKSB7XG4gICAgLy8gU29ydCBvbiBxcmFuayAocXVldWUtcmFuaykuXG4gICAgLy8gUmFuayBjYW4gY2hhbmdlIGR1cmluZyBwcm9wYWdhdGlvbiBkdWUgdG8gcmV3aXJpbmcuXG4gICAgcmV0dXJuIGEuX3FyYW5rIC0gYi5fcXJhbms7XG4gIH0pO1xuXG4gIGlmIChwdWxzZS5zdGFtcCkgdGhyb3cgRXJyb3IoJ1B1bHNlIGFscmVhZHkgaGFzIGEgbm9uLXplcm8gc3RhbXAuJyk7XG5cbiAgcHVsc2Uuc3RhbXAgPSBzdGFtcCB8fCArK3RoaXMuX3N0YW1wO1xuICBwdWxzZXNbbm9kZS5faWRdID0gcHVsc2U7XG4gIHBxLnB1c2gobm9kZS5xcmFuayh0cnVlKSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICBub2RlICA9IHBxLnBlZWsoKTtcbiAgICBwdWxzZSA9IHB1bHNlc1tub2RlLl9pZF07XG5cbiAgICBpZiAobm9kZS5yYW5rKCkgIT09IG5vZGUucXJhbmsoKSkge1xuICAgICAgLy8gQSBub2RlJ3MgcmFuayBtaWdodCBjaGFuZ2UgZHVyaW5nIGEgcHJvcGFnYXRpb24uIFJlLXF1ZXVlIGlmIHNvLlxuICAgICAgcHEucmVwbGFjZShub2RlLnFyYW5rKHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZhbHVhdGUgbm9kZSBhbmQgcHJvcGFnYXRlIHB1bHNlLlxuICAgICAgcHEucG9wKCk7XG4gICAgICBwdWxzZXNbbm9kZS5faWRdID0gbnVsbDtcbiAgICAgIGxpc3RlbmVycyA9IG5vZGUuX2xpc3RlbmVycztcbiAgICAgIHB1bHNlID0gdGhpcy5ldmFsdWF0ZShwdWxzZSwgbm9kZSk7XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0aGUgcHVsc2UuIFxuICAgICAgaWYgKHB1bHNlICE9PSB0aGlzLmRvTm90UHJvcGFnYXRlKSB7XG4gICAgICAgIC8vIEVuc3VyZSByZWZsb3cgcHVsc2VzIGFsd2F5cyBzZW5kIHJlZmxvdyBwdWxzZXMgZXZlbiBpZiBza2lwcGVkLlxuICAgICAgICBpZiAoIXB1bHNlLnJlZmxvdyAmJiBub2RlLnJlZmxvd3MoKSkge1xuICAgICAgICAgIHB1bHNlID0gQ2hhbmdlU2V0LmNyZWF0ZShwdWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGk9MCwgbGVuPWxpc3RlbmVycy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICBuZXh0ID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgaWYgKChucGxzZSA9IHB1bHNlc1tuZXh0Ll9pZF0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChucGxzZSA9PT0gbnVsbCkgdGhyb3cgRXJyb3IoJ0FscmVhZHkgcHJvcGFnYXRlZCB0byBub2RlLicpO1xuICAgICAgICAgICAgaWYgKG5wbHNlID09PSBwdWxzZSkgY29udGludWU7ICAvLyBSZS1xdWV1ZWluZyB0aGUgc2FtZSBwdWxzZS5cblxuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBub2RlLiBFbnN1cmUgdGhlcmUgc2hvdWxkIGJlIGF0IG1vc3Qgb25lXG4gICAgICAgICAgICAvLyBwdWxzZSB3aXRoIHR1cGxlcyAoYWRkL21vZC9yZW0pLCBhbmQgdGhlIHJlbWFpbmRlciB3aWxsIGJlIHJlZmxvd3MuIFxuICAgICAgICAgICAgdHBscyAgPSBwdWxzZS5hZGQubGVuZ3RoIHx8IHB1bHNlLm1vZC5sZW5ndGggfHwgcHVsc2UucmVtLmxlbmd0aDtcbiAgICAgICAgICAgIG50cGxzID0gbnBsc2UuYWRkLmxlbmd0aCB8fCBucGxzZS5tb2QubGVuZ3RoIHx8IG5wbHNlLnJlbS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh0cGxzICYmIG50cGxzKSB0aHJvdyBFcnJvcignTXVsdGlwbGUgY2hhbmdlc2V0IHB1bHNlcyB0byBzYW1lIG5vZGUnKTtcblxuICAgICAgICAgICAgLy8gQ29tYmluZSByZWZsb3cgYW5kIHR1cGxlcyBpbnRvIGEgc2luZ2xlIHB1bHNlLiBcbiAgICAgICAgICAgIHB1bHNlc1tuZXh0Ll9pZF0gPSB0cGxzID8gcHVsc2UgOiBucGxzZTtcbiAgICAgICAgICAgIHB1bHNlc1tuZXh0Ll9pZF0ucmVmbG93ID0gcHVsc2UucmVmbG93IHx8IG5wbHNlLnJlZmxvdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSdyZSBzZWVpbmcgdGhpcyBub2RlLCBxdWV1ZSBpdCBmb3IgcHJvcGFnYXRpb24uXG4gICAgICAgICAgICBwcS5wdXNoKG5leHQucXJhbmsodHJ1ZSkpO1xuICAgICAgICAgICAgcHVsc2VzW25leHQuX2lkXSA9IHB1bHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gUHJvY2VzcyBhIG5ldyBicmFuY2ggb2YgdGhlIGRhdGFmbG93IGdyYXBoIHByaW9yIHRvIGNvbm5lY3Rpb246XG4vLyAoMSkgSW5zZXJ0IG5ldyBDb2xsZWN0b3Igbm9kZXMgYXMgbmVlZGVkLiBcbi8vICgyKSBUcmFjayArIHJldHVybiBtdXRhdGlvbi9yb3V0aW5nIHN0YXR1cyBvZiB0aGUgYnJhbmNoLlxucHJvdG90eXBlLnByZXByb2Nlc3MgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGdyYXBoID0gdGhpcyxcbiAgICAgIG11dGF0ZXMgPSAwLFxuICAgICAgbm9kZSwgcm91dGVyLCBjb2xsZWN0b3IsIGNvbGxlY3RzO1xuXG4gIGZvciAodmFyIGk9MDsgaTxicmFuY2gubGVuZ3RoOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuXG4gICAgLy8gQmF0Y2ggbm9kZXMgbmVlZCBhY2Nlc3MgdG8gYSBtYXRlcmlhbGl6ZWQgZGF0YXNldC4gXG4gICAgaWYgKG5vZGUuYmF0Y2goKSAmJiAhbm9kZS5fY29sbGVjdG9yKSB7XG4gICAgICBpZiAocm91dGVyIHx8ICFjb2xsZWN0b3IpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICAgICAgICBicmFuY2guc3BsaWNlKGksIDAsIG5vZGUpO1xuICAgICAgICByb3V0ZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuX2NvbGxlY3RvciA9IGNvbGxlY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKGNvbGxlY3RzID0gbm9kZS5jb2xsZWN0b3IoKSkpIGNvbGxlY3RvciA9IG5vZGU7XG4gICAgcm91dGVyICA9IHJvdXRlciAgfHwgbm9kZS5yb3V0ZXIoKSAmJiAhY29sbGVjdHM7XG4gICAgbXV0YXRlcyA9IG11dGF0ZXMgfHwgbm9kZS5tdXRhdGVzKCk7XG5cbiAgICAvLyBBIGNvbGxlY3RvciBuZWVkcyB0byBiZSBpbnNlcnRlZCBhZnRlciB0dXBsZS1wcm9kdWNpbmdcbiAgICAvLyBub2RlcyBmb3IgY29ycmVjdCBwcmV2aW91cyB2YWx1ZSB0cmFja2luZy5cbiAgICBpZiAobm9kZS5wcm9kdWNlcygpKSB7XG4gICAgICBicmFuY2guc3BsaWNlKGkrMSwgMCwgbmV3IENvbGxlY3RvcihncmFwaCkpO1xuICAgICAgcm91dGVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtyb3V0ZXI6IHJvdXRlciwgY29sbGVjdG9yOiBjb2xsZWN0b3IsIG11dGF0ZXM6IG11dGF0ZXN9O1xufTtcblxucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGNvbGxlY3Rvciwgbm9kZSwgZGF0YSwgc2lnbmFscywgaSwgbiwgaiwgbTtcblxuICAvLyBjb25uZWN0IHRoZSBwaXBlbGluZVxuICBmb3IgKGk9MCwgbj1icmFuY2gubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYgKG5vZGUuY29sbGVjdG9yKCkpIGNvbGxlY3RvciA9IG5vZGU7XG5cbiAgICBkYXRhID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuREFUQSk7XG4gICAgZm9yIChqPTAsIG09ZGF0YS5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLmRhdGEoZGF0YVtqXSkuYWRkTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBzaWduYWxzID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUyk7XG4gICAgZm9yIChqPTAsIG09c2lnbmFscy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLnNpZ25hbChzaWduYWxzW2pdKS5hZGRMaXN0ZW5lcihjb2xsZWN0b3IpO1xuICAgIH1cblxuICAgIGlmIChpID4gMCkgYnJhbmNoW2ktMV0uYWRkTGlzdGVuZXIobm9kZSk7XG4gIH1cblxuICByZXR1cm4gYnJhbmNoO1xufTtcblxucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGNvbGxlY3Rvciwgbm9kZSwgZGF0YSwgc2lnbmFscywgaSwgbiwgaiwgbTtcblxuICBmb3IgKGk9MCwgbj1icmFuY2gubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYgKG5vZGUuY29sbGVjdG9yKCkpIGNvbGxlY3RvciA9IG5vZGU7XG5cbiAgICBkYXRhID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuREFUQSk7XG4gICAgZm9yIChqPTAsIG09ZGF0YS5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLmRhdGEoZGF0YVtqXSkucmVtb3ZlTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBzaWduYWxzID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUyk7XG4gICAgZm9yIChqPTAsIG09c2lnbmFscy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLnNpZ25hbChzaWduYWxzW2pdKS5yZW1vdmVMaXN0ZW5lcihjb2xsZWN0b3IpO1xuICAgIH1cblxuICAgIG5vZGUuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvdHlwZS5zeW5jaHJvbml6ZSA9IGZ1bmN0aW9uKGJyYW5jaCkge1xuICB2YXIgaWRzID0ge30sXG4gICAgICBub2RlLCBkYXRhLCBpLCBuLCBqLCBtLCBkLCBpZDtcblxuICBmb3IgKGk9MCwgbj1icmFuY2gubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYgKCFub2RlLmNvbGxlY3RvcigpKSBjb250aW51ZTtcblxuICAgIGZvciAoaj0wLCBkYXRhPW5vZGUuZGF0YSgpLCBtPWRhdGEubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWQgPSAoZCA9IGRhdGFbal0pLl9pZDtcbiAgICAgIGlmIChpZHNbaWRdKSBjb250aW51ZTsgXG4gICAgICBUdXBsZS5wcmV2X3VwZGF0ZShkKTtcbiAgICAgIGlkc1tpZF0gPSAxOyBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgdmFyIHJlZmxvd2VkID0gcHVsc2UucmVmbG93ICYmIG5vZGUubGFzdCgpID49IHB1bHNlLnN0YW1wLFxuICAgICAgcnVuID0gbm9kZS5yb3V0ZXIoKSB8fCBwdWxzZS5hZGQubGVuZ3RoIHx8IHB1bHNlLnJlbS5sZW5ndGg7XG5cbiAgcmV0dXJuIHJ1biB8fCAhcmVmbG93ZWQgfHwgbm9kZS5yZWV2YWx1YXRlKHB1bHNlKTtcbn07XG5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIGlmICghdGhpcy5yZWV2YWx1YXRlKHB1bHNlLCBub2RlKSkgcmV0dXJuIHB1bHNlO1xuICBwdWxzZSA9IG5vZGUuZXZhbHVhdGUocHVsc2UpO1xuICBub2RlLmxhc3QocHVsc2Uuc3RhbXApO1xuICByZXR1cm4gcHVsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoO1xuIiwiZnVuY3Rpb24gSGVhcChjb21wYXJhdG9yKSB7XG4gIHRoaXMuY21wID0gY29tcGFyYXRvcjtcbiAgdGhpcy5ub2RlcyA9IFtdO1xufVxuXG52YXIgcHJvdG90eXBlID0gSGVhcC5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbn07XG5cbnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMubm9kZXMgPSBbXSwgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbn07XG5cbnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYXJyYXkgPSB0aGlzLm5vZGVzO1xuICBhcnJheS5wdXNoKHgpO1xuICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGgtMSwgdGhpcy5jbXApO1xufTtcblxucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJyYXkgPSB0aGlzLm5vZGVzLFxuICAgICAgbGFzdCA9IGFycmF5LnBvcCgpLFxuICAgICAgaXRlbTtcblxuICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gbGFzdDtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCB0aGlzLmNtcCk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbSA9IGxhc3Q7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcyxcbiAgICAgIHJldHZhbCA9IGFycmF5WzBdO1xuICBhcnJheVswXSA9IGl0ZW07XG4gIF9zaWZ0dXAoYXJyYXksIDAsIHRoaXMuY21wKTtcbiAgcmV0dXJuIHJldHZhbDtcbn07XG5cbnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgYXJyYXkgPSB0aGlzLm5vZGVzLCByZWYgPSBhcnJheVswXTtcbiAgaWYgKGFycmF5Lmxlbmd0aCAmJiB0aGlzLmNtcChyZWYsIGl0ZW0pIDwgMCkge1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBpdGVtID0gcmVmO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIHRoaXMuY21wKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cbmZ1bmN0aW9uIF9zaWZ0ZG93bihhcnJheSwgc3RhcnQsIGlkeCwgY21wKSB7XG4gIHZhciBpdGVtLCBwYXJlbnQsIHBpZHg7XG5cbiAgaXRlbSA9IGFycmF5W2lkeF07XG4gIHdoaWxlIChpZHggPiBzdGFydCkge1xuICAgIHBpZHggPSAoaWR4IC0gMSkgPj4gMTtcbiAgICBwYXJlbnQgPSBhcnJheVtwaWR4XTtcbiAgICBpZiAoY21wKGl0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICBhcnJheVtpZHhdID0gcGFyZW50O1xuICAgICAgaWR4ID0gcGlkeDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gKGFycmF5W2lkeF0gPSBpdGVtKTtcbn1cblxuZnVuY3Rpb24gX3NpZnR1cChhcnJheSwgaWR4LCBjbXApIHtcbiAgdmFyIHN0YXJ0ID0gaWR4LFxuICAgICAgZW5kID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXRlbSA9IGFycmF5W2lkeF0sXG4gICAgICBjaWR4ID0gMiAqIGlkeCArIDEsIHJpZHg7XG5cbiAgd2hpbGUgKGNpZHggPCBlbmQpIHtcbiAgICByaWR4ID0gY2lkeCArIDE7XG4gICAgaWYgKHJpZHggPCBlbmQgJiYgY21wKGFycmF5W2NpZHhdLCBhcnJheVtyaWR4XSkgPj0gMCkge1xuICAgICAgY2lkeCA9IHJpZHg7XG4gICAgfVxuICAgIGFycmF5W2lkeF0gPSBhcnJheVtjaWR4XTtcbiAgICBpZHggPSBjaWR4O1xuICAgIGNpZHggPSAyICogaWR4ICsgMTtcbiAgfVxuICBhcnJheVtpZHhdID0gaXRlbTtcbiAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnQsIGlkeCwgY21wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xuIiwidmFyIERFUFMgPSByZXF1aXJlKCcuL0RlcGVuZGVuY2llcycpLkFMTCxcbiAgICBub2RlSUQgPSAwO1xuXG5mdW5jdGlvbiBOb2RlKGdyYXBoKSB7XG4gIGlmIChncmFwaCkgdGhpcy5pbml0KGdyYXBoKTtcbn1cblxudmFyIEZsYWdzID0gTm9kZS5GbGFncyA9IHtcbiAgUm91dGVyOiAgICAgMHgwMSwgLy8gUmVzcG9uc2libGUgZm9yIHByb3BhZ2F0aW5nIHR1cGxlcywgY2Fubm90IGJlIHNraXBwZWQuXG4gIENvbGxlY3RvcjogIDB4MDIsIC8vIEhvbGRzIGEgbWF0ZXJpYWxpemVkIGRhdGFzZXQsIHB1bHNlIG5vZGUgdG8gcmVmbG93LlxuICBQcm9kdWNlczogICAweDA0LCAvLyBQcm9kdWNlcyBuZXcgdHVwbGVzLiBcbiAgTXV0YXRlczogICAgMHgwOCwgLy8gU2V0cyBwcm9wZXJ0aWVzIG9mIGluY29taW5nIHR1cGxlcy5cbiAgUmVmbG93czogICAgMHgxMCwgLy8gRm9yd2FyZHMgYSByZWZsb3cgcHVsc2UuXG4gIEJhdGNoOiAgICAgIDB4MjAgIC8vIFBlcmZvcm1zIGJhdGNoIGRhdGEgcHJvY2Vzc2luZywgbmVlZHMgY29sbGVjdG9yLlxufTtcblxudmFyIHByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuX2lkID0gKytub2RlSUQ7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX3JhbmsgID0gZ3JhcGgucmFuaygpOyAvLyBUb3BvbG9naWNhbCBzb3J0IGJ5IHJhbmtcbiAgdGhpcy5fcXJhbmsgPSBudWxsOyAvLyBSYW5rIHdoZW4gZW5xdWV1ZWQgZm9yIHByb3BhZ2F0aW9uXG4gIHRoaXMuX3N0YW1wID0gMDsgICAgLy8gTGFzdCBzdGFtcCBzZWVuXG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX2xpc3RlbmVycy5faWRzID0ge307IC8vIFRvIHByZXZlbnQgZHVwbGljYXRlIGxpc3RlbmVyc1xuXG4gIC8vIEluaXRpYWxpemUgZGVwZW5kZW5jaWVzLlxuICB0aGlzLl9kZXBzID0ge307XG4gIGZvciAodmFyIGk9MCwgbj1ERVBTLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB0aGlzLl9kZXBzW0RFUFNbaV1dID0gW107XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHN0YXR1cyBmbGFncy5cbiAgdGhpcy5fZmxhZ3MgPSAwO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJhbmsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jhbms7XG59O1xuXG5wcm90b3R5cGUucXJhbmsgPSBmdW5jdGlvbigvKiBzZXQgKi8pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcXJhbms7XG4gIHJldHVybiAodGhpcy5fcXJhbmsgPSB0aGlzLl9yYW5rLCB0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oc3RhbXApIHsgXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3N0YW1wO1xuICByZXR1cm4gKHRoaXMuX3N0YW1wID0gc3RhbXAsIHRoaXMpO1xufTtcblxuLy8gLS0gc3RhdHVzIGZsYWdzIC0tLVxuXG5wcm90b3R5cGUuX3NldGYgPSBmdW5jdGlvbih2LCBiKSB7XG4gIGlmIChiKSB7IHRoaXMuX2ZsYWdzIHw9IHY7IH0gZWxzZSB7IHRoaXMuX2ZsYWdzICY9IH52OyB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLlJvdXRlcik7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLlJvdXRlciwgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLmNvbGxlY3RvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLkNvbGxlY3Rvcik7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLkNvbGxlY3Rvciwgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLnByb2R1Y2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuUHJvZHVjZXMpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5Qcm9kdWNlcywgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLm11dGF0ZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5NdXRhdGVzKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuTXV0YXRlcywgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLnJlZmxvd3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5SZWZsb3dzKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuUmVmbG93cywgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuQmF0Y2gpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5CYXRjaCwgc3RhdGUpO1xufTtcblxucHJvdG90eXBlLmRlcGVuZGVuY3kgPSBmdW5jdGlvbih0eXBlLCBkZXBzKSB7XG4gIHZhciBkID0gdGhpcy5fZGVwc1t0eXBlXSxcbiAgICAgIG4gPSBkLl9uYW1lcyB8fCAoZC5fbmFtZXMgPSB7fSk7ICAvLyBUbyBwcmV2ZW50IGR1cGUgZGVwc1xuXG4gIC8vIEdldCBkZXBlbmRlbmNpZXMgb2YgdGhlIGdpdmVuIHR5cGVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGlmIChkZXBzID09PSBudWxsKSB7XG4gICAgLy8gQ2xlYXIgZGVwZW5kZW5jaWVzIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZC5zcGxpY2UoMCwgZC5sZW5ndGgpO1xuICAgIGQuX25hbWVzID0ge307XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAvLyBTZXBhcmF0ZSB0aGlzIGNhc2UgdG8gYXZvaWQgY29zdCBvZiBhcnJheSBjcmVhdGlvblxuICAgIGlmIChuW2RlcHNdKSByZXR1cm4gdGhpcztcbiAgICBkLnB1c2goZGVwcyk7XG4gICAgbltkZXBzXSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49ZGVwcy5sZW5ndGgsIGRlcDsgaTxsZW47ICsraSkge1xuICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgIGlmIChuW2RlcF0pIGNvbnRpbnVlO1xuICAgICAgZC5wdXNoKGRlcCk7XG4gICAgICBuW2RlcF0gPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzO1xufTtcblxucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZiAoIShsIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcignTGlzdGVuZXIgaXMgbm90IGEgTm9kZScpO1xuICB9XG4gIGlmICh0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0pIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKGwpO1xuICB0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0gPSAxO1xuICBpZiAodGhpcy5fcmFuayA+IGwuX3JhbmspIHtcbiAgICB2YXIgcSA9IFtsXSxcbiAgICAgICAgZyA9IHRoaXMuX2dyYXBoLCBjdXI7XG4gICAgd2hpbGUgKHEubGVuZ3RoKSB7XG4gICAgICBjdXIgPSBxLnNoaWZ0KCk7XG4gICAgICBjdXIuX3JhbmsgPSBnLnJhbmsoKTtcbiAgICAgIHEudW5zaGlmdC5hcHBseShxLCBjdXIubGlzdGVuZXJzKCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycy5faWRzW2wuX2lkXSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgdmFyIGlkeCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGwpLFxuICAgICAgYiA9IGlkeCA+PSAwO1xuXG4gIGlmIChiKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX2xpc3RlbmVycy5faWRzW2wuX2lkXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fbGlzdGVuZXJzLl9pZHMgPSB7fTtcbn07XG5cbi8vIEV2YWx1YXRlIHRoaXMgZGF0YWZsb3cgbm9kZSBmb3IgdGhlIGN1cnJlbnQgcHVsc2UuXG4vLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSBwcm9jZXNzaW5nLlxucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHtcbiAgcmV0dXJuIHB1bHNlO1xufTtcblxuLy8gU2hvdWxkIHRoaXMgbm9kZSBiZSByZS1ldmFsdWF0ZWQgZm9yIHRoZSBjdXJyZW50IHB1bHNlP1xuLy8gU2VhcmNoZXMgcHVsc2UgdG8gc2VlIGlmIGFueSBkZXBlbmRlbmNpZXMgaGF2ZSB1cGRhdGVkLlxucHJvdG90eXBlLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgcHJvcCwgZGVwLCBpLCBuLCBqLCBtO1xuXG4gIGZvciAoaT0wLCBuPURFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBERVBTW2ldO1xuICAgIGRlcCA9IHRoaXMuX2RlcHNbcHJvcF07XG4gICAgZm9yIChqPTAsIG09ZGVwLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChwdWxzZVtwcm9wXVtkZXBbal1dKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ob2RlLnJlc2V0ID0gZnVuY3Rpb24oKSB7IG5vZGVJRCA9IDA7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsInZhciBDaGFuZ2VTZXQgPSByZXF1aXJlKCcuL0NoYW5nZVNldCcpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgQmFzZSA9IE5vZGUucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBTaWduYWwoZ3JhcGgsIG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICBCYXNlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX25hbWUgID0gbmFtZTtcbiAgdGhpcy5fdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIHRoaXMuX3ZlcmJvc2UgPSBmYWxzZTsgLy8gVmVyYm9zZSBzaWduYWxzIHJlLXB1bHNlIHRoZSBncmFwaCBldmVuIGlmIHByZXYgPT09IHZhbC5cbiAgdGhpcy5faGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoU2lnbmFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2lnbmFsO1xuXG5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbmFtZTtcbn07XG5cbnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgcmV0dXJuICh0aGlzLl92YWx1ZSA9IHZhbCwgdGhpcyk7XG59O1xuXG4vLyBBbGlhcyB0byB2YWx1ZSwgZm9yIHNoYXJlZCBBUEkgd2l0aCBEYXRhU291cmNlXG5wcm90b3R5cGUudmFsdWVzID0gcHJvdG90eXBlLnZhbHVlO1xuXG5wcm90b3R5cGUudmVyYm9zZSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmVyYm9zZTtcbiAgcmV0dXJuICh0aGlzLl92ZXJib3NlID0gISF2LCB0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5zaWduYWxzW3RoaXMuX25hbWVdID8gaW5wdXQgOiB0aGlzLl9ncmFwaC5kb05vdFByb3BhZ2F0ZTtcbn07XG5cbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oY3MpIHtcbiAgaWYgKCFjcykgY3MgPSBDaGFuZ2VTZXQuY3JlYXRlKG51bGwsIHRydWUpO1xuICBjcy5zaWduYWxzW3RoaXMuX25hbWVdID0gMTtcbiAgdGhpcy5fZ3JhcGgucHJvcGFnYXRlKGNzLCB0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHNpZ25hbCA9IHRoaXMsXG4gICAgICBub2RlID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpO1xuXG4gIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGhhbmRsZXIoc2lnbmFsLm5hbWUoKSwgc2lnbmFsLnZhbHVlKCkpO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICB0aGlzLl9oYW5kbGVycy5wdXNoKHtcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIG5vZGU6IG5vZGVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIobm9kZSk7XG59O1xuXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzLCBpLCB4O1xuXG4gIGZvciAoaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIHggPSBoLnNwbGljZShpLCAxKVswXTtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoeC5ub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmFsO1xuIiwidmFyIHR1cGxlSUQgPSAwO1xuXG5mdW5jdGlvbiBpbmdlc3QoZGF0dW0pIHtcbiAgZGF0dW0gPSAoZGF0dW0gPT09IE9iamVjdChkYXR1bSkpID8gZGF0dW0gOiB7ZGF0YTogZGF0dW19O1xuICBkYXR1bS5faWQgPSArK3R1cGxlSUQ7XG4gIGlmIChkYXR1bS5fcHJldikgZGF0dW0uX3ByZXYgPSBudWxsO1xuICByZXR1cm4gZGF0dW07XG59XG5cbmZ1bmN0aW9uIGlkTWFwKGEsIGlkcykge1xuICBpZHMgPSBpZHMgfHwge307XG4gIGZvciAodmFyIGk9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpZHNbYVtpXS5faWRdID0gMTtcbiAgfVxuICByZXR1cm4gaWRzO1xufVxuXG5mdW5jdGlvbiBjb3B5KHQsIGMpIHtcbiAgYyA9IGMgfHwge307XG4gIGZvciAodmFyIGsgaW4gdCkge1xuICAgIGlmIChrICE9PSAnX3ByZXYnICYmIGsgIT09ICdfaWQnKSBjW2tdID0gdFtrXTtcbiAgfVxuICByZXR1cm4gYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluZ2VzdDogaW5nZXN0LFxuICBpZE1hcDogaWRNYXAsXG5cbiAgZGVyaXZlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGluZ2VzdChjb3B5KGQpKTtcbiAgfSxcblxuICByZWRlcml2ZTogZnVuY3Rpb24oZCwgdCkge1xuICAgIHJldHVybiBjb3B5KGQsIHQpO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24odCwgaywgdikge1xuICAgIHJldHVybiB0W2tdID09PSB2ID8gMCA6ICh0W2tdID0gdiwgMSk7XG4gIH0sXG5cbiAgcHJldjogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0Ll9wcmV2IHx8IHQ7XG4gIH0sXG5cbiAgcHJldl9pbml0OiBmdW5jdGlvbih0KSB7XG4gICAgaWYgKCF0Ll9wcmV2KSB7IHQuX3ByZXYgPSB7X2lkOiB0Ll9pZH07IH1cbiAgfSxcblxuICBwcmV2X3VwZGF0ZTogZnVuY3Rpb24odCkge1xuICAgIHZhciBwID0gdC5fcHJldiwgaywgdjtcbiAgICBpZiAocCkgZm9yIChrIGluIHQpIHtcbiAgICAgIGlmIChrICE9PSAnX3ByZXYnICYmIGsgIT09ICdfaWQnKSB7XG4gICAgICAgIHBba10gPSAoKHY9dFtrXSkgaW5zdGFuY2VvZiBPYmplY3QgJiYgdi5fcHJldikgPyB2Ll9wcmV2IDogdjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB0dXBsZUlEID0gMDsgfSxcblxuICBpZEZpbHRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBpZHMgPSB7fTtcbiAgICBmb3IgKHZhciBpPWFyZ3VtZW50cy5sZW5ndGg7IC0taT4wOykge1xuICAgICAgaWRNYXAoYXJndW1lbnRzW2ldLCBpZHMpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlkc1t4Ll9pZF07IH0pO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIENoYW5nZVNldDogICAgcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSxcbiAgQ29sbGVjdG9yOiAgICByZXF1aXJlKCcuL0NvbGxlY3RvcicpLFxuICBEYXRhU291cmNlOiAgIHJlcXVpcmUoJy4vRGF0YVNvdXJjZScpLFxuICBEZXBlbmRlbmNpZXM6IHJlcXVpcmUoJy4vRGVwZW5kZW5jaWVzJyksXG4gIEdyYXBoOiAgICAgICAgcmVxdWlyZSgnLi9HcmFwaCcpLFxuICBOb2RlOiAgICAgICAgIHJlcXVpcmUoJy4vTm9kZScpLFxuICBTaWduYWw6ICAgICAgIHJlcXVpcmUoJy4vU2lnbmFsJyksXG4gIFR1cGxlOiAgICAgICAgcmVxdWlyZSgnLi9UdXBsZScpLFxuICBkZWJ1ZzogICAgICAgIHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLmRlYnVnXG59O1xuIiwiZnVuY3Rpb24gdG9NYXAobGlzdCkge1xuICB2YXIgbWFwID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPWxpc3QubGVuZ3RoOyBpPG47ICsraSkgbWFwW2xpc3RbaV1dID0gMTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgdmFyIGxpc3QgPSBbXSwgaztcbiAgZm9yIChrIGluIG9iamVjdCkgbGlzdC5wdXNoKGspO1xuICByZXR1cm4gbGlzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgY29uc3RhbnRzID0gb3B0LmNvbnN0YW50cyB8fCByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgICAgZnVuY3Rpb25zID0gKG9wdC5mdW5jdGlvbnMgfHwgcmVxdWlyZSgnLi9mdW5jdGlvbnMnKSkoY29kZWdlbiksXG4gICAgICBpZFdoaXRlTGlzdCA9IG9wdC5pZFdoaXRlTGlzdCA/IHRvTWFwKG9wdC5pZFdoaXRlTGlzdCkgOiBudWxsLFxuICAgICAgaWRCbGFja0xpc3QgPSBvcHQuaWRCbGFja0xpc3QgPyB0b01hcChvcHQuaWRCbGFja0xpc3QpIDogbnVsbCxcbiAgICAgIG1lbWJlckRlcHRoID0gMCxcbiAgICAgIEZJRUxEX1ZBUiA9IG9wdC5maWVsZFZhciB8fCAnZGF0dW0nLFxuICAgICAgR0xPQkFMX1ZBUiA9IG9wdC5nbG9iYWxWYXIgfHwgJ3NpZ25hbHMnLFxuICAgICAgZ2xvYmFscyA9IHt9LFxuICAgICAgZmllbGRzID0ge307XG5cbiAgZnVuY3Rpb24gY29kZWdlbl93cmFwKGFzdCkgeyAgICBcbiAgICB2YXIgcmV0dmFsID0ge1xuICAgICAgY29kZTogY29kZWdlbihhc3QpLFxuICAgICAgZ2xvYmFsczoga2V5cyhnbG9iYWxzKSxcbiAgICAgIGZpZWxkczoga2V5cyhmaWVsZHMpXG4gICAgfTtcbiAgICBnbG9iYWxzID0ge307XG4gICAgZmllbGRzID0ge307XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEdsb2JhbChpZCkge1xuICAgIHJldHVybiBHTE9CQUxfVkFSICsgJ1tcIicgKyBpZCArICdcIl0nO1xuICB9XG5cbiAgZnVuY3Rpb24gY29kZWdlbihhc3QpIHtcbiAgICBpZiAodHlwZW9mIGFzdCA9PT0gJ3N0cmluZycpIHJldHVybiBhc3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IENPREVHRU5fVFlQRVNbYXN0LnR5cGVdO1xuICAgIGlmIChnZW5lcmF0b3IgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgYXN0LnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdG9yKGFzdCk7XG4gIH1cblxuICB2YXIgQ09ERUdFTl9UWVBFUyA9IHtcbiAgICAnTGl0ZXJhbCc6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4ucmF3O1xuICAgICAgfSxcbiAgICAnSWRlbnRpZmllcic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGlkID0gbi5uYW1lO1xuICAgICAgICBpZiAobWVtYmVyRGVwdGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50c1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkV2hpdGVMaXN0KSB7XG4gICAgICAgICAgaWYgKGlkV2hpdGVMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxzW2lkXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwR2xvYmFsKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkQmxhY2tMaXN0ICYmIGlkQmxhY2tMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBpZGVudGlmaWVyOiAnICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0sXG4gICAgJ1Byb2dyYW0nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLmJvZHkubWFwKGNvZGVnZW4pLmpvaW4oJ1xcbicpO1xuICAgICAgfSxcbiAgICAnTWVtYmVyRXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGQgPSAhbi5jb21wdXRlZDtcbiAgICAgICAgdmFyIG8gPSBjb2RlZ2VuKG4ub2JqZWN0KTtcbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBwID0gY29kZWdlbihuLnByb3BlcnR5KTtcbiAgICAgICAgaWYgKG8gPT09IEZJRUxEX1ZBUikgeyBmaWVsZHNbcF0gPSAxOyB9IC8vIEhBQ0tpc2guLi5cbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBvICsgKGQgPyAnLicrcCA6ICdbJytwKyddJyk7XG4gICAgICB9LFxuICAgICdDYWxsRXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgaWYgKG4uY2FsbGVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjYWxsZWUgdHlwZTogJyArIG4uY2FsbGVlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lO1xuICAgICAgICB2YXIgYXJncyA9IG4uYXJndW1lbnRzO1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoY2FsbGVlKSAmJiBmdW5jdGlvbnNbY2FsbGVlXTtcbiAgICAgICAgaWYgKCFmbikgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgZnVuY3Rpb246ICcgKyBjYWxsZWUpO1xuICAgICAgICByZXR1cm4gZm4gaW5zdGFuY2VvZiBGdW5jdGlvbiA/XG4gICAgICAgICAgZm4oYXJncykgOlxuICAgICAgICAgIGZuICsgJygnICsgYXJncy5tYXAoY29kZWdlbikuam9pbignLCcpICsgJyknO1xuICAgICAgfSxcbiAgICAnQXJyYXlFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJ1snICsgbi5lbGVtZW50cy5tYXAoY29kZWdlbikuam9pbignLCcpICsgJ10nO1xuICAgICAgfSxcbiAgICAnQmluYXJ5RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICcoJyArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgJyknO1xuICAgICAgfSxcbiAgICAnVW5hcnlFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJygnICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5hcmd1bWVudCkgKyAnKSc7XG4gICAgICB9LFxuICAgICdDb25kaXRpb25hbEV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyBjb2RlZ2VuKG4udGVzdCkgK1xuICAgICAgICAgICc/JyArIGNvZGVnZW4obi5jb25zZXF1ZW50KSArXG4gICAgICAgICAgJzonICsgY29kZWdlbihuLmFsdGVybmF0ZSkgK1xuICAgICAgICAgICcpJztcbiAgICAgIH0sXG4gICAgJ0xvZ2ljYWxFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJygnICsgY29kZWdlbihuLmxlZnQpICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5yaWdodCkgKyAnKSc7XG4gICAgICB9LFxuICAgICdPYmplY3RFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJ3snICsgbi5wcm9wZXJ0aWVzLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnfSc7XG4gICAgICB9LFxuICAgICdQcm9wZXJ0eSc6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgICAgdmFyIGsgPSBjb2RlZ2VuKG4ua2V5KTtcbiAgICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgICAgcmV0dXJuIGsgKyAnOicgKyBjb2RlZ2VuKG4udmFsdWUpO1xuICAgICAgfSxcbiAgICAnRXhwcmVzc2lvblN0YXRlbWVudCc6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW4obi5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgfTtcblxuICBjb2RlZ2VuX3dyYXAuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICBjb2RlZ2VuX3dyYXAuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICByZXR1cm4gY29kZWdlbl93cmFwO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnTmFOJzogICAgICdOYU4nLFxuICAnRSc6ICAgICAgICdNYXRoLkUnLFxuICAnTE4yJzogICAgICdNYXRoLkxOMicsXG4gICdMTjEwJzogICAgJ01hdGguTE4xMCcsXG4gICdMT0cyRSc6ICAgJ01hdGguTE9HMkUnLFxuICAnTE9HMTBFJzogICdNYXRoLkxPRzEwRScsXG4gICdQSSc6ICAgICAgJ01hdGguUEknLFxuICAnU1FSVDFfMic6ICdNYXRoLlNRUlQxXzInLFxuICAnU1FSVDInOiAgICdNYXRoLlNRUlQyJ1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvZGVnZW4pIHtcblxuICBmdW5jdGlvbiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSkge1xuICAgIHZhciBvYmogPSBjb2RlZ2VuKGFyZ3NbMF0pO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgJygnICsgb2JqICsgJyknO1xuICAgICAgaWYgKGNhc3QubGFzdEluZGV4T2YoJ25ldyAnLCAwKSA9PT0gMCkgb2JqID0gJygnICsgb2JqICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gb2JqICsgJy4nICsgbmFtZSArICh0eXBlIDwgMCA/ICcnIDogdHlwZSA9PT0gMCA/XG4gICAgICAnKCknIDpcbiAgICAgICcoJyArIGFyZ3Muc2xpY2UoMSkubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICcpJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbihuYW1lLCBjYXN0LCB0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBEQVRFID0gJ25ldyBEYXRlJyxcbiAgICAgIFNUUklORyA9ICdTdHJpbmcnLFxuICAgICAgUkVHRVhQID0gJ1JlZ0V4cCc7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBNQVRIIGZ1bmN0aW9uc1xuICAgICdpc05hTic6ICAgICdpc05hTicsXG4gICAgJ2lzRmluaXRlJzogJ2lzRmluaXRlJyxcbiAgICAnYWJzJzogICAgICAnTWF0aC5hYnMnLFxuICAgICdhY29zJzogICAgICdNYXRoLmFjb3MnLFxuICAgICdhc2luJzogICAgICdNYXRoLmFzaW4nLFxuICAgICdhdGFuJzogICAgICdNYXRoLmF0YW4nLFxuICAgICdhdGFuMic6ICAgICdNYXRoLmF0YW4yJyxcbiAgICAnY2VpbCc6ICAgICAnTWF0aC5jZWlsJyxcbiAgICAnY29zJzogICAgICAnTWF0aC5jb3MnLFxuICAgICdleHAnOiAgICAgICdNYXRoLmV4cCcsXG4gICAgJ2Zsb29yJzogICAgJ01hdGguZmxvb3InLFxuICAgICdsb2cnOiAgICAgICdNYXRoLmxvZycsXG4gICAgJ21heCc6ICAgICAgJ01hdGgubWF4JyxcbiAgICAnbWluJzogICAgICAnTWF0aC5taW4nLFxuICAgICdwb3cnOiAgICAgICdNYXRoLnBvdycsXG4gICAgJ3JhbmRvbSc6ICAgJ01hdGgucmFuZG9tJyxcbiAgICAncm91bmQnOiAgICAnTWF0aC5yb3VuZCcsXG4gICAgJ3Npbic6ICAgICAgJ01hdGguc2luJyxcbiAgICAnc3FydCc6ICAgICAnTWF0aC5zcXJ0JyxcbiAgICAndGFuJzogICAgICAnTWF0aC50YW4nLFxuXG4gICAgJ2NsYW1wJzogZnVuY3Rpb24oYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIHZhciBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICByZXR1cm4gJ01hdGgubWF4KCcrYVsxXSsnLCBNYXRoLm1pbignK2FbMl0rJywnK2FbMF0rJykpJztcbiAgICB9LFxuXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICAnbm93JzogICAgICAgICAgICAgJ0RhdGUubm93JyxcbiAgICAnZGF0ZXRpbWUnOiAgICAgICAgREFURSxcbiAgICAnZGF0ZSc6ICAgICAgICAgICAgZm4oJ2dldERhdGUnLCBEQVRFLCAwKSxcbiAgICAnZGF5JzogICAgICAgICAgICAgZm4oJ2dldERheScsIERBVEUsIDApLFxuICAgICd5ZWFyJzogICAgICAgICAgICBmbignZ2V0RnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICAnbW9udGgnOiAgICAgICAgICAgZm4oJ2dldE1vbnRoJywgREFURSwgMCksXG4gICAgJ2hvdXJzJzogICAgICAgICAgIGZuKCdnZXRIb3VycycsIERBVEUsIDApLFxuICAgICdtaW51dGVzJzogICAgICAgICBmbignZ2V0TWludXRlcycsIERBVEUsIDApLFxuICAgICdzZWNvbmRzJzogICAgICAgICBmbignZ2V0U2Vjb25kcycsIERBVEUsIDApLFxuICAgICdtaWxsaXNlY29uZHMnOiAgICBmbignZ2V0TWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgJ3RpbWUnOiAgICAgICAgICAgIGZuKCdnZXRUaW1lJywgREFURSwgMCksXG4gICAgJ3RpbWV6b25lb2Zmc2V0JzogIGZuKCdnZXRUaW1lem9uZU9mZnNldCcsIERBVEUsIDApLFxuICAgICd1dGNkYXRlJzogICAgICAgICBmbignZ2V0VVRDRGF0ZScsIERBVEUsIDApLFxuICAgICd1dGNkYXknOiAgICAgICAgICBmbignZ2V0VVRDRGF5JywgREFURSwgMCksXG4gICAgJ3V0Y3llYXInOiAgICAgICAgIGZuKCdnZXRVVENGdWxsWWVhcicsIERBVEUsIDApLFxuICAgICd1dGNtb250aCc6ICAgICAgICBmbignZ2V0VVRDTW9udGgnLCBEQVRFLCAwKSxcbiAgICAndXRjaG91cnMnOiAgICAgICAgZm4oJ2dldFVUQ0hvdXJzJywgREFURSwgMCksXG4gICAgJ3V0Y21pbnV0ZXMnOiAgICAgIGZuKCdnZXRVVENNaW51dGVzJywgREFURSwgMCksXG4gICAgJ3V0Y3NlY29uZHMnOiAgICAgIGZuKCdnZXRVVENTZWNvbmRzJywgREFURSwgMCksXG4gICAgJ3V0Y21pbGxpc2Vjb25kcyc6IGZuKCdnZXRVVENNaWxsaXNlY29uZHMnLCBEQVRFLCAwKSxcblxuICAgIC8vIHNoYXJlZCBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICAnbGVuZ3RoJzogICAgICBmbignbGVuZ3RoJywgbnVsbCwgLTEpLFxuICAgICdpbmRleG9mJzogICAgIGZuKCdpbmRleE9mJywgbnVsbCksXG4gICAgJ2xhc3RpbmRleG9mJzogZm4oJ2xhc3RJbmRleE9mJywgbnVsbCksXG5cbiAgICAvLyBTVFJJTkcgZnVuY3Rpb25zXG4gICAgJ3BhcnNlRmxvYXQnOiAgJ3BhcnNlRmxvYXQnLFxuICAgICdwYXJzZUludCc6ICAgICdwYXJzZUludCcsXG4gICAgJ3VwcGVyJzogICAgICAgZm4oJ3RvVXBwZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICAnbG93ZXInOiAgICAgICBmbigndG9Mb3dlckNhc2UnLCBTVFJJTkcsIDApLFxuICAgICdzbGljZSc6ICAgICAgIGZuKCdzbGljZScsIFNUUklORyksXG4gICAgJ3N1YnN0cmluZyc6ICAgZm4oJ3N1YnN0cmluZycsIFNUUklORyksXG5cbiAgICAvLyBSRUdFWFAgZnVuY3Rpb25zXG4gICAgJ3JlZ2V4cCc6ICBSRUdFWFAsXG4gICAgJ3Rlc3QnOiAgICBmbigndGVzdCcsIFJFR0VYUCksXG5cbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgJ2lmJzogZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgICB2YXIgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgICByZXR1cm4gYVswXSsnPycrYVsxXSsnOicrYVsyXTtcbiAgICAgIH1cbiAgfTtcbn07IiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyksXG4gICAgY29kZWdlbiA9IHJlcXVpcmUoJy4vY29kZWdlbicpO1xuICAgIFxudmFyIGV4cHIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBvcHQpIHtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2UoJygnK2lucHV0KycpJywgb3B0KTtcbiAgICB9LFxuICBjb2RlOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgIHJldHVybiBjb2RlZ2VuKG9wdCk7XG4gICAgfSxcbiAgY29tcGlsZXI6IGZ1bmN0aW9uKGFyZ3MsIG9wdCkge1xuICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBjb2RlZ2VuKG9wdCksXG4gICAgICAgICAgbGVuID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgY29tcGlsZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2VuZXJhdG9yKGV4cHIucGFyc2Uoc3RyKSk7XG4gICAgICAgICAgICBhcmdzW2xlbl0gPSAnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIHZhbHVlLmNvZGUgKyAnKTsnO1xuICAgICAgICAgICAgdmFsdWUuZm4gPSBGdW5jdGlvbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgY29tcGlsZS5jb2RlZ2VuID0gZ2VuZXJhdG9yO1xuICAgICAgcmV0dXJuIGNvbXBpbGU7XG4gICAgfSxcbiAgZnVuY3Rpb25zOiByZXF1aXJlKCcuL2Z1bmN0aW9ucycpLFxuICBjb25zdGFudHM6IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbn07XG4iLCIvKlxuICBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb24gcGFyc2VyIGlzIGJhc2VkIG9uIEVzcHJpbWEgKGh0dHA6Ly9lc3ByaW1hLm9yZy8pLlxuICBPcmlnaW5hbCBoZWFkZXIgY29tbWVudCBhbmQgbGljZW5zZSBmb3IgRXNwcmltYSBpcyBpbmNsdWRlZCBoZXJlOlxuXG4gIENvcHlyaWdodCAoQykgMjAxMyBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIFRoYWRkZWUgVHlsIDx0aGFkZGVlLnR5bEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBUb2tlbixcbiAgICAgIFRva2VuTmFtZSxcbiAgICAgIFN5bnRheCxcbiAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgIE1lc3NhZ2VzLFxuICAgICAgUmVnZXgsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdHJpY3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxpbmVOdW1iZXIsXG4gICAgICBsaW5lU3RhcnQsXG4gICAgICBsZW5ndGgsXG4gICAgICBsb29rYWhlYWQsXG4gICAgICBzdGF0ZSxcbiAgICAgIGV4dHJhO1xuXG4gIFRva2VuID0ge1xuICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICBFT0Y6IDIsXG4gICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgS2V5d29yZDogNCxcbiAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgIFJlZ3VsYXJFeHByZXNzaW9uOiA5XG4gIH07XG5cbiAgVG9rZW5OYW1lID0ge307XG4gIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG4gIFRva2VuTmFtZVtUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbl0gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuXG4gIFN5bnRheCA9IHtcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nXG4gIH07XG5cbiAgUHJvcGVydHlLaW5kID0ge1xuICAgICAgRGF0YTogMSxcbiAgICAgIEdldDogMixcbiAgICAgIFNldDogNFxuICB9O1xuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gIE1lc3NhZ2VzID0ge1xuICAgICAgVW5leHBlY3RlZFRva2VuOiAgJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgVW5leHBlY3RlZE51bWJlcjogICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgICBVbmV4cGVjdGVkU3RyaW5nOiAgJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAgJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICAgIFVuZXhwZWN0ZWRFT1M6ICAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgTm9DYXRjaE9yRmluYWxseTogICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXG4gICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdE1vZGVXaXRoOiAgJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFZhck5hbWU6ICAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFBhcmFtTmFtZTogICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdERlbGV0ZTogICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIGRhdGEgYW5kIGFjY2Vzc29yIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBBY2Nlc3NvckdldFNldDogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQb3N0Zml4OiAgJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQcmVmaXg6ICAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAgJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZSdcbiAgfTtcblxuICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICBSZWdleCA9IHtcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpLFxuICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gIH1cblxuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gIH1cblxuICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgfVxuXG4gIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gIGZ1bmN0aW9uIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICBjYXNlICdlbnVtJzpcbiAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICBjYXNlICdleHRlbmRzJzpcbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIDcuNi4xLjEgS2V5d29yZHNcblxuICBmdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcbiAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAvLyAneWllbGQnIGFuZCAnbGV0JyBhcmUgZm9yIGNvbXBhdGlibGl0eSB3aXRoIFNwaWRlck1vbmtleSBhbmQgRVMubmV4dC5cbiAgICAgIC8vIFNvbWUgb3RoZXJzIGFyZSBmcm9tIGZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cblxuICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgIHZhciBjaCwgc3RhcnQ7XG5cbiAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBjb2RlID0gMDtcblxuICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICB9XG4gICAgICBjdTEgPSAoKGNvZGUgLSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICBjdTIgPSAoKGNvZGUgLSAweDEwMDAwKSAmIDEwMjMpICsgMHhEQzAwO1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICAgICAgaWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkID0gY2g7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgY2g7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgaWQsIHR5cGU7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICBpZCA9IChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUMpID8gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSA6IGdldElkZW50aWZpZXIoKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLktleXdvcmQ7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjcgUHVuY3R1YXRvcnNcblxuICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgIHZhciBzdGFydCA9IGluZGV4LFxuICAgICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICAgICAgY29kZTIsXG4gICAgICAgICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICAgICAgICBjaDIsXG4gICAgICAgICAgY2gzLFxuICAgICAgICAgIGNoNDtcblxuICAgICAgc3dpdGNoIChjb2RlKSB7XG5cbiAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgY2FzZSAweDJFOiAgLy8gLiBkb3RcbiAgICAgIGNhc2UgMHgyODogIC8vICggb3BlbiBicmFja2V0XG4gICAgICBjYXNlIDB4Mjk6ICAvLyApIGNsb3NlIGJyYWNrZXRcbiAgICAgIGNhc2UgMHgzQjogIC8vIDsgc2VtaWNvbG9uXG4gICAgICBjYXNlIDB4MkM6ICAvLyAsIGNvbW1hXG4gICAgICBjYXNlIDB4N0I6ICAvLyB7IG9wZW4gY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg3RDogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg1QjogIC8vIFtcbiAgICAgIGNhc2UgMHg1RDogIC8vIF1cbiAgICAgIGNhc2UgMHgzQTogIC8vIDpcbiAgICAgIGNhc2UgMHgzRjogIC8vID9cbiAgICAgIGNhc2UgMHg3RTogIC8vIH5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4N0IpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29kZTIgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHgyQjogIC8vICtcbiAgICAgICAgICAgICAgY2FzZSAweDJEOiAgLy8gLVxuICAgICAgICAgICAgICBjYXNlIDB4MkY6ICAvLyAvXG4gICAgICAgICAgICAgIGNhc2UgMHgzQzogIC8vIDxcbiAgICAgICAgICAgICAgY2FzZSAweDNFOiAgLy8gPlxuICAgICAgICAgICAgICBjYXNlIDB4NUU6ICAvLyBeXG4gICAgICAgICAgICAgIGNhc2UgMHg3QzogIC8vIHxcbiAgICAgICAgICAgICAgY2FzZSAweDI1OiAgLy8gJVxuICAgICAgICAgICAgICBjYXNlIDB4MjY6ICAvLyAmXG4gICAgICAgICAgICAgIGNhc2UgMHgyQTogIC8vICpcbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUyKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNhc2UgMHgyMTogLy8gIVxuICAgICAgICAgICAgICBjYXNlIDB4M0Q6IC8vID1cbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgIC8vICE9PSBhbmQgPT09XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcblxuICAgICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2g0LFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuICAgICAgY2gzID0gY2g0LnN1YnN0cigwLCAzKTtcblxuICAgICAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gzLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG4gICAgICBjaDIgPSBjaDMuc3Vic3RyKDAsIDIpO1xuXG4gICAgICBpZiAoKGNoMSA9PT0gY2gyWzFdICYmICgnKy08PiZ8Jy5pbmRleE9mKGNoMSkgPj0gMCkpIHx8IGNoMiA9PT0gJz0+Jykge1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG4gICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihjaDEpID49IDApIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gIH1cblxuICAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnJztcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW1iZXIsIDE2KSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xuICAgICAgdmFyIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgIG9jdGFsOiB0cnVlLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksXG4gICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgbnVtYmVyID0gJyc7XG4gICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgICAgICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0TGluZVN0YXJ0O1xuICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgKytpbmRleDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5TdHJpbmdMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXJ0TGluZVN0YXJ0OiBzdGFydExpbmVTdGFydCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgdmFyIHRtcCA9IHBhdHRlcm4sXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG8gYXZvaWQgdGhyb3dpbmcgb25cbiAgICAgICAgICAvLyByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAgICAgICAvLyBgL3VgIGZsYWcuXG4gICAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggdGhlIEFTQ0lJIHN5bWJvbCBgeGAgbWlnaHQgY2F1c2UgZmFsc2VcbiAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdFxuICAgICAgICAgIC8vIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IGBbeC1iXWAgd2hpY2ggdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoJDEsIDE2KSA8PSAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgJ3gnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cCh0bXApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAgICAgLy8gdXNlcy5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgc3RyID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIGJvZHkgPSBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICAgICAgdmFyIGNoLCBzdHIsIGZsYWdzLCByZXN0b3JlO1xuXG4gICAgICBzdHIgPSAnJztcbiAgICAgIGZsYWdzID0gJyc7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBmbGFncyxcbiAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG5cbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcbiAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHJlZ2V4LmxpdGVyYWwsXG4gICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2V4O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkdmFuY2VTbGFzaCgpIHtcbiAgICAgIHZhciBwcmV2VG9rZW4sXG4gICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cbiAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIXByZXZUb2tlbikge1xuICAgICAgICAgIC8vIE5vdGhpbmcgYmVmb3JlIHRoYXQ6IGl0IGNhbm5vdCBiZSBhIGRpdmlzaW9uLlxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuUGFyZW5Ub2tlbiAtIDFdO1xuICAgICAgICAgICAgICBpZiAoY2hlY2tUb2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGNoZWNrVG9rZW4udmFsdWUgPT09ICdpZicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3doaWxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2l0aCcpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXG4gICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDVdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmIHByZXZUb2tlbi52YWx1ZSAhPT0gJ3RoaXMnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgdmFyIGNoO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcbiAgICAgIGlmIChjaCA9PT0gMHgyOCB8fCBjaCA9PT0gMHgyOSB8fCBjaCA9PT0gMHgzQikge1xuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoY2ggPT09IDB4MkUpIHtcbiAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2xhc2ggKC8pIFUrMDAyRiBjYW4gYWxzbyBzdGFydCBhIHJlZ2V4LlxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgcmV0dXJuIGFkdmFuY2VTbGFzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgIHZhciBsb2MsIHRva2VuLCB2YWx1ZSwgZW50cnk7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRva2VuID0gYWR2YW5jZSgpO1xuICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJhbmdlOiBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB0b2tlbi5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IHRva2VuLnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgdmFyIHRva2VuO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcblxuICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0O1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICB0aGlzLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChzdGFydFRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydFxuICAgICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5saW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICAgIC8vIFNraXAgY29tbWVudC5cbiAgICAgIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLnN0YXJ0TGluZVN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLmxpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLmxpbmVTdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbaW5kZXgsIDBdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikge1xuICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9jLmVuZCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgICAgICAgICBpZiAoZXh0cmEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpID8gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DYWxsRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaElkZW50aWZpZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTGl0ZXJhbDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yYXcgPT0gJy8vJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gJy8oPzopLyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZWdleCA9IHRva2VuLnJlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoUHJvcGVydHk6IGZ1bmN0aW9uIChraW5kLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb3BlcnR5O1xuICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBsaW5lIHRlcm1pbmF0b3IgYmVmb3JlIHRoZSBuZXh0IHRva2VuLlxuXG4gIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0LCBmb3VuZDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICAgICAgdmFyIGVycm9yLFxuICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgLyUoXFxkKS9nLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBhc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IG1zZztcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvclRvbGVyYW50KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvd0Vycm9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgaWYgKGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb29sZWFuTGl0ZXJhbCwgTnVsbExpdGVyYWwsIG9yIFB1bmN0dWF0b3IuXG4gICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG4gIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGV4cGVjdFRvbGVyYW50XG4gICAqIEBkZXNjcmlwdGlvbiBRdWlldGx5IGV4cGVjdCB0aGUgZ2l2ZW4gdG9rZW4gdmFsdWUgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAqIHRvIDxjb2RlPmV4cGVjdCh2YWx1ZSk8L2NvZGU+XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgd2UgYXJlIGV4cGVjdGluZyB0aGUgbG9va2FoZWFkIHRva2VuIHRvIGhhdmVcbiAgICogQHNpbmNlIDIuMFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwZWN0VG9sZXJhbnQodmFsdWUpIHtcbiAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBlY3QodmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG5cbiAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICBmdW5jdGlvbiBtYXRjaEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgICB2YXIgbGluZTtcblxuICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQiB8fCBtYXRjaCgnOycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXgoKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICAgICAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBraW5kID0gKHByb3BlcnR5LmtpbmQgPT09ICdpbml0JykgPyBQcm9wZXJ0eUtpbmQuRGF0YSA6IChwcm9wZXJ0eS5raW5kID09PSAnZ2V0JykgPyBQcm9wZXJ0eUtpbmQuR2V0IDogUHJvcGVydHlLaW5kLlNldDtcblxuICAgICAgICAgIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0RHVwbGljYXRlUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kICE9PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcFtrZXldICYga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JHZXRTZXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcFtrZXldIHw9IGtpbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFwW2tleV0gPSBraW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICArK3N0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cblxuICAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuICB2YXIgbGVnYWxLZXl3b3JkcyA9IHtcImlmXCI6MSwgXCJ0aGlzXCI6MX07XG5cbiAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0eXBlLCB0b2tlbiwgZXhwciwgbm9kZTtcblxuICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKTtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8IGxlZ2FsS2V5d29yZHNbbG9va2FoZWFkLnZhbHVlXSkge1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWwpIHtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGNvbGxlY3RSZWdleCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlZWsoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICB2YXIgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBpZiAoKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSAmJiAhcGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIHRva2VuLCBleHByLCBzdGFydFRva2VuO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xuICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9PSc6XG4gICAgICBjYXNlICchPSc6XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc+JzpcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgIHByZWMgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPDwnOlxuICAgICAgY2FzZSAnPj4nOlxuICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICctJzpcbiAgICAgICAgICBwcmVjID0gOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcvJzpcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZWM7XG4gIH1cblxuICAvLyAxMS41IE11bHRpcGxpY2F0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gIC8vIDExLjggUmVsYXRpb25hbCBPcGVyYXRvcnNcbiAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gIC8vIDExLjExIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gICAgICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgc3RhdGUuYWxsb3dJbik7XG4gICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICBsZXgoKTtcblxuICAgICAgbWFya2VycyA9IFttYXJrZXIsIGxvb2thaGVhZF07XG4gICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgICAgIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkLCBzdGF0ZS5hbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNoaWZ0LlxuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cbiAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgZXhwciA9IHN0YWNrW2ldO1xuICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnMucG9wKCkpLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgICAgICAgIGkgLT0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTMgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIG9sZFBhcmVudGhlc2lzQ291bnQsIHRva2VuLCBleHByLCBzdGFydFRva2VuO1xuXG4gICAgICBvbGRQYXJlbnRoZXNpc0NvdW50ID0gc3RhdGUucGFyZW50aGVzaXNDb3VudDtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gbm8gc2VxdWVuY2UgZXhwcmVzc2lvbnNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTIgU3RhdGVtZW50c1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICBleHByLFxuICAgICAgICAgIG5vZGU7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGJsb2NrIHN0YXRlbWVudFxuICAgICAgfVxuXG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGVtcHR5IHN0YXRlbWVudFxuICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8ga2V5d29yZFxuICAgICAgfVxuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTQgUHJvZ3JhbVxuXG4gIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudCgpIHtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIHNvdXJjZUVsZW1lbnQsIHNvdXJjZUVsZW1lbnRzID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICAgIHZhciBib2R5LCBub2RlO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgcGVlaygpO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICBzdHJpY3QgPSB0cnVlOyAvLyBhc3N1bWUgc3RyaWN0XG5cbiAgICAgIGJvZHkgPSBwYXJzZVNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcbiAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZW50cnkgPSBleHRyYS50b2tlbnNbaV07XG4gICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgIHRva2VuLnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHRvU3RyaW5nLFxuICAgICAgICAgIHRva2VucztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG5cbiAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gT2YgY291cnNlIHdlIGNvbGxlY3QgdG9rZW5zIGhlcmUuXG4gICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgIGV4dHJhLnRva2VuaXplID0gdHJ1ZTtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gLTE7XG4gICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IC0xO1xuXG4gICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHdoaWxlIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAobGV4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChsZXhFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBicmVhayBvbiB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgdG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9ncmFtLCB0b1N0cmluZztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgcGFyZW50aGVzaXNDb3VudDogMCxcbiAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxuICAgICAgfTtcblxuICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemUsXG4gICAgcGFyc2U6IHBhcnNlXG4gIH07XG5cbn0pKCk7IiwidmFyIHRzID0gRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gd3JpdGUobXNnKSB7XG4gIG1zZyA9ICdbVmVnYSBMb2ddICcgKyBtc2c7XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBtc2cgPSAnW1ZlZ2EgRXJyXSAnICsgbXNnO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGRlYnVnKGlucHV0LCBhcmdzKSB7XG4gIGlmICghZGVidWcuZW5hYmxlKSByZXR1cm47XG4gIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHByZXZUaW1lOiAgRGF0ZS5ub3coKSAtIHRzLFxuICAgIHN0YW1wOiBpbnB1dC5zdGFtcFxuICB9O1xuXG4gIGlmIChpbnB1dC5hZGQpIHtcbiAgICBzdGF0ZS5hZGQgPSBpbnB1dC5hZGQubGVuZ3RoO1xuICAgIHN0YXRlLm1vZCA9IGlucHV0Lm1vZC5sZW5ndGg7XG4gICAgc3RhdGUucmVtID0gaW5wdXQucmVtLmxlbmd0aDtcbiAgICBzdGF0ZS5yZWZsb3cgPSAhIWlucHV0LnJlZmxvdztcbiAgfVxuXG4gIGxvZy5hcHBseShjb25zb2xlLCAoYXJncy5wdXNoKEpTT04uc3RyaW5naWZ5KHN0YXRlKSksIGFyZ3MpKTtcbiAgdHMgPSBEYXRlLm5vdygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nOiAgIHdyaXRlLFxuICBlcnJvcjogZXJyb3IsXG4gIGRlYnVnOiAoZGVidWcuZW5hYmxlID0gZmFsc2UsIGRlYnVnKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXRoOiAgICAgICByZXF1aXJlKCcuL3BhdGgnKSxcbiAgcmVuZGVyOiAgICAgcmVxdWlyZSgnLi9yZW5kZXInKSxcbiAgSXRlbTogICAgICAgcmVxdWlyZSgnLi91dGlsL0l0ZW0nKSxcbiAgYm91bmQ6ICAgICAgcmVxdWlyZSgnLi91dGlsL2JvdW5kJyksXG4gIEJvdW5kczogICAgIHJlcXVpcmUoJy4vdXRpbC9Cb3VuZHMnKSxcbiAgY2FudmFzOiAgICAgcmVxdWlyZSgnLi91dGlsL2NhbnZhcycpLFxuICBHcmFkaWVudDogICByZXF1aXJlKCcuL3V0aWwvR3JhZGllbnQnKSxcbiAgdG9KU09OOiAgICAgcmVxdWlyZSgnLi91dGlsL3NjZW5lJykudG9KU09OLFxuICBmcm9tSlNPTjogICByZXF1aXJlKCcuL3V0aWwvc2NlbmUnKS5mcm9tSlNPTlxufTsiLCJ2YXIgc2VnbWVudENhY2hlID0ge30sXG4gICAgYmV6aWVyQ2FjaGUgPSB7fSxcbiAgICBqb2luID0gW10uam9pbjtcblxuLy8gQ29waWVkIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcbmZ1bmN0aW9uIHNlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgdmFyIGtleSA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoc2VnbWVudENhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gc2VnbWVudENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGggPSByb3RhdGVYICogKE1hdGguUEkvMTgwKTtcbiAgdmFyIHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgdmFyIGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICB2YXIgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICB2YXIgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICB2YXIgcGwgPSAocHgqcHgpIC8gKHJ4KnJ4KSArIChweSpweSkgLyAocnkqcnkpO1xuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAvIHJ4O1xuICB2YXIgYTAxID0gc2luX3RoIC8gcng7XG4gIHZhciBhMTAgPSAoLXNpbl90aCkgLyByeTtcbiAgdmFyIGExMSA9IChjb3NfdGgpIC8gcnk7XG4gIHZhciB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIHZhciB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIHZhciB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICB2YXIgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcblxuICB2YXIgZCA9ICh4MS14MCkgKiAoeDEteDApICsgKHkxLXkwKSAqICh5MS15MCk7XG4gIHZhciBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHNmYWN0b3Jfc3EgPSAwO1xuICB2YXIgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09IGxhcmdlKSBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIHZhciB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEteTApO1xuICB2YXIgeWMgPSAwLjUgKiAoeTAgKyB5MSkgKyBzZmFjdG9yICogKHgxLXgwKTtcblxuICB2YXIgdGgwID0gTWF0aC5hdGFuMih5MC15YywgeDAteGMpO1xuICB2YXIgdGgxID0gTWF0aC5hdGFuMih5MS15YywgeDEteGMpO1xuXG4gIHZhciB0aF9hcmMgPSB0aDEtdGgwO1xuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PT0gMSl7XG4gICAgdGhfYXJjICs9IDIgKiBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cblxuICB2YXIgc2VncyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoTWF0aC5QSSAqIDAuNSArIDAuMDAxKSkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzOyArK2kpIHtcbiAgICB2YXIgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgdmFyIHRoMyA9IHRoMCArIChpKzEpICogdGhfYXJjIC8gc2VncztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cblxuICByZXR1cm4gKHNlZ21lbnRDYWNoZVtrZXldID0gcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gYmV6aWVyKHBhcmFtcykge1xuICB2YXIga2V5ID0gam9pbi5jYWxsKHBhcmFtcyk7XG4gIGlmIChiZXppZXJDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGJlemllckNhY2hlW2tleV07XG4gIH1cbiAgXG4gIHZhciBjeCA9IHBhcmFtc1swXSxcbiAgICAgIGN5ID0gcGFyYW1zWzFdLFxuICAgICAgdGgwID0gcGFyYW1zWzJdLFxuICAgICAgdGgxID0gcGFyYW1zWzNdLFxuICAgICAgcnggPSBwYXJhbXNbNF0sXG4gICAgICByeSA9IHBhcmFtc1s1XSxcbiAgICAgIHNpbl90aCA9IHBhcmFtc1s2XSxcbiAgICAgIGNvc190aCA9IHBhcmFtc1s3XTtcblxuICB2YXIgYTAwID0gY29zX3RoICogcng7XG4gIHZhciBhMDEgPSAtc2luX3RoICogcnk7XG4gIHZhciBhMTAgPSBzaW5fdGggKiByeDtcbiAgdmFyIGExMSA9IGNvc190aCAqIHJ5O1xuXG4gIHZhciBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgdmFyIHNpbl90aDAgPSBNYXRoLnNpbih0aDApO1xuICB2YXIgY29zX3RoMSA9IE1hdGguY29zKHRoMSk7XG4gIHZhciBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcblxuICB2YXIgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICB2YXIgc2luX3RoX2gyID0gTWF0aC5zaW4odGhfaGFsZiAqIDAuNSk7XG4gIHZhciB0ID0gKDgvMykgKiBzaW5fdGhfaDIgKiBzaW5fdGhfaDIgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgdmFyIHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIHZhciB5MSA9IGN5ICsgc2luX3RoMCArIHQgKiBjb3NfdGgwO1xuICB2YXIgeDMgPSBjeCArIGNvc190aDE7XG4gIHZhciB5MyA9IGN5ICsgc2luX3RoMTtcbiAgdmFyIHgyID0geDMgKyB0ICogc2luX3RoMTtcbiAgdmFyIHkyID0geTMgLSB0ICogY29zX3RoMTtcblxuICByZXR1cm4gKGJlemllckNhY2hlW2tleV0gPSBbXG4gICAgYTAwICogeDEgKyBhMDEgKiB5MSwgIGExMCAqIHgxICsgYTExICogeTEsXG4gICAgYTAwICogeDIgKyBhMDEgKiB5MiwgIGExMCAqIHgyICsgYTExICogeTIsXG4gICAgYTAwICogeDMgKyBhMDEgKiB5MywgIGExMCAqIHgzICsgYTExICogeTNcbiAgXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZWdtZW50czogc2VnbWVudHMsXG4gIGJlemllcjogYmV6aWVyLFxuICBjYWNoZToge1xuICAgIHNlZ21lbnRzOiBzZWdtZW50Q2FjaGUsXG4gICAgYmV6aWVyOiBiZXppZXJDYWNoZVxuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiAgcmVxdWlyZSgnLi9wYXJzZScpLFxuICByZW5kZXI6IHJlcXVpcmUoJy4vcmVuZGVyJylcbn07XG4iLCIvLyBQYXRoIHBhcnNpbmcgYW5kIHJlbmRlcmluZyBjb2RlIGFkYXB0ZWQgZnJvbSBmYWJyaWMuanMgLS0gVGhhbmtzIVxudmFyIGNtZGxlbiA9IHsgbToyLCBsOjIsIGg6MSwgdjoxLCBjOjYsIHM6NCwgcTo0LCB0OjIsIGE6NyB9LFxuICAgIHJlZ2V4cCA9IFsvKFtNTEhWQ1NRVEFabWxodmNzcXRhel0pL2csIC8jIyMvLCAvKFxcZCkoWy0rXSkvZywgL1xcc3wsfCMjIy9dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGhzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcGF0aCxcbiAgICAgIGN1cnIsXG4gICAgICBjaHVua3MsXG4gICAgICBwYXJzZWQsIHBhcmFtLFxuICAgICAgY21kLCBsZW4sIGksIGosIG4sIG07XG5cbiAgLy8gRmlyc3QsIGJyZWFrIHBhdGggaW50byBjb21tYW5kIHNlcXVlbmNlXG4gIHBhdGggPSBwYXRoc3RyXG4gICAgLnNsaWNlKClcbiAgICAucmVwbGFjZShyZWdleHBbMF0sICcjIyMkMScpXG4gICAgLnNwbGl0KHJlZ2V4cFsxXSlcbiAgICAuc2xpY2UoMSk7XG5cbiAgLy8gTmV4dCwgcGFyc2UgZWFjaCBjb21tYW5kIGluIHR1cm5cbiAgZm9yIChpPTAsIG49cGF0aC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgY3VyciA9IHBhdGhbaV07XG4gICAgY2h1bmtzID0gY3VyclxuICAgICAgLnNsaWNlKDEpXG4gICAgICAudHJpbSgpXG4gICAgICAucmVwbGFjZShyZWdleHBbMl0sJyQxIyMjJDInKVxuICAgICAgLnNwbGl0KHJlZ2V4cFszXSk7XG4gICAgY21kID0gY3Vyci5jaGFyQXQoMCk7XG5cbiAgICBwYXJzZWQgPSBbY21kXTtcbiAgICBmb3IgKGo9MCwgbT1jaHVua3MubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKChwYXJhbSA9ICtjaHVua3Nbal0pID09PSBwYXJhbSkgeyAvLyBub3QgTmFOXG4gICAgICAgIHBhcnNlZC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBjbWRsZW5bY21kLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChwYXJzZWQubGVuZ3RoLTEgPiBsZW4pIHtcbiAgICAgIGZvciAoaj0xLCBtPXBhcnNlZC5sZW5ndGg7IGo8bTsgais9bGVuKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtjbWRdLmNvbmNhdChwYXJzZWQuc2xpY2UoaiwgaitsZW4pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBhcmMgPSByZXF1aXJlKCcuL2FyYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGcsIHBhdGgsIGwsIHQpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFk7XG5cbiAgaWYgKGwgPT0gbnVsbCkgbCA9IDA7XG4gIGlmICh0ID09IG51bGwpIHQgPSAwO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBsLFxuICAgICAgICAgIHkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgIF0pO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICBdKTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxufTtcblxuZnVuY3Rpb24gZHJhd0FyYyhnLCB4LCB5LCBjb29yZHMpIHtcbiAgdmFyIHNlZyA9IGFyYy5zZWdtZW50cyhcbiAgICBjb29yZHNbNV0sIC8vIGVuZCB4XG4gICAgY29vcmRzWzZdLCAvLyBlbmQgeVxuICAgIGNvb3Jkc1swXSwgLy8gcmFkaXVzIHhcbiAgICBjb29yZHNbMV0sIC8vIHJhZGl1cyB5XG4gICAgY29vcmRzWzNdLCAvLyBsYXJnZSBmbGFnXG4gICAgY29vcmRzWzRdLCAvLyBzd2VlcCBmbGFnXG4gICAgY29vcmRzWzJdLCAvLyByb3RhdGlvblxuICAgIHgsIHlcbiAgKTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBiZXogPSBhcmMuYmV6aWVyKHNlZ1tpXSk7XG4gICAgZy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGcsIGJleik7XG4gIH1cbn1cbiIsImZ1bmN0aW9uIEhhbmRsZXIoKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG59XG5cbnZhciBwcm90b3R5cGUgPSBIYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgdGhpcy5fb2JqID0gb2JqIHx8IG51bGw7XG4gIHJldHVybiB0aGlzLnBhZGRpbmcocGFkKTtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQgfHwge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxuLy8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKC8qdHlwZSwgaGFuZGxlciovKSB7fTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbi8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oLyp0eXBlLCBoYW5kbGVyKi8pIHt9O1xuXG4vLyByZXR1cm4gYW4gYXJyYXkgd2l0aCBhbGwgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyc1xucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnMsIGEgPSBbXSwgaztcbiAgZm9yIChrIGluIGgpIHsgYS5wdXNoLmFwcGx5KGEsIGhba10pOyB9XG4gIHJldHVybiBhO1xufTtcblxucHJvdG90eXBlLmV2ZW50TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjsiLCJmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9iZ2NvbG9yID0gbnVsbDtcbn1cblxudmFyIHByb3RvdHlwZSA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB0aGlzLl9lbCA9IGVsO1xuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvblxucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsO1xufTtcblxuLy8gUmV0dXJucyB0aGUgc2NlbmUgZWxlbWVudCAoZS5nLiwgY2FudmFzIG9yIFNWRykgb2YgdGhlIHZpc3VhbGl6YXRpb25cbi8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50XG5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsICYmIHRoaXMuX2VsLmZpcnN0Q2hpbGQ7XG59O1xuXG5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKGJnY29sb3IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9iZ2NvbG9yO1xuICB0aGlzLl9iZ2NvbG9yID0gYmdjb2xvcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nIHx8IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKC8qc2NlbmUsIGl0ZW1zKi8pIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyOyIsInZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIEhhbmRsZXIgPSByZXF1aXJlKCcuLi9IYW5kbGVyJyksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbmZ1bmN0aW9uIENhbnZhc0hhbmRsZXIoKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5fZG93biA9IG51bGw7XG4gIHRoaXMuX3RvdWNoID0gbnVsbDtcbiAgdGhpcy5fZmlyc3QgPSB0cnVlO1xufVxuXG52YXIgYmFzZSA9IEhhbmRsZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChDYW52YXNIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzSGFuZGxlcjtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzID0gRE9NLmZpbmQoZWwsICdjYW52YXMnKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAocHJvdG90eXBlW3R5cGVdKSB7XG4gICAgICAgICAgcHJvdG90eXBlW3R5cGVdLmNhbGwodGhhdCwgZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmZpcmUodHlwZSwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHBhZCwgb2JqKTtcbn07XG5cbnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG59O1xuXG4vLyBzdXBwb3J0ZWQgZXZlbnRzXG5wcm90b3R5cGUuZXZlbnRzID0gW1xuICAna2V5ZG93bicsXG4gICdrZXlwcmVzcycsXG4gICdrZXl1cCcsXG4gICdtb3VzZWRvd24nLFxuICAnbW91c2V1cCcsXG4gICdtb3VzZW1vdmUnLFxuICAnbW91c2VvdXQnLFxuICAnbW91c2VvdmVyJyxcbiAgJ2NsaWNrJyxcbiAgJ2RibGNsaWNrJyxcbiAgJ3doZWVsJyxcbiAgJ21vdXNld2hlZWwnLFxuICAndG91Y2hzdGFydCcsXG4gICd0b3VjaG1vdmUnLFxuICAndG91Y2hlbmQnXG5dO1xuXG4vLyB0byBrZWVwIGZpcmVmb3ggaGFwcHlcbnByb3RvdHlwZS5ET01Nb3VzZVNjcm9sbCA9IGZ1bmN0aW9uKGV2dCkge1xuICB0aGlzLmZpcmUoJ21vdXNld2hlZWwnLCBldnQpO1xufTtcblxucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICB2YXIgYSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgIHAgPSB0aGlzLnBpY2tFdmVudChldnQpO1xuXG4gIGlmIChwID09PSBhKSB7XG4gICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSB0aGUgc2FtZVxuICAgIHRoaXMuZmlyZSgnbW91c2Vtb3ZlJywgZXZ0KTsgLy8gZmlyZSBtb3ZlXG4gIH0gZWxzZSB7XG4gICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSBkaWZmZXJlbnRcbiAgICB0aGlzLmZpcmUoJ21vdXNlb3V0JywgZXZ0KTsgIC8vIGZpcmUgb3V0IGZvciBwcmlvciBhY3RpdmUgaXRlbVxuICAgIHRoaXMuX2FjdGl2ZSA9IHA7ICAgICAgICAgICAgLy8gc2V0IG5ldyBhY3RpdmUgaXRlbVxuICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywgZXZ0KTsgLy8gZmlyZSBvdmVyIGZvciBuZXcgYWN0aXZlIGl0ZW1cbiAgICB0aGlzLmZpcmUoJ21vdXNlbW92ZScsIGV2dCk7IC8vIGZpcmUgbW92ZSBmb3IgbmV3IGFjdGl2ZSBpdGVtXG4gIH1cbn07XG5cbnByb3RvdHlwZS5tb3VzZW91dCA9IGZ1bmN0aW9uKGV2dCkge1xuICB0aGlzLmZpcmUoJ21vdXNlb3V0JywgZXZ0KTtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5fZG93biA9IHRoaXMuX2FjdGl2ZTtcbiAgdGhpcy5maXJlKCdtb3VzZWRvd24nLCBldnQpO1xufTtcblxucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9kb3duID09PSB0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoJ2NsaWNrJywgZXZ0KTtcbiAgICB0aGlzLl9kb3duID0gbnVsbDtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5fdG91Y2ggPSB0aGlzLnBpY2tFdmVudChldnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuXG4gIGlmICh0aGlzLl9maXJzdCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX3RvdWNoO1xuICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLmZpcmUoJ3RvdWNoc3RhcnQnLCBldnQsIHRydWUpO1xufTtcblxucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICB0aGlzLmZpcmUoJ3RvdWNobW92ZScsIGV2dCwgdHJ1ZSk7XG59O1xuXG5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKCd0b3VjaGVuZCcsIGV2dCwgdHJ1ZSk7XG4gIHRoaXMuX3RvdWNoID0gbnVsbDtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0LCB0b3VjaCkge1xuICB2YXIgYSA9IHRvdWNoID8gdGhpcy5fdG91Y2ggOiB0aGlzLl9hY3RpdmUsXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbdHlwZV0sIGksIGxlbjtcbiAgaWYgKGgpIHtcbiAgICBldnQudmVnYVR5cGUgPSB0eXBlO1xuICAgIGZvciAoaT0wLCBsZW49aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGhbaV0uaGFuZGxlci5jYWxsKHRoaXMuX29iaiwgZXZ0LCBhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnM7XG4gIChoW25hbWVdIHx8IChoW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sIGk7XG4gIGlmICghaCkgcmV0dXJuO1xuICBmb3IgKGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5waWNrRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcbiAgdmFyIHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLCB4LCB5O1xuICByZXR1cm4gdGhpcy5waWNrKHRoaXMuX3NjZW5lLFxuICAgIHggPSAoZXZ0LmNsaWVudFggLSByZWN0LmxlZnQpLFxuICAgIHkgPSAoZXZ0LmNsaWVudFkgLSByZWN0LnRvcCksXG4gICAgeCAtIHBhZC5sZWZ0LCB5IC0gcGFkLnRvcCk7XG59O1xuXG4vLyBmaW5kIHRoZSBzY2VuZWdyYXBoIGl0ZW0gYXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbi8vIHgsIHkgLS0gdGhlIGFic29sdXRlIHgsIHkgbW91c2UgY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcyBlbGVtZW50XG4vLyBneCwgZ3kgLS0gdGhlIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgY3VycmVudCBncm91cFxucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbihzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIHZhciBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICBtYXJrID0gbWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICByZXR1cm4gbWFyay5waWNrLmNhbGwodGhpcywgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0hhbmRsZXI7XG4iLCJ2YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi91dGlsL0JvdW5kcycpLFxuICAgIEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9JbWFnZUxvYWRlcicpLFxuICAgIENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY2FudmFzJyksXG4gICAgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9SZW5kZXJlcicpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihsb2FkQ29uZmlnKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcbn1cblxuQ2FudmFzUmVuZGVyZXIuUkVUSU5BID0gdHJ1ZTtcblxudmFyIGJhc2UgPSBSZW5kZXJlci5wcm90b3R5cGU7XG52YXIgcHJvdG90eXBlID0gKENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVuZGVyZXI7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdGhpcy5fY2FudmFzID0gQ2FudmFzLmluc3RhbmNlKHdpZHRoLCBoZWlnaHQpO1xuICBpZiAoZWwpIHtcbiAgICBET00uY2xlYXIoZWwsIDApLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFya3MnKTtcbiAgfVxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgYmFzZS5yZXNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgQ2FudmFzLnJlc2l6ZSh0aGlzLl9jYW52YXMsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsXG4gICAgdGhpcy5fcGFkZGluZywgQ2FudmFzUmVuZGVyZXIuUkVUSU5BKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzID8gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJykgOiBudWxsO1xufTtcblxucHJvdG90eXBlLnBlbmRpbmdJbWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5wZW5kaW5nKCk7XG59O1xuXG5mdW5jdGlvbiBjbGlwVG9Cb3VuZHMoZywgaXRlbXMpIHtcbiAgaWYgKCFpdGVtcykgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGIgPSBuZXcgQm91bmRzKCksIGksIG4sIGl0ZW0sIG1hcmssIGdyb3VwO1xuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIG1hcmsgPSBpdGVtLm1hcms7XG4gICAgZ3JvdXAgPSBtYXJrLmdyb3VwO1xuICAgIGl0ZW0gPSBtYXJrc1ttYXJrLm1hcmt0eXBlXS5uZXN0ZWQgPyBtYXJrIDogaXRlbTtcbiAgICBiLnVuaW9uKHRyYW5zbGF0ZShpdGVtLmJvdW5kcywgZ3JvdXApKTtcbiAgICBpZiAoaXRlbVsnYm91bmRzOnByZXYnXSkge1xuICAgICAgYi51bmlvbih0cmFuc2xhdGUoaXRlbVsnYm91bmRzOnByZXYnXSwgZ3JvdXApKTtcbiAgICB9XG4gIH1cbiAgYi5yb3VuZCgpO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcucmVjdChiLngxLCBiLnkxLCBiLndpZHRoKCksIGIuaGVpZ2h0KCkpO1xuICBnLmNsaXAoKTtcblxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGJvdW5kcywgZ3JvdXApIHtcbiAgaWYgKGdyb3VwID09IG51bGwpIHJldHVybiBib3VuZHM7XG4gIHZhciBiID0gYm91bmRzLmNsb25lKCk7XG4gIGZvciAoOyBncm91cCAhPSBudWxsOyBncm91cCA9IGdyb3VwLm1hcmsuZ3JvdXApIHtcbiAgICBiLnRyYW5zbGF0ZShncm91cC54IHx8IDAsIGdyb3VwLnkgfHwgMCk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIHAgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgdyA9IHRoaXMuX3dpZHRoICsgcC5sZWZ0ICsgcC5yaWdodCxcbiAgICAgIGggPSB0aGlzLl9oZWlnaHQgKyBwLnRvcCArIHAuYm90dG9tLFxuICAgICAgYjtcblxuICAvLyBzZXR1cFxuICB0aGlzLl9zY2VuZSA9IHNjZW5lOyAvLyBjYWNoZSBzY2VuZSBmb3IgYXN5bmMgcmVkcmF3XG4gIGcuc2F2ZSgpO1xuICBiID0gY2xpcFRvQm91bmRzKGcsIGl0ZW1zKTtcbiAgdGhpcy5jbGVhcigtcC5sZWZ0LCAtcC50b3AsIHcsIGgpO1xuXG4gIC8vIHJlbmRlclxuICB0aGlzLmRyYXcoZywgc2NlbmUsIGIpO1xuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDsgLy8gY2xlYXIgc2NlbmUgY2FjaGVcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrID0gbWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICBtYXJrLmRyYXcuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICB2YXIgZyA9IHRoaXMuY29udGV4dCgpO1xuICBnLmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgaWYgKHRoaXMuX2JnY29sb3IgIT0gbnVsbCkge1xuICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fYmdjb2xvcjtcbiAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpOyBcbiAgfVxufTtcblxucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVyaSkge1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkSW1hZ2UodXJpLCBmdW5jdGlvbigpIHtcbiAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gIH0pO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCAxMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1JlbmRlcmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhhbmRsZXI6ICByZXF1aXJlKCcuL0NhbnZhc0hhbmRsZXInKSxcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vQ2FudmFzUmVuZGVyZXInKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhbGZwaSA9IE1hdGguUEkgLyAyO1xuXG5mdW5jdGlvbiBwYXRoKGcsIG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gaGFsZnBpO1xuICBnLmJlZ2luUGF0aCgpO1xuICBpZiAoaXIgPT09IDApIGcubW92ZVRvKHgsIHkpO1xuICBlbHNlIGcuYXJjKHgsIHksIGlyLCBzYSwgZWEsIDApO1xuICBnLmFyYyh4LCB5LCBvciwgZWEsIHNhLCAxKTtcbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHV0aWwuZHJhd0FsbChwYXRoKSxcbiAgcGljazogdXRpbC5waWNrUGF0aChwYXRoKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHBhcnNlID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9wYXJzZScpLFxuICAgIHJlbmRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhdGgvcmVuZGVyJyksXG4gICAgYXJlYVBhdGggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3N2ZycpLnBhdGguYXJlYTtcblxuZnVuY3Rpb24gcGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGFyZWFQYXRoKGl0ZW1zKSkpO1xuICByZW5kZXIoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBpY2soZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG5cbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGcucGl4ZWxyYXRpbyAhPSBudWxsICYmIGcucGl4ZWxyYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgIHkgKj0gZy5waXhlbHJhdGlvO1xuICB9XG4gIHJldHVybiBoaXQoZywgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xufVxuXG52YXIgaGl0ID0gdXRpbC50ZXN0UGF0aChwYXRoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHV0aWwuZHJhd09uZShwYXRoKSxcbiAgcGljazogcGljayxcbiAgbmVzdGVkOiB0cnVlXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBFTVBUWSA9IFtdO1xuXG5mdW5jdGlvbiBkcmF3KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcyB8fCAhc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGdyb3VwcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgZ3JvdXAsIGl0ZW1zLCBheGVzLCBsZWdlbmRzLCBneCwgZ3ksIHcsIGgsIG9wYWMsIGksIG4sIGosIG07XG5cbiAgZm9yIChpPTAsIG49Z3JvdXBzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IEVNUFRZO1xuICAgIGl0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgRU1QVFk7XG4gICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IEVNUFRZO1xuICAgIGd4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGd5ID0gZ3JvdXAueSB8fCAwO1xuICAgIHcgPSBncm91cC53aWR0aCB8fCAwO1xuICAgIGggPSBncm91cC5oZWlnaHQgfHwgMDtcblxuICAgIC8vIGRyYXcgZ3JvdXAgYmFja2dyb3VuZFxuICAgIGlmIChncm91cC5zdHJva2UgfHwgZ3JvdXAuZmlsbCkge1xuICAgICAgb3BhYyA9IGdyb3VwLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBncm91cC5vcGFjaXR5O1xuICAgICAgaWYgKG9wYWMgPiAwKSB7XG4gICAgICAgIGlmIChncm91cC5maWxsICYmIHV0aWwuZmlsbChnLCBncm91cCwgb3BhYykpIHtcbiAgICAgICAgICBnLmZpbGxSZWN0KGd4LCBneSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwLnN0cm9rZSAmJiB1dGlsLnN0cm9rZShnLCBncm91cCwgb3BhYykpIHtcbiAgICAgICAgICBnLnN0cm9rZVJlY3QoZ3gsIGd5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHRcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGlmIChncm91cC5jbGlwKSB7XG4gICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgZy5yZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgZy5jbGlwKCk7XG4gICAgfVxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuXG4gICAgLy8gZHJhdyBncm91cCBjb250ZW50c1xuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0ubGF5ZXIgPT09ICdiYWNrJykge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgaXRlbXNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0ubGF5ZXIgIT09ICdiYWNrJykge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBsZWdlbmRzW2pdLCBib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZ3JhcGhpY3MgY29udGV4dFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBnLnJlc3RvcmUoKTtcbiAgfSAgICBcbn1cblxuZnVuY3Rpb24gcGljayhnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChzY2VuZS5ib3VuZHMgJiYgIXNjZW5lLmJvdW5kcy5jb250YWlucyhneCwgZ3kpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gc2NlbmUuaXRlbXMgfHwgRU1QVFksIHN1YnNjZW5lLFxuICAgICAgZ3JvdXAsIGF4ZXMsIGl0ZW1zLCBsZWdlbmRzLCBoaXRzLCBkeCwgZHksIGksIGosIGI7XG5cbiAgZm9yIChpPWdyb3Vwcy5sZW5ndGg7IC0taT49MDspIHtcbiAgICBncm91cCA9IGdyb3Vwc1tpXTtcblxuICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgLy8gaWYgYSBncm91cCBpcyBjbGlwcGVkLCB0aGF0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBib3VuZHMgY2hlY2suXG4gICAgYiA9IGdyb3VwLmJvdW5kcztcbiAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSBjb250aW51ZTtcblxuICAgIC8vIHBhc3NlZCBib3VuZHMgY2hlY2ssIHNvIHRlc3Qgc3ViLWdyb3Vwc1xuICAgIGF4ZXMgPSBncm91cC5heGlzSXRlbXMgfHwgRU1QVFk7XG4gICAgaXRlbXMgPSBncm91cC5pdGVtcyB8fCBFTVBUWTtcbiAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgRU1QVFk7XG4gICAgZHggPSAoZ3JvdXAueCB8fCAwKTtcbiAgICBkeSA9IChncm91cC55IHx8IDApO1xuXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICBkeCA9IGd4IC0gZHg7XG4gICAgZHkgPSBneSAtIGR5O1xuICAgIGZvciAoaj1sZWdlbmRzLmxlbmd0aDsgLS1qPj0wOykge1xuICAgICAgc3Vic2NlbmUgPSBsZWdlbmRzW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICBoaXRzID0gdGhpcy5waWNrKHN1YnNjZW5lLCB4LCB5LCBkeCwgZHkpO1xuICAgICAgICBpZiAoaGl0cykgeyBnLnJlc3RvcmUoKTsgcmV0dXJuIGhpdHM7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPWF4ZXMubGVuZ3RoOyAtLWo+PTA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGF4ZXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlICYmIHN1YnNjZW5lLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgICAgaGl0cyA9IHRoaXMucGljayhzdWJzY2VuZSwgeCwgeSwgZHgsIGR5KTtcbiAgICAgICAgaWYgKGhpdHMpIHsgZy5yZXN0b3JlKCk7IHJldHVybiBoaXRzOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj1pdGVtcy5sZW5ndGg7IC0taj49MDspIHtcbiAgICAgIHN1YnNjZW5lID0gaXRlbXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIGhpdHMgPSB0aGlzLnBpY2soc3Vic2NlbmUsIHgsIHksIGR4LCBkeSk7XG4gICAgICAgIGlmIChoaXRzKSB7IGcucmVzdG9yZSgpOyByZXR1cm4gaGl0czsgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9YXhlcy5sZW5ndGg7IC0taj49MDspIHtcbiAgICAgIHN1YnNjZW5lID0gYXhlc1tqXTtcbiAgICAgIGlmIChzdWJzY2VuZS5pbnRlcmF0aXZlICE9PSBmYWxzZSAmJiBzdWJzY2VuZS5sYXllciA9PT0gJ2JhY2snKSB7XG4gICAgICAgIGhpdHMgPSB0aGlzLnBpY2soc3Vic2NlbmUsIHgsIHksIGR4LCBkeSk7XG4gICAgICAgIGlmIChoaXRzKSB7IGcucmVzdG9yZSgpOyByZXR1cm4gaGl0czsgfVxuICAgICAgfVxuICAgIH1cbiAgICBnLnJlc3RvcmUoKTtcblxuICAgIGlmIChzY2VuZS5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UgJiYgKGdyb3VwLmZpbGwgfHwgZ3JvdXAuc3Ryb2tlKSAmJlxuICAgICAgICBkeCA+PSAwICYmIGR4IDw9IGdyb3VwLndpZHRoICYmIGR5ID49IDAgJiYgZHkgPD0gZ3JvdXAuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiBwaWNrXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLCBvO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBpZiAoIShvLmltYWdlICYmIG8uaW1hZ2UudXJsID09PSBvLnVybCkpIHtcbiAgICAgIG8uaW1hZ2UgPSByZW5kZXJlci5sb2FkSW1hZ2Uoby51cmwpO1xuICAgICAgby5pbWFnZS51cmwgPSBvLnVybDtcbiAgICB9XG5cbiAgICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgICB5ID0gby55IHx8IDAsXG4gICAgICAgIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgICAgb3BhYztcbiAgICB4ID0geCAtIChvLmFsaWduPT09J2NlbnRlcicgPyB3LzIgOiBvLmFsaWduPT09J3JpZ2h0JyA/IHcgOiAwKTtcbiAgICB5ID0geSAtIChvLmJhc2VsaW5lPT09J21pZGRsZScgPyBoLzIgOiBvLmJhc2VsaW5lPT09J2JvdHRvbScgPyBoIDogMCk7XG5cbiAgICBpZiAoby5pbWFnZS5sb2FkZWQpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSAob3BhYyA9IG8ub3BhY2l0eSkgIT0gbnVsbCA/IG9wYWMgOiAxO1xuICAgICAgZy5kcmF3SW1hZ2Uoby5pbWFnZSwgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiB1dGlsLnBpY2soKVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJjOiAgICByZXF1aXJlKCcuL2FyYycpLFxuICBhcmVhOiAgIHJlcXVpcmUoJy4vYXJlYScpLFxuICBncm91cDogIHJlcXVpcmUoJy4vZ3JvdXAnKSxcbiAgaW1hZ2U6ICByZXF1aXJlKCcuL2ltYWdlJyksXG4gIGxpbmU6ICAgcmVxdWlyZSgnLi9saW5lJyksXG4gIHBhdGg6ICAgcmVxdWlyZSgnLi9wYXRoJyksXG4gIHJlY3Q6ICAgcmVxdWlyZSgnLi9yZWN0JyksXG4gIHJ1bGU6ICAgcmVxdWlyZSgnLi9ydWxlJyksXG4gIHN5bWJvbDogcmVxdWlyZSgnLi9zeW1ib2wnKSxcbiAgdGV4dDogICByZXF1aXJlKCcuL3RleHQnKVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgcGFyc2UgPSByZXF1aXJlKCcuLi8uLi8uLi9wYXRoL3BhcnNlJyksXG4gICAgcmVuZGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9yZW5kZXInKSxcbiAgICBsaW5lUGF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvc3ZnJykucGF0aC5saW5lO1xuICAgIFxuZnVuY3Rpb24gcGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGxpbmVQYXRoKGl0ZW1zKSkpO1xuICByZW5kZXIoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBpY2soZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG5cbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGcucGl4ZWxyYXRpbyAhPSBudWxsICYmIGcucGl4ZWxyYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgIHkgKj0gZy5waXhlbHJhdGlvO1xuICB9XG4gIHJldHVybiBoaXQoZywgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xufVxuXG52YXIgaGl0ID0gdXRpbC50ZXN0UGF0aChwYXRoLCBmYWxzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdPbmUocGF0aCksXG4gIHBpY2s6IHBpY2ssXG4gIG5lc3RlZDogdHJ1ZVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgcGFyc2UgPSByZXF1aXJlKCcuLi8uLi8uLi9wYXRoL3BhcnNlJyksXG4gICAgcmVuZGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9yZW5kZXInKTtcblxuZnVuY3Rpb24gcGF0aChnLCBvKSB7XG4gIGlmIChvLnBhdGggPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2Uoby5wYXRoKSk7XG4gIHJlbmRlcihnLCBwLCBvLngsIG8ueSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdBbGwocGF0aCksXG4gIHBpY2s6IHV0aWwucGlja1BhdGgocGF0aClcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBkcmF3KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcyB8fCAhc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBvcGFjLCB4LCB5LCB3LCBoO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09PSAwKSBjb250aW51ZTtcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgdyA9IG8ud2lkdGggfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICAgIGlmIChvLmZpbGwgJiYgdXRpbC5maWxsKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgICBpZiAoby5zdHJva2UgJiYgdXRpbC5zdHJva2UoZywgbywgb3BhYykpIHtcbiAgICAgIGcuc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHV0aWwucGljaygpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIGRyYXcoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zIHx8ICFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIG9wYWMsIHgxLCB5MSwgeDIsIHkyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09PSAwKSBjb250aW51ZTtcbiAgICAgIFxuICAgIHgxID0gby54IHx8IDA7XG4gICAgeTEgPSBvLnkgfHwgMDtcbiAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MTtcbiAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MTtcblxuICAgIGlmIChvLnN0cm9rZSAmJiB1dGlsLnN0cm9rZShnLCBvLCBvcGFjKSkge1xuICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgIGcubW92ZVRvKHgxLCB5MSk7XG4gICAgICBnLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Ryb2tlKGcsIG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwLFxuICAgICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG5cbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiAxO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgZy5saW5lVG8oeDIsIHkyKTtcbn1cblxuZnVuY3Rpb24gaGl0KGcsIG8sIHgsIHkpIHtcbiAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICBzdHJva2UoZywgbyk7XG4gIHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LCB5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHV0aWwucGljayhoaXQpXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKTtcblxuZnVuY3Rpb24gcGF0aChnLCBvKSB7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54LCB5ID0gby55LCByLCB0LCByeCwgcnk7XG5cbiAgZy5iZWdpblBhdGgoKTtcblxuICBpZiAoby5zaGFwZSA9PSBudWxsIHx8IG8uc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgciA9IE1hdGguc3FydChzaXplIC8gTWF0aC5QSSk7XG4gICAgZy5hcmMoeCwgeSwgciwgMCwgMipNYXRoLlBJLCAwKTtcbiAgICBnLmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBnLm1vdmVUbyh4LXQsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4LXQsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RpYW1vbmQnOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeSk7XG4gICAgICBnLmxpbmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGcucmVjdCh4LXIsIHktciwgdCwgdCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLWRvd24nOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeS1yeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLXVwJzpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkrcnkpO1xuICB9XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdBbGwocGF0aCksXG4gIHBpY2s6IHV0aWwucGlja1BhdGgocGF0aClcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgdGV4dEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvYm91bmQnKS50ZXh0LFxuICAgIHRleHQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3RleHQnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgb3BhYywgeCwgeSwgciwgdCwgc3RyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBzdHIgPSB0ZXh0LnZhbHVlKG8udGV4dCk7XG4gICAgaWYgKCFzdHIpIGNvbnRpbnVlO1xuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgZy5mb250ID0gdGV4dC5mb250KG8pO1xuICAgIGcudGV4dEFsaWduID0gby5hbGlnbiB8fCAnbGVmdCc7XG5cbiAgICB4ID0gKG8ueCB8fCAwKTtcbiAgICB5ID0gKG8ueSB8fCAwKTtcbiAgICBpZiAoKHIgPSBvLnJhZGl1cykpIHtcbiAgICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIHtcbiAgICAgIGcuc2F2ZSgpO1xuICAgICAgZy50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBnLnJvdGF0ZShvLmFuZ2xlICogTWF0aC5QSS8xODApO1xuICAgICAgeCA9IHkgPSAwOyAvLyByZXNldCB4LCB5XG4gICAgfVxuICAgIHggKz0gKG8uZHggfHwgMCk7XG4gICAgeSArPSAoby5keSB8fCAwKSArIHRleHQub2Zmc2V0KG8pO1xuXG4gICAgaWYgKG8uZmlsbCAmJiB1dGlsLmZpbGwoZywgbywgb3BhYykpIHtcbiAgICAgIGcuZmlsbFRleHQoc3RyLCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKG8uc3Ryb2tlICYmIHV0aWwuc3Ryb2tlKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLnN0cm9rZVRleHQoc3RyLCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKG8uYW5nbGUpIGcucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhpdChnLCBvLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKG8uZm9udFNpemUgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIW8uYW5nbGUpIHJldHVybiB0cnVlOyAvLyBib3VuZHMgc3VmZmljaWVudCBpZiBubyByb3RhdGlvblxuXG4gIC8vIHByb2plY3QgcG9pbnQgaW50byBzcGFjZSBvZiB1bnJvdGF0ZWQgYm91bmRzXG4gIHZhciBiID0gdGV4dEJvdW5kcyhvLCB0ZW1wQm91bmRzLCB0cnVlKSxcbiAgICAgIGEgPSAtby5hbmdsZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGEpLFxuICAgICAgb3ggPSBvLngsXG4gICAgICBveSA9IG8ueSxcbiAgICAgIHB4ID0gY29zKmd4IC0gc2luKmd5ICsgKG94IC0gb3gqY29zICsgb3kqc2luKSxcbiAgICAgIHB5ID0gc2luKmd4ICsgY29zKmd5ICsgKG95IC0gb3gqc2luIC0gb3kqY29zKTtcblxuICByZXR1cm4gYi5jb250YWlucyhweCwgcHkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhdyxcbiAgcGljazogdXRpbC5waWNrKGhpdClcbn07XG4iLCJmdW5jdGlvbiBkcmF3UGF0aE9uZShwYXRoLCBnLCBvLCBpdGVtcykge1xuICBpZiAocGF0aChnLCBpdGVtcykpIHJldHVybjtcblxuICB2YXIgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgaWYgKG9wYWM9PT0wKSByZXR1cm47XG5cbiAgaWYgKG8uZmlsbCAmJiBmaWxsKGcsIG8sIG9wYWMpKSB7IGcuZmlsbCgpOyB9XG4gIGlmIChvLnN0cm9rZSAmJiBzdHJva2UoZywgbywgb3BhYykpIHsgZy5zdHJva2UoKTsgfVxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aEFsbChwYXRoLCBnLCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBpLCBsZW4sIGl0ZW07XG4gIGZvciAoaT0wLCBsZW49c2NlbmUuaXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHNjZW5lLml0ZW1zW2ldO1xuICAgIGlmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkge1xuICAgICAgZHJhd1BhdGhPbmUocGF0aCwgZywgaXRlbSwgaXRlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdBbGwocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBkcmF3UGF0aEFsbChwYXRoRnVuYywgZywgc2NlbmUsIGJvdW5kcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdPbmUocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKHNjZW5lLmJvdW5kcykpIHtcbiAgICAgIGRyYXdQYXRoT25lKHBhdGhGdW5jLCBnLCBzY2VuZS5pdGVtc1swXSwgc2NlbmUuaXRlbXMpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHRydWVGdW5jID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuXG5mdW5jdGlvbiBwaWNrKHRlc3QpIHtcbiAgaWYgKCF0ZXN0KSB0ZXN0ID0gdHJ1ZUZ1bmM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgbywgYiwgaTtcblxuICAgIGlmIChnLnBpeGVscmF0aW8gIT0gbnVsbCAmJiBnLnBpeGVscmF0aW8gIT09IDEpIHtcbiAgICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgICAgeSAqPSBnLnBpeGVscmF0aW87XG4gICAgfVxuXG4gICAgZm9yIChpPXNjZW5lLml0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICBvID0gc2NlbmUuaXRlbXNbaV07IGIgPSBvLmJvdW5kcztcbiAgICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgICBpZiAoKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgfHwgIWIpIGNvbnRpbnVlO1xuICAgICAgLy8gaWYgaW4gYm91bmRpbmcgYm94LCBwZXJmb3JtIG1vcmUgY2FyZWZ1bCB0ZXN0XG4gICAgICBpZiAodGVzdChnLCBvLCB4LCB5LCBneCwgZ3kpKSByZXR1cm4gbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRlc3RQYXRoKHBhdGgsIGZpbGxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgbywgeCwgeSkge1xuICAgIHZhciBpdGVtID0gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvLFxuICAgICAgICBmaWxsID0gKGZpbGxlZCA9PSBudWxsKSA/IGl0ZW0uZmlsbCA6IGZpbGxlZCxcbiAgICAgICAgc3Ryb2tlID0gaXRlbS5zdHJva2UgJiYgZy5pc1BvaW50SW5TdHJva2UsIGx3LCBsYztcblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGx3ID0gaXRlbS5zdHJva2VXaWR0aDtcbiAgICAgIGxjID0gaXRlbS5zdHJva2VDYXA7XG4gICAgICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IDE7XG4gICAgICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aChnLCBvKSA/IGZhbHNlIDpcbiAgICAgIChmaWxsICYmIGcuaXNQb2ludEluUGF0aCh4LCB5KSkgfHxcbiAgICAgIChzdHJva2UgJiYgZy5pc1BvaW50SW5TdHJva2UoeCwgeSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwaWNrUGF0aChwYXRoKSB7XG4gIHJldHVybiBwaWNrKHRlc3RQYXRoKHBhdGgpKTtcbn1cblxuZnVuY3Rpb24gZmlsbChnLCBvLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgKj0gKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgby5maWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Ryb2tlKGcsIG8sIG9wYWNpdHkpIHtcbiAgdmFyIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMSwgbGM7XG4gIGlmIChsdyA8PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgb3BhY2l0eSAqPSAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBvLnN0cm9rZSk7XG4gICAgZy5saW5lV2lkdGggPSBsdztcbiAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogJ2J1dHQnO1xuICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sb3IoZywgbywgdmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZS5pZCkgP1xuICAgIGdyYWRpZW50KGcsIHZhbHVlLCBvLmJvdW5kcykgOlxuICAgIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChnLCBwLCBiKSB7XG4gIHZhciB3ID0gYi53aWR0aCgpLFxuICAgICAgaCA9IGIuaGVpZ2h0KCksXG4gICAgICB4MSA9IGIueDEgKyBwLngxICogdyxcbiAgICAgIHkxID0gYi55MSArIHAueTEgKiBoLFxuICAgICAgeDIgPSBiLngxICsgcC54MiAqIHcsXG4gICAgICB5MiA9IGIueTEgKyBwLnkyICogaCxcbiAgICAgIGdyYWQgPSBnLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSxcbiAgICAgIHN0b3AgPSBwLnN0b3BzLFxuICAgICAgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1zdG9wLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncmFkLmFkZENvbG9yU3RvcChzdG9wW2ldLm9mZnNldCwgc3RvcFtpXS5jb2xvcik7XG4gIH1cbiAgcmV0dXJuIGdyYWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3T25lOiAgZHJhd09uZSxcbiAgZHJhd0FsbDogIGRyYXdBbGwsXG4gIHBpY2s6ICAgICBwaWNrLFxuICBwaWNrUGF0aDogcGlja1BhdGgsXG4gIHRlc3RQYXRoOiB0ZXN0UGF0aCxcbiAgc3Ryb2tlOiAgIHN0cm9rZSxcbiAgZmlsbDogICAgIGZpbGwsXG4gIGNvbG9yOiAgICBjb2xvcixcbiAgZ3JhZGllbnQ6IGdyYWRpZW50XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICdjYW52YXMnOiByZXF1aXJlKCcuL2NhbnZhcycpLFxuICAnc3ZnJzogICAgcmVxdWlyZSgnLi9zdmcnKVxufTtcbiIsInZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIEhhbmRsZXIgPSByZXF1aXJlKCcuLi9IYW5kbGVyJyk7XG5cbmZ1bmN0aW9uIFNWR0hhbmRsZXIoKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIGJhc2UgPSBIYW5kbGVyLnByb3RvdHlwZTtcbnZhciBwcm90b3R5cGUgPSAoU1ZHSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR0hhbmRsZXI7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIHRoaXMuX3N2ZyA9IERPTS5maW5kKGVsLCAnc3ZnJyk7XG4gIHJldHVybiBiYXNlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgcGFkLCBvYmopO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3ZnO1xufTtcblxuLy8gd3JhcCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIFNWRyBET01cbnByb3RvdHlwZS5saXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGl0ZW0gPSB0YXJnZXQuX19kYXRhX187XG4gICAgZXZ0LnZlZ2FUeXBlID0gZXZ0LnR5cGU7XG4gICAgaXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtWzBdIDogaXRlbTtcbiAgICBoYW5kbGVyLmNhbGwodGhhdC5fb2JqLCBldnQsIGl0ZW0pO1xuICB9O1xufTtcblxuLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgIHggPSB7XG4gICAgICAgIHR5cGU6ICAgICB0eXBlLFxuICAgICAgICBoYW5kbGVyOiAgaGFuZGxlcixcbiAgICAgICAgbGlzdGVuZXI6IHRoaXMubGlzdGVuZXIoaGFuZGxlcilcbiAgICAgIH07XG5cbiAgKGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSkpLnB1c2goeCk7XG4gIHN2Zy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHgubGlzdGVuZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLCBpO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yIChpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYgKGhbaV0udHlwZSA9PT0gdHlwZSAmJiAhaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhbaV0ubGlzdGVuZXIpO1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdIYW5kbGVyO1xuIiwidmFyIEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9JbWFnZUxvYWRlcicpLFxuICAgIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKSxcbiAgICB0ZXh0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90ZXh0JyksXG4gICAgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIG5zID0gU1ZHLm1ldGFkYXRhLnhtbG5zLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBTVkdSZW5kZXJlcihsb2FkQ29uZmlnKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcbiAgdGhpcy5fZGlydHlJRCA9IDA7XG59XG5cbnZhciBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChTVkdSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR1JlbmRlcmVyO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGlmIChlbCkge1xuICAgIHRoaXMuX3N2ZyA9IERPTS5jaGlsZChlbCwgMCwgJ3N2ZycsIG5zLCAnbWFya3MnKTtcbiAgICBET00uY2xlYXIoZWwsIDEpO1xuICAgIC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcbiAgICB0aGlzLl9yb290ID0gRE9NLmNoaWxkKHRoaXMuX3N2ZywgMCwgJ2cnLCBucyk7XG4gICAgRE9NLmNsZWFyKHRoaXMuX3N2ZywgMSk7XG4gIH1cblxuICAvLyBjcmVhdGUgdGhlIHN2ZyBkZWZpbml0aW9ucyBjYWNoZVxuICB0aGlzLl9kZWZzID0ge1xuICAgIGNsaXBfaWQ6ICAxLFxuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcblxuICAvLyBzZXQgYmFja2dyb3VuZCBjb2xvciBpZiBkZWZpbmVkXG4gIHRoaXMuYmFja2dyb3VuZCh0aGlzLl9iZ2NvbG9yKTtcblxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xufTtcblxucHJvdG90eXBlLmJhY2tncm91bmQgPSBmdW5jdGlvbihiZ2NvbG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHRoaXMuX3N2Zykge1xuICAgIHRoaXMuX3N2Zy5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicsIGJnY29sb3IpO1xuICB9XG4gIHJldHVybiBiYXNlLmJhY2tncm91bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGJhc2UucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gIFxuICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgdmFyIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuX2hlaWdodCxcbiAgICAgICAgcCA9IHRoaXMuX3BhZGRpbmc7XG4gIFxuICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdyArIHAubGVmdCArIHAucmlnaHQpO1xuICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGggKyBwLnRvcCArIHAuYm90dG9tKTtcbiAgICBcbiAgICB0aGlzLl9yb290LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnK3AubGVmdCsnLCcrcC50b3ArJyknKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3N2ZykgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGF0dHIgPSB7XG4gICAgJ2NsYXNzJzogICdtYXJrcycsXG4gICAgJ3dpZHRoJzogIHRoaXMuX3dpZHRoICsgdGhpcy5fcGFkZGluZy5sZWZ0ICsgdGhpcy5fcGFkZGluZy5yaWdodCxcbiAgICAnaGVpZ2h0JzogdGhpcy5faGVpZ2h0ICsgdGhpcy5fcGFkZGluZy50b3AgKyB0aGlzLl9wYWRkaW5nLmJvdHRvbSxcbiAgfTtcbiAgZm9yICh2YXIga2V5IGluIFNWRy5tZXRhZGF0YSkge1xuICAgIGF0dHJba2V5XSA9IFNWRy5tZXRhZGF0YVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIERPTS5vcGVuVGFnKCdzdmcnLCBhdHRyKSArIHRoaXMuX3N2Zy5pbm5lckhUTUwgKyBET00uY2xvc2VUYWcoJ3N2ZycpO1xufTtcblxucHJvdG90eXBlLmltYWdlVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIuaW1hZ2VVUkwodXJsKTtcbn07XG5cblxuLy8gLS0gUmVuZGVyIGVudHJ5IHBvaW50IC0tXG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgaWYgKHRoaXMuX2RpcnR5Q2hlY2soaXRlbXMpKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5QWxsKSB0aGlzLl9yZXNldERlZnMoKTtcbiAgICB0aGlzLmRyYXcodGhpcy5fcm9vdCwgc2NlbmUsIC0xKTtcbiAgICBET00uY2xlYXIodGhpcy5fcm9vdCwgMSk7XG4gIH1cbiAgdGhpcy51cGRhdGVEZWZzKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihlbCwgc2NlbmUsIGluZGV4KSB7XG4gIHRoaXMuZHJhd01hcmsoZWwsIHNjZW5lLCBpbmRleCwgbWFya3Nbc2NlbmUubWFya3R5cGVdKTtcbn07XG5cblxuLy8gLS0gTWFuYWdlIFNWRyBkZWZpbml0aW9ucyAoJ2RlZnMnKSBibG9jayAtLVxuXG5wcm90b3R5cGUudXBkYXRlRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgZGVmcyA9IHRoaXMuX2RlZnMsXG4gICAgICBlbCA9IGRlZnMuZWwsXG4gICAgICBpbmRleCA9IDAsIGlkO1xuXG4gIGZvciAoaWQgaW4gZGVmcy5ncmFkaWVudCkge1xuICAgIGlmICghZWwpIGVsID0gKGRlZnMuZWwgPSBET00uY2hpbGQoc3ZnLCAwLCAnZGVmcycsIG5zKSk7XG4gICAgdXBkYXRlR3JhZGllbnQoZWwsIGRlZnMuZ3JhZGllbnRbaWRdLCBpbmRleCsrKTtcbiAgfVxuXG4gIGZvciAoaWQgaW4gZGVmcy5jbGlwcGluZykge1xuICAgIGlmICghZWwpIGVsID0gKGRlZnMuZWwgPSBET00uY2hpbGQoc3ZnLCAwLCAnZGVmcycsIG5zKSk7XG4gICAgdXBkYXRlQ2xpcHBpbmcoZWwsIGRlZnMuY2xpcHBpbmdbaWRdLCBpbmRleCsrKTtcbiAgfVxuXG4gIC8vIGNsZWFuLXVwXG4gIGlmIChlbCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgc3ZnLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIGRlZnMuZWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBET00uY2xlYXIoZWwsIGluZGV4KTsgICAgICBcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZUdyYWRpZW50KGVsLCBncmFkLCBpbmRleCkge1xuICB2YXIgaSwgbiwgc3RvcDtcblxuICBlbCA9IERPTS5jaGlsZChlbCwgaW5kZXgsICdsaW5lYXJHcmFkaWVudCcsIG5zKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdpZCcsIGdyYWQuaWQpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3gxJywgZ3JhZC54MSk7XG4gIGVsLnNldEF0dHJpYnV0ZSgneDInLCBncmFkLngyKTtcbiAgZWwuc2V0QXR0cmlidXRlKCd5MScsIGdyYWQueTEpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3kyJywgZ3JhZC55Mik7XG4gIFxuICBmb3IgKGk9MCwgbj1ncmFkLnN0b3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBzdG9wID0gRE9NLmNoaWxkKGVsLCBpLCAnc3RvcCcsIG5zKTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgZ3JhZC5zdG9wc1tpXS5vZmZzZXQpO1xuICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgZ3JhZC5zdG9wc1tpXS5jb2xvcik7XG4gIH1cbiAgRE9NLmNsZWFyKGVsLCBpKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xpcHBpbmcoZWwsIGNsaXAsIGluZGV4KSB7XG4gIHZhciByZWN0O1xuXG4gIGVsID0gRE9NLmNoaWxkKGVsLCBpbmRleCwgJ2NsaXBQYXRoJywgbnMpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcC5pZCk7XG4gIHJlY3QgPSBET00uY2hpbGQoZWwsIDAsICdyZWN0JywgbnMpO1xuICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjbGlwLndpZHRoKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNsaXAuaGVpZ2h0KTtcbn1cblxucHJvdG90eXBlLl9yZXNldERlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZnM7XG4gIGRlZi5jbGlwX2lkID0gMTtcbiAgZGVmLmdyYWRpZW50ID0ge307XG4gIGRlZi5jbGlwcGluZyA9IHt9O1xufTtcblxuXG4vLyAtLSBNYW5hZ2UgcmVuZGVyaW5nIG9mIGl0ZW1zIG1hcmtlZCBhcyBkaXJ0eSAtLVxuXG5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIHRoaXMuX2RpcnR5QWxsIHx8IGl0ZW0uZGlydHkgPT09IHRoaXMuX2RpcnR5SUQ7XG59O1xuXG5wcm90b3R5cGUuX2RpcnR5Q2hlY2sgPSBmdW5jdGlvbihpdGVtcykge1xuICB0aGlzLl9kaXJ0eUFsbCA9IHRydWU7XG4gIGlmICghaXRlbXMpIHJldHVybiB0cnVlO1xuXG4gIHZhciBpZCA9ICsrdGhpcy5fZGlydHlJRCxcbiAgICAgIGl0ZW0sIG1hcmssIHR5cGUsIG1kZWYsIGksIG4sIG87XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBtYXJrID0gaXRlbS5tYXJrO1xuICAgIGlmIChtYXJrLm1hcmt0eXBlICE9PSB0eXBlKSB7XG4gICAgICAvLyBtZW1vaXplIG1hcmsgaW5zdGFuY2UgbG9va3VwXG4gICAgICB0eXBlID0gbWFyay5tYXJrdHlwZTtcbiAgICAgIG1kZWYgPSBtYXJrc1t0eXBlXTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09ICdleGl0JykgeyAvLyBFWElUXG4gICAgICBpZiAoaXRlbS5fc3ZnKSB7XG4gICAgICAgIGlmIChtZGVmLm5lc3QgJiYgaXRlbS5tYXJrLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGlmIG5lc3RlZCBtYXJrIHdpdGggcmVtYWluaW5nIHBvaW50cywgdXBkYXRlIGluc3RlYWRcbiAgICAgICAgICB0aGlzLl91cGRhdGUobWRlZiwgaXRlbS5fc3ZnLCBpdGVtLm1hcmsuaXRlbXNbMF0pO1xuICAgICAgICAgIG8gPSBpdGVtLm1hcmsuaXRlbXNbMF07XG4gICAgICAgICAgby5fc3ZnID0gaXRlbS5fc3ZnO1xuICAgICAgICAgIG8uX3VwZGF0ZSA9IGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSByZW1vdmUgZnJvbSBET01cbiAgICAgICAgICBET00ucmVtb3ZlKGl0ZW0uX3N2Zyk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5fc3ZnID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGl0ZW0gPSAobWRlZi5uZXN0ID8gbWFyay5pdGVtc1swXSA6IGl0ZW0pO1xuICAgIGlmIChpdGVtLl91cGRhdGUgPT09IGlkKSB7IC8vIEFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uX3N2ZykgeyAvLyBVUERBVEVcbiAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBpdGVtLl9zdmcsIGl0ZW0pO1xuICAgIH0gZWxzZSB7IC8vIEVOVEVSXG4gICAgICB0aGlzLl9kaXJ0eUFsbCA9IGZhbHNlO1xuICAgICAgZGlydHlQYXJlbnRzKGl0ZW0sIGlkKTtcbiAgICB9XG4gICAgaXRlbS5fdXBkYXRlID0gaWQ7XG4gIH1cbiAgcmV0dXJuICF0aGlzLl9kaXJ0eUFsbDtcbn07XG5cbmZ1bmN0aW9uIGRpcnR5UGFyZW50cyhpdGVtLCBpZCkge1xuICBmb3IgKDsgaXRlbSAmJiBpdGVtLmRpcnR5ICE9PSBpZDsgaXRlbT1pdGVtLm1hcmsuZ3JvdXApIHtcbiAgICBpdGVtLmRpcnR5ID0gaWQ7XG4gICAgaWYgKGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZGlydHkgIT09IGlkKSB7XG4gICAgICBpdGVtLm1hcmsuZGlydHkgPSBpZDtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG59XG5cblxuLy8gLS0gQ29uc3RydWN0ICYgbWFpbnRhaW4gc2NlbmVncmFwaCB0byBTVkcgbWFwcGluZyAtLS1cblxuLy8gRHJhdyBhIG1hcmsgY29udGFpbmVyLlxucHJvdG90eXBlLmRyYXdNYXJrID0gZnVuY3Rpb24oZWwsIHNjZW5lLCBpbmRleCwgbWRlZikge1xuICBpZiAoIXRoaXMuaXNEaXJ0eShzY2VuZSkpIHJldHVybjtcblxuICB2YXIgaXRlbXMgPSBtZGVmLm5lc3QgP1xuICAgICAgICAoc2NlbmUuaXRlbXMgJiYgc2NlbmUuaXRlbXMubGVuZ3RoID8gW3NjZW5lLml0ZW1zWzBdXSA6IFtdKSA6XG4gICAgICAgIHNjZW5lLml0ZW1zIHx8IFtdLFxuICAgICAgZXZlbnRzID0gc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbCxcbiAgICAgIGlzR3JvdXAgPSAobWRlZi50YWcgPT09ICdnJyksXG4gICAgICBjbGFzc05hbWUgPSBET00uY3NzQ2xhc3Moc2NlbmUpLFxuICAgICAgcCwgaSwgbiwgYywgZCwgaW5zZXJ0O1xuXG4gIHAgPSBET00uY2hpbGQoZWwsIGluZGV4KzEsICdnJywgbnMsIGNsYXNzTmFtZSk7XG4gIHAuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG4gIHNjZW5lLl9zdmcgPSBwO1xuICBpZiAoIWlzR3JvdXAgJiYgZXZlbnRzKSB7XG4gICAgcC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCBldmVudHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGlmICh0aGlzLmlzRGlydHkoZCA9IGl0ZW1zW2ldKSkge1xuICAgICAgaW5zZXJ0ID0gISh0aGlzLl9kaXJ0eUFsbCB8fCBkLl9zdmcpO1xuICAgICAgYyA9IGJpbmQocCwgbWRlZiwgZCwgaSwgaW5zZXJ0KTtcbiAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBjLCBkKTtcbiAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIGlmIChpbnNlcnQpIHRoaXMuX2RpcnR5QWxsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdXJzZShjLCBkKTtcbiAgICAgICAgaWYgKGluc2VydCkgdGhpcy5fZGlydHlBbGwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgRE9NLmNsZWFyKHAsIGkpO1xuICByZXR1cm4gcDtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgZ3JvdXAgY29udGVudHMuXG5wcm90b3R5cGUuX3JlY3Vyc2UgPSBmdW5jdGlvbihlbCwgZ3JvdXApIHtcbiAgdmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaWR4ID0gMCwgaiwgbTtcblxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5sYXllciA9PT0gJ2JhY2snKSB7XG4gICAgICB0aGlzLmRyYXdNYXJrKGVsLCBheGVzW2pdLCBpZHgrKywgbWFya3MuZ3JvdXApO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgdGhpcy5kcmF3KGVsLCBpdGVtc1tqXSwgaWR4KyspO1xuICB9XG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgIHRoaXMuZHJhd01hcmsoZWwsIGF4ZXNbal0sIGlkeCsrLCBtYXJrcy5ncm91cCk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHRoaXMuZHJhd01hcmsoZWwsIGxlZ2VuZHNbal0sIGlkeCsrLCBtYXJrcy5ncm91cCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IGV4dHJhbmVvdXMgRE9NIGVsZW1lbnRzXG4gIERPTS5jbGVhcihlbCwgMSArIGlkeCk7XG59O1xuXG4vLyBCaW5kIGEgc2NlbmVncmFwaCBpdGVtIHRvIGFuIFNWRyBET00gZWxlbWVudC5cbi8vIENyZWF0ZSBuZXcgU1ZHIGVsZW1lbnRzIGFzIG5lZWRlZC5cbmZ1bmN0aW9uIGJpbmQoZWwsIG1kZWYsIGl0ZW0sIGluZGV4LCBpbnNlcnQpIHtcbiAgLy8gY3JlYXRlIHN2ZyBlbGVtZW50LCBiaW5kIGl0ZW0gZGF0YSBmb3IgRDMgY29tcGF0aWJpbGl0eVxuICB2YXIgbm9kZSA9IERPTS5jaGlsZChlbCwgaW5kZXgsIG1kZWYudGFnLCBucywgbnVsbCwgaW5zZXJ0KTtcbiAgbm9kZS5fX2RhdGFfXyA9IGl0ZW07XG4gIG5vZGUuX192YWx1ZXNfXyA9IHtmaWxsOiAnZGVmYXVsdCd9O1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHJlY3RcbiAgaWYgKG1kZWYudGFnID09PSAnZycpIHtcbiAgICB2YXIgYmcgPSBET00uY2hpbGQobm9kZSwgMCwgJ3JlY3QnLCBucywgJ2JhY2tncm91bmQnKTtcbiAgICBiZy5fX2RhdGFfXyA9IGl0ZW07XG4gIH1cblxuICAvLyBhZGQgcG9pbnRlciBmcm9tIHNjZW5lZ3JhcGggaXRlbSB0byBzdmcgZWxlbWVudFxuICByZXR1cm4gKGl0ZW0uX3N2ZyA9IG5vZGUpO1xufVxuXG5cbi8vIC0tIFNldCBhdHRyaWJ1dGVzICYgc3R5bGVzIG9uIFNWRyBlbGVtZW50cyAtLS1cblxudmFyIGhyZWYgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICcnKSxcbiAgICBlbGVtZW50ID0gbnVsbCwgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgU1ZHIGVsZW1lbnRcbiAgICB2YWx1ZXMgPSBudWxsOyAgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgdmFsdWVzIGhhc2hcblxuLy8gRXh0cmEgY29uZmlndXJhdGlvbiBmb3IgY2VydGFpbiBtYXJrIHR5cGVzXG52YXIgbWFya19leHRyYXMgPSB7XG4gIGdyb3VwOiBmdW5jdGlvbihtZGVmLCBlbCwgaXRlbSkge1xuICAgIGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzBdO1xuICAgIHZhbHVlcyA9IGVsLl9fdmFsdWVzX187IC8vIHVzZSBwYXJlbnQncyB2YWx1ZXMgaGFzaFxuICAgIG1kZWYuYmFja2dyb3VuZChlbWl0LCBpdGVtLCB0aGlzKTtcblxuICAgIHZhciB2YWx1ZSA9IGl0ZW0ubWFyay5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsO1xuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWVzLmV2ZW50cykge1xuICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCB2YWx1ZSk7XG4gICAgICB2YWx1ZXMuZXZlbnRzID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICB0ZXh0OiBmdW5jdGlvbihtZGVmLCBlbCwgaXRlbSkge1xuICAgIHZhciBzdHIgPSB0ZXh0LnZhbHVlKGl0ZW0udGV4dCk7XG4gICAgaWYgKHN0ciAhPT0gdmFsdWVzLnRleHQpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gc3RyO1xuICAgICAgdmFsdWVzLnRleHQgPSBzdHI7XG4gICAgfVxuICAgIHN0ciA9IHRleHQuZm9udChpdGVtKTtcbiAgICBpZiAoc3RyICE9PSB2YWx1ZXMuZm9udCkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoJ2ZvbnQnLCBzdHIpO1xuICAgICAgdmFsdWVzLmZvbnQgPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKG1kZWYsIGVsLCBpdGVtKSB7XG4gIC8vIHNldCBkb20gZWxlbWVudCBhbmQgdmFsdWVzIGNhY2hlXG4gIC8vIHByb3ZpZGVzIGFjY2VzcyB0byBlbWl0IG1ldGhvZFxuICBlbGVtZW50ID0gZWw7XG4gIHZhbHVlcyA9IGVsLl9fdmFsdWVzX187XG5cbiAgLy8gYXBwbHkgc3ZnIGF0dHJpYnV0ZXNcbiAgbWRlZi5hdHRyKGVtaXQsIGl0ZW0sIHRoaXMpO1xuXG4gIC8vIHNvbWUgbWFya3MgbmVlZCBzcGVjaWFsIHRyZWF0bWVudFxuICB2YXIgZXh0cmEgPSBtYXJrX2V4dHJhc1ttZGVmLnR5cGVdO1xuICBpZiAoZXh0cmEpIGV4dHJhKG1kZWYsIGVsLCBpdGVtKTtcblxuICAvLyBhcHBseSBzdmcgY3NzIHN0eWxlc1xuICAvLyBub3RlOiBlbGVtZW50IG1heSBiZSBtb2RpZmllZCBieSAnZXh0cmEnIG1ldGhvZFxuICB0aGlzLnN0eWxlKGVsZW1lbnQsIGl0ZW0pO1xufTtcblxuZnVuY3Rpb24gZW1pdChuYW1lLCB2YWx1ZSwgbnMpIHtcbiAgLy8gZWFybHkgZXhpdCBpZiB2YWx1ZSBpcyB1bmNoYW5nZWRcbiAgaWYgKHZhbHVlID09PSB2YWx1ZXNbbmFtZV0pIHJldHVybjtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIGlmIHZhbHVlIGlzIHByb3ZpZGVkLCB1cGRhdGUgRE9NIGF0dHJpYnV0ZVxuICAgIGlmIChucykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhucywgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICBpZiAobnMpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBub3RlIGN1cnJlbnQgdmFsdWUgZm9yIGZ1dHVyZSBjb21wYXJpc29uXG4gIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xufVxuXG5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihlbCwgbykge1xuICBpZiAobyA9PSBudWxsKSByZXR1cm47XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZTtcblxuICBmb3IgKGk9MCwgbj1TVkcuc3R5bGVQcm9wZXJ0aWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gU1ZHLnN0eWxlUHJvcGVydGllc1tpXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG4gICAgaWYgKHZhbHVlID09PSB2YWx1ZXNbcHJvcF0pIGNvbnRpbnVlO1xuXG4gICAgbmFtZSA9IFNWRy5zdHlsZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSAnZmlsbCcpIHtcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgJ25vbmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgdGhpcy5fZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAndXJsKCcgKyBocmVmICsgJyMnICsgdmFsdWUuaWQgKyAnKSc7XG4gICAgICB9XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSsnJyk7XG4gICAgfVxuXG4gICAgdmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHUmVuZGVyZXI7XG4iLCJ2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9SZW5kZXJlcicpLFxuICAgIEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9JbWFnZUxvYWRlcicpLFxuICAgIFNWRyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ZnJyksXG4gICAgdGV4dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGV4dCcpLFxuICAgIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgb3BlblRhZyA9IERPTS5vcGVuVGFnLFxuICAgIGNsb3NlVGFnID0gRE9NLmNsb3NlVGFnLFxuICAgIE1BUktTID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBTVkdTdHJpbmdSZW5kZXJlcihsb2FkQ29uZmlnKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5fbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKGxvYWRDb25maWcpO1xuXG4gIHRoaXMuX3RleHQgPSB7XG4gICAgaGVhZDogJycsXG4gICAgcm9vdDogJycsXG4gICAgZm9vdDogJycsXG4gICAgZGVmczogJycsXG4gICAgYm9keTogJydcbiAgfTtcblxuICB0aGlzLl9kZWZzID0ge1xuICAgIGNsaXBfaWQ6ICAxLFxuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn1cblxudmFyIGJhc2UgPSBSZW5kZXJlci5wcm90b3R5cGU7XG52YXIgcHJvdG90eXBlID0gKFNWR1N0cmluZ1JlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHU3RyaW5nUmVuZGVyZXI7XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGJhc2UucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gIHZhciBwID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHQgPSB0aGlzLl90ZXh0O1xuXG4gIHZhciBhdHRyID0ge1xuICAgICdjbGFzcyc6ICAnbWFya3MnLFxuICAgICd3aWR0aCc6ICB0aGlzLl93aWR0aCArIHAubGVmdCArIHAucmlnaHQsXG4gICAgJ2hlaWdodCc6IHRoaXMuX2hlaWdodCArIHAudG9wICsgcC5ib3R0b20sXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBTVkcubWV0YWRhdGEpIHtcbiAgICBhdHRyW2tleV0gPSBTVkcubWV0YWRhdGFba2V5XTtcbiAgfVxuXG4gIHQuaGVhZCA9IG9wZW5UYWcoJ3N2ZycsIGF0dHIpO1xuICB0LnJvb3QgPSBvcGVuVGFnKCdnJywge1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgcC5sZWZ0ICsgJywnICsgcC50b3AgKyAnKSdcbiAgfSk7XG4gIHQuZm9vdCA9IGNsb3NlVGFnKCdnJykgKyBjbG9zZVRhZygnc3ZnJyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy5fdGV4dDtcbiAgcmV0dXJuIHQuaGVhZCArIHQuZGVmcyArIHQucm9vdCArIHQuYm9keSArIHQuZm9vdDtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSkge1xuICB0aGlzLl90ZXh0LmJvZHkgPSB0aGlzLm1hcmsoc2NlbmUpO1xuICB0aGlzLl90ZXh0LmRlZnMgPSB0aGlzLmJ1aWxkRGVmcygpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kZWZzLmNsaXBfaWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5idWlsZERlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFsbCA9IHRoaXMuX2RlZnMsXG4gICAgICBkZWZzID0gJycsXG4gICAgICBpLCBpZCwgZGVmLCBzdG9wcztcblxuICBmb3IgKGlkIGluIGFsbC5ncmFkaWVudCkge1xuICAgIGRlZiA9IGFsbC5ncmFkaWVudFtpZF07XG4gICAgc3RvcHMgPSBkZWYuc3RvcHM7XG5cbiAgICBkZWZzICs9IG9wZW5UYWcoJ2xpbmVhckdyYWRpZW50Jywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDE6IGRlZi54MSxcbiAgICAgIHgyOiBkZWYueDIsXG4gICAgICB5MTogZGVmLnkxLFxuICAgICAgeTI6IGRlZi55MlxuICAgIH0pO1xuICAgIFxuICAgIGZvciAoaT0wOyBpPHN0b3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBkZWZzICs9IG9wZW5UYWcoJ3N0b3AnLCB7XG4gICAgICAgIG9mZnNldDogc3RvcHNbaV0ub2Zmc2V0LFxuICAgICAgICAnc3RvcC1jb2xvcic6IHN0b3BzW2ldLmNvbG9yXG4gICAgICB9KSArIGNsb3NlVGFnKCdzdG9wJyk7XG4gICAgfVxuICAgIFxuICAgIGRlZnMgKz0gY2xvc2VUYWcoJ2xpbmVhckdyYWRpZW50Jyk7XG4gIH1cbiAgXG4gIGZvciAoaWQgaW4gYWxsLmNsaXBwaW5nKSB7XG4gICAgZGVmID0gYWxsLmNsaXBwaW5nW2lkXTtcblxuICAgIGRlZnMgKz0gb3BlblRhZygnY2xpcFBhdGgnLCB7aWQ6IGlkfSk7XG5cbiAgICBkZWZzICs9IG9wZW5UYWcoJ3JlY3QnLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBkZWYud2lkdGgsXG4gICAgICBoZWlnaHQ6IGRlZi5oZWlnaHRcbiAgICB9KSArIGNsb3NlVGFnKCdyZWN0Jyk7XG5cbiAgICBkZWZzICs9IGNsb3NlVGFnKCdjbGlwUGF0aCcpO1xuICB9XG4gIFxuICByZXR1cm4gKGRlZnMubGVuZ3RoID4gMCkgPyBvcGVuVGFnKCdkZWZzJykgKyBkZWZzICsgY2xvc2VUYWcoJ2RlZnMnKSA6ICcnO1xufTtcblxucHJvdG90eXBlLmltYWdlVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIuaW1hZ2VVUkwodXJsKTtcbn07XG5cbnZhciBvYmplY3Q7XG5cbmZ1bmN0aW9uIGVtaXQobmFtZSwgdmFsdWUsIG5zLCBwcmVmaXhlZCkge1xuICBvYmplY3RbcHJlZml4ZWQgfHwgbmFtZV0gPSB2YWx1ZTtcbn1cblxucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbihhdHRyLCBpdGVtKSB7XG4gIG9iamVjdCA9IHt9O1xuICBhdHRyKGVtaXQsIGl0ZW0sIHRoaXMpO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgbWRlZiA9IE1BUktTW3NjZW5lLm1hcmt0eXBlXSxcbiAgICAgIHRhZyAgPSBtZGVmLnRhZyxcbiAgICAgIGF0dHIgPSBtZGVmLmF0dHIsXG4gICAgICBuZXN0ID0gbWRlZi5uZXN0IHx8IGZhbHNlLFxuICAgICAgZGF0YSA9IG5lc3QgP1xuICAgICAgICAgIChzY2VuZS5pdGVtcyAmJiBzY2VuZS5pdGVtcy5sZW5ndGggPyBbc2NlbmUuaXRlbXNbMF1dIDogW10pIDpcbiAgICAgICAgICAoc2NlbmUuaXRlbXMgfHwgW10pLFxuICAgICAgZGVmcyA9IHRoaXMuX2RlZnMsXG4gICAgICBzdHIgPSAnJyxcbiAgICAgIHN0eWxlLCBpLCBpdGVtO1xuXG4gIGlmICh0YWcgIT09ICdnJyAmJiBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICBzdHlsZSA9ICdzdHlsZT1cInBvaW50ZXItZXZlbnRzOiBub25lO1wiJztcbiAgfVxuXG4gIC8vIHJlbmRlciBvcGVuaW5nIGdyb3VwIHRhZ1xuICBzdHIgKz0gb3BlblRhZygnZycsIHtcbiAgICAnY2xhc3MnOiBET00uY3NzQ2xhc3Moc2NlbmUpXG4gIH0sIHN0eWxlKTtcblxuICAvLyByZW5kZXIgY29udGFpbmVkIGVsZW1lbnRzXG4gIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBpdGVtID0gZGF0YVtpXTtcbiAgICBzdHlsZSA9ICh0YWcgIT09ICdnJykgPyBzdHlsZXMoaXRlbSwgc2NlbmUsIHRhZywgZGVmcykgOiBudWxsO1xuICAgIHN0ciArPSBvcGVuVGFnKHRhZywgdGhpcy5hdHRyaWJ1dGVzKGF0dHIsIGl0ZW0pLCBzdHlsZSk7XG4gICAgaWYgKHRhZyA9PT0gJ3RleHQnKSB7XG4gICAgICBzdHIgKz0gZXNjYXBlX3RleHQodGV4dC52YWx1ZShpdGVtLnRleHQpKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2cnKSB7XG4gICAgICBzdHIgKz0gb3BlblRhZygncmVjdCcsXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyhtZGVmLmJhY2tncm91bmQsIGl0ZW0pLFxuICAgICAgICBzdHlsZXMoaXRlbSwgc2NlbmUsICdiZ3JlY3QnLCBkZWZzKSkgKyBjbG9zZVRhZygncmVjdCcpO1xuICAgICAgc3RyICs9IHRoaXMubWFya0dyb3VwKGl0ZW0pO1xuICAgIH1cbiAgICBzdHIgKz0gY2xvc2VUYWcodGFnKTtcbiAgfVxuXG4gIC8vIHJlbmRlciBjbG9zaW5nIGdyb3VwIHRhZ1xuICByZXR1cm4gc3RyICsgY2xvc2VUYWcoJ2cnKTtcbn07XG5cbnByb3RvdHlwZS5tYXJrR3JvdXAgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgc3RyID0gJycsXG4gICAgICBheGVzID0gc2NlbmUuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcyB8fCBbXSxcbiAgICAgIGxlZ2VuZHMgPSBzY2VuZS5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgIGosIG07XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0ubGF5ZXIgPT09ICdiYWNrJykge1xuICAgICAgc3RyICs9IHRoaXMubWFyayhheGVzW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN0ciArPSB0aGlzLm1hcmsoaXRlbXNbal0pO1xuICB9XG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgIHN0ciArPSB0aGlzLm1hcmsoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN0ciArPSB0aGlzLm1hcmsobGVnZW5kc1tqXSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuZnVuY3Rpb24gc3R5bGVzKG8sIG1hcmssIHRhZywgZGVmcykge1xuICBpZiAobyA9PSBudWxsKSByZXR1cm4gJyc7XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZSwgcyA9ICcnO1xuXG4gIGlmICh0YWcgPT09ICdiZ3JlY3QnICYmIG1hcmsuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgcyArPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbiAgfVxuXG4gIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgIHMgKz0gJ2ZvbnQ6ICcgKyB0ZXh0LmZvbnQobykgKyAnOyc7XG4gIH1cblxuICBmb3IgKGk9MCwgbj1TVkcuc3R5bGVQcm9wZXJ0aWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gU1ZHLnN0eWxlUHJvcGVydGllc1tpXTtcbiAgICBuYW1lID0gU1ZHLnN0eWxlc1twcm9wXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09ICdmaWxsJykge1xuICAgICAgICBzICs9IChzLmxlbmd0aCA/ICcgJyA6ICcnKSArICdmaWxsOiBub25lOyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICBkZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICd1cmwoIycgKyB2YWx1ZS5pZCArICcpJztcbiAgICAgIH1cbiAgICAgIHMgKz0gKHMubGVuZ3RoID8gJyAnIDogJycpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICc7JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcyA/ICdzdHlsZT1cIicgKyBzICsgJ1wiJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZV90ZXh0KHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1N0cmluZ1JlbmRlcmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhhbmRsZXI6ICByZXF1aXJlKCcuL1NWR0hhbmRsZXInKSxcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vU1ZHUmVuZGVyZXInKSxcbiAgc3RyaW5nOiB7XG4gICAgUmVuZGVyZXIgOiByZXF1aXJlKCcuL1NWR1N0cmluZ1JlbmRlcmVyJylcbiAgfVxufTsiLCJ2YXIgdGV4dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGV4dCcpLFxuICAgIFNWRyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ZnJyksXG4gICAgdGV4dEFsaWduID0gU1ZHLnRleHRBbGlnbixcbiAgICBwYXRoID0gU1ZHLnBhdGg7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUl0ZW0obykge1xuICByZXR1cm4gdHJhbnNsYXRlKG8ueCB8fCAwLCBvLnkgfHwgMCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFyYzoge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAnYXJjJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ2QnLCBwYXRoLmFyYyhvKSk7XG4gICAgfVxuICB9LFxuICBhcmVhOiB7XG4gICAgdGFnOiAgJ3BhdGgnLFxuICAgIHR5cGU6ICdhcmVhJyxcbiAgICBuZXN0OiB0cnVlLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcztcbiAgICAgIGlmIChpdGVtcy5sZW5ndGgpIGVtaXQoJ2QnLCBwYXRoLmFyZWEoaXRlbXMpKTtcbiAgICB9XG4gIH0sXG4gIGdyb3VwOiB7XG4gICAgdGFnOiAgJ2cnLFxuICAgIHR5cGU6ICdncm91cCcsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbywgcmVuZGVyZXIpIHtcbiAgICAgIHZhciBpZCA9IG51bGwsIGRlZnMsIGM7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGlmIChvLmNsaXApIHtcbiAgICAgICAgZGVmcyA9IHJlbmRlcmVyLl9kZWZzO1xuICAgICAgICBpZCA9IG8uY2xpcF9pZCB8fCAoby5jbGlwX2lkID0gJ2NsaXAnICsgZGVmcy5jbGlwX2lkKyspO1xuICAgICAgICBjID0gZGVmcy5jbGlwcGluZ1tpZF0gfHwgKGRlZnMuY2xpcHBpbmdbaWRdID0ge2lkOiBpZH0pO1xuICAgICAgICBjLndpZHRoID0gby53aWR0aCB8fCAwO1xuICAgICAgICBjLmhlaWdodCA9IG8uaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgICBlbWl0KCdjbGlwLXBhdGgnLCBpZCA/ICgndXJsKCMnICsgaWQgKyAnKScpIDogbnVsbCk7XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCdjbGFzcycsICdiYWNrZ3JvdW5kJyk7XG4gICAgICBlbWl0KCd3aWR0aCcsIG8ud2lkdGggfHwgMCk7XG4gICAgICBlbWl0KCdoZWlnaHQnLCBvLmhlaWdodCB8fCAwKTtcbiAgICB9XG4gIH0sXG4gIGltYWdlOiB7XG4gICAgdGFnOiAgJ2ltYWdlJyxcbiAgICB0eXBlOiAnaW1hZ2UnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8sIHJlbmRlcmVyKSB7XG4gICAgICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgICAgICB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgICAgIGggPSBvLmhlaWdodCB8fCAwLFxuICAgICAgICAgIHVybCA9IHJlbmRlcmVyLmltYWdlVVJMKG8udXJsKTtcblxuICAgICAgeCA9IHggLSAoby5hbGlnbiA9PT0gJ2NlbnRlcicgPyB3LzIgOiBvLmFsaWduID09PSAncmlnaHQnID8gdyA6IDApO1xuICAgICAgeSA9IHkgLSAoby5iYXNlbGluZSA9PT0gJ21pZGRsZScgPyBoLzIgOiBvLmJhc2VsaW5lID09PSAnYm90dG9tJyA/IGggOiAwKTtcblxuICAgICAgZW1pdCgnaHJlZicsIHVybCwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAneGxpbms6aHJlZicpO1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlKHgsIHkpKTtcbiAgICAgIGVtaXQoJ3dpZHRoJywgdyk7XG4gICAgICBlbWl0KCdoZWlnaHQnLCBoKTtcbiAgICB9XG4gIH0sXG4gIGxpbmU6IHtcbiAgICB0YWc6ICAncGF0aCcsXG4gICAgdHlwZTogJ2xpbmUnLFxuICAgIG5lc3Q6IHRydWUsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkgZW1pdCgnZCcsIHBhdGgubGluZShpdGVtcykpO1xuICAgIH1cbiAgfSxcbiAgcGF0aDoge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAncGF0aCcsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBlbWl0KCdkJywgby5wYXRoKTtcbiAgICB9XG4gIH0sXG4gIHJlY3Q6IHtcbiAgICB0YWc6ICAncmVjdCcsXG4gICAgdHlwZTogJ3JlY3QnLFxuICAgIG5lc3Q6IGZhbHNlLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0obykpO1xuICAgICAgZW1pdCgnd2lkdGgnLCBvLndpZHRoIHx8IDApO1xuICAgICAgZW1pdCgnaGVpZ2h0Jywgby5oZWlnaHQgfHwgMCk7XG4gICAgfVxuICB9LFxuICBydWxlOiB7XG4gICAgdGFnOiAgJ2xpbmUnLFxuICAgIHR5cGU6ICdydWxlJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ3gyJywgby54MiAhPSBudWxsID8gby54MiAtIChvLnh8fDApIDogMCk7XG4gICAgICBlbWl0KCd5MicsIG8ueTIgIT0gbnVsbCA/IG8ueTIgLSAoby55fHwwKSA6IDApO1xuICAgIH1cbiAgfSxcbiAgc3ltYm9sOiB7XG4gICAgdGFnOiAgJ3BhdGgnLFxuICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0obykpO1xuICAgICAgZW1pdCgnZCcsIHBhdGguc3ltYm9sKG8pKTtcbiAgICB9XG4gIH0sXG4gIHRleHQ6IHtcbiAgICB0YWc6ICAndGV4dCcsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIG5lc3Q6IGZhbHNlLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIHZhciBkeCA9IChvLmR4IHx8IDApLFxuICAgICAgICAgIGR5ID0gKG8uZHkgfHwgMCkgKyB0ZXh0Lm9mZnNldChvKSxcbiAgICAgICAgICB4ID0gKG8ueCB8fCAwKSxcbiAgICAgICAgICB5ID0gKG8ueSB8fCAwKSxcbiAgICAgICAgICBhID0gby5hbmdsZSB8fCAwLFxuICAgICAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLCB0O1xuXG4gICAgICBpZiAocikge1xuICAgICAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgICAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgICAgIH1cblxuICAgICAgZW1pdCgndGV4dC1hbmNob3InLCB0ZXh0QWxpZ25bby5hbGlnbl0gfHwgJ3N0YXJ0Jyk7XG4gICAgICBcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIHQgPSB0cmFuc2xhdGUoeCwgeSkgKyAnIHJvdGF0ZSgnK2ErJyknO1xuICAgICAgICBpZiAoZHggfHwgZHkpIHQgKz0gJyAnICsgdHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdHJhbnNsYXRlKHgrZHgsIHkrZHkpO1xuICAgICAgfVxuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdCk7XG4gICAgfVxuICB9XG59O1xuIiwiZnVuY3Rpb24gQm91bmRzKGIpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBpZiAoYikgdGhpcy51bmlvbihiKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IEJvdW5kcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJvdW5kcyh0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLngxID0gK051bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueTEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy54MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnkyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xuICB0aGlzLngyID0geDI7XG4gIHRoaXMueTIgPSB5MjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoeCA8IHRoaXMueDEpIHRoaXMueDEgPSB4O1xuICBpZiAoeSA8IHRoaXMueTEpIHRoaXMueTEgPSB5O1xuICBpZiAoeCA+IHRoaXMueDIpIHRoaXMueDIgPSB4O1xuICBpZiAoeSA+IHRoaXMueTIpIHRoaXMueTIgPSB5O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbihkKSB7XG4gIHRoaXMueDEgLT0gZDtcbiAgdGhpcy55MSAtPSBkO1xuICB0aGlzLngyICs9IGQ7XG4gIHRoaXMueTIgKz0gZDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54MSA9IE1hdGguZmxvb3IodGhpcy54MSk7XG4gIHRoaXMueTEgPSBNYXRoLmZsb29yKHRoaXMueTEpO1xuICB0aGlzLngyID0gTWF0aC5jZWlsKHRoaXMueDIpO1xuICB0aGlzLnkyID0gTWF0aC5jZWlsKHRoaXMueTIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgdGhpcy54MSArPSBkeDtcbiAgdGhpcy54MiArPSBkeDtcbiAgdGhpcy55MSArPSBkeTtcbiAgdGhpcy55MiArPSBkeTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oYW5nbGUsIHgsIHkpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgIGN4ID0geCAtIHgqY29zICsgeSpzaW4sXG4gICAgICBjeSA9IHkgLSB4KnNpbiAtIHkqY29zLFxuICAgICAgeDEgPSB0aGlzLngxLCB4MiA9IHRoaXMueDIsXG4gICAgICB5MSA9IHRoaXMueTEsIHkyID0gdGhpcy55MjtcblxuICByZXR1cm4gdGhpcy5jbGVhcigpXG4gICAgLmFkZChjb3MqeDEgLSBzaW4qeTEgKyBjeCwgIHNpbip4MSArIGNvcyp5MSArIGN5KVxuICAgIC5hZGQoY29zKngxIC0gc2luKnkyICsgY3gsICBzaW4qeDEgKyBjb3MqeTIgKyBjeSlcbiAgICAuYWRkKGNvcyp4MiAtIHNpbip5MSArIGN4LCAgc2luKngyICsgY29zKnkxICsgY3kpXG4gICAgLmFkZChjb3MqeDIgLSBzaW4qeTIgKyBjeCwgIHNpbip4MiArIGNvcyp5MiArIGN5KTtcbn07XG5cbnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKGIpIHtcbiAgaWYgKGIueDEgPCB0aGlzLngxKSB0aGlzLngxID0gYi54MTtcbiAgaWYgKGIueTEgPCB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgaWYgKGIueDIgPiB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgaWYgKGIueTIgPiB0aGlzLnkyKSB0aGlzLnkyID0gYi55MjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZW5jbG9zZXMgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiBiICYmIChcbiAgICB0aGlzLngxIDw9IGIueDEgJiZcbiAgICB0aGlzLngyID49IGIueDIgJiZcbiAgICB0aGlzLnkxIDw9IGIueTEgJiZcbiAgICB0aGlzLnkyID49IGIueTJcbiAgKTtcbn07XG5cbnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAhKFxuICAgIHRoaXMueDIgPCBiLngxIHx8XG4gICAgdGhpcy54MSA+IGIueDIgfHxcbiAgICB0aGlzLnkyIDwgYi55MSB8fFxuICAgIHRoaXMueTEgPiBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiAhKFxuICAgIHggPCB0aGlzLngxIHx8XG4gICAgeCA+IHRoaXMueDIgfHxcbiAgICB5IDwgdGhpcy55MSB8fFxuICAgIHkgPiB0aGlzLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvdW5kcztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYikge1xuICBmdW5jdGlvbiBub29wKCkgeyB9XG4gIGZ1bmN0aW9uIGFkZCh4LHkpIHsgYi5hZGQoeCwgeSk7IH1cblxuICByZXR1cm4ge1xuICAgIGJvdW5kczogZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYjtcbiAgICAgIHJldHVybiAoYiA9IF8sIHRoaXMpO1xuICAgIH0sXG4gICAgYmVnaW5QYXRoOiBub29wLFxuICAgIGNsb3NlUGF0aDogbm9vcCxcbiAgICBtb3ZlVG86IGFkZCxcbiAgICBsaW5lVG86IGFkZCxcbiAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgYi5hZGQoeDEsIHkxKTtcbiAgICAgIGIuYWRkKHgyLCB5Mik7XG4gICAgfSxcbiAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICBiLmFkZCh4MSwgeTEpO1xuICAgICAgYi5hZGQoeDIsIHkyKTtcbiAgICAgIGIuYWRkKHgzLCB5Myk7XG4gICAgfVxuICB9O1xufTtcbiIsInZhciBncmFkaWVudF9pZCA9IDA7XG5cbmZ1bmN0aW9uIEdyYWRpZW50KHR5cGUpIHtcbiAgdGhpcy5pZCA9ICdncmFkaWVudF8nICsgKGdyYWRpZW50X2lkKyspO1xuICB0aGlzLnR5cGUgPSB0eXBlIHx8ICdsaW5lYXInO1xuICB0aGlzLnN0b3BzID0gW107XG4gIHRoaXMueDEgPSAwO1xuICB0aGlzLngyID0gMTtcbiAgdGhpcy55MSA9IDA7XG4gIHRoaXMueTIgPSAwO1xufVxuXG52YXIgcHJvdG90eXBlID0gR3JhZGllbnQucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKG9mZnNldCwgY29sb3IpIHtcbiAgdGhpcy5zdG9wcy5wdXNoKHtcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBjb2xvcjogY29sb3JcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFkaWVudDsiLCJ2YXIgbG9hZCA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2ltcG9ydC9sb2FkJyk7XG5cbmZ1bmN0aW9uIEltYWdlTG9hZGVyKGxvYWRDb25maWcpIHtcbiAgdGhpcy5fcGVuZGluZyA9IDA7XG4gIHRoaXMuX2NvbmZpZyA9IGxvYWRDb25maWcgfHwgSW1hZ2VMb2FkZXIuQ29uZmlnOyBcbn1cblxuLy8gT3ZlcnJpZGFibGUgZ2xvYmFsIGRlZmF1bHQgbG9hZCBjb25maWd1cmF0aW9uXG5JbWFnZUxvYWRlci5Db25maWcgPSBudWxsO1xuXG52YXIgcHJvdG90eXBlID0gSW1hZ2VMb2FkZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUucGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGVuZGluZztcbn07XG5cbnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIHAgPSB7dXJsOiB1cml9LCBrO1xuICBmb3IgKGsgaW4gdGhpcy5fY29uZmlnKSB7IHBba10gPSB0aGlzLl9jb25maWdba107IH1cbiAgcmV0dXJuIHA7XG59O1xuXG5wcm90b3R5cGUuaW1hZ2VVUkwgPSBmdW5jdGlvbih1cmkpIHtcbiAgcmV0dXJuIGxvYWQuc2FuaXRpemVVcmwodGhpcy5wYXJhbXModXJpKSk7XG59O1xuXG5mdW5jdGlvbiBicm93c2VyKHVyaSwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IGxvYWQuc2FuaXRpemVVcmwodGhpcy5wYXJhbXModXJpKSk7XG4gIGlmICghdXJsKSB7IC8vIGVycm9yXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh1cmksIG51bGwpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxvYWRlciA9IHRoaXMsXG4gICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gIGxvYWRlci5fcGVuZGluZyArPSAxO1xuXG4gIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGxvYWRlci5fcGVuZGluZyAtPSAxO1xuICAgIGltYWdlLmxvYWRlZCA9IHRydWU7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCBpbWFnZSk7XG4gIH07XG4gIGltYWdlLnNyYyA9IHVybDtcblxuICByZXR1cm4gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIHNlcnZlcih1cmksIGNhbGxiYWNrKSB7XG4gIHZhciBsb2FkZXIgPSB0aGlzLFxuICAgICAgaW1hZ2UgPSBuZXcgKCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydjYW52YXMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2NhbnZhcyddIDogbnVsbCkuSW1hZ2UpKCk7XG5cbiAgbG9hZGVyLl9wZW5kaW5nICs9IDE7XG5cbiAgbG9hZCh0aGlzLnBhcmFtcyh1cmkpLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICBsb2FkZXIuX3BlbmRpbmcgLT0gMTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gZGF0YTtcbiAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgaW1hZ2UpO1xuICB9KTtcblxuICByZXR1cm4gaW1hZ2U7XG59XG5cbnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmksIGNhbGxiYWNrKSB7XG4gIHJldHVybiBsb2FkLnVzZVhIUiA/XG4gICAgYnJvd3Nlci5jYWxsKHRoaXMsIHVyaSwgY2FsbGJhY2spIDpcbiAgICBzZXJ2ZXIuY2FsbCh0aGlzLCB1cmksIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VMb2FkZXI7XG4iLCJmdW5jdGlvbiBJdGVtKG1hcmspIHtcbiAgdGhpcy5tYXJrID0gbWFyaztcbn1cblxudmFyIHByb3RvdHlwZSA9IEl0ZW0ucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaGFzUHJvcGVydHlTZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMubWFyay5kZWYucHJvcGVydGllcztcbiAgcmV0dXJuIHByb3BzICYmIHByb3BzW25hbWVdICE9IG51bGw7XG59O1xuXG5wcm90b3R5cGUuY291c2luID0gZnVuY3Rpb24ob2Zmc2V0LCBpbmRleCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGdyb3VwID0gbWFyay5ncm91cCxcbiAgICAgIGlpZHggPSBpbmRleD09bnVsbCA/IG1hcmsuaXRlbXMuaW5kZXhPZih0aGlzKSA6IGluZGV4LFxuICAgICAgbWlkeCA9IGdyb3VwLml0ZW1zLmluZGV4T2YobWFyaykgKyBvZmZzZXQ7XG4gIHJldHVybiBncm91cC5pdGVtc1ttaWR4XS5pdGVtc1tpaWR4XTtcbn07XG5cbnByb3RvdHlwZS5zaWJsaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiB0aGlzO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgLTE7XG4gIHZhciBtYXJrID0gdGhpcy5tYXJrLFxuICAgICAgaWlkeCA9IG1hcmsuaXRlbXMuaW5kZXhPZih0aGlzKSArIG9mZnNldDtcbiAgcmV0dXJuIG1hcmsuaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gdGhpcyxcbiAgICAgIGxpc3QgPSBpdGVtLm1hcmsuaXRlbXMsXG4gICAgICBpID0gbGlzdC5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaSA+PSAwKSB7XG4gICAgaWYgKGk9PT1saXN0Lmxlbmd0aC0xKSB7XG4gICAgICBsaXN0LnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZW07IiwidmFyIEJvdW5kc0NvbnRleHQgPSByZXF1aXJlKCcuL0JvdW5kc0NvbnRleHQnKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuL0JvdW5kcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4vY2FudmFzJyksXG4gICAgc3ZnID0gcmVxdWlyZSgnLi9zdmcnKSxcbiAgICB0ZXh0ID0gcmVxdWlyZSgnLi90ZXh0JyksXG4gICAgcGF0aHMgPSByZXF1aXJlKCcuLi9wYXRoJyksXG4gICAgcGFyc2UgPSBwYXRocy5wYXJzZSxcbiAgICBkcmF3UGF0aCA9IHBhdGhzLnJlbmRlcixcbiAgICBhcmVhUGF0aCA9IHN2Zy5wYXRoLmFyZWEsXG4gICAgbGluZVBhdGggPSBzdmcucGF0aC5saW5lLFxuICAgIGhhbGZwaSA9IE1hdGguUEkgLyAyLFxuICAgIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKSxcbiAgICBnMkQgPSBudWxsLFxuICAgIGJjID0gQm91bmRzQ29udGV4dCgpO1xuXG5mdW5jdGlvbiBjb250ZXh0KCkge1xuICByZXR1cm4gZzJEIHx8IChnMkQgPSBjYW52YXMuaW5zdGFuY2UoMSwxKS5nZXRDb250ZXh0KCcyZCcpKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlQm91bmRzKG8sIGJvdW5kcykge1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Rva2VPcGFjaXR5ICE9PSAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoICE9IG51bGwgPyBvLnN0cm9rZVdpZHRoIDogMSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gcGF0aEJvdW5kcyhvLCBwYXRoLCBib3VuZHMsIHgsIHkpIHtcbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgZHJhd1BhdGgoYmMuYm91bmRzKGJvdW5kcyksIHBhdGgsIHgsIHkpO1xuICAgIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHBhdGgobywgYm91bmRzKSB7XG4gIHZhciBwID0gby5wYXRoID8gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2Uoby5wYXRoKSkgOiBudWxsO1xuICByZXR1cm4gcGF0aEJvdW5kcyhvLCBwLCBib3VuZHMsIG8ueCwgby55KTtcbn1cblxuZnVuY3Rpb24gYXJlYShtYXJrLCBib3VuZHMpIHtcbiAgaWYgKG1hcmsuaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gYm91bmRzO1xuICB2YXIgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaXRlbSA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IGl0ZW0ucGF0aENhY2hlIHx8IChpdGVtLnBhdGhDYWNoZSA9IHBhcnNlKGFyZWFQYXRoKGl0ZW1zKSkpO1xuICByZXR1cm4gcGF0aEJvdW5kcyhpdGVtLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKG1hcmssIGJvdW5kcykge1xuICBpZiAobWFyay5pdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBib3VuZHM7XG4gIHZhciBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICBpdGVtID0gaXRlbXNbMF0sXG4gICAgICBwID0gaXRlbS5wYXRoQ2FjaGUgfHwgKGl0ZW0ucGF0aENhY2hlID0gcGFyc2UobGluZVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIHJlY3QobywgYm91bmRzKSB7XG4gIHZhciB4LCB5O1xuICByZXR1cm4gc3Ryb2tlQm91bmRzKG8sIGJvdW5kcy5zZXQoXG4gICAgeCA9IG8ueCB8fCAwLFxuICAgIHkgPSBvLnkgfHwgMCxcbiAgICAoeCArIG8ud2lkdGgpIHx8IDAsXG4gICAgKHkgKyBvLmhlaWdodCkgfHwgMFxuICApKTtcbn1cblxuZnVuY3Rpb24gaW1hZ2UobywgYm91bmRzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG4gIHggPSB4IC0gKG8uYWxpZ24gPT09ICdjZW50ZXInID8gdy8yIDogKG8uYWxpZ24gPT09ICdyaWdodCcgPyB3IDogMCkpO1xuICB5ID0geSAtIChvLmJhc2VsaW5lID09PSAnbWlkZGxlJyA/IGgvMiA6IChvLmJhc2VsaW5lID09PSAnYm90dG9tJyA/IGggOiAwKSk7XG4gIHJldHVybiBib3VuZHMuc2V0KHgsIHksIHgrdywgeStoKTtcbn1cblxuZnVuY3Rpb24gcnVsZShvLCBib3VuZHMpIHtcbiAgdmFyIHgxLCB5MTtcbiAgcmV0dXJuIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMuc2V0KFxuICAgIHgxID0gby54IHx8IDAsXG4gICAgeTEgPSBvLnkgfHwgMCxcbiAgICBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gICkpO1xufVxuXG5mdW5jdGlvbiBhcmMobywgYm91bmRzKSB7XG4gIHZhciBjeCA9IG8ueCB8fCAwLFxuICAgICAgY3kgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgeG1pbiA9IEluZmluaXR5LCB4bWF4ID0gLUluZmluaXR5LFxuICAgICAgeW1pbiA9IEluZmluaXR5LCB5bWF4ID0gLUluZmluaXR5LFxuICAgICAgYSwgaSwgbiwgeCwgeSwgaXgsIGl5LCBveCwgb3k7XG5cbiAgdmFyIGFuZ2xlcyA9IFtzYSwgZWFdLFxuICAgICAgcyA9IHNhIC0gKHNhICUgaGFsZnBpKTtcbiAgZm9yIChpPTA7IGk8NCAmJiBzPGVhOyArK2ksIHMrPWhhbGZwaSkge1xuICAgIGFuZ2xlcy5wdXNoKHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49YW5nbGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBhID0gYW5nbGVzW2ldO1xuICAgIHggPSBNYXRoLmNvcyhhKTsgaXggPSBpcip4OyBveCA9IG9yKng7XG4gICAgeSA9IE1hdGguc2luKGEpOyBpeSA9IGlyKnk7IG95ID0gb3IqeTtcbiAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgaXgsIG94KTtcbiAgICB4bWF4ID0gTWF0aC5tYXgoeG1heCwgaXgsIG94KTtcbiAgICB5bWluID0gTWF0aC5taW4oeW1pbiwgaXksIG95KTtcbiAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgaXksIG95KTtcbiAgfVxuXG4gIHJldHVybiBzdHJva2VCb3VuZHMobywgYm91bmRzLnNldChcbiAgICBjeCArIHhtaW4sXG4gICAgY3kgKyB5bWluLFxuICAgIGN4ICsgeG1heCxcbiAgICBjeSArIHltYXhcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvLCBib3VuZHMpIHtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHIsIHQsIHJ4LCByeTtcblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB0ID0gMyAqIE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXQsIHktdCwgeCt0LCB5K3QpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIHRhbjMwKSk7XG4gICAgICByeCA9IHJ5ICogdGFuMzA7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndHJpYW5nbGUtZG93bic6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLXVwJzpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZS9NYXRoLlBJKTtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgfVxuXG4gIHJldHVybiBzdHJva2VCb3VuZHMobywgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gdGV4dE1hcmsobywgYm91bmRzLCBub1JvdGF0ZSkge1xuICB2YXIgZyA9IGNvbnRleHQoKSxcbiAgICAgIGggPSB0ZXh0LnNpemUobyksXG4gICAgICBhID0gby5hbGlnbixcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgeCA9IChvLnggfHwgMCksXG4gICAgICB5ID0gKG8ueSB8fCAwKSxcbiAgICAgIGR4ID0gKG8uZHggfHwgMCksXG4gICAgICBkeSA9IChvLmR5IHx8IDApICsgdGV4dC5vZmZzZXQobykgLSBNYXRoLnJvdW5kKDAuOCpoKSwgLy8gdXNlIDQvNSBvZmZzZXRcbiAgICAgIHcsIHQ7XG5cbiAgaWYgKHIpIHtcbiAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICAvLyBob3Jpem9udGFsIGFsaWdubWVudFxuICBnLmZvbnQgPSB0ZXh0LmZvbnQobyk7XG4gIHcgPSBnLm1lYXN1cmVUZXh0KHRleHQudmFsdWUoby50ZXh0KSkud2lkdGg7XG4gIGlmIChhID09PSAnY2VudGVyJykge1xuICAgIGR4IC09ICh3IC8gMik7XG4gIH0gZWxzZSBpZiAoYSA9PT0gJ3JpZ2h0Jykge1xuICAgIGR4IC09IHc7XG4gIH0gZWxzZSB7XG4gICAgLy8gbGVmdCBieSBkZWZhdWx0LCBkbyBub3RoaW5nXG4gIH1cblxuICBib3VuZHMuc2V0KGR4Kz14LCBkeSs9eSwgZHgrdywgZHkraCk7XG4gIGlmIChvLmFuZ2xlICYmICFub1JvdGF0ZSkge1xuICAgIGJvdW5kcy5yb3RhdGUoby5hbmdsZSpNYXRoLlBJLzE4MCwgeCwgeSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy5leHBhbmQobm9Sb3RhdGUgPyAwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKGcsIGJvdW5kcywgaW5jbHVkZUxlZ2VuZHMpIHtcbiAgdmFyIGF4ZXMgPSBnLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGl0ZW1zID0gZy5pdGVtcyB8fCBbXSxcbiAgICAgIGxlZ2VuZHMgPSBnLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgaiwgbTtcblxuICBpZiAoIWcuY2xpcCkge1xuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGF4ZXNbal0uYm91bmRzKTtcbiAgICB9XG4gICAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGl0ZW1zW2pdLmJvdW5kcyk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlTGVnZW5kcykge1xuICAgICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICAgIGJvdW5kcy51bmlvbihsZWdlbmRzW2pdLmJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChnLmNsaXAgfHwgZy53aWR0aCB8fCBnLmhlaWdodCkge1xuICAgIHN0cm9rZUJvdW5kcyhnLCBib3VuZHNcbiAgICAgIC5hZGQoMCwgMClcbiAgICAgIC5hZGQoZy53aWR0aCB8fCAwLCBnLmhlaWdodCB8fCAwKSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy50cmFuc2xhdGUoZy54IHx8IDAsIGcueSB8fCAwKTtcbn1cblxudmFyIG1ldGhvZHMgPSB7XG4gIGdyb3VwOiAgZ3JvdXAsXG4gIHN5bWJvbDogc3ltYm9sLFxuICBpbWFnZTogIGltYWdlLFxuICByZWN0OiAgIHJlY3QsXG4gIHJ1bGU6ICAgcnVsZSxcbiAgYXJjOiAgICBhcmMsXG4gIHRleHQ6ICAgdGV4dE1hcmssXG4gIHBhdGg6ICAgcGF0aCxcbiAgYXJlYTogICBhcmVhLFxuICBsaW5lOiAgIGxpbmVcbn07XG5tZXRob2RzLmFyZWEubmVzdCA9IHRydWU7XG5tZXRob2RzLmxpbmUubmVzdCA9IHRydWU7XG5cbmZ1bmN0aW9uIGl0ZW1Cb3VuZHMoaXRlbSwgZnVuYywgb3B0KSB7XG4gIHZhciB0eXBlID0gaXRlbS5tYXJrLm1hcmt0eXBlO1xuICBmdW5jID0gZnVuYyB8fCBtZXRob2RzW3R5cGVdO1xuICBpZiAoZnVuYy5uZXN0KSBpdGVtID0gaXRlbS5tYXJrO1xuXG4gIHZhciBjdXJyID0gaXRlbS5ib3VuZHMsXG4gICAgICBwcmV2ID0gaXRlbVsnYm91bmRzOnByZXYnXSB8fCAoaXRlbVsnYm91bmRzOnByZXYnXSA9IG5ldyBCb3VuZHMoKSk7XG5cbiAgaWYgKGN1cnIpIHtcbiAgICBwcmV2LmNsZWFyKCkudW5pb24oY3Vycik7XG4gICAgY3Vyci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0uYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICB9XG4gIGZ1bmMoaXRlbSwgaXRlbS5ib3VuZHMsIG9wdCk7XG4gIGlmICghY3VycikgcHJldi5jbGVhcigpLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgcmV0dXJuIGl0ZW0uYm91bmRzO1xufVxuXG52YXIgRFVNTVlfSVRFTSA9IHttYXJrOiBudWxsfTtcblxuZnVuY3Rpb24gbWFya0JvdW5kcyhtYXJrLCBib3VuZHMsIG9wdCkge1xuICB2YXIgdHlwZSAgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgZnVuYyAgPSBtZXRob2RzW3R5cGVdLFxuICAgICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaGFzaSAgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG4gICAgICBpLCBuLCBvLCBiO1xuXG4gIGlmIChmdW5jLm5lc3QpIHtcbiAgICBvID0gaGFzaSA/IGl0ZW1zWzBdXG4gICAgICA6IChEVU1NWV9JVEVNLm1hcmsgPSBtYXJrLCBEVU1NWV9JVEVNKTsgLy8gbm8gaXRlbXMsIHNvIGZha2UgaXRcbiAgICBiID0gaXRlbUJvdW5kcyhvLCBmdW5jLCBvcHQpO1xuICAgIGJvdW5kcyA9IGJvdW5kcyAmJiBib3VuZHMudW5pb24oYikgfHwgYjtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuICBpZiAoaGFzaSkgeyAgXG4gICAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgYm91bmRzLnVuaW9uKGl0ZW1Cb3VuZHMoaXRlbXNbaV0sIGZ1bmMsIG9wdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKG1hcmsuYm91bmRzID0gYm91bmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hcms6ICBtYXJrQm91bmRzLFxuICBpdGVtOiAgaXRlbUJvdW5kcyxcbiAgdGV4dDogIHRleHRNYXJrLFxuICBncm91cDogZ3JvdXBcbn07XG4iLCJmdW5jdGlvbiBpbnN0YW5jZSh3LCBoKSB7XG4gIHcgPSB3IHx8IDE7XG4gIGggPSBoIHx8IDE7XG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgY2FudmFzLmhlaWdodCA9IGg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIENhbnZhcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydjYW52YXMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2NhbnZhcyddIDogbnVsbCk7XG4gICAgaWYgKCFDYW52YXMucHJvdG90eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjYW52YXMgPSBuZXcgQ2FudmFzKHcsIGgpO1xuICB9XG4gIHJldHVybiBsaW5lRGFzaChjYW52YXMpO1xufVxuXG5mdW5jdGlvbiByZXNpemUoY2FudmFzLCB3LCBoLCBwLCByZXRpbmEpIHtcbiAgdmFyIGcgPSB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgXG4gICAgICBzID0gMTtcblxuICBjYW52YXMud2lkdGggPSB3ICsgcC5sZWZ0ICsgcC5yaWdodDtcbiAgY2FudmFzLmhlaWdodCA9IGggKyBwLnRvcCArIHAuYm90dG9tO1xuXG4gIC8vIGlmIGJyb3dzZXIgY2FudmFzLCBhdHRlbXB0IHRvIG1vZGlmeSBmb3IgcmV0aW5hIGRpc3BsYXlcbiAgaWYgKHJldGluYSAmJiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBjYW52YXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudClcbiAge1xuICAgIGcucGl4ZWxyYXRpbyA9IChzID0gcGl4ZWxSYXRpbyhjYW52YXMpIHx8IDEpO1xuICB9XG5cbiAgZy5zZXRUcmFuc2Zvcm0ocywgMCwgMCwgcywgcypwLmxlZnQsIHMqcC50b3ApO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBwaXhlbFJhdGlvKGNhbnZhcykge1xuICB2YXIgZyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIC8vIGdldCBjYW52YXMgcGl4ZWwgZGF0YVxuICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSAoXG4gICAgICAgIGcud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBnLm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgZy5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgZy5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBnLmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8pIHx8IDEsXG4gICAgICByYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblxuICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyAhPT0gYmFja2luZ1N0b3JlUmF0aW8pIHtcbiAgICAvLyBzZXQgYWN0dWFsIGFuZCB2aXNpYmxlIGNhbnZhcyBzaXplXG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGgsXG4gICAgICAgIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IHcgKiByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gaCAqIHJhdGlvO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiByYXRpbztcbn1cblxuZnVuY3Rpb24gbGluZURhc2goY2FudmFzKSB7XG4gIHZhciBnID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmIChnLnZnTGluZURhc2gpIHJldHVybjsgLy8gYWxyZWFkeSBpbml0aWFsaXplZCFcblxuICB2YXIgTk9PUCA9IGZ1bmN0aW9uKCkge30sXG4gICAgICBOT0RBU0ggPSBbXTtcbiAgXG4gIGlmIChnLnNldExpbmVEYXNoKSB7XG4gICAgZy52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLnNldExpbmVEYXNoKGRhc2ggfHwgTk9EQVNIKTsgfTtcbiAgICBnLnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy5saW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChnLndlYmtpdExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRnLnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMud2Via2l0TGluZURhc2ggPSBkYXNoIHx8IE5PREFTSDsgfTtcbiAgICBnLnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChnLm1vekRhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGcudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5tb3pEYXNoID0gZGFzaDsgfTtcbiAgICBnLnZnTGluZURhc2hPZmZzZXQgPSBOT09QO1xuICB9IGVsc2Uge1xuICAgIGcudmdMaW5lRGFzaCA9IE5PT1A7XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0ID0gTk9PUDtcbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5zdGFuY2U6ICAgaW5zdGFuY2UsXG4gIHJlc2l6ZTogICAgIHJlc2l6ZSxcbiAgbGluZURhc2g6ICAgbGluZURhc2hcbn07XG4iLCIvLyBjcmVhdGUgYSBuZXcgRE9NIGVsZW1lbnRcbmZ1bmN0aW9uIGNyZWF0ZShkb2MsIHRhZywgbnMpIHtcbiAgcmV0dXJuIG5zID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG59XG5cbi8vIHJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4vLyByZWN1cnNpdmVseSByZW1vdmUgcGFyZW50IGVsZW1lbnRzIGlmIGVtcHR5XG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICB2YXIgcCA9IGVsLnBhcmVudE5vZGU7XG4gIGlmIChwKSB7XG4gICAgcC5yZW1vdmVDaGlsZChlbCk7XG4gICAgaWYgKCFwLmNoaWxkTm9kZXMgfHwgIXAuY2hpbGROb2Rlcy5sZW5ndGgpIHJlbW92ZShwKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmluZCBmaXJzdCBjaGlsZCBlbGVtZW50IHdpdGggbWF0Y2hpbmcgdGFnXG4gIGZpbmQ6IGZ1bmN0aW9uKGVsLCB0YWcpIHtcbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciBpPTAsIG49ZWwuY2hpbGROb2Rlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoZWwuY2hpbGROb2Rlc1tpXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZykge1xuICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIHJldHJpZXZlIGNoaWxkIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXhcbiAgLy8gY3JlYXRlICYgaW5zZXJ0IGlmIGRvZXNuJ3QgZXhpc3Qgb3IgaWYgdGFnL2NsYXNzTmFtZSBkbyBub3QgbWF0Y2hcbiAgY2hpbGQ6IGZ1bmN0aW9uKGVsLCBpbmRleCwgdGFnLCBucywgY2xhc3NOYW1lLCBpbnNlcnQpIHtcbiAgICB2YXIgYSwgYjtcbiAgICBhID0gYiA9IGVsLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgIGlmICghYSB8fCBpbnNlcnQgfHxcbiAgICAgICAgYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRhZy50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgIGNsYXNzTmFtZSAmJiBhLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAhPSBjbGFzc05hbWUpIHtcbiAgICAgIGEgPSBjcmVhdGUoZWwub3duZXJEb2N1bWVudCwgdGFnLCBucyk7XG4gICAgICBlbC5pbnNlcnRCZWZvcmUoYSwgYik7XG4gICAgICBpZiAoY2xhc3NOYW1lKSBhLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgLy8gcmVtb3ZlIGFsbCBjaGlsZCBlbGVtZW50cyBhdCBvciBhYm92ZSB0aGUgZ2l2ZW4gaW5kZXhcbiAgY2xlYXI6IGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgIHZhciBjdXJyID0gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGN1cnIgPiBpbmRleCkge1xuICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuY2hpbGROb2Rlc1stLWN1cnJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICByZW1vdmU6IHJlbW92ZSxcbiAgLy8gZ2VuZXJhdGUgY3NzIGNsYXNzIG5hbWUgZm9yIG1hcmtcbiAgY3NzQ2xhc3M6IGZ1bmN0aW9uKG1hcmspIHtcbiAgICByZXR1cm4gJ21hcmstJyArIG1hcmsubWFya3R5cGUgKyAobWFyay5uYW1lID8gJyAnK21hcmsubmFtZSA6ICcnKTtcbiAgfSxcbiAgLy8gZ2VuZXJhdGUgc3RyaW5nIGZvciBhbiBvcGVuaW5nIHhtbCB0YWdcbiAgLy8gdGFnOiB0aGUgbmFtZSBvZiB0aGUgeG1sIHRhZ1xuICAvLyBhdHRyOiBoYXNoIG9mIGF0dHJpYnV0ZSBuYW1lLXZhbHVlIHBhaXJzIHRvIGluY2x1ZGVcbiAgLy8gcmF3OiBhZGRpdGlvbmFsIHJhdyBzdHJpbmcgdG8gaW5jbHVkZSBpbiB0YWcgbWFya3VwXG4gIG9wZW5UYWc6IGZ1bmN0aW9uKHRhZywgYXR0ciwgcmF3KSB7XG4gICAgdmFyIHMgPSAnPCcgKyB0YWcsIGtleSwgdmFsO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBmb3IgKGtleSBpbiBhdHRyKSB7XG4gICAgICAgIHZhbCA9IGF0dHJba2V5XTtcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgcyArPSAnICcgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhdykgcyArPSAnICcgKyByYXc7XG4gICAgcmV0dXJuIHMgKyAnPic7XG4gIH0sXG4gIC8vIGdlbmVyYXRlIHN0cmluZyBmb3IgY2xvc2luZyB4bWwgdGFnXG4gIC8vIHRhZzogdGhlIG5hbWUgb2YgdGhlIHhtbCB0YWdcbiAgY2xvc2VUYWc6IGZ1bmN0aW9uKHRhZykge1xuICAgIHJldHVybiAnPC8nICsgdGFnICsgJz4nO1xuICB9XG59O1xuIiwidmFyIGJvdW5kID0gcmVxdWlyZSgnLi4vdXRpbC9ib3VuZCcpO1xuXG52YXIgc2V0cyA9IFtcbiAgJ2l0ZW1zJyxcbiAgJ2F4aXNJdGVtcycsXG4gICdsZWdlbmRJdGVtcydcbl07XG5cbnZhciBrZXlzID0gW1xuICAnbWFya3R5cGUnLCAnbmFtZScsICdpbnRlcmFjdGl2ZScsICdjbGlwJyxcbiAgJ2l0ZW1zJywgJ2F4aXNJdGVtcycsICdsZWdlbmRJdGVtcycsICdsYXllcicsXG4gICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsaWduJywgJ2Jhc2VsaW5lJywgICAgICAgICAgICAgLy8gbGF5b3V0XG4gICdmaWxsJywgJ2ZpbGxPcGFjaXR5JywgJ29wYWNpdHknLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsbFxuICAnc3Ryb2tlJywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlQ2FwJywgICAgICAgIC8vIHN0cm9rZVxuICAnc3Ryb2tlRGFzaCcsICdzdHJva2VEYXNoT2Zmc2V0JywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cm9rZSBkYXNoXG4gICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgICAgICAgLy8gYXJjXG4gICdpbnRlcnBvbGF0ZScsICd0ZW5zaW9uJywgJ29yaWVudCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlYSwgbGluZVxuICAndXJsJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltYWdlXG4gICdwYXRoJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF0aFxuICAneDInLCAneTInLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGVcbiAgJ3NpemUnLCAnc2hhcGUnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgJ3RleHQnLCAnYW5nbGUnLCAndGhldGEnLCAncmFkaXVzJywgJ2R4JywgJ2R5JywgICAgICAgICAgICAgICAvLyB0ZXh0XG4gICdmb250JywgJ2ZvbnRTaXplJywgJ2ZvbnRXZWlnaHQnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JyAgLy8gZm9udFxuXTtcblxuZnVuY3Rpb24gdG9KU09OKHNjZW5lLCBpbmRlbnQpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNjZW5lLCBrZXlzLCBpbmRlbnQpO1xufVxuXG5mdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gIHZhciBzY2VuZSA9ICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbik7XG4gIHJldHVybiBpbml0aWFsaXplKHNjZW5lKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShzY2VuZSkge1xuICB2YXIgdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgaSwgbiwgcywgbSwgaXRlbXM7XG5cbiAgZm9yIChzPTAsIG09c2V0cy5sZW5ndGg7IHM8bTsgKytzKSB7XG4gICAgaWYgKChpdGVtcyA9IHNjZW5lW3NldHNbc11dKSkge1xuICAgICAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgICBpdGVtc1tpXVt0eXBlID8gJ21hcmsnIDogJ2dyb3VwJ10gPSBzY2VuZTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBpbml0aWFsaXplKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlKSBib3VuZC5tYXJrKHNjZW5lKTtcbiAgcmV0dXJuIHNjZW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdG9KU09OOiAgIHRvSlNPTixcbiAgZnJvbUpTT046IGZyb21KU09OXG59OyIsInZhciBkM19zdmcgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKS5zdmc7XG5cbmZ1bmN0aW9uIHgobykgICAgIHsgcmV0dXJuIG8ueCB8fCAwOyB9XG5mdW5jdGlvbiB5KG8pICAgICB7IHJldHVybiBvLnkgfHwgMDsgfVxuZnVuY3Rpb24geHcobykgICAgeyByZXR1cm4gKG8ueCB8fCAwKSArIChvLndpZHRoIHx8IDApOyB9XG5mdW5jdGlvbiB5aChvKSAgICB7IHJldHVybiAoby55IHx8IDApICsgKG8uaGVpZ2h0IHx8IDApOyB9XG5mdW5jdGlvbiBzaXplKG8pICB7IHJldHVybiBvLnNpemUgPT0gbnVsbCA/IDEwMCA6IG8uc2l6ZTsgfVxuZnVuY3Rpb24gc2hhcGUobykgeyByZXR1cm4gby5zaGFwZSB8fCAnY2lyY2xlJzsgfVxuXG52YXIgYXJlYXYgPSBkM19zdmcuYXJlYSgpLngoeCkueTEoeSkueTAoeWgpLFxuICAgIGFyZWFoID0gZDNfc3ZnLmFyZWEoKS55KHkpLngxKHgpLngwKHh3KSxcbiAgICBsaW5lICA9IGQzX3N2Zy5saW5lKCkueCh4KS55KHkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWV0YWRhdGE6IHtcbiAgICAndmVyc2lvbic6ICcxLjEnLFxuICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgJ3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG4gIH0sXG4gIHBhdGg6IHtcbiAgICBhcmM6IGQzX3N2Zy5hcmMoKSxcbiAgICBzeW1ib2w6IGQzX3N2Zy5zeW1ib2woKS50eXBlKHNoYXBlKS5zaXplKHNpemUpLFxuICAgIGFyZWE6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICB2YXIgbyA9IGl0ZW1zWzBdO1xuICAgICAgcmV0dXJuIChvLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gYXJlYWggOiBhcmVhdilcbiAgICAgICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgJ2xpbmVhcicpXG4gICAgICAgIC50ZW5zaW9uKG8udGVuc2lvbiB8fCAwLjcpXG4gICAgICAgIChpdGVtcyk7XG4gICAgfSxcbiAgICBsaW5lOiBmdW5jdGlvbihpdGVtcykge1xuICAgICAgdmFyIG8gPSBpdGVtc1swXTtcbiAgICAgIHJldHVybiBsaW5lXG4gICAgICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8ICdsaW5lYXInKVxuICAgICAgICAudGVuc2lvbihvLnRlbnNpb24gfHwgMC43KVxuICAgICAgICAoaXRlbXMpO1xuICAgIH1cbiAgfSxcbiAgdGV4dEFsaWduOiB7XG4gICAgJ2xlZnQnOiAgICdzdGFydCcsXG4gICAgJ2NlbnRlcic6ICdtaWRkbGUnLFxuICAgICdyaWdodCc6ICAnZW5kJ1xuICB9LFxuICB0ZXh0QmFzZWxpbmU6IHtcbiAgICAndG9wJzogICAgJ2JlZm9yZS1lZGdlJyxcbiAgICAnYm90dG9tJzogJ2FmdGVyLWVkZ2UnLFxuICAgICdtaWRkbGUnOiAnY2VudHJhbCdcbiAgfSxcbiAgc3R5bGVzOiB7XG4gICAgJ2ZpbGwnOiAgICAgICAgICAgICAnZmlsbCcsXG4gICAgJ2ZpbGxPcGFjaXR5JzogICAgICAnZmlsbC1vcGFjaXR5JyxcbiAgICAnc3Ryb2tlJzogICAgICAgICAgICdzdHJva2UnLFxuICAgICdzdHJva2VXaWR0aCc6ICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgJ3N0cm9rZU9wYWNpdHknOiAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICdzdHJva2VDYXAnOiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJyxcbiAgICAnc3Ryb2tlRGFzaCc6ICAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAnc3Ryb2tlRGFzaE9mZnNldCc6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgJ29wYWNpdHknOiAgICAgICAgICAnb3BhY2l0eSdcbiAgfSxcbiAgc3R5bGVQcm9wZXJ0aWVzOiBbXG4gICAgJ2ZpbGwnLFxuICAgICdmaWxsT3BhY2l0eScsXG4gICAgJ3N0cm9rZScsXG4gICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgJ3N0cm9rZUNhcCcsXG4gICAgJ3N0cm9rZURhc2gnLFxuICAgICdzdHJva2VEYXNoT2Zmc2V0JyxcbiAgICAnb3BhY2l0eSdcbiAgXVxufTtcbiIsImZ1bmN0aW9uIHNpemUoaXRlbSkge1xuICByZXR1cm4gaXRlbS5mb250U2l6ZSAhPSBudWxsID8gaXRlbS5mb250U2l6ZSA6IDExO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2l6ZTogc2l6ZSxcbiAgdmFsdWU6IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcyAhPSBudWxsID8gU3RyaW5nKHMpIDogJyc7XG4gIH0sXG4gIGZvbnQ6IGZ1bmN0aW9uKGl0ZW0sIHF1b3RlKSB7XG4gICAgdmFyIGZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgaWYgKHF1b3RlICYmIGZvbnQpIHtcbiAgICAgIGZvbnQgPSBTdHJpbmcoZm9udCkucmVwbGFjZSgvXFxcIi9nLCAnXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiAnJyArXG4gICAgICAoaXRlbS5mb250U3R5bGUgPyBpdGVtLmZvbnRTdHlsZSArICcgJyA6ICcnKSArXG4gICAgICAoaXRlbS5mb250VmFyaWFudCA/IGl0ZW0uZm9udFZhcmlhbnQgKyAnICcgOiAnJykgK1xuICAgICAgKGl0ZW0uZm9udFdlaWdodCA/IGl0ZW0uZm9udFdlaWdodCArICcgJyA6ICcnKSArXG4gICAgICBzaXplKGl0ZW0pICsgJ3B4ICcgK1xuICAgICAgKGZvbnQgfHwgJ3NhbnMtc2VyaWYnKTtcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gcGVyZm9ybSBvdXIgb3duIGZvbnQgYmFzZWxpbmUgY2FsY3VsYXRpb25cbiAgICAvLyB3aHk/IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBTVkcgMS4xICdhbGlnbm1lbnQtYmFzZWxpbmUnIDooXG4gICAgdmFyIGJhc2VsaW5lID0gaXRlbS5iYXNlbGluZSxcbiAgICAgICAgaCA9IHNpemUoaXRlbSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgICBiYXNlbGluZSA9PT0gJ3RvcCcgICAgPyAgMC45MypoIDpcbiAgICAgIGJhc2VsaW5lID09PSAnbWlkZGxlJyA/ICAwLjMwKmggOlxuICAgICAgYmFzZWxpbmUgPT09ICdib3R0b20nID8gLTAuMjEqaCA6IDBcbiAgICApO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnNpb246ICcyLjIuNicsXG4gIGRhdGFmbG93OiByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gIHBhcnNlOiByZXF1aXJlKCcuL3NyYy9wYXJzZS8nKSxcbiAgc2NlbmU6IHtcbiAgICBCb3VuZGVyOiByZXF1aXJlKCcuL3NyYy9zY2VuZS9Cb3VuZGVyJyksXG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvQnVpbGRlcicpLFxuICAgIEVuY29kZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0VuY29kZXInKSxcbiAgICBHcm91cEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0dyb3VwQnVpbGRlcicpLFxuICB9LFxuICB0cmFuc2Zvcm1zOiByZXF1aXJlKCcuL3NyYy90cmFuc2Zvcm1zJyksXG4gIHNjaGVtYTogcmVxdWlyZSgnLi9zcmMvY29yZS9zY2hlbWEnKSxcbiAgY29uZmlnOiByZXF1aXJlKCcuL3NyYy9jb3JlL2NvbmZpZycpLFxuICB1dGlsOiAgcmVxdWlyZSgnZGF0YWxpYicpLFxuICBkZWJ1ZzogcmVxdWlyZSgndmVnYS1sb2dnaW5nJykuZGVidWdcbn07IiwidmFyIHNnID0gcmVxdWlyZSgndmVnYS1zY2VuZWdyYXBoJykucmVuZGVyLFxuICAgIGNhbnZhcyA9IHNnLmNhbnZhcyxcbiAgICBzdmcgPSBzZy5zdmcuc3RyaW5nLFxuICAgIFZpZXcgPSByZXF1aXJlKCcuL1ZpZXcnKTtcblxuZnVuY3Rpb24gSGVhZGxlc3NWaWV3KHdpZHRoLCBoZWlnaHQsIG1vZGVsKSB7XG4gIFZpZXcuY2FsbChudWxsLCB3aWR0aCwgaGVpZ2h0LCBtb2RlbCk7XG4gIHRoaXMuX3R5cGUgPSAnY2FudmFzJztcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG59XG5cbnZhciBwcm90b3R5cGUgPSAoSGVhZGxlc3NWaWV3LnByb3RvdHlwZSA9IG5ldyBWaWV3KCkpO1xuXG5wcm90b3R5cGUucmVuZGVyZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmKHR5cGUpIHRoaXMuX3R5cGUgPSB0eXBlO1xuICByZXR1cm4gVmlldy5wcm90b3R5cGUucmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl90eXBlID09PSAnY2FudmFzJykgPyB0aGlzLl9yZW5kZXJlci5jYW52YXMoKSA6IG51bGw7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzQXN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgciA9IHRoaXMuX3JlbmRlcmVyLCB2aWV3ID0gdGhpcztcbiAgXG4gIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKHIucGVuZGluZ0ltYWdlcygpID09PSAwKSB7XG4gICAgICB2aWV3LnJlbmRlcigpOyAvLyByZS1yZW5kZXIgd2l0aCBhbGwgaW1hZ2VzXG4gICAgICBjYWxsYmFjayh2aWV3LmNhbnZhcygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh3YWl0LCAxMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgaW1hZ2VzIGxvYWRpbmcsIHBvbGwgdW50aWwgcmVhZHlcbiAgaWYgKHRoaXMuX3R5cGUgIT09ICdjYW52YXMnKSByZXR1cm4gbnVsbDtcbiAgaWYgKHIucGVuZGluZ0ltYWdlcygpID4gMCkgeyB3YWl0KCk7IH0gZWxzZSB7IGNhbGxiYWNrKHRoaXMuY2FudmFzKCkpOyB9XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fdHlwZSA9PT0gJ3N2ZycpID8gdGhpcy5fcmVuZGVyZXIuc3ZnKCkgOiBudWxsO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHsgICAgXG4gIHZhciB3ID0gdGhpcy5fd2lkdGgsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0LFxuICAgICAgYmcgID0gdGhpcy5fYmdjb2xvcixcbiAgICAgIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBjb25maWcgPSB0aGlzLm1vZGVsKCkuY29uZmlnKCk7XG5cbiAgaWYgKHRoaXMuX3ZpZXdwb3J0KSB7XG4gICAgdyA9IHRoaXMuX3ZpZXdwb3J0WzBdIC0gKHBhZCA/IHBhZC5sZWZ0ICsgcGFkLnJpZ2h0IDogMCk7XG4gICAgaCA9IHRoaXMuX3ZpZXdwb3J0WzFdIC0gKHBhZCA/IHBhZC50b3AgKyBwYWQuYm90dG9tIDogMCk7XG4gIH1cblxuICB0aGlzLl9yZW5kZXJlciA9ICh0aGlzLl9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoY29uZmlnLmxvYWQpKVxuICAgIC5pbml0aWFsaXplKG51bGwsIHcsIGgsIHBhZClcbiAgICAuYmFja2dyb3VuZChiZyk7XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGxlc3NWaWV3OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBDaGFuZ2VTZXQgPSBkZi5DaGFuZ2VTZXQsXG4gICAgQmFzZSA9IGRmLkdyYXBoLnByb3RvdHlwZSxcbiAgICBOb2RlICA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIEdyb3VwQnVpbGRlciA9IHJlcXVpcmUoJy4uL3NjZW5lL0dyb3VwQnVpbGRlcicpLFxuICAgIHZpc2l0ID0gcmVxdWlyZSgnLi4vc2NlbmUvdmlzaXQnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5mdW5jdGlvbiBNb2RlbChjZmcpIHtcbiAgdGhpcy5fZGVmcyA9IHt9O1xuICB0aGlzLl9wcmVkaWNhdGVzID0ge307XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcblxuICB0aGlzLl9ub2RlID0gbnVsbDtcbiAgdGhpcy5fYnVpbGRlciA9IG51bGw7IC8vIFRvcC1sZXZlbCBzY2VuZWdyYXBoIGJ1aWxkZXJcblxuICB0aGlzLl9yZXNldCA9IHtheGVzOiBmYWxzZSwgbGVnZW5kczogZmFsc2V9O1xuXG4gIHRoaXMuY29uZmlnKGNmZyk7XG4gIEJhc2UuaW5pdC5jYWxsKHRoaXMpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKE1vZGVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kZWw7XG5cbnByb3RvdHlwZS5kZWZzID0gZnVuY3Rpb24oZGVmcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kZWZzO1xuICB0aGlzLl9kZWZzID0gZGVmcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24oY2ZnKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmNyZWF0ZShjb25maWcpO1xuICBmb3IgKHZhciBuYW1lIGluIGNmZykge1xuICAgIHZhciB4ID0gY2ZnW25hbWVdLCB5ID0gdGhpcy5fY29uZmlnW25hbWVdO1xuICAgIGlmIChkbC5pc09iamVjdCh4KSAmJiBkbC5pc09iamVjdCh5KSkge1xuICAgICAgZGwuZXh0ZW5kKHksIHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25maWdbbmFtZV0gPSB4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgaWYgKHRoaXMuX2RlZnMpIHRoaXMuX2RlZnMud2lkdGggPSB3aWR0aDtcbiAgaWYgKHRoaXMuX2RlZnMgJiYgdGhpcy5fZGVmcy5tYXJrcykgdGhpcy5fZGVmcy5tYXJrcy53aWR0aCA9IHdpZHRoO1xuICBpZiAodGhpcy5fc2NlbmUpIHtcbiAgICB0aGlzLl9zY2VuZS5pdGVtc1swXS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX3NjZW5lLml0ZW1zWzBdLl9kaXJ0eSA9IHRydWU7XG4gIH1cbiAgdGhpcy5fcmVzZXQuYXhlcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICBpZiAodGhpcy5fZGVmcykgdGhpcy5fZGVmcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGlmICh0aGlzLl9kZWZzICYmIHRoaXMuX2RlZnMubWFya3MpIHRoaXMuX2RlZnMubWFya3MuaGVpZ2h0ID0gaGVpZ2h0O1xuICBpZiAodGhpcy5fc2NlbmUpIHtcbiAgICB0aGlzLl9zY2VuZS5pdGVtc1swXS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fc2NlbmUuaXRlbXNbMF0uX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9yZXNldC5heGVzID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZSB8fCAodGhpcy5fbm9kZSA9IG5ldyBOb2RlKHRoaXMpKTtcbn07XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gQmFzZS5kYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgeyAgLy8gbmV3IERhdGFzb3VyY2VcbiAgICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihkYXRhLnBpcGVsaW5lKClbMF0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufTtcblxuZnVuY3Rpb24gcHJlZGljYXRlcyhuYW1lKSB7XG4gIHZhciBtID0gdGhpcywgcHJlZCA9IHt9O1xuICBpZiAoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9wcmVkaWNhdGVzW25hbWVdO1xuICBuYW1lLmZvckVhY2goZnVuY3Rpb24obikgeyBwcmVkW25dID0gbS5fcHJlZGljYXRlc1tuXTsgfSk7XG4gIHJldHVybiBwcmVkO1xufVxuXG5wcm90b3R5cGUucHJlZGljYXRlID0gZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcHJlZGljYXRlcy5jYWxsKHRoaXMsIG5hbWUpO1xuICByZXR1cm4gKHRoaXMuX3ByZWRpY2F0ZXNbbmFtZV0gPSBwcmVkaWNhdGUpO1xufTtcblxucHJvdG90eXBlLnByZWRpY2F0ZXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXM7IH07XG5cbnByb3RvdHlwZS5zY2VuZSA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NjZW5lO1xuICBpZiAodGhpcy5fYnVpbGRlcikgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5fYnVpbGRlci5kaXNjb25uZWN0KCkpO1xuICB0aGlzLl9idWlsZGVyID0gbmV3IEdyb3VwQnVpbGRlcih0aGlzLCB0aGlzLl9kZWZzLm1hcmtzLCB0aGlzLl9zY2VuZT17fSk7XG4gIHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKHRoaXMuX2J1aWxkZXIuY29ubmVjdCgpKTtcbiAgdmFyIHAgPSB0aGlzLl9idWlsZGVyLnBpcGVsaW5lKCk7XG4gIHBbcC5sZW5ndGgtMV0uYWRkTGlzdGVuZXIocmVuZGVyZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc2NlbmUgJiYgdGhpcy5fcmVzZXQuYXhlcykge1xuICAgIHZpc2l0KHRoaXMuX3NjZW5lLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5heGVzKSBpdGVtLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihheGlzKSB7IGF4aXMucmVzZXQoKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzZXQuYXhlcyA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9zY2VuZSAmJiB0aGlzLl9yZXNldC5sZWdlbmRzKSB7XG4gICAgdmlzaXQodGhpcy5fc2NlbmUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLmxlZ2VuZHMpIGl0ZW0ubGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbC5yZXNldCgpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNldC5sZWdlbmRzID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKGwpO1xufTtcblxucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICB0aGlzLm5vZGUoKS5yZW1vdmVMaXN0ZW5lcihsKTsgXG59O1xuXG5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmICghY3MpIGNzID0gQ2hhbmdlU2V0LmNyZWF0ZSgpO1xuICB0aGlzLnByb3BhZ2F0ZShjcywgdGhpcy5ub2RlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBzZyA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLnJlbmRlcixcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBEZXBzID0gZGYuRGVwZW5kZW5jaWVzLFxuICAgIHBhcnNlU3RyZWFtcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3N0cmVhbXMnKSxcbiAgICBFbmNvZGVyID0gcmVxdWlyZSgnLi4vc2NlbmUvRW5jb2RlcicpLFxuICAgIFRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi9zY2VuZS9UcmFuc2l0aW9uJyk7XG5cbmZ1bmN0aW9uIFZpZXcoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy5fZWwgICAgPSBudWxsO1xuICB0aGlzLl9tb2RlbCA9IG51bGw7XG4gIHRoaXMuX3dpZHRoID0gdGhpcy5fX3dpZHRoID0gd2lkdGggfHwgNTAwO1xuICB0aGlzLl9oZWlnaHQgID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodCB8fCAzMDA7XG4gIHRoaXMuX2JnY29sb3IgPSBudWxsO1xuICB0aGlzLl9hdXRvcGFkID0gMTtcbiAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVyICA9IG51bGw7XG4gIHRoaXMuX3N0cmVhbWVyID0gbnVsbDsgLy8gVGFyZ2V0ZWQgdXBkYXRlIGZvciBzdHJlYW1pbmcgY2hhbmdlc1xuICB0aGlzLl9jaGFuZ2VzZXQgPSBudWxsO1xuICB0aGlzLl9yZXBhaW50ID0gdHJ1ZTsgLy8gRnVsbCByZS1yZW5kZXIgb24gZXZlcnkgcmUtaW5pdFxuICB0aGlzLl9yZW5kZXJlcnMgPSBzZztcbiAgdGhpcy5faW8gID0gbnVsbDtcbiAgdGhpcy5fYXBpID0ge307IC8vIFN0YXNoIHN0cmVhbWluZyBkYXRhIEFQSSBzYW5kYm94ZXMuXG59XG5cbnZhciBwcm90b3R5cGUgPSBWaWV3LnByb3RvdHlwZTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIGlmICh0aGlzLl9tb2RlbCAhPT0gbW9kZWwpIHtcbiAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuX3N0cmVhbWVyID0gbmV3IGRmLk5vZGUobW9kZWwpO1xuICAgIHRoaXMuX3N0cmVhbWVyLl9yYW5rID0gLTE7ICAvLyBIQUNLOiBUbyByZWR1Y2UgcmUtcmFua2luZyBjaHVybi5cbiAgICB0aGlzLl9jaGFuZ2VzZXQgPSBkZi5DaGFuZ2VTZXQuY3JlYXRlKCk7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIubW9kZWwobW9kZWwpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU2FuZGJveGVkIHN0cmVhbWluZyBkYXRhIEFQSVxuZnVuY3Rpb24gc3RyZWFtaW5nKHNyYykge1xuICB2YXIgdmlldyA9IHRoaXMsXG4gICAgICBkcyA9IHRoaXMuX21vZGVsLmRhdGEoc3JjKSxcbiAgICAgIG5hbWUgPSBkcy5uYW1lKCksXG4gICAgICBsaXN0ZW5lciA9IGRzLnBpcGVsaW5lKClbMF0sXG4gICAgICBzdHJlYW1lciA9IHRoaXMuX3N0cmVhbWVyLFxuICAgICAgYXBpID0ge307XG5cbiAgLy8gSWYgd2UgaGF2ZSBpdCBzdGFzaGVkLCBkb24ndCBjcmVhdGUgYSBuZXcgY2xvc3VyZS4gXG4gIGlmICh0aGlzLl9hcGlbc3JjXSkgcmV0dXJuIHRoaXMuX2FwaVtzcmNdO1xuXG4gIGFwaS5pbnNlcnQgPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgZHMuaW5zZXJ0KGRsLmR1cGxpY2F0ZSh2YWxzKSk7ICAvLyBEb24ndCBwb2xsdXRlIHRoZSBlbnZpcm9ubWVudFxuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB2aWV3Ll9jaGFuZ2VzZXQuZGF0YVtuYW1lXSA9IDE7XG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICBhcGkudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHZpZXcuX2NoYW5nZXNldC5kYXRhW25hbWVdID0gMTtcbiAgICByZXR1cm4gKGRzLnVwZGF0ZS5hcHBseShkcywgYXJndW1lbnRzKSwgYXBpKTtcbiAgfTtcblxuICBhcGkucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHZpZXcuX2NoYW5nZXNldC5kYXRhW25hbWVdID0gMTtcbiAgICByZXR1cm4gKGRzLnJlbW92ZS5hcHBseShkcywgYXJndW1lbnRzKSwgYXBpKTtcbiAgfTtcblxuICBhcGkudmFsdWVzID0gZnVuY3Rpb24oKSB7IHJldHVybiBkcy52YWx1ZXMoKTsgfTsgICAgXG5cbiAgcmV0dXJuICh0aGlzLl9hcGlbc3JjXSA9IGFwaSk7XG59XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgdiA9IHRoaXM7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHYuX21vZGVsLnZhbHVlcygpO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyhkYXRhKSkgcmV0dXJuIHN0cmVhbWluZy5jYWxsKHYsIGRhdGEpO1xuICBlbHNlIGlmIChkbC5pc09iamVjdChkYXRhKSkge1xuICAgIGRsLmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgYXBpID0gc3RyZWFtaW5nLmNhbGwodiwgayk7XG4gICAgICBkYXRhW2tdKGFwaSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG0gID0gdGhpcy5fbW9kZWwsXG4gICAgICBjcyA9IHRoaXMuX2NoYW5nZXNldCxcbiAgICAgIHN0cmVhbWVyID0gdGhpcy5fc3RyZWFtZXIsXG4gICAgICBzZXR0ZXIgPSBuYW1lOyBcblxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbS52YWx1ZXMoRGVwcy5TSUdOQUxTKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZGwuaXNTdHJpbmcobmFtZSkpIHtcbiAgICByZXR1cm4gbS52YWx1ZXMoRGVwcy5TSUdOQUxTLCBuYW1lKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICBzZXR0ZXIgPSB7fTtcbiAgICBzZXR0ZXJbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGRsLmtleXMoc2V0dGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihtLnNpZ25hbChrKS52YWx1ZShzZXR0ZXJba10pKTtcbiAgICBjcy5zaWduYWxzW2tdID0gMTtcbiAgICBjcy5yZWZsb3cgPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX193aWR0aDtcbiAgaWYgKHRoaXMuX193aWR0aCAhPT0gd2lkdGgpIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMubW9kZWwoKS53aWR0aCh3aWR0aCk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19oZWlnaHQ7XG4gIGlmICh0aGlzLl9faGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubW9kZWwoKS5oZWlnaHQoaGVpZ2h0KTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5iYWNrZ3JvdW5kID0gZnVuY3Rpb24oYmdjb2xvcikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iZ2NvbG9yO1xuICBpZiAodGhpcy5fYmdjb2xvciAhPT0gYmdjb2xvcikge1xuICAgIHRoaXMuX2JnY29sb3IgPSBiZ2NvbG9yO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnBhZGRpbmcgPSBmdW5jdGlvbihwYWQpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgaWYgKHRoaXMuX3BhZGRpbmcgIT09IHBhZCkge1xuICAgIGlmIChkbC5pc1N0cmluZyhwYWQpKSB7XG4gICAgICB0aGlzLl9hdXRvcGFkID0gMTtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICAgICAgdGhpcy5fc3RyaWN0ID0gKHBhZCA9PT0gJ3N0cmljdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvcGFkID0gMDtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgICB0aGlzLl9zdHJpY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB0aGlzLl9yZW5kZXJlci5yZXNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgcGFkKTtcbiAgICBpZiAodGhpcy5faGFuZGxlcikgIHRoaXMuX2hhbmRsZXIucGFkZGluZyhwYWQpO1xuICB9XG4gIHJldHVybiAodGhpcy5fcmVwYWludCA9IHRydWUsIHRoaXMpO1xufTtcblxucHJvdG90eXBlLmF1dG9wYWQgPSBmdW5jdGlvbihvcHQpIHtcbiAgaWYgKHRoaXMuX2F1dG9wYWQgPCAxKSByZXR1cm4gdGhpcztcbiAgZWxzZSB0aGlzLl9hdXRvcGFkID0gMDtcblxuICB2YXIgYiA9IHRoaXMubW9kZWwoKS5zY2VuZSgpLmJvdW5kcyxcbiAgICAgIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBjb25maWcgPSB0aGlzLm1vZGVsKCkuY29uZmlnKCksXG4gICAgICBpbnNldCA9IGNvbmZpZy5hdXRvcGFkSW5zZXQsXG4gICAgICBsID0gYi54MSA8IDAgPyBNYXRoLmNlaWwoLWIueDEpICsgaW5zZXQgOiAwLFxuICAgICAgdCA9IGIueTEgPCAwID8gTWF0aC5jZWlsKC1iLnkxKSArIGluc2V0IDogMCxcbiAgICAgIHIgPSBiLngyID4gdGhpcy5fd2lkdGggID8gTWF0aC5jZWlsKCtiLngyIC0gdGhpcy5fd2lkdGgpICsgaW5zZXQgOiAwO1xuICBiID0gYi55MiA+IHRoaXMuX2hlaWdodCA/IE1hdGguY2VpbCgrYi55MiAtIHRoaXMuX2hlaWdodCkgKyBpbnNldCA6IDA7XG4gIHBhZCA9IHtsZWZ0OmwsIHRvcDp0LCByaWdodDpyLCBib3R0b206Yn07XG5cbiAgaWYgKHRoaXMuX3N0cmljdCkge1xuICAgIHRoaXMuX2F1dG9wYWQgPSAwO1xuICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9fd2lkdGggLSAobCtyKSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoMCwgdGhpcy5fX2hlaWdodCAtICh0K2IpKTtcblxuICAgIHRoaXMuX21vZGVsLndpZHRoKHRoaXMuX3dpZHRoKVxuICAgICAgLmhlaWdodCh0aGlzLl9oZWlnaHQpLnJlc2V0KCk7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKVxuICAgICAgLnVwZGF0ZSh7cHJvcHM6J2VudGVyJ30pLnVwZGF0ZSh7cHJvcHM6J3VwZGF0ZSd9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhZGRpbmcocGFkKS51cGRhdGUob3B0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gIGlmICh0aGlzLl92aWV3cG9ydCAhPT0gc2l6ZSkge1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gc2l6ZTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gIGlmICh0aGlzLl9yZW5kZXJlcnNbdHlwZV0pIHR5cGUgPSB0aGlzLl9yZW5kZXJlcnNbdHlwZV07XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcmVuZGVyZXI6ICcgKyB0eXBlKTtcbiAgZWxzZSBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcignTm8gcmVuZGVyZXIgc3BlY2lmaWVkJyk7XG5cbiAgaWYgKHRoaXMuX2lvICE9PSB0eXBlKSB7XG4gICAgdGhpcy5faW8gPSB0eXBlO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fYnVpbGQpIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gIHZhciB2ID0gdGhpcywgcHJldkhhbmRsZXIsXG4gICAgICB3ID0gdi5fd2lkdGgsIGggPSB2Ll9oZWlnaHQsIHBhZCA9IHYuX3BhZGRpbmcsIGJnID0gdi5fYmdjb2xvcixcbiAgICAgIGNvbmZpZyA9IHRoaXMubW9kZWwoKS5jb25maWcoKTtcblxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgZWwgPT09IG51bGwpIHtcbiAgICBlbCA9IHRoaXMuX2VsID8gdGhpcy5fZWwucGFyZW50Tm9kZSA6IG51bGw7XG4gICAgaWYgKCFlbCkgcmV0dXJuIHRoaXM7ICAvLyBUaGlzIFZpZXcgY2Fubm90IGluaXQgdy9vIGFuXG4gIH1cblxuICAvLyBjbGVhciBwcmUtZXhpc3RpbmcgY29udGFpbmVyXG4gIGQzLnNlbGVjdChlbCkuc2VsZWN0KCdkaXYudmVnYScpLnJlbW92ZSgpO1xuICBcbiAgLy8gYWRkIGRpdiBjb250YWluZXJcbiAgdGhpcy5fZWwgPSBlbCA9IGQzLnNlbGVjdChlbClcbiAgICAuYXBwZW5kKCdkaXYnKVxuICAgIC5hdHRyKCdjbGFzcycsICd2ZWdhJylcbiAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJylcbiAgICAubm9kZSgpO1xuICBpZiAodi5fdmlld3BvcnQpIHtcbiAgICBkMy5zZWxlY3QoZWwpXG4gICAgICAuc3R5bGUoJ3dpZHRoJywgICh2Ll92aWV3cG9ydFswXSB8fCB3KSsncHgnKVxuICAgICAgLnN0eWxlKCdoZWlnaHQnLCAodi5fdmlld3BvcnRbMV0gfHwgaCkrJ3B4JylcbiAgICAgIC5zdHlsZSgnb3ZlcmZsb3cnLCAnYXV0bycpO1xuICB9XG5cbiAgLy8gcmVuZGVyZXJcbiAgc2cuY2FudmFzLlJlbmRlcmVyLlJFVElOQSA9IGNvbmZpZy5yZW5kZXIucmV0aW5hO1xuICB2Ll9yZW5kZXJlciA9ICh2Ll9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoY29uZmlnLmxvYWQpKVxuICAgIC5pbml0aWFsaXplKGVsLCB3LCBoLCBwYWQpXG4gICAgLmJhY2tncm91bmQoYmcpO1xuICBcbiAgLy8gaW5wdXQgaGFuZGxlclxuICBwcmV2SGFuZGxlciA9IHYuX2hhbmRsZXI7XG4gIHYuX2hhbmRsZXIgPSBuZXcgdGhpcy5faW8uSGFuZGxlcigpXG4gICAgLmluaXRpYWxpemUoZWwsIHBhZCwgdik7XG5cbiAgaWYgKHByZXZIYW5kbGVyKSB7XG4gICAgcHJldkhhbmRsZXIuaGFuZGxlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgIHYuX2hhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmb3Igc2lnbmFsIHN0cmVhbSBkZWZpbml0aW9ucy5cbiAgICB2Ll9kZXRhY2ggPSBwYXJzZVN0cmVhbXModGhpcyk7XG4gIH1cbiAgXG4gIHJldHVybiAodGhpcy5fcmVwYWludCA9IHRydWUsIHRoaXMpO1xufTtcblxucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2RldGFjaCkgdGhpcy5fZGV0YWNoKCk7XG59O1xuXG5mdW5jdGlvbiBidWlsZCgpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICB2Ll9yZW5kZXJOb2RlID0gbmV3IGRmLk5vZGUodi5fbW9kZWwpXG4gICAgLnJvdXRlcih0cnVlKTtcblxuICB2Ll9yZW5kZXJOb2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBsb2cuZGVidWcoaW5wdXQsIFsncmVuZGVyaW5nJ10pO1xuXG4gICAgdmFyIHMgPSB2Ll9tb2RlbC5zY2VuZSgpLFxuICAgICAgICBoID0gdi5faGFuZGxlcjtcblxuICAgIGlmIChoICYmIGguc2NlbmUpIGguc2NlbmUocyk7XG5cbiAgICBpZiAoaW5wdXQudHJhbnMpIHtcbiAgICAgIGlucHV0LnRyYW5zLnN0YXJ0KGZ1bmN0aW9uKGl0ZW1zKSB7IHYuX3JlbmRlcmVyLnJlbmRlcihzLCBpdGVtcyk7IH0pO1xuICAgIH0gZWxzZSBpZiAodi5fcmVwYWludCkge1xuICAgICAgdi5fcmVuZGVyZXIucmVuZGVyKHMpO1xuICAgICAgdi5fcmVwYWludCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZGlydHkubGVuZ3RoKSB7XG4gICAgICB2Ll9yZW5kZXJlci5yZW5kZXIocywgaW5wdXQuZGlydHkpO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5kaXJ0eS5sZW5ndGgpIHtcbiAgICAgIGlucHV0LmRpcnR5LmZvckVhY2goZnVuY3Rpb24oaSkgeyBpLl9kaXJ0eSA9IGZhbHNlOyB9KTtcbiAgICAgIHMuaXRlbXNbMF0uX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRm9yIGFsbCB1cGRhdGVkIGRhdGFzb3VyY2VzLCBjbGVhciB0aGVpciBwcmV2aW91cyB2YWx1ZXMuXG4gICAgZm9yICh2YXIgZCBpbiBpbnB1dC5kYXRhKSB7IHYuX21vZGVsLmRhdGEoZCkuc3luY2hyb25pemUoKTsgfVxuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICByZXR1cm4gKHYuX21vZGVsLnNjZW5lKHYuX3JlbmRlck5vZGUpLCB0cnVlKTsgIFxufVxuXG5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHYgPSB0aGlzLFxuICAgICAgdHJhbnMgPSBvcHQuZHVyYXRpb24gPyBuZXcgVHJhbnNpdGlvbihvcHQuZHVyYXRpb24sIG9wdC5lYXNlKSA6IG51bGw7XG5cbiAgdmFyIGNzID0gdi5fY2hhbmdlc2V0O1xuICBpZiAodHJhbnMpIGNzLnRyYW5zID0gdHJhbnM7XG4gIGlmIChvcHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5rZXlzKGNzLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnTmV3IGRhdGEgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLicgK1xuICAgICAgICAnIFBsZWFzZSBjYWxsIHZpZXcudXBkYXRlKCkgYmVmb3JlIHVwZGF0aW5nIGEgc3BlY2lmaWVkIHByb3BlcnR5IHNldC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNzLnJlZmxvdyAgPSB0cnVlO1xuICAgIGNzLnJlcXVlc3QgPSBvcHQucHJvcHM7XG4gIH1cblxuICB2YXIgYnVpbHQgPSB2Ll9idWlsZDtcbiAgdi5fYnVpbGQgPSB2Ll9idWlsZCB8fCBidWlsZC5jYWxsKHRoaXMpO1xuXG4gIC8vIElmIHNwZWNpZmljIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHNob3J0LWNpcmN1aXQgZGF0YWZsb3cgZ3JhcGguXG4gIC8vIEVsc2UtSWYgdGhlcmUgYXJlIHN0cmVhbWluZyB1cGRhdGVzLCBwZXJmb3JtIGEgdGFyZ2V0ZWQgcHJvcGFnYXRpb24uXG4gIC8vIE90aGVyd2lzZSwgcmVldmFsdWF0ZSB0aGUgZW50aXJlIG1vZGVsIChkYXRhc291cmNlcyArIHNjZW5lKS5cbiAgaWYgKG9wdC5pdGVtcyAmJiBidWlsdCkgeyBcbiAgICBFbmNvZGVyLnVwZGF0ZSh0aGlzLl9tb2RlbCwgb3B0LnRyYW5zLCBvcHQucHJvcHMsIG9wdC5pdGVtcywgY3MuZGlydHkpO1xuICAgIHYuX3JlbmRlck5vZGUuZXZhbHVhdGUoY3MpO1xuICB9IGVsc2UgaWYgKHYuX3N0cmVhbWVyLmxpc3RlbmVycygpLmxlbmd0aCAmJiBidWlsdCkge1xuICAgIHYuX21vZGVsLnByb3BhZ2F0ZShjcywgdi5fc3RyZWFtZXIpO1xuICAgIHYuX3N0cmVhbWVyLmRpc2Nvbm5lY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB2Ll9tb2RlbC5maXJlKGNzKTtcbiAgfVxuXG4gIHYuX2NoYW5nZXNldCA9IGRmLkNoYW5nZVNldC5jcmVhdGUoKTtcblxuICByZXR1cm4gdi5hdXRvcGFkKG9wdCk7XG59O1xuXG5wcm90b3R5cGUudG9JbWFnZVVSTCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHYgPSB0aGlzLCBSZW5kZXJlcjtcblxuICAvLyBsb29rdXAgYXBwcm9wcmlhdGUgcmVuZGVyZXJcbiAgc3dpdGNoICh0eXBlIHx8ICdwbmcnKSB7XG4gICAgY2FzZSAnY2FudmFzJzpcbiAgICBjYXNlICdwbmcnOlxuICAgICAgUmVuZGVyZXIgPSBzZy5jYW52YXMuUmVuZGVyZXI7IGJyZWFrO1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICBSZW5kZXJlciA9IHNnLnN2Zy5zdHJpbmcuUmVuZGVyZXI7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IEVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICB9XG5cbiAgdmFyIHJldGluYSA9IHNnLmNhbnZhcy5SZW5kZXJlci5SRVRJTkE7XG4gIHNnLmNhbnZhcy5SZW5kZXJlci5SRVRJTkEgPSBmYWxzZTsgLy8gaWdub3JlIHJldGluYSBzY3JlZW5cblxuICAvLyByZW5kZXIgdGhlIHNjZW5lZ3JhcGhcbiAgdmFyIHJlbiA9IG5ldyBSZW5kZXJlcih2Ll9tb2RlbC5jb25maWcubG9hZClcbiAgICAuaW5pdGlhbGl6ZShudWxsLCB2Ll93aWR0aCwgdi5faGVpZ2h0LCB2Ll9wYWRkaW5nKVxuICAgIC5yZW5kZXIodi5fbW9kZWwuc2NlbmUoKSk7XG5cbiAgc2cuY2FudmFzLlJlbmRlcmVyLlJFVElOQSA9IHJldGluYTsgLy8gcmVzdG9yZSByZXRpbmEgc2V0dGluZ3NcblxuICAvLyByZXR1cm4gZGF0YSB1cmxcbiAgaWYgKHR5cGUgPT09ICdzdmcnKSB7XG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbcmVuLnN2ZygpXSwge3R5cGU6ICdpbWFnZS9zdmcreG1sJ30pO1xuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVuLmNhbnZhcygpLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIH1cbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihpdGVtcykge1xuICB0aGlzLl9yZW5kZXJlci5yZW5kZXIodGhpcy5fbW9kZWwuc2NlbmUoKSwgaXRlbXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW5kbGVyLm9uLmFwcGx5KHRoaXMuX2hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9uU2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICB0aGlzLl9tb2RlbC5zaWduYWwobmFtZSkub24oaGFuZGxlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW5kbGVyLm9mZi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmZTaWduYWwgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuX21vZGVsLnNpZ25hbChuYW1lKS5vZmYoaGFuZGxlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmlldy5mYWN0b3J5ID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgdmFyIEhlYWRsZXNzVmlldyA9IHJlcXVpcmUoJy4vSGVhZGxlc3NWaWV3Jyk7XG4gIHJldHVybiBmdW5jdGlvbihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIGRlZnMgPSBtb2RlbC5kZWZzKCk7XG4gICAgdmFyIHYgPSAob3B0LmVsID8gbmV3IFZpZXcoKSA6IG5ldyBIZWFkbGVzc1ZpZXcoKSlcbiAgICAgIC5tb2RlbChtb2RlbClcbiAgICAgIC5yZW5kZXJlcihvcHQucmVuZGVyZXIgfHwgJ2NhbnZhcycpXG4gICAgICAud2lkdGgoZGVmcy53aWR0aClcbiAgICAgIC5oZWlnaHQoZGVmcy5oZWlnaHQpXG4gICAgICAuYmFja2dyb3VuZChkZWZzLmJhY2tncm91bmQpXG4gICAgICAucGFkZGluZyhkZWZzLnBhZGRpbmcpXG4gICAgICAudmlld3BvcnQoZGVmcy52aWV3cG9ydClcbiAgICAgIC5pbml0aWFsaXplKG9wdC5lbCk7XG5cbiAgICBpZiAob3B0LmRhdGEpIHYuZGF0YShvcHQuZGF0YSk7XG5cbiAgICBpZiAob3B0LmhvdmVyICE9PSBmYWxzZSAmJiBvcHQuZWwpIHtcbiAgICAgIHYub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGV2dCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmhhc1Byb3BlcnR5U2V0KCdob3ZlcicpKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoe3Byb3BzOidob3ZlcicsIGl0ZW1zOml0ZW19KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihldnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5oYXNQcm9wZXJ0eVNldCgnaG92ZXInKSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKHtwcm9wczondXBkYXRlJywgaXRlbXM6aXRlbX0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB2O1xuICB9OyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldzsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBjb25maWcgPSB7fTtcblxuY29uZmlnLmxvYWQgPSB7XG4gIC8vIGJhc2UgdXJsIGZvciBsb2FkaW5nIGV4dGVybmFsIGRhdGEgZmlsZXNcbiAgLy8gdXNlZCBvbmx5IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25cbiAgYmFzZVVSTDogJycsXG4gIC8vIEFsbG93cyBkb21haW4gcmVzdHJpY3Rpb24gd2hlbiB1c2luZyBkYXRhIGxvYWRpbmcgdmlhIFhIUi5cbiAgLy8gVG8gZW5hYmxlLCBzZXQgaXQgdG8gYSBsaXN0IG9mIGFsbG93ZWQgZG9tYWluc1xuICAvLyBlLmcuLCBbJ3dpa2lwZWRpYS5vcmcnLCAnZWZmLm9yZyddXG4gIGRvbWFpbldoaXRlTGlzdDogZmFsc2Vcbn07XG5cbi8vIGluc2V0IHBhZGRpbmcgZm9yIGF1dG9tYXRpYyBwYWRkaW5nIGNhbGN1bGF0aW9uXG5jb25maWcuYXV0b3BhZEluc2V0ID0gNTtcblxuLy8gZXh0ZW5zaWJsZSBzY2FsZSBsb29rdXAgdGFibGVcbi8vIGFsbCBkMy5zY2FsZS4qIGluc3RhbmNlcyBhbHNvIHN1cHBvcnRlZFxuY29uZmlnLnNjYWxlID0ge1xuICB0aW1lOiBkMy50aW1lLnNjYWxlLFxuICB1dGM6ICBkMy50aW1lLnNjYWxlLnV0Y1xufTtcblxuLy8gZGVmYXVsdCByZW5kZXJpbmcgc2V0dGluZ3NcbmNvbmZpZy5yZW5kZXIgPSB7XG4gIHJldGluYTogdHJ1ZVxufTtcblxuLy8gZGVmYXVsdCBheGlzIHByb3BlcnRpZXNcbmNvbmZpZy5heGlzID0ge1xuICBvcmllbnQ6ICdib3R0b20nLFxuICB0aWNrczogMTAsXG4gIHBhZGRpbmc6IDMsXG4gIGF4aXNDb2xvcjogJyMwMDAnLFxuICBncmlkQ29sb3I6ICcjMDAwJyxcbiAgZ3JpZE9wYWNpdHk6IDAuMTUsXG4gIHRpY2tDb2xvcjogJyMwMDAnLFxuICB0aWNrTGFiZWxDb2xvcjogJyMwMDAnLFxuICBheGlzV2lkdGg6IDEsXG4gIHRpY2tXaWR0aDogMSxcbiAgdGlja1NpemU6IDYsXG4gIHRpY2tMYWJlbEZvbnRTaXplOiAxMSxcbiAgdGlja0xhYmVsRm9udDogJ3NhbnMtc2VyaWYnLFxuICB0aXRsZUNvbG9yOiAnIzAwMCcsXG4gIHRpdGxlRm9udDogJ3NhbnMtc2VyaWYnLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiAnYm9sZCcsXG4gIHRpdGxlT2Zmc2V0OiAzNVxufTtcblxuLy8gZGVmYXVsdCBsZWdlbmQgcHJvcGVydGllc1xuY29uZmlnLmxlZ2VuZCA9IHtcbiAgb3JpZW50OiAncmlnaHQnLFxuICBvZmZzZXQ6IDIwLFxuICBwYWRkaW5nOiAzLFxuICBncmFkaWVudFN0cm9rZUNvbG9yOiAnIzg4OCcsXG4gIGdyYWRpZW50U3Ryb2tlV2lkdGg6IDEsXG4gIGdyYWRpZW50SGVpZ2h0OiAxNixcbiAgZ3JhZGllbnRXaWR0aDogMTAwLFxuICBsYWJlbENvbG9yOiAnIzAwMCcsXG4gIGxhYmVsRm9udFNpemU6IDEwLFxuICBsYWJlbEZvbnQ6ICdzYW5zLXNlcmlmJyxcbiAgbGFiZWxBbGlnbjogJ2xlZnQnLFxuICBsYWJlbEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgbGFiZWxPZmZzZXQ6IDgsXG4gIHN5bWJvbFNoYXBlOiAnY2lyY2xlJyxcbiAgc3ltYm9sU2l6ZTogNTAsXG4gIHN5bWJvbENvbG9yOiAnIzg4OCcsXG4gIHN5bWJvbFN0cm9rZVdpZHRoOiAxLFxuICB0aXRsZUNvbG9yOiAnIzAwMCcsXG4gIHRpdGxlRm9udDogJ3NhbnMtc2VyaWYnLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiAnYm9sZCdcbn07XG5cbi8vIGRlZmF1bHQgY29sb3IgdmFsdWVzXG5jb25maWcuY29sb3IgPSB7XG4gIHJnYjogWzEyOCwgMTI4LCAxMjhdLFxuICBsYWI6IFs1MCwgMCwgMF0sXG4gIGhjbDogWzAsIDAsIDUwXSxcbiAgaHNsOiBbMCwgMCwgMC41XVxufTtcblxuLy8gZGVmYXVsdCBzY2FsZSByYW5nZXNcbmNvbmZpZy5yYW5nZSA9IHtcbiAgY2F0ZWdvcnkxMDogIGQzLnNjYWxlLmNhdGVnb3J5MTAoKS5yYW5nZSgpLFxuICBjYXRlZ29yeTIwOiAgZDMuc2NhbGUuY2F0ZWdvcnkyMCgpLnJhbmdlKCksXG4gIGNhdGVnb3J5MjBiOiBkMy5zY2FsZS5jYXRlZ29yeTIwYigpLnJhbmdlKCksXG4gIGNhdGVnb3J5MjBjOiBkMy5zY2FsZS5jYXRlZ29yeTIwYygpLnJhbmdlKCksXG4gIHNoYXBlczogW1xuICAgICdjaXJjbGUnLFxuICAgICdjcm9zcycsXG4gICAgJ2RpYW1vbmQnLFxuICAgICdzcXVhcmUnLFxuICAgICd0cmlhbmdsZS1kb3duJyxcbiAgICAndHJpYW5nbGUtdXAnXG4gIF1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyksXG4gICAgU2NhbGUgPSByZXF1aXJlKCcuLi9zY2VuZS9TY2FsZScpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbmZ1bmN0aW9uIGNvbXBpbGUobW9kdWxlLCBvcHQsIHNjaGVtYSkge1xuICB2YXIgcyA9IG1vZHVsZS5zY2hlbWE7XG4gIGlmICghcykgcmV0dXJuO1xuICBpZiAocy5yZWZzKSBkbC5leHRlbmQoc2NoZW1hLnJlZnMsIHMucmVmcyk7XG4gIGlmIChzLmRlZnMpIGRsLmV4dGVuZChzY2hlbWEuZGVmcywgcy5kZWZzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgdmFyIHNjaGVtYSA9IG51bGw7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBDb21waWxlIGlmIHdlJ3JlIG5vdCBsb2FkaW5nIHRoZSBzY2hlbWEgZnJvbSBhIFVSTC4gXG4gIC8vIExvYWQgZnJvbSBhIFVSTCB0byBleHRlbmQgdGhlIGV4aXN0aW5nIGJhc2Ugc2NoZW1hLlxuICBpZiAob3B0LnVybCkge1xuICAgIHNjaGVtYSA9IGRsLmpzb24oZGwuZXh0ZW5kKHt1cmw6IG9wdC51cmx9LCBjb25maWcubG9hZCkpO1xuICB9IGVsc2Uge1xuICAgIHNjaGVtYSA9IHtcbiAgICAgIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICAgICAgXCJ0aXRsZVwiOiBcIlZlZ2EgVmlzdWFsaXphdGlvbiBTcGVjaWZpY2F0aW9uIExhbmd1YWdlXCIsXG4gICAgICBcImRlZnNcIjoge30sIFxuICAgICAgXCJyZWZzXCI6IHt9LCBcbiAgICAgIFwiJHJlZlwiOiBcIiMvZGVmcy9zcGVjXCJcbiAgICB9O1xuXG4gICAgZGwua2V5cyhwYXJzZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7IGNvbXBpbGUocGFyc2Vba10sIG9wdCwgc2NoZW1hKTsgfSk7XG5cbiAgICAvLyBTY2FsZXMgYXJlbid0IGluIHRoZSBwYXJzZXIsIGFkZCBzY2hlbWEgbWFudWFsbHlcbiAgICBjb21waWxlKFNjYWxlLCBvcHQsIHNjaGVtYSk7XG4gIH1cblxuICAvLyBFeHRlbmQgc2NoZW1hIHRvIHN1cHBvcnQgY3VzdG9tIG1hcmsgcHJvcGVydGllcyBvciBwcm9wZXJ0eSBzZXRzLlxuICBpZiAob3B0LnByb3BlcnRpZXMpIGRsLmtleXMob3B0LnByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHNjaGVtYS5kZWZzLnByb3BzZXQucHJvcGVydGllc1trXSA9IHtcIiRyZWZcIjogXCIjL3JlZnMvXCIrb3B0LnByb3BlcnRpZXNba10rXCJWYWx1ZVwifTtcbiAgfSk7XG5cbiAgaWYgKG9wdC5wcm9wZXJ0eVNldHMpIGRsLmtleXMob3B0LnByb3BlcnR5U2V0cykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgc2NoZW1hLmRlZnMubWFyay5wcm9wZXJ0aWVzLnByb3BlcnRpZXMucHJvcGVydGllc1trXSA9IHtcIiRyZWZcIjogXCIjL2RlZnMvcHJvcHNldFwifTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGF4cyA9IHJlcXVpcmUoJy4uL3NjZW5lL2F4aXMnKTtcblxudmFyIE9SSUVOVCA9IHtcbiAgXCJ4XCI6ICAgICAgXCJib3R0b21cIixcbiAgXCJ5XCI6ICAgICAgXCJsZWZ0XCIsXG4gIFwidG9wXCI6ICAgIFwidG9wXCIsXG4gIFwiYm90dG9tXCI6IFwiYm90dG9tXCIsXG4gIFwibGVmdFwiOiAgIFwibGVmdFwiLFxuICBcInJpZ2h0XCI6ICBcInJpZ2h0XCJcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQXhlcyhtb2RlbCwgc3BlYywgYXhlcywgZ3JvdXApIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZygpO1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgYXhlc1tpbmRleF0gPSBheGVzW2luZGV4XSB8fCBheHMobW9kZWwpO1xuICAgIHBhcnNlQXhpcyhjb25maWcsIGRlZiwgaW5kZXgsIGF4ZXNbaW5kZXhdLCBncm91cCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUF4aXMoY29uZmlnLCBkZWYsIGluZGV4LCBheGlzLCBncm91cCkge1xuICAvLyBheGlzIHNjYWxlXG4gIGlmIChkZWYuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGF4aXMuc2NhbGUoZ3JvdXAuc2NhbGUoZGVmLnNjYWxlKSk7XG4gIH1cblxuICAvLyBheGlzIG9yaWVudGF0aW9uXG4gIGF4aXMub3JpZW50KGRlZi5vcmllbnQgfHwgT1JJRU5UW2RlZi50eXBlXSk7XG4gIC8vIGF4aXMgb2Zmc2V0XG4gIGF4aXMub2Zmc2V0KGRlZi5vZmZzZXQgfHwgMCk7XG4gIC8vIGF4aXMgbGF5ZXJcbiAgYXhpcy5sYXllcihkZWYubGF5ZXIgfHwgXCJmcm9udFwiKTtcbiAgLy8gYXhpcyBncmlkIGxpbmVzXG4gIGF4aXMuZ3JpZChkZWYuZ3JpZCB8fCBmYWxzZSk7XG4gIC8vIGF4aXMgdGl0bGVcbiAgYXhpcy50aXRsZShkZWYudGl0bGUgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGl0bGUgb2Zmc2V0XG4gIGF4aXMudGl0bGVPZmZzZXQoZGVmLnRpdGxlT2Zmc2V0ICE9IG51bGwgP1xuICAgIGRlZi50aXRsZU9mZnNldCA6IGNvbmZpZy5heGlzLnRpdGxlT2Zmc2V0KTtcbiAgLy8gYXhpcyB2YWx1ZXNcbiAgYXhpcy50aWNrVmFsdWVzKGRlZi52YWx1ZXMgfHwgbnVsbCk7XG4gIC8vIGF4aXMgbGFiZWwgZm9ybWF0dGluZ1xuICBheGlzLnRpY2tGb3JtYXQoZGVmLmZvcm1hdCB8fCBudWxsKTtcbiAgYXhpcy50aWNrRm9ybWF0VHlwZShkZWYuZm9ybWF0VHlwZSB8fCBudWxsKTtcbiAgLy8gYXhpcyB0aWNrIHN1YmRpdmlzaW9uXG4gIGF4aXMudGlja1N1YmRpdmlkZShkZWYuc3ViZGl2aWRlIHx8IDApO1xuICAvLyBheGlzIHRpY2sgcGFkZGluZ1xuICBheGlzLnRpY2tQYWRkaW5nKGRlZi50aWNrUGFkZGluZyB8fCBjb25maWcuYXhpcy5wYWRkaW5nKTtcblxuICAvLyBheGlzIHRpY2sgc2l6ZShzKVxuICB2YXIgc2l6ZSA9IFtdO1xuICBpZiAoZGVmLnRpY2tTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8MzsgKytpKSBzaXplLnB1c2goZGVmLnRpY2tTaXplKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHMgPSBjb25maWcuYXhpcy50aWNrU2l6ZTtcbiAgICBzaXplID0gW3RzLCB0cywgdHNdO1xuICB9XG4gIGlmIChkZWYudGlja1NpemVNYWpvciAhPSBudWxsKSBzaXplWzBdID0gZGVmLnRpY2tTaXplTWFqb3I7XG4gIGlmIChkZWYudGlja1NpemVNaW5vciAhPSBudWxsKSBzaXplWzFdID0gZGVmLnRpY2tTaXplTWlub3I7XG4gIGlmIChkZWYudGlja1NpemVFbmQgICAhPSBudWxsKSBzaXplWzJdID0gZGVmLnRpY2tTaXplRW5kO1xuICBpZiAoc2l6ZS5sZW5ndGgpIHtcbiAgICBheGlzLnRpY2tTaXplLmFwcGx5KGF4aXMsIHNpemUpO1xuICB9XG5cbiAgLy8gYXhpcyB0aWNrIGNvdW50XG4gIGF4aXMudGlja0NvdW50KGRlZi50aWNrcyB8fCBjb25maWcuYXhpcy50aWNrcyk7XG5cbiAgLy8gc3R5bGUgcHJvcGVydGllc1xuICB2YXIgcCA9IGRlZi5wcm9wZXJ0aWVzO1xuICBpZiAocCAmJiBwLnRpY2tzKSB7XG4gICAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzKHAubWFqb3JUaWNrcyA/XG4gICAgICBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWFqb3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMocC5taW5vclRpY2tzID9cbiAgICAgIGRsLmV4dGVuZCh7fSwgcC50aWNrcywgcC5taW5vclRpY2tzKSA6IHAudGlja3MpO1xuICB9IGVsc2Uge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwICYmIHAubWFqb3JUaWNrcyB8fCB7fSk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAgJiYgcC5taW5vclRpY2tzIHx8IHt9KTtcbiAgfVxuICBheGlzLnRpY2tMYWJlbFByb3BlcnRpZXMocCAmJiBwLmxhYmVscyB8fCB7fSk7XG4gIGF4aXMudGl0bGVQcm9wZXJ0aWVzKHAgJiYgcC50aXRsZSB8fCB7fSk7XG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzKHAgJiYgcC5ncmlkIHx8IHt9KTtcbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzKHAgJiYgcC5heGlzIHx8IHt9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUF4ZXM7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCk7XG5cbmZ1bmN0aW9uIHBhcnNlQmcoYmcpIHtcbiAgLy8gcmV0dXJuIG51bGwgaWYgaW5wdXQgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgaWYgKGJnID09IG51bGwpIHJldHVybiBudWxsO1xuICAvLyBydW4gdGhyb3VnaCBkMyByZ2IgdG8gc2FuaXR5IGNoZWNrXG4gIHJldHVybiBkMy5yZ2IoYmcpICsgXCJcIjsgIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQmc7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIHBhcnNlVHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtcycpLFxuICAgIHBhcnNlTW9kaWZ5ID0gcmVxdWlyZSgnLi9tb2RpZnknKTtcblxuZnVuY3Rpb24gcGFyc2VEYXRhKG1vZGVsLCBzcGVjLCBjYWxsYmFjaykge1xuICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnKCksXG4gICAgICBjb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gbG9hZGVkKGQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBsb2cuZXJyb3IoJ0xPQURJTkcgRkFJTEVEOiAnICsgZC51cmwgKyAnICcgKyBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5kYXRhKGQubmFtZSkudmFsdWVzKGRsLnJlYWQoZGF0YSwgZC5mb3JtYXQpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLWNvdW50ID09PSAwKSBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2ggZGF0YSBzZXQgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgaWYgKGQudXJsKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgZGwubG9hZChkbC5leHRlbmQoe3VybDogZC51cmx9LCBjb25maWcubG9hZCksIGxvYWRlZChkKSk7XG4gICAgfVxuICAgIHBhcnNlRGF0YS5kYXRhc291cmNlKG1vZGVsLCBkKTtcbiAgfSk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbiAgcmV0dXJuIHNwZWM7XG59XG5cbnBhcnNlRGF0YS5kYXRhc291cmNlID0gZnVuY3Rpb24obW9kZWwsIGQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IChkLnRyYW5zZm9ybSB8fCBbXSkubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVHJhbnNmb3Jtcyhtb2RlbCwgdCk7IFxuICAgICAgfSksXG4gICAgICBtb2QgPSAoZC5tb2RpZnkgfHwgW10pLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU1vZGlmeShtb2RlbCwgbSwgZCk7XG4gICAgICB9KSxcbiAgICAgIGRzID0gbW9kZWwuZGF0YShkLm5hbWUsIG1vZC5jb25jYXQodHJhbnNmb3JtKSk7XG5cbiAgaWYgKGQudmFsdWVzKSB7XG4gICAgZHMudmFsdWVzKGRsLnJlYWQoZC52YWx1ZXMsIGQuZm9ybWF0KSk7XG4gIH0gZWxzZSBpZiAoZC5zb3VyY2UpIHtcbiAgICAvLyBEZXJpdmVkIGRzIHdpbGwgYmUgcHVsc2VkIGJ5IGl0cyBzcmMgcmF0aGVyIHRoYW4gdGhlIG1vZGVsLlxuICAgIGRzLnNvdXJjZShkLnNvdXJjZSkuYWRkTGlzdGVuZXIoZHMpOyAgXG4gICAgbW9kZWwucmVtb3ZlTGlzdGVuZXIoZHMucGlwZWxpbmUoKVswXSk7IFxuICB9XG5cbiAgcmV0dXJuIGRzOyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VEYXRhOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHN0YXJ0OiBwZWckcGFyc2VzdGFydCB9LFxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlc3RhcnQsXG5cbiAgICAgICAgcGVnJGMwID0gcGVnJEZBSUxFRCxcbiAgICAgICAgcGVnJGMxID0gXCIsXCIsXG4gICAgICAgIHBlZyRjMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzID0gZnVuY3Rpb24obywgbSkgeyByZXR1cm4gW29dLmNvbmNhdChtKTsgfSxcbiAgICAgICAgcGVnJGM0ID0gZnVuY3Rpb24obykgeyByZXR1cm4gW29dOyB9LFxuICAgICAgICBwZWckYzUgPSBcIltcIixcbiAgICAgICAgcGVnJGM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgICBwZWckYzcgPSBcIl1cIixcbiAgICAgICAgcGVnJGM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgICBwZWckYzkgPSBcIj5cIixcbiAgICAgICAgcGVnJGMxMCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj5cIiwgZGVzY3JpcHRpb246IFwiXFxcIj5cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMSA9IGZ1bmN0aW9uKGYxLCBmMiwgbykgeyByZXR1cm4ge3N0YXJ0OiBmMSwgZW5kOiBmMiwgbWlkZGxlOiBvfTsgfSxcbiAgICAgICAgcGVnJGMxMiA9IFtdLFxuICAgICAgICBwZWckYzEzID0gZnVuY3Rpb24ocywgZikgeyByZXR1cm4gKHMuZmlsdGVycyA9IGYsIHMpOyB9LFxuICAgICAgICBwZWckYzE0ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gczsgfSxcbiAgICAgICAgcGVnJGMxNSA9IFwiKFwiLFxuICAgICAgICBwZWckYzE2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgICBwZWckYzE3ID0gXCIpXCIsXG4gICAgICAgIHBlZyRjMTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIpXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIpXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihtKSB7IHJldHVybiB7c3RyZWFtOiBtfTsgfSxcbiAgICAgICAgcGVnJGMyMCA9IFwiQFwiLFxuICAgICAgICBwZWckYzIxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQFxcXCJcIiB9LFxuICAgICAgICBwZWckYzIyID0gXCI6XCIsXG4gICAgICAgIHBlZyRjMjMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbihuLCBlKSB7IHJldHVybiB7ZXZlbnQ6IGUsIG5hbWU6IG59OyB9LFxuICAgICAgICBwZWckYzI1ID0gZnVuY3Rpb24obSwgZSkgeyByZXR1cm4ge2V2ZW50OiBlLCBtYXJrOiBtfTsgfSxcbiAgICAgICAgcGVnJGMyNiA9IGZ1bmN0aW9uKHQsIGUpIHsgcmV0dXJuIHtldmVudDogZSwgdGFyZ2V0OiB0fTsgfSxcbiAgICAgICAgcGVnJGMyNyA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHtldmVudDogZX07IH0sXG4gICAgICAgIHBlZyRjMjggPSBmdW5jdGlvbihzKSB7IHJldHVybiB7c2lnbmFsOiBzfTsgfSxcbiAgICAgICAgcGVnJGMyOSA9IFwicmVjdFwiLFxuICAgICAgICBwZWckYzMwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVjdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVjdFxcXCJcIiB9LFxuICAgICAgICBwZWckYzMxID0gXCJzeW1ib2xcIixcbiAgICAgICAgcGVnJGMzMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN5bWJvbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic3ltYm9sXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMzMgPSBcInBhdGhcIixcbiAgICAgICAgcGVnJGMzNCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInBhdGhcIiwgZGVzY3JpcHRpb246IFwiXFxcInBhdGhcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzNSA9IFwiYXJjXCIsXG4gICAgICAgIHBlZyRjMzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhcmNcIiwgZGVzY3JpcHRpb246IFwiXFxcImFyY1xcXCJcIiB9LFxuICAgICAgICBwZWckYzM3ID0gXCJhcmVhXCIsXG4gICAgICAgIHBlZyRjMzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhcmVhXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhcmVhXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMzkgPSBcImxpbmVcIixcbiAgICAgICAgcGVnJGM0MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImxpbmVcIiwgZGVzY3JpcHRpb246IFwiXFxcImxpbmVcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0MSA9IFwicnVsZVwiLFxuICAgICAgICBwZWckYzQyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicnVsZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicnVsZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzQzID0gXCJpbWFnZVwiLFxuICAgICAgICBwZWckYzQ0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaW1hZ2VcIiwgZGVzY3JpcHRpb246IFwiXFxcImltYWdlXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDUgPSBcInRleHRcIixcbiAgICAgICAgcGVnJGM0NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRleHRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRleHRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0NyA9IFwiZ3JvdXBcIixcbiAgICAgICAgcGVnJGM0OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImdyb3VwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJncm91cFxcXCJcIiB9LFxuICAgICAgICBwZWckYzQ5ID0gXCJtb3VzZWRvd25cIixcbiAgICAgICAgcGVnJGM1MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vkb3duXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTEgPSBcIm1vdXNldXBcIixcbiAgICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNldXBcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNldXBcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MyA9IFwiY2xpY2tcIixcbiAgICAgICAgcGVnJGM1NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJjbGlja1xcXCJcIiB9LFxuICAgICAgICBwZWckYzU1ID0gXCJkYmxjbGlja1wiLFxuICAgICAgICBwZWckYzU2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZGJsY2xpY2tcIiwgZGVzY3JpcHRpb246IFwiXFxcImRibGNsaWNrXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTcgPSBcIndoZWVsXCIsXG4gICAgICAgIHBlZyRjNTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwid2hlZWxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1OSA9IFwia2V5ZG93blwiLFxuICAgICAgICBwZWckYzYwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5ZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5ZG93blxcXCJcIiB9LFxuICAgICAgICBwZWckYzYxID0gXCJrZXlwcmVzc1wiLFxuICAgICAgICBwZWckYzYyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5cHJlc3NcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXByZXNzXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNjMgPSBcImtleXVwXCIsXG4gICAgICAgIHBlZyRjNjQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXl1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5dXBcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2NSA9IFwibW91c2V3aGVlbFwiLFxuICAgICAgICBwZWckYzY2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2V3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2V3aGVlbFxcXCJcIiB9LFxuICAgICAgICBwZWckYzY3ID0gXCJtb3VzZW1vdmVcIixcbiAgICAgICAgcGVnJGM2OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlbW92ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vtb3ZlXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNjkgPSBcIm1vdXNlb3V0XCIsXG4gICAgICAgIHBlZyRjNzAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW91dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VvdXRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3MSA9IFwibW91c2VvdmVyXCIsXG4gICAgICAgIHBlZyRjNzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW92ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3ZlclxcXCJcIiB9LFxuICAgICAgICBwZWckYzczID0gXCJtb3VzZWVudGVyXCIsXG4gICAgICAgIHBlZyRjNzQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWVudGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZWVudGVyXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNzUgPSBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgcGVnJGM3NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoc3RhcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoc3RhcnRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3NyA9IFwidG91Y2htb3ZlXCIsXG4gICAgICAgIHBlZyRjNzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaG1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNobW92ZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzc5ID0gXCJ0b3VjaGVuZFwiLFxuICAgICAgICBwZWckYzgwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2hlbmRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoZW5kXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjODEgPSBmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9LFxuICAgICAgICBwZWckYzgyID0gL15bYS16QS1aMC05X1xcLV0vLFxuICAgICAgICBwZWckYzgzID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTlfXFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTlfXFxcXC1dXCIgfSxcbiAgICAgICAgcGVnJGM4NCA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uam9pbihcIlwiKTsgfSxcbiAgICAgICAgcGVnJGM4NSA9IC9eW2EtekEtWjAtOVxcLV8gICMuPit+W1xcXT18XFxeJCpdLyxcbiAgICAgICAgcGVnJGM4NiA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05XFxcXC1fICAjLj4rfltcXFxcXT18XFxcXF4kKl1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOVxcXFwtXyAgIy4+K35bXFxcXF09fFxcXFxeJCpdXCIgfSxcbiAgICAgICAgcGVnJGM4NyA9IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGMuam9pbihcIlwiKTsgfSxcbiAgICAgICAgcGVnJGM4OCA9IC9eWydcImEtekEtWjAtOV8oKS4+PD0hIFxcdC0mfH5dLyxcbiAgICAgICAgcGVnJGM4OSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbJ1xcXCJhLXpBLVowLTlfKCkuPjw9ISBcXFxcdC0mfH5dXCIsIGRlc2NyaXB0aW9uOiBcIlsnXFxcImEtekEtWjAtOV8oKS4+PD0hIFxcXFx0LSZ8fl1cIiB9LFxuICAgICAgICBwZWckYzkwID0gZnVuY3Rpb24odikgeyByZXR1cm4gdi5qb2luKFwiXCIpOyB9LFxuICAgICAgICBwZWckYzkxID0gL15bIFxcdFxcclxcbl0vLFxuICAgICAgICBwZWckYzkyID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsgXFxcXHRcXFxcclxcXFxuXVwiLCBkZXNjcmlwdGlvbjogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiB9LFxuXG4gICAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgICAgcGVnJHJlc3VsdDtcblxuICAgIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXBvcnRlZFBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sdW1uKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgICBudWxsLFxuICAgICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgcCwgY2g7XG5cbiAgICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xuICAgICAgICAgIGNoID0gaW5wdXQuY2hhckF0KHApO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgIT09IHBvcykge1xuICAgICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3MgPSAwO1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlKHBlZyRjYWNoZWRQb3NEZXRhaWxzLCBwZWckY2FjaGVkUG9zLCBwb3MpO1xuICAgICAgICBwZWckY2FjaGVkUG9zID0gcG9zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVnJGNhY2hlZFBvc0RldGFpbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgICB9XG5cbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICB2YXIgaSA9IDE7XG5cbiAgICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcbiAgICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsO1xuXG4gICAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSAhPT0gbnVsbCA/IG1lc3NhZ2UgOiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGZvdW5kLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBvc0RldGFpbHMubGluZSxcbiAgICAgICAgcG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RhcnQoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtZXJnZWQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMxO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMyhzMSwgczUpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0KHMxKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlb3JkZXJlZCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwLCBzMTEsIHMxMiwgczEzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICBzMSA9IHBlZyRjNTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckYzE7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRjNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGM5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMShzMywgczcsIHMxMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXJlZCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBbXTtcbiAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXIoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxMyhzMSwgczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VzdHJlYW0oKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzE0KHMxKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyZWFtKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgczEgPSBwZWckYzE1O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgczMgPSBwZWckYzE3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzE5KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2NCkge1xuICAgICAgICAgIHMxID0gcGVnJGMyMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VuYW1lKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMyMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlZXZlbnRUeXBlKCk7XG4gICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNChzMiwgczQpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlbWFya1R5cGUoKTtcbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckYzIyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VldmVudFR5cGUoKTtcbiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzI1KHMxLCBzMyk7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWNzcygpO1xuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgICBzMiA9IHBlZyRjMjI7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlZXZlbnRUeXBlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNihzMSwgczMpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWV2ZW50VHlwZSgpO1xuICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjcoczEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VuYW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyOChzMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW1hcmtUeXBlKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGMyOSkge1xuICAgICAgICBzMCA9IHBlZyRjMjk7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMzMSkge1xuICAgICAgICAgIHMwID0gcGVnJGMzMTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMzMpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGMzMztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGMzNSkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMzU7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGMzNykge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMzNztcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzgpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMzkpIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMzOTtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0MCk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGM0MSkge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDE7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Mik7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0Mykge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0MztcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDQpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Nik7IH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWV2ZW50VHlwZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNDkpIHtcbiAgICAgICAgczAgPSBwZWckYzQ5O1xuICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTApOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjNTEpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjNTE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzUzKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjNTM7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTQpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNTUpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzU1O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNTcpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTc7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzU5KSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTk7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNjEpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYxO1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjIpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjM7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY0KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM2NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nik7IH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM2Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2OCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM2OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM3MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3Mik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzczO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzc0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM3NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM3NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzc2KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzc3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNzc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzgpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNzkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzc5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXIoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWV4cHIoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgczMgPSBwZWckYzc7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM4MShzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbmFtZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzgyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODMpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjODIudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgzKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM4NChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY3NzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjODUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Nik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGM4NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODYpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzg3KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VleHByKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjODgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4OSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGM4OC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODkpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzkwKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzZXAoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBzMCA9IFtdO1xuICAgICAgaWYgKHBlZyRjOTEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5Mik7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMC5wdXNoKHMxKTtcbiAgICAgICAgaWYgKHBlZyRjOTEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOTIpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxuICB9O1xufSkoKTsiLCJ2YXIgZXhwciA9IHJlcXVpcmUoJ3ZlZ2EtZXhwcmVzc2lvbicpLFxuICAgIGFyZ3MgPSBbJ2RhdHVtJywgJ2V2ZW50JywgJ3NpZ25hbHMnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHByLmNvbXBpbGVyKGFyZ3MsIHtcbiAgaWRXaGl0ZUxpc3Q6IGFyZ3MsXG4gIGZpZWxkVmFyOiAgICBhcmdzWzBdLFxuICBnbG9iYWxWYXI6ICAgYXJnc1syXSxcbiAgZnVuY3Rpb25zOiAgIGZ1bmN0aW9uKGNvZGVnZW4pIHtcbiAgICB2YXIgZm4gPSBleHByLmZ1bmN0aW9ucyhjb2RlZ2VuKTtcbiAgICBmbi5ldmVudEl0ZW0gPSBmdW5jdGlvbigpIHsgcmV0dXJuICdldmVudC52Zy5pdGVtJzsgfTtcbiAgICBmbi5ldmVudEdyb3VwID0gJ2V2ZW50LnZnLmdldEdyb3VwJztcbiAgICBmbi5ldmVudFggPSAnZXZlbnQudmcuZ2V0WCc7XG4gICAgZm4uZXZlbnRZID0gJ2V2ZW50LnZnLmdldFknO1xuICAgIGZuLm9wZW4gPSAnd2luZG93Lm9wZW4nO1xuICAgIHJldHVybiBmbjtcbiAgfVxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF4ZXM6IHJlcXVpcmUoJy4vYXhlcycpLFxuICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuL2JhY2tncm91bmQnKSxcbiAgZGF0YTogcmVxdWlyZSgnLi9kYXRhJyksXG4gIGV2ZW50czogcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgZXhwcjogcmVxdWlyZSgnLi9leHByJyksXG4gIGxlZ2VuZHM6IHJlcXVpcmUoJy4vbGVnZW5kcycpLFxuICBtYXJrOiByZXF1aXJlKCcuL21hcmsnKSxcbiAgbWFya3M6IHJlcXVpcmUoJy4vbWFya3MnKSxcbiAgbW9kaWZ5OiByZXF1aXJlKCcuL21vZGlmeScpLFxuICBwYWRkaW5nOiByZXF1aXJlKCcuL3BhZGRpbmcnKSxcbiAgcHJlZGljYXRlczogcmVxdWlyZSgnLi9wcmVkaWNhdGVzJyksXG4gIHByb3BlcnRpZXM6IHJlcXVpcmUoJy4vcHJvcGVydGllcycpLFxuICBzaWduYWxzOiByZXF1aXJlKCcuL3NpZ25hbHMnKSxcbiAgc3BlYzogcmVxdWlyZSgnLi9zcGVjJyksXG4gIHN0cmVhbXM6IHJlcXVpcmUoJy4vc3RyZWFtcycpLFxuICB0cmFuc2Zvcm1zOiByZXF1aXJlKCcuL3RyYW5zZm9ybXMnKVxufTsiLCJ2YXIgbGduZCA9IHJlcXVpcmUoJy4uL3NjZW5lL2xlZ2VuZCcpO1xuXG5mdW5jdGlvbiBwYXJzZUxlZ2VuZHMobW9kZWwsIHNwZWMsIGxlZ2VuZHMsIGdyb3VwKSB7XG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICBsZWdlbmRzW2luZGV4XSA9IGxlZ2VuZHNbaW5kZXhdIHx8IGxnbmQobW9kZWwpO1xuICAgIHBhcnNlTGVnZW5kKGRlZiwgaW5kZXgsIGxlZ2VuZHNbaW5kZXhdLCBncm91cCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxlZ2VuZChkZWYsIGluZGV4LCBsZWdlbmQsIGdyb3VwKSB7XG4gIC8vIGxlZ2VuZCBzY2FsZXNcbiAgbGVnZW5kLnNpemUgIChkZWYuc2l6ZSAgID8gZ3JvdXAuc2NhbGUoZGVmLnNpemUpICAgOiBudWxsKTtcbiAgbGVnZW5kLnNoYXBlIChkZWYuc2hhcGUgID8gZ3JvdXAuc2NhbGUoZGVmLnNoYXBlKSAgOiBudWxsKTtcbiAgbGVnZW5kLmZpbGwgIChkZWYuZmlsbCAgID8gZ3JvdXAuc2NhbGUoZGVmLmZpbGwpICAgOiBudWxsKTtcbiAgbGVnZW5kLnN0cm9rZShkZWYuc3Ryb2tlID8gZ3JvdXAuc2NhbGUoZGVmLnN0cm9rZSkgOiBudWxsKTtcblxuICAvLyBsZWdlbmQgb3JpZW50YXRpb25cbiAgaWYgKGRlZi5vcmllbnQpIGxlZ2VuZC5vcmllbnQoZGVmLm9yaWVudCk7XG5cbiAgLy8gbGVnZW5kIG9mZnNldFxuICBpZiAoZGVmLm9mZnNldCAhPSBudWxsKSBsZWdlbmQub2Zmc2V0KGRlZi5vZmZzZXQpO1xuXG4gIC8vIGxlZ2VuZCB0aXRsZVxuICBsZWdlbmQudGl0bGUoZGVmLnRpdGxlIHx8IG51bGwpO1xuXG4gIC8vIGxlZ2VuZCB2YWx1ZXNcbiAgbGVnZW5kLnZhbHVlcyhkZWYudmFsdWVzIHx8IG51bGwpO1xuXG4gIC8vIGxlZ2VuZCBsYWJlbCBmb3JtYXR0aW5nXG4gIGxlZ2VuZC5mb3JtYXQoZGVmLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZGVmLmZvcm1hdCA6IG51bGwpO1xuXG4gIC8vIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHAgPSBkZWYucHJvcGVydGllcztcbiAgbGVnZW5kLnRpdGxlUHJvcGVydGllcyhwICYmIHAudGl0bGUgfHwge30pO1xuICBsZWdlbmQubGFiZWxQcm9wZXJ0aWVzKHAgJiYgcC5sYWJlbHMgfHwge30pO1xuICBsZWdlbmQubGVnZW5kUHJvcGVydGllcyhwICYmIHAubGVnZW5kIHx8IHt9KTtcbiAgbGVnZW5kLnN5bWJvbFByb3BlcnRpZXMocCAmJiBwLnN5bWJvbHMgfHwge30pO1xuICBsZWdlbmQuZ3JhZGllbnRQcm9wZXJ0aWVzKHAgJiYgcC5ncmFkaWVudCB8fCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VMZWdlbmRzOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBwYXJzZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMnKTtcblxuZnVuY3Rpb24gcGFyc2VNYXJrKG1vZGVsLCBtYXJrKSB7XG4gIHZhciBwcm9wcyA9IG1hcmsucHJvcGVydGllcyxcbiAgICAgIGdyb3VwID0gbWFyay5tYXJrcztcblxuICAvLyBwYXJzZSBtYXJrIHByb3BlcnR5IGRlZmluaXRpb25zXG4gIGRsLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHByb3BzW2tdID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHByb3BzW2tdKTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgZGVsYXkgZnVuY3Rpb25cbiAgaWYgKG1hcmsuZGVsYXkpIHtcbiAgICBtYXJrLmRlbGF5ID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHtkZWxheTogbWFyay5kZWxheX0pO1xuICB9XG5cbiAgLy8gcmVjdXJzZSBpZiBncm91cCB0eXBlXG4gIGlmIChncm91cCkge1xuICAgIG1hcmsubWFya3MgPSBncm91cC5tYXAoZnVuY3Rpb24oZykgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBnKTsgfSk7XG4gIH1cbiAgICBcbiAgcmV0dXJuIG1hcms7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VNYXJrOyIsInZhciBwYXJzZU1hcmsgPSByZXF1aXJlKCcuL21hcmsnKTtcblxuZnVuY3Rpb24gcGFyc2VSb290TWFyayhtb2RlbCwgc3BlYywgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgc2NhbGVzOiBzcGVjLnNjYWxlcyB8fCBbXSxcbiAgICBheGVzOiBzcGVjLmF4ZXMgfHwgW10sXG4gICAgbGVnZW5kczogc3BlYy5sZWdlbmRzIHx8IFtdLFxuICAgIG1hcmtzOiAoc3BlYy5tYXJrcyB8fCBbXSkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VSb290TWFyazsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgTm9kZSA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcztcblxudmFyIFR5cGVzID0ge1xuICBJTlNFUlQ6IFwiaW5zZXJ0XCIsXG4gIFJFTU9WRTogXCJyZW1vdmVcIixcbiAgVE9HR0xFOiBcInRvZ2dsZVwiLFxuICBDTEVBUjogIFwiY2xlYXJcIlxufTtcblxudmFyIEVNUFRZID0gW107XG5cbnZhciBmaWx0ZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIHNyYywgZGVzdCkge1xuICBmb3IodmFyIGkgPSBzcmMubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHNyY1tpXVtmaWVsZF0gPT0gdmFsdWUpXG4gICAgICBkZXN0LnB1c2guYXBwbHkoZGVzdCwgc3JjLnNwbGljZShpLCAxKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZ5KG1vZGVsLCBkZWYsIGRzKSB7XG4gIHZhciBzaWduYWwgPSBkZWYuc2lnbmFsID8gZGwuZmllbGQoZGVmLnNpZ25hbCkgOiBudWxsLCBcbiAgICAgIHNpZ25hbE5hbWUgPSBzaWduYWwgPyBzaWduYWxbMF0gOiBudWxsLFxuICAgICAgcHJlZGljYXRlID0gZGVmLnByZWRpY2F0ZSA/IG1vZGVsLnByZWRpY2F0ZShkZWYucHJlZGljYXRlLm5hbWUgfHwgZGVmLnByZWRpY2F0ZSkgOiBudWxsLFxuICAgICAgcmVldmFsID0gKHByZWRpY2F0ZSA9PT0gbnVsbCksXG4gICAgICBub2RlID0gbmV3IE5vZGUobW9kZWwpLnJvdXRlcihkZWYudHlwZSA9PT0gVHlwZXMuQ0xFQVIpO1xuXG4gIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChwcmVkaWNhdGUgIT09IG51bGwpIHsgIC8vIFRPRE86IHByZWRpY2F0ZSBhcmdzXG4gICAgICB2YXIgZGIgPSBtb2RlbC52YWx1ZXMoRGVwcy5EQVRBLCBwcmVkaWNhdGUuZGF0YSB8fCBFTVBUWSksXG4gICAgICAgICAgc2cgPSBtb2RlbC52YWx1ZXMoRGVwcy5TSUdOQUxTLCBwcmVkaWNhdGUuc2lnbmFscyB8fCBFTVBUWSk7XG4gICAgICByZWV2YWwgPSBwcmVkaWNhdGUuY2FsbChwcmVkaWNhdGUsIHt9LCBkYiwgc2csIG1vZGVsLl9wcmVkaWNhdGVzKTtcbiAgICB9XG5cbiAgICBsb2cuZGVidWcoaW5wdXQsIFtkZWYudHlwZStcImluZ1wiLCByZWV2YWxdKTtcbiAgICBpZiAoIXJlZXZhbCkgcmV0dXJuIGlucHV0O1xuXG4gICAgdmFyIGRhdHVtID0ge30sIFxuICAgICAgICB2YWx1ZSA9IHNpZ25hbCA/IG1vZGVsLnNpZ25hbFJlZihkZWYuc2lnbmFsKSA6IG51bGwsXG4gICAgICAgIGQgPSBtb2RlbC5kYXRhKGRzLm5hbWUpLFxuICAgICAgICB0ID0gbnVsbDtcblxuICAgIGRhdHVtW2RlZi5maWVsZF0gPSB2YWx1ZTtcblxuICAgIC8vIFdlIGhhdmUgdG8gbW9kaWZ5IGRzLl9kYXRhIHNvIHRoYXQgc3Vic2VxdWVudCBwdWxzZXMgY29udGFpblxuICAgIC8vIG91ciBkeW5hbWljIGRhdGEuIFcvbyBtb2RpZnlpbmcgZHMuX2RhdGEsIG9ubHkgdGhlIG91dHB1dFxuICAgIC8vIGNvbGxlY3RvciB3aWxsIGNvbnRhaW4gZHluYW1pYyB0dXBsZXMuIFxuICAgIGlmIChkZWYudHlwZSA9PT0gVHlwZXMuSU5TRVJUKSB7XG4gICAgICB0ID0gVHVwbGUuaW5nZXN0KGRhdHVtKTtcbiAgICAgIGlucHV0LmFkZC5wdXNoKHQpO1xuICAgICAgZC5fZGF0YS5wdXNoKHQpO1xuICAgIH0gZWxzZSBpZiAoZGVmLnR5cGUgPT09IFR5cGVzLlJFTU9WRSkge1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LmFkZCwgaW5wdXQucmVtKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5tb2QsIGlucHV0LnJlbSk7XG4gICAgICBkLl9kYXRhID0gZC5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4geFtkZWYuZmllbGRdICE9PSB2YWx1ZTsgfSk7XG4gICAgfSBlbHNlIGlmIChkZWYudHlwZSA9PT0gVHlwZXMuVE9HR0xFKSB7XG4gICAgICB2YXIgYWRkID0gW10sIHJlbSA9IFtdO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LnJlbSwgYWRkKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIHJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCByZW0pO1xuICAgICAgaWYgKCEoYWRkLmxlbmd0aCB8fCByZW0ubGVuZ3RoKSkgYWRkLnB1c2goVHVwbGUuaW5nZXN0KGRhdHVtKSk7XG5cbiAgICAgIGlucHV0LmFkZC5wdXNoLmFwcGx5KGlucHV0LmFkZCwgYWRkKTtcbiAgICAgIGQuX2RhdGEucHVzaC5hcHBseShkLl9kYXRhLCBhZGQpO1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCByZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbS5pbmRleE9mKHgpID09PSAtMTsgfSk7XG4gICAgfSBlbHNlIGlmIChkZWYudHlwZSA9PT0gVHlwZXMuQ0xFQVIpIHtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQuYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQubW9kKTtcbiAgICAgIGlucHV0LmFkZCA9IFtdO1xuICAgICAgaW5wdXQubW9kID0gW107XG4gICAgICBkLl9kYXRhICA9IFtdO1xuICAgIH0gXG5cbiAgICBpbnB1dC5maWVsZHNbZGVmLmZpZWxkXSA9IDE7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIGlmIChzaWduYWxOYW1lKSBub2RlLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCBzaWduYWxOYW1lKTtcbiAgXG4gIGlmIChwcmVkaWNhdGUpIHtcbiAgICBub2RlLmRlcGVuZGVuY3koRGVwcy5EQVRBLCBwcmVkaWNhdGUuZGF0YSk7XG4gICAgbm9kZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgcHJlZGljYXRlLnNpZ25hbHMpO1xuICB9XG4gIFxuICByZXR1cm4gbm9kZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU1vZGlmeTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWQpIHtcbiAgaWYgKHBhZCA9PSBudWxsKSByZXR1cm4gXCJhdXRvXCI7XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHJldHVybiBwYWQ9PT1cInN0cmljdFwiID8gXCJzdHJpY3RcIiA6IFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc09iamVjdChwYWQpKSByZXR1cm4gcGFkO1xuICB2YXIgcCA9IGRsLmlzTnVtYmVyKHBhZCkgPyBwYWQgOiAyMDtcbiAgcmV0dXJuIHt0b3A6cCwgbGVmdDpwLCByaWdodDpwLCBib3R0b206cH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VQYWRkaW5nOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxudmFyIHR5cGVzID0ge1xuICAnPSc6ICAgcGFyc2VDb21wYXJhdG9yLFxuICAnPT0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAnIT0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAnPic6ICAgcGFyc2VDb21wYXJhdG9yLFxuICAnPj0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAnPCc6ICAgcGFyc2VDb21wYXJhdG9yLFxuICAnPD0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAnYW5kJzogcGFyc2VMb2dpY2FsLFxuICAnJiYnOiAgcGFyc2VMb2dpY2FsLFxuICAnb3InOiAgcGFyc2VMb2dpY2FsLFxuICAnfHwnOiAgcGFyc2VMb2dpY2FsLFxuICAnaW4nOiAgcGFyc2VJblxufTtcblxudmFyIG51bGxTY2FsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbm51bGxTY2FsZS5pbnZlcnQgPSBudWxsU2NhbGU7XG5cbmZ1bmN0aW9uIHBhcnNlUHJlZGljYXRlcyhtb2RlbCwgc3BlYykge1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgdmFyIHBhcnNlID0gdHlwZXNbcy50eXBlXShtb2RlbCwgcyk7XG4gICAgXG4gICAgLyoganNoaW50IGV2aWw6dHJ1ZSAqL1xuICAgIHZhciBwcmVkICA9IEZ1bmN0aW9uKFwiYXJnc1wiLCBcImRiXCIsIFwic2lnbmFsc1wiLCBcInByZWRpY2F0ZXNcIiwgcGFyc2UuY29kZSk7XG4gICAgcHJlZC5yb290ID0gZnVuY3Rpb24oKSB7IHJldHVybiBtb2RlbC5zY2VuZSgpLml0ZW1zWzBdOyB9OyAvLyBGb3IgZ2xvYmFsIHNjYWxlc1xuICAgIHByZWQubnVsbFNjYWxlID0gbnVsbFNjYWxlO1xuICAgIHByZWQuaXNGdW5jdGlvbiA9IGRsLmlzRnVuY3Rpb247XG4gICAgcHJlZC5zaWduYWxzID0gcGFyc2Uuc2lnbmFscztcbiAgICBwcmVkLmRhdGEgPSBwYXJzZS5kYXRhO1xuXG4gICAgbW9kZWwucHJlZGljYXRlKHMubmFtZSwgcHJlZCk7XG4gIH0pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpZ25hbChzaWduYWwsIHNpZ25hbHMpIHtcbiAgdmFyIHMgPSBkbC5maWVsZChzaWduYWwpLFxuICAgICAgY29kZSA9IFwic2lnbmFsc1tcIitzLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjtcbiAgc2lnbmFsc1tzWzBdXSA9IDE7XG4gIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9wZXJhbmRzKG1vZGVsLCBvcGVyYW5kcykge1xuICB2YXIgZGVjbCA9IFtdLCBkZWZzID0gW10sXG4gICAgICBzaWduYWxzID0ge30sIGRiID0ge307XG5cbiAgZnVuY3Rpb24gc2V0U2lnbmFsKHMpIHsgc2lnbmFsc1tzXSA9IDE7IH1cbiAgZnVuY3Rpb24gc2V0RGF0YShkKSB7IGRiW2RdID0gMTsgfVxuXG4gIGRsLmFycmF5KG9wZXJhbmRzKS5mb3JFYWNoKGZ1bmN0aW9uKG8sIGkpIHtcbiAgICB2YXIgbmFtZSA9IFwib1wiICsgaSxcbiAgICAgICAgZGVmID0gXCJcIjtcblxuICAgIGlmIChvLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZiA9IGRsLnN0cihvLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG8uYXJnKSB7XG4gICAgICBkZWYgPSBcImFyZ3NbXCIrZGwuc3RyKG8uYXJnKStcIl1cIjtcbiAgICB9IGVsc2UgaWYgKG8uc2lnbmFsKSB7XG4gICAgICBkZWYgPSBwYXJzZVNpZ25hbChvLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgfSBlbHNlIGlmIChvLnByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlZiA9IG8ucHJlZGljYXRlLFxuICAgICAgICAgIHByZWROYW1lID0gcmVmICYmIChyZWYubmFtZSB8fCByZWYpLFxuICAgICAgICAgIHByZWQgPSBtb2RlbC5wcmVkaWNhdGUocHJlZE5hbWUpLFxuICAgICAgICAgIHAgPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKHByZWROYW1lKStcIl1cIjtcblxuICAgICAgcHJlZC5zaWduYWxzLmZvckVhY2goc2V0U2lnbmFsKTtcbiAgICAgIHByZWQuZGF0YS5mb3JFYWNoKHNldERhdGEpO1xuXG4gICAgICBpZiAoZGwuaXNPYmplY3QocmVmKSkge1xuICAgICAgICBkbC5rZXlzKHJlZikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgaWYgKGsgPT09IFwibmFtZVwiKSByZXR1cm47XG4gICAgICAgICAgdmFyIGkgPSByZWZba107XG4gICAgICAgICAgZGVmICs9IFwiYXJnc1tcIitkbC5zdHIoaykrXCJdID0gXCI7XG4gICAgICAgICAgaWYgKGkuc2lnbmFsKSB7XG4gICAgICAgICAgICBkZWYgKz0gcGFyc2VTaWduYWwoaS5zaWduYWwsIHNpZ25hbHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaS5hcmcpIHtcbiAgICAgICAgICAgIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGkuYXJnKStcIl1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmICs9IFwiLCBcIjtcbiAgICAgICAgfSk7ICBcbiAgICAgIH0gXG5cbiAgICAgIGRlZiArPSBwK1wiLmNhbGwoXCIrcCtcIiwgYXJncywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpXCI7XG4gICAgfVxuXG4gICAgZGVjbC5wdXNoKG5hbWUpO1xuICAgIGRlZnMucHVzaChuYW1lK1wiPShcIitkZWYrXCIpXCIpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGNvZGU6IFwidmFyIFwiICsgZGVjbC5qb2luKFwiLCBcIikgKyBcIjtcXG5cIiArIGRlZnMuam9pbihcIjtcXG5cIikgKyBcIjtcXG5cIixcbiAgICBzaWduYWxzOiBkbC5rZXlzKHNpZ25hbHMpLFxuICAgIGRhdGE6IGRsLmtleXMoZGIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvcihtb2RlbCwgc3BlYykge1xuICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhtb2RlbCwgc3BlYy5vcGVyYW5kcyk7XG4gIGlmIChzcGVjLnR5cGUgPT09ICc9Jykgc3BlYy50eXBlID0gJz09JztcblxuICBvcHMuY29kZSArPSBcIm8wID0gbzAgaW5zdGFuY2VvZiBEYXRlID8gbzAuZ2V0VGltZSgpIDogbzA7XFxuXCIgK1xuICAgIFwibzEgPSBvMSBpbnN0YW5jZW9mIERhdGUgPyBvMS5nZXRUaW1lKCkgOiBvMTtcXG5cIjtcblxuICByZXR1cm4ge1xuICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBbXCJvMFwiLCBcIm8xXCJdLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLFxuICAgIGRhdGE6IG9wcy5kYXRhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9naWNhbChtb2RlbCwgc3BlYykge1xuICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhtb2RlbCwgc3BlYy5vcGVyYW5kcyksXG4gICAgICBvID0gW10sIGkgPSAwLCBsZW4gPSBzcGVjLm9wZXJhbmRzLmxlbmd0aDtcblxuICB3aGlsZSAoby5wdXNoKFwib1wiK2krKykgPCBsZW4pO1xuICBpZiAoc3BlYy50eXBlID09PSAnYW5kJykgc3BlYy50eXBlID0gJyYmJztcbiAgZWxzZSBpZiAoc3BlYy50eXBlID09PSAnb3InKSBzcGVjLnR5cGUgPSAnfHwnO1xuXG4gIHJldHVybiB7XG4gICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIG8uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgc2lnbmFsczogb3BzLnNpZ25hbHMsXG4gICAgZGF0YTogb3BzLmRhdGFcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJbihtb2RlbCwgc3BlYykge1xuICB2YXIgbyA9IFtzcGVjLml0ZW1dLCBjb2RlID0gXCJcIjtcbiAgaWYgKHNwZWMucmFuZ2UpIG8ucHVzaC5hcHBseShvLCBzcGVjLnJhbmdlKTtcbiAgaWYgKHNwZWMuc2NhbGUpIHtcbiAgICBjb2RlID0gcGFyc2VTY2FsZShzcGVjLnNjYWxlLCBvKTtcbiAgfVxuXG4gIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKG1vZGVsLCBvKTtcbiAgY29kZSA9IG9wcy5jb2RlICsgY29kZSArIFwiXFxuICB2YXIgb3JkU2V0ID0gbnVsbDtcXG5cIjtcblxuICBpZiAoc3BlYy5kYXRhKSB7XG4gICAgdmFyIGZpZWxkID0gZGwuZmllbGQoc3BlYy5maWVsZCkubWFwKGRsLnN0cik7XG4gICAgY29kZSArPSBcInZhciB3aGVyZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbXCIrZmllbGQuam9pbihcIl1bXCIpK1wiXSA9PSBvMCB9O1xcblwiO1xuICAgIGNvZGUgKz0gXCJyZXR1cm4gZGJbXCIrZGwuc3RyKHNwZWMuZGF0YSkrXCJdLmZpbHRlcih3aGVyZSkubGVuZ3RoID4gMDtcIjtcbiAgfSBlbHNlIGlmIChzcGVjLnJhbmdlKSB7XG4gICAgLy8gVE9ETzogaW5jbHVzaXZlL2V4Y2x1c2l2ZSByYW5nZT9cbiAgICBpZiAoc3BlYy5zY2FsZSkge1xuICAgICAgY29kZSArPSBcImlmIChzY2FsZS5sZW5ndGggPT0gMikge1xcblwiICsgLy8gaW52ZXJ0aW5nIG9yZGluYWwgc2NhbGVzXG4gICAgICAgIFwiICBvcmRTZXQgPSBzY2FsZShvMSwgbzIpO1xcblwiICtcbiAgICAgICAgXCJ9IGVsc2Uge1xcblwiICtcbiAgICAgICAgXCIgIG8xID0gc2NhbGUobzEpO1xcbm8yID0gc2NhbGUobzIpO1xcblwiICtcbiAgICAgICAgXCJ9XCI7XG4gICAgfVxuXG4gICAgY29kZSArPSBcInJldHVybiBvcmRTZXQgIT09IG51bGwgPyBvcmRTZXQuaW5kZXhPZihvMCkgIT09IC0xIDpcXG5cIiArIFxuICAgICAgXCIgIG8xIDwgbzIgPyBvMSA8PSBvMCAmJiBvMCA8PSBvMiA6IG8yIDw9IG8wICYmIG8wIDw9IG8xO1wiO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBjb2RlLCBcbiAgICBzaWduYWxzOiBvcHMuc2lnbmFscywgXG4gICAgZGF0YTogb3BzLmRhdGEuY29uY2F0KHNwZWMuZGF0YSA/IFtzcGVjLmRhdGFdIDogW10pXG4gIH07XG59XG5cbi8vIFBvcHVsYXRlIG9wcyBzdWNoIHRoYXQgdWx0aW1hdGUgc2NhbGUvaW52ZXJzaW9uIGZ1bmN0aW9uIHdpbGwgYmUgaW4gYHNjYWxlYCB2YXIuIFxuZnVuY3Rpb24gcGFyc2VTY2FsZShzcGVjLCBvcHMpIHtcbiAgdmFyIGNvZGUgPSBcInZhciBzY2FsZSA9IFwiLCBcbiAgICAgIGlkeCAgPSBvcHMubGVuZ3RoO1xuXG4gIGlmIChkbC5pc1N0cmluZyhzcGVjKSkge1xuICAgIG9wcy5wdXNoKHsgdmFsdWU6IHNwZWMgfSk7XG4gICAgY29kZSArPSBcInRoaXMucm9vdCgpLnNjYWxlKG9cIitpZHgrXCIpXCI7XG4gIH0gZWxzZSBpZiAoc3BlYy5hcmcpIHsgIC8vIFNjYWxlIGZ1bmN0aW9uIGlzIGJlaW5nIHBhc3NlZCBhcyBhbiBhcmdcbiAgICBvcHMucHVzaChzcGVjKTtcbiAgICBjb2RlICs9IFwib1wiK2lkeDtcbiAgfSBlbHNlIGlmIChzcGVjLm5hbWUpIHsgLy8gRnVsbCBzY2FsZSBwYXJhbWV0ZXIge25hbWU6IC4ufVxuICAgIG9wcy5wdXNoKGRsLmlzU3RyaW5nKHNwZWMubmFtZSkgPyB7dmFsdWU6IHNwZWMubmFtZX0gOiBzcGVjLm5hbWUpO1xuICAgIGNvZGUgKz0gXCIodGhpcy5pc0Z1bmN0aW9uKG9cIitpZHgrXCIpID8gb1wiK2lkeCtcIiA6IFwiO1xuICAgIGlmIChzcGVjLnNjb3BlKSB7XG4gICAgICBvcHMucHVzaChzcGVjLnNjb3BlKTtcbiAgICAgIGNvZGUgKz0gXCIoKG9cIisoaWR4KzEpK1wiLnNjYWxlIHx8IHRoaXMucm9vdCgpLnNjYWxlKShvXCIraWR4K1wiKSB8fCB0aGlzLm51bGxTY2FsZSlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcInRoaXMucm9vdCgpLnNjYWxlKG9cIitpZHgrXCIpXCI7XG4gICAgfVxuICAgIGNvZGUgKz0gXCIpXCI7XG4gIH1cblxuICBpZiAoc3BlYy5pbnZlcnQgPT09IHRydWUpIHsgIC8vIEFsbG93IHNwZWMuaW52ZXJ0LmFyZz9cbiAgICBjb2RlICs9IFwiLmludmVydFwiO1xuICB9XG5cbiAgcmV0dXJuIGNvZGUrXCI7XFxuXCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VQcmVkaWNhdGVzOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlO1xuXG52YXIgREVQUyA9IFtcInNpZ25hbHNcIiwgXCJzY2FsZXNcIiwgXCJkYXRhXCIsIFwiZmllbGRzXCJdO1xuXG5mdW5jdGlvbiBwcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLCBzcGVjKSB7XG4gIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcoKSxcbiAgICAgIGNvZGUgPSBcIlwiLFxuICAgICAgbmFtZXMgPSBkbC5rZXlzKHNwZWMpLFxuICAgICAgaSwgbGVuLCBuYW1lLCByZWYsIHZhcnMgPSB7fSwgXG4gICAgICBkZXBzID0ge1xuICAgICAgICBzaWduYWxzOiB7fSxcbiAgICAgICAgc2NhbGVzOiAge30sXG4gICAgICAgIGRhdGE6ICAgIHt9LFxuICAgICAgICBmaWVsZHM6ICB7fSxcbiAgICAgICAgbmVzdGVkOiAgW10sXG4gICAgICAgIF9uUmVmczogIHt9LCAgLy8gVGVtcCBzdGFzaCB0byBkZS1kdXBlIG5lc3RlZCByZWZzLlxuICAgICAgICByZWZsb3c6ICBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICBjb2RlICs9IFwidmFyIG8gPSB0cmFucyA/IHt9IDogaXRlbSwgZD0wLCBzZXQ9dGhpcy50cGwuc2V0LCB0bXBsPXNpZ25hbHN8fHt9LCB0O1xcblwiICtcbiAgICAgICAgICAvLyBTdGFzaCBmb3IgZGwudGVtcGxhdGVcbiAgICAgICAgICBcInRtcGwuZGF0dW0gID0gaXRlbS5kYXR1bTtcXG5cIiArIFxuICAgICAgICAgIFwidG1wbC5ncm91cCAgPSBncm91cDtcXG5cIiArIFxuICAgICAgICAgIFwidG1wbC5wYXJlbnQgPSBncm91cC5kYXR1bTtcXG5cIjtcblxuICBmdW5jdGlvbiBoYW5kbGVEZXAocCkge1xuICAgIGlmIChyZWZbcF0gPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBrID0gZGwuYXJyYXkocmVmW3BdKSwgaSwgbjtcbiAgICBmb3IgKGk9MCwgbj1rLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGRlcHNbcF1ba1tpXV0gPSAxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5lc3RlZFJlZnMocikge1xuICAgIHZhciBrID0gKHIucGFyZW50ID8gXCJwYXJlbnRfXCIgOiBcImdyb3VwX1wiKStyLmxldmVsO1xuICAgIGRlcHMuX25SZWZzW2tdID0gcjtcbiAgfVxuXG4gIGZvciAoaT0wLCBsZW49bmFtZXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgcmVmID0gc3BlY1tuYW1lID0gbmFtZXNbaV1dO1xuICAgIGNvZGUgKz0gKGkgPiAwKSA/IFwiXFxuICBcIiA6IFwiICBcIjtcbiAgICBpZiAocmVmLnJ1bGUpIHtcbiAgICAgIHJlZiA9IHJ1bGUobW9kZWwsIG5hbWUsIHJlZi5ydWxlKTtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIFwiICsgcmVmLmNvZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHZhbHVlUmVmKGNvbmZpZywgbmFtZSwgcmVmKTtcbiAgICAgIGNvZGUgKz0gXCJkICs9IHNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1wiO1xuICAgIH1cblxuICAgIHZhcnNbbmFtZV0gPSB0cnVlO1xuICAgIERFUFMuZm9yRWFjaChoYW5kbGVEZXApO1xuICAgIGRlcHMucmVmbG93ID0gZGVwcy5yZWZsb3cgfHwgcmVmLnJlZmxvdztcbiAgICBpZiAocmVmLm5lc3RlZC5sZW5ndGgpIHJlZi5uZXN0ZWQuZm9yRWFjaChoYW5kbGVOZXN0ZWRSZWZzKTtcbiAgfVxuXG4gIC8vIElmIG5lc3RlZCByZWZlcmVuY2VzIGFyZSBwcmVzZW50LCBzb3J0IHRoZW0gYmFzZWQgb24gdGhlaXIgbGV2ZWxcbiAgLy8gdG8gc3BlZWQgdXAgZGV0ZXJtaW5hdGlvbiBvZiB3aGV0aGVyIGVuY29kZXJzIHNob3VsZCBiZSByZWV2YWwnZC5cbiAgZGwua2V5cyhkZXBzLl9uUmVmcykuZm9yRWFjaChmdW5jdGlvbihrKSB7IGRlcHMubmVzdGVkLnB1c2goZGVwcy5fblJlZnNba10pOyB9KTtcbiAgZGVwcy5uZXN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7IFxuICAgIGEgPSBhLmxldmVsO1xuICAgIGIgPSBiLmxldmVsO1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjsgXG4gIH0pO1xuXG4gIGlmICh2YXJzLngyKSB7XG4gICAgaWYgKHZhcnMueCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgaWYgKG8ueCA+IG8ueDIpIHsgXCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgICB0ID0gby54O1wiICtcbiAgICAgICAgICAgICAgXCJcXG4gICAgZCArPSBzZXQobywgJ3gnLCBvLngyKTtcIiArXG4gICAgICAgICAgICAgIFwiXFxuICAgIGQgKz0gc2V0KG8sICd4MicsIHQpOyBcIiArXG4gICAgICAgICAgICAgIFwiXFxuICB9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3dpZHRoJywgKG8ueDIgLSBvLngpKTtcIjtcbiAgICB9IGVsc2UgaWYgKHZhcnMud2lkdGgpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd4JywgKG8ueDIgLSBvLndpZHRoKSk7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd4Jywgby54Mik7XCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhcnMueGMpIHtcbiAgICBpZiAodmFycy53aWR0aCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3gnLCAoby54YyAtIG8ud2lkdGgvMikpO1wiIDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3gnLCBvLnhjKTtcIiA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhcnMueTIpIHtcbiAgICBpZiAodmFycy55KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby55ID4gby55MikgeyBcIiArXG4gICAgICAgICAgICAgIFwiXFxuICAgIHQgPSBvLnk7XCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgICBkICs9IHNldChvLCAneScsIG8ueTIpO1wiICtcbiAgICAgICAgICAgICAgXCJcXG4gICAgZCArPSBzZXQobywgJ3kyJywgdCk7XCIgK1xuICAgICAgICAgICAgICBcIlxcbiAgfTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICdoZWlnaHQnLCAoby55MiAtIG8ueSkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy5oZWlnaHQpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGQgKz0gc2V0KG8sICd5JywgKG8ueTIgLSBvLmhlaWdodCkpO1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAneScsIG8ueTIpO1wiO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YXJzLnljKSB7XG4gICAgaWYgKHZhcnMuaGVpZ2h0KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBkICs9IHNldChvLCAneScsIChvLnljIC0gby5oZWlnaHQvMikpO1wiIDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgZCArPSBzZXQobywgJ3knLCBvLnljKTtcIiA7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoaGFzUGF0aChtYXJrLCB2YXJzKSkgY29kZSArPSBcIlxcbiAgZCArPSAoaXRlbS50b3VjaCgpLCAxKTtcIjtcbiAgY29kZSArPSBcIlxcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcIjtcbiAgY29kZSArPSBcIlxcbiAgcmV0dXJuIGQgPiAwO1wiO1xuXG4gIHRyeSB7XG4gICAgLyoganNoaW50IGV2aWw6dHJ1ZSAqL1xuICAgIHZhciBlbmNvZGVyID0gRnVuY3Rpb24oJ2l0ZW0nLCAnZ3JvdXAnLCAndHJhbnMnLCAnZGInLCBcbiAgICAgICdzaWduYWxzJywgJ3ByZWRpY2F0ZXMnLCBjb2RlKTtcbiAgICBlbmNvZGVyLnRwbCAgPSBUdXBsZTtcbiAgICBlbmNvZGVyLnV0aWwgPSBkbDtcbiAgICBlbmNvZGVyLmQzICAgPSBkMzsgLy8gRm9yIGNvbG9yIHNwYWNlc1xuICAgIGRsLmV4dGVuZChlbmNvZGVyLCBkbC50ZW1wbGF0ZS5jb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiAgZW5jb2RlcixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoZGVwcy5zaWduYWxzKSxcbiAgICAgIHNjYWxlczogIGRsLmtleXMoZGVwcy5zY2FsZXMpLFxuICAgICAgZGF0YTogICAgZGwua2V5cyhkZXBzLmRhdGEpLFxuICAgICAgZmllbGRzOiAgZGwua2V5cyhkZXBzLmZpZWxkcyksXG4gICAgICBuZXN0ZWQ6ICBkZXBzLm5lc3RlZCxcbiAgICAgIHJlZmxvdzogIGRlcHMucmVmbG93XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihlKTtcbiAgICBsb2cubG9nKGNvZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlcGVuZGVuY2llcyhhLCBiKSB7XG4gIGlmICghZGwuaXNPYmplY3QoYSkpIHtcbiAgICBhID0ge3JlZmxvdzogZmFsc2UsIG5lc3RlZDogW119O1xuICAgIERFUFMuZm9yRWFjaChmdW5jdGlvbihkKSB7IGFbZF0gPSBbXTsgfSk7XG4gIH1cblxuICBpZiAoZGwuaXNPYmplY3QoYikpIHtcbiAgICBhLnJlZmxvdyA9IGEucmVmbG93IHx8IGIucmVmbG93O1xuICAgIGEubmVzdGVkLnB1c2guYXBwbHkoYS5uZXN0ZWQsIGIubmVzdGVkKTtcbiAgICBERVBTLmZvckVhY2goZnVuY3Rpb24oZCkgeyBhW2RdLnB1c2guYXBwbHkoYVtkXSwgYltkXSk7IH0pO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGhhc1BhdGgobWFyaywgdmFycykge1xuICByZXR1cm4gdmFycy5wYXRoIHx8XG4gICAgKChtYXJrPT09J2FyZWEnIHx8IG1hcms9PT0nbGluZScpICYmXG4gICAgICAodmFycy54IHx8IHZhcnMueDIgfHwgdmFycy53aWR0aCB8fFxuICAgICAgIHZhcnMueSB8fCB2YXJzLnkyIHx8IHZhcnMuaGVpZ2h0IHx8XG4gICAgICAgdmFycy50ZW5zaW9uIHx8IHZhcnMuaW50ZXJwb2xhdGUpKTtcbn1cblxuZnVuY3Rpb24gcnVsZShtb2RlbCwgbmFtZSwgcnVsZXMpIHtcbiAgdmFyIGNvbmZpZyAgPSBtb2RlbC5jb25maWcoKSxcbiAgICAgIGRlcHMgPSBkZXBlbmRlbmNpZXMoKSxcbiAgICAgIGlucHV0cyAgPSBbXSwgY29kZSA9ICcnO1xuXG4gIChydWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ociwgaSkge1xuICAgIHZhciBkZWYgPSByLnByZWRpY2F0ZSxcbiAgICAgICAgcHJlZE5hbWUgPSBkZWYgJiYgKGRlZi5uYW1lIHx8IGRlZiksXG4gICAgICAgIHByZWQgPSBtb2RlbC5wcmVkaWNhdGUocHJlZE5hbWUpLFxuICAgICAgICBwID0gJ3ByZWRpY2F0ZXNbJytkbC5zdHIocHJlZE5hbWUpKyddJyxcbiAgICAgICAgaW5wdXQgPSBbXSwgYXJncyA9IG5hbWUrJ19hcmcnK2ksXG4gICAgICAgIHJlZjtcblxuICAgIGlmIChkbC5pc09iamVjdChkZWYpKSB7XG4gICAgICBkbC5rZXlzKGRlZikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmIChrID09PSAnbmFtZScpIHJldHVybjtcbiAgICAgICAgdmFyIHJlZiA9IHZhbHVlUmVmKGNvbmZpZywgaSwgZGVmW2tdKTtcbiAgICAgICAgaW5wdXQucHVzaChkbC5zdHIoaykrJzogJytyZWYudmFsKTtcbiAgICAgICAgZGVwZW5kZW5jaWVzKGRlcHMsIHJlZik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZWYgPSB2YWx1ZVJlZihjb25maWcsIG5hbWUsIHIpO1xuICAgIGRlcGVuZGVuY2llcyhkZXBzLCByZWYpO1xuXG4gICAgaWYgKHByZWROYW1lKSB7XG4gICAgICBkZXBzLnNpZ25hbHMucHVzaC5hcHBseShkZXBzLnNpZ25hbHMsIHByZWQuc2lnbmFscyk7XG4gICAgICBkZXBzLmRhdGEucHVzaC5hcHBseShkZXBzLmRhdGEsIHByZWQuZGF0YSk7XG4gICAgICBpbnB1dHMucHVzaChhcmdzK1wiID0ge1xcbiAgICBcIitpbnB1dC5qb2luKFwiLFxcbiAgICBcIikrXCJcXG4gIH1cIik7XG4gICAgICBjb2RlICs9IFwiaWYgKFwiK3ArXCIuY2FsbChcIitwK1wiLFwiK2FyZ3MrXCIsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSkge1wiICtcbiAgICAgICAgXCJcXG4gICAgZCArPSBzZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcIjtcbiAgICAgIGNvZGUgKz0gcnVsZXNbaSsxXSA/IFwiXFxuICB9IGVsc2UgXCIgOiBcIiAgfVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwie1wiICsgXG4gICAgICAgIFwiXFxuICAgIGQgKz0gc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XCIrXG4gICAgICAgIFwiXFxuICB9XFxuXCI7XG4gICAgfVxuICB9KTtcblxuICBjb2RlID0gXCJ2YXIgXCIgKyBpbnB1dHMuam9pbihcIixcXG4gICAgICBcIikgKyBcIjtcXG4gIFwiICsgY29kZTtcbiAgcmV0dXJuIChkZXBzLmNvZGUgPSBjb2RlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVSZWYoY29uZmlnLCBuYW1lLCByZWYpIHtcbiAgaWYgKHJlZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBpZiAobmFtZT09PSdmaWxsJyB8fCBuYW1lPT09J3N0cm9rZScpIHtcbiAgICBpZiAocmVmLmMpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihjb25maWcsICdoY2wnLCByZWYuaCwgcmVmLmMsIHJlZi5sKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5oIHx8IHJlZi5zKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoY29uZmlnLCAnaHNsJywgcmVmLmgsIHJlZi5zLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYubCB8fCByZWYuYSkge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKGNvbmZpZywgJ2xhYicsIHJlZi5sLCByZWYuYSwgcmVmLmIpO1xuICAgIH0gZWxzZSBpZiAocmVmLnIgfHwgcmVmLmcgfHwgcmVmLmIpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihjb25maWcsICdyZ2InLCByZWYuciwgcmVmLmcsIHJlZi5iKTtcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHZhbHVlXG4gIHZhciB2YWwgPSBudWxsLCBzY2FsZSA9IG51bGwsIFxuICAgICAgZGVwcyA9IGRlcGVuZGVuY2llcygpLFxuICAgICAgc2dSZWYgPSBudWxsLCBmUmVmID0gbnVsbCwgc1JlZiA9IG51bGwsIHRtcGwgPSB7fTtcblxuICBpZiAocmVmLnRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBkbC50ZW1wbGF0ZS5zb3VyY2UocmVmLnRlbXBsYXRlLCAndG1wbCcsIHRtcGwpO1xuICAgIGRsLmtleXModG1wbCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgZiA9IGRsLmZpZWxkKGspLFxuICAgICAgICAgIGEgPSBmLnNoaWZ0KCk7XG4gICAgICBpZiAoYSA9PT0gJ3BhcmVudCcgfHwgYSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBkZXBzLm5lc3RlZC5wdXNoKHsgXG4gICAgICAgICAgcGFyZW50OiBhID09PSAncGFyZW50JyxcbiAgICAgICAgICBncm91cDogIGEgPT09ICdncm91cCcsIFxuICAgICAgICAgIGxldmVsOiAgMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gJ2RhdHVtJykge1xuICAgICAgICBkZXBzLmZpZWxkcy5wdXNoKGZbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwcy5zaWduYWxzLnB1c2goYSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVmLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBkbC5zdHIocmVmLnZhbHVlKTtcbiAgfVxuXG4gIGlmIChyZWYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZ1JlZiA9IGRsLmZpZWxkKHJlZi5zaWduYWwpO1xuICAgIHZhbCA9ICdzaWduYWxzWycrc2dSZWYubWFwKGRsLnN0cikuam9pbignXVsnKSsnXSc7IFxuICAgIGRlcHMuc2lnbmFscy5wdXNoKHNnUmVmLnNoaWZ0KCkpO1xuICB9XG5cbiAgaWYgKHJlZi5maWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmZpZWxkID0gZGwuaXNTdHJpbmcocmVmLmZpZWxkKSA/IHtkYXR1bTogcmVmLmZpZWxkfSA6IHJlZi5maWVsZDtcbiAgICBmUmVmID0gZmllbGRSZWYocmVmLmZpZWxkKTtcbiAgICB2YWwgID0gZlJlZi52YWw7XG4gICAgZGVwZW5kZW5jaWVzKGRlcHMsIGZSZWYpO1xuICB9XG5cbiAgaWYgKHJlZi5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc1JlZiAgPSBzY2FsZVJlZihyZWYuc2NhbGUpO1xuICAgIHNjYWxlID0gc1JlZi52YWw7XG4gICAgZGVwZW5kZW5jaWVzKGRlcHMsIHNSZWYpO1xuICAgIGRlcHMuc2NhbGVzLnB1c2gocmVmLnNjYWxlLm5hbWUgfHwgcmVmLnNjYWxlKTtcblxuICAgIC8vIHJ1biB0aHJvdWdoIHNjYWxlIGZ1bmN0aW9uIGlmIHZhbCBzcGVjaWZpZWQuXG4gICAgLy8gaWYgbm8gdmFsLCBzY2FsZSBmdW5jdGlvbiBpcyBwcmVkaWNhdGUgYXJnLlxuICAgIGlmICh2YWwgIT09IG51bGwgfHwgcmVmLmJhbmQgfHwgcmVmLm11bHQgfHwgcmVmLm9mZnNldCkge1xuICAgICAgdmFsID0gc2NhbGUgKyAocmVmLmJhbmQgPyAnLnJhbmdlQmFuZCgpJyA6IFxuICAgICAgICAnKCcrKHZhbCAhPT0gbnVsbCA/IHZhbCA6ICdpdGVtLmRhdHVtLmRhdGEnKSsnKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBzY2FsZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIG11bHRpcGx5LCBvZmZzZXQsIHJldHVybiB2YWx1ZVxuICB2YWwgPSAnKCcgKyAocmVmLm11bHQ/KGRsLm51bWJlcihyZWYubXVsdCkrJyAqICcpOicnKSArIHZhbCArICcpJyArXG4gICAgICAgIChyZWYub2Zmc2V0ID8gJyArICcgKyBkbC5udW1iZXIocmVmLm9mZnNldCkgOiAnJyk7XG5cbiAgLy8gQ29sbGF0ZSBkZXBlbmRlbmNpZXNcbiAgcmV0dXJuIChkZXBzLnZhbCA9IHZhbCwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yUmVmKGNvbmZpZywgdHlwZSwgeCwgeSwgeikge1xuICB2YXIgeHggPSB4ID8gdmFsdWVSZWYoY29uZmlnLCAnJywgeCkgOiBjb25maWcuY29sb3JbdHlwZV1bMF0sXG4gICAgICB5eSA9IHkgPyB2YWx1ZVJlZihjb25maWcsICcnLCB5KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsxXSxcbiAgICAgIHp6ID0geiA/IHZhbHVlUmVmKGNvbmZpZywgJycsIHopIDogY29uZmlnLmNvbG9yW3R5cGVdWzJdLFxuICAgICAgZGVwcyA9IGRlcGVuZGVuY2llcygpO1xuXG4gIFt4eCwgeXksIHp6XS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZGwuaXNBcnJheSkgcmV0dXJuO1xuICAgIGRlcGVuZGVuY2llcyhkZXBzLCB2KTtcbiAgfSk7XG5cbiAgdmFyIHZhbCA9ICcodGhpcy5kMy4nICsgdHlwZSArICcoJyArIFt4eC52YWwsIHl5LnZhbCwgenoudmFsXS5qb2luKCcsJykgKyAnKSArIFwiXCIpJztcbiAgcmV0dXJuIChkZXBzLnZhbCA9IHZhbCwgZGVwcyk7XG59XG5cbi8vIHtmaWVsZDoge2RhdHVtOiBcImZvb1wifSB9ICAtPiBpdGVtLmRhdHVtLmZvb1xuLy8ge2ZpZWxkOiB7Z3JvdXA6IFwiZm9vXCJ9IH0gIC0+IGdyb3VwLmZvb1xuLy8ge2ZpZWxkOiB7cGFyZW50OiBcImZvb1wifSB9IC0+IGdyb3VwLmRhdHVtLmZvb1xuZnVuY3Rpb24gZmllbGRSZWYocmVmKSB7XG4gIGlmIChkbC5pc1N0cmluZyhyZWYpKSB7XG4gICAgcmV0dXJuIHt2YWw6IGRsLmZpZWxkKHJlZikubWFwKGRsLnN0cikuam9pbignXVsnKX07XG4gIH0gXG5cbiAgLy8gUmVzb2x2ZSBuZXN0aW5nL3BhcmVudCBsb29rdXBzXG4gIHZhciBsID0gcmVmLmxldmVsIHx8IDEsXG4gICAgICBuZXN0ZWQgPSAocmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQpICYmIGwsXG4gICAgICBzY29wZSA9IG5lc3RlZCA/IEFycmF5KGwpLmpvaW4oJ2dyb3VwLm1hcmsuJykgOiAnJyxcbiAgICAgIHIgPSBmaWVsZFJlZihyZWYuZGF0dW0gfHwgcmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQgfHwgcmVmLnNpZ25hbCksXG4gICAgICB2YWwgPSByLnZhbCxcbiAgICAgIGRlcHMgPSBkZXBlbmRlbmNpZXMobnVsbCwgcik7XG5cbiAgaWYgKHJlZi5kYXR1bSkge1xuICAgIHZhbCA9ICdpdGVtLmRhdHVtWycrdmFsKyddJztcbiAgICBkZXBzLmZpZWxkcy5wdXNoKHJlZi5kYXR1bSk7XG4gIH0gZWxzZSBpZiAocmVmLmdyb3VwKSB7XG4gICAgdmFsID0gc2NvcGUrJ2dyb3VwWycrdmFsKyddJztcbiAgICBkZXBzLm5lc3RlZC5wdXNoKHsgbGV2ZWw6IGwsIGdyb3VwOiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKHJlZi5wYXJlbnQpIHtcbiAgICB2YWwgPSBzY29wZSsnZ3JvdXAuZGF0dW1bJyt2YWwrJ10nO1xuICAgIGRlcHMubmVzdGVkLnB1c2goeyBsZXZlbDogbCwgcGFyZW50OiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKHJlZi5zaWduYWwpIHtcbiAgICB2YWwgPSAnc2lnbmFsc1snK3ZhbCsnXSc7XG4gICAgZGVwcy5zaWduYWxzLnB1c2goZGwuZmllbGQocmVmLnNpZ25hbClbMF0pO1xuICAgIGRlcHMucmVmbG93ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoZGVwcy52YWwgPSB2YWwsIGRlcHMpO1xufVxuXG4vLyB7c2NhbGU6IFwieFwifVxuLy8ge3NjYWxlOiB7bmFtZTogXCJ4XCJ9fSxcbi8vIHtzY2FsZTogZmllbGRSZWZ9XG5mdW5jdGlvbiBzY2FsZVJlZihyZWYpIHtcbiAgdmFyIHNjYWxlID0gbnVsbCxcbiAgICAgIGZyID0gbnVsbCxcbiAgICAgIGRlcHMgPSBkZXBlbmRlbmNpZXMoKTtcblxuICBpZiAoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHNjYWxlID0gZGwuc3RyKHJlZik7XG4gIH0gZWxzZSBpZiAocmVmLm5hbWUpIHtcbiAgICBzY2FsZSA9IGRsLmlzU3RyaW5nKHJlZi5uYW1lKSA/IGRsLnN0cihyZWYubmFtZSkgOiAoZnIgPSBmaWVsZFJlZihyZWYubmFtZSkpLnZhbDtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZSA9IChmciA9IGZpZWxkUmVmKHJlZikpLnZhbDtcbiAgfVxuXG4gIHNjYWxlID0gJyhpdGVtLm1hcmsuX3NjYWxlUmVmc1snK3NjYWxlKyddID0gMSwgZ3JvdXAuc2NhbGUoJytzY2FsZSsnKSknO1xuICBpZiAocmVmLmludmVydCkgc2NhbGUgKz0gJy5pbnZlcnQnO1xuXG4gIC8vIE1hcmsgc2NhbGUgcmVmcyBhcyB0aGV5J3JlIGRlYWx0IHdpdGggc2VwYXJhdGVseSBpbiBtYXJrLl9zY2FsZVJlZnMuXG4gIGlmIChmcikgZnIubmVzdGVkLmZvckVhY2goZnVuY3Rpb24oZykgeyBnLnNjYWxlID0gdHJ1ZTsgfSk7XG4gIHJldHVybiBmciA/IChmci52YWwgPSBzY2FsZSwgZnIpIDogKGRlcHMudmFsID0gc2NhbGUsIGRlcHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnRpZXM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFNJR05BTFMgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuRGVwZW5kZW5jaWVzLlNJR05BTFMsXG4gICAgZXhwciA9IHJlcXVpcmUoJy4vZXhwcicpO1xuXG52YXIgUkVTRVJWRUQgPSBbJ2RhdHVtJywgJ2V2ZW50JywgJ3NpZ25hbHMnXVxuICAuY29uY2F0KGRsLmtleXMoZXhwci5jb2RlZ2VuLmZ1bmN0aW9ucykpO1xuXG5mdW5jdGlvbiBwYXJzZVNpZ25hbHMobW9kZWwsIHNwZWMpIHtcbiAgLy8gcHJvY2VzcyBlYWNoIHNpZ25hbCBkZWZpbml0aW9uXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAoUkVTRVJWRUQuaW5kZXhPZihzLm5hbWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1NpZ25hbCBuYW1lIFwiJytzLm5hbWUrJ1wiIGlzIGEgJytcbiAgICAgICAgJ3Jlc2VydmVkIGtleXdvcmQgKCcrUkVTRVJWRUQuam9pbignLCAnKSsnKS4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmFsID0gbW9kZWwuc2lnbmFsKHMubmFtZSwgcy5pbml0KVxuICAgICAgLnZlcmJvc2Uocy52ZXJib3NlKTtcblxuICAgIGlmIChzLmluaXQgJiYgcy5pbml0LmV4cHIpIHtcbiAgICAgIHMuaW5pdC5leHByID0gZXhwcihzLmluaXQuZXhwcik7XG4gICAgICBzaWduYWwudmFsdWUoZXhwclZhbChtb2RlbCwgcy5pbml0KSk7XG4gICAgfVxuXG4gICAgaWYgKHMuZXhwcikge1xuICAgICAgcy5leHByID0gZXhwcihzLmV4cHIpO1xuICAgICAgc2lnbmFsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGV4cHJWYWwobW9kZWwsIHMpO1xuICAgICAgICBpZiAodmFsICE9PSBzaWduYWwudmFsdWUoKSB8fCBzaWduYWwudmVyYm9zZSgpKSB7XG4gICAgICAgICAgc2lnbmFsLnZhbHVlKHZhbCk7XG4gICAgICAgICAgaW5wdXQuc2lnbmFsc1tzLm5hbWVdID0gMTtcbiAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlOyAgICAgICAgXG4gICAgICB9O1xuICAgICAgc2lnbmFsLmRlcGVuZGVuY3koU0lHTkFMUywgcy5leHByLmdsb2JhbHMpO1xuICAgICAgcy5leHByLmdsb2JhbHMuZm9yRWFjaChmdW5jdGlvbihkZXApIHtcbiAgICAgICAgbW9kZWwuc2lnbmFsKGRlcCkuYWRkTGlzdGVuZXIoc2lnbmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59XG5cbmZ1bmN0aW9uIGV4cHJWYWwobW9kZWwsIHNwZWMpIHtcbiAgdmFyIGUgPSBzcGVjLmV4cHIsXG4gICAgICB2YWwgPSBlLmZuKG51bGwsIG51bGwsIG1vZGVsLnZhbHVlcyhTSUdOQUxTLCBlLmdsb2JhbHMpKTtcbiAgcmV0dXJuIHNwZWMuc2NhbGUgPyBwYXJzZVNpZ25hbHMuc2NhbGUobW9kZWwsIHNwZWMsIHZhbCkgOiB2YWw7XG59XG5cbnBhcnNlU2lnbmFscy5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKG1vZGVsLCBzcGVjLCB2YWx1ZSwgZGF0dW0sIGV2dCkge1xuICB2YXIgZGVmID0gc3BlYy5zY2FsZSxcbiAgICAgIG5hbWUgID0gZGVmLm5hbWUgfHwgZGVmLnNpZ25hbCB8fCBkZWYsXG4gICAgICBzY29wZSA9IGRlZi5zY29wZSwgZTtcblxuICBpZiAoc2NvcGUpIHtcbiAgICBpZiAoc2NvcGUuc2lnbmFsKSB7XG4gICAgICBzY29wZSA9IG1vZGVsLnNpZ25hbFJlZihzY29wZS5zaWduYWwpO1xuICAgIH0gZWxzZSBpZiAoZGwuaXNTdHJpbmcoc2NvcGUpKSB7IC8vIFNjb3BlIGlzIGFuIGV4cHJlc3Npb25cbiAgICAgIGUgPSBkZWYuX2V4cHIgPSAoZGVmLl9leHByIHx8IGV4cHIoc2NvcGUpKTtcbiAgICAgIHNjb3BlID0gZS5mbihkYXR1bSwgZXZ0LCBtb2RlbC52YWx1ZXMoU0lHTkFMUywgZS5nbG9iYWxzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzY29wZSB8fCAhc2NvcGUuc2NhbGUpIHtcbiAgICBzY29wZSA9IChzY29wZSAmJiBzY29wZS5tYXJrKSA/IHNjb3BlLm1hcmsuZ3JvdXAgOiBtb2RlbC5zY2VuZSgpLml0ZW1zWzBdO1xuICB9XG5cbiAgdmFyIHMgPSBzY29wZS5zY2FsZShuYW1lKTtcbiAgcmV0dXJuICFzID8gdmFsdWUgOiAoZGVmLmludmVydCA/IHMuaW52ZXJ0KHZhbHVlKSA6IHModmFsdWUpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VTaWduYWxzOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4uL2NvcmUvTW9kZWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi4vY29yZS9WaWV3Jyk7XG5cbmZ1bmN0aW9uIHBhcnNlU3BlYyhzcGVjLCBjYWxsYmFjaykge1xuICB2YXIgdmYgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSxcbiAgICAgIHZpZXdGYWN0b3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgZGwuaXNGdW5jdGlvbih2ZikgPyB2ZiA6IFZpZXcuZmFjdG9yeSxcbiAgICAgIGNvbmZpZyA9IGFyZ3VtZW50c1syXSAhPT0gdmlld0ZhY3RvcnkgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIG1vZGVsID0gbmV3IE1vZGVsKGNvbmZpZyk7XG5cbiAgZnVuY3Rpb24gcGFyc2Uoc3BlYykge1xuICAgIC8vIHByb3RlY3QgYWdhaW5zdCBzdWJzZXF1ZW50IHNwZWMgbW9kaWZpY2F0aW9uXG4gICAgc3BlYyA9IGRsLmR1cGxpY2F0ZShzcGVjKTtcblxuICAgIHZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi8nKSxcbiAgICAgICAgd2lkdGggPSBzcGVjLndpZHRoIHx8IDUwMCxcbiAgICAgICAgaGVpZ2h0ID0gc3BlYy5oZWlnaHQgfHwgNTAwLFxuICAgICAgICB2aWV3cG9ydCA9IHNwZWMudmlld3BvcnQgfHwgbnVsbDtcblxuICAgIG1vZGVsLmRlZnMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBiYWNrZ3JvdW5kOiBwYXJzZXJzLmJhY2tncm91bmQoc3BlYy5iYWNrZ3JvdW5kKSxcbiAgICAgIHBhZGRpbmc6IHBhcnNlcnMucGFkZGluZyhzcGVjLnBhZGRpbmcpLFxuICAgICAgc2lnbmFsczogcGFyc2Vycy5zaWduYWxzKG1vZGVsLCBzcGVjLnNpZ25hbHMpLFxuICAgICAgcHJlZGljYXRlczogcGFyc2Vycy5wcmVkaWNhdGVzKG1vZGVsLCBzcGVjLnByZWRpY2F0ZXMpLFxuICAgICAgbWFya3M6IHBhcnNlcnMubWFya3MobW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgZGF0YTogcGFyc2Vycy5kYXRhKG1vZGVsLCBzcGVjLmRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayh2aWV3RmFjdG9yeShtb2RlbCkpO1xuICAgICAgfSlcbiAgICB9KTsgICAgXG4gIH1cblxuICBpZiAoZGwuaXNPYmplY3Qoc3BlYykpIHtcbiAgICBwYXJzZShzcGVjKTtcbiAgfSBlbHNlIGlmIChkbC5pc1N0cmluZyhzcGVjKSkge1xuICAgIHZhciBvcHRzID0gZGwuZXh0ZW5kKHt1cmw6IHNwZWN9LCBtb2RlbC5jb25maWcoKS5sb2FkKTtcbiAgICBkbC5sb2FkKG9wdHMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoJ0xPQURJTkcgU1BFQ0lGSUNBVElPTiBGQUlMRUQ6ICcgKyBlcnIuc3RhdHVzVGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkgeyBcbiAgICAgICAgICBwYXJzZShKU09OLnBhcnNlKGRhdGEpKTsgXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgXG4gICAgICAgICAgbG9nLmVycm9yKCdJTlZBTElEIFNQRUNJRklDQVRJT046IE11c3QgYmUgYSB2YWxpZCBKU09OIG9iamVjdC4gJytlKTsgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuZXJyb3IoJ0lOVkFMSUQgU1BFQ0lGSUNBVElPTjogTXVzdCBiZSBhIHZhbGlkIEpTT04gb2JqZWN0IG9yIFVSTC4nKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlU3BlYzsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBTSUdOQUxTID0gZGYuRGVwZW5kZW5jaWVzLlNJR05BTFMsXG4gICAgcGFyc2VTaWduYWxzID0gcmVxdWlyZSgnLi9zaWduYWxzJyksXG4gICAgc2VsZWN0b3IgPSByZXF1aXJlKCcuL2V2ZW50cycpLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuL2V4cHInKTtcblxudmFyIEdBVEVLRUVQRVIgPSAnX3ZnR0FURUtFRVBFUic7XG5cbnZhciB2Z0V2ZW50ID0ge1xuICBnZXRHcm91cDogZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZSA/IHRoaXMubmFtZVtuYW1lXSA6IHRoaXMuZ3JvdXA7IH0sXG4gIGdldFhZOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB2YXIgcCA9IHt4OiB0aGlzLngsIHk6IHRoaXMueX07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLm5hbWVbaXRlbV07XG4gICAgICB9XG4gICAgICBmb3IgKDsgaXRlbTsgaXRlbSA9IGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZ3JvdXApIHtcbiAgICAgICAgcC54IC09IGl0ZW0ueCB8fCAwO1xuICAgICAgICBwLnkgLT0gaXRlbS55IHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICBnZXRYOiBmdW5jdGlvbihpdGVtKSB7IHJldHVybiB0aGlzLmdldFhZKGl0ZW0pLng7IH0sXG4gIGdldFk6IGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHRoaXMuZ2V0WFkoaXRlbSkueTsgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VTdHJlYW1zKHZpZXcpIHtcbiAgdmFyIG1vZGVsID0gdmlldy5tb2RlbCgpLFxuICAgICAgc3BlYyAgPSBtb2RlbC5kZWZzKCkuc2lnbmFscyxcbiAgICAgIHJlZ2lzdHJ5ID0ge2hhbmRsZXJzOiB7fSwgbm9kZXM6IHt9fSxcbiAgICAgIGludGVybmFsID0gZGwuZHVwbGljYXRlKHJlZ2lzdHJ5KSwgIC8vIEludGVybmFsIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgIGV4dGVybmFsID0gZGwuZHVwbGljYXRlKHJlZ2lzdHJ5KTsgIC8vIEV4dGVybmFsIGV2ZW50IHByb2Nlc3NpbmdcblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnbmFsID0gbW9kZWwuc2lnbmFsKHNpZy5uYW1lKTtcbiAgICBpZiAoc2lnLmV4cHIpIHJldHVybjsgIC8vIENhbm5vdCBoYXZlIGFuIGV4cHIgYW5kIHN0cmVhbSBkZWZpbml0aW9uLlxuXG4gICAgKHNpZy5zdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIHNlbCA9IHNlbGVjdG9yLnBhcnNlKHN0cmVhbS50eXBlKSxcbiAgICAgICAgICBleHAgPSBleHByKHN0cmVhbS5leHByKTtcbiAgICAgIG1lcmdlZFN0cmVhbShzaWduYWwsIHNlbCwgZXhwLCBzdHJlYW0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBXZSByZWdpc3RlciB0aGUgZXZlbnQgbGlzdGVuZXJzIGFsbCB0b2dldGhlciBzbyB0aGF0IGlmIG11bHRpcGxlXG4gIC8vIHNpZ25hbHMgYXJlIHJlZ2lzdGVyZWQgb24gdGhlIHNhbWUgZXZlbnQsIHRoZXkgd2lsbCByZWNlaXZlIHRoZVxuICAvLyBuZXcgdmFsdWUgb24gdGhlIHNhbWUgcHVsc2UuIFxuICBkbC5rZXlzKGludGVybmFsLmhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2aWV3Lm9uKHR5cGUsIGZ1bmN0aW9uKGV2dCwgaXRlbSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIHN0b3AgdGV4dCBzZWxlY3Rpb25cbiAgICAgIGV4dGVuZEV2ZW50KGV2dCwgaXRlbSk7XG4gICAgICBmaXJlKGludGVybmFsLCB0eXBlLCAoaXRlbSAmJiBpdGVtLmRhdHVtKSB8fCB7fSwgZXZ0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYWRkIGV4dGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuICBkbC5rZXlzKGV4dGVybmFsLmhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjsgLy8gTm8gZXh0ZXJuYWwgc3VwcG9ydFxuXG4gICAgdmFyIGggPSBleHRlcm5hbC5oYW5kbGVyc1t0eXBlXSxcbiAgICAgICAgdCA9IHR5cGUuc3BsaXQoJzonKSwgLy8gLS0+IG5vIGVsZW1lbnQgcHNldWRvLXNlbGVjdG9yc1xuICAgICAgICBlbHQgPSAodFswXSA9PT0gJ3dpbmRvdycpID8gW3dpbmRvd10gOlxuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0WzBdKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZXZ0KSB7XG4gICAgICBleHRlbmRFdmVudChldnQpO1xuICAgICAgZmlyZShleHRlcm5hbCwgdHlwZSwgZDMuc2VsZWN0KHRoaXMpLmRhdHVtKCksIGV2dCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpPGVsdC5sZW5ndGg7ICsraSkge1xuICAgICAgZWx0W2ldLmFkZEV2ZW50TGlzdGVuZXIodFsxXSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgaC5lbGVtZW50cyA9IGVsdDtcbiAgICBoLmxpc3RlbmVyID0gaGFuZGxlcjtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGV4dGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuICBleHRlcm5hbC5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICBkbC5rZXlzKGV4dGVybmFsLmhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBoID0gZXh0ZXJuYWwuaGFuZGxlcnNbdHlwZV0sXG4gICAgICAgICAgdCA9IHR5cGUuc3BsaXQoJzonKSxcbiAgICAgICAgICBlbHQgPSBoLmVsZW1lbnRzIHx8IFtdO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGVsdFtpXS5yZW1vdmVFdmVudExpc3RlbmVyKHRbMV0sIGgubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGV4cG9ydCBkZXRhY2ggbWV0aG9kXG4gIHJldHVybiBleHRlcm5hbC5kZXRhY2g7XG5cbiAgLy8gLS0gaGVscGVyIGZ1bmN0aW9ucyAtLS0tLVxuXG4gIGZ1bmN0aW9uIGV4dGVuZEV2ZW50KGV2dCwgaXRlbSkge1xuICAgIHZhciBtb3VzZSA9IGQzLm1vdXNlKChkMy5ldmVudD1ldnQsIHZpZXcucmVuZGVyZXIoKS5zY2VuZSgpKSksXG4gICAgICAgIHBhZCA9IHZpZXcucGFkZGluZygpLFxuICAgICAgICBuYW1lcyA9IHt9LCBtYXJrLCBncm91cCwgaTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICBtYXJrID0gaXRlbS5tYXJrO1xuICAgICAgZ3JvdXAgPSBtYXJrLm1hcmt0eXBlID09PSAnZ3JvdXAnID8gaXRlbSA6IG1hcmsuZ3JvdXA7XG4gICAgICBmb3IgKGk9aXRlbTsgaSE9bnVsbDsgaT1pLm1hcmsuZ3JvdXApIHtcbiAgICAgICAgaWYgKGkubWFyay5kZWYubmFtZSkge1xuICAgICAgICAgIG5hbWVzW2kubWFyay5kZWYubmFtZV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5hbWVzLnJvb3QgPSB2aWV3Lm1vZGVsKCkuc2NlbmUoKS5pdGVtc1swXTtcblxuICAgIGV2dC52ZyA9IE9iamVjdC5jcmVhdGUodmdFdmVudCk7XG4gICAgZXZ0LnZnLmdyb3VwID0gZ3JvdXA7XG4gICAgZXZ0LnZnLml0ZW0gPSBpdGVtIHx8IHt9O1xuICAgIGV2dC52Zy5uYW1lID0gbmFtZXM7XG4gICAgZXZ0LnZnLnggPSBtb3VzZVswXSAtIHBhZC5sZWZ0O1xuICAgIGV2dC52Zy55ID0gbW91c2VbMV0gLSBwYWQudG9wO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZShyZWdpc3RyeSwgdHlwZSwgZGF0dW0sIGV2dCkge1xuICAgIHZhciBoYW5kbGVycyA9IHJlZ2lzdHJ5LmhhbmRsZXJzW3R5cGVdLFxuICAgICAgICBub2RlID0gcmVnaXN0cnkubm9kZXNbdHlwZV0sXG4gICAgICAgIGNzID0gZGYuQ2hhbmdlU2V0LmNyZWF0ZShudWxsLCB0cnVlKSxcbiAgICAgICAgZmlsdGVyZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsLCBpLCBuLCBoO1xuXG4gICAgZnVuY3Rpb24gaW52b2tlKGYpIHtcbiAgICAgIHJldHVybiAhZi5mbihkYXR1bSwgZXZ0LCBtb2RlbC52YWx1ZXMoU0lHTkFMUywgZi5nbG9iYWxzKSk7XG4gICAgfVxuXG4gICAgZm9yIChpPTAsIG49aGFuZGxlcnMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaCA9IGhhbmRsZXJzW2ldO1xuICAgICAgZmlsdGVyZWQgPSBoLmZpbHRlcnMuc29tZShpbnZva2UpO1xuICAgICAgaWYgKGZpbHRlcmVkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgdmFsID0gaC5leHAuZm4oZGF0dW0sIGV2dCwgbW9kZWwudmFsdWVzKFNJR05BTFMsIGguZXhwLmdsb2JhbHMpKTtcbiAgICAgIGlmIChoLnNwZWMuc2NhbGUpIHtcbiAgICAgICAgdmFsID0gcGFyc2VTaWduYWxzLnNjYWxlKG1vZGVsLCBoLnNwZWMsIHZhbCwgZGF0dW0sIGV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgIT09IGguc2lnbmFsLnZhbHVlKCkgfHwgaC5zaWduYWwudmVyYm9zZSgpKSB7XG4gICAgICAgIGguc2lnbmFsLnZhbHVlKHZhbCk7XG4gICAgICAgIGNzLnNpZ25hbHNbaC5zaWduYWwubmFtZSgpXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWwucHJvcGFnYXRlKGNzLCBub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICBzZWxlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmIChzLmV2ZW50KSAgICAgICBkb21FdmVudChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmIChzLnNpZ25hbCkgc2lnbmFsKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYgKHMuc3RhcnQpICBvcmRlcmVkU3RyZWFtKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYgKHMuc3RyZWFtKSBtZXJnZWRTdHJlYW0oc2lnLCBzLnN0cmVhbSwgZXhwLCBzcGVjKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbUV2ZW50KHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBldnQgPSBzZWxlY3Rvci5ldmVudCxcbiAgICAgICAgbmFtZSA9IHNlbGVjdG9yLm5hbWUsXG4gICAgICAgIG1hcmsgPSBzZWxlY3Rvci5tYXJrLFxuICAgICAgICB0YXJnZXQgICA9IHNlbGVjdG9yLnRhcmdldCxcbiAgICAgICAgZmlsdGVycyAgPSBzZWxlY3Rvci5maWx0ZXJzIHx8IFtdLFxuICAgICAgICByZWdpc3RyeSA9IHRhcmdldCA/IGV4dGVybmFsIDogaW50ZXJuYWwsXG4gICAgICAgIHR5cGUgPSB0YXJnZXQgPyB0YXJnZXQrJzonK2V2dCA6IGV2dCxcbiAgICAgICAgbm9kZSA9IHJlZ2lzdHJ5Lm5vZGVzW3R5cGVdIHx8IChyZWdpc3RyeS5ub2Rlc1t0eXBlXSA9IG5ldyBkZi5Ob2RlKG1vZGVsKSksXG4gICAgICAgIGhhbmRsZXJzID0gcmVnaXN0cnkuaGFuZGxlcnNbdHlwZV0gfHwgKHJlZ2lzdHJ5LmhhbmRsZXJzW3R5cGVdID0gW10pO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGZpbHRlcnMucHVzaCgnISFldmVudC52Zy5uYW1lW1wiJyArIG5hbWUgKyAnXCJdJyk7IC8vIE1pbWljIGV2ZW50IGJ1YmJsaW5nXG4gICAgfSBlbHNlIGlmIChtYXJrKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goJ2V2ZW50LnZnLml0ZW0ubWFyayAmJiBldmVudC52Zy5pdGVtLm1hcmsubWFya3R5cGU9PT0nK2RsLnN0cihtYXJrKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMucHVzaCh7XG4gICAgICBzaWduYWw6IHNpZyxcbiAgICAgIGV4cDogZXhwLFxuICAgICAgc3BlYzogc3BlYyxcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGV4cHIoZik7IH0pXG4gICAgfSk7XG5cbiAgICBub2RlLmFkZExpc3RlbmVyKHNpZyk7XG4gIH1cblxuICBmdW5jdGlvbiBzaWduYWwoc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIG4gPSBuZXcgZGYuTm9kZShtb2RlbCk7XG4gICAgbi5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZiAoIWlucHV0LnNpZ25hbHNbc2VsZWN0b3Iuc2lnbmFsXSkgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuICAgICAgdmFyIHZhbCA9IGV4cC5mbihudWxsLCBudWxsLCBtb2RlbC52YWx1ZXMoU0lHTkFMUywgZXhwLmdsb2JhbHMpKTtcbiAgICAgIGlmIChzcGVjLnNjYWxlKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlU2lnbmFscy5zY2FsZShtb2RlbCwgc3BlYywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbCAhPT0gc2lnLnZhbHVlKCkgfHwgc2lnLnZlcmJvc2UoKSkge1xuICAgICAgICBzaWcudmFsdWUodmFsKTtcbiAgICAgICAgaW5wdXQuc2lnbmFsc1tzaWcubmFtZSgpXSA9IDE7XG4gICAgICAgIGlucHV0LnJlZmxvdyA9IHRydWU7ICAgICAgICBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0OyAgXG4gICAgfTtcbiAgICBuLmRlcGVuZGVuY3koZGYuRGVwZW5kZW5jaWVzLlNJR05BTFMsIHNlbGVjdG9yLnNpZ25hbCk7XG4gICAgbi5hZGRMaXN0ZW5lcihzaWcpO1xuICAgIG1vZGVsLnNpZ25hbChzZWxlY3Rvci5zaWduYWwpLmFkZExpc3RlbmVyKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gb3JkZXJlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgbmFtZSA9IHNpZy5uYW1lKCksIFxuICAgICAgICBnayA9IG5hbWUgKyBHQVRFS0VFUEVSLCBcbiAgICAgICAgdHJ1ZUZuICA9IGV4cHIoJ3RydWUnKSwgXG4gICAgICAgIGZhbHNlRm4gPSBleHByKCdmYWxzZScpLFxuICAgICAgICBtaWRkbGUgID0gc2VsZWN0b3IubWlkZGxlLFxuICAgICAgICBmaWx0ZXJzID0gbWlkZGxlLmZpbHRlcnMgfHwgKG1pZGRsZS5maWx0ZXJzID0gW10pLFxuICAgICAgICBnYXRla2VlcGVyID0gbW9kZWwuc2lnbmFsKGdrKSB8fCBtb2RlbC5zaWduYWwoZ2ssIGZhbHNlKTtcblxuICAgIC8vIFJlZ2lzdGVyIGFuIGFub255bW91cyBzaWduYWwgdG8gYWN0IGFzIGEgZ2F0ZWtlZXBlci4gSXRzIHZhbHVlIGlzXG4gICAgLy8gdHJ1ZSBvciBmYWxzZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc3RhcnQgb3IgZW5kIHN0cmVhbXMgb2NjdXIuIFxuICAgIC8vIFRoZSBtaWRkbGUgc2lnbmFsIHRoZW4gc2ltcGx5IGZpbHRlcnMgZm9yIHRoZSBnYXRla2VlcGVyJ3MgdmFsdWUuIFxuICAgIG1lcmdlZFN0cmVhbShnYXRla2VlcGVyLCBbc2VsZWN0b3Iuc3RhcnRdLCB0cnVlRm4sIHt9KTtcbiAgICBtZXJnZWRTdHJlYW0oZ2F0ZWtlZXBlciwgW3NlbGVjdG9yLmVuZF0sIGZhbHNlRm4sIHt9KTtcblxuICAgIGZpbHRlcnMucHVzaChnYXRla2VlcGVyLm5hbWUoKSk7XG4gICAgbWVyZ2VkU3RyZWFtKHNpZywgW3NlbGVjdG9yLm1pZGRsZV0sIGV4cCwgc3BlYyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVN0cmVhbXM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2luZGV4Jyk7XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3Jtcyhtb2RlbCwgZGVmKSB7XG4gIHZhciB0eCA9IG5ldyB0cmFuc2Zvcm1zW2RlZi50eXBlXShtb2RlbCk7XG4gIFxuICAvLyBXZSB3YW50IHRvIHJlbmFtZSBvdXRwdXQgZmllbGRzIGJlZm9yZSBzZXR0aW5nIGFueSBvdGhlciBwcm9wZXJ0aWVzLFxuICAvLyBhcyBzdWJzZXF1ZW50IHByb3BlcnRpZXMgbWF5IHJlcXVpcmUgb3V0cHV0IHRvIGJlIHNldCAoZS5nLiBncm91cCBieSkuXG4gIGlmKGRlZi5vdXRwdXQpIHR4Lm91dHB1dChkZWYub3V0cHV0KTtcblxuICBkbC5rZXlzKGRlZikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYoayA9PT0gJ3R5cGUnIHx8IGsgPT09ICdvdXRwdXQnKSByZXR1cm47XG4gICAgdHgucGFyYW0oaywgZGVmW2tdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVHJhbnNmb3JtczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgTm9kZSA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIGJvdW5kID0gcmVxdWlyZSgndmVnYS1zY2VuZWdyYXBoJykuYm91bmQsXG4gICAgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2RlcicpO1xuXG5mdW5jdGlvbiBCb3VuZGVyKGdyYXBoLCBtYXJrKSB7XG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAucmVmbG93cyh0cnVlKVxuICAgIC5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQm91bmRlci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnYm91bmRzJywgdGhpcy5fbWFyay5tYXJrdHlwZV0pO1xuXG4gIHZhciB0eXBlICA9IHRoaXMuX21hcmsubWFya3R5cGUsXG4gICAgICBpc0dycCA9IHR5cGUgPT09ICdncm91cCcsXG4gICAgICBpdGVtcyA9IHRoaXMuX21hcmsuaXRlbXMsXG4gICAgICBoYXNMZWdlbmRzID0gZGwuYXJyYXkodGhpcy5fbWFyay5kZWYubGVnZW5kcykubGVuZ3RoID4gMCxcbiAgICAgIGksIGlsZW4sIGosIGpsZW4sIGdyb3VwLCBsZWdlbmQ7XG5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCB8fCAhaXRlbXMubGVuZ3RoIHx8IFxuICAgICAgaW5wdXQubW9kLmxlbmd0aCA9PT0gaXRlbXMubGVuZ3RoIHx8XG4gICAgICB0eXBlID09PSAnYXJlYScgfHwgdHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgYm91bmQubWFyayh0aGlzLl9tYXJrLCBudWxsLCBpc0dycCAmJiAhaGFzTGVnZW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oaXRlbSkgeyBib3VuZC5pdGVtKGl0ZW0pOyB9KTtcbiAgfVxuXG4gIGlmIChpc0dycCAmJiBoYXNMZWdlbmRzKSB7XG4gICAgZm9yIChpPTAsIGlsZW49aXRlbXMubGVuZ3RoOyBpPGlsZW47ICsraSkge1xuICAgICAgZ3JvdXAgPSBpdGVtc1tpXTtcbiAgICAgIGdyb3VwLl9sZWdlbmRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgZm9yIChqPTAsIGpsZW49Z3JvdXAubGVnZW5kSXRlbXMubGVuZ3RoOyBqPGpsZW47ICsraikge1xuICAgICAgICBsZWdlbmQgPSBncm91cC5sZWdlbmRJdGVtc1tqXTtcbiAgICAgICAgRW5jb2Rlci51cGRhdGUodGhpcy5fZ3JhcGgsIGlucHV0LnRyYW5zLCAndmdfbGVnZW5kUG9zaXRpb24nLCBsZWdlbmQuaXRlbXMsIGlucHV0LmRpcnR5KTtcbiAgICAgICAgYm91bmQubWFyayhsZWdlbmQsIG51bGwsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBib3VuZC5tYXJrKHRoaXMuX21hcmssIG51bGwsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIGRmLkNoYW5nZVNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBJdGVtID0gcmVxdWlyZSgndmVnYS1zY2VuZWdyYXBoJykuSXRlbSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBOb2RlID0gZGYuTm9kZSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIENoYW5nZVNldCA9IGRmLkNoYW5nZVNldCxcbiAgICBTZW50aW5lbCA9IHt9LFxuICAgIEVuY29kZXIgID0gcmVxdWlyZSgnLi9FbmNvZGVyJyksXG4gICAgQm91bmRlciAgPSByZXF1aXJlKCcuL0JvdW5kZXInKSxcbiAgICBwYXJzZURhdGEgPSByZXF1aXJlKCcuLi9wYXJzZS9kYXRhJyk7XG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7ICAgIFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIFN0YXR1cyA9IEJ1aWxkZXIuU1RBVFVTID0ge1xuICBFTlRFUjogICdlbnRlcicsXG4gIFVQREFURTogJ3VwZGF0ZScsXG4gIEVYSVQ6ICAgJ2V4aXQnXG59O1xuXG52YXIgQ09OTkVDVEVEID0gMSwgRElTQ09OTkVDVEVEID0gMjtcblxudmFyIHByb3RvID0gKEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIHRoaXMuX2RlZiAgID0gZGVmO1xuICB0aGlzLl9tYXJrICA9IG1hcms7XG4gIHRoaXMuX2Zyb20gID0gKGRlZi5mcm9tID8gZGVmLmZyb20uZGF0YSA6IG51bGwpIHx8IGluaGVyaXRGcm9tO1xuICB0aGlzLl9kcyAgICA9IGRsLmlzU3RyaW5nKHRoaXMuX2Zyb20pID8gZ3JhcGguZGF0YSh0aGlzLl9mcm9tKSA6IG51bGw7XG4gIHRoaXMuX21hcCAgID0ge307XG4gIHRoaXMuX3N0YXR1cyA9IG51bGw7IC8vIENvbm5lY3RlZCBvciBkaXNjb25uZWN0ZWQ/XG5cbiAgbWFyay5kZWYgPSBkZWY7XG4gIG1hcmsubWFya3R5cGUgPSBkZWYudHlwZTtcbiAgbWFyay5pbnRlcmFjdGl2ZSA9IChkZWYuaW50ZXJhY3RpdmUgIT09IGZhbHNlKTtcbiAgbWFyay5pdGVtcyA9IFtdO1xuICBpZiAoZGwuaXNWYWxpZChkZWYubmFtZSkpIG1hcmsubmFtZSA9IGRlZi5uYW1lO1xuXG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fcGFyZW50X2lkID0gcGFyZW50X2lkO1xuXG4gIGlmIChkZWYuZnJvbSAmJiAoZGVmLmZyb20ubWFyayB8fCBkZWYuZnJvbS50cmFuc2Zvcm0gfHwgZGVmLmZyb20ubW9kaWZ5KSkge1xuICAgIGlubGluZURzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBOb24tZ3JvdXAgbWFyayBidWlsZGVycyBhcmUgc3VwZXIgbm9kZXMuIEVuY29kZXIgYW5kIEJvdW5kZXIgcmVtYWluIFxuICAvLyBzZXBhcmF0ZSBvcGVyYXRvcnMgYnV0IGFyZSBlbWJlZGRlZCBhbmQgY2FsbGVkIGJ5IEJ1aWxkZXIuZXZhbHVhdGUuXG4gIHRoaXMuX2lzU3VwZXIgPSAodGhpcy5fZGVmLnR5cGUgIT09ICdncm91cCcpOyBcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrLCB0aGlzKTtcbiAgdGhpcy5fYm91bmRlciA9IG5ldyBCb3VuZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcbiAgdGhpcy5fb3V0cHV0ICA9IG51bGw7IC8vIE91dHB1dCBjaGFuZ2VzZXQgZm9yIHJlYWN0aXZlIGdlb20gYXMgQm91bmRlciByZWZsb3dzXG5cbiAgaWYgKHRoaXMuX2RzKSB7IHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShEZXBzLkRBVEEsIHRoaXMuX2Zyb20pOyB9XG5cbiAgLy8gU2luY2UgQnVpbGRlcnMgYXJlIHN1cGVyIG5vZGVzLCBjb3B5IG92ZXIgZW5jb2RlciBkZXBlbmRlbmNpZXNcbiAgLy8gKGJvdW5kZXIgaGFzIG5vIHJlZ2lzdGVyZWQgZGVwZW5kZW5jaWVzKS5cbiAgdGhpcy5kZXBlbmRlbmN5KERlcHMuREFUQSwgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KERlcHMuREFUQSkpO1xuICB0aGlzLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShEZXBzLlNDQUxFUykpO1xuICB0aGlzLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBSZWFjdGl2ZSBnZW9tZXRyeSBhbmQgbWFyay1sZXZlbCB0cmFuc2Zvcm1hdGlvbnMgYXJlIGhhbmRsZWQgaGVyZSBcbi8vIGJlY2F1c2UgdGhleSBuZWVkIHRoZWlyIGdyb3VwJ3MgZGF0YS1qb2luZWQgY29udGV4dC4gXG5mdW5jdGlvbiBpbmxpbmVEcygpIHtcbiAgdmFyIGZyb20gPSB0aGlzLl9kZWYuZnJvbSxcbiAgICAgIGdlb20gPSBmcm9tLm1hcmssXG4gICAgICBzcmMsIG5hbWUsIHNwZWMsIHNpYmxpbmcsIG91dHB1dCwgaW5wdXQ7XG5cbiAgaWYgKGdlb20pIHtcbiAgICBuYW1lID0gWyd2ZycsIHRoaXMuX3BhcmVudF9pZCwgZ2VvbV0uam9pbignXycpO1xuICAgIHNwZWMgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdHJhbnNmb3JtOiBmcm9tLnRyYW5zZm9ybSwgXG4gICAgICBtb2RpZnk6IGZyb20ubW9kaWZ5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzcmMgPSB0aGlzLl9ncmFwaC5kYXRhKHRoaXMuX2Zyb20pO1xuICAgIG5hbWUgPSBbJ3ZnJywgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGUsIHNyYy5saXN0ZW5lcnModHJ1ZSkubGVuZ3RoXS5qb2luKCdfJyk7XG4gICAgc3BlYyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzb3VyY2U6IHRoaXMuX2Zyb20sXG4gICAgICB0cmFuc2Zvcm06IGZyb20udHJhbnNmb3JtLFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH1cblxuICB0aGlzLl9mcm9tID0gbmFtZTtcbiAgdGhpcy5fZHMgPSBwYXJzZURhdGEuZGF0YXNvdXJjZSh0aGlzLl9ncmFwaCwgc3BlYyk7XG4gIHZhciBub2RlO1xuXG4gIGlmIChnZW9tKSB7XG4gICAgc2libGluZyA9IHRoaXMuc2libGluZyhnZW9tKTtcblxuICAgIC8vIEJvdW5kZXIgcmVmbG93cywgc28gd2UgbmVlZCBhbiBpbnRlcm1lZGlhcnkgbm9kZSB0byBwcm9wYWdhdGVcbiAgICAvLyB0aGUgb3V0cHV0IGNvbnN0cnVjdGVkIGJ5IHRoZSBCdWlsZGVyLlxuICAgIG5vZGUgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCkuYWRkTGlzdGVuZXIodGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gICAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2libGluZy5fb3V0cHV0OyB9O1xuXG4gICAgaWYgKHNpYmxpbmcuX2lzU3VwZXIpIHtcbiAgICAgIHNpYmxpbmcuYWRkTGlzdGVuZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpYmxpbmcuX2JvdW5kZXIuYWRkTGlzdGVuZXIobm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgYSBuZXcgZGF0YXNvdXJjZSBidXQgaXQgaXMgZW1wdHkgYXNcbiAgICAvLyB0aGUgcHJvcGFnYXRpb24gY3ljbGUgaGFzIGFscmVhZHkgY3Jvc3NlZCB0aGUgZGF0YXNvdXJjZXMuIFxuICAgIC8vIFNvLCB3ZSByZXB1bHNlIGp1c3QgdGhpcyBkYXRhc291cmNlLiBUaGlzIHNob3VsZCBiZSBzYWZlXG4gICAgLy8gYXMgdGhlIGRzIGlzbid0IGNvbm5lY3RlZCB0byB0aGUgc2NlbmVncmFwaCB5ZXQuXG4gICAgb3V0cHV0ID0gdGhpcy5fZHMuc291cmNlKCkubGFzdCgpO1xuICAgIGlucHV0ICA9IENoYW5nZVNldC5jcmVhdGUob3V0cHV0KTtcblxuICAgIGlucHV0LmFkZCA9IG91dHB1dC5hZGQ7XG4gICAgaW5wdXQubW9kID0gb3V0cHV0Lm1vZDtcbiAgICBpbnB1dC5yZW0gPSBvdXRwdXQucmVtO1xuICAgIGlucHV0LnN0YW1wID0gbnVsbDtcbiAgICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUoaW5wdXQsIHRoaXMuX2RzLmxpc3RlbmVyKCksIG91dHB1dC5zdGFtcCk7XG4gIH1cbn1cblxucHJvdG8uZHMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RzOyB9O1xucHJvdG8ucGFyZW50ICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfTtcbnByb3RvLmVuY29kZXIgID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9lbmNvZGVyOyB9O1xucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFt0aGlzXTsgfTtcblxucHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVpbGRlciA9IHRoaXM7XG5cbiAgdGhpcy5fZ3JhcGguY29ubmVjdCh0aGlzLnBpcGVsaW5lKCkpO1xuICB0aGlzLl9lbmNvZGVyLl9zY2FsZXMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgaWYgKCEocyA9IGJ1aWxkZXIuX3BhcmVudC5zY2FsZShzKSkpIHJldHVybjtcbiAgICBzLmFkZExpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcblxuICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzU3VwZXIpIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICAgIGVsc2UgdGhpcy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQuX2NvbGxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gKHRoaXMuX3N0YXR1cyA9IENPTk5FQ1RFRCwgdGhpcyk7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICBmdW5jdGlvbiBkaXNjb25uZWN0U2NhbGVzKHNjYWxlcykge1xuICAgIGZvcih2YXIgaT0wLCBsZW49c2NhbGVzLmxlbmd0aCwgczsgaTxsZW47ICsraSkge1xuICAgICAgaWYgKCEocyA9IGJ1aWxkZXIuX3BhcmVudC5zY2FsZShzY2FsZXNbaV0pKSkgY29udGludWU7XG4gICAgICBzLnJlbW92ZUxpc3RlbmVyKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxuXG4gIE5vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbiAgdGhpcy5fZ3JhcGguZGlzY29ubmVjdCh0aGlzLnBpcGVsaW5lKCkpO1xuICBkaXNjb25uZWN0U2NhbGVzKHRoaXMuX2VuY29kZXIuX3NjYWxlcyk7XG4gIGRpc2Nvbm5lY3RTY2FsZXMoZGwua2V5cyh0aGlzLl9tYXJrLl9zY2FsZVJlZnMpKTtcbiAgXG4gIHJldHVybiAodGhpcy5fc3RhdHVzID0gRElTQ09OTkVDVEVELCB0aGlzKTtcbn07XG5cbnByb3RvLnNpYmxpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wYXJlbnQuY2hpbGQobmFtZSwgdGhpcy5fcGFyZW50X2lkKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2J1aWxkaW5nJywgKHRoaXMuX2Zyb20gfHwgdGhpcy5fZGVmLmZyb20pLCB0aGlzLl9kZWYudHlwZV0pO1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGRlZiA9IHRoaXMuX21hcmsuZGVmLFxuICAgICAgcHJvcHMgID0gZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUgICB8fCB7fSxcbiAgICAgIG91dHB1dCwgZnVsbFVwZGF0ZSwgZmNzLCBkYXRhLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9kcykge1xuICAgIG91dHB1dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYW55IGVuY29kZXIgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBlbmNvZGVyJ3MgZGF0YSBzb3VyY2Ugd2lsbCBsaWtlbHkgYmUgdXBkYXRlZCwgYW5kIHNob3VsZG4ndFxuICAgIC8vIHRyaWdnZXIgYWxsIGl0ZW1zIHRvIG1vZC5cbiAgICBkYXRhID0gb3V0cHV0LmRhdGFbKG5hbWU9dGhpcy5fZHMubmFtZSgpKV07XG4gICAgZGVsZXRlIG91dHB1dC5kYXRhW25hbWVdO1xuICAgIGZ1bGxVcGRhdGUgPSB0aGlzLl9lbmNvZGVyLnJlZXZhbHVhdGUob3V0cHV0KTtcbiAgICBvdXRwdXQuZGF0YVtuYW1lXSA9IGRhdGE7XG5cbiAgICAvLyBJZiBhIHNjYWxlIG9yIHNpZ25hbCBpbiB0aGUgdXBkYXRlIHByb3BzZXQgaGFzIGJlZW4gdXBkYXRlZCwgXG4gICAgLy8gc2VuZCBmb3J3YXJkIGFsbCBpdGVtcyBmb3IgcmVlbmNvZGluZyBpZiB3ZSBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgaWYgKGZ1bGxVcGRhdGUpIG91dHB1dC5tb2QgPSB0aGlzLl9tYXJrLml0ZW1zLnNsaWNlKCk7XG5cbiAgICBmY3MgPSB0aGlzLl9kcy5sYXN0KCk7XG4gICAgaWYgKCFmY3MpIHRocm93IEVycm9yKCdCdWlsZGVyIGV2YWx1YXRlZCBiZWZvcmUgYmFja2luZyBEYXRhU291cmNlLicpO1xuICAgIGlmIChmY3Muc3RhbXAgPiB0aGlzLl9zdGFtcCkge1xuICAgICAgb3V0cHV0ID0gam9pbi5jYWxsKHRoaXMsIGZjcywgdGhpcy5fZHMudmFsdWVzKCksIHRydWUsIGZ1bGxVcGRhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gZGwuaXNGdW5jdGlvbih0aGlzLl9kZWYuZnJvbSkgPyB0aGlzLl9kZWYuZnJvbSgpIDogW1NlbnRpbmVsXTtcbiAgICBvdXRwdXQgPSBqb2luLmNhbGwodGhpcywgaW5wdXQsIGRhdGEpO1xuICB9XG5cbiAgLy8gU3Rhc2ggb3V0cHV0IGJlZm9yZSBCb3VuZGVyIGZvciBkb3duc3RyZWFtIHJlYWN0aXZlIGdlb21ldHJ5LlxuICB0aGlzLl9vdXRwdXQgPSBvdXRwdXQgPSB0aGlzLl9ncmFwaC5ldmFsdWF0ZShvdXRwdXQsIHRoaXMuX2VuY29kZXIpO1xuXG4gIC8vIEFkZCBhbnkgbmV3IHNjYWxlIHJlZmVyZW5jZXMgdG8gdGhlIGRlcGVuZGVuY3kgbGlzdCwgYW5kIGVuc3VyZVxuICAvLyB0aGV5J3JlIGNvbm5lY3RlZC5cbiAgaWYgKHVwZGF0ZS5uZXN0ZWQgJiYgdXBkYXRlLm5lc3RlZC5sZW5ndGggJiYgdGhpcy5fc3RhdHVzID09PSBDT05ORUNURUQpIHtcbiAgICBkbC5rZXlzKHRoaXMuX21hcmsuX3NjYWxlUmVmcykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgc2NhbGUgPSBzZWxmLl9wYXJlbnQuc2NhbGUocyk7XG4gICAgICBpZiAoIXNjYWxlKSByZXR1cm47XG5cbiAgICAgIHNjYWxlLmFkZExpc3RlbmVyKHNlbGYpO1xuICAgICAgc2VsZi5kZXBlbmRlbmN5KERlcHMuU0NBTEVTLCBzKTtcbiAgICAgIHNlbGYuX2VuY29kZXIuZGVwZW5kZW5jeShEZXBzLlNDQUxFUywgcyk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBTdXBlcm5vZGVzIGNhbGN1bGF0ZSBib3VuZHMgdG9vLCBidXQgb25seSBvbiBpdGVtcyBtYXJrZWQgZGlydHkuXG4gIGlmICh0aGlzLl9pc1N1cGVyKSB7XG4gICAgb3V0cHV0Lm1vZCA9IG91dHB1dC5tb2QuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHguX2RpcnR5OyB9KTtcbiAgICBvdXRwdXQgPSB0aGlzLl9ncmFwaC5ldmFsdWF0ZShvdXRwdXQsIHRoaXMuX2JvdW5kZXIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIG5ld0l0ZW0oKSB7XG4gIHZhciBpdGVtID0gVHVwbGUuaW5nZXN0KG5ldyBJdGVtKHRoaXMuX21hcmspKTtcblxuICAvLyBGb3IgdGhlIHJvb3Qgbm9kZSdzIGl0ZW1cbiAgaWYgKHRoaXMuX2RlZi53aWR0aCkgIFR1cGxlLnNldChpdGVtLCAnd2lkdGgnLCAgdGhpcy5fZGVmLndpZHRoKTtcbiAgaWYgKHRoaXMuX2RlZi5oZWlnaHQpIFR1cGxlLnNldChpdGVtLCAnaGVpZ2h0JywgdGhpcy5fZGVmLmhlaWdodCk7XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBqb2luKGlucHV0LCBkYXRhLCBkcywgZnVsbFVwZGF0ZSkge1xuICB2YXIgb3V0cHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBrZXlmID0ga2V5RnVuY3Rpb24odGhpcy5fZGVmLmtleSB8fCAoZHMgPyAnX2lkJyA6IG51bGwpKSxcbiAgICAgIHByZXYgPSB0aGlzLl9tYXJrLml0ZW1zIHx8IFtdLFxuICAgICAgcmVtICA9IGRzID8gaW5wdXQucmVtIDogcHJldixcbiAgICAgIG1vZCAgPSBUdXBsZS5pZE1hcCgoIWRzIHx8IGZ1bGxVcGRhdGUpID8gZGF0YSA6IGlucHV0Lm1vZCksXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyLCBkaWZmO1xuXG4gIC8vIE9ubHkgbWFyayByZW1zIGFzIGV4aXRpbmcuIER1ZSB0byBrZXlmLCB0aGVyZSBtYXkgYmUgYW4gYWRkL21vZCBcbiAgLy8gdHVwbGUgdGhhdCByZXBsYWNlcyBpdC5cbiAgZm9yIChpPTAsIGxlbj1yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IChyZW1baV0gPT09IHByZXZbaV0pID8gcHJldltpXSA6XG4gICAgICBrZXlmID8gdGhpcy5fbWFwW2tleWYocmVtW2ldKV0gOiByZW1baV07XG4gICAgaXRlbS5zdGF0dXMgPSBTdGF0dXMuRVhJVDtcbiAgfVxuXG4gIGZvcihpPTAsIGxlbj1kYXRhLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcbiAgICBpdGVtICA9IGtleWYgPyB0aGlzLl9tYXBba2V5ID0ga2V5ZihkYXR1bSldIDogcHJldltpXTtcbiAgICBlbnRlciA9IGl0ZW0gPyBmYWxzZSA6IChpdGVtID0gbmV3SXRlbS5jYWxsKHRoaXMpLCB0cnVlKTtcbiAgICBpdGVtLnN0YXR1cyA9IGVudGVyID8gU3RhdHVzLkVOVEVSIDogU3RhdHVzLlVQREFURTtcbiAgICBkaWZmID0gIWVudGVyICYmIGl0ZW0uZGF0dW0gIT09IGRhdHVtO1xuICAgIGl0ZW0uZGF0dW0gPSBkYXR1bTtcblxuICAgIGlmIChrZXlmKSB7XG4gICAgICBUdXBsZS5zZXQoaXRlbSwgJ2tleScsIGtleSk7XG4gICAgICB0aGlzLl9tYXBba2V5XSA9IGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGVudGVyKSB7XG4gICAgICBvdXRwdXQuYWRkLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIGlmIChkaWZmIHx8IG1vZFtkYXR1bS5faWRdKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgZm9yIChpPTAsIGxlbj1yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IChyZW1baV0gPT09IHByZXZbaV0pID8gcHJldltpXSA6XG4gICAgICBrZXlmID8gdGhpcy5fbWFwW2tleSA9IGtleWYocmVtW2ldKV0gOiByZW1baV07XG4gICAgaWYgKGl0ZW0uc3RhdHVzID09PSBTdGF0dXMuRVhJVCkge1xuICAgICAgaXRlbS5fZGlydHkgPSB0cnVlO1xuICAgICAgaW5wdXQuZGlydHkucHVzaChpdGVtKTtcbiAgICAgIG5leHQucHVzaChpdGVtKTtcbiAgICAgIG91dHB1dC5yZW0ucHVzaChpdGVtKTtcbiAgICAgIGlmIChrZXlmKSB0aGlzLl9tYXBba2V5XSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICh0aGlzLl9tYXJrLml0ZW1zID0gbmV4dCwgb3V0cHV0KTtcbn1cblxuZnVuY3Rpb24ga2V5RnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBmID0gZGwuYXJyYXkoa2V5KS5tYXAoZGwuYWNjZXNzb3IpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIGZvciAodmFyIHM9JycsIGk9MCwgbj1mLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmIChpPjApIHMgKz0gJ3wnO1xuICAgICAgcyArPSBTdHJpbmcoZltpXShkKSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIE5vZGUgPSBkZi5Ob2RlLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBEZXBzID0gZGYuRGVwZW5kZW5jaWVzLFxuICAgIGJvdW5kID0gcmVxdWlyZSgndmVnYS1zY2VuZWdyYXBoJykuYm91bmQ7XG5cbnZhciBFTVBUWSA9IHt9O1xuXG5mdW5jdGlvbiBFbmNvZGVyKGdyYXBoLCBtYXJrLCBidWlsZGVyKSB7XG4gIHZhciBwcm9wcyAgPSBtYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0O1xuXG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG5cbiAgdGhpcy5fbWFyayA9IG1hcms7XG4gIHRoaXMuX2J1aWxkZXIgPSBidWlsZGVyO1xuICB2YXIgcyA9IHRoaXMuX3NjYWxlcyA9IFtdO1xuXG4gIC8vIE9ubHkgc2NhbGVzIHVzZWQgaW4gdGhlICd1cGRhdGUnIHByb3BlcnR5IHNldCBhcmUgc2V0IGFzXG4gIC8vIGVuY29kZXIgZGVwZWRlbmNpZXMgdG8gaGF2ZSB0YXJnZXRlZCByZWV2YWx1YXRpb25zLiBIb3dldmVyLFxuICAvLyB3ZSBzdGlsbCB3YW50IHNjYWxlcyBpbiAnZW50ZXInIGFuZCAnZXhpdCcgdG8gYmUgZXZhbHVhdGVkXG4gIC8vIGJlZm9yZSB0aGUgZW5jb2Rlci4gXG4gIGlmIChlbnRlcikgcy5wdXNoLmFwcGx5KHMsIGVudGVyLnNjYWxlcyk7XG5cbiAgaWYgKHVwZGF0ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeShEZXBzLkRBVEEsIHVwZGF0ZS5kYXRhKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCB1cGRhdGUuc2lnbmFscyk7XG4gICAgdGhpcy5kZXBlbmRlbmN5KERlcHMuRklFTERTLCB1cGRhdGUuZmllbGRzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koRGVwcy5TQ0FMRVMsIHVwZGF0ZS5zY2FsZXMpO1xuICAgIHMucHVzaC5hcHBseShzLCB1cGRhdGUuc2NhbGVzKTtcbiAgfVxuXG4gIGlmIChleGl0KSBzLnB1c2guYXBwbHkocywgZXhpdC5zY2FsZXMpO1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChFbmNvZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydlbmNvZGluZycsIHRoaXMuX21hcmsuZGVmLnR5cGVdKTtcbiAgdmFyIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBwcm9wcyA9IHRoaXMuX21hcmsuZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBpdGVtcyA9IHRoaXMuX21hcmsuaXRlbXMsXG4gICAgICBlbnRlciAgPSBwcm9wcy5lbnRlcixcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZSxcbiAgICAgIGV4aXQgICA9IHByb3BzLmV4aXQsXG4gICAgICBkaXJ0eSAgPSBpbnB1dC5kaXJ0eSxcbiAgICAgIHByZWRzICA9IGdyYXBoLnByZWRpY2F0ZXMoKSxcbiAgICAgIHJlcSA9IGlucHV0LnJlcXVlc3QsXG4gICAgICBncm91cCA9IHRoaXMuX21hcmsuZ3JvdXAsXG4gICAgICBndWlkZSA9IGdyb3VwICYmIChncm91cC5tYXJrLmF4aXMgfHwgZ3JvdXAubWFyay5sZWdlbmQpLFxuICAgICAgZGIgPSBFTVBUWSwgc2cgPSBFTVBUWSwgaSwgbGVuLCBpdGVtLCBwcm9wO1xuXG4gIGlmIChyZXEgJiYgIWd1aWRlKSB7XG4gICAgaWYgKChwcm9wID0gcHJvcHNbcmVxXSkgJiYgaW5wdXQubW9kLmxlbmd0aCkge1xuICAgICAgZGIgPSBwcm9wLmRhdGEgPyBncmFwaC52YWx1ZXMoRGVwcy5EQVRBLCBwcm9wLmRhdGEpIDogbnVsbDtcbiAgICAgIHNnID0gcHJvcC5zaWduYWxzID8gZ3JhcGgudmFsdWVzKERlcHMuU0lHTkFMUywgcHJvcC5zaWduYWxzKSA6IG51bGw7XG5cbiAgICAgIGZvciAoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICBpdGVtID0gaW5wdXQubW9kW2ldO1xuICAgICAgICBlbmNvZGUuY2FsbCh0aGlzLCBwcm9wLCBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnB1dDsgLy8gZXhpdCBlYXJseSBpZiBnaXZlbiByZXF1ZXN0XG4gIH1cblxuICBkYiA9IHZhbHVlcyhEZXBzLkRBVEEsIGdyYXBoLCBpbnB1dCwgcHJvcHMpO1xuICBzZyA9IHZhbHVlcyhEZXBzLlNJR05BTFMsIGdyYXBoLCBpbnB1dCwgcHJvcHMpO1xuXG4gIC8vIEl0ZW1zIG1hcmtlZCBmb3IgcmVtb3ZhbCBhcmUgYXQgdGhlIHRhaWwgb2YgaXRlbXMuIFByb2Nlc3MgdGhlbSBmaXJzdC5cbiAgZm9yIChpPTAsIGxlbj1pbnB1dC5yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGlucHV0LnJlbVtpXTtcbiAgICBpZiAoZXhpdCkgZW5jb2RlLmNhbGwodGhpcywgZXhpdCwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMsIGRpcnR5KTsgXG4gICAgaWYgKGlucHV0LnRyYW5zICYmICFleGl0KSBpbnB1dC50cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBFTVBUWSk7XG4gICAgZWxzZSBpZiAoIWlucHV0LnRyYW5zKSBpdGVtcy5wb3AoKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVfc3RhdHVzID0gcmVxdWlyZSgnLi9CdWlsZGVyJykuU1RBVFVTLlVQREFURTtcbiAgZm9yIChpPTAsIGxlbj1pbnB1dC5hZGQubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGlucHV0LmFkZFtpXTtcbiAgICBpZiAoZW50ZXIpICBlbmNvZGUuY2FsbCh0aGlzLCBlbnRlciwgIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzLCBkaXJ0eSk7XG4gICAgaWYgKHVwZGF0ZSkgZW5jb2RlLmNhbGwodGhpcywgdXBkYXRlLCBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpO1xuICAgIGl0ZW0uc3RhdHVzID0gdXBkYXRlX3N0YXR1cztcbiAgfVxuXG4gIGlmICh1cGRhdGUpIHtcbiAgICBmb3IgKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzLCBkaXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuLy8gT25seSBtYXJzaGFsIG5lY2Vzc2FyeSBkYXRhIGFuZCBzaWduYWwgdmFsdWVzXG5mdW5jdGlvbiB2YWx1ZXModHlwZSwgZ3JhcGgsIGlucHV0LCBwcm9wcykge1xuICB2YXIgcCwgeCwgbywgYWRkID0gaW5wdXQuYWRkLmxlbmd0aDtcbiAgaWYgKChwPXByb3BzLmVudGVyKSAmJiAoeD1wW3R5cGVdKS5sZW5ndGggJiYgYWRkKSB7XG4gICAgbyA9IGdyYXBoLnZhbHVlcyh0eXBlLCB4LCAobz1vfHx7fSkpO1xuICB9XG4gIGlmICgocD1wcm9wcy5leGl0KSAmJiAoeD1wW3R5cGVdKS5sZW5ndGggJiYgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG8gPSBncmFwaC52YWx1ZXModHlwZSwgeCwgKG89b3x8e30pKTsgXG4gIH1cbiAgaWYgKChwPXByb3BzLnVwZGF0ZSkgJiYgKHg9cFt0eXBlXSkubGVuZ3RoICYmIChhZGQgfHwgaW5wdXQubW9kLmxlbmd0aCkpIHtcbiAgICBvID0gZ3JhcGgudmFsdWVzKHR5cGUsIHgsIChvPW98fHt9KSk7XG4gIH1cbiAgcmV0dXJuIG8gfHwgRU1QVFk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZShwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpIHtcbiAgdmFyIGVuYyA9IHByb3AuZW5jb2RlLFxuICAgICAgd2FzRGlydHkgPSBpdGVtLl9kaXJ0eSxcbiAgICAgIGlzRGlydHkgID0gZW5jLmNhbGwoZW5jLCBpdGVtLCBpdGVtLm1hcmsuZ3JvdXB8fGl0ZW0sIHRyYW5zLCBkYiwgc2csIHByZWRzKTtcblxuICBpdGVtLl9kaXJ0eSA9IGlzRGlydHkgfHwgd2FzRGlydHk7XG4gIGlmIChpc0RpcnR5ICYmICF3YXNEaXJ0eSkgZGlydHkucHVzaChpdGVtKTtcbn1cblxuLy8gSWYgYSBzcGVjaWZpZWQgcHJvcGVydHkgc2V0IGNhbGxlZCwgb3IgdXBkYXRlIHByb3BlcnR5IHNldCBcbi8vIHVzZXMgbmVzdGVkIGZpZWxkcmVmcywgcmVldmFsdWF0ZSBhbGwgaXRlbXMuXG5wcm90by5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHtcbiAgdmFyIGRlZiA9IHRoaXMuX21hcmsuZGVmLFxuICAgICAgcHJvcHMgPSBkZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIHJlZXZhbCA9IGRsLmlzRnVuY3Rpb24oZGVmLmZyb20pIHx8IGRlZi5vcmllbnQgfHwgcHVsc2UucmVxdWVzdCB8fCBcbiAgICAgICAgTm9kZS5wcm90b3R5cGUucmVldmFsdWF0ZS5jYWxsKHRoaXMsIHB1bHNlKTtcblxuICByZXR1cm4gcmVldmFsIHx8IChwcm9wcy51cGRhdGUgPyBuZXN0ZWRSZWZzLmNhbGwodGhpcykgOiBmYWxzZSk7XG59O1xuXG4vLyBUZXN0IGlmIGFueSBuZXN0ZWQgcmVmcyB0cmlnZ2VyIGEgcmVmbG93IG9mIG1hcmsgaXRlbXMuXG5mdW5jdGlvbiBuZXN0ZWRSZWZzKCkge1xuICB2YXIgcmVmcyA9IHRoaXMuX21hcmsuZGVmLnByb3BlcnRpZXMudXBkYXRlLm5lc3RlZCxcbiAgICAgIHBhcmVudCA9IHRoaXMuX2J1aWxkZXIsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICBpID0gMCwgbGVuID0gcmVmcy5sZW5ndGgsXG4gICAgICByZWYsIGRzLCBzdGFtcDtcblxuICBmb3IgKDsgaTxsZW47ICsraSkge1xuICAgIHJlZiA9IHJlZnNbaV07XG5cbiAgICAvLyBTY2FsZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZCB2aWEgdGhpcy5fbWFyay5fc2NhbGVSZWZzIHdoaWNoIGFyZVxuICAgIC8vIGFkZGVkIHRvIGRlcGVuZGVuY3kgbGlzdHMgKyBjb25uZWN0ZWQgaW4gQnVpbGRlci5ldmFsdWF0ZS5cbiAgICBpZiAocmVmLnNjYWxlKSBjb250aW51ZTtcblxuICAgIGZvciAoOyBsZXZlbDxyZWYubGV2ZWw7ICsrbGV2ZWwpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKTtcbiAgICAgIGRzID0gcGFyZW50LmRzKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGFyZSBzdGFtcHMgdG8gZGV0ZXJtaW5lIGlmIGEgY2hhbmdlIGluIGEgZ3JvdXAncyBwcm9wZXJ0aWVzXG4gICAgLy8gb3IgZGF0YSBzaG91bGQgdHJpZ2dlciBhIHJlZXZhbC4gV2UgY2Fubm90IGNoZWNrIGFueXRoaW5nIGZhbmNpZXJcbiAgICAvLyAoZS5nLiwgcHVsc2UuZmllbGRzKSBhcyB0aGUgcmVmIG1heSB1c2UgaXRlbS5kYXR1bS5cbiAgICBzdGFtcCA9IChyZWYuZ3JvdXAgPyBwYXJlbnQuZW5jb2RlcigpIDogZHMubGFzdCgpKS5fc3RhbXA7XG4gICAgaWYgKHN0YW1wID4gdGhpcy5fc3RhbXApIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTaG9ydC1jaXJjdWl0IGVuY29kZXIgaWYgdXNlciBzcGVjaWZpZXMgaXRlbXNcbkVuY29kZXIudXBkYXRlID0gZnVuY3Rpb24oZ3JhcGgsIHRyYW5zLCByZXF1ZXN0LCBpdGVtcywgZGlydHkpIHtcbiAgaXRlbXMgPSBkbC5hcnJheShpdGVtcyk7XG4gIHZhciBwcmVkcyA9IGdyYXBoLnByZWRpY2F0ZXMoKSwgXG4gICAgICBkYiA9IGdyYXBoLnZhbHVlcyhEZXBzLkRBVEEpLFxuICAgICAgc2cgPSBncmFwaC52YWx1ZXMoRGVwcy5TSUdOQUxTKSxcbiAgICAgIGksIGxlbiwgaXRlbSwgcHJvcHMsIHByb3A7XG5cbiAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgcHJvcHMgPSBpdGVtLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gICAgcHJvcCA9IHByb3BzICYmIHByb3BzW3JlcXVlc3RdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBlbmNvZGUuY2FsbChudWxsLCBwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcywgZGlydHkpO1xuICAgICAgYm91bmQuaXRlbShpdGVtKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBOb2RlID0gZGYuTm9kZSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBDb2xsZWN0b3IgPSBkZi5Db2xsZWN0b3IsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgQnVpbGRlciA9IHJlcXVpcmUoJy4vQnVpbGRlcicpLFxuICAgIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpLFxuICAgIHBhcnNlQXhlcyA9IHJlcXVpcmUoJy4uL3BhcnNlL2F4ZXMnKSxcbiAgICBwYXJzZUxlZ2VuZHMgPSByZXF1aXJlKCcuLi9wYXJzZS9sZWdlbmRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnVpbGRlcigpIHtcbiAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy5fc2NhbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjdXJzb3IgPSBudWxsO1xuXG4gIHRoaXMuX3NjYWxlcyA9IHt9O1xuICB0aGlzLnNjYWxlID0gc2NhbGUuYmluZCh0aGlzKTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBUeXBlcyA9IEdyb3VwQnVpbGRlci5UWVBFUyA9IHtcbiAgR1JPVVA6ICBcImdyb3VwXCIsXG4gIE1BUks6ICAgXCJtYXJrXCIsXG4gIEFYSVM6ICAgXCJheGlzXCIsXG4gIExFR0VORDogXCJsZWdlbmRcIlxufTtcblxudmFyIHByb3RvID0gKEdyb3VwQnVpbGRlci5wcm90b3R5cGUgPSBuZXcgQnVpbGRlcigpKTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKGdyYXBoLCBkZWYpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzLCBuYW1lO1xuXG4gIHRoaXMuX3NjYWxlciA9IG5ldyBOb2RlKGdyYXBoKTtcblxuICAoZGVmLnNjYWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHMgPSBidWlsZGVyLnNjYWxlKChuYW1lPXMubmFtZSksIG5ldyBTY2FsZShncmFwaCwgcywgYnVpbGRlcikpO1xuICAgIGJ1aWxkZXIuc2NhbGUobmFtZStcIjpwcmV2XCIsIHMpO1xuICAgIGJ1aWxkZXIuX3NjYWxlci5hZGRMaXN0ZW5lcihzKTsgIC8vIFNjYWxlcyBzaG91bGQgYmUgY29tcHV0ZWQgYWZ0ZXIgZ3JvdXAgaXMgZW5jb2RlZFxuICB9KTtcblxuICB0aGlzLl9yZWN1cnNvciA9IG5ldyBOb2RlKGdyYXBoKTtcbiAgdGhpcy5fcmVjdXJzb3IuZXZhbHVhdGUgPSByZWN1cnNlLmJpbmQodGhpcyk7XG5cbiAgdmFyIHNjYWxlcyA9IChkZWYuYXhlc3x8W10pLnJlZHVjZShmdW5jdGlvbihhY2MsIHgpIHtcbiAgICByZXR1cm4gKGFjY1t4LnNjYWxlXSA9IDEsIGFjYyk7XG4gIH0sIHt9KTtcblxuICBzY2FsZXMgPSAoZGVmLmxlZ2VuZHN8fFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIChhY2NbeC5zaXplIHx8IHguc2hhcGUgfHwgeC5maWxsIHx8IHguc3Ryb2tlXSwgYWNjKTtcbiAgfSwgc2NhbGVzKTtcblxuICB0aGlzLl9yZWN1cnNvci5kZXBlbmRlbmN5KERlcHMuU0NBTEVTLCBkbC5rZXlzKHNjYWxlcykpO1xuXG4gIC8vIFdlIG9ubHkgbmVlZCBhIGNvbGxlY3RvciBmb3IgdXAtcHJvcGFnYXRpb24gb2YgYm91bmRzIGNhbGN1bGF0aW9uLFxuICAvLyBzbyBvbmx5IEdyb3VwQnVpbGRlcnMsIGFuZCBub3QgcmVndWxhciBCdWlsZGVycywgaGF2ZSBjb2xsZWN0b3JzLlxuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcblxuICByZXR1cm4gQnVpbGRlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWxkZXIuX2NoaWxkcmVuID0ge307XG4gIHJldHVybiBCdWlsZGVyLnByb3RvdHlwZS5kaXNjb25uZWN0LmNhbGwodGhpcyk7XG59O1xuXG5wcm90by5jaGlsZCA9IGZ1bmN0aW9uKG5hbWUsIGdyb3VwX2lkKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwX2lkXSxcbiAgICAgIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICBjaGlsZDtcblxuICBmb3IgKDsgaTxsZW47ICsraSkge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLnR5cGUgPT0gVHlwZXMuTUFSSyAmJiBjaGlsZC5idWlsZGVyLl9kZWYubmFtZSA9PSBuYW1lKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBjaGlsZC5idWlsZGVyO1xufTtcblxuZnVuY3Rpb24gcmVjdXJzZShpbnB1dCkge1xuICB2YXIgYnVpbGRlciA9IHRoaXMsXG4gICAgICBoYXNNYXJrcyA9IGRsLmFycmF5KHRoaXMuX2RlZi5tYXJrcykubGVuZ3RoID4gMCxcbiAgICAgIGhhc0F4ZXMgPSBkbC5hcnJheSh0aGlzLl9kZWYuYXhlcykubGVuZ3RoID4gMCxcbiAgICAgIGhhc0xlZ2VuZHMgPSBkbC5hcnJheSh0aGlzLl9kZWYubGVnZW5kcykubGVuZ3RoID4gMCxcbiAgICAgIGksIGosIGMsIGxlbiwgZ3JvdXAsIHBpcGVsaW5lLCBkZWYsIGlubGluZSA9IGZhbHNlO1xuXG4gIGZvciAoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmIChoYXNNYXJrcykgYnVpbGRNYXJrcy5jYWxsKHRoaXMsIGlucHV0LCBncm91cCk7XG4gICAgaWYgKGhhc0F4ZXMpICBidWlsZEF4ZXMuY2FsbCh0aGlzLCBpbnB1dCwgZ3JvdXApO1xuICAgIGlmIChoYXNMZWdlbmRzKSBidWlsZExlZ2VuZHMuY2FsbCh0aGlzLCBpbnB1dCwgZ3JvdXApO1xuICB9XG5cbiAgLy8gV2lyZSB1cCBuZXcgY2hpbGRyZW4gYnVpbGRlcnMgaW4gcmV2ZXJzZSB0byBtaW5pbWl6ZSBncmFwaCByZXdyaXRlcy5cbiAgZm9yIChpPWlucHV0LmFkZC5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgZ3JvdXAgPSBpbnB1dC5hZGRbaV07XG4gICAgZm9yIChqPXRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ubGVuZ3RoLTE7IGo+PTA7IC0taikge1xuICAgICAgYyA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF1bal07XG4gICAgICBjLmJ1aWxkZXIuY29ubmVjdCgpO1xuICAgICAgcGlwZWxpbmUgPSBjLmJ1aWxkZXIucGlwZWxpbmUoKTtcbiAgICAgIGRlZiA9IGMuYnVpbGRlci5fZGVmO1xuXG4gICAgICAvLyBUaGlzIG5ldyBjaGlsZCBuZWVkcyB0byBiZSBidWlsdCBkdXJpbmcgdGhpcyBwcm9wYWdhdGlvbiBjeWNsZS5cbiAgICAgIC8vIFdlIGNvdWxkIGFkZCBpdHMgYnVpbGRlciBhcyBhIGxpc3RlbmVyIG9mZiB0aGUgX3JlY3Vyc29yIG5vZGUsIFxuICAgICAgLy8gYnV0IHRyeSB0byBpbmxpbmUgaXQgaWYgd2UgY2FuIHRvIG1pbmltaXplIGdyYXBoIGRpc3BhdGNoZXMuXG4gICAgICBpbmxpbmUgPSAoZGVmLnR5cGUgIT09IFR5cGVzLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PT0gMSk7IC8vIFJlYWN0aXZlIGdlb20gc291cmNlXG4gICAgICBpbmxpbmUgPSBpbmxpbmUgJiYgKGRlZi5mcm9tICYmICFkZWYuZnJvbS5tYXJrKTsgLy8gUmVhY3RpdmUgZ2VvbSB0YXJnZXRcbiAgICAgIGMuaW5saW5lID0gaW5saW5lO1xuXG4gICAgICBpZiAoaW5saW5lKSB0aGlzLl9ncmFwaC5ldmFsdWF0ZShpbnB1dCwgYy5idWlsZGVyKTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVUZW1wKGMpIHtcbiAgICBpZiAoYy50eXBlID09IFR5cGVzLk1BUksgJiYgIWMuaW5saW5lICYmXG4gICAgICAgIGJ1aWxkZXIuX2dyYXBoLmRhdGEoYy5mcm9tKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWlsZGVyLl9yZWN1cnNvci5yZW1vdmVMaXN0ZW5lcihjLmJ1aWxkZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUF4aXMoYSkgeyBcbiAgICB2YXIgc2NhbGUgPSBhLnNjYWxlKCk7XG4gICAgaWYgKCFpbnB1dC5zY2FsZXNbc2NhbGUuc2NhbGVOYW1lXSkgcmV0dXJuO1xuICAgIGEucmVzZXQoKS5kZWYoKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gdXBkYXRlTGVnZW5kKGwpIHsgXG4gICAgdmFyIHNjYWxlID0gbC5zaXplKCkgfHwgbC5zaGFwZSgpIHx8IGwuZmlsbCgpIHx8IGwuc3Ryb2tlKCk7XG4gICAgaWYgKCFpbnB1dC5zY2FsZXNbc2NhbGUuc2NhbGVOYW1lXSkgcmV0dXJuO1xuICAgIGwucmVzZXQoKS5kZWYoKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuXG4gICAgLy8gUmVtb3ZlIHRlbXBvcmFyeSBjb25uZWN0aW9uIGZvciBtYXJrcyB0aGF0IGRyYXcgZnJvbSBhIHNvdXJjZVxuICAgIGlmIChoYXNNYXJrcykgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKHJlbW92ZVRlbXApO1xuXG4gICAgLy8gVXBkYXRlIGF4aXMgZGF0YSBkZWZzXG4gICAgaWYgKGhhc0F4ZXMpIGdyb3VwLmF4ZXMuZm9yRWFjaCh1cGRhdGVBeGlzKTtcblxuICAgIC8vIFVwZGF0ZSBsZWdlbmQgZGF0YSBkZWZzXG4gICAgaWYgKGhhc0xlZ2VuZHMpIGdyb3VwLmxlZ2VuZHMuZm9yRWFjaCh1cGRhdGVMZWdlbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzY29ubmVjdENoaWxkcmVuKGMpIHsgXG4gICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICBjLmJ1aWxkZXIuZGlzY29ubmVjdCgpOyBcbiAgfVxuXG4gIGZvciAoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQucmVtW2ldO1xuICAgIC8vIEZvciBkZWxldGVkIGdyb3VwcywgZGlzY29ubmVjdCB0aGVpciBjaGlsZHJlblxuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0uZm9yRWFjaChkaXNjb25uZWN0Q2hpbGRyZW4pO1xuICAgIGRlbGV0ZSBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBzY2FsZShuYW1lLCB4KSB7XG4gIHZhciBncm91cCA9IHRoaXMsIHMgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIChncm91cC5fc2NhbGVzW25hbWVdID0geCwgeCk7XG4gIHdoaWxlIChzID09IG51bGwpIHtcbiAgICBzID0gZ3JvdXAuX3NjYWxlc1tuYW1lXTtcbiAgICBncm91cCA9IGdyb3VwLm1hcmsgPyBncm91cC5tYXJrLmdyb3VwIDogZ3JvdXAuX3BhcmVudDtcbiAgICBpZiAoIWdyb3VwKSBicmVhaztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gYnVpbGRHcm91cChpbnB1dCwgZ3JvdXApIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBncm91cFwiLCBncm91cC5faWRdKTtcblxuICBncm91cC5fc2NhbGVzID0gZ3JvdXAuX3NjYWxlcyB8fCB7fTsgICAgXG4gIGdyb3VwLnNjYWxlID0gc2NhbGUuYmluZChncm91cCk7XG5cbiAgZ3JvdXAuaXRlbXMgPSBncm91cC5pdGVtcyB8fCBbXTtcbiAgdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXSA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gfHwgW107XG5cbiAgZ3JvdXAuYXhlcyA9IGdyb3VwLmF4ZXMgfHwgW107XG4gIGdyb3VwLmF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcblxuICBncm91cC5sZWdlbmRzID0gZ3JvdXAubGVnZW5kcyB8fCBbXTtcbiAgZ3JvdXAubGVnZW5kSXRlbXMgPSBncm91cC5sZWdlbmRJdGVtcyB8fCBbXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNYXJrcyhpbnB1dCwgZ3JvdXApIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBjaGlsZHJlbiBtYXJrcyAjXCIrZ3JvdXAuX2lkXSk7XG4gIHZhciBtYXJrcyA9IHRoaXMuX2RlZi5tYXJrcyxcbiAgICAgIG1hcmssIGZyb20sIGluaGVyaXQsIGksIGxlbiwgYjtcblxuICBmb3IgKGk9MCwgbGVuPW1hcmtzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG1hcmsgPSBtYXJrc1tpXTtcbiAgICBmcm9tID0gbWFyay5mcm9tIHx8IHt9O1xuICAgIGluaGVyaXQgPSBncm91cC5kYXR1bS5fZmFjZXRJRDtcbiAgICBncm91cC5pdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIF9zY2FsZVJlZnM6IHt9fTtcbiAgICBiID0gKG1hcmsudHlwZSA9PT0gVHlwZXMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQodGhpcy5fZ3JhcGgsIG1hcmssIGdyb3VwLml0ZW1zW2ldLCB0aGlzLCBncm91cC5faWQsIGluaGVyaXQpO1xuICAgIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IFxuICAgICAgYnVpbGRlcjogYiwgXG4gICAgICBmcm9tOiBmcm9tLmRhdGEgfHwgKGZyb20ubWFyayA/IChcInZnX1wiICsgZ3JvdXAuX2lkICsgXCJfXCIgKyBmcm9tLm1hcmspIDogaW5oZXJpdCksIFxuICAgICAgdHlwZTogVHlwZXMuTUFSSyBcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEF4ZXMoaW5wdXQsIGdyb3VwKSB7XG4gIHZhciBheGVzID0gZ3JvdXAuYXhlcyxcbiAgICAgIGF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlQXhlcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmF4ZXMsIGF4ZXMsIGdyb3VwKTtcbiAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBidWlsZGVyLl9kZWYuYXhlc1tpXS5zY2FsZSxcbiAgICAgICAgZGVmID0gYS5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBheGlzSXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwLCBheGlzOiB0cnVlLCBsYXllcjogZGVmLmxheWVyfTtcbiAgICBiID0gKGRlZi50eXBlID09PSBUeXBlcy5HUk9VUCkgPyBuZXcgR3JvdXBCdWlsZGVyKCkgOiBuZXcgQnVpbGRlcigpO1xuICAgIGIuaW5pdChidWlsZGVyLl9ncmFwaCwgZGVmLCBheGlzSXRlbXNbaV0sIGJ1aWxkZXIpXG4gICAgICAuZGVwZW5kZW5jeShEZXBzLlNDQUxFUywgc2NhbGUpO1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IGJ1aWxkZXI6IGIsIHR5cGU6IFR5cGVzLkFYSVMsIHNjYWxlOiBzY2FsZSB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGVnZW5kcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRzLFxuICAgICAgbGVnZW5kSXRlbXMgPSBncm91cC5sZWdlbmRJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlTGVnZW5kcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmxlZ2VuZHMsIGxlZ2VuZHMsIGdyb3VwKTtcbiAgbGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGwsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBsLnNpemUoKSB8fCBsLnNoYXBlKCkgfHwgbC5maWxsKCkgfHwgbC5zdHJva2UoKSxcbiAgICAgICAgZGVmID0gbC5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBsZWdlbmRJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGxlZ2VuZDogdHJ1ZX07XG4gICAgYiA9IChkZWYudHlwZSA9PT0gVHlwZXMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQoYnVpbGRlci5fZ3JhcGgsIGRlZiwgbGVnZW5kSXRlbXNbaV0sIGJ1aWxkZXIpXG4gICAgICAuZGVwZW5kZW5jeShEZXBzLlNDQUxFUywgc2NhbGUpO1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IGJ1aWxkZXI6IGIsIHR5cGU6IFR5cGVzLkxFR0VORCwgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgTm9kZSA9IGRmLk5vZGUsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIERlcHMgPSBkZi5EZXBlbmRlbmNpZXMsXG4gICAgQWdncmVnYXRlID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9BZ2dyZWdhdGUnKTtcblxudmFyIFByb3BlcnRpZXMgPSB7XG4gIHdpZHRoOiAxLFxuICBoZWlnaHQ6IDFcbn07XG5cbnZhciBUeXBlcyA9IHtcbiAgTElORUFSOiAnbGluZWFyJyxcbiAgT1JESU5BTDogJ29yZGluYWwnLFxuICBMT0c6ICdsb2cnLFxuICBQT1dFUjogJ3BvdycsXG4gIFNRUlQ6ICdzcXJ0JyxcbiAgVElNRTogJ3RpbWUnLFxuICBUSU1FX1VUQzogJ3V0YycsXG4gIFFVQU5USUxFOiAncXVhbnRpbGUnLFxuICBRVUFOVElaRTogJ3F1YW50aXplJyxcbiAgVEhSRVNIT0xEOiAndGhyZXNob2xkJ1xufTtcblxudmFyIERhdGFSZWYgPSB7XG4gIERPTUFJTjogJ2RvbWFpbicsXG4gIFJBTkdFOiAncmFuZ2UnLFxuXG4gIENPVU5UOiAnY291bnQnLFxuICBHUk9VUEJZOiAnZ3JvdXBieScsXG4gIE1JTjogJ21pbicsXG4gIE1BWDogJ21heCcsXG4gIFZBTFVFOiAndmFsdWUnLFxuXG4gIEFTQzogJ2FzYycsXG4gIERFU0M6ICdkZXNjJ1xufTtcblxuZnVuY3Rpb24gU2NhbGUoZ3JhcGgsIGRlZiwgcGFyZW50KSB7XG4gIHRoaXMuX2RlZiAgICAgPSBkZWY7XG4gIHRoaXMuX3BhcmVudCAgPSBwYXJlbnQ7XG4gIHRoaXMuX3VwZGF0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCkucmVmbG93cyh0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKFNjYWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZuID0gZnVuY3Rpb24oZ3JvdXApIHsgc2NhbGUuY2FsbChzZWxmLCBncm91cCk7IH07XG5cbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICBpbnB1dC5hZGQuZm9yRWFjaChmbik7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZuKTtcblxuICAvLyBTY2FsZXMgYXJlIGF0IHRoZSBlbmQgb2YgYW4gZW5jb2RpbmcgcGlwZWxpbmUsIHNvIHRoZXkgc2hvdWxkIGZvcndhcmQgYVxuICAvLyByZWZsb3cgcHVsc2UuIFRodXMsIGlmIG11bHRpcGxlIHNjYWxlcyB1cGRhdGUgaW4gdGhlIHBhcmVudCBncm91cCwgd2UgZG9uJ3RcbiAgLy8gcmVldmFsdWF0ZSBjaGlsZCBtYXJrcyBtdWx0aXBsZSB0aW1lcy4gXG4gIGlmICh0aGlzLl91cGRhdGVkKSB7XG4gICAgaW5wdXQuc2NhbGVzW3RoaXMuX2RlZi5uYW1lXSA9IDE7XG4gICAgbG9nLmRlYnVnKGlucHV0LCBbXCJzY2FsZVwiLCB0aGlzLl9kZWYubmFtZV0pOyAgXG4gIH0gXG4gIHJldHVybiBkZi5DaGFuZ2VTZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcbn07XG5cbi8vIEFsbCBvZiBhIHNjYWxlJ3MgZGVwZW5kZW5jaWVzIGFyZSByZWdpc3RlcmVkIGR1cmluZyBwcm9wYWdhdGlvbiBhcyB3ZSBwYXJzZVxuLy8gZGF0YVJlZnMuIFNvIGEgc2NhbGUgbXVzdCBiZSByZXNwb25zaWJsZSBmb3IgY29ubmVjdGluZyBpdHNlbGYgdG8gZGVwZW5kZW50cy5cbnByb3RvLmRlcGVuZGVuY3kgPSBmdW5jdGlvbih0eXBlLCBkZXBzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgbWV0aG9kID0gKHR5cGUgPT09IERlcHMuREFUQSA/ICdkYXRhJyA6ICdzaWduYWwnKTtcbiAgICBkZXBzID0gZGwuYXJyYXkoZGVwcyk7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49ZGVwcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2dyYXBoW21ldGhvZF0oZGVwc1tpXSkuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuZGVwZW5kZW5jeS5jYWxsKHRoaXMsIHR5cGUsIGRlcHMpO1xufTtcblxuZnVuY3Rpb24gc2NhbGUoZ3JvdXApIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9kZWYubmFtZSxcbiAgICAgIHByZXYgPSBuYW1lICsgJzpwcmV2JyxcbiAgICAgIHMgPSBpbnN0YW5jZS5jYWxsKHRoaXMsIGdyb3VwLnNjYWxlKG5hbWUpKSxcbiAgICAgIG0gPSBzLnR5cGU9PT1UeXBlcy5PUkRJTkFMID8gb3JkaW5hbCA6IHF1YW50aXRhdGl2ZSxcbiAgICAgIHJuZyA9IHJhbmdlLmNhbGwodGhpcywgZ3JvdXApO1xuXG4gIG0uY2FsbCh0aGlzLCBzLCBybmcsIGdyb3VwKTtcblxuICBncm91cC5zY2FsZShuYW1lLCBzKTtcbiAgZ3JvdXAuc2NhbGUocHJldiwgZ3JvdXAuc2NhbGUocHJldikgfHwgcyk7XG5cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlKHNjYWxlKSB7XG4gIHZhciBjb25maWcgPSB0aGlzLl9ncmFwaC5jb25maWcoKSxcbiAgICAgIHR5cGUgPSB0aGlzLl9kZWYudHlwZSB8fCBUeXBlcy5MSU5FQVI7XG4gIGlmICghc2NhbGUgfHwgdHlwZSAhPT0gc2NhbGUudHlwZSkge1xuICAgIHZhciBjdG9yID0gY29uZmlnLnNjYWxlW3R5cGVdIHx8IGQzLnNjYWxlW3R5cGVdO1xuICAgIGlmICghY3RvcikgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSB0eXBlOiAnICsgdHlwZSk7XG4gICAgKHNjYWxlID0gY3RvcigpKS50eXBlID0gc2NhbGUudHlwZSB8fCB0eXBlO1xuICAgIHNjYWxlLnNjYWxlTmFtZSA9IHRoaXMuX2RlZi5uYW1lO1xuICAgIHNjYWxlLl9wcmV2ID0ge307XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkYXRhRHJpdmVuUmFuZ2UgPSBmYWxzZSxcbiAgICAgIHBhZCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5wYWRkaW5nKSB8fCAwLFxuICAgICAgb3V0ZXIgPSBkZWYub3V0ZXJQYWRkaW5nID09IG51bGwgPyBwYWQgOiBzaWduYWwuY2FsbCh0aGlzLCBkZWYub3V0ZXJQYWRkaW5nKSxcbiAgICAgIHBvaW50cyA9IGRlZi5wb2ludHMgJiYgc2lnbmFsLmNhbGwodGhpcywgZGVmLnBvaW50cyksXG4gICAgICByb3VuZCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yb3VuZCkgfHwgZGVmLnJvdW5kID09IG51bGwsXG4gICAgICBkb21haW4sIHN0cjtcbiAgXG4gIC8vIHJhbmdlIHByZS1wcm9jZXNzaW5nIGZvciBkYXRhLWRyaXZlbiByYW5nZXNcbiAgaWYgKGRsLmlzT2JqZWN0KGRlZi5yYW5nZSkgJiYgIWRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgIGRhdGFEcml2ZW5SYW5nZSA9IHRydWU7XG4gICAgcm5nID0gZGF0YVJlZi5jYWxsKHRoaXMsIERhdGFSZWYuUkFOR0UsIGRlZi5yYW5nZSwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuICBcbiAgLy8gZG9tYWluXG4gIGRvbWFpbiA9IGRhdGFSZWYuY2FsbCh0aGlzLCBEYXRhUmVmLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgaWYgKGRvbWFpbiAmJiAhZGwuZXF1YWwocHJldi5kb21haW4sIGRvbWFpbikpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICBwcmV2LmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgfSBcblxuICAvLyByYW5nZVxuICBpZiAoZGwuZXF1YWwocHJldi5yYW5nZSwgcm5nKSkgcmV0dXJuO1xuXG4gIC8vIHdpZHRoLWRlZmluZWQgcmFuZ2VcbiAgaWYgKGRlZi5iYW5kV2lkdGgpIHtcbiAgICB2YXIgYncgPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYuYmFuZFdpZHRoKSxcbiAgICAgICAgbGVuID0gZG9tYWluLmxlbmd0aCxcbiAgICAgICAgc3BhY2UgPSBkZWYucG9pbnRzID8gKHBhZCpidykgOiAocGFkKmJ3KihsZW4tMSkgKyAyKm91dGVyKSxcbiAgICAgICAgc3RhcnQ7XG4gICAgaWYgKHJuZ1swXSA+IHJuZ1sxXSkge1xuICAgICAgc3RhcnQgPSBybmdbMV0gfHwgMDtcbiAgICAgIHJuZyA9IFtzdGFydCArIChidyAqIGxlbiArIHNwYWNlKSwgc3RhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IHJuZ1swXSB8fCAwO1xuICAgICAgcm5nID0gW3N0YXJ0LCBzdGFydCArIChidyAqIGxlbiArIHNwYWNlKV07XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdHlwZW9mIHJuZ1swXSA9PT0gJ3N0cmluZyc7XG4gIGlmIChzdHIgfHwgcm5nLmxlbmd0aCA+IDIgfHwgcm5nLmxlbmd0aD09PTEgfHwgZGF0YURyaXZlblJhbmdlKSB7XG4gICAgc2NhbGUucmFuZ2Uocm5nKTsgLy8gY29sb3Igb3Igc2hhcGUgdmFsdWVzXG4gIH0gZWxzZSBpZiAocG9pbnRzICYmIHJvdW5kKSB7XG4gICAgc2NhbGUucmFuZ2VSb3VuZFBvaW50cyhybmcsIHBhZCk7XG4gIH0gZWxzZSBpZiAocG9pbnRzKSB7XG4gICAgc2NhbGUucmFuZ2VQb2ludHMocm5nLCBwYWQpO1xuICB9IGVsc2UgaWYgKHJvdW5kKSB7XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzKHJuZywgcGFkLCBvdXRlcik7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGUucmFuZ2VCYW5kcyhybmcsIHBhZCwgb3V0ZXIpO1xuICB9XG5cbiAgaWYgKCFzY2FsZS5pbnZlcnQpIHtcbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2NhbGUuZG9tYWluKClbZDMuYmlzZWN0KHNjYWxlLnJhbmdlKCksIHgpIC0gMV07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHsgIC8vIEludmVydCBleHRlbnRzXG4gICAgICAgIGlmICghZGwuaXNOdW1iZXIoeCkgfHwgIWRsLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4dGVudHMgdG8gb3JkaW5hbCBpbnZlcnQgYXJlIG5vdCBudW1iZXJzICgnK3grJywgJyt5KycpLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtdLFxuICAgICAgICAgICAgcm5nID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgICAgICAgIGkgPSAwLCBsZW4gPSBybmcubGVuZ3RoLCByO1xuXG4gICAgICAgIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICByID0gcm5nW2ldO1xuICAgICAgICAgIGlmICh4IDwgeSA/IHggPD0gciAmJiByIDw9IHkgOiB5IDw9IHIgJiYgciA8PSB4KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBzY2FsZS5pbnZlcnQocCk7IH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpdGF0aXZlKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICByb3VuZCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yb3VuZCksXG4gICAgICBleHBvbmVudCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5leHBvbmVudCksXG4gICAgICBjbGFtcCA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5jbGFtcCksXG4gICAgICBuaWNlID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLm5pY2UpLFxuICAgICAgZG9tYWluLCBpbnRlcnZhbDtcblxuICAvLyBkb21haW5cbiAgZG9tYWluID0gKGRlZi50eXBlID09PSBUeXBlcy5RVUFOVElMRSkgP1xuICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBEYXRhUmVmLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKSA6XG4gICAgZG9tYWluTWluTWF4LmNhbGwodGhpcywgc2NhbGUsIGdyb3VwKTtcbiAgaWYgKGRvbWFpbiAmJiAhZGwuZXF1YWwocHJldi5kb21haW4sIGRvbWFpbikpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICBwcmV2LmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgfSBcblxuICAvLyByYW5nZVxuICAvLyB2ZXJ0aWNhbCBzY2FsZXMgc2hvdWxkIGZsaXAgYnkgZGVmYXVsdCwgc28gdXNlIFhPUiBoZXJlXG4gIGlmIChzaWduYWwuY2FsbCh0aGlzLCBkZWYucmFuZ2UpID09PSAnaGVpZ2h0Jykgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcbiAgc2NhbGVbcm91bmQgJiYgc2NhbGUucmFuZ2VSb3VuZCA/ICdyYW5nZVJvdW5kJyA6ICdyYW5nZSddKHJuZyk7XG4gIHByZXYucmFuZ2UgPSBybmc7XG4gIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuXG4gIC8vIFRPRE86IFN1cHBvcnQgc2lnbmFscyBmb3IgdGhlc2UgcHJvcGVydGllcy4gVW50aWwgdGhlbiwgb25seSBldmFsXG4gIC8vIHRoZW0gb25jZS5cbiAgaWYgKHRoaXMuX3N0YW1wID4gMCkgcmV0dXJuO1xuICBpZiAoZXhwb25lbnQgJiYgZGVmLnR5cGU9PT1UeXBlcy5QT1dFUikgc2NhbGUuZXhwb25lbnQoZXhwb25lbnQpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAobmljZSkge1xuICAgIGlmIChkZWYudHlwZSA9PT0gVHlwZXMuVElNRSkge1xuICAgICAgaW50ZXJ2YWwgPSBkMy50aW1lW25pY2VdO1xuICAgICAgaWYgKCFpbnRlcnZhbCkgbG9nLmVycm9yKCdVbnJlY29nbml6ZWQgaW50ZXJ2YWw6ICcgKyBpbnRlcnZhbCk7XG4gICAgICBzY2FsZS5uaWNlKGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUubmljZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuaXF1ZXMoc2NhbGUpIHsgXG4gIHJldHVybiBzY2FsZS50eXBlID09PSBUeXBlcy5PUkRJTkFMIHx8IHNjYWxlLnR5cGUgPT09IFR5cGVzLlFVQU5USUxFOyBcbn1cblxuZnVuY3Rpb24gZ2V0UmVmcyhkZWYpIHsgXG4gIHJldHVybiBkZWYuZmllbGRzIHx8IGRsLmFycmF5KGRlZik7XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKHJlZnMpIHtcbiAgcmV0dXJuIHJlZnMuc29tZShmdW5jdGlvbihyKSB7XG4gICAgaWYgKCFyLmRhdGEpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiByLmRhdGEgJiYgZGwuYXJyYXkoci5maWVsZCkuc29tZShmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZi5wYXJlbnQ7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGaWVsZHMocmVmLCBncm91cCkge1xuICByZXR1cm4gZGwuYXJyYXkocmVmLmZpZWxkKS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmLnBhcmVudCA/XG4gICAgICBkbC5hY2Nlc3NvcihmLnBhcmVudCkoZ3JvdXAuZGF0dW0pIDpcbiAgICAgIGY7IC8vIFN0cmluZyBvciB7J3NpZ25hbCd9XG4gIH0pO1xufVxuXG4vLyBTY2FsZSBkYXRhcmVmcyBjYW4gYmUgY29tcHV0ZWQgb3ZlciBtdWx0aXBsZSBzY2hlbWEgdHlwZXMuIFxuLy8gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIGFnZ3JlZ2F0b3IgY3JlYXRlZCwgYW5kXG4vLyB3aGF0IGRhdGEgaXMgc2VudCB0byBpdDogdmFsdWVzLCB0dXBsZXMsIG9yIG11bHRpLXR1cGxlcyB0aGF0IG11c3Rcbi8vIGJlIHN0YW5kYXJkaXplZCBpbnRvIGEgY29uc2lzdGVudCBzY2hlbWEuIFxuZnVuY3Rpb24gYWdnclR5cGUoZGVmLCBzY2FsZSkge1xuICB2YXIgcmVmcyA9IGdldFJlZnMoZGVmKTtcblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgb3ZlciBvbmx5IGEgc2luZ2xlIGRvbWFpbiwgc2VuZCBmdWxsIHR1cGxlc1xuICAvLyB0aHJvdWdoIGZvciBlZmZpY2llbmN5IChmZXdlciBhY2Nlc3NvciBjcmVhdGlvbnMvY2FsbHMpXG4gIGlmIChyZWZzLmxlbmd0aCA9PSAxICYmIGRsLmFycmF5KHJlZnNbMF0uZmllbGQpLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0ZS5UWVBFUy5UVVBMRTtcbiAgfVxuXG4gIC8vIFdpdGggcXVhbnRpdGF0aXZlIHNjYWxlcywgd2Ugb25seSBjYXJlIGFib3V0IG1pbi9tYXguXG4gIGlmICghaXNVbmlxdWVzKHNjYWxlKSkgcmV0dXJuIEFnZ3JlZ2F0ZS5UWVBFUy5WQUxVRTtcblxuICAvLyBJZiB3ZSBkb24ndCBzb3J0LCB0aGVuIHdlIGNhbiBzZW5kIHZhbHVlcyBkaXJlY3RseSB0byBhZ2dycyBhcyB3ZWxsXG4gIGlmICghZGwuaXNPYmplY3QoZGVmLnNvcnQpKSByZXR1cm4gQWdncmVnYXRlLlRZUEVTLlZBTFVFO1xuXG4gIHJldHVybiBBZ2dyZWdhdGUuVFlQRVMuTVVMVEk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlKHdoaWNoLCBkZWYsIHNjYWxlLCBncm91cCkge1xuICB2YXIgcmVmcyA9IGdldFJlZnMoZGVmKSxcbiAgICAgIGluaGVyaXQgPSBpbmhlcml0cyhyZWZzKSxcbiAgICAgIGF0eXBlID0gYWdnclR5cGUoZGVmLCBzY2FsZSksXG4gICAgICB1bmlxdWVzID0gaXNVbmlxdWVzKHNjYWxlKSxcbiAgICAgIHNvcnQgPSBkZWYuc29ydCxcbiAgICAgIGNrID0gJ18nK3doaWNoLFxuICAgICAgZmllbGRzID0gZ2V0RmllbGRzKHJlZnNbMF0sIGdyb3VwKTtcblxuICBpZiAoc2NhbGVbY2tdIHx8IHRoaXNbY2tdKSByZXR1cm4gc2NhbGVbY2tdIHx8IHRoaXNbY2tdO1xuXG4gIHZhciBjYWNoZSA9IG5ldyBBZ2dyZWdhdGUodGhpcy5fZ3JhcGgpLnR5cGUoYXR5cGUpLFxuICAgICAgZ3JvdXBieSwgc3VtbWFyaXplO1xuXG4gIC8vIElmIGEgc2NhbGUncyBkYXRhcmVmIGRvZXNuJ3QgaW5oZXJpdCBkYXRhIGZyb20gdGhlIGdyb3VwLCB3ZSBjYW5cbiAgLy8gc3RvcmUgdGhlIGRhdGFyZWYgYWdncmVnYXRvciBhdCB0aGUgU2NhbGUgKGRhdGFmbG93IG5vZGUpIGxldmVsLiBcbiAgaWYgKGluaGVyaXQpIHtcbiAgICBzY2FsZVtja10gPSBjYWNoZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzW2NrXSAgPSBjYWNoZTtcbiAgfVxuXG4gIGlmICh1bmlxdWVzKSB7XG4gICAgaWYgKGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuVkFMVUUpIHtcbiAgICAgIGdyb3VwYnkgPSBbeyBuYW1lOiBEYXRhUmVmLkdST1VQQlksIGdldDogZGwuaWRlbnRpdHkgfV07XG4gICAgICBzdW1tYXJpemUgPSB7JyonOiBEYXRhUmVmLkNPVU5UfTtcbiAgICB9IGVsc2UgaWYgKGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuVFVQTEUpIHtcbiAgICAgIGdyb3VwYnkgPSBbeyBuYW1lOiBEYXRhUmVmLkdST1VQQlksIGdldDogZGwuJChmaWVsZHNbMF0pIH1dO1xuICAgICAgc3VtbWFyaXplID0gZGwuaXNPYmplY3Qoc29ydCkgPyBbe1xuICAgICAgICBmaWVsZDogRGF0YVJlZi5WQUxVRSxcbiAgICAgICAgZ2V0OiAgZGwuJChzb3J0LmZpZWxkKSxcbiAgICAgICAgb3BzOiBbc29ydC5vcF1cbiAgICAgIH1dIDogeycqJzogRGF0YVJlZi5DT1VOVH07XG4gICAgfSBlbHNlIHsgIC8vIGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuTVVMVElcbiAgICAgIGdyb3VwYnkgICA9IERhdGFSZWYuR1JPVVBCWTtcbiAgICAgIHN1bW1hcml6ZSA9IFt7IGZpZWxkOiBEYXRhUmVmLlZBTFVFLCBvcHM6IFtzb3J0Lm9wXSB9XTsgXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdyb3VwYnkgPSBbXTtcbiAgICBzdW1tYXJpemUgPSBbe1xuICAgICAgZmllbGQ6IERhdGFSZWYuVkFMVUUsXG4gICAgICBnZXQ6IChhdHlwZSA9PSBBZ2dyZWdhdGUuVFlQRVMuVFVQTEUpID8gZGwuJChmaWVsZHNbMF0pIDogZGwuaWRlbnRpdHksXG4gICAgICBvcHM6IFtEYXRhUmVmLk1JTiwgRGF0YVJlZi5NQVhdLFxuICAgICAgYXM6ICBbRGF0YVJlZi5NSU4sIERhdGFSZWYuTUFYXVxuICAgIH1dO1xuICB9XG5cbiAgY2FjaGUucGFyYW0oJ2dyb3VwYnknLCBncm91cGJ5KVxuICAgIC5wYXJhbSgnc3VtbWFyaXplJywgc3VtbWFyaXplKTtcblxuICByZXR1cm4gKGNhY2hlLl9sYXN0VXBkYXRlID0gLTEsIGNhY2hlKTtcbn1cblxuZnVuY3Rpb24gZGF0YVJlZih3aGljaCwgZGVmLCBzY2FsZSwgZ3JvdXApIHtcbiAgaWYgKGRlZiA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuICBpZiAoZGwuaXNBcnJheShkZWYpKSByZXR1cm4gZGVmLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLCBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgcmVmcyA9IGdldFJlZnMoZGVmKSxcbiAgICAgIGluaGVyaXQgPSBpbmhlcml0cyhyZWZzKSxcbiAgICAgIGF0eXBlID0gYWdnclR5cGUoZGVmLCBzY2FsZSksXG4gICAgICBjYWNoZSA9IGdldENhY2hlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBzb3J0ICA9IGRlZi5zb3J0LFxuICAgICAgdW5pcXVlcyA9IGlzVW5pcXVlcyhzY2FsZSksXG4gICAgICBpLCBybGVuLCBqLCBmbGVuLCByZWYsIGZpZWxkcywgZmllbGQsIGRhdGEsIGZyb20sIHNvLCBjbXA7XG5cbiAgZnVuY3Rpb24gYWRkRGVwKHMpIHtcbiAgICBzZWxmLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCBzKTtcbiAgfVxuXG4gIGlmIChpbmhlcml0IHx8ICghaW5oZXJpdCAmJiBjYWNoZS5fbGFzdFVwZGF0ZSA8IHRoaXMuX3N0YW1wKSkge1xuICAgIGZvciAoaT0wLCBybGVuPXJlZnMubGVuZ3RoOyBpPHJsZW47ICsraSkge1xuICAgICAgcmVmID0gcmVmc1tpXTtcbiAgICAgIGZyb20gPSByZWYuZGF0YSB8fCBncm91cC5kYXR1bS5fZmFjZXRJRDtcbiAgICAgIGRhdGEgPSBncmFwaC5kYXRhKGZyb20pLmxhc3QoKTtcblxuICAgICAgaWYgKGRhdGEuc3RhbXAgPD0gdGhpcy5fc3RhbXApIGNvbnRpbnVlO1xuXG4gICAgICBmaWVsZHMgPSBnZXRGaWVsZHMocmVmLCBncm91cCk7XG4gICAgICBmb3IgKGo9MCwgZmxlbj1maWVsZHMubGVuZ3RoOyBqPGZsZW47ICsraikge1xuICAgICAgICBmaWVsZCA9IGZpZWxkc1tqXTtcblxuICAgICAgICBpZiAoYXR5cGUgPT09IEFnZ3JlZ2F0ZS5UWVBFUy5WQUxVRSkge1xuICAgICAgICAgIGNhY2hlLmFjY2Vzc29ycyhudWxsLCBmaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR5cGUgPT09IEFnZ3JlZ2F0ZS5UWVBFUy5NVUxUSSkge1xuICAgICAgICAgIGNhY2hlLmFjY2Vzc29ycyhmaWVsZCwgcmVmLnNvcnQgfHwgc29ydC5maWVsZCk7XG4gICAgICAgIH0gLy8gRWxzZSAoVHVwbGUtY2FzZSkgaXMgaGFuZGxlZCBieSB0aGUgYWdncmVnYXRvciBhY2Nlc3NvcnMgYnkgZGVmYXVsdFxuXG4gICAgICAgIGNhY2hlLmV2YWx1YXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlcGVuZGVuY3koRGVwcy5EQVRBLCBmcm9tKTtcbiAgICAgIGNhY2hlLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTKS5mb3JFYWNoKGFkZERlcCk7XG4gICAgfVxuXG4gICAgY2FjaGUuX2xhc3RVcGRhdGUgPSB0aGlzLl9zdGFtcDtcblxuICAgIGRhdGEgPSBjYWNoZS5hZ2dyKCkucmVzdWx0KCk7XG4gICAgaWYgKHVuaXF1ZXMpIHtcbiAgICAgIGlmIChkbC5pc09iamVjdChzb3J0KSkge1xuICAgICAgICBjbXAgPSAoc28gPSBzb3J0Lm9yZGVyKSAmJiBzby5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc28uc2lnbmFsKSA6IHNvO1xuICAgICAgICBjbXAgPSAoY21wID09IERhdGFSZWYuREVTQyA/ICctJyA6ICcrJykgKyBzb3J0Lm9wICsgJ18nICsgRGF0YVJlZi5WQUxVRTtcbiAgICAgICAgY21wID0gZGwuY29tcGFyYXRvcihjbXApO1xuICAgICAgfSBlbHNlIGlmIChzb3J0ID09PSB0cnVlKSB7XG4gICAgICAgIGNtcCA9IGRsLmNvbXBhcmF0b3IoRGF0YVJlZi5HUk9VUEJZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNtcCkgZGF0YSA9IGRhdGEuc29ydChjbXApO1xuICAgICAgY2FjaGUuX3ZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbRGF0YVJlZi5HUk9VUEJZXTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgY2FjaGUuX3ZhbHVlcyA9ICFkbC5pc1ZhbGlkKGRhdGEpID8gW10gOiBbZGF0YVtEYXRhUmVmLk1JTl0sIGRhdGFbRGF0YVJlZi5NQVhdXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FjaGUuX3ZhbHVlcztcbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgaWYgKCF2IHx8ICF2LnNpZ25hbCkgcmV0dXJuIHY7XG4gIHZhciBzID0gdi5zaWduYWwsIHJlZjtcbiAgdGhpcy5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgKHJlZiA9IGRsLmZpZWxkKHMpKVswXSk7XG4gIHJldHVybiB0aGlzLl9ncmFwaC5zaWduYWxSZWYocmVmKTtcbn1cblxuZnVuY3Rpb24gZG9tYWluTWluTWF4KHNjYWxlLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgZG9tYWluID0gW251bGwsIG51bGxdLCBzLCB6O1xuXG4gIGlmIChkZWYuZG9tYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICBkb21haW4gPSAoIWRsLmlzT2JqZWN0KGRlZi5kb21haW4pKSA/IGRvbWFpbiA6XG4gICAgICBkYXRhUmVmLmNhbGwodGhpcywgRGF0YVJlZi5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIH1cblxuICB6ID0gZG9tYWluLmxlbmd0aCAtIDE7XG4gIGlmIChkZWYuZG9tYWluTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGwuaXNPYmplY3QoZGVmLmRvbWFpbk1pbikpIHtcbiAgICAgIGlmIChkZWYuZG9tYWluTWluLnNpZ25hbCkge1xuICAgICAgICBkb21haW5bMF0gPSBkbC5pc1ZhbGlkKHM9c2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1pbikpID8gcyA6IGRvbWFpblswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbWFpblswXSA9IGRhdGFSZWYuY2FsbCh0aGlzLCBEYXRhUmVmLkRPTUFJTitEYXRhUmVmLk1JTiwgZGVmLmRvbWFpbk1pbiwgc2NhbGUsIGdyb3VwKVswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZG9tYWluWzBdID0gZGVmLmRvbWFpbk1pbjtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5kb21haW5NYXggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWF4KSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NYXguc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblt6XSA9IGRsLmlzVmFsaWQocz1zaWduYWwuY2FsbCh0aGlzLCBkZWYuZG9tYWluTWF4KSkgPyBzIDogZG9tYWluW3pdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluW3pdID0gZGF0YVJlZi5jYWxsKHRoaXMsIERhdGFSZWYuRE9NQUlOK0RhdGFSZWYuTUFYLCBkZWYuZG9tYWluTWF4LCBzY2FsZSwgZ3JvdXApWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bel0gPSBkZWYuZG9tYWluTWF4O1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLnR5cGUgIT09IFR5cGVzLkxPRyAmJiBkZWYudHlwZSAhPT0gVHlwZXMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBjb25maWcgPSB0aGlzLl9ncmFwaC5jb25maWcoKSxcbiAgICAgIHJhbmdlVmFsID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlKSxcbiAgICAgIHJuZyA9IFtudWxsLCBudWxsXTtcblxuICBpZiAocmFuZ2VWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmFuZ2VWYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoUHJvcGVydGllc1tyYW5nZVZhbF0pIHtcbiAgICAgICAgcm5nID0gWzAsIGdyb3VwW3JhbmdlVmFsXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtyYW5nZVZhbF0pIHtcbiAgICAgICAgcm5nID0gY29uZmlnLnJhbmdlW3JhbmdlVmFsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZy5lcnJvcignVW5yZWNvZ2l6ZWQgcmFuZ2U6ICcgKyByYW5nZVZhbCk7XG4gICAgICAgIHJldHVybiBybmc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkbC5pc0FycmF5KHJhbmdlVmFsKSkge1xuICAgICAgcm5nID0gZGwuZHVwbGljYXRlKHJhbmdlVmFsKS5tYXAoc2lnbmFsLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSBpZiAoZGwuaXNPYmplY3QocmFuZ2VWYWwpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgcmFuZ2VWYWxdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLnJhbmdlTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICBybmdbMF0gPSBkZWYucmFuZ2VNaW4uc2lnbmFsID9cbiAgICAgIHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOlxuICAgICAgZGVmLnJhbmdlTWluO1xuICB9XG4gIGlmIChkZWYucmFuZ2VNYXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJuZ1tybmcubGVuZ3RoLTFdID0gZGVmLnJhbmdlTWF4LnNpZ25hbCA/XG4gICAgICBzaWduYWwuY2FsbCh0aGlzLCBkZWYucmFuZ2VNYXgpIDpcbiAgICAgIGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJldmVyc2UpO1xuICAgIGlmIChkbC5pc09iamVjdChyZXYpKSB7XG4gICAgICByZXYgPSBkbC5hY2Nlc3NvcihyZXYuZmllbGQpKGdyb3VwLmRhdHVtKTtcbiAgICB9XG4gICAgaWYgKHJldikgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgfVxuICBcbiAgcmV0dXJuIHJuZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2QzJ10gOiBudWxsKSxcbiAgICBib3VuZCA9IHJlcXVpcmUoJ3ZlZ2Etc2NlbmVncmFwaCcpLmJvdW5kLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIFN0YXR1cyA9IHJlcXVpcmUoJy4vQnVpbGRlcicpLlNUQVRVUztcblxuZnVuY3Rpb24gVHJhbnNpdGlvbihkdXJhdGlvbiwgZWFzZSkge1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb24gfHwgNTAwO1xuICB0aGlzLmVhc2UgPSBlYXNlICYmIGQzLmVhc2UoZWFzZSkgfHwgZDMuZWFzZSgnY3ViaWMtaW4tb3V0Jyk7XG4gIHRoaXMudXBkYXRlcyA9IHtuZXh0OiBudWxsfTtcbn1cblxudmFyIHByb3RvdHlwZSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG52YXIgc2tpcCA9IHtcbiAgJ3RleHQnOiAxLFxuICAndXJsJzogIDFcbn07XG5cbnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlcykge1xuICB2YXIga2V5LCBjdXJyLCBuZXh0LCBpbnRlcnAsIGxpc3QgPSBudWxsO1xuXG4gIGZvciAoa2V5IGluIHZhbHVlcykge1xuICAgIGN1cnIgPSBpdGVtW2tleV07XG4gICAgbmV4dCA9IHZhbHVlc1trZXldOyAgICAgIFxuICAgIGlmIChjdXJyICE9PSBuZXh0KSB7XG4gICAgICBpZiAoc2tpcFtrZXldIHx8IGN1cnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBza2lwIGludGVycG9sYXRpb24gZm9yIHNwZWNpZmljIGtleXMgb3IgdW5kZWZpbmVkIHN0YXJ0IHZhbHVlc1xuICAgICAgICBUdXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnIgPT09ICdudW1iZXInICYmICFpc0Zpbml0ZShjdXJyKSkge1xuICAgICAgICAvLyBmb3IgTmFOIG9yIGluZmluaXRlIG51bWVyaWMgdmFsdWVzLCBza2lwIHRvIGZpbmFsIHZhbHVlXG4gICAgICAgIFR1cGxlLnNldChpdGVtLCBrZXksIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxvb2t1cCBpbnRlcnBvbGF0b3JcbiAgICAgICAgaW50ZXJwID0gZDMuaW50ZXJwb2xhdGUoY3VyciwgbmV4dCk7XG4gICAgICAgIGludGVycC5wcm9wZXJ0eSA9IGtleTtcbiAgICAgICAgKGxpc3QgfHwgKGxpc3Q9W10pKS5wdXNoKGludGVycCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpc3QgPT09IG51bGwgJiYgaXRlbS5zdGF0dXMgPT09IFN0YXR1cy5FWElUKSB7XG4gICAgbGlzdCA9IFtdOyAvLyBlbnN1cmUgZXhpdGluZyBpdGVtcyBhcmUgaW5jbHVkZWRcbiAgfVxuXG4gIGlmIChsaXN0ICE9IG51bGwpIHtcbiAgICBsaXN0Lml0ZW0gPSBpdGVtO1xuICAgIGxpc3QuZWFzZSA9IGl0ZW0ubWFyay5lYXNlIHx8IHRoaXMuZWFzZTtcbiAgICBsaXN0Lm5leHQgPSB0aGlzLnVwZGF0ZXMubmV4dDtcbiAgICB0aGlzLnVwZGF0ZXMubmV4dCA9IGxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdCA9IHRoaXMsIHByZXYgPSB0LnVwZGF0ZXMsIGN1cnIgPSBwcmV2Lm5leHQ7XG4gIGZvciAoOyBjdXJyIT1udWxsOyBwcmV2PWN1cnIsIGN1cnI9cHJldi5uZXh0KSB7XG4gICAgaWYgKGN1cnIuaXRlbS5zdGF0dXMgPT09IFN0YXR1cy5FWElUKSB7XG4gICAgICAvLyBPbmx5IG1hcmsgaXRlbSBhcyBleGl0ZWQgd2hlbiBpdCBpcyByZW1vdmVkLlxuICAgICAgY3Vyci5pdGVtLnN0YXR1cyA9IFN0YXR1cy5VUERBVEU7XG4gICAgICBjdXJyLnJlbW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHQuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgZDMudGltZXIoZnVuY3Rpb24oZWxhcHNlZCkgeyByZXR1cm4gc3RlcC5jYWxsKHQsIGVsYXBzZWQpOyB9KTtcbn07XG5cbmZ1bmN0aW9uIHN0ZXAoZWxhcHNlZCkge1xuICB2YXIgbGlzdCA9IHRoaXMudXBkYXRlcywgcHJldiA9IGxpc3QsIGN1cnIgPSBwcmV2Lm5leHQsXG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICBpdGVtLCBkZWxheSwgZiwgZSwgaSwgbiwgc3RvcCA9IHRydWU7XG5cbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpdGVtID0gY3Vyci5pdGVtO1xuICAgIGRlbGF5ID0gaXRlbS5kZWxheSB8fCAwO1xuXG4gICAgZiA9IChlbGFwc2VkIC0gZGVsYXkpIC8gZHVyYXRpb247XG4gICAgaWYgKGYgPCAwKSB7IHN0b3AgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBpZiAoZiA+IDEpIGYgPSAxO1xuICAgIGUgPSBjdXJyLmVhc2UoZik7XG5cbiAgICBmb3IgKGk9MCwgbj1jdXJyLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGl0ZW1bY3VycltpXS5wcm9wZXJ0eV0gPSBjdXJyW2ldKGUpO1xuICAgIH1cbiAgICBpdGVtLnRvdWNoKCk7XG4gICAgYm91bmQuaXRlbShpdGVtKTtcblxuICAgIGlmIChmID09PSAxKSB7XG4gICAgICBpZiAoY3Vyci5yZW1vdmUpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBTdGF0dXMuRVhJVDtcbiAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHByZXYubmV4dCA9IGN1cnIubmV4dDtcbiAgICAgIGN1cnIgPSBwcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWxsYmFjaygpO1xuICByZXR1cm4gc3RvcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBwYXJzZU1hcmsgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrJyk7XG5cbnZhciBUSU1FICAgID0gJ3RpbWUnLFxuICAgIFVUQyAgICAgPSAndXRjJyxcbiAgICBTVFJJTkcgID0gJ3N0cmluZycsXG4gICAgT1JESU5BTCA9ICdvcmRpbmFsJyxcbiAgICBOVU1CRVIgID0gJ251bWJlcic7XG5cbmZ1bmN0aW9uIGF4cyhtb2RlbCkge1xuICB2YXIgc2NhbGUsXG4gICAgICBjb25maWcgPSBtb2RlbC5jb25maWcoKSxcbiAgICAgIG9yaWVudCA9IGNvbmZpZy5heGlzLm9yaWVudCxcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICB0aXRsZU9mZnNldCA9IGNvbmZpZy5heGlzLnRpdGxlT2Zmc2V0LFxuICAgICAgYXhpc0RlZiA9IHt9LFxuICAgICAgbGF5ZXIgPSAnZnJvbnQnLFxuICAgICAgZ3JpZCA9IGZhbHNlLFxuICAgICAgdGl0bGUgPSBudWxsLFxuICAgICAgdGlja01ham9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja01pbm9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja0VuZFNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tQYWRkaW5nID0gY29uZmlnLmF4aXMucGFkZGluZyxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdFN0cmluZyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0VHlwZSA9IG51bGwsXG4gICAgICB0aWNrU3ViZGl2aWRlID0gMCxcbiAgICAgIHRpY2tDb3VudCA9IGNvbmZpZy5heGlzLnRpY2tzLFxuICAgICAgZ3JpZExpbmVTdHlsZSA9IHt9LFxuICAgICAgdGlja0xhYmVsU3R5bGUgPSB7fSxcbiAgICAgIG1ham9yVGlja1N0eWxlID0ge30sXG4gICAgICBtaW5vclRpY2tTdHlsZSA9IHt9LFxuICAgICAgdGl0bGVTdHlsZSA9IHt9LFxuICAgICAgZG9tYWluU3R5bGUgPSB7fSxcbiAgICAgIG0gPSB7IC8vIEF4aXMgbWFya3MgYXMgcmVmZXJlbmNlcyBmb3IgdXBkYXRlc1xuICAgICAgICBncmlkTGluZXM6ICB7fSxcbiAgICAgICAgbWFqb3JUaWNrczoge30sXG4gICAgICAgIG1pbm9yVGlja3M6IHt9LFxuICAgICAgICB0aWNrTGFiZWxzOiB7fSxcbiAgICAgICAgZG9tYWluOiB7fSxcbiAgICAgICAgdGl0bGU6ICB7fVxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpbmdlc3QoZCkge1xuICAgIHJldHVybiB7ZGF0YTogZH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaWNrRm9ybWF0KCkge1xuICAgIHZhciBmb3JtYXRUeXBlID0gdGlja0Zvcm1hdFR5cGUgfHwgaW5mZXJGb3JtYXRUeXBlKCk7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlcihmb3JtYXRUeXBlLCB0aWNrRm9ybWF0U3RyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZmVyRm9ybWF0VHlwZSgpIHtcbiAgICBzd2l0Y2ggKHNjYWxlLnR5cGUpIHtcbiAgICAgIGNhc2UgVElNRTogICAgcmV0dXJuIFRJTUU7XG4gICAgICBjYXNlIFVUQzogICAgIHJldHVybiBVVEM7XG4gICAgICBjYXNlIE9SRElOQUw6IHJldHVybiBTVFJJTkc7XG4gICAgICBkZWZhdWx0OiAgICAgIHJldHVybiBOVU1CRVI7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRhcHRlZCBmcm9tIGQzIGxvZyBzY2FsZVxuICAvLyBUT0RPIGN1c3RvbWl6ZT8gcmVwbGFjZSB3aXRoIHJhbmdlLXNpemUtYXdhcmUgZmlsdGVyaW5nP1xuICBmdW5jdGlvbiBsb2dGaWx0ZXIoZG9tYWluLCBjb3VudCwgZikge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSByZXR1cm4gZjtcbiAgICB2YXIgYmFzZSA9IHNjYWxlLmJhc2UoKSxcbiAgICAgICAgayA9IE1hdGgubWluKGJhc2UsIHNjYWxlLnRpY2tzKCkubGVuZ3RoIC8gY291bnQpLFxuICAgICAgICB2ID0gZG9tYWluWzBdID4gMCA/IChlID0gMWUtMTIsIE1hdGguY2VpbCkgOiAoZSA9IC0xZS0xMiwgTWF0aC5mbG9vciksXG4gICAgICAgIGU7XG4gICAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgIHJldHVybiAoZG9tYWluWzBdIDwgMCA/XG4gICAgICAgIC1NYXRoLmxvZyh4ID4gMCA/IDAgOiAteCkgOlxuICAgICAgICBNYXRoLmxvZyh4IDwgMCA/IDAgOiB4KSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93KHgpIHtcbiAgICAgIHJldHVybiBkb21haW5bMF0gPCAwID8gLU1hdGgucG93KGJhc2UsIC14KSA6IE1hdGgucG93KGJhc2UsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHBvdyh2KGxvZyhkKSArIGUpKSAvIGQgPj0gayA/IGYoZCkgOiAnJztcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKGZvcm1hdFR5cGUsIHN0cikge1xuICAgIHZhciBmbXQgPSBkbC5mb3JtYXQsXG4gICAgICAgIGxvZyA9IHNjYWxlLnR5cGUgPT09ICdsb2cnLFxuICAgICAgICBkb21haW4sIGY7XG5cbiAgICBzd2l0Y2ggKGZvcm1hdFR5cGUpIHtcbiAgICAgIGNhc2UgTlVNQkVSOlxuICAgICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG4gICAgICAgICBmID0gZm10LmF1dG8ubnVtYmVyKGRvbWFpbiwgdGlja0NvdW50LCBzdHIgfHwgKGxvZyA/ICcuMXInIDogbnVsbCkpO1xuICAgICAgICAgcmV0dXJuIGxvZyA/IGxvZ0ZpbHRlcihkb21haW4sIHRpY2tDb3VudCwgZikgOiBmO1xuICAgICAgY2FzZSBUSU1FOiByZXR1cm4gKHN0ciA/IGZtdCA6IGZtdC5hdXRvKS50aW1lKHN0cik7XG4gICAgICBjYXNlIFVUQzogIHJldHVybiAoc3RyID8gZm10IDogZm10LmF1dG8pLnV0YyhzdHIpO1xuICAgICAgZGVmYXVsdDogICByZXR1cm4gU3RyaW5nO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0VGlja3MoZm9ybWF0KSB7XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyB8fCAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcyh0aWNrQ291bnQpIDogc2NhbGUuZG9tYWluKCkpLFxuICAgICAgICBtaW5vciA9IGF4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5nZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAoZCA9IGluZ2VzdChkKSwgZC5sYWJlbCA9IGZvcm1hdChkLmRhdGEpLCBkKTsgfSk7XG4gICAgcmV0dXJuIFttYWpvciwgbWlub3JdO1xuICB9XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWF4aXNEZWYudHlwZSkgYXhpc19kZWYoc2NhbGUpO1xuXG4gICAgdmFyIHRpY2tzID0gZ2V0VGlja3MoZ2V0VGlja0Zvcm1hdCgpKTtcbiAgICB2YXIgdGRhdGEgPSB0aXRsZSA/IFt0aXRsZV0ubWFwKGluZ2VzdCkgOiBbXTtcblxuICAgIGF4aXNEZWYubWFya3NbMF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ3JpZCA/IHRpY2tzWzBdIDogW107IH07XG4gICAgYXhpc0RlZi5tYXJrc1sxXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aWNrc1swXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzJdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRpY2tzWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbM10uZnJvbSA9IGF4aXNEZWYubWFya3NbMV0uZnJvbTtcbiAgICBheGlzRGVmLm1hcmtzWzRdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIFsxXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzVdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRkYXRhOyB9O1xuICAgIGF4aXNEZWYub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGF4aXNEZWYub3JpZW50ID0gb3JpZW50O1xuICAgIGF4aXNEZWYubGF5ZXIgPSBsYXllcjtcblxuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBPUkRJTkFMKSB7XG4gICAgICBuZXdTY2FsZSA9IHtzY2FsZTogc2NhbGUuc2NhbGVOYW1lLCBvZmZzZXQ6IDAuNSArIHNjYWxlLnJhbmdlQmFuZCgpLzJ9O1xuICAgICAgb2xkU2NhbGUgPSBuZXdTY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjV9O1xuICAgICAgb2xkU2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSsnOnByZXYnLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcywgYXhpc1RpY2tzKGNvbmZpZykpO1xuICAgIGRsLmV4dGVuZChtLm1ham9yVGlja3MsIGF4aXNUaWNrcyhjb25maWcpKTtcbiAgICBkbC5leHRlbmQobS5taW5vclRpY2tzLCBheGlzVGlja3MoY29uZmlnKSk7XG4gICAgZGwuZXh0ZW5kKG0udGlja0xhYmVscywgYXhpc1RpY2tMYWJlbHMoY29uZmlnKSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLCBheGlzRG9tYWluKGNvbmZpZykpO1xuICAgIGRsLmV4dGVuZChtLnRpdGxlLCBheGlzVGl0bGUoY29uZmlnKSk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2VPcGFjaXR5ID0ge3ZhbHVlOiBjb25maWcuYXhpcy5ncmlkT3BhY2l0eX07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIGF4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICBheGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIGF4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICBheGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7IFxuICAgICAgICBlbnRlcjoge1xuICAgICAgICAgIGVuY29kZTogYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICBlbmNvZGU6IGF4aXNVcGRhdGUsXG4gICAgICAgICAgc2NhbGVzOiBbc2NhbGUuc2NhbGVOYW1lXSxcbiAgICAgICAgICBzaWduYWxzOiBbXSwgZGF0YTogW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXhpc0RlZi5tYXJrcyA9IG1hcmtzLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KTtcbiAgfVxuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIGF4aXNPcmllbnRzID8geCArICcnIDogY29uZmlnLmF4aXMub3JpZW50O1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZTtcbiAgICBpZiAodGl0bGUgIT09IHgpIHsgdGl0bGUgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrQ291bnQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0NvdW50O1xuICAgIHRpY2tDb3VudCA9IHg7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tWYWx1ZXM7XG4gICAgdGlja1ZhbHVlcyA9IHg7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXRTdHJpbmc7XG4gICAgaWYgKHRpY2tGb3JtYXRTdHJpbmcgIT09IHgpIHtcbiAgICAgIHRpY2tGb3JtYXRTdHJpbmcgPSB4O1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0VHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0VHlwZTtcbiAgICBpZiAodGlja0Zvcm1hdFR5cGUgIT09IHgpIHtcbiAgICAgIHRpY2tGb3JtYXRUeXBlID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja01ham9yU2l6ZTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICBtYWpvciA9ICt4LFxuICAgICAgICBtaW5vciA9IG4gPiAxID8gK3kgOiB0aWNrTWFqb3JTaXplLFxuICAgICAgICBlbmQgICA9IG4gPiAwID8gK2FyZ3VtZW50c1tuXSA6IHRpY2tNYWpvclNpemU7XG5cbiAgICBpZiAodGlja01ham9yU2l6ZSAhPT0gbWFqb3IgfHxcbiAgICAgICAgdGlja01pbm9yU2l6ZSAhPT0gbWlub3IgfHxcbiAgICAgICAgdGlja0VuZFNpemUgIT09IGVuZCkge1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG5cbiAgICB0aWNrTWFqb3JTaXplID0gbWFqb3I7XG4gICAgdGlja01pbm9yU2l6ZSA9IG1pbm9yO1xuICAgIHRpY2tFbmRTaXplID0gZW5kO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1N1YmRpdmlkZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrU3ViZGl2aWRlO1xuICAgIHRpY2tTdWJkaXZpZGUgPSAreDtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMub2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICBvZmZzZXQgPSBkbC5pc09iamVjdCh4KSA/IHggOiAreDtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tQYWRkaW5nO1xuICAgIGlmICh0aWNrUGFkZGluZyAhPT0gK3gpIHsgdGlja1BhZGRpbmcgPSAreDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGl0bGVPZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGVPZmZzZXQ7XG4gICAgaWYgKHRpdGxlT2Zmc2V0ICE9PSAreCkgeyB0aXRsZU9mZnNldCA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5sYXllciA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYXllcjtcbiAgICBpZiAobGF5ZXIgIT09IHgpIHsgbGF5ZXIgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5ncmlkID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWQ7XG4gICAgaWYgKGdyaWQgIT09IHgpIHsgZ3JpZCA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWRMaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmlkTGluZVN0eWxlO1xuICAgIGlmIChncmlkTGluZVN0eWxlICE9PSB4KSB7IGdyaWRMaW5lU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1ham9yVGlja1N0eWxlO1xuICAgIGlmIChtYWpvclRpY2tTdHlsZSAhPT0geCkgeyBtYWpvclRpY2tTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWlub3JUaWNrU3R5bGU7XG4gICAgaWYgKG1pbm9yVGlja1N0eWxlICE9PSB4KSB7IG1pbm9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0xhYmVsUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTGFiZWxTdHlsZTtcbiAgICBpZiAodGlja0xhYmVsU3R5bGUgIT09IHgpIHsgdGlja0xhYmVsU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZVByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGVTdHlsZTtcbiAgICBpZiAodGl0bGVTdHlsZSAhPT0geCkgeyB0aXRsZVN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZG9tYWluUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW5TdHlsZTtcbiAgICBpZiAoZG9tYWluU3R5bGUgIT09IHgpIHsgZG9tYWluU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIFxuICBheGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7IFxuICAgIHJlc2V0KCk7IFxuICAgIHJldHVybiBheGlzOyBcbiAgfTtcblxuICByZXR1cm4gYXhpcztcbn1cblxudmFyIGF4aXNPcmllbnRzID0ge3RvcDogMSwgcmlnaHQ6IDEsIGJvdHRvbTogMSwgbGVmdDogMX07XG5cbmZ1bmN0aW9uIGF4aXNTdWJkaXZpZGUoc2NhbGUsIHRpY2tzLCBtKSB7XG4gIHZhciBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IGF4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHRpY2tzLmxlbmd0aCxcbiAgICAgICAgZCA9ICh0aWNrc1sxXSAtIHRpY2tzWzBdKSAvICsrbSxcbiAgICAgICAgaixcbiAgICAgICAgdjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgZm9yIChqID0gbTsgLS1qID4gMDspIHtcbiAgICAgICAgaWYgKCh2ID0gK3RpY2tzW2ldIC0gaiAqIGQpID49IGV4dGVudFswXSkge1xuICAgICAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICgtLWksIGogPSAwOyArK2ogPCBtICYmICh2ID0gK3RpY2tzW2ldICsgaiAqIGQpIDwgZXh0ZW50WzFdOykge1xuICAgICAgc3VidGlja3MucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnRpY2tzO1xufVxuXG5mdW5jdGlvbiBheGlzU2NhbGVFeHRlbnQoZG9tYWluKSB7XG4gIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBzdGFydCA8IHN0b3AgPyBbc3RhcnQsIHN0b3BdIDogW3N0b3AsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpIHtcbiAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50ID9cbiAgICBzY2FsZS5yYW5nZUV4dGVudCgpIDpcbiAgICBheGlzU2NhbGVFeHRlbnQoc2NhbGUucmFuZ2UoKSk7XG59XG5cbnZhciBheGlzQWxpZ24gPSB7XG4gIGJvdHRvbTogJ2NlbnRlcicsXG4gIHRvcDogJ2NlbnRlcicsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbnZhciBheGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbScsXG4gIGxlZnQ6ICdtaWRkbGUnLFxuICByaWdodDogJ21pZGRsZSdcbn07XG5cbmZ1bmN0aW9uIGF4aXNMYWJlbEV4dGVuZChvcmllbnQsIGxhYmVscywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplLCBwYWQpIHtcbiAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDApICsgcGFkO1xuICBpZiAob3JpZW50ID09PSAnbGVmdCcgfHwgb3JpZW50ID09PSAndG9wJykge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSAndG9wJyB8fCBvcmllbnQgPT09ICdib3R0b20nKSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiBvbGRTY2FsZSxcbiAgICAgIHk6IHt2YWx1ZTogc2l6ZX0sXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDogbmV3U2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgICAgYWxpZ246IHt2YWx1ZTogJ2NlbnRlcid9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgdGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgc2l6ZSkge1xuICB2YXIgc2lnbiA9IChvcmllbnQgPT09ICdsZWZ0JyB8fCBvcmllbnQgPT09ICd0b3AnKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09ICd0b3AnIHx8IG9yaWVudCA9PT0gJ2JvdHRvbScpID9cbiAgICAgIHtmaWVsZDoge2dyb3VwOiAnaGVpZ2h0JywgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn0gOlxuICAgICAge2ZpZWxkOiB7Z3JvdXA6ICd3aWR0aCcsICBsZXZlbDogMn0sIG11bHQ6IC1zaWdufTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0ge3ZhbHVlOiBzaWduICogc2l6ZX07XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gJ3RvcCcgfHwgb3JpZW50ID09PSAnYm90dG9tJykge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAgb2xkU2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgIH0pOyAgICAgICAgXG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgb2xkU2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgbmV3U2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB5OiAgbmV3U2NhbGUsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgdGl0bGUsIHJhbmdlLCBvZmZzZXQpIHtcbiAgdmFyIG1pZCA9IH5+KChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDIpLFxuICAgICAgc2lnbiA9IChvcmllbnQgPT09ICd0b3AnIHx8IG9yaWVudCA9PT0gJ2xlZnQnKSA/IC0xIDogMTtcbiAgXG4gIGlmIChvcmllbnQgPT09ICdib3R0b20nIHx8IG9yaWVudCA9PT0gJ3RvcCcpIHtcbiAgICBkbC5leHRlbmQodGl0bGUucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IHt2YWx1ZTogbWlkfSxcbiAgICAgIHk6IHt2YWx1ZTogc2lnbipvZmZzZXR9LFxuICAgICAgYW5nbGU6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkbC5leHRlbmQodGl0bGUucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IHt2YWx1ZTogc2lnbipvZmZzZXR9LFxuICAgICAgeToge3ZhbHVlOiBtaWR9LFxuICAgICAgYW5nbGU6IHt2YWx1ZTogb3JpZW50ID09PSAnbGVmdCcgPyAtOTAgOiA5MH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRG9tYWluRXh0ZW5kKG9yaWVudCwgZG9tYWluLCByYW5nZSwgc2l6ZSkge1xuICB2YXIgcGF0aDtcbiAgaWYgKG9yaWVudCA9PT0gJ3RvcCcgfHwgb3JpZW50ID09PSAnbGVmdCcpIHtcbiAgICBzaXplID0gLTEgKiBzaXplO1xuICB9XG4gIGlmIChvcmllbnQgPT09ICdib3R0b20nIHx8IG9yaWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwYXRoID0gJ00nICsgcmFuZ2VbMF0gKyAnLCcgKyBzaXplICsgJ1YwSCcgKyByYW5nZVsxXSArICdWJyArIHNpemU7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9ICdNJyArIHNpemUgKyAnLCcgKyByYW5nZVswXSArICdIMFYnICsgcmFuZ2VbMV0gKyAnSCcgKyBzaXplO1xuICB9XG4gIGRvbWFpbi5wcm9wZXJ0aWVzLnVwZGF0ZS5wYXRoID0ge3ZhbHVlOiBwYXRofTtcbn1cblxuZnVuY3Rpb24gYXhpc1VwZGF0ZShpdGVtLCBncm91cCwgdHJhbnMpIHtcbiAgdmFyIG8gPSB0cmFucyA/IHt9IDogaXRlbSxcbiAgICAgIG9mZnNldCA9IGl0ZW0ubWFyay5kZWYub2Zmc2V0LFxuICAgICAgb3JpZW50ID0gaXRlbS5tYXJrLmRlZi5vcmllbnQsXG4gICAgICB3aWR0aCAgPSBncm91cC53aWR0aCxcbiAgICAgIGhlaWdodCA9IGdyb3VwLmhlaWdodDsgLy8gVE9ETyBmYWxsYmFjayB0byBnbG9iYWwgdyxoP1xuXG4gIGlmIChkbC5pc0FycmF5KG9mZnNldCkpIHtcbiAgICB2YXIgb2Z4ID0gb2Zmc2V0WzBdLFxuICAgICAgICBvZnkgPSBvZmZzZXRbMV07XG5cbiAgICBzd2l0Y2ggKG9yaWVudCkge1xuICAgICAgY2FzZSAnbGVmdCc6ICAgeyBUdXBsZS5zZXQobywgJ3gnLCAtb2Z4KTsgVHVwbGUuc2V0KG8sICd5Jywgb2Z5KTsgYnJlYWs7IH1cbiAgICAgIGNhc2UgJ3JpZ2h0JzogIHsgVHVwbGUuc2V0KG8sICd4Jywgd2lkdGggKyBvZngpOyBUdXBsZS5zZXQobywgJ3knLCBvZnkpOyBicmVhazsgfVxuICAgICAgY2FzZSAnYm90dG9tJzogeyBUdXBsZS5zZXQobywgJ3gnLCBvZngpOyBUdXBsZS5zZXQobywgJ3knLCBoZWlnaHQgKyBvZnkpOyBicmVhazsgfVxuICAgICAgY2FzZSAndG9wJzogICAgeyBUdXBsZS5zZXQobywgJ3gnLCBvZngpOyBUdXBsZS5zZXQobywgJ3knLCAtb2Z5KTsgYnJlYWs7IH1cbiAgICAgIGRlZmF1bHQ6ICAgICAgIHsgVHVwbGUuc2V0KG8sICd4Jywgb2Z4KTsgVHVwbGUuc2V0KG8sICd5Jywgb2Z5KTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGwuaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ID0gLWdyb3VwLnNjYWxlKG9mZnNldC5zY2FsZSkob2Zmc2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9yaWVudCkge1xuICAgICAgY2FzZSAnbGVmdCc6ICAgeyBUdXBsZS5zZXQobywgJ3gnLCAtb2Zmc2V0KTsgVHVwbGUuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgICBjYXNlICdyaWdodCc6ICB7IFR1cGxlLnNldChvLCAneCcsIHdpZHRoICsgb2Zmc2V0KTsgVHVwbGUuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgICBjYXNlICdib3R0b20nOiB7IFR1cGxlLnNldChvLCAneCcsIDApOyBUdXBsZS5zZXQobywgJ3knLCBoZWlnaHQgKyBvZmZzZXQpOyBicmVhazsgfVxuICAgICAgY2FzZSAndG9wJzogICAgeyBUdXBsZS5zZXQobywgJ3gnLCAwKTsgVHVwbGUuc2V0KG8sICd5JywgLW9mZnNldCk7IGJyZWFrOyB9XG4gICAgICBkZWZhdWx0OiAgICAgICB7IFR1cGxlLnNldChvLCAneCcsIDApOyBUdXBsZS5zZXQobywgJ3knLCAwKTsgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBheGlzVGlja3MoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3J1bGUnLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja1dpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc1RpY2tMYWJlbHMoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIGtleTogJ2RhdGEnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250U2l6ZX0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogJ2xhYmVsJ31cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZTogeyBvcGFjaXR5OiB7dmFsdWU6IDF9IH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZShjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnRTaXplfSxcbiAgICAgICAgZm9udFdlaWdodDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnRXZWlnaHR9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpdGxlQ29sb3J9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiAnY2VudGVyJ30sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiAnZGF0YSd9XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiB7fVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc0RvbWFpbihjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAncGF0aCcsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgeToge3ZhbHVlOiAwLjV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc1dpZHRofVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhzOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEdyYWRpZW50ID0gcmVxdWlyZSgndmVnYS1zY2VuZWdyYXBoJykuR3JhZGllbnQsXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vcGFyc2UvcHJvcGVydGllcycpLFxuICAgIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmsnKTtcblxuZnVuY3Rpb24gbGduZChtb2RlbCkge1xuICB2YXIgc2l6ZSA9IG51bGwsXG4gICAgICBzaGFwZSA9IG51bGwsXG4gICAgICBmaWxsID0gbnVsbCxcbiAgICAgIHN0cm9rZSA9IG51bGwsXG4gICAgICBzcGFjaW5nID0gbnVsbCxcbiAgICAgIHZhbHVlcyA9IG51bGwsXG4gICAgICBmb3JtYXQgPSBudWxsLFxuICAgICAgZm9ybWF0U3RyaW5nID0gbnVsbCxcbiAgICAgIGNvbmZpZyA9IG1vZGVsLmNvbmZpZygpLFxuICAgICAgdGl0bGUsXG4gICAgICBvcmllbnQgPSAncmlnaHQnLFxuICAgICAgb2Zmc2V0ID0gY29uZmlnLmxlZ2VuZC5vZmZzZXQsXG4gICAgICBwYWRkaW5nID0gY29uZmlnLmxlZ2VuZC5wYWRkaW5nLFxuICAgICAgdGlja0FyZ3VtZW50cyA9IFs1XSxcbiAgICAgIGxlZ2VuZFN0eWxlID0ge30sXG4gICAgICBzeW1ib2xTdHlsZSA9IHt9LFxuICAgICAgZ3JhZGllbnRTdHlsZSA9IHt9LFxuICAgICAgdGl0bGVTdHlsZSA9IHt9LFxuICAgICAgbGFiZWxTdHlsZSA9IHt9LFxuICAgICAgbSA9IHsgLy8gTGVnZW5kIG1hcmtzIGFzIHJlZmVyZW5jZXMgZm9yIHVwZGF0ZXNcbiAgICAgICAgdGl0bGVzOiAge30sXG4gICAgICAgIHN5bWJvbHM6IHt9LFxuICAgICAgICBsYWJlbHM6ICB7fSxcbiAgICAgICAgZ3JhZGllbnQ6IHt9XG4gICAgICB9O1xuXG4gIHZhciBsZWdlbmQgPSB7fSxcbiAgICAgIGxlZ2VuZERlZiA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkgeyBsZWdlbmREZWYudHlwZSA9IG51bGw7IH1cbiAgZnVuY3Rpb24gaW5nZXN0KGQsIGkpIHsgcmV0dXJuIHtkYXRhOiBkLCBpbmRleDogaX07IH1cblxuICBsZWdlbmQuZGVmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gc2l6ZSB8fCBzaGFwZSB8fCBmaWxsIHx8IHN0cm9rZTtcbiAgICBcbiAgICBmb3JtYXQgPSAhZm9ybWF0U3RyaW5nID8gbnVsbCA6ICgoc2NhbGUudHlwZSA9PT0gJ3RpbWUnKSA/XG4gICAgICBkbC5mb3JtYXQudGltZShmb3JtYXRTdHJpbmcpIDogZGwuZm9ybWF0Lm51bWJlcihmb3JtYXRTdHJpbmcpKTtcbiAgICBcbiAgICBpZiAoIWxlZ2VuZERlZi50eXBlKSB7XG4gICAgICBsZWdlbmREZWYgPSAoc2NhbGU9PT1maWxsIHx8IHNjYWxlPT09c3Ryb2tlKSAmJiAhZGlzY3JldGUoc2NhbGUudHlwZSkgP1xuICAgICAgICBxdWFudERlZihzY2FsZSkgOiBvcmRpbmFsRGVmKHNjYWxlKTsgICAgICBcbiAgICB9XG4gICAgbGVnZW5kRGVmLm9yaWVudCA9IG9yaWVudDtcbiAgICBsZWdlbmREZWYub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxlZ2VuZERlZi5wYWRkaW5nID0gcGFkZGluZztcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpc2NyZXRlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZT09PSdvcmRpbmFsJyB8fCB0eXBlPT09J3F1YW50aXplJyB8fFxuICAgICAgICAgICB0eXBlPT09J3F1YW50aWxlJyB8fCB0eXBlPT09J3RocmVzaG9sZCc7XG4gIH1cblxuICBmdW5jdGlvbiBvcmRpbmFsRGVmKHNjYWxlKSB7XG4gICAgdmFyIGRlZiA9IG9fbGVnZW5kX2RlZihzaXplLCBzaGFwZSwgZmlsbCwgc3Ryb2tlKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICB2YXIgZGF0YSA9ICh2YWx1ZXMgPT0gbnVsbCA/XG4gICAgICAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSkgOlxuICAgICAgdmFsdWVzKS5tYXAoaW5nZXN0KTtcbiAgICB2YXIgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG4gICAgXG4gICAgLy8gZGV0ZXJtaW5lIHNwYWNpbmcgYmV0d2VlbiBsZWdlbmQgZW50cmllc1xuICAgIHZhciBmcywgcmFuZ2UsIG9mZnNldCwgcGFkPTUsIGRvbWFpbiA9IGQzLnJhbmdlKGRhdGEubGVuZ3RoKTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgcmFuZ2UgPSBkYXRhLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnNxcnQoc2l6ZSh4LmRhdGEpKTsgfSk7XG4gICAgICBvZmZzZXQgPSBkMy5tYXgocmFuZ2UpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZWR1Y2UoZnVuY3Rpb24oYSxiLGkseikge1xuICAgICAgICAgIGlmIChpID4gMCkgYVtpXSA9IGFbaS0xXSArIHpbaS0xXS8yICsgcGFkO1xuICAgICAgICAgIHJldHVybiAoYVtpXSArPSBiLzIsIGEpOyB9LCBbMF0pLm1hcChNYXRoLnJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoY29uZmlnLmxlZ2VuZC5zeW1ib2xTaXplKSk7XG4gICAgICByYW5nZSA9IHNwYWNpbmcgfHxcbiAgICAgICAgKGZzID0gbGFiZWxTdHlsZS5mb250U2l6ZSkgJiYgKGZzLnZhbHVlICsgcGFkKSB8fFxuICAgICAgICAoY29uZmlnLmxlZ2VuZC5sYWJlbEZvbnRTaXplICsgcGFkKTtcbiAgICAgIHJhbmdlID0gZG9tYWluLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0LzIgKyBpKnJhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFjY291bnQgZm9yIHBhZGRpbmcgYW5kIHRpdGxlIHNpemVcbiAgICB2YXIgc3ogPSBwYWRkaW5nLCB0cztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRzID0gdGl0bGVTdHlsZS5mb250U2l6ZTtcbiAgICAgIHN6ICs9IDUgKyAoKHRzICYmIHRzLnZhbHVlKSB8fCBjb25maWcubGVnZW5kLnRpdGxlRm9udFNpemUpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpPTAsIG49cmFuZ2UubGVuZ3RoOyBpPG47ICsraSkgcmFuZ2VbaV0gKz0gc3o7XG4gICAgXG4gICAgLy8gYnVpbGQgc2NhbGUgZm9yIGxhYmVsIGxheW91dFxuICAgIHZhciBzY2FsZVNwZWMgPSB7XG4gICAgICBuYW1lOiAnbGVnZW5kJyxcbiAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgIHBvaW50czogdHJ1ZSxcbiAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgICBcbiAgICAvLyB1cGRhdGUgbGVnZW5kIGRlZlxuICAgIHZhciB0ZGF0YSA9ICh0aXRsZSA/IFt0aXRsZV0gOiBbXSkubWFwKGluZ2VzdCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQubGFiZWwgPSBmbXQoZC5kYXRhKTtcbiAgICAgIGQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH0pO1xuICAgIGRlZi5zY2FsZXMgPSBbIHNjYWxlU3BlYyBdO1xuICAgIGRlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiB0ZGF0YTsgfTtcbiAgICBkZWYubWFya3NbMV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICBkZWYubWFya3NbMl0uZnJvbSA9IGRlZi5tYXJrc1sxXS5mcm9tO1xuXG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9fbGVnZW5kX2RlZihzaXplLCBzaGFwZSwgZmlsbCwgc3Ryb2tlKSB7XG4gICAgLy8gc2V0dXAgbGVnZW5kIG1hcmtzXG4gICAgdmFyIHRpdGxlcyAgPSBkbC5leHRlbmQobS50aXRsZXMsIHZnX2xlZ2VuZFRpdGxlKGNvbmZpZykpLFxuICAgICAgICBzeW1ib2xzID0gZGwuZXh0ZW5kKG0uc3ltYm9scywgdmdfbGVnZW5kU3ltYm9scyhjb25maWcpKSxcbiAgICAgICAgbGFiZWxzICA9IGRsLmV4dGVuZChtLmxhYmVscywgdmdfdkxlZ2VuZExhYmVscyhjb25maWcpKTtcblxuICAgIC8vIGV4dGVuZCBsZWdlbmQgbWFya3NcbiAgICB2Z19sZWdlbmRTeW1ib2xFeHRlbmQoc3ltYm9scywgc2l6ZSwgc2hhcGUsIGZpbGwsIHN0cm9rZSk7XG4gICAgXG4gICAgLy8gYWRkIC8gb3ZlcnJpZGUgY3VzdG9tIHN0eWxlIHByb3BlcnRpZXNcbiAgICBkbC5leHRlbmQodGl0bGVzLnByb3BlcnRpZXMudXBkYXRlLCAgdGl0bGVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKHN5bWJvbHMucHJvcGVydGllcy51cGRhdGUsIHN5bWJvbFN0eWxlKTtcbiAgICBkbC5leHRlbmQobGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCAgbGFiZWxTdHlsZSk7XG5cbiAgICAvLyBwYWRkaW5nIGZyb20gbGVnZW5kIGJvcmRlclxuICAgIHRpdGxlcy5wcm9wZXJ0aWVzLmVudGVyLngudmFsdWUgKz0gcGFkZGluZztcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMuZW50ZXIueC5vZmZzZXQgKz0gcGFkZGluZyArIDE7XG4gICAgc3ltYm9scy5wcm9wZXJ0aWVzLmVudGVyLngub2Zmc2V0ID0gcGFkZGluZyArIDE7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLngub2Zmc2V0ICs9IHBhZGRpbmcgKyAxO1xuICAgIHN5bWJvbHMucHJvcGVydGllcy51cGRhdGUueC5vZmZzZXQgPSBwYWRkaW5nICsgMTtcblxuICAgIGRsLmV4dGVuZChsZWdlbmREZWYsIHtcbiAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsICdncm91cCcsIGxlZ2VuZFN0eWxlKSxcbiAgICAgICAgdmdfbGVnZW5kUG9zaXRpb246IHtcbiAgICAgICAgICBlbmNvZGU6IHZnX2xlZ2VuZFBvc2l0aW9uLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBzY2FsZXM6W10sIGRhdGE6IFtdLCBmaWVsZHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxlZ2VuZERlZi5tYXJrcyA9IFt0aXRsZXMsIHN5bWJvbHMsIGxhYmVsc10ubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICAgIHJldHVybiBsZWdlbmREZWY7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudERlZihzY2FsZSkge1xuICAgIHZhciBkZWYgPSBxX2xlZ2VuZF9kZWYoc2NhbGUpLFxuICAgICAgICBkb20gPSBzY2FsZS5kb21haW4oKSxcbiAgICAgICAgZGF0YSA9ICh2YWx1ZXMgPT0gbnVsbCA/XG4gICAgICAgICAgKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDpcbiAgICAgICAgICB2YWx1ZXMpLm1hcChpbmdlc3QpLFxuICAgICAgICB3aWR0aCA9IChncmFkaWVudFN0eWxlLndpZHRoICYmIGdyYWRpZW50U3R5bGUud2lkdGgudmFsdWUpIHx8IGNvbmZpZy5sZWdlbmQuZ3JhZGllbnRXaWR0aCxcbiAgICAgICAgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG5cbiAgICAvLyBidWlsZCBzY2FsZSBmb3IgbGFiZWwgbGF5b3V0XG4gICAgdmFyIGxheW91dFNwZWMgPSB7XG4gICAgICBuYW1lOiAnbGVnZW5kJyxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUsXG4gICAgICByb3VuZDogdHJ1ZSxcbiAgICAgIHplcm86IGZhbHNlLFxuICAgICAgZG9tYWluOiBbZG9tWzBdLCBkb21bZG9tLmxlbmd0aC0xXV0sXG4gICAgICByYW5nZTogW3BhZGRpbmcsIHdpZHRoK3BhZGRpbmddXG4gICAgfTtcbiAgICBpZiAoc2NhbGUudHlwZT09PSdwb3cnKSBsYXlvdXRTcGVjLmV4cG9uZW50ID0gc2NhbGUuZXhwb25lbnQoKTtcbiAgICBcbiAgICAvLyB1cGRhdGUgbGVnZW5kIGRlZlxuICAgIHZhciB0ZGF0YSA9ICh0aXRsZSA/IFt0aXRsZV0gOiBbXSkubWFwKGluZ2VzdCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgZC5sYWJlbCA9IGZtdChkLmRhdGEpO1xuICAgICAgZC5hbGlnbiA9IGk9PShkYXRhLmxlbmd0aC0xKSA/ICdyaWdodCcgOiBpPT09MCA/ICdsZWZ0JyA6ICdjZW50ZXInO1xuICAgIH0pO1xuICAgIGRlZi5zY2FsZXMgPSBbIGxheW91dFNwZWMgXTtcbiAgICBkZWYubWFya3NbMF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgZGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIFsxXTsgfTtcbiAgICBkZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICByZXR1cm4gZGVmO1xuICB9XG4gIFxuICBmdW5jdGlvbiBxX2xlZ2VuZF9kZWYoc2NhbGUpIHtcbiAgICAvLyBzZXR1cCBsZWdlbmQgbWFya3NcbiAgICB2YXIgdGl0bGVzID0gZGwuZXh0ZW5kKG0udGl0bGVzLCB2Z19sZWdlbmRUaXRsZShjb25maWcpKSxcbiAgICAgICAgZ3JhZGllbnQgPSBkbC5leHRlbmQobS5ncmFkaWVudCwgdmdfbGVnZW5kR3JhZGllbnQoY29uZmlnKSksXG4gICAgICAgIGxhYmVscyA9IGRsLmV4dGVuZChtLmxhYmVscywgdmdfaExlZ2VuZExhYmVscyhjb25maWcpKSxcbiAgICAgICAgZ3JhZCA9IG5ldyBHcmFkaWVudCgpO1xuXG4gICAgLy8gc2V0dXAgY29sb3IgZ3JhZGllbnRcbiAgICB2YXIgZG9tID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIG1pbiA9IGRvbVswXSxcbiAgICAgICAgbWF4ID0gZG9tW2RvbS5sZW5ndGgtMV0sXG4gICAgICAgIGYgPSBzY2FsZS5jb3B5KCkuZG9tYWluKFttaW4sIG1heF0pLnJhbmdlKFswLDFdKTtcbiAgICAgICAgXG4gICAgdmFyIHN0b3BzID0gKHNjYWxlLnR5cGUgIT09ICdsaW5lYXInICYmIHNjYWxlLnRpY2tzKSA/XG4gICAgICBzY2FsZS50aWNrcy5jYWxsKHNjYWxlLCAxNSkgOiBkb207XG4gICAgaWYgKG1pbiAhPT0gc3RvcHNbMF0pIHN0b3BzLnVuc2hpZnQobWluKTtcbiAgICBpZiAobWF4ICE9PSBzdG9wc1tzdG9wcy5sZW5ndGgtMV0pIHN0b3BzLnB1c2gobWF4KTtcblxuICAgIGZvciAodmFyIGk9MCwgbj1zdG9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBncmFkLnN0b3AoZihzdG9wc1tpXSksIHNjYWxlKHN0b3BzW2ldKSk7XG4gICAgfVxuICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIuZmlsbCA9IHt2YWx1ZTogZ3JhZH07XG5cbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZCh0aXRsZXMucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuICAgIGRsLmV4dGVuZChncmFkaWVudC5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JhZGllbnRTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbGFiZWxTdHlsZSk7XG5cbiAgICAvLyBhY2NvdW50IGZvciBncmFkaWVudCBzaXplXG4gICAgdmFyIGdwID0gZ3JhZGllbnQucHJvcGVydGllcywgZ2ggPSBncmFkaWVudFN0eWxlLmhlaWdodCxcbiAgICAgICAgaGggPSAoZ2ggJiYgZ2gudmFsdWUpIHx8IGdwLmVudGVyLmhlaWdodC52YWx1ZTtcbiAgICBsYWJlbHMucHJvcGVydGllcy5lbnRlci55LnZhbHVlID0gaGg7XG4gICAgbGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgPSBoaDtcblxuICAgIC8vIGFjY291bnQgZm9yIHRpdGxlIHNpemUgYXMgbmVlZGVkXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICB2YXIgdHAgPSB0aXRsZXMucHJvcGVydGllcywgZnMgPSB0aXRsZVN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIHN6ID0gNCArICgoZnMgJiYgZnMudmFsdWUpIHx8IHRwLmVudGVyLmZvbnRTaXplLnZhbHVlKTtcbiAgICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBzejtcbiAgICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gc3o7XG4gICAgICBncmFkaWVudC5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlICs9IHN6O1xuICAgICAgbGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgKz0gc3o7XG4gICAgfVxuICAgIFxuICAgIC8vIHBhZGRpbmcgZnJvbSBsZWdlbmQgYm9yZGVyXG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueC52YWx1ZSArPSBwYWRkaW5nO1xuICAgIHRpdGxlcy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gcGFkZGluZztcbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLmVudGVyLngudmFsdWUgKz0gcGFkZGluZztcbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gcGFkZGluZztcbiAgICBsYWJlbHMucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy51cGRhdGUueC52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgKz0gcGFkZGluZztcbiAgICBsYWJlbHMucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBwYWRkaW5nO1xuXG4gICAgZGwuZXh0ZW5kKGxlZ2VuZERlZiwge1xuICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZW50ZXI6IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgJ2dyb3VwJywgbGVnZW5kU3R5bGUpLFxuICAgICAgICB2Z19sZWdlbmRQb3NpdGlvbjoge1xuICAgICAgICAgIGVuY29kZTogdmdfbGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgc2lnbmFsczogW10sIHNjYWxlczogW10sIGRhdGE6IFtdLCBmaWVsZHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxlZ2VuZERlZi5tYXJrcyA9IFt0aXRsZXMsIGdyYWRpZW50LCBsYWJlbHNdLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KTtcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9XG5cbiAgbGVnZW5kLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0geCkgeyBzaXplID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgIGlmIChzaGFwZSAhPT0geCkgeyBzaGFwZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5maWxsID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpbGw7XG4gICAgaWYgKGZpbGwgIT09IHgpIHsgZmlsbCA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuICBcbiAgbGVnZW5kLnN0cm9rZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdHJva2U7XG4gICAgaWYgKHN0cm9rZSAhPT0geCkgeyBzdHJva2UgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgaWYgKHRpdGxlICE9PSB4KSB7IHRpdGxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmZvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JtYXRTdHJpbmc7XG4gICAgaWYgKGZvcm1hdFN0cmluZyAhPT0geCkge1xuICAgICAgZm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNwYWNpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3BhY2luZztcbiAgICBpZiAoc3BhY2luZyAhPT0gK3gpIHsgc3BhY2luZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBvcmllbnQgPSB4IGluIHZnX2xlZ2VuZE9yaWVudHMgPyB4ICsgJycgOiBjb25maWcubGVnZW5kLm9yaWVudDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9ICt4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXM7XG4gICAgdmFsdWVzID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sZWdlbmRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxlZ2VuZFN0eWxlO1xuICAgIGxlZ2VuZFN0eWxlID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zeW1ib2xQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN5bWJvbFN0eWxlO1xuICAgIHN5bWJvbFN0eWxlID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5ncmFkaWVudFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhZGllbnRTdHlsZTtcbiAgICBncmFkaWVudFN0eWxlID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxTdHlsZTtcbiAgICBsYWJlbFN0eWxlID0geDtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuICBcbiAgbGVnZW5kLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIHRpdGxlU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnJlc2V0ID0gZnVuY3Rpb24oKSB7IFxuICAgIHJlc2V0KCk7IFxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgcmV0dXJuIGxlZ2VuZDtcbn1cblxudmFyIHZnX2xlZ2VuZE9yaWVudHMgPSB7cmlnaHQ6IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19sZWdlbmRQb3NpdGlvbihpdGVtLCBncm91cCwgdHJhbnMsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSB7XG4gIHZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sIGd4LFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHBhZCAgICA9IGl0ZW0ubWFyay5kZWYucGFkZGluZyAqIDIsXG4gICAgICBsdyAgICAgPSB+fml0ZW0uYm91bmRzLndpZHRoKCkgKyAoaXRlbS53aWR0aCA/IDAgOiBwYWQpLFxuICAgICAgbGggICAgID0gfn5pdGVtLmJvdW5kcy5oZWlnaHQoKSArIChpdGVtLmhlaWdodCA/IDAgOiBwYWQpLFxuICAgICAgcG9zID0gZ3JvdXAuX2xlZ2VuZFBvc2l0aW9ucyB8fCBcbiAgICAgICAgKGdyb3VwLl9sZWdlbmRQb3NpdGlvbnMgPSB7cmlnaHQ6IDAuNSwgbGVmdDogMC41fSk7XG5cbiAgby54ID0gMC41O1xuICBvLndpZHRoID0gbHc7XG4gIG8ueSA9IHBvc1tvcmllbnRdO1xuICBwb3Nbb3JpZW50XSArPSAoby5oZWlnaHQgPSBsaCk7XG5cbiAgLy8gSEFDSzogdXNlIHRvIGVzdGltYXRlIGdyb3VwIGJvdW5kcyBkdXJpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvblxuICBpZiAoIXRyYW5zICYmIGdyb3VwLmJvdW5kcykge1xuICAgIGdyb3VwLmJvdW5kcy5kZWx0YSA9IGdyb3VwLmJvdW5kcy54MiAtIGdyb3VwLndpZHRoO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlICdsZWZ0JzogIHtcbiAgICAgIGd4ID0gZ3JvdXAuYm91bmRzID8gZ3JvdXAuYm91bmRzLngxIDogMDtcbiAgICAgIG8ueCArPSBneCAtIG9mZnNldCAtIGx3O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgZ3ggPSBncm91cC53aWR0aCArIChncm91cC5ib3VuZHMgJiYgdHJhbnMgPyBncm91cC5ib3VuZHMuZGVsdGEgOiAwKTtcbiAgICAgIG8ueCArPSBneCArIG9mZnNldDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbiAgdmFyIGVuYyA9IGl0ZW0ubWFyay5kZWYucHJvcGVydGllcy5lbnRlci5lbmNvZGU7XG4gIGVuYy5jYWxsKGVuYywgaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2Z19sZWdlbmRTeW1ib2xFeHRlbmQobWFyaywgc2l6ZSwgc2hhcGUsIGZpbGwsIHN0cm9rZSkge1xuICB2YXIgZSA9IG1hcmsucHJvcGVydGllcy5lbnRlcixcbiAgICAgIHUgPSBtYXJrLnByb3BlcnRpZXMudXBkYXRlO1xuICBpZiAoc2l6ZSkgICBlLnNpemUgICA9IHUuc2l6ZSAgID0ge3NjYWxlOiBzaXplLnNjYWxlTmFtZSwgICBmaWVsZDogJ2RhdGEnfTtcbiAgaWYgKHNoYXBlKSAgZS5zaGFwZSAgPSB1LnNoYXBlICA9IHtzY2FsZTogc2hhcGUuc2NhbGVOYW1lLCAgZmllbGQ6ICdkYXRhJ307XG4gIGlmIChmaWxsKSAgIGUuZmlsbCAgID0gdS5maWxsICAgPSB7c2NhbGU6IGZpbGwuc2NhbGVOYW1lLCAgIGZpZWxkOiAnZGF0YSd9O1xuICBpZiAoc3Ryb2tlKSBlLnN0cm9rZSA9IHUuc3Ryb2tlID0ge3NjYWxlOiBzdHJva2Uuc2NhbGVOYW1lLCBmaWVsZDogJ2RhdGEnfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kVGl0bGUoY29uZmlnKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiAnZGF0YScsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjZmcudGl0bGVDb2xvcn0sXG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY2ZnLnRpdGxlRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNmZy50aXRsZUZvbnRTaXplfSxcbiAgICAgICAgZm9udFdlaWdodDoge3ZhbHVlOiBjZmcudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ3RvcCd9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6ICdkYXRhJ30sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZTogeyBvcGFjaXR5OiB7dmFsdWU6IDF9IH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2xlZ2VuZFN5bWJvbHMoY29uZmlnKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7ZmllbGQ6ICdvZmZzZXQnLCBtdWx0OiAwLjV9LFxuICAgICAgICB5OiB7c2NhbGU6ICdsZWdlbmQnLCBmaWVsZDogJ2luZGV4J30sXG4gICAgICAgIHNoYXBlOiB7dmFsdWU6IGNmZy5zeW1ib2xTaGFwZX0sXG4gICAgICAgIHNpemU6IHt2YWx1ZTogY2ZnLnN5bWJvbFNpemV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY2ZnLnN5bWJvbENvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY2ZnLnN5bWJvbFN0cm9rZVdpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtmaWVsZDogJ29mZnNldCcsIG11bHQ6IDAuNX0sXG4gICAgICAgIHk6IHtzY2FsZTogJ2xlZ2VuZCcsIGZpZWxkOiAnaW5kZXgnfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfdkxlZ2VuZExhYmVscyhjb25maWcpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7ZmllbGQ6ICdvZmZzZXQnLCBvZmZzZXQ6IDV9LFxuICAgICAgICB5OiB7c2NhbGU6ICdsZWdlbmQnLCBmaWVsZDogJ2luZGV4J30sXG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY2ZnLmxhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNmZy5sYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjZmcubGFiZWxGb250U2l6ZX0sXG4gICAgICAgIGFsaWduOiB7dmFsdWU6IGNmZy5sYWJlbEFsaWdufSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogY2ZnLmxhYmVsQmFzZWxpbmV9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6ICdsYWJlbCd9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgICAgeDoge2ZpZWxkOiAnb2Zmc2V0Jywgb2Zmc2V0OiA1fSxcbiAgICAgICAgeToge3NjYWxlOiAnbGVnZW5kJywgZmllbGQ6ICdpbmRleCd9LFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kR3JhZGllbnQoY29uZmlnKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdyZWN0JyxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgICAgd2lkdGg6IHt2YWx1ZTogY2ZnLmdyYWRpZW50V2lkdGh9LFxuICAgICAgICBoZWlnaHQ6IHt2YWx1ZTogY2ZnLmdyYWRpZW50SGVpZ2h0fSxcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNmZy5ncmFkaWVudFN0cm9rZUNvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY2ZnLmdyYWRpZW50U3Ryb2tlV2lkdGh9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfaExlZ2VuZExhYmVscyhjb25maWcpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7c2NhbGU6ICdsZWdlbmQnLCBmaWVsZDogJ2RhdGEnfSxcbiAgICAgICAgeToge3ZhbHVlOiAyMH0sXG4gICAgICAgIGR5OiB7dmFsdWU6IDJ9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNmZy5sYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjZmcubGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udFNpemV9LFxuICAgICAgICBhbGlnbjoge2ZpZWxkOiAnYWxpZ24nfSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ3RvcCd9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6ICdsYWJlbCd9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgeDoge3NjYWxlOiAnbGVnZW5kJywgZmllbGQ6ICdkYXRhJ30sXG4gICAgICAgIHk6IHt2YWx1ZTogMjB9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDF9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxnbmQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2aXNpdChub2RlLCBmdW5jKSB7XG4gIHZhciBpLCBuLCBzLCBtLCBpdGVtcztcbiAgaWYgKGZ1bmMobm9kZSkpIHJldHVybiB0cnVlO1xuXG4gIHZhciBzZXRzID0gWydpdGVtcycsICdheGlzSXRlbXMnLCAnbGVnZW5kSXRlbXMnXTtcbiAgZm9yIChzPTAsIG09c2V0cy5sZW5ndGg7IHM8bTsgKytzKSB7XG4gICAgaWYgKChpdGVtcyA9IG5vZGVbc2V0c1tzXV0pKSB7XG4gICAgICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICAgIGlmICh2aXNpdChpdGVtc1tpXSwgZnVuYykpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgQ2hhbmdlU2V0ID0gZGYuQ2hhbmdlU2V0LFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEZhY2V0b3IgPSByZXF1aXJlKCcuL0ZhY2V0b3InKTtcblxuZnVuY3Rpb24gQWdncmVnYXRlKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcblxuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZ3JvdXBieToge3R5cGU6ICdhcnJheTxmaWVsZD4nfSxcbiAgICBzdW1tYXJpemU6IHtcbiAgICAgIHR5cGU6ICdjdXN0b20nLCBcbiAgICAgIHNldDogZnVuY3Rpb24oc3VtbWFyaXplKSB7XG4gICAgICAgIHZhciBzaWduYWxEZXBzID0ge30sXG4gICAgICAgICAgICB0eCA9IHRoaXMuX3RyYW5zZm9ybSxcbiAgICAgICAgICAgIGksIGxlbiwgZiwgZmllbGRzLCBuYW1lLCBvcHM7XG5cbiAgICAgICAgaWYgKCFkbC5pc0FycmF5KGZpZWxkcyA9IHN1bW1hcml6ZSkpIHsgLy8gT2JqZWN0IHN5bnRheCBmcm9tIGRsXG4gICAgICAgICAgZmllbGRzID0gW107XG4gICAgICAgICAgZm9yIChuYW1lIGluIHN1bW1hcml6ZSkge1xuICAgICAgICAgICAgb3BzID0gZGwuYXJyYXkoc3VtbWFyaXplW25hbWVdKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtmaWVsZDogbmFtZSwgb3BzOiBvcHN9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZyh4KSB7IGlmICh4LnNpZ25hbCkgc2lnbmFsRGVwc1t4LnNpZ25hbF0gPSAxOyB9XG5cbiAgICAgICAgZm9yIChpPTAsIGxlbj1maWVsZHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgZiA9IGZpZWxkc1tpXTtcbiAgICAgICAgICBpZiAoZi5maWVsZC5zaWduYWwpIHsgc2lnbmFsRGVwc1tmLmZpZWxkLnNpZ25hbF0gPSAxOyB9XG4gICAgICAgICAgZGwuYXJyYXkoZi5vcHMpLmZvckVhY2goc2cpO1xuICAgICAgICAgIGRsLmFycmF5KGYuYXMpLmZvckVhY2goc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHguX2ZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdHguX2FnZ3IgPSBudWxsO1xuICAgICAgICB0eC5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgZGwua2V5cyhzaWduYWxEZXBzKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuX2FnZ3IgID0gbnVsbDsgLy8gZGwuQWdncmVnYXRvclxuICB0aGlzLl9pbnB1dCA9IG51bGw7IC8vIFVzZWQgYnkgRmFjZXRvci5fb25fa2VlcC5cbiAgdGhpcy5fYXJncyAgPSBudWxsOyAvLyBUbyBjdWxsIHJlLWNvbXB1dGF0aW9uLlxuICB0aGlzLl9maWVsZHMgPSBbXTtcbiAgdGhpcy5fb3V0ID0gW107XG5cbiAgdGhpcy5fdHlwZSA9IFRZUEVTLlRVUExFOyBcbiAgdGhpcy5fYWNjID0ge2dyb3VwYnk6IGRsLnRydWUsIHZhbHVlOiBkbC50cnVlfTtcblxuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSkucHJvZHVjZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoQWdncmVnYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWdncmVnYXRlO1xuXG52YXIgVFlQRVMgPSBBZ2dyZWdhdGUuVFlQRVMgPSB7XG4gIFZBTFVFOiAxLCBcbiAgVFVQTEU6IDIsIFxuICBNVUxUSTogM1xufTtcblxuQWdncmVnYXRlLlZBTElEX09QUyA9IFtcbiAgJ3ZhbHVlcycsICdjb3VudCcsICd2YWxpZCcsICdtaXNzaW5nJywgJ2Rpc3RpbmN0JywgXG4gICdzdW0nLCAnbWVhbicsICdhdmVyYWdlJywgJ3ZhcmlhbmNlJywgJ3ZhcmlhbmNlcCcsICdzdGRldicsIFxuICAnc3RkZXZwJywgJ21lZGlhbicsICdxMScsICdxMycsICdtb2Rlc2tldycsICdtaW4nLCAnbWF4JywgXG4gICdhcmdtaW4nLCAnYXJnbWF4J1xuXTtcblxucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKSB7IFxuICByZXR1cm4gKHRoaXMuX3R5cGUgPSB0eXBlLCB0aGlzKTsgXG59O1xuXG5wcm90b3R5cGUuYWNjZXNzb3JzID0gZnVuY3Rpb24oZ3JvdXBieSwgdmFsdWUpIHtcbiAgdmFyIGFjYyA9IHRoaXMuX2FjYztcbiAgYWNjLmdyb3VwYnkgPSBkbC4kKGdyb3VwYnkpIHx8IGRsLnRydWU7XG4gIGFjYy52YWx1ZSA9IGRsLiQodmFsdWUpIHx8IGRsLnRydWU7XG59O1xuXG5wcm90b3R5cGUuYWdnciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fYWdncikgcmV0dXJuIHRoaXMuX2FnZ3I7XG5cbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGhhc0dldHRlciA9IGZhbHNlLFxuICAgICAgYXJncyA9IFtdLFxuICAgICAgZ3JvdXBieSA9IHRoaXMucGFyYW0oJ2dyb3VwYnknKS5maWVsZCxcbiAgICAgIHZhbHVlID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geC5zaWduYWwgPyBnLnNpZ25hbFJlZih4LnNpZ25hbCkgOiB4OyB9O1xuXG4gIC8vIFByZXBhcmUgc3VtbWFyaXplIGZpZWxkcy5cbiAgdmFyIGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBmaWVsZCA9IHtcbiAgICAgIG5hbWU6IHZhbHVlKGYuZmllbGQpLFxuICAgICAgYXM6ICAgZGwuYXJyYXkoZi5hcyksXG4gICAgICBvcHM6ICBkbC5hcnJheSh2YWx1ZShmLm9wcykpLm1hcCh2YWx1ZSksXG4gICAgICBnZXQ6ICBmLmdldFxuICAgIH07XG4gICAgaGFzR2V0dGVyID0gaGFzR2V0dGVyIHx8IGZpZWxkLmdldCAhPSBudWxsO1xuICAgIGFyZ3MucHVzaChmaWVsZC5uYW1lKTtcbiAgICByZXR1cm4gZmllbGQ7XG4gIH0pO1xuXG4gIC8vIElmIHRoZXJlIGlzIGFuIGFyYml0cmFyeSBnZXR0ZXIsIGFsbCBiZXRzIGFyZSBvZmYuXG4gIC8vIE90aGVyd2lzZSwgd2UgY2FuIGNoZWNrIGFyZ3VtZW50IGZpZWxkcyB0byBjdWxsIHJlLWNvbXB1dGF0aW9uLlxuICBncm91cGJ5LmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgIGlmIChnLmdldCkgaGFzR2V0dGVyID0gdHJ1ZTtcbiAgICBhcmdzLnB1c2goZy5uYW1lIHx8IGcpO1xuICB9KTtcbiAgdGhpcy5fYXJncyA9IGhhc0dldHRlciB8fCAhZmllbGRzLmxlbmd0aCA/IG51bGwgOiBhcmdzO1xuXG4gIGlmICghZmllbGRzLmxlbmd0aCkgZmllbGRzID0geycqJzogJ3ZhbHVlcyd9O1xuXG4gIC8vIEluc3RhdGlhdGUgb3VyIGFnZ3JlZ2F0b3IgaW5zdGFuY2UuXG4gIC8vIEZhY2V0b3IgaXMgYSBzcGVjaWFsIHN1YmNsYXNzIHRoYXQgY2FuIGZhY2V0IGludG8gZGF0YSBwaXBlbGluZXMuXG4gIHZhciBhZ2dyID0gdGhpcy5fYWdnciA9IG5ldyBGYWNldG9yKClcbiAgICAuZ3JvdXBieShncm91cGJ5KVxuICAgIC5zdHJlYW0odHJ1ZSlcbiAgICAuc3VtbWFyaXplKGZpZWxkcyk7XG5cbiAgLy8gQ29sbGVjdCBvdXRwdXQgZmllbGRzIHNldHMgYnkgdGhpcyBhZ2dyZWdhdGUuXG4gIHRoaXMuX291dCA9IGdldEZpZWxkcyhhZ2dyKTtcblxuICAvLyBJZiB3ZSBhcmUgcHJvY2Vzc2luZyB0dXBsZXMsIGtleSB0aGVtIGJ5ICdfaWQnLlxuICBpZiAodGhpcy5fdHlwZSAhPT0gVFlQRVMuVkFMVUUpIHsgYWdnci5rZXkoJ19pZCcpOyB9XG5cbiAgcmV0dXJuIGFnZ3I7XG59O1xuXG5mdW5jdGlvbiBnZXRGaWVsZHMoYWdncikge1xuICAvLyBDb2xsZWN0IHRoZSBvdXRwdXQgZmllbGRzIHNldCBieSB0aGlzIGFnZ3JlZ2F0ZS5cbiAgdmFyIGYgPSBbXSwgaSwgbiwgaiwgbSwgZGltcywgdmFscywgbWVhcztcblxuICBkaW1zID0gYWdnci5fZGltcztcbiAgZm9yIChpPTAsIG49ZGltcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZi5wdXNoKGRpbXNbaV0ubmFtZSk7XG4gIH1cblxuICB2YWxzID0gYWdnci5fYWdncjtcbiAgZm9yIChpPTAsIG49dmFscy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgbWVhcyA9IHZhbHNbaV0ubWVhc3VyZXMuZmllbGRzO1xuICAgIGZvciAoaj0wLCBtPW1lYXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgZi5wdXNoKG1lYXNbal0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmO1xufVxuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydhZ2dyZWdhdGUnXSk7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIFVzZWQgYnkgRmFjZXRvci5fb25fa2VlcC5cblxuICB2YXIgb3V0cHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBhZ2dyID0gdGhpcy5hZ2dyKCksXG4gICAgICBvdXQgPSB0aGlzLl9vdXQsXG4gICAgICBhcmdzID0gdGhpcy5fYXJncyxcbiAgICAgIHJlZXZhbCA9IHRydWUsXG4gICAgICBwID0gVHVwbGUucHJldixcbiAgICAgIGFkZCwgcmVtLCBtb2QsIGk7XG5cbiAgLy8gVXBvbiByZXNldCwgcmV0cmFjdCBwcmlvciB0dXBsZXMgYW5kIHJlLWluaXRpYWxpemUuXG4gIGlmIChyZXNldCkge1xuICAgIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCBhZ2dyLnJlc3VsdCgpKTtcbiAgICBhZ2dyLmNsZWFyKCk7XG4gICAgdGhpcy5fYWdnciA9IG51bGw7XG4gICAgYWdnciA9IHRoaXMuYWdncigpO1xuICB9XG5cbiAgLy8gR2V0IHVwZGF0ZSBtZXRob2RzIGFjY29yZGluZyB0byBpbnB1dCB0eXBlLlxuICBpZiAodGhpcy5fdHlwZSA9PT0gVFlQRVMuVFVQTEUpIHtcbiAgICBhZGQgPSBmdW5jdGlvbih4KSB7IGFnZ3IuX2FkZCh4KTsgVHVwbGUucHJldl9pbml0KHgpOyB9O1xuICAgIHJlbSA9IGZ1bmN0aW9uKHgpIHsgYWdnci5fcmVtKHAoeCkpOyB9O1xuICAgIG1vZCA9IGZ1bmN0aW9uKHgpIHsgYWdnci5fbW9kKHgsIHAoeCkpOyB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBnYnkgPSB0aGlzLl9hY2MuZ3JvdXBieSxcbiAgICAgICAgdmFsID0gdGhpcy5fYWNjLnZhbHVlLFxuICAgICAgICBnZXQgPSB0aGlzLl90eXBlID09PSBUWVBFUy5WQUxVRSA/IHZhbCA6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4geyBfaWQ6IHguX2lkLCBncm91cGJ5OiBnYnkoeCksIHZhbHVlOiB2YWwoeCkgfTtcbiAgICAgICAgfTtcbiAgICBhZGQgPSBmdW5jdGlvbih4KSB7IGFnZ3IuX2FkZChnZXQoeCkpOyBUdXBsZS5wcmV2X2luaXQoeCk7IH07XG4gICAgcmVtID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9yZW0oZ2V0KHAoeCkpKTsgfTtcbiAgICBtb2QgPSBmdW5jdGlvbih4KSB7IGFnZ3IuX21vZChnZXQoeCksIGdldChwKHgpKSk7IH07XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChhZGQpO1xuICBpZiAocmVzZXQpIHtcbiAgICAvLyBBIHNpZ25hbCBjaGFuZ2UgdHJpZ2dlcmVkIHJlZmxvdy4gQWRkIGV2ZXJ5dGhpbmcuXG4gICAgLy8gTm8gbmVlZCBmb3IgcmVtLCB3ZSBjbGVhcmVkIHRoZSBhZ2dyZWdhdG9yLlxuICAgIGlucHV0Lm1vZC5mb3JFYWNoKGFkZCk7XG4gIH0gZWxzZSB7XG4gICAgaW5wdXQucmVtLmZvckVhY2gocmVtKTtcblxuICAgIC8vIElmIHBvc3NpYmxlLCBjaGVjayBhcmd1bWVudCBmaWVsZHMgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmUtcHJvY2VzcyBtb2RzLlxuICAgIGlmIChhcmdzKSBmb3IgKGk9MCwgcmVldmFsPWZhbHNlOyBpPGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpbnB1dC5maWVsZHNbYXJnc1tpXV0pIHsgcmVldmFsID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHJlZXZhbCkgaW5wdXQubW9kLmZvckVhY2gobW9kKTtcbiAgfVxuXG4gIC8vIEluZGljYXRlIG91dHB1dCBmaWVsZHMgYW5kIHJldHVybiBhZ2dyZWdhdGUgdHVwbGVzLlxuICBmb3IgKGk9MDsgaTxvdXQubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRwdXQuZmllbGRzW291dFtpXV0gPSAxO1xuICB9XG4gIHJldHVybiBhZ2dyLmNoYW5nZXMob3V0cHV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRlOyIsInZhciBCYXNlID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIEJhdGNoVHJhbnNmb3JtKCkge1xuICAvLyBOZWFyZXN0IGFwcHJvcHJpYXRlIGNvbGxlY3Rvci4gXG4gIC8vIFNldCBieSB0aGUgZGF0YWZsb3cgR3JhcGggZHVyaW5nIGNvbm5lY3Rpb24uXG4gIHRoaXMuX2NvbGxlY3RvciA9IG51bGw7IFxufVxuXG52YXIgcHJvdG90eXBlID0gKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmF0Y2hUcmFuc2Zvcm07XG5cbnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICByZXR1cm4gdGhpcy5iYXRjaCh0cnVlKTtcbn07XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gdGhpcy5iYXRjaFRyYW5zZm9ybShpbnB1dCwgdGhpcy5fY29sbGVjdG9yLmRhdGEoKSk7XG59O1xuXG5wcm90b3R5cGUuYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbigvKiBpbnB1dCwgZGF0YSAqLykge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFRyYW5zZm9ybTsiLCJ2YXIgYmlucyA9IHJlcXVpcmUoJ2RhdGFsaWInKS5iaW5zLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEJpbihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6ICdmaWVsZCd9LFxuICAgIG1pbjoge3R5cGU6ICd2YWx1ZSd9LFxuICAgIG1heDoge3R5cGU6ICd2YWx1ZSd9LFxuICAgIGJhc2U6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAxMH0sXG4gICAgbWF4Ymluczoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDIwfSxcbiAgICBzdGVwOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgc3RlcHM6IHt0eXBlOiAndmFsdWUnfSxcbiAgICBtaW5zdGVwOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgZGl2OiB7dHlwZTogJ2FycmF5PHZhbHVlPicsIGRlZmF1bHQ6IFs1LCAyXX1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge2JpbjogJ2Jpbid9O1xuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEJpbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbjtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydiaW5uaW5nJ10pO1xuXG4gIHZhciBvdXRwdXQgID0gdGhpcy5fb3V0cHV0LmJpbixcbiAgICAgIHN0ZXAgICAgPSB0aGlzLnBhcmFtKCdzdGVwJyksXG4gICAgICBzdGVwcyAgID0gdGhpcy5wYXJhbSgnc3RlcHMnKSxcbiAgICAgIG1pbnN0ZXAgPSB0aGlzLnBhcmFtKCdtaW5zdGVwJyksXG4gICAgICBnZXQgICAgID0gdGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvcixcbiAgICAgIG9wdCA9IHtcbiAgICAgICAgbWluOiB0aGlzLnBhcmFtKCdtaW4nKSxcbiAgICAgICAgbWF4OiB0aGlzLnBhcmFtKCdtYXgnKSxcbiAgICAgICAgYmFzZTogdGhpcy5wYXJhbSgnYmFzZScpLFxuICAgICAgICBtYXhiaW5zOiB0aGlzLnBhcmFtKCdtYXhiaW5zJyksXG4gICAgICAgIGRpdjogdGhpcy5wYXJhbSgnZGl2JylcbiAgICAgIH07XG5cbiAgaWYgKHN0ZXApIG9wdC5zdGVwID0gc3RlcDtcbiAgaWYgKHN0ZXBzKSBvcHQuc3RlcHMgPSBzdGVwcztcbiAgaWYgKG1pbnN0ZXApIG9wdC5taW5zdGVwID0gbWluc3RlcDtcbiAgdmFyIGIgPSBiaW5zKG9wdCk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IGdldChkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgVHVwbGUuc2V0KGQsIG91dHB1dCwgdik7XG4gIH1cbiAgaW5wdXQuYWRkLmZvckVhY2godXBkYXRlKTtcbiAgaW5wdXQubW9kLmZvckVhY2godXBkYXRlKTtcbiAgaW5wdXQucmVtLmZvckVhY2godXBkYXRlKTtcblxuICBpbnB1dC5maWVsZHNbb3V0cHV0XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluOyIsInZhciBkZiA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKSxcbiAgICBUdXBsZSA9IGRmLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIENvdW50UGF0dGVybihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDogICAgIHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnZGF0YSd9LFxuICAgIHBhdHRlcm46ICAge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdbXFxcXHdcXCddKyd9LFxuICAgIGNhc2U6ICAgICAge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdsb3dlcid9LFxuICAgIHN0b3B3b3Jkczoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICcnfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7dGV4dDogJ3RleHQnLCBjb3VudDogJ2NvdW50J307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpLnByb2R1Y2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKENvdW50UGF0dGVybi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvdW50UGF0dGVybjtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnY291bnRwYXR0ZXJuJ10pO1xuXG4gIHZhciBnZXQgPSB0aGlzLnBhcmFtKCdmaWVsZCcpLmFjY2Vzc29yLFxuICAgICAgcGF0dGVybiA9IHRoaXMucGFyYW0oJ3BhdHRlcm4nKSxcbiAgICAgIHN0b3AgPSB0aGlzLnBhcmFtKCdzdG9wd29yZHMnKSxcbiAgICAgIHJlbSA9IGZhbHNlO1xuXG4gIC8vIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gIGlmICh0aGlzLl9zdG9wICE9PSBzdG9wKSB7XG4gICAgdGhpcy5fc3RvcCA9IHN0b3A7XG4gICAgdGhpcy5fc3RvcF9yZSA9IG5ldyBSZWdFeHAoJ14nICsgc3RvcCArICckJywgJ2knKTtcbiAgICByZXNldCA9IHRydWU7XG4gIH1cblxuICBpZiAodGhpcy5fcGF0dGVybiAhPT0gcGF0dGVybikge1xuICAgIHRoaXMuX3BhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHRoaXMuX21hdGNoID0gbmV3IFJlZ0V4cCh0aGlzLl9wYXR0ZXJuLCAnZycpO1xuICAgIHJlc2V0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyZXNldCkgdGhpcy5fY291bnRzID0ge307XG5cbiAgZnVuY3Rpb24gY3Vycih0KSB7IHJldHVybiAoVHVwbGUucHJldl9pbml0KHQpLCBnZXQodCkpOyB9XG4gIGZ1bmN0aW9uIHByZXYodCkgeyByZXR1cm4gZ2V0KFR1cGxlLnByZXYodCkpOyB9XG5cbiAgdGhpcy5fYWRkKGlucHV0LmFkZCwgY3Vycik7XG4gIGlmICghcmVzZXQpIHRoaXMuX3JlbShpbnB1dC5yZW0sIHByZXYpO1xuICBpZiAocmVzZXQgfHwgKHJlbSA9IGlucHV0LmZpZWxkc1tnZXQuZmllbGRdKSkge1xuICAgIGlmIChyZW0pIHRoaXMuX3JlbShpbnB1dC5tb2QsIHByZXYpO1xuICAgIHRoaXMuX2FkZChpbnB1dC5tb2QsIGN1cnIpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgb3V0cHV0IHR1cGxlc1xuICByZXR1cm4gdGhpcy5fY2hhbmdlc2V0KGlucHV0KTtcbn07XG5cbnByb3RvdHlwZS5fY2hhbmdlc2V0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGNvdW50cyA9IHRoaXMuX2NvdW50cyxcbiAgICAgIHR1cGxlcyA9IHRoaXMuX3R1cGxlcyB8fCAodGhpcy5fdHVwbGVzID0ge30pLFxuICAgICAgY2hhbmdlID0gZGYuQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBvdXQgPSB0aGlzLl9vdXRwdXQsIHcsIHQsIGM7XG5cbiAgZm9yICh3IGluIGNvdW50cykge1xuICAgIHQgPSB0dXBsZXNbd107XG4gICAgYyA9IGNvdW50c1t3XSB8fCAwO1xuICAgIGlmICghdCAmJiBjKSB7XG4gICAgICB0dXBsZXNbd10gPSAodCA9IFR1cGxlLmluZ2VzdCh7fSkpO1xuICAgICAgdFtvdXQudGV4dF0gPSB3O1xuICAgICAgdFtvdXQuY291bnRdID0gYztcbiAgICAgIGNoYW5nZS5hZGQucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDApIHtcbiAgICAgIGlmICh0KSBjaGFuZ2UucmVtLnB1c2godCk7XG4gICAgICBkZWxldGUgY291bnRzW3ddO1xuICAgICAgZGVsZXRlIHR1cGxlc1t3XTtcbiAgICB9IGVsc2UgaWYgKHRbb3V0LmNvdW50XSAhPT0gYykge1xuICAgICAgVHVwbGUuc2V0KHQsIG91dC5jb3VudCwgYyk7XG4gICAgICBjaGFuZ2UubW9kLnB1c2godCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2U7XG59O1xuXG5wcm90b3R5cGUuX3Rva2VuaXplID0gZnVuY3Rpb24odGV4dCkge1xuICBzd2l0Y2ggKHRoaXMucGFyYW0oJ2Nhc2UnKSkge1xuICAgIGNhc2UgJ3VwcGVyJzogdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTsgYnJlYWs7XG4gICAgY2FzZSAnbG93ZXInOiB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGV4dC5tYXRjaCh0aGlzLl9tYXRjaCk7XG59O1xuXG5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHR1cGxlcywgZ2V0KSB7XG4gIHZhciBjb3VudHMgPSB0aGlzLl9jb3VudHMsXG4gICAgICBzdG9wID0gdGhpcy5fc3RvcF9yZSxcbiAgICAgIHRvaywgaSwgaiwgdDtcblxuICBmb3IgKGo9MDsgajx0dXBsZXMubGVuZ3RoOyArK2opIHtcbiAgICB0b2sgPSB0aGlzLl90b2tlbml6ZShnZXQodHVwbGVzW2pdKSk7XG4gICAgZm9yIChpPTA7IGk8dG9rLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIXN0b3AudGVzdCh0PXRva1tpXSkpIHtcbiAgICAgICAgY291bnRzW3RdID0gMSArIChjb3VudHNbdF0gfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5wcm90b3R5cGUuX3JlbSA9IGZ1bmN0aW9uKHR1cGxlcywgZ2V0KSB7XG4gIHZhciBjb3VudHMgPSB0aGlzLl9jb3VudHMsXG4gICAgICBzdG9wID0gdGhpcy5fc3RvcF9yZSxcbiAgICAgIHRvaywgaSwgaiwgdDtcblxuICBmb3IgKGo9MDsgajx0dXBsZXMubGVuZ3RoOyArK2opIHtcbiAgICB0b2sgPSB0aGlzLl90b2tlbml6ZShnZXQodHVwbGVzW2pdKSk7XG4gICAgZm9yIChpPTA7IGk8dG9rLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIXN0b3AudGVzdCh0PXRva1tpXSkpIHtcbiAgICAgICAgY291bnRzW3RdIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvdW50UGF0dGVybjsiLCJ2YXIgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgQ2hhbmdlU2V0ID0gZGYuQ2hhbmdlU2V0LFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgU0lHTkFMUyA9IGRmLkRlcGVuZGVuY2llcy5TSUdOQUxTLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIENyb3NzKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgd2l0aDoge3R5cGU6ICdkYXRhJ30sXG4gICAgZGlhZ29uYWw6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAndHJ1ZSd9LFxuICAgIGZpbHRlcjoge3R5cGU6ICdleHByJ31cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0geydsZWZ0JzogJ2EnLCAncmlnaHQnOiAnYid9O1xuICB0aGlzLl9sYXN0UmVtICA9IG51bGw7IC8vIE1vc3QgcmVjZW50IHN0YW1wIHRoYXQgcmVtIG9jY3VyZWQuIFxuICB0aGlzLl9sYXN0V2l0aCA9IG51bGw7IC8vIExhc3QgdGltZSB3ZSBjcm9zc2VkIHcvd2l0aGRzLlxuICB0aGlzLl9pZHMgICA9IHt9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5wcm9kdWNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChDcm9zcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3Jvc3M7XG5cbi8vIEVhY2ggY2FjaGVkIGluY29taW5nIHR1cGxlIGFsc28gaGFzIGEgc3RhbXAgdG8gdHJhY2sgaWYgd2UgbmVlZCB0byBkb1xuLy8gbGF6eSBmaWx0ZXJpbmcgb2YgcmVtb3ZlZCB0dXBsZXMuXG5mdW5jdGlvbiBjYWNoZSh4LCB0KSB7XG4gIHZhciBjID0gdGhpcy5fY2FjaGVbeC5faWRdID0gdGhpcy5fY2FjaGVbeC5faWRdIHx8IHtjOiBbXSwgczogdGhpcy5fc3RhbXB9O1xuICBjLmMucHVzaCh0KTtcbn1cblxuZnVuY3Rpb24gYWRkKG91dHB1dCwgbGVmdCwgZGF0YSwgZGlhZywgdGVzdCwgeCkge1xuICB2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoLCB0ID0ge30sIHksIGlkO1xuXG4gIGZvciAoOyBpPGxlbjsgKytpKSB7XG4gICAgeSA9IGRhdGFbaV07XG4gICAgaWQgPSBsZWZ0ID8geC5faWQrJ18nK3kuX2lkIDogeS5faWQrJ18nK3guX2lkO1xuICAgIGlmICh0aGlzLl9pZHNbaWRdKSBjb250aW51ZTtcbiAgICBpZiAoeC5faWQgPT0geS5faWQgJiYgIWRpYWcpIGNvbnRpbnVlO1xuXG4gICAgdFt0aGlzLl9vdXRwdXQubGVmdF0gID0gbGVmdCA/IHggOiB5O1xuICAgIHRbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IGxlZnQgPyB5IDogeDtcblxuICAgIC8vIE9ubHkgaW5nZXN0IGEgdHVwbGUgaWYgd2Uga2VlcCBpdCBhcm91bmQuXG4gICAgaWYgKCF0ZXN0IHx8IHRlc3QodCkpIHtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh0PVR1cGxlLmluZ2VzdCh0KSk7XG4gICAgICBjYWNoZS5jYWxsKHRoaXMsIHgsIHQpO1xuICAgICAgY2FjaGUuY2FsbCh0aGlzLCB5LCB0KTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSAxO1xuICAgICAgdCA9IHt9O1xuICAgIH0gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gbW9kKG91dHB1dCwgbGVmdCwgeCkge1xuICB2YXIgY3Jvc3MgPSB0aGlzLFxuICAgICAgYyA9IHRoaXMuX2NhY2hlW3guX2lkXTtcblxuICBpZiAodGhpcy5fbGFzdFJlbSA+IGMucykgeyAgLy8gUmVtb3ZlZCB0dXBsZXMgaGF2ZW4ndCBiZWVuIGZpbHRlcmVkIHlldFxuICAgIGMuYyA9IGMuYy5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHQgPSB5W2Nyb3NzLl9vdXRwdXRbbGVmdCA/ICdyaWdodCcgOiAnbGVmdCddXTtcbiAgICAgIHJldHVybiBjcm9zcy5fY2FjaGVbdC5faWRdICE9PSBudWxsO1xuICAgIH0pO1xuICAgIGMucyA9IHRoaXMuX2xhc3RSZW07XG4gIH1cblxuICBvdXRwdXQubW9kLnB1c2guYXBwbHkob3V0cHV0Lm1vZCwgYy5jKTtcbn1cblxuZnVuY3Rpb24gcmVtKG91dHB1dCwgeCkge1xuICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgdGhpcy5fY2FjaGVbeC5faWRdLmMpO1xuICB0aGlzLl9jYWNoZVt4Ll9pZF0gPSBudWxsO1xuICB0aGlzLl9sYXN0UmVtID0gdGhpcy5fc3RhbXA7XG59XG5cbmZ1bmN0aW9uIHVwRmllbGRzKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYgKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmxlZnRdICA9IDE7IFxuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IDE7XG4gIH1cbn1cblxucHJvdG90eXBlLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2Nyb3NzaW5nJ10pO1xuXG4gIHZhciB3ID0gdGhpcy5wYXJhbSgnd2l0aCcpLFxuICAgICAgZiA9IHRoaXMucGFyYW0oJ2ZpbHRlcicpLFxuICAgICAgZGlhZyA9IHRoaXMucGFyYW0oJ2RpYWdvbmFsJyksXG4gICAgICBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgc2lnbmFscyA9IGdyYXBoLnZhbHVlcyhTSUdOQUxTLCB0aGlzLmRlcGVuZGVuY3koU0lHTkFMUykpLFxuICAgICAgdGVzdCA9IGYgPyBmdW5jdGlvbih4KSB7cmV0dXJuIGYoeCwgbnVsbCwgc2lnbmFscyk7IH0gOiBudWxsLFxuICAgICAgc2VsZkNyb3NzID0gKCF3Lm5hbWUpLFxuICAgICAgd291dHB1dCA9IHNlbGZDcm9zcyA/IGlucHV0IDogdy5zb3VyY2UubGFzdCgpLFxuICAgICAgd2RhdGEgICA9IHNlbGZDcm9zcyA/IGRhdGEgOiB3LnNvdXJjZS52YWx1ZXMoKSxcbiAgICAgIG91dHB1dCAgPSBDaGFuZ2VTZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIHIgPSByZW0uYmluZCh0aGlzLCBvdXRwdXQpO1xuXG4gIGlucHV0LnJlbS5mb3JFYWNoKHIpO1xuICBpbnB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUsIHdkYXRhLCBkaWFnLCB0ZXN0KSk7XG5cbiAgaWYgKCFzZWxmQ3Jvc3MgJiYgd291dHB1dC5zdGFtcCA+IHRoaXMuX2xhc3RXaXRoKSB7XG4gICAgd291dHB1dC5yZW0uZm9yRWFjaChyKTtcbiAgICB3b3V0cHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgZmFsc2UsIGRhdGEsIGRpYWcsIHRlc3QpKTtcbiAgICB3b3V0cHV0Lm1vZC5mb3JFYWNoKG1vZC5iaW5kKHRoaXMsIG91dHB1dCwgZmFsc2UpKTtcbiAgICB1cEZpZWxkcy5jYWxsKHRoaXMsIHdvdXRwdXQsIG91dHB1dCk7XG4gICAgdGhpcy5fbGFzdFdpdGggPSB3b3V0cHV0LnN0YW1wO1xuICB9XG5cbiAgLy8gTW9kcyBuZWVkIHRvIGNvbWUgYWZ0ZXIgYWxsIHJlbW92YWxzIGhhdmUgYmVlbiBydW4uXG4gIGlucHV0Lm1vZC5mb3JFYWNoKG1vZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSkpO1xuICB1cEZpZWxkcy5jYWxsKHRoaXMsIGlucHV0LCBvdXRwdXQpO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyb3NzOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vQWdncmVnYXRlJyk7XG5cbmZ1bmN0aW9uIEZhY2V0KGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB0cmFuc2Zvcm06IHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJhbnNmb3JtLl9waXBlbGluZSA9IHBpcGVsaW5lLCB0aGlzLl90cmFuc2Zvcm0pO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlL3RyYW5zZm9ybXMnKSxcbiAgICAgICAgICAgIGZhY2V0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4gZmFjZXQuX3BpcGVsaW5lLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlKGZhY2V0Ll9ncmFwaCwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAgICAgIFxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5fcGlwZWxpbmUgPSBbXTtcbiAgcmV0dXJuIEFnZ3JlZ2F0ZS5jYWxsKHRoaXMsIGdyYXBoKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChGYWNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFnZ3JlZ2F0ZS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZhY2V0O1xuXG5wcm90b3R5cGUuYWdnciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQWdncmVnYXRlLnByb3RvdHlwZS5hZ2dyLmNhbGwodGhpcykuZmFjZXQodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBBZ2dyZWdhdG9yID0gZGwuQWdncmVnYXRvcixcbiAgICBCYXNlID0gQWdncmVnYXRvci5wcm90b3R5cGUsXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgVHVwbGUgPSBkZi5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBmYWNldElEID0gMDtcblxuZnVuY3Rpb24gRmFjZXRvcigpIHtcbiAgQWdncmVnYXRvci5jYWxsKHRoaXMpO1xuICB0aGlzLl9mYWNldCA9IG51bGw7XG4gIHRoaXMuX2ZhY2V0SUQgPSArK2ZhY2V0SUQ7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoRmFjZXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZhY2V0b3I7XG5cbnByb3RvdHlwZS5mYWNldCA9IGZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5fZmFjZXQgPSBmLCB0aGlzKSA6IHRoaXMuX2ZhY2V0O1xufTtcblxucHJvdG90eXBlLl9pbmdlc3QgPSBmdW5jdGlvbih0KSB7IFxuICByZXR1cm4gVHVwbGUuaW5nZXN0KHQsIG51bGwpO1xufTtcblxucHJvdG90eXBlLl9hc3NpZ24gPSBUdXBsZS5zZXQ7XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RfY2VsbChmYWNldCkge1xuICBsb2cuZGVidWcoe30sIFsnZGlzY29ubmVjdGluZyBjZWxsJywgdGhpcy50dXBsZS5faWRdKTtcbiAgdmFyIHBpcGVsaW5lID0gdGhpcy5kcy5waXBlbGluZSgpO1xuICBmYWNldC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gIGZhY2V0Ll9ncmFwaC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gIGZhY2V0Ll9ncmFwaC5kaXNjb25uZWN0KHBpcGVsaW5lKTtcbn1cblxucHJvdG90eXBlLl9uZXdjZWxsID0gZnVuY3Rpb24oeCwga2V5KSB7XG4gIHZhciBjZWxsICA9IEJhc2UuX25ld2NlbGwuY2FsbCh0aGlzLCB4LCBrZXkpLFxuICAgICAgZmFjZXQgPSB0aGlzLl9mYWNldDtcblxuICBpZiAoZmFjZXQpIHtcbiAgICB2YXIgZ3JhcGggPSBmYWNldC5fZ3JhcGgsXG4gICAgICAgIHR1cGxlID0gY2VsbC50dXBsZSxcbiAgICAgICAgcGlwZWxpbmUgPSBmYWNldC5wYXJhbSgndHJhbnNmb3JtJyk7XG4gICAgY2VsbC5kcyA9IGdyYXBoLmRhdGEodHVwbGUuX2ZhY2V0SUQsIHBpcGVsaW5lLCB0dXBsZSk7XG4gICAgY2VsbC5kaXNjb25uZWN0ID0gZGlzY29ubmVjdF9jZWxsO1xuICAgIGZhY2V0LmFkZExpc3RlbmVyKHBpcGVsaW5lWzBdKTtcbiAgfVxuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG90eXBlLl9uZXd0dXBsZSA9IGZ1bmN0aW9uKHgsIGtleSkge1xuICB2YXIgdCA9IEJhc2UuX25ld3R1cGxlLmNhbGwodGhpcywgeCk7XG4gIGlmICh0aGlzLl9mYWNldCkge1xuICAgIFR1cGxlLnNldCh0LCAna2V5Jywga2V5KTtcbiAgICBUdXBsZS5zZXQodCwgJ19mYWNldElEJywgdGhpcy5fZmFjZXRJRCArICdfJyArIGtleSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgICAgdGhpcy5fY2VsbHNba10uZGlzY29ubmVjdCh0aGlzLl9mYWNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBCYXNlLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG5wcm90b3R5cGUuX29uX2FkZCA9IGZ1bmN0aW9uKHgsIGNlbGwpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSBjZWxsLmRzLl9pbnB1dC5hZGQucHVzaCh4KTtcbn07XG5cbnByb3RvdHlwZS5fb25fcmVtID0gZnVuY3Rpb24oeCwgY2VsbCkge1xuICBpZiAodGhpcy5fZmFjZXQpIGNlbGwuZHMuX2lucHV0LnJlbS5wdXNoKHgpO1xufTtcblxucHJvdG90eXBlLl9vbl9tb2QgPSBmdW5jdGlvbih4LCBwcmV2LCBjZWxsMCwgY2VsbDEpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSB7IC8vIFByb3BhZ2F0ZSB0dXBsZXNcbiAgICBpZiAoY2VsbDAgPT09IGNlbGwxKSB7XG4gICAgICBjZWxsMC5kcy5faW5wdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGwwLmRzLl9pbnB1dC5yZW0ucHVzaCh4KTtcbiAgICAgIGNlbGwxLmRzLl9pbnB1dC5hZGQucHVzaCh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnByb3RvdHlwZS5fb25fZHJvcCA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSBjZWxsLmRpc2Nvbm5lY3QodGhpcy5fZmFjZXQpO1xufTtcblxucHJvdG90eXBlLl9vbl9rZWVwID0gZnVuY3Rpb24oY2VsbCkge1xuICAvLyBwcm9wYWdhdGUgc29ydCwgc2lnbmFscywgZmllbGRzLCBldGMuXG4gIGlmICh0aGlzLl9mYWNldCkgZGYuQ2hhbmdlU2V0LmNvcHkodGhpcy5faW5wdXQsIGNlbGwuZHMuX2lucHV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXRvcjsiLCJ2YXIgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgU0lHTkFMUyA9IGRmLkRlcGVuZGVuY2llcy5TSUdOQUxTLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEZpbHRlcihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHt0ZXN0OiB7dHlwZTogJ2V4cHInfX0pO1xuXG4gIHRoaXMuX3NraXAgPSB7fTtcbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbHRlcjtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydmaWx0ZXJpbmcnXSk7XG5cbiAgdmFyIG91dHB1dCA9IGRmLkNoYW5nZVNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHNraXAgPSB0aGlzLl9za2lwLFxuICAgICAgdGVzdCA9IHRoaXMucGFyYW0oJ3Rlc3QnKSxcbiAgICAgIHNpZ25hbHMgPSBncmFwaC52YWx1ZXMoU0lHTkFMUywgdGhpcy5kZXBlbmRlbmN5KFNJR05BTFMpKTtcblxuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYgKHNraXBbeC5faWRdICE9PSAxKSBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgZWxzZSBza2lwW3guX2lkXSA9IDA7XG4gIH0pO1xuXG4gIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAodGVzdCh4LCBudWxsLCBzaWduYWxzKSkgb3V0cHV0LmFkZC5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAxO1xuICB9KTtcblxuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdmFyIGIgPSB0ZXN0KHgsIG51bGwsIHNpZ25hbHMpLFxuICAgICAgICBzID0gKHNraXBbeC5faWRdID09PSAxKTtcbiAgICBpZiAoYiAmJiBzKSB7XG4gICAgICBza2lwW3guX2lkXSA9IDA7XG4gICAgICBvdXRwdXQuYWRkLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmIChiICYmICFzKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmICghYiAmJiBzKSB7XG4gICAgICAvLyBkbyBub3RoaW5nLCBrZWVwIHNraXAgdHJ1ZVxuICAgIH0gZWxzZSB7IC8vICFiICYmICFzXG4gICAgICBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgICBza2lwW3guX2lkXSA9IDE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gRm9sZChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZHM6IHt0eXBlOiAnYXJyYXk8ZmllbGQ+J30gXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtrZXk6ICdrZXknLCB2YWx1ZTogJ3ZhbHVlJ307XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpLnByb2R1Y2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEZvbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb2xkO1xuXG5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkgeyBcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgdGhpcy5fY2FjaGVbaWRdKTtcbiAgfVxuICB0aGlzLl9jYWNoZSA9IHt9O1xufTtcblxucHJvdG90eXBlLl90dXBsZSA9IGZ1bmN0aW9uKHgsIGksIGxlbikge1xuICB2YXIgbGlzdCA9IHRoaXMuX2NhY2hlW3guX2lkXSB8fCAodGhpcy5fY2FjaGVbeC5faWRdID0gQXJyYXkobGVuKSk7XG4gIHJldHVybiBsaXN0W2ldID8gVHVwbGUucmVkZXJpdmUoeCwgbGlzdFtpXSkgOiAobGlzdFtpXSA9IFR1cGxlLmRlcml2ZSh4KSk7XG59O1xuXG5wcm90b3R5cGUuX2ZuID0gZnVuY3Rpb24oZGF0YSwgb24sIG91dCkge1xuICB2YXIgaSwgaiwgbiwgbSwgZCwgdDtcbiAgZm9yIChpPTAsIG49ZGF0YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZCA9IGRhdGFbaV07XG4gICAgZm9yIChqPTAsIG09b24uZmllbGQubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdCA9IHRoaXMuX3R1cGxlKGQsIGosIG0pOyAgXG4gICAgICBUdXBsZS5zZXQodCwgdGhpcy5fb3V0cHV0LmtleSwgb24uZmllbGRbal0pO1xuICAgICAgVHVwbGUuc2V0KHQsIHRoaXMuX291dHB1dC52YWx1ZSwgb24uYWNjZXNzb3Jbal0oZCkpO1xuICAgICAgb3V0LnB1c2godCk7XG4gICAgfSAgICAgIFxuICB9XG59O1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydmb2xkaW5nJ10pO1xuXG4gIHZhciBmb2xkID0gdGhpcyxcbiAgICAgIG9uID0gdGhpcy5wYXJhbSgnZmllbGRzJyksXG4gICAgICBvdXRwdXQgPSBkZi5DaGFuZ2VTZXQuY3JlYXRlKGlucHV0KTtcblxuICBpZiAocmVzZXQpIHRoaXMuX3Jlc2V0KGlucHV0LCBvdXRwdXQpO1xuXG4gIHRoaXMuX2ZuKGlucHV0LmFkZCwgb24sIG91dHB1dC5hZGQpO1xuICB0aGlzLl9mbihpbnB1dC5tb2QsIG9uLCByZXNldCA/IG91dHB1dC5hZGQgOiBvdXRwdXQubW9kKTtcbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCBmb2xkLl9jYWNoZVt4Ll9pZF0pO1xuICAgIGZvbGQuX2NhY2hlW3guX2lkXSA9IG51bGw7XG4gIH0pO1xuXG4gIC8vIElmIHdlJ3JlIG9ubHkgcHJvcGFnYXRpbmcgdmFsdWVzLCBkb24ndCBtYXJrIGtleS92YWx1ZSBhcyB1cGRhdGVkLlxuICBpZiAoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoIHx8IFxuICAgICAgb24uZmllbGQuc29tZShmdW5jdGlvbihmKSB7IHJldHVybiAhIWlucHV0LmZpZWxkc1tmXTsgfSkpIHtcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5rZXldID0gMTtcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC52YWx1ZV0gPSAxO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvbGQ7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgVHVwbGUgPSBkZi5UdXBsZSxcbiAgICBDaGFuZ2VTZXQgPSBkZi5DaGFuZ2VTZXQsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gRm9yY2UoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuXG4gIHRoaXMuX3ByZXYgPSBudWxsO1xuICB0aGlzLl9pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9zZXR1cCA9IHRydWU7XG4gIHRoaXMuX25vZGVzICA9IFtdO1xuICB0aGlzLl9saW5rcyA9IFtdO1xuICB0aGlzLl9sYXlvdXQgPSBkMy5sYXlvdXQuZm9yY2UoKTtcblxuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc2l6ZToge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbNTAwLCA1MDBdfSxcbiAgICBib3VuZDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IHRydWV9LFxuICAgIGxpbmtzOiB7dHlwZTogJ2RhdGEnfSxcblxuICAgIC8vIFRPRE86IGZvciBub3cgZm9yY2UgdGhlc2UgdG8gYmUgdmFsdWUgcGFyYW1zIG9ubHkgKHB1bi1pbnRlbmRlZClcbiAgICAvLyBDYW4gdXBkYXRlIHRvIGluY2x1ZGUgZmllbGRzIGFmdGVyIFBhcmFtZXRlciByZWZhY3RvcmluZy5cbiAgICBsaW5rU3RyZW5ndGg6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAxfSxcbiAgICBsaW5rRGlzdGFuY2U6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAyMH0sXG4gICAgY2hhcmdlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogLTMwfSxcblxuICAgIGNoYXJnZURpc3RhbmNlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogSW5maW5pdHl9LFxuICAgIGZyaWN0aW9uOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMC45fSxcbiAgICB0aGV0YToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDAuOH0sXG4gICAgZ3Jhdml0eToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDAuMX0sXG4gICAgYWxwaGE6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwLjF9LFxuICAgIGl0ZXJhdGlvbnM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiA1MDB9LFxuXG4gICAgaW50ZXJhY3RpdmU6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiB0aGlzLl9pbnRlcmFjdGl2ZX0sICAgIFxuICAgIGFjdGl2ZToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IHRoaXMuX3ByZXZ9LFxuICAgIGZpeGVkOiB7dHlwZTogJ2RhdGEnfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgJ3gnOiAnbGF5b3V0X3gnLFxuICAgICd5JzogJ2xheW91dF95J1xuICB9O1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoRm9yY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb3JjZTtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG5vZGVJbnB1dCwgcmVzZXQpIHtcbiAgbG9nLmRlYnVnKG5vZGVJbnB1dCwgWydmb3JjZSddKTtcbiAgcmVzZXQgPSByZXNldCAtIChub2RlSW5wdXQuc2lnbmFscy5hY3RpdmUgPyAxIDogMCk7XG5cbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgaW50ZXJhY3RpdmUgPSB0aGlzLnBhcmFtKCdpbnRlcmFjdGl2ZScpLFxuICAgICAgbGlua1NvdXJjZSA9IHRoaXMucGFyYW0oJ2xpbmtzJykuc291cmNlLFxuICAgICAgbGlua0lucHV0ID0gbGlua1NvdXJjZS5sYXN0KCksXG4gICAgICBhY3RpdmUgPSB0aGlzLnBhcmFtKCdhY3RpdmUnKSxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsaW5rcyA9IHRoaXMuX2xpbmtzO1xuXG4gIC8vIGNvbmZpZ3VyZSBub2RlcywgbGlua3MgYW5kIGxheW91dFxuICBpZiAobGlua0lucHV0LnN0YW1wIDwgbm9kZUlucHV0LnN0YW1wKSBsaW5rSW5wdXQgPSBudWxsO1xuICB0aGlzLmNvbmZpZ3VyZShub2RlSW5wdXQsIGxpbmtJbnB1dCwgaW50ZXJhY3RpdmUsIHJlc2V0KTtcbiAgXG4gIC8vIHJ1biBiYXRjaCBsYXlvdXRcbiAgaWYgKCFpbnRlcmFjdGl2ZSkge1xuICAgIHZhciBpdGVyYXRpb25zID0gdGhpcy5wYXJhbSgnaXRlcmF0aW9ucycpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpdGVyYXRpb25zOyArK2kpIGxheW91dC50aWNrKCk7XG4gICAgbGF5b3V0LnN0b3AoKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBub2RlIHBvc2l0aW9uc1xuICB0aGlzLnVwZGF0ZShhY3RpdmUpO1xuXG4gIC8vIHJlLXVwIGFscGhhIG9uIHBhcmFtZXRlciBjaGFuZ2VcbiAgaWYgKHJlc2V0IHx8IGFjdGl2ZSAhPT0gdGhpcy5fcHJldiAmJiBhY3RpdmUgJiYgYWN0aXZlLnVwZGF0ZSkge1xuICAgIGxheW91dC5hbHBoYSh0aGlzLnBhcmFtKCdhbHBoYScpKTsgLy8gcmUtc3RhcnQgbGF5b3V0XG4gIH1cblxuICAvLyB1cGRhdGUgYWN0aXZlIG5vZGUgc3RhdHVzLCBcbiAgaWYgKGFjdGl2ZSAhPT0gdGhpcy5fcHJldikge1xuICAgIHRoaXMuX3ByZXYgPSBhY3RpdmU7XG4gIH1cblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgbm9kZXMgb3IgZWRnZXNcbiAgaWYgKG5vZGVJbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgbGF5b3V0Lm5vZGVzKHRoaXMuX25vZGVzID0gVHVwbGUuaWRGaWx0ZXIobm9kZXMsIG5vZGVJbnB1dC5yZW0pKTtcbiAgfVxuICBpZiAobGlua0lucHV0ICYmIGxpbmtJbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgbGF5b3V0LmxpbmtzKHRoaXMuX2xpbmtzID0gVHVwbGUuaWRGaWx0ZXIobGlua3MsIGxpbmtJbnB1dC5yZW0pKTtcbiAgfVxuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBub2RlSW5wdXQ7XG59O1xuXG5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24obm9kZUlucHV0LCBsaW5rSW5wdXQsIGludGVyYWN0aXZlLCByZXNldCkge1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHJ1biBjb25maWd1cmF0aW9uXG4gIHZhciBsYXlvdXQgPSB0aGlzLl9sYXlvdXQsXG4gICAgICB1cGRhdGUgPSB0aGlzLl9zZXR1cCB8fCBub2RlSW5wdXQuYWRkLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGlua0lucHV0ICYmIGxpbmtJbnB1dC5hZGQubGVuZ3RoIHx8XG4gICAgICAgICAgICBpbnRlcmFjdGl2ZSAhPT0gdGhpcy5faW50ZXJhY3RpdmUgfHxcbiAgICAgICAgICAgIHRoaXMucGFyYW0oJ2NoYXJnZScpICE9PSBsYXlvdXQuY2hhcmdlKCkgfHxcbiAgICAgICAgICAgIHRoaXMucGFyYW0oJ2xpbmtTdHJlbmd0aCcpICE9PSBsYXlvdXQubGlua1N0cmVuZ3RoKCkgfHxcbiAgICAgICAgICAgIHRoaXMucGFyYW0oJ2xpbmtEaXN0YW5jZScpICE9PSBsYXlvdXQubGlua0Rpc3RhbmNlKCk7XG5cbiAgaWYgKHVwZGF0ZSB8fCByZXNldCkge1xuICAgIC8vIGEgcGFyYW1ldGVyIGNoYW5nZWQsIHNvIHVwZGF0ZSB0aWNrLW9ubHkgcGFyYW1ldGVyc1xuICAgIGxheW91dFxuICAgICAgLnNpemUodGhpcy5wYXJhbSgnc2l6ZScpKVxuICAgICAgLmNoYXJnZURpc3RhbmNlKHRoaXMucGFyYW0oJ2NoYXJnZURpc3RhbmNlJykpXG4gICAgICAudGhldGEodGhpcy5wYXJhbSgndGhldGEnKSlcbiAgICAgIC5ncmF2aXR5KHRoaXMucGFyYW0oJ2dyYXZpdHknKSlcbiAgICAgIC5mcmljdGlvbih0aGlzLnBhcmFtKCdmcmljdGlvbicpKTtcbiAgfVxuXG4gIGlmICghdXBkYXRlKSByZXR1cm47IC8vIGlmIG5vIG1vcmUgdXBkYXRlcyBuZWVkZWQsIHJldHVybiBub3dcblxuICB0aGlzLl9zZXR1cCA9IGZhbHNlO1xuICB0aGlzLl9pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXG4gIHZhciBmb3JjZSA9IHRoaXMsXG4gICAgICBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgIGxpbmtzID0gdGhpcy5fbGlua3MsIGEsIGk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBub2Rlc1xuICBmb3IgKGE9bm9kZUlucHV0LmFkZCwgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICBub2Rlcy5wdXNoKHt0dXBsZTogYVtpXX0pO1xuICB9XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBlZGdlc1xuICBpZiAobGlua0lucHV0KSBmb3IgKGE9bGlua0lucHV0LmFkZCwgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBUT0RPIGFkZCBjb25maWd1cmFibGUgc291cmNlL3RhcmdldCBhY2Nlc3NvcnNcbiAgICAvLyBUT0RPIHN1cHBvcnQgbG9va3VwIGJ5IG5vZGUgaWRcbiAgICAvLyBUT0RPIHByb2Nlc3MgJ21vZCcgb2YgZWRnZSBzb3VyY2Ugb3IgdGFyZ2V0P1xuICAgIGxpbmtzLnB1c2goe1xuICAgICAgdHVwbGU6ICBhW2ldLFxuICAgICAgc291cmNlOiBub2Rlc1thW2ldLnNvdXJjZV0sXG4gICAgICB0YXJnZXQ6IG5vZGVzW2FbaV0udGFyZ2V0XVxuICAgIH0pO1xuICB9XG5cbiAgLy8gc2V0dXAgaGFuZGxlciBmb3IgZm9yY2UgbGF5b3V0IHRpY2sgZXZlbnRzXG4gIHZhciB0aWNrSGFuZGxlciA9ICFpbnRlcmFjdGl2ZSA/IG51bGwgOiBmdW5jdGlvbigpIHtcbiAgICAvLyByZS1zY2hlZHVsZSB0aGUgdHJhbnNmb3JtLCBmb3JjZSByZWZsb3dcbiAgICBncmFwaC5wcm9wYWdhdGUoQ2hhbmdlU2V0LmNyZWF0ZShudWxsLCB0cnVlKSwgZm9yY2UpO1xuICB9O1xuXG4gIC8vIGNvbmZpZ3VyZSB0aGUgcmVzdCBvZiB0aGUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5saW5rU3RyZW5ndGgodGhpcy5wYXJhbSgnbGlua1N0cmVuZ3RoJykpXG4gICAgLmxpbmtEaXN0YW5jZSh0aGlzLnBhcmFtKCdsaW5rRGlzdGFuY2UnKSlcbiAgICAuY2hhcmdlKHRoaXMucGFyYW0oJ2NoYXJnZScpKVxuICAgIC5ub2Rlcyhub2RlcylcbiAgICAubGlua3MobGlua3MpXG4gICAgLm9uKCd0aWNrJywgdGlja0hhbmRsZXIpXG4gICAgLnN0YXJ0KCkuYWxwaGEodGhpcy5wYXJhbSgnYWxwaGEnKSk7XG59O1xuXG5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oYWN0aXZlKSB7XG4gIHZhciBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBib3VuZCA9IHRoaXMucGFyYW0oJ2JvdW5kJyksXG4gICAgICBmaXhlZCA9IHRoaXMucGFyYW0oJ2ZpeGVkJyksXG4gICAgICBzaXplID0gdGhpcy5wYXJhbSgnc2l6ZScpLFxuICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgIGx1dCA9IHt9LCBpZCwgaSwgbiwgdCwgeCwgeTtcblxuICBpZiAoZml4ZWQgJiYgZml4ZWQuc291cmNlKSB7XG4gICAgLy8gVE9ETzogY291bGQgY2FjaGUgYW5kIHVwZGF0ZSBhcyBuZWVkZWQ/XG4gICAgZml4ZWQgPSBmaXhlZC5zb3VyY2UudmFsdWVzKCk7XG4gICAgZm9yIChpPTAsIG49Zml4ZWQubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgbHV0W2ZpeGVkW2ldLmlkXSA9IDE7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICBuID0gbm9kZXNbaV07XG4gICAgdCA9IG4udHVwbGU7XG4gICAgaWQgPSB0Ll9pZDtcblxuICAgIGlmIChhY3RpdmUgJiYgYWN0aXZlLmlkID09PSBpZCkge1xuICAgICAgbi5maXhlZCA9IDE7XG4gICAgICBpZiAoYWN0aXZlLnVwZGF0ZSkge1xuICAgICAgICBuLnggPSBuLnB4ID0gYWN0aXZlLng7XG4gICAgICAgIG4ueSA9IG4ucHkgPSBhY3RpdmUueTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbi5maXhlZCA9IGx1dFtpZF0gfHwgMDtcbiAgICB9XG5cbiAgICB4ID0gYm91bmQgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihuLngsIHNpemVbMF0pKSA6IG4ueDtcbiAgICB5ID0gYm91bmQgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihuLnksIHNpemVbMV0pKSA6IG4ueTtcbiAgICBUdXBsZS5zZXQodCwgb3V0cHV0LngsIHgpO1xuICAgIFR1cGxlLnNldCh0LCBvdXRwdXQueSwgeSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yY2U7IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgU0lHTkFMUyA9IGRmLkRlcGVuZGVuY2llcy5TSUdOQUxTLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEZvcm11bGEoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiAndmFsdWUnfSxcbiAgICBleHByOiAge3R5cGU6ICdleHByJ31cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChGb3JtdWxhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9ybXVsYTtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydmb3JtdWxhdGluZyddKTtcblxuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgZmllbGQgPSB0aGlzLnBhcmFtKCdmaWVsZCcpLFxuICAgICAgZXhwciA9IHRoaXMucGFyYW0oJ2V4cHInKSxcbiAgICAgIHNpZ25hbHMgPSBnLnZhbHVlcyhTSUdOQUxTLCB0aGlzLmRlcGVuZGVuY3koU0lHTkFMUykpO1xuXG4gIGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgVHVwbGUuc2V0KHgsIGZpZWxkLCBleHByKHgsIG51bGwsIHNpZ25hbHMpKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIFxuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbZmllbGRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtdWxhOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIEdlbyhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGxvbjoge3R5cGU6ICdmaWVsZCd9LFxuICAgIGxhdDoge3R5cGU6ICdmaWVsZCd9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICAneCc6ICdsYXlvdXRfeCcsXG4gICAgJ3knOiAnbGF5b3V0X3knXG4gIH07XG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbkdlby5QYXJhbWV0ZXJzID0ge1xuICBwcm9qZWN0aW9uOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ21lcmNhdG9yJ30sXG4gIGNlbnRlcjogICAgIHt0eXBlOiAnYXJyYXk8dmFsdWU+J30sXG4gIHRyYW5zbGF0ZTogIHt0eXBlOiAnYXJyYXk8dmFsdWU+J30sXG4gIHJvdGF0ZTogICAgIHt0eXBlOiAnYXJyYXk8dmFsdWU+J30sXG4gIHNjYWxlOiAgICAgIHt0eXBlOiAndmFsdWUnfSxcbiAgcHJlY2lzaW9uOiAge3R5cGU6ICd2YWx1ZSd9LFxuICBjbGlwQW5nbGU6ICB7dHlwZTogJ3ZhbHVlJ30sXG4gIGNsaXBFeHRlbnQ6IHt0eXBlOiAndmFsdWUnfVxufTtcblxuR2VvLmQzUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcCA9IHRoaXMucGFyYW0oJ3Byb2plY3Rpb24nKSxcbiAgICAgIHBhcmFtID0gR2VvLlBhcmFtZXRlcnMsXG4gICAgICBwcm9qLCBuYW1lLCB2YWx1ZTtcblxuICBpZiAocCAhPT0gdGhpcy5fbW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSBwO1xuICAgIHRoaXMuX3Byb2plY3Rpb24gPSBkMy5nZW9bcF0oKTtcbiAgfVxuICBwcm9qID0gdGhpcy5fcHJvamVjdGlvbjtcblxuICBmb3IgKG5hbWUgaW4gcGFyYW0pIHtcbiAgICBpZiAobmFtZSA9PT0gJ3Byb2plY3Rpb24nIHx8ICFwcm9qW25hbWVdKSBjb250aW51ZTtcbiAgICB2YWx1ZSA9IHRoaXMucGFyYW0obmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgKGRsLmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHByb2pbbmFtZV0oKSkge1xuICAgICAgcHJvaltuYW1lXSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb2o7XG59O1xuXG52YXIgcHJvdG90eXBlID0gKEdlby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbztcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydnZW8nXSk7XG5cbiAgdmFyIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGxvbiA9IHRoaXMucGFyYW0oJ2xvbicpLmFjY2Vzc29yLFxuICAgICAgbGF0ID0gdGhpcy5wYXJhbSgnbGF0JykuYWNjZXNzb3IsXG4gICAgICBwcm9qID0gR2VvLmQzUHJvamVjdGlvbi5jYWxsKHRoaXMpO1xuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgdmFyIGxsID0gW2xvbih0KSwgbGF0KHQpXTtcbiAgICB2YXIgeHkgPSBwcm9qKGxsKSB8fCBbbnVsbCwgbnVsbF07XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC54LCB4eVswXSk7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC55LCB4eVsxXSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW87IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgR2VvID0gcmVxdWlyZSgnLi9HZW8nKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBHZW9QYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywgR2VvLlBhcmFtZXRlcnMpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiBudWxsfSxcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgICdwYXRoJzogJ2xheW91dF9wYXRoJ1xuICB9O1xuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEdlb1BhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW9QYXRoO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2dlb3BhdGgnXSk7XG5cbiAgdmFyIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGdlb2pzb24gPSB0aGlzLnBhcmFtKCdmaWVsZCcpLmFjY2Vzc29yIHx8IGRsLmlkZW50aXR5LFxuICAgICAgcHJvaiA9IEdlby5kM1Byb2plY3Rpb24uY2FsbCh0aGlzKSxcbiAgICAgIHBhdGggPSBkMy5nZW8ucGF0aCgpLnByb2plY3Rpb24ocHJvaik7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICBUdXBsZS5zZXQodCwgb3V0cHV0LnBhdGgsIHBhdGgoZ2VvanNvbih0KSkpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnBhdGhdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9QYXRoOyIsInZhciBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBMaW5rUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBzb3VyY2VYOiAge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdfc291cmNlLmxheW91dF94J30sXG4gICAgc291cmNlWTogIHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnX3NvdXJjZS5sYXlvdXRfeSd9LFxuICAgIHRhcmdldFg6ICB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ190YXJnZXQubGF5b3V0X3gnfSxcbiAgICB0YXJnZXRZOiAge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdfdGFyZ2V0LmxheW91dF95J30sXG4gICAgdGVuc2lvbjogIHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwLjJ9LFxuICAgIHNoYXBlOiAgICB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ2xpbmUnfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7J3BhdGgnOiAnbGF5b3V0X3BhdGgnfTtcbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChMaW5rUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmtQYXRoO1xuXG5mdW5jdGlvbiBsaW5lKHN4LCBzeSwgdHgsIHR5KSB7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICtcbiAgICAgICAgICdMJyArIHR4ICsgJywnICsgdHk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlKHN4LCBzeSwgdHgsIHR5LCB0ZW5zaW9uKSB7XG4gIHZhciBkeCA9IHR4IC0gc3gsXG4gICAgICBkeSA9IHR5IC0gc3ksXG4gICAgICBpeCA9IHRlbnNpb24gKiAoZHggKyBkeSksXG4gICAgICBpeSA9IHRlbnNpb24gKiAoZHkgLSBkeCk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICtcbiAgICAgICAgICdDJyArIChzeCtpeCkgKyAnLCcgKyAoc3kraXkpICtcbiAgICAgICAgICcgJyArICh0eCtpeSkgKyAnLCcgKyAodHktaXgpICtcbiAgICAgICAgICcgJyArIHR4ICsgJywnICsgdHk7XG59XG5cbmZ1bmN0aW9uIGRpYWdvbmFsWChzeCwgc3ksIHR4LCB0eSkge1xuICB2YXIgbSA9IChzeCArIHR4KSAvIDI7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICtcbiAgICAgICAgICdDJyArIG0gICsgJywnICsgc3kgK1xuICAgICAgICAgJyAnICsgbSAgKyAnLCcgKyB0eSArXG4gICAgICAgICAnICcgKyB0eCArICcsJyArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFkoc3gsIHN5LCB0eCwgdHkpIHtcbiAgdmFyIG0gPSAoc3kgKyB0eSkgLyAyO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArXG4gICAgICAgICAnQycgKyBzeCArICcsJyArIG0gK1xuICAgICAgICAgJyAnICsgdHggKyAnLCcgKyBtICtcbiAgICAgICAgICcgJyArIHR4ICsgJywnICsgdHk7XG59XG5cbnZhciBzaGFwZXMgPSB7XG4gIGxpbmU6ICAgICAgbGluZSxcbiAgY3VydmU6ICAgICBjdXJ2ZSxcbiAgZGlhZ29uYWw6ICBkaWFnb25hbFgsXG4gIGRpYWdvbmFsWDogZGlhZ29uYWxYLFxuICBkaWFnb25hbFk6IGRpYWdvbmFsWVxufTtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydsaW5rcGF0aCddKTtcblxuICB2YXIgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgc2hhcGUgPSBzaGFwZXNbdGhpcy5wYXJhbSgnc2hhcGUnKV0gfHwgc2hhcGVzLmxpbmUsXG4gICAgICBzb3VyY2VYID0gdGhpcy5wYXJhbSgnc291cmNlWCcpLmFjY2Vzc29yLFxuICAgICAgc291cmNlWSA9IHRoaXMucGFyYW0oJ3NvdXJjZVknKS5hY2Nlc3NvcixcbiAgICAgIHRhcmdldFggPSB0aGlzLnBhcmFtKCd0YXJnZXRYJykuYWNjZXNzb3IsXG4gICAgICB0YXJnZXRZID0gdGhpcy5wYXJhbSgndGFyZ2V0WScpLmFjY2Vzc29yLFxuICAgICAgdGVuc2lvbiA9IHRoaXMucGFyYW0oJ3RlbnNpb24nKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBwYXRoID0gc2hhcGUoc291cmNlWCh0KSwgc291cmNlWSh0KSwgdGFyZ2V0WCh0KSwgdGFyZ2V0WSh0KSwgdGVuc2lvbik7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5wYXRoXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua1BhdGg7IiwidmFyIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLlR1cGxlLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIExvb2t1cChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBvbjogICAgICB7dHlwZTogJ2RhdGEnfSxcbiAgICBvbktleTogICB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogbnVsbH0sXG4gICAgYXM6ICAgICAge3R5cGU6ICdhcnJheTx2YWx1ZT4nfSxcbiAgICBrZXlzOiAgICB7dHlwZTogJ2FycmF5PGZpZWxkPicsIGRlZmF1bHQ6IFsnZGF0YSddfSxcbiAgICBkZWZhdWx0OiB7dHlwZTogJ3ZhbHVlJ31cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChMb29rdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29rdXA7XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ2xvb2t1cCddKTtcblxuICB2YXIgb24gPSB0aGlzLnBhcmFtKCdvbicpLFxuICAgICAgb25MYXN0ID0gb24uc291cmNlLmxhc3QoKSxcbiAgICAgIG9uRGF0YSA9IG9uLnNvdXJjZS52YWx1ZXMoKSxcbiAgICAgIG9uS2V5ID0gdGhpcy5wYXJhbSgnb25LZXknKSxcbiAgICAgIG9uRiA9IG9uS2V5LmZpZWxkLFxuICAgICAga2V5cyA9IHRoaXMucGFyYW0oJ2tleXMnKSxcbiAgICAgIGdldCA9IGtleXMuYWNjZXNzb3IsXG4gICAgICBhcyA9IHRoaXMucGFyYW0oJ2FzJyksXG4gICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLnBhcmFtKCdkZWZhdWx0JyksXG4gICAgICBsdXQgPSB0aGlzLl9sdXQsXG4gICAgICBpLCB2O1xuXG4gIC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvbiBpbml0LCB3aXRoS2V5IG1vZGlmaWVkLCBvciB0dXBsZSBhZGQvcmVtXG4gIGlmIChsdXQgPT0gbnVsbCB8fCB0aGlzLl9vbiAhPT0gb25GIHx8IG9uRiAmJiBvbkxhc3QuZmllbGRzW29uRl0gfHxcbiAgICAgIG9uTGFzdC5hZGQubGVuZ3RoIHx8IG9uTGFzdC5yZW0ubGVuZ3RoKVxuICB7XG4gICAgaWYgKG9uRikgeyAvLyBidWlsZCBoYXNoIGZyb20gd2l0aEtleSBmaWVsZFxuICAgICAgb25LZXkgPSBvbktleS5hY2Nlc3NvcjtcbiAgICAgIGZvciAobHV0PXt9LCBpPTA7IGk8b25EYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGx1dFtvbktleSh2ID0gb25EYXRhW2ldKV0gPSB2O1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgdXNlIGluZGV4LWJhc2VkIGxvb2t1cFxuICAgICAgbHV0ID0gb25EYXRhO1xuICAgIH1cbiAgICB0aGlzLl9sdXQgPSBsdXQ7XG4gICAgdGhpcy5fb24gPSBvbkY7XG4gICAgcmVzZXQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8Z2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdiA9IGx1dFtnZXRbaV0odCldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgIFR1cGxlLnNldCh0LCBhc1tpXSwgdik7XG4gICAgfVxuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgdmFyIHJ1biA9IGtleXMuZmllbGQuc29tZShmdW5jdGlvbihmKSB7IHJldHVybiBpbnB1dC5maWVsZHNbZl07IH0pO1xuICBpZiAocnVuIHx8IHJlc2V0KSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpOyBcbiAgfVxuXG4gIGFzLmZvckVhY2goZnVuY3Rpb24oaykgeyBpbnB1dC5maWVsZHNba10gPSAxOyB9KTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb29rdXA7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIERlcHMgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuRGVwZW5kZW5jaWVzLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZS9leHByJyk7XG5cbnZhciBhcnJheVR5cGUgPSAvYXJyYXkvaSxcbiAgICBkYXRhVHlwZSAgPSAvZGF0YS9pLFxuICAgIGZpZWxkVHlwZSA9IC9maWVsZC9pLFxuICAgIGV4cHJUeXBlICA9IC9leHByL2ksXG4gICAgdmFsVHlwZSAgID0gL3ZhbHVlL2k7XG5cbmZ1bmN0aW9uIFBhcmFtZXRlcihuYW1lLCB0eXBlLCB0cmFuc2Zvcm0pIHtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgLy8gSWYgcGFyYW1ldGVyIGlzIGRlZmluZWQgdy9zaWduYWxzLCBpdCBtdXN0IGJlIHJlc29sdmVkXG4gIC8vIG9uIGV2ZXJ5IHB1bHNlLlxuICB0aGlzLl92YWx1ZSA9IFtdO1xuICB0aGlzLl9hY2Nlc3NvcnMgPSBbXTtcbiAgdGhpcy5fcmVzb2x1dGlvbiA9IGZhbHNlO1xuICB0aGlzLl9zaWduYWxzID0ge307XG59XG5cbnZhciBwcm90b3R5cGUgPSBQYXJhbWV0ZXIucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIHZhciBpc0FycmF5ID0gYXJyYXlUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICB2YXIgdmFsID0gaXNBcnJheSA/IHRoaXMuX3ZhbHVlIDogdGhpcy5fdmFsdWVbMF0sXG4gICAgICBhY2MgPSBpc0FycmF5ID8gdGhpcy5fYWNjZXNzb3JzIDogdGhpcy5fYWNjZXNzb3JzWzBdO1xuXG4gIGlmICghZGwuaXNWYWxpZChhY2MpICYmIHZhbFR5cGUudGVzdCh0aGlzLl90eXBlKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzRGF0YSA/IHsgbmFtZTogdmFsLCBzb3VyY2U6IGFjYyB9IDpcbiAgICBpc0ZpZWxkID8geyBmaWVsZDogdmFsLCBhY2Nlc3NvcjogYWNjIH0gOiB2YWw7XG4gIH1cbn1cblxucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ3JhcGggPSB0aGlzLl90cmFuc2Zvcm0uX2dyYXBoLCBcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgcywgaWR4LCB2YWw7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgcmVxdWlyZSByZXNvbHV0aW9uLCByZXR1cm4gdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICBpZiAoIXRoaXMuX3Jlc29sdXRpb24pIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgdGhpcy5fYWNjZXNzb3JzID0gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGdyYXBoLmRhdGEodik7IH0pO1xuICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTsgLy8gVE9ETzogc3VwcG9ydCBzaWduYWwgYXMgZGF0YVR5cGVzXG4gIH1cblxuICBmb3IgKHMgaW4gdGhpcy5fc2lnbmFscykge1xuICAgIGlkeCA9IHRoaXMuX3NpZ25hbHNbc107XG4gICAgdmFsID0gZ3JhcGguc2lnbmFsUmVmKHMpO1xuXG4gICAgaWYgKGlzRmllbGQpIHtcbiAgICAgIHRoaXMuX2FjY2Vzc29yc1tpZHhdID0gdGhpcy5fdmFsdWVbaWR4XSAhPSB2YWwgPyBcbiAgICAgICAgZGwuYWNjZXNzb3IodmFsKSA6IHRoaXMuX2FjY2Vzc29yc1tpZHhdO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlW2lkeF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZ2V0LmNhbGwodGhpcyk7XG59O1xuXG5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHAgPSB0aGlzLFxuICAgICAgaXNFeHByID0gZXhwclR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpO1xuXG4gIHRoaXMuX3ZhbHVlID0gZGwuYXJyYXkodmFsdWUpLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgaWYgKGRsLmlzU3RyaW5nKHYpKSB7XG4gICAgICBpZiAoaXNFeHByKSB7XG4gICAgICAgIHZhciBlID0gZXhwcih2KTtcbiAgICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5GSUVMRFMsICBlLmZpZWxkcyk7XG4gICAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgZS5nbG9iYWxzKTtcbiAgICAgICAgcmV0dXJuIGUuZm47XG4gICAgICB9IGVsc2UgaWYgKGlzRmllbGQpIHsgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHAuX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYpO1xuICAgICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLkZJRUxEUywgZGwuZmllbGQodikpO1xuICAgICAgfSBlbHNlIGlmIChpc0RhdGEpIHtcbiAgICAgICAgcC5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuREFUQSwgdik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9IGVsc2UgaWYgKHYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHYudmFsdWU7XG4gICAgfSBlbHNlIGlmICh2LmZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAuX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYuZmllbGQpO1xuICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5GSUVMRFMsIGRsLmZpZWxkKHYuZmllbGQpKTtcbiAgICAgIHJldHVybiB2LmZpZWxkO1xuICAgIH0gZWxzZSBpZiAodi5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICBwLl9zaWduYWxzW3Yuc2lnbmFsXSA9IGk7XG4gICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLlNJR05BTFMsIHYuc2lnbmFsKTtcbiAgICAgIHJldHVybiB2LnNpZ25hbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbiAgfSk7XG5cbiAgcmV0dXJuIHAuX3RyYW5zZm9ybTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYW1ldGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBQaWUoZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDogICAgICB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogbnVsbH0sXG4gICAgc3RhcnRBbmdsZToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDB9LFxuICAgIGVuZEFuZ2xlOiAgIHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAyICogTWF0aC5QSX0sXG4gICAgc29ydDogICAgICAge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IGZhbHNlfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgJ3N0YXJ0JzogJ2xheW91dF9zdGFydCcsXG4gICAgJ2VuZCc6ICAgJ2xheW91dF9lbmQnLFxuICAgICdtaWQnOiAgICdsYXlvdXRfbWlkJ1xuICB9O1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoUGllLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaWU7XG5cbmZ1bmN0aW9uIG9uZXMoKSB7IHJldHVybiAxOyB9XG5cbnByb3RvdHlwZS5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydwaWUnXSk7XG5cbiAgdmFyIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGZpZWxkID0gdGhpcy5wYXJhbSgnZmllbGQnKS5hY2Nlc3NvciB8fCBvbmVzLFxuICAgICAgc3RhcnQgPSB0aGlzLnBhcmFtKCdzdGFydEFuZ2xlJyksXG4gICAgICBzdG9wID0gdGhpcy5wYXJhbSgnZW5kQW5nbGUnKSxcbiAgICAgIHNvcnQgPSB0aGlzLnBhcmFtKCdzb3J0Jyk7XG5cbiAgdmFyIHZhbHVlcyA9IGRhdGEubWFwKGZpZWxkKSxcbiAgICAgIGEgPSBzdGFydCxcbiAgICAgIGsgPSAoc3RvcCAtIHN0YXJ0KSAvIGRsLnN1bSh2YWx1ZXMpLFxuICAgICAgaW5kZXggPSBkbC5yYW5nZShkYXRhLmxlbmd0aCksXG4gICAgICBpLCB0LCB2O1xuXG4gIGlmIChzb3J0KSB7XG4gICAgaW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FdIC0gdmFsdWVzW2JdO1xuICAgIH0pO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8aW5kZXgubGVuZ3RoOyArK2kpIHtcbiAgICB0ID0gZGF0YVtpbmRleFtpXV07XG4gICAgdiA9IHZhbHVlc1tpbmRleFtpXV07XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC5zdGFydCwgYSk7XG4gICAgVHVwbGUuc2V0KHQsIG91dHB1dC5taWQsIChhICsgMC41ICogdiAqIGspKTtcbiAgICBUdXBsZS5zZXQodCwgb3V0cHV0LmVuZCwgKGEgKz0gdiAqIGspKTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5lbmRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5taWRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWU7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGxvZyAgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBTb3J0KGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2J5OiB7dHlwZTogJ2FycmF5PGZpZWxkPid9IH0pO1xuICB0aGlzLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChTb3J0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29ydDtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydzb3J0aW5nJ10pO1xuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0Lm1vZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGlucHV0LnNvcnQgPSBkbC5jb21wYXJhdG9yKHRoaXMucGFyYW0oJ2J5JykuZmllbGQpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29ydDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gU3RhY2soZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cGJ5OiB7dHlwZTogJ2FycmF5PGZpZWxkPid9LFxuICAgIHNvcnRieToge3R5cGU6ICdhcnJheTxmaWVsZD4nfSxcbiAgICBmaWVsZDoge3R5cGU6ICdmaWVsZCd9LFxuICAgIG9mZnNldDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICd6ZXJvJ31cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgICdzdGFydCc6ICdsYXlvdXRfc3RhcnQnLFxuICAgICdlbmQnOiAgICdsYXlvdXRfZW5kJyxcbiAgICAnbWlkJzogICAnbGF5b3V0X21pZCdcbiAgfTtcbiAgcmV0dXJuIHRoaXMubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhY2s7XG5cbnByb3RvdHlwZS5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydzdGFja2luZyddKTtcblxuICB2YXIgZ3JvdXBieSA9IHRoaXMucGFyYW0oJ2dyb3VwYnknKS5hY2Nlc3NvcixcbiAgICAgIHNvcnRieSA9IGRsLmNvbXBhcmF0b3IodGhpcy5wYXJhbSgnc29ydGJ5JykuZmllbGQpLFxuICAgICAgZmllbGQgPSB0aGlzLnBhcmFtKCdmaWVsZCcpLmFjY2Vzc29yLFxuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJhbSgnb2Zmc2V0JyksXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQ7XG5cbiAgLy8gcGFydGl0aW9uLCBzdW0sIGFuZCBzb3J0IHRoZSBzdGFjayBncm91cHNcbiAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIGZpZWxkKTtcblxuICAvLyBjb21wdXRlIHN0YWNrIGxheW91dHMgcGVyIGdyb3VwXG4gIGZvciAodmFyIGk9MCwgbWF4PWdyb3Vwcy5tYXg7IGk8Z3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldLFxuICAgICAgICBzdW0gPSBncm91cC5zdW0sXG4gICAgICAgIG9mZiA9IG9mZnNldD09PSdjZW50ZXInID8gKG1heCAtIHN1bSkvMiA6IDAsXG4gICAgICAgIHNjYWxlID0gb2Zmc2V0PT09J25vcm1hbGl6ZScgPyAoMS9zdW0pIDogMSxcbiAgICAgICAgaiwgeCwgYSwgYiA9IG9mZiwgdiA9IDA7XG5cbiAgICAvLyBzZXQgc3RhY2sgY29vcmRpbmF0ZXMgZm9yIGVhY2ggZGF0dW0gaW4gZ3JvdXBcbiAgICBmb3IgKGo9MDsgajxncm91cC5sZW5ndGg7ICsraikge1xuICAgICAgeCA9IGdyb3VwW2pdO1xuICAgICAgYSA9IGI7IC8vIHVzZSBwcmV2aW91cyB2YWx1ZSBmb3Igc3RhcnQgcG9pbnRcbiAgICAgIHYgKz0gZmllbGQoeCk7XG4gICAgICBiID0gc2NhbGUgKiB2ICsgb2ZmOyAvLyBjb21wdXRlIGVuZCBwb2ludFxuICAgICAgVHVwbGUuc2V0KHgsIG91dHB1dC5zdGFydCwgYSk7XG4gICAgICBUdXBsZS5zZXQoeCwgb3V0cHV0LmVuZCwgYik7XG4gICAgICBUdXBsZS5zZXQoeCwgb3V0cHV0Lm1pZCwgMC41ICogKGEgKyBiKSk7XG4gICAgfVxuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdGFydF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LmVuZF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0Lm1pZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCBmaWVsZCkge1xuICB2YXIgZ3JvdXBzID0gW10sXG4gICAgICBnZXQgPSBmdW5jdGlvbihmKSB7IHJldHVybiBmKHgpOyB9LFxuICAgICAgbWFwLCBpLCB4LCBrLCBnLCBzLCBtYXg7XG5cbiAgLy8gcGFydGl0aW9uIGRhdGEgcG9pbnRzIGludG8gc3RhY2sgZ3JvdXBzXG4gIGlmIChncm91cGJ5ID09IG51bGwpIHtcbiAgICBncm91cHMucHVzaChkYXRhLnNsaWNlKCkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobWFwPXt9LCBpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgeCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba10gfHwgKGdyb3Vwcy5wdXNoKG1hcFtrXSA9IFtdKSwgbWFwW2tdKTtcbiAgICAgIGcucHVzaCh4KTtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wdXRlIHN1bXMgb2YgZ3JvdXBzLCBzb3J0IGdyb3VwcyBhcyBuZWVkZWRcbiAgZm9yIChrPTAsIG1heD0wOyBrPGdyb3Vwcy5sZW5ndGg7ICsraykge1xuICAgIGcgPSBncm91cHNba107XG4gICAgZm9yIChpPTAsIHM9MDsgaTxnLmxlbmd0aDsgKytpKSB7XG4gICAgICBzICs9IGZpZWxkKGdbaV0pO1xuICAgIH1cbiAgICBnLnN1bSA9IHM7XG4gICAgaWYgKHMgPiBtYXgpIG1heCA9IHM7XG4gICAgaWYgKHNvcnRieSAhPSBudWxsKSBnLnNvcnQoc29ydGJ5KTtcbiAgfVxuICBncm91cHMubWF4ID0gbWF4O1xuXG4gIHJldHVybiBncm91cHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIEJhc2UgPSBkZi5Ob2RlLnByb3RvdHlwZSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL1BhcmFtZXRlcicpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oZ3JhcGgpIHtcbiAgaWYgKGdyYXBoKSBCYXNlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG59XG5cblRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocHJvdG8sIHBhcmFtcykge1xuICBwcm90by5fcGFyYW1ldGVycyA9IHByb3RvLl9wYXJhbWV0ZXJzIHx8IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIHBhcmFtcykge1xuICAgIHZhciBwID0gcGFyYW1zW25hbWVdLFxuICAgICAgICBwYXJhbSA9IG5ldyBQYXJhbWV0ZXIobmFtZSwgcC50eXBlLCBwcm90byk7XG5cbiAgICBwcm90by5fcGFyYW1ldGVyc1tuYW1lXSA9IHBhcmFtO1xuXG4gICAgaWYgKHAudHlwZSA9PT0gJ2N1c3RvbScpIHtcbiAgICAgIGlmIChwLnNldCkgcGFyYW0uc2V0ID0gcC5zZXQuYmluZChwYXJhbSk7XG4gICAgICBpZiAocC5nZXQpIHBhcmFtLmdldCA9IHAuZ2V0LmJpbmQocGFyYW0pO1xuICAgIH1cblxuICAgIGlmIChwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHBhcmFtLnNldChwLmRlZmF1bHQpO1xuICB9XG59O1xuXG52YXIgcHJvdG90eXBlID0gKFRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybTtcblxucHJvdG90eXBlLnBhcmFtID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHBhcmFtID0gdGhpcy5fcGFyYW1ldGVyc1tuYW1lXTtcbiAgcmV0dXJuIChwYXJhbSA9PT0gdW5kZWZpbmVkKSA/IHRoaXMgOlxuICAgIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/IHBhcmFtLmdldCgpIDogcGFyYW0uc2V0KHZhbHVlKTtcbn07XG5cbi8vIFBlcmZvcm0gdHJhbnNmb3JtYXRpb24uIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlLlxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LyosIHJlc2V0ICovKSB7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIE1hbnkgdHJhbnNmb3JtcyBzdG9yZSBjYWNoZXMgdGhhdCBtdXN0IGJlIGludmFsaWRhdGVkIGlmXG4gIC8vIGEgc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkLiBcbiAgdmFyIHJlc2V0ID0gdGhpcy5fc3RhbXAgPCBpbnB1dC5zdGFtcCAmJlxuICAgIHRoaXMuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMpLnJlZHVjZShmdW5jdGlvbihjLCBzKSB7XG4gICAgICByZXR1cm4gYyArPSBpbnB1dC5zaWduYWxzW3NdID8gMSA6IDA7XG4gICAgfSwgMCk7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybShpbnB1dCwgcmVzZXQpO1xufTtcblxucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKG1hcCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fb3V0cHV0KSB7XG4gICAgaWYgKG1hcFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX291dHB1dFtrZXldID0gbWFwW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JykuVHVwbGUsXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKTtcblxudmFyIGRlZmF1bHRSYXRpbyA9IDAuNSAqICgxICsgTWF0aC5zcXJ0KDUpKTtcblxuZnVuY3Rpb24gVHJlZW1hcChncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIC8vIGhpZXJhcmNoeSBwYXJhbWV0ZXJzXG4gICAgc29ydDoge3R5cGU6ICdhcnJheTxmaWVsZD4nLCBkZWZhdWx0OiBbJy12YWx1ZSddfSxcbiAgICBjaGlsZHJlbjoge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdjaGlsZHJlbid9LFxuICAgIGZpZWxkOiB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ3ZhbHVlJ30sXG4gICAgLy8gdHJlZW1hcCBwYXJhbWV0ZXJzXG4gICAgc2l6ZToge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbNTAwLCA1MDBdfSxcbiAgICByb3VuZDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IHRydWV9LFxuICAgIHN0aWNreToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICByYXRpbzoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IGRlZmF1bHRSYXRpb30sXG4gICAgcGFkZGluZzoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IG51bGx9LFxuICAgIG1vZGU6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnc3F1YXJpZnknfVxuICB9KTtcblxuICB0aGlzLl9sYXlvdXQgPSBkMy5sYXlvdXQudHJlZW1hcCgpO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICAneCc6ICAgICAgJ2xheW91dF94JyxcbiAgICAneSc6ICAgICAgJ2xheW91dF95JyxcbiAgICAnd2lkdGgnOiAgJ2xheW91dF93aWR0aCcsXG4gICAgJ2hlaWdodCc6ICdsYXlvdXRfaGVpZ2h0JyxcbiAgICAnZGVwdGgnOiAgJ2xheW91dF9kZXB0aCcsXG4gIH07XG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoVHJlZW1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJlZW1hcDtcblxucHJvdG90eXBlLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ3RyZWVtYXAnXSk7XG5cbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0O1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNvcnQoZGwuY29tcGFyYXRvcih0aGlzLnBhcmFtKCdzb3J0JykuZmllbGQpKVxuICAgIC5jaGlsZHJlbih0aGlzLnBhcmFtKCdjaGlsZHJlbicpLmFjY2Vzc29yKVxuICAgIC52YWx1ZSh0aGlzLnBhcmFtKCdmaWVsZCcpLmFjY2Vzc29yKVxuICAgIC5zaXplKHRoaXMucGFyYW0oJ3NpemUnKSlcbiAgICAucm91bmQodGhpcy5wYXJhbSgncm91bmQnKSlcbiAgICAuc3RpY2t5KHRoaXMucGFyYW0oJ3N0aWNreScpKVxuICAgIC5yYXRpbyh0aGlzLnBhcmFtKCdyYXRpbycpKVxuICAgIC5wYWRkaW5nKHRoaXMucGFyYW0oJ3BhZGRpbmcnKSlcbiAgICAubW9kZSh0aGlzLnBhcmFtKCdtb2RlJykpXG4gICAgLm5vZGVzKGRhdGFbMF0pO1xuXG4gIC8vIGNvcHkgbGF5b3V0IHZhbHVlcyB0byBub2Rlc1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIFR1cGxlLnNldChuLCBvdXRwdXQueCwgbi54KTtcbiAgICBUdXBsZS5zZXQobiwgb3V0cHV0LnksIG4ueSk7XG4gICAgVHVwbGUuc2V0KG4sIG91dHB1dC53aWR0aCwgbi5keCk7XG4gICAgVHVwbGUuc2V0KG4sIG91dHB1dC5oZWlnaHQsIG4uZHkpO1xuICAgIFR1cGxlLnNldChuLCBvdXRwdXQuZGVwdGgsIG4uZGVwdGgpO1xuICB9KTtcblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC53aWR0aF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LmhlaWdodF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVtYXA7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgVHVwbGUgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93L3NyYy9UdXBsZScpLFxuICAgIGxvZyA9IHJlcXVpcmUoJ3ZlZ2EtbG9nZ2luZycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIFZvcm9ub2koZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBjbGlwRXh0ZW50OiB7dHlwZTogJ2FycmF5PHZhbHVlPicsIGRlZmF1bHQ6IFtbLTFlNSwtMWU1XSxbMWU1LDFlNV1dfSxcbiAgICB4OiB7dHlwZTogJ2ZpZWxkJywgZGVmYXVsdDogJ2xheW91dF94J30sXG4gICAgeToge3R5cGU6ICdmaWVsZCcsIGRlZmF1bHQ6ICdsYXlvdXRfeSd9XG4gIH0pO1xuXG4gIHRoaXMuX2xheW91dCA9IGQzLmdlb20udm9yb25vaSgpO1xuICB0aGlzLl9vdXRwdXQgPSB7J3BhdGgnOiAnbGF5b3V0X3BhdGgnfTtcblxuICByZXR1cm4gdGhpcy5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFZvcm9ub2kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZvcm9ub2k7XG5cbnByb3RvdHlwZS5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWyd2b3Jvbm9pJ10pO1xuXG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIHBhdGhuYW1lID0gdGhpcy5fb3V0cHV0LnBhdGg7XG5cbiAgLy8gY29uZmlndXJlIGxheW91dFxuICB2YXIgcG9seWdvbnMgPSB0aGlzLl9sYXlvdXRcbiAgICAuY2xpcEV4dGVudCh0aGlzLnBhcmFtKCdjbGlwRXh0ZW50JykpXG4gICAgLngodGhpcy5wYXJhbSgneCcpLmFjY2Vzc29yKVxuICAgIC55KHRoaXMucGFyYW0oJ3knKS5hY2Nlc3NvcilcbiAgICAoZGF0YSk7XG5cbiAgLy8gYnVpbGQgYW5kIGFzc2lnbiBwYXRoIHN0cmluZ3NcbiAgZm9yICh2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBUdXBsZS5zZXQoZGF0YVtpXSwgcGF0aG5hbWUsICdNJyArIHBvbHlnb25zW2ldLmpvaW4oJ0wnKSArICdaJyk7XG4gIH1cblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIGlucHV0LmZpZWxkc1twYXRobmFtZV0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZvcm9ub2k7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2QzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddIDogbnVsbCksXG4gICAgZDNfY2xvdWQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snZDMnXVsnbGF5b3V0J11bJ2Nsb3VkJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydkMyddWydsYXlvdXQnXVsnY2xvdWQnXSA6IG51bGwpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdy9zcmMvVHVwbGUnKSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBXb3JkY2xvdWQoZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBzaXplOiB7dHlwZTogJ2FycmF5PHZhbHVlPicsIGRlZmF1bHQ6IFs5MDAsIDUwMF19LFxuICAgIHRleHQ6IHt0eXBlOiAnZmllbGQnLCBkZWZhdWx0OiAnZGF0YSd9LFxuICAgIHJvdGF0ZToge3R5cGU6ICdmaWVsZHx2YWx1ZScsIGRlZmF1bHQ6IDB9LFxuICAgIGZvbnQ6IHt0eXBlOiAnZmllbGR8dmFsdWUnLCBkZWZhdWx0OiB7dmFsdWU6ICdzYW5zLXNlcmlmJ319LFxuICAgIGZvbnRTaXplOiB7dHlwZTogJ2ZpZWxkfHZhbHVlJywgZGVmYXVsdDogMTR9LFxuICAgIGZvbnRTdHlsZToge3R5cGU6ICdmaWVsZHx2YWx1ZScsIGRlZmF1bHQ6IHt2YWx1ZTogJ25vcm1hbCd9fSxcbiAgICBmb250V2VpZ2h0OiB7dHlwZTogJ2ZpZWxkfHZhbHVlJywgZGVmYXVsdDoge3ZhbHVlOiAnbm9ybWFsJ319LFxuICAgIGZvbnRTY2FsZToge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbMTAsIDUwXX0sXG4gICAgcGFkZGluZzoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDF9LFxuICAgIHNwaXJhbDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdhcmNoaW1lZGVhbid9XG4gIH0pO1xuXG4gIHRoaXMuX2xheW91dCA9IGQzX2Nsb3VkKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgICd4JzogICAgICAgICAgJ2xheW91dF94JyxcbiAgICAneSc6ICAgICAgICAgICdsYXlvdXRfeScsXG4gICAgJ2ZvbnQnOiAgICAgICAnbGF5b3V0X2ZvbnQnLFxuICAgICdmb250U2l6ZSc6ICAgJ2xheW91dF9mb250U2l6ZScsXG4gICAgJ2ZvbnRTdHlsZSc6ICAnbGF5b3V0X2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRXZWlnaHQnOiAnbGF5b3V0X2ZvbnRXZWlnaHQnLFxuICAgICdyb3RhdGUnOiAgICAgJ2xheW91dF9yb3RhdGUnLFxuICB9O1xuXG4gIHJldHVybiB0aGlzLm11dGF0ZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoV29yZGNsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JkY2xvdWQ7XG5cbmZ1bmN0aW9uIGdldChwKSB7XG4gIHJldHVybiAocCAmJiBwLmFjY2Vzc29yKSB8fCBwO1xufVxuXG5mdW5jdGlvbiB3cmFwKHR1cGxlKSB7XG4gIHZhciB4ID0gT2JqZWN0LmNyZWF0ZSh0dXBsZSk7XG4gIHguX3R1cGxlID0gdHVwbGU7XG4gIHJldHVybiB4O1xufVxuXG5wcm90b3R5cGUuYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnd29yZGNsb3VkJ10pO1xuXG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGZvbnRTaXplID0gdGhpcy5wYXJhbSgnZm9udFNpemUnKSxcbiAgICAgIHJhbmdlID0gZm9udFNpemUuYWNjZXNzb3IgJiYgdGhpcy5wYXJhbSgnZm9udFNjYWxlJyksXG4gICAgICBzaXplLCBzY2FsZTtcbiAgZm9udFNpemUgPSBmb250U2l6ZS5hY2Nlc3NvciB8fCBkMy5mdW5jdG9yKGZvbnRTaXplKTtcbiAgXG4gIC8vIGNyZWF0ZSBmb250IHNpemUgc2NhbGluZyBmdW5jdGlvbiBhcyBuZWVkZWRcbiAgaWYgKHJhbmdlLmxlbmd0aCkge1xuICAgIHNjYWxlID0gZDMuc2NhbGUuc3FydCgpXG4gICAgICAuZG9tYWluKGRsLmV4dGVudChkYXRhLCBzaXplPWZvbnRTaXplKSlcbiAgICAgIC5yYW5nZShyYW5nZSk7XG4gICAgZm9udFNpemUgPSBmdW5jdGlvbih4KSB7IHJldHVybiBzY2FsZShzaXplKHgpKTsgfTtcbiAgfVxuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNpemUodGhpcy5wYXJhbSgnc2l6ZScpKVxuICAgIC50ZXh0KGdldCh0aGlzLnBhcmFtKCd0ZXh0JykpKVxuICAgIC5wYWRkaW5nKHRoaXMucGFyYW0oJ3BhZGRpbmcnKSlcbiAgICAuc3BpcmFsKHRoaXMucGFyYW0oJ3NwaXJhbCcpKVxuICAgIC5yb3RhdGUoZ2V0KHRoaXMucGFyYW0oJ3JvdGF0ZScpKSlcbiAgICAuZm9udChnZXQodGhpcy5wYXJhbSgnZm9udCcpKSlcbiAgICAuZm9udFN0eWxlKGdldCh0aGlzLnBhcmFtKCdmb250U3R5bGUnKSkpXG4gICAgLmZvbnRXZWlnaHQoZ2V0KHRoaXMucGFyYW0oJ2ZvbnRXZWlnaHQnKSkpXG4gICAgLmZvbnRTaXplKGZvbnRTaXplKVxuICAgIC53b3JkcyhkYXRhLm1hcCh3cmFwKSkgLy8gd3JhcCB0byBhdm9pZCB0dXBsZSB3cml0ZXNcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICB2YXIgc2l6ZSA9IGxheW91dC5zaXplKCksXG4gICAgICAgICAgZHggPSBzaXplWzBdID4+IDEsXG4gICAgICAgICAgZHkgPSBzaXplWzFdID4+IDEsXG4gICAgICAgICAgdywgdCwgaSwgbGVuO1xuXG4gICAgICBmb3IgKGk9MCwgbGVuPXdvcmRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICB3ID0gd29yZHNbaV07XG4gICAgICAgIHQgPSB3Ll90dXBsZTtcbiAgICAgICAgVHVwbGUuc2V0KHQsIG91dHB1dC54LCB3LnggKyBkeCk7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQueSwgdy55ICsgZHkpO1xuICAgICAgICBUdXBsZS5zZXQodCwgb3V0cHV0LmZvbnQsIHcuZm9udCk7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQuZm9udFNpemUsIHcuc2l6ZSk7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQuZm9udFN0eWxlLCB3LnN0eWxlKTtcbiAgICAgICAgVHVwbGUuc2V0KHQsIG91dHB1dC5mb250V2VpZ2h0LCB3LndlaWdodCk7XG4gICAgICAgIFR1cGxlLnNldCh0LCBvdXRwdXQucm90YXRlLCB3LnJvdGF0ZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuc3RhcnQoKTtcblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIGZvciAodmFyIGtleSBpbiBvdXRwdXQpIGlucHV0LmZpZWxkc1tvdXRwdXRba2V5XV0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmRjbG91ZDsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWdncmVnYXRlOiAgICByZXF1aXJlKCcuL0FnZ3JlZ2F0ZScpLFxuICBiaW46ICAgICAgICAgIHJlcXVpcmUoJy4vQmluJyksXG4gIGNyb3NzOiAgICAgICAgcmVxdWlyZSgnLi9Dcm9zcycpLFxuICBjb3VudHBhdHRlcm46IHJlcXVpcmUoJy4vQ291bnRQYXR0ZXJuJyksXG4gIGxpbmtwYXRoOiAgICAgcmVxdWlyZSgnLi9MaW5rUGF0aCcpLFxuICBmYWNldDogICAgICAgIHJlcXVpcmUoJy4vRmFjZXQnKSxcbiAgZmlsdGVyOiAgICAgICByZXF1aXJlKCcuL0ZpbHRlcicpLFxuICBmb2xkOiAgICAgICAgIHJlcXVpcmUoJy4vRm9sZCcpLFxuICBmb3JjZTogICAgICAgIHJlcXVpcmUoJy4vRm9yY2UnKSxcbiAgZm9ybXVsYTogICAgICByZXF1aXJlKCcuL0Zvcm11bGEnKSxcbiAgZ2VvOiAgICAgICAgICByZXF1aXJlKCcuL0dlbycpLFxuICBnZW9wYXRoOiAgICAgIHJlcXVpcmUoJy4vR2VvUGF0aCcpLFxuICBsb29rdXA6ICAgICAgIHJlcXVpcmUoJy4vTG9va3VwJyksXG4gIHBpZTogICAgICAgICAgcmVxdWlyZSgnLi9QaWUnKSxcbiAgc29ydDogICAgICAgICByZXF1aXJlKCcuL1NvcnQnKSxcbiAgc3RhY2s6ICAgICAgICByZXF1aXJlKCcuL1N0YWNrJyksXG4gIHRyZWVtYXA6ICAgICAgcmVxdWlyZSgnLi9UcmVlbWFwJyksXG4gIHZvcm9ub2k6ICAgICAgcmVxdWlyZSgnLi9Wb3Jvbm9pJyksXG4gIHdvcmRjbG91ZDogICAgcmVxdWlyZSgnLi9Xb3JkY2xvdWQnKVxufTsiLCIvKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGFuZCBleHBvc2VzIEpTIHBzZXVkby1jbGFzc2VzIHRvIHN1cHBvcnQgYSBjb21wbGV4IHZpZXdcbiAqIG1vZGVsIGZvciBlZGl0aW5nIGlsbHVzdHJhdGlvbnMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi90aS11dGlscy5qcycpLFxuICAgIHN0eWxpc3QgPSByZXF1aXJlKCcuL3N0eWxpc3QuanMnKTtcblxuLy9nbG9iYWwuc3R5bGlzdCA9IHN0eWxpc3Q7XG5cbnZhciBUcmVlSWxsdXN0cmF0b3IgPSBmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCAkLCBrbywgc3R5bGlzdCkge1xuXG4gICAgLy8gRXhwbGljaXRseSBjaGVjayBmb3IgZGVwZW5kZW5jaWVzIGJ5IHBhc3NpbmcgdGhlbSBhcyBhcmdzIHRvIHRoZSBtb2R1bGVcbiAgICBpZiAodHlwZW9mKCQpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFsZXJ0KFwiVHJlZUlsbHVzdHJhdG9yIG1vZHVsZSBjYW5jZWxsZWQsIG5lZWRzIGpRdWVyeSAoYXMgJyQnKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgha28gfHwgdHlwZW9mKGtvKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWxlcnQoXCJUcmVlSWxsdXN0cmF0b3IgbW9kdWxlIGNhbmNlbGxlZCwgbmVlZHMgS25vY2tvdXRKUyAoYXMgJ2tvJylcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXN0eWxpc3QgfHwgdHlwZW9mKHN0eWxpc3QpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBhbGVydChcIlRyZWVJbGx1c3RyYXRvciBtb2R1bGUgY2FuY2VsbGVkLCBuZWVkcyAnc3R5bGlzdCcgbW9kdWxlIChhcyAnc3R5bGlzdCcpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgc29tZSBzaW1wbGUgZW51bWVyYXRpb25zIChmb3IgbGVnaWJpbGl0eSwgYW5kIHRvIGF2b2lkIHR5cG9zKVxuICAgIHZhciB1bml0cyA9IHtcbiAgICAgICAgSU5DSEVTOiAnSU5DSEVTJyxcbiAgICAgICAgQ0VOVElNRVRFUlM6ICdDRU5USU1FVEVSUydcbiAgICB9O1xuICAgIHZhciBjb2xvckRlcHRocyA9IHtcbiAgICAgICAgRlVMTF9DT0xPUjogJ0ZVTExfQ09MT1InLFxuICAgICAgICBHUkFZU0NBTEU6ICdHUkFZU0NBTEUnLFxuICAgICAgICBCTEFDS19BTkRfV0hJVEU6ICdCTEFDS19BTkRfV0hJVEUnXG4gICAgfTtcbiAgICB2YXIgdHJlZUxheW91dHMgPSB7XG4gICAgICAgIFJFQ1RBTkdMRTogJ1JFQ1RBTkdMRScsXG4gICAgICAgIENJUkNMRTogJ0NJUkNMRScsXG4gICAgICAgIFRSSUFOR0xFOiAnVFJJQU5HTEUnXG4gICAgfTtcbiAgICB2YXIgYnJhbmNoUm90YXRpb25NZXRob2RzID0ge1xuICAgICAgICBVTkNIQU5HRUQ6ICdVTkNIQU5HRUQnLCAgLy8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNpYmxpbmcgb3JkZXJcbiAgICAgICAgQUxQSEFCRVRJQ0FMOiAnQUxQSEFCRVRJQ0FMJywgIC8vIGFsc28gdXNlZCBhcyBhIHRpZS1icmVha2VyIGZvciBhbGwgbWV0aG9kc1xuICAgICAgICBMQURERVJJWkVfUklHSFQ6ICdMQURERVJJWkVfUklHSFQnLFxuICAgICAgICBMQURERVJJWkVfTEVGVDogJ0xBRERFUklaRV9MRUZUJyxcbiAgICAgICAgWklHX1pBRzogJ1pJR19aQUcnXG4gICAgfTtcbiAgICB2YXIgYWxpZ25tZW50cyA9IHtcbiAgICAgICAgVE9QOiAnVE9QJyxcbiAgICAgICAgUklHSFQ6ICdSSUdIVCcsXG4gICAgICAgIEJPVFRPTTogJ0JPVFRPTScsXG4gICAgICAgIExFRlQ6ICdMRUZUJyxcbiAgICAgICAgQ0VOVEVSOiAnQ0VOVEVSJ1xuICAgIH07XG4gICAgdmFyIHN3ZWVwRGlyZWN0aW9ucyA9IHtcbiAgICAgICAgQ0xPQ0tXSVNFOiAnQ0xPQ0tXSVNFJyxcbiAgICAgICAgQ09VTlRFUkNMT0NLV0lTRTogJ0NPVU5URVJDTE9DS1dJU0UnXG4gICAgfTtcbiAgICB2YXIgZGF0YVNvdXJjZVR5cGVzID0ge1xuICAgICAgICBCVUlMVF9JTjogJ0JVSUxUX0lOJyxcbiAgICAgICAgVVJMOiAnVVJMJyxcbiAgICAgICAgVVBMT0FEOiAnVVBMT0FEJ1xuICAgIH07XG4gICAgdmFyIHZlcnNpb25UeXBlcyA9IHtcbiAgICAgICAgQ0hFQ0tTVU06ICdDSEVDS1NVTScsICAgLy8gZS5nLiwgYSBnaXQgU0hBXG4gICAgICAgIFRJTUVTVEFNUDogJ1RJTUVTVEFNUCcsIC8vIGUuZy4sIGEgbW9kaWZpY2F0aW9uIGRhdGVcbiAgICAgICAgU0VNQU5USUM6ICdTRU1BTlRJQycgICAgLy8gYSBjb252ZW50aW9uYWwgdmVyc2lvbiBudW1iZXIsIGUuZy4sIFwiMy4yLjBhXCJcbiAgICB9O1xuICAgIHZhciBob3N0QXBwbGljYXRpb25zID0ge1xuICAgICAgICBKVVBZVEVSX05PVEVCT09LOiAnSlVQWVRFUl9OT1RFQk9PSycsICAgIC8vIGEuay5hLiBJUHl0aG9uIG5vdGVib29rXG4gICAgICAgIC8vVE9ETzogQVJCT1JfV09SS0ZMT1c6ICdBUkJPUl9XT1JLRkxPVycgXG4gICAgICAgIC8vVE9ETzogT1BFTlRSRUVfVE9PTFM6ICdPUEVOVFJFRV9UT09MUydcbiAgICAgICAgU1RBTkRBTE9ORTogJ1NUQU5EQUxPTkUnICAgICAgICAgICAgICAgICAvLyBcIm5ha2VkXCIgc3R5bGlzdCwgcGVyaGFwcyBmcm9tIGEgc3RhdGljIGZpbGVcbiAgICB9O1xuICAgIHZhciBzdG9yYWdlQmFja2VuZHMgPSB7XG4gICAgICAgIExPQ0FMX0ZJTEVTWVNURU06ICdMT0NBTF9GSUxFU1lTVEVNJyxcbiAgICAgICAgSlVQWVRFUl9OT1RFQk9PSzogJ0pVUFlURVJfTk9URUJPT0snLCAgICAvLyBKU09OIHN0b3JhZ2UgaW4gYW4gSVB5dGhvbi1zdHlsZSBub3RlYm9vayBmaWxlXG4gICAgICAgIEdJVEhVQl9SRVBPOiAnR0lUSFVCX1JFUE8nICAgICAgICAgICAgICAgLy8gaW4gb3VyIGRlc2lnbmF0ZWQgKHB1YmxpYykgcmVwb1xuICAgIH1cblxuICAgIC8qIEhlcmUgd2UgY2FuIHNoYXJlIGluZm9ybWF0aW9uIGFtb25nIGFsbCBjbGFzc2VzIGFuZCBpbnN0YW5jZXMgKi9cblxuICAgIC8qIENhY2hlIGRhdGEgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBvciByZWR1Y2UgbmV0d29yayB0cmFmZmljOiBcbiAgICAgKiAgIC0gdHJlZSBzb3VyY2UgbG9hZGVkIHZpYSBBSkFYXG4gICAgICogICAtIGludGVybWVkaWF0ZSB0cmVlIGRhdGEgKGFmdGVyIG9uZSBvciBtb3JlIHRyYW5zZm9ybXMpXG4gICAgICogICAtIHN1cHBvcnRpbmcgZGF0YXNldHNcbiAgICAgKiAgIC0gZXRjLlxuICAgICAqIE5vdGUgdGhhdCBpbml0aWFsIHVzZSBpcyBieSB0aGUgJ3N0YXNoJyB0cmFuc2Zvcm0gYmVsb3cuXG4gICAgICovXG4gICAgdmFyIGNhY2hlID0geyB9O1xuICAgIHZhciBzZXRDYWNoZWREYXRhID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgZmx1c2gpIHtcbiAgICAgICAgLy8gYWRkIChvciB1cGRhdGUpIHRoZSBjYWNoZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgLy8gTi5CLiB3ZSdsbCBpZ25vcmUgdGhlICdmbHVzaCcgYm9vbGVhbiBoZXJlLCBpbiBmYXZvciBvZiBhIGNoZWNrc3VtLlxuICAgICAgICBjYWNoZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBnZXRDYWNoZWREYXRhID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8vIHJldHJpZXZlIHRoaXMga2V5J3MgY2FjaGUgZnJvbSB0aGUgY2FjaGUgKG9yIHJldHVybiBudWxsKVxuICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSkgPyBjYWNoZVtrZXldIDogbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhckNhY2hlZERhdGEgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2xvYmJlciB0aGUgZGF0YSBmb3IgdGhpcyBrZXksIGFuZCBwb3NzaWJseSBpdHMgZGVwZW5kZW50c1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMuREVMRVRFX0RFUEVOREVOVF9JVEVNUykgeyAgLy8gVE9ET1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVudHMgPSAkLmZpbHRlcihjYWNoZSwgZnVuY3Rpb24oY2FjaGVQYXRoLCBpdGVtSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoJC5pbkFycmF5KGtleSwgaXRlbUluZm8uZGVwZW5kZW5jaWVzKSAhPT0gLTEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkLmVhY2goZGVwZW5kZW50cywgZnVuY3Rpb24oY2FjaGVQYXRoLCBpdGVtSW5mbykge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgY2xvYmJlciAqdGhlaXIqIGRlcGVuZGVudHMgaW4gdHVyblxuICAgICAgICAgICAgICAgIGNsZWFyQ2FjaGVkRGF0YShjYWNoZVBhdGgsIHtERUxFVEVfREVQRU5ERU5UX0lURU1TOiB0cnVlfSk7IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBmbHVzaENhY2hlID0gZnVuY3Rpb24oIG5ld0NhY2hlRGF0YSApIHtcbiAgICAgICAgLy8gY2xlYXIgYWxsIGtleXMgYW5kIGVudHJpZXM7IHJlcGxhY2Ugd2l0aCBuZXcgZGF0YSBpZiBmb3VuZFxuICAgICAgICBjYWNoZSA9IHsgfTtcbiAgICAgICAgZXhwb3J0cy5jYWNoZSA9IGNhY2hlOyAgLy8gZWxzZSBpdCBsYWdzXG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q2FjaGVEYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld0NhY2hlRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIGVhY2ggcHJvcGVydHkgaW4gdHVybiwganVzdCBpbiBjYXNlIHRoZXJlJ3NcbiAgICAgICAgICAgICAgICAvLyBpbnRlcm5hbCBob3VzZWtlZXBpbmcgdG8gZG8gKGNoZWNrc3VtcywgdGltZXN0YW1wcywgZXRjLilcbiAgICAgICAgICAgICAgICBzZXRDYWNoZWREYXRhKCBrZXksIG5ld0NhY2hlRGF0YVtrZXldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogR2F0aGVyIHZhcmlvdXMgc3Vic2V0cyAob3IgYWxsKSBvZiBjYWNoZWQgZGF0YSBpbiBhIHRlbXAgb2JqZWN0LiAqL1xuICAgIGZ1bmN0aW9uIGdhdGhlckFsbENhY2hlZERhdGEoKSB7XG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgY2FjaGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnYXRoZXJBbGxJbnB1dERhdGEoKSB7XG4gICAgICAgIC8vIGllLCBldmVyeXRoaW5nIGNhY2hlZCB1bmRlciBwYXRocyBzdGFydGluZyAnaW5wdXQvJ1xuICAgICAgICByZXR1cm4gJC5tYXAoY2FjaGUsIGZ1bmN0aW9uKGl0ZW1JbmZvLCBjYWNoZVBhdGgpIHtcbiAgICAgICAgICAgIGlmKCBjYWNoZVBhdGgubWF0Y2goL15pbnB1dFxcLy4qLykgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogY2FjaGVQYXRoLCB2YWx1ZTogaXRlbUluZm8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNT09UXG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICAkLmVhY2goY2FjaGUsIGZ1bmN0aW9uKGNhY2hlUGF0aCwgaXRlbUluZm8pIHtcbiAgICAgICAgICAgIGlmKCBjYWNoZVBhdGgubWF0Y2goL15pbnB1dFxcLy4qLykgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRbIGNhY2hlUGF0aCBdID0gaXRlbUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdhdGhlclN0YXRpY0lucHV0RGF0YSgpIHtcbiAgICAgICAgLy8gaWUsIGV2ZXJ5dGhpbmcgY2FjaGVkIHVuZGVyIHBhdGhzIHN0YXJ0aW5nICdpbnB1dC8nIEFORCB3aXRoIG5vXG4gICAgICAgIC8vIGNsZWFyIHByb3ZlbmFuY2VcbiAgICAgICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgICAgICQuZWFjaChjYWNoZSwgZnVuY3Rpb24oY2FjaGVQYXRoLCBpdGVtSW5mbykge1xuICAgICAgICAgICAgaWYoY2FjaGVQYXRoLm1hdGNoKC9eaW5wdXRcXC8uKi8pICYmXG4gICAgICAgICAgICAgICBpdGVtSW5mby5zcmMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRbIGNhY2hlUGF0aCBdID0gaXRlbUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdhdGhlckFsbFRyYW5zZm9ybURhdGEoKSB7XG4gICAgICAgIC8vIGllLCBldmVyeXRoaW5nIGNhY2hlZCB1bmRlciBwYXRocyBzdGFydGluZyAndHJhbnNmb3JtLydcbiAgICAgICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgICAgICQuZWFjaChjYWNoZSwgZnVuY3Rpb24oY2FjaGVQYXRoLCBpdGVtSW5mbykge1xuICAgICAgICAgICAgaWYoIGNhY2hlUGF0aC5tYXRjaCgvXnRyYW5zZm9ybVxcLy4qLykgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRbIGNhY2hlUGF0aCBdID0gaXRlbUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdhdGhlckFsbE91dHB1dERhdGEoKSB7XG4gICAgICAgIC8vIGllLCBldmVyeXRoaW5nIGNhY2hlZCB1bmRlciBwYXRocyBzdGFydGluZyAnb3V0cHV0LydcbiAgICAgICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgICAgICQuZWFjaChjYWNoZSwgZnVuY3Rpb24oY2FjaGVQYXRoLCBpdGVtSW5mbykge1xuICAgICAgICAgICAgaWYoIGNhY2hlUGF0aC5tYXRjaCgvXm91dHB1dFxcLy4qLykgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRbIGNhY2hlUGF0aCBdID0gaXRlbUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuXG4gICAgLyogUmV0dXJuIHRoZSBkYXRhIG1vZGVsIGZvciBhIG5ldyBpbGx1c3RyYXRpb24gKG91ciBKU09OIHJlcHJlc2VudGF0aW9uKSAqL1xuICAgIHZhciBnZXROZXdJbGx1c3RyYXRpb25Nb2RlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7XG4gICAgICAgICAgICAgICAgJ25hbWUnOiBcIlVudGl0bGVkIGlsbHVzdHJhdGlvblwiLFxuICAgICAgICAgICAgICAgICd1cmwnOiBcIlwiLCAgLy8gc291cmNlIFVSTCBvbiBHaXRIdWIgKEdpdEh1YiBzdG9yYWdlIG9ubHkpXG4gICAgICAgICAgICAgICAgJ3NoYSc6IFwiXCIsICAvLyBsYXRlc3QgU0hBIG9uIEdpdEh1YiAoR2l0SHViIHN0b3JhZ2Ugb25seSlcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiBcIlwiLFxuICAgICAgICAgICAgICAgICdhdXRob3JzJzogWyBdLCAgIC8vIGFzc2lnbiBpbW1lZGlhdGVseSB0byB0aGlzIHVzZXI/XG4gICAgICAgICAgICAgICAgJ3RhZ3MnOiBbIF0sXG4gICAgICAgICAgICAgICAgJ2RvaXMnOiBbIF0sXG4gICAgICAgICAgICAgICAgJ0ZPT0ZPTyc6IFwiQkFSQkFSXCIsXG4gICAgICAgICAgICAgICAgJ2RhdGVfY3JlYXRlZCc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdHlsZUd1aWRlJzoge1xuICAgICAgICAgICAgICAgIC8vIG1heWJlIHRoZSBkZWZhdWx0cyBoZXJlIGFyZSBcImFueXRoaW5nIGdvZXNcIiAoYWxsIG9wdGlvbnMgZW5hYmxlZCk/XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXhwbGljaXRseSBsaXN0IGFsbCBvcHRpb25zIHNvbWV3aGVyZSBlbHNlPyBcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaWx0ZXIgc3R5bGVzIGlmIHRoZXkgZmFsbCBvdXQgb2YgY29uZm9ybWFuY2U/XG4gICAgICAgICAgICAgICAgJ25hbWUnOiBcIkRlZmF1bHQgc3R5bGVzXCIsXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzogXCJTdHlsZSBndWlkZXMgYXJlIHVzZWQgdG8gc3VnZ2VzdCBhbmQgY29uc3RyYWluIHRoZSBvdmVyYWxsIGxvb2sgb2YgeW91ciBpbGx1c3RyYXRpb24gZm9yIGEgcGFydGljdWxhciBwdWJsaWNhdGlvbiBvciBjb250ZXh0LiBZb3UgY2FuIHRyeSBkaWZmZXJlbnQgc3R5bGVzIHVzaW5nIHRoZSA8c3Ryb25nPkxvYWQgc3R5bGVzLi4uPC9zdHJvbmc+IGJ1dHRvbi5cIiwgLy8gY2FwdHVyZWQgd2hlbiBhc3NpZ25lZFxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB7J3R5cGUnOiBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU4sICd2YWx1ZSc6IFwiREVGQVVMVFwifSxcbiAgICAgICAgICAgICAgICAndmVyc2lvbic6IHsndHlwZSc6IHZlcnNpb25UeXBlcy5TRU1BTlRJQywgJ3ZhbHVlJzogXCIwLjFcIn0sXG4gICAgICAgICAgICAgICAgJ2NvbnN0cmFpbnRzJzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IGNvbnN0cmFpbmVkIGxhYmVscyBhbmQgdmFsdWVzLCBpZiBhbnkgKGl0ZW1zIG5vdCBsaXN0ZWQgYXJlIHVuY29uc3RyYWluZWQpXG4gICAgICAgICAgICAgICAgICAgICdwcmludFNpemVzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJMZXR0ZXIgc2l6ZSAocG9ydHJhaXQpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogOC41LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogMTEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bml0cyc6IHVuaXRzLklOQ0hFUyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkxldHRlciBzaXplIChsYW5kc2NhcGUpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogMTEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiA4LjUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bml0cyc6IHVuaXRzLklOQ0hFUyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIlF1YXJ0ZXItcGFnZSAocG9ydHJhaXQpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogNC4yNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IDUuNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXRzJzogdW5pdHMuSU5DSEVTIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiUXVhcnRlci1wYWdlIChsYW5kc2NhcGUpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogNS41LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogNC4yNSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXRzJzogdW5pdHMuSU5DSEVTIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiQ3VzdG9tIHNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZm9udEZhbWlsaWVzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJUaW1lcyBOZXcgUm9tYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBcIlRpbWVzIE5ldyBSb21hbiwgVGltZXMsIHNlcmlmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkhlbHZldGljYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IFwiSGVsdmV0aWNhLCBBcmlhbCwgc2Fuc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJBcmlhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IFwiQXJpYWwsIHNhbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IFwiU29tZXRoaW5nIGVsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnY29sb3JEZXB0aHMnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkZ1bGwgY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5GVUxMX0NPTE9SXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogXCJHcmF5c2NhbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5HUkFZU0NBTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBcIkJsYWNrIGFuZCB3aGl0ZSAobm8gZ3JheSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb2xvckRlcHRocy5CTEFDS19BTkRfV0hJVEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW1UZXh0U2l6ZSc6IDEyLCAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gcHQsIGJ1dCBlY2hvZWQgdXNpbmcgcGh5c2ljYWwgdW5pdHMgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW1MaW5lVGhpY2tuZXNzJzogMiwgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIHB0LCBidXQgZWNob2VkIHVzaW5nIHBoeXNpY2FsIHVuaXRzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBcIiNmZGRcIixcbiAgICAgICAgICAgICAgICAgICAgJ2JvcmRlcic6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZGVmYXVsdCBsaW5lIGNvbG9yLCB0aGlja25lc3MsIG5vZGUgc2hhcGUvc2l6ZSwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJzogXCIjNzc3XCIsXG4gICAgICAgICAgICAgICAgICAgICdlZGdlVGhpY2tuZXNzJzogMC44LFxuICAgICAgICAgICAgICAgICAgICAnbm9kZUNvbG9yJzogXCIjMzM5XCIsXG4gICAgICAgICAgICAgICAgICAgICdub2RlU2hhcGUnOiAnY2lyY2xlJyAgLy8gVE9ETzogc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICAvLyBjaG9pY2VzIGFuZCBvdmVycmlkZXMgZnJvbSB0aGUgc3R5bGUgZ3VpZGUgYWJvdmVcbiAgICAgICAgICAgICAgICAncHJpbnRTaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAndW5pdHMnOiB1bml0cy5JTkNIRVMsICAvLyBPUiB1bml0cy5DRU5USU1FVEVSU1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiA4LjUsICAvLyBpbiBwaHlzaWNhbCB1bml0c1xuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogMTEsICAgLy8gaW4gcGh5c2ljYWwgdW5pdHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb250RmFtaWx5JzogXCJUaW1lcyBOZXcgUm9tYW4sIFRpbWVzLCBzZXJpZlwiLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBcIiNmZGRcIixcbiAgICAgICAgICAgICAgICAnYm9yZGVyJzogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgLy8gYWRkIGRlZmF1bHQgbGluZSBjb2xvciwgdGhpY2tuZXNzLCBub2RlIHNoYXBlL3NpemUsIGV0Yy5cbiAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJzogXCIjNzc3XCIsXG4gICAgICAgICAgICAgICAgJ2VkZ2VUaGlja25lc3MnOiAwLjgsXG4gICAgICAgICAgICAgICAgJ25vZGVDb2xvcic6IFwiIzMzOVwiLFxuICAgICAgICAgICAgICAgICdub2RlU2hhcGUnOiAnY2lyY2xlJyAgLy8gVE9ETzogc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgIHZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2VsZW1lbnRzJzogW1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICd2ZWdhU3BlYyc6IHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiA4MDAsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IDkwMCxcbiAgICAgICAgICAgICAgICAncGFkZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdyaWdodCc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkYXRhJzogWyBdLFxuICAgICAgICAgICAgICAgICdzdHlsZSc6IHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBUT0RPOiBBcHBseSBvcHRpb25hbCBtb2RpZmljYXRpb25zP1xuICAgICAgICBpZiAob3B0aW9ucy5CTEFIKSB7XG4gICAgICAgICAgICBvYmoubWV0YWRhdGEuRk9PID0gJ0JBUic7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyogUmV0dXJuIHRoZSBkYXRhIG1vZGVsIGZvciBhIG5ldyB0cmVlIChvdXIgSlNPTiByZXByZXNlbnRhdGlvbikgKi9cbiAgICB2YXIgZ2V0TmV3SWxsdXN0cmF0ZWRUcmVlTW9kZWwgPSBmdW5jdGlvbihpbGx1c3RyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBuZXdJRCA9IGlsbHVzdHJhdGlvbi5nZXROZXh0QXZhaWxhYmxlSUQoJ3RyZWUnKTsgXG4gICAgICAgIHZhciBsYW5kbWFya3MgPSBzdHlsaXN0LmdldFByaW50QXJlYUxhbmRtYXJrcygpO1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgJ2lkJzogbmV3SUQsXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnSWxsdXN0cmF0ZWRUcmVlJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVW50aXRsZWQgKFwiKyBuZXdJRCArXCIpXCIsXG4gICAgICAgICAgICAgICAgJ3NvdXJjZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU4sIFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiAnLi9wbGFjZWhvbGRlci10cmVlLmpzb24nLFxuICAgICAgICAgICAgICAgICAgICAncGh5bGVzeXN0ZW1TdHVkeUlEJzogJycsXG4gICAgICAgICAgICAgICAgICAgICdwaHlsZXN5c3RlbVRyZWVJRCc6ICcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiBcIlwiLFxuICAgICAgICAgICAgICAgICdkb2lzJzogWyBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RhdGEnOiB7IH0sXG4gICAgICAgICAgICAnbGF5b3V0JzogdHJlZUxheW91dHMuQ0lSQ0xFLFxuICAgICAgICAgICAgLyogT3ZlcmxvYWQgdGhlIG1vZGVsIHdpdGggYWxsIGxheW91dCBwcm9wZXJ0aWVzLiBXZSdsbCB1c2UgdGhlXG4gICAgICAgICAgICAgKiBvbmVzIHRoYXQgY3VycmVudCBhcHBseSAqYW5kKiByZXRhaW4gbGFzdC1rbm93biB2YWx1ZXMgZm9yXG4gICAgICAgICAgICAgKiBvdGhlcnMsIGluIGNhc2UgdGhlIHVzZXIgc3dpdGNoZXMgYmFjayB0byBhIHByaW9yIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYnJhbmNoUm90YXRpb24nOiBicmFuY2hSb3RhdGlvbk1ldGhvZHMuVU5DSEFOR0VELFxuICAgICAgICAgICAgJ3dpZHRoJzogbGFuZG1hcmtzLndpZHRoICogMC40LFxuICAgICAgICAgICAgJ2hlaWdodCc6IGxhbmRtYXJrcy5oZWlnaHQgKiAwLjQsXG4gICAgICAgICAgICAncmFkaXVzJzogTWF0aC5taW4obGFuZG1hcmtzLmhlaWdodCwgbGFuZG1hcmtzLndpZHRoKSAqIDAuMyxcbiAgICAgICAgICAgICdyYWRpYWxBcmMnOiBbMCwgMzUwXSxcbiAgICAgICAgICAgICdyYWRpYWxTd2VlcCc6IHN3ZWVwRGlyZWN0aW9ucy5DTE9DS1dJU0UsXG4gICAgICAgICAgICAndGlwc0FsaWdubWVudCc6IGFsaWdubWVudHMuUklHSFQsXG4gICAgICAgICAgICAncm9vdFgnOiBsYW5kbWFya3MuY2VudGVyWCArIHV0aWxzLmppZ2dsZSg1KSwgICAvLyBUT0RPOiB1c2UgYSBib3VuZGluZyBib3ggaW5zdGVhZD9cbiAgICAgICAgICAgICdyb290WSc6IGxhbmRtYXJrcy5jZW50ZXJZICsgdXRpbHMuamlnZ2xlKDUpLFxuICAgICAgICAgICAgJ25vZGVMYWJlbEZpZWxkJzogJ290dFRheG9uTmFtZScsICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcGxhY2Vob2xkZXIgdHJlZVxuICAgICAgICAgICAgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgIC8vIGluY2wuIG9ubHkgZGV2aWF0aW9ucyBmcm9tIHRoZSBzdHlsZSBndWlkZSBhYm92ZT9cbi8qXG4gICAgICAgICAgICAgICAgJ2VkZ2VUaGlja25lc3MnOiAxLjAsICBcbiAgICAgICAgICAgICAgICAnZWRnZUNvbG9yJzogJyM5OTknLFxuICAgICAgICAgICAgICAgICdsYWJlbFRleHRIZWlnaHQnOiBpbGx1c3RyYXRpb24uc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtVGV4dFNpemUoKVxuKi9cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8qIFRPRE86IEFwcGx5IG9wdGlvbmFsIG1vZGlmaWNhdGlvbnM/XG4gICAgICAgIGlmIChvcHRpb25zLkJMQUgpIHtcbiAgICAgICAgICAgIG9iai5tZXRhZGF0YS5GT08gPSAnQkFSJztcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKiBSZXR1cm4gdGhlIGRhdGEgbW9kZWwgZm9yIGEgbmV3IGRhdGFzZXQgKG91ciBKU09OIHJlcHJlc2VudGF0aW9uKSAqL1xuICAgIHZhciBnZXROZXdTdXBwb3J0aW5nRGF0YXNldE1vZGVsID0gZnVuY3Rpb24oaWxsdXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgbmV3SUQgPSBpbGx1c3RyYXRpb24uZ2V0TmV4dEF2YWlsYWJsZUlEKCdkYXRhc2V0Jyk7IFxuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgJ2lkJzogbmV3SUQsXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnU3VwcG9ydGluZ0RhdGFzZXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogXCJVbnRpdGxlZCAoXCIrIG5ld0lEICtcIilcIixcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiBcIlwiLFxuICAgICAgICAgICAgICAgICdkb2lzJzogWyBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RhdGEnOiB7IH0sXG4gICAgICAgICAgICAnc3R5bGUnOiB7XG4gICAgICAgICAgICAgICAgLy8gaW5jbC4gb25seSBkZXZpYXRpb25zIGZyb20gdGhlIHN0eWxlIGd1aWRlIGFib3ZlP1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLyogVE9ETzogQXBwbHkgb3B0aW9uYWwgbW9kaWZpY2F0aW9ucz9cbiAgICAgICAgaWYgKG9wdGlvbnMuQkxBSCkge1xuICAgICAgICAgICAgb2JqLm1ldGFkYXRhLkZPTyA9ICdCQVInO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8qIFJldHVybiB0aGUgZGF0YSBtb2RlbCBmb3IgYSBuZXcgb3JuYW1lbnQgKG91ciBKU09OIHJlcHJlc2VudGF0aW9uKSAqL1xuICAgIHZhciBnZXROZXdPcm5hbWVudE1vZGVsID0gZnVuY3Rpb24oaWxsdXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgbmV3SUQgPSBpbGx1c3RyYXRpb24uZ2V0TmV4dEF2YWlsYWJsZUlEKCdvcm5hbWVudCcpOyBcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICdpZCc6IG5ld0lELFxuICAgICAgICAgICAgJ21ldGFkYXRhJzoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ09ybmFtZW50JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IFwiVW50aXRsZWQgKFwiKyBuZXdJRCArXCIpXCIsXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzogXCJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkYXRhJzogeyB9LFxuICAgICAgICAgICAgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgIC8vIGluY2wuIG9ubHkgZGV2aWF0aW9ucyBmcm9tIHRoZSBzdHlsZSBndWlkZSBhYm92ZT9cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8qIFRPRE86IEFwcGx5IG9wdGlvbmFsIG1vZGlmaWNhdGlvbnM/XG4gICAgICAgIGlmIChvcHRpb25zLkJMQUgpIHtcbiAgICAgICAgICAgIG9iai5tZXRhZGF0YS5GT08gPSAnQkFSJztcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKiBPdXIgcHJpbmNpcGxlIHZpZXcgbW9kZWwgWzFdIGlzIGEgc2luZ2xlIGlsbHVzdHJhdGlvbi4gVGhpcyB1c2VzIGJhc2ljXG4gICAgICogS25vY2tvdXQgb2JzZXJ2YWJsZXMgYXMgbWVtYmVycywgYnV0IGFkZHMgY3VzdG9tIGJlaGF2aW9yLiBXZSdsbCB1c2UgYVxuICAgICAqIGZhbWlseSBvZiBwc2V1ZG8tY2xhc3NlcyB0byBkZWZpbmUgdGhlIG1haW4gaWxsdXN0cmF0aW9uIGFuZCBzZWxlY3RlZCBwYXJ0cy5cbiAgICAgKlxuICAgICAqIFsxXSBodHRwOi8va25vY2tvdXRqcy5jb20vZG9jdW1lbnRhdGlvbi9vYnNlcnZhYmxlcy5odG1sXG4gICAgICovXG4gICAgdmFyIElsbHVzdHJhdGlvbiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBJbGx1c3RyYXRpb24pICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTUlTU0lORyAnbmV3JyBrZXl3b3JkLCBwYXRjaGluZyB0aGlzIG5vd1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWxsdXN0cmF0aW9uKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZihkYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIFwiZW1wdHlcIiBpbGx1c3RyYXRpb24gb2JqZWN0IGFib3ZlXG4gICAgICAgICAgICBkYXRhID0gZ2V0TmV3SWxsdXN0cmF0aW9uTW9kZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhZmVseSByZWZlciB0byB0aGlzIGluc3RhbmNlXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvKiBkZWZpbmUgUFJJVkFURSBtZW1iZXJzICh2YXJpYWJsZXMgYW5kIG1ldGhvZHMpZnVuY3Rpb25zIGFuZCB3aXRoICd2YXInICovXG5cbiAgICAgICAgLyogV2UnbGwgbmVlZCB0byBtaW50IGEgdW5pcXVlLCBzZXJpYWwgSUQgZm9yIGVhY2ggbmV3IGlsbHVzdHJhdGlvblxuICAgICAgICAgKiBlbGVtZW50LiBTaW5jZSB3ZSBoYXZlIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgZWxlbWVudHMsIHdlIGNhblxuICAgICAgICAgKiBzZXQgdGhlIGluaXRpYWwgdmFsdWVzIGZvciBhbiBpbGx1c3RyYXRpb24gYXMgaXQgbG9hZHMsIGJ5IHNjYW5uaW5nXG4gICAgICAgICAqIHRoZSBleGlzdGluZyBlbGVtZW50cyBvZiBlYWNoIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbmV4dEF2YWlsYWJsZUlEID0ge1xuICAgICAgICAgICAgJ3RyZWUnOiAwLFxuICAgICAgICAgICAgJ2RhdGFzZXQnOiAwLFxuICAgICAgICAgICAgJ29ybmFtZW50JzogMFxuICAgICAgICB9O1xuICAgICAgICAvLyBFYWNoIGVsZW1lbnQgbmlja25hbWUgYWJvdmUgaXMgdXNlZCBpbiBJRHMsIGVnLiAndHJlZS0zMidcbiAgICAgICAgdmFyIGluaXRTZXJpYWxFbGVtZW50SURzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhVHlwZSBpbiBuZXh0QXZhaWxhYmxlSUQpIHtcbiAgICAgICAgICAgICAgICBuZXh0QXZhaWxhYmxlSURbIGFUeXBlIF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhpZ2hlc3RUcmVlSURGb3VuZCA9IDA7XG4gICAgICAgICAgICB2YXIgaGlnaGVzdERhdGFzZXRJREZvdW5kID0gMDtcbiAgICAgICAgICAgIHZhciBoaWdoZXN0T3JuYW1lbnRJREZvdW5kID0gMDtcblxuICAgICAgICAgICAgJC5lYWNoKHNlbGYuZWxlbWVudHMoKSwgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBlbC5pZCgpLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGl0c1NlcmlhbElEID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICBuZXh0QXZhaWxhYmxlSURbIGVsZW1lbnRUeXBlIF0gPSBNYXRoLm1heCggXG4gICAgICAgICAgICAgICAgICAgIGl0c1NlcmlhbElELFxuICAgICAgICAgICAgICAgICAgICBuZXh0QXZhaWxhYmxlSURbIGVsZW1lbnRUeXBlIF0gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKiBkZWZpbmUgUFVCTElDIHZhcmlhYmxlcyAoYW5kIHByaXZpbGVnZWQgbWV0aG9kcykgd2l0aCAnc2VsZicgKi9cblxuICAgICAgICBzZWxmLmdldEVsZW1lbnRCeUlEID0gZnVuY3Rpb24oIGVsZW1lbnRJRCApIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBhbiBlbGVtZW50IChlZywgYW4gSWxsdXN0cmF0ZWRUcmVlKSwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgIHZhciBmb3VuZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgJC5lYWNoKHNlbGYuZWxlbWVudHMoKSwgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuaWQoKSA9PT0gZWxlbWVudElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5nZXROZXh0QXZhaWxhYmxlSUQgPSBmdW5jdGlvbiggZWxlbWVudFR5cGUgKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIGEgc2VyaWFsIElEIGxpa2UgJ2RhdGFzZXQtNCcgb3IgJ3RyZWUtMTInXG4gICAgICAgICAgICB2YXIgcmVhZHlJRCA9IG5leHRBdmFpbGFibGVJRFsgZWxlbWVudFR5cGUgXTtcbiAgICAgICAgICAgIG5leHRBdmFpbGFibGVJRFsgZWxlbWVudFR5cGUgXSA9IHJlYWR5SUQgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50VHlwZSArJy0nKyBuZXh0QXZhaWxhYmxlSURbIGVsZW1lbnRUeXBlIF0pO1xuICAgICAgICB9IFxuXG4gICAgICAgIC8vIFJFTUlOREVSOiBjb21wdXRlZCBvYnNlcnZhYmxlcyBzaG91bGQgdXNlICdkZWZlckV2YWx1YXRpb24nIGluXG4gICAgICAgIC8vIGNhc2UgdGhlaXIgZGVwZW5kZW5jaWVzIHdpbGwgYXBwZWFyIGR1cmluZyBrby5tYXBwaW5nXG4gICAgICAgIHNlbGYuc3R5bGVHdWlkZVNvdXJjZUhUTUwgPSBrby5jb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2goc2VsZi5zdHlsZUd1aWRlLnNvdXJjZS50eXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGRhdGFTb3VyY2VUeXBlcy5VUkw6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdHNVUkwgPSBzZWxmLnN0eWxlR3VpZGUuc291cmNlLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj0nKyBpdHNVUkwgKycgdGFyZ2V0PVwiX2JsYW5rXCI+JysgaXRzVVJMICsnPC9hPic7XG4gICAgICAgICAgICAgICAgY2FzZSBkYXRhU291cmNlVHlwZXMuQlVJTFRfSU46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJ1aWx0LWluXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJVbmRlZmluZWRcIjsgXG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYudXNlQ2hvc2VuUHJpbnRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZU5hbWUgPSAkKCcjc3R5bGUtZG9jc2l6ZS1jaG9vc2VyJykudmFsKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRTaXplID0gZ2V0UHJpbnRTaXplQnlOYW1lKCBzaXplTmFtZSApO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzZUNob3NlblByaW50U2l6ZSgpOiBubyBtYXRjaGluZyBzaXplIGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFNpemUudW5pdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gc2l6ZSBzaG91bGQgcmV0YWluIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLnByaW50U2l6ZS53aWR0aCggc2VsZWN0ZWRTaXplLndpZHRoKCkgKTtcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoIHNlbGVjdGVkU2l6ZS5oZWlnaHQoKSApO1xuICAgICAgICAgICAgICAgIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCBzZWxlY3RlZFNpemUudW5pdHMoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlzaWJsZSBjYW52YXMgYW5kIGQzIHZpelxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYudXBkYXRlUHJpbnRTaXplQ2hvb3NlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gKGRlKXNlbGVjdCBtYXRjaGluZyBzaXplIGFmdGVyIG1hbnVhbCBhZGp1c3RtZW50c1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nU2l6ZSA9ICQuZ3JlcChcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMucHJpbnRTaXplcygpLCBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCd1bml0cycgaW4gbykpIHJldHVybiBmYWxzZTsgLy8gJ0N1c3RvbSBzaXplJyBuZXZlciBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdXNlIG9mICE9IGluc3RlYWQgb2YgIT09IGJlbG93LCBiZWNhdXNlIFwiMTFcIiA9PSAxMVxuICAgICAgICAgICAgICAgICAgICBpZiAoby51bml0cygpICE9IHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ud2lkdGgoKSAhPSBzZWxmLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLmhlaWdodCgpICE9IHNlbGYuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClbMF07XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdTaXplTmFtZSA9ICdDdXN0b20gc2l6ZSc7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTaXplTmFtZSA9IG1hdGNoaW5nU2l6ZS5uYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCcjc3R5bGUtZG9jc2l6ZS1jaG9vc2VyJykudmFsKG1hdGNoaW5nU2l6ZU5hbWUpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlzaWJsZSBjYW52YXMgYW5kIGQzIHZpelxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRQcmludFNpemVCeU5hbWUgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ1NpemUgPSAkLmdyZXAoXG4gICAgICAgICAgICAgICAgc2VsZi5zdHlsZUd1aWRlLmNvbnN0cmFpbnRzLnByaW50U2l6ZXMoKSwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5uYW1lKCkgPT09IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hpbmdTaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2V0UHJpbnRTaXplQnluYW1lKCk6IG5vIHN1Y2ggc2l6ZSBhcyBcIicrIG5hbWUgKydcIiEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi51bml0c0Z1bGxOYW1lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2goIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5JTkNIRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluY2hlc1wiXG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5DRU5USU1FVEVSUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY2VudGltZXRlcnNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VsZiwge2RlZmVyRXZhbHVhdGlvbjp0cnVlfSk7XG4gICAgICAgIHNlbGYudW5pdHNEaXNwbGF5QWJicmV2aWF0aW9uID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2goIHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5JTkNIRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluLlwiXG4gICAgICAgICAgICAgICAgY2FzZSB1bml0cy5DRU5USU1FVEVSUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VsZiwge2RlZmVyRXZhbHVhdGlvbjp0cnVlfSk7XG4gICAgICAgIHNlbGYudW5pdHNDc3NTdWZmaXggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCggc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSApIHtcbiAgICAgICAgICAgICAgICBjYXNlIHVuaXRzLklOQ0hFUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5cIlxuICAgICAgICAgICAgICAgIGNhc2UgdW5pdHMuQ0VOVElNRVRFUlM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNtXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYudXNlQ2hvc2VuRm9udEZhbWlseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gJCgnI3N0eWxlLWZvbnRmYW1pbHktY2hvb3NlcicpLnZhbCgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRm9udCA9IGdldEZvbnRGYW1pbHlCeU5hbWUoIGZvbnROYW1lICk7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkRm9udCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNlQ2hvc2VuRm9udEZhbWlseSgpOiBubyBtYXRjaGluZyBmb250IGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEZvbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gc2l6ZSBzaG91bGQgcmV0YWluIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlLmZvbnRGYW1pbHkoIHNlbGVjdGVkRm9udC52YWx1ZSgpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9udE5hbWUgPT09ICdTb21ldGhpbmcgZWxzZScpIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1vcHRpb25zJykuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1vcHRpb25zJykuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnVwZGF0ZUZvbnRGYW1pbHlDaG9vc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAoZGUpc2VsZWN0IG1hdGNoaW5nIGZvbnQgYWZ0ZXIgbWFudWFsIGFkanVzdG1lbnRzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGb250ID0gJC5ncmVwKFxuICAgICAgICAgICAgICAgIHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5mb250RmFtaWxpZXMoKSwgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgndmFsdWUnIGluIG8pKSByZXR1cm4gZmFsc2U7IC8vICdTb21ldGhpbmcgZWxzZScgbmV2ZXIgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoby52YWx1ZSgpICE9PSBzZWxmLnN0eWxlLmZvbnRGYW1pbHkoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApWzBdO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRm9udE5hbWUgPSAnU29tZXRoaW5nIGVsc2UnO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRm9udCkge1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nRm9udE5hbWUgPSBtYXRjaGluZ0ZvbnQubmFtZSgpO1xuICAgICAgICAgICAgICAgICQoJyNzdHlsZS1mb250ZmFtaWx5LW9wdGlvbnMnKS5oaWRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNzdHlsZS1mb250ZmFtaWx5LW9wdGlvbnMnKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCcjc3R5bGUtZm9udGZhbWlseS1jaG9vc2VyJykudmFsKG1hdGNoaW5nRm9udE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0Rm9udEZhbWlseUJ5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRm9udCA9ICQuZ3JlcChcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMuZm9udEZhbWlsaWVzKCksIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ubmFtZSgpID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoaW5nRm9udCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dldEZvbnRGYW1pbHlCeW5hbWUoKTogbm8gc3VjaCBmb250IGFzIFwiJysgbmFtZSArJ1wiIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nRm9udDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubWluVGV4dFNpemVIZWxwZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhpcyBzaXplIGluIGNob3NlbiB1bml0c1xuICAgICAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU2l6ZSA9IHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtVGV4dFNpemUoKTtcbiAgICAgICAgICAgIGlmIChpc05hTihjaG9zZW5TaXplKSB8fCAkLnRyaW0oY2hvc2VuU2l6ZSkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0cyBhbnkgbm9uLW51bWVyaWMgY2hhcnMsIGFsbG93cyB3aGl0ZXNwYWNlIGFuZCBkZWNpbWFsXG4gICAgICAgICAgICAgICAgaHRtbCA9ICc8ZW0+VGhpcyB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyPC9lbT4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlY2hvIHRoZSBuZXcgc2l6ZSAoaW4gcHQpIGFzIGluY2hlcy9jbVxuICAgICAgICAgICAgICAgIGNob3NlblNpemUgPSBwYXJzZUZsb2F0KGNob3NlblNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRTaXplID0gc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gdW5pdHMuSU5DSEVTID9cbiAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5wb2ludHNUb0luY2hlcyggY2hvc2VuU2l6ZSApIDpcbiAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5wb2ludHNUb0NlbnRpbWV0ZXJzKCBjaG9zZW5TaXplICk7XG4gICAgICAgICAgICAgICAgY29udmVydGVkU2l6ZSA9IGNvbnZlcnRlZFNpemUudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdFN1ZmZpeCA9IHNlbGYuc3R5bGUucHJpbnRTaXplLnVuaXRzKCkgPT09IHVuaXRzLklOQ0hFUyA/XG4gICAgICAgICAgICAgICAgICAgICdpbmNoZXMnIDogJ2NtJztcbiAgICAgICAgICAgICAgICBodG1sID0gJ3B0ICZuYnNwOygnKyBjb252ZXJ0ZWRTaXplICsnICcrIHVuaXRTdWZmaXggKycpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9LCBzZWxmLCB7ZGVmZXJFdmFsdWF0aW9uOnRydWV9KTtcblxuICAgICAgICBzZWxmLm1pbkxpbmVUaGlja25lc3NIZWxwZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhpcyBzaXplIGluIGNob3NlbiB1bml0c1xuICAgICAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgICAgICB2YXIgY2hvc2VuU2l6ZSA9IHNlbGYuc3R5bGVHdWlkZS5jb25zdHJhaW50cy5taW5pbXVtTGluZVRoaWNrbmVzcygpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGNob3NlblNpemUpIHx8ICQudHJpbShjaG9zZW5TaXplKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyByZWplY3RzIGFueSBub24tbnVtZXJpYyBjaGFycywgYWxsb3dzIHdoaXRlc3BhY2UgYW5kIGRlY2ltYWxcbiAgICAgICAgICAgICAgICBodG1sID0gJzxlbT5UaGlzIHZhbHVlIG11c3QgYmUgYSBudW1iZXI8L2VtPic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVjaG8gdGhlIG5ldyBzaXplIChpbiBwdCkgYXMgaW5jaGVzL2NtXG4gICAgICAgICAgICAgICAgY2hvc2VuU2l6ZSA9IHBhcnNlRmxvYXQoY2hvc2VuU2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFNpemUgPSBzZWxmLnN0eWxlLnByaW50U2l6ZS51bml0cygpID09PSB1bml0cy5JTkNIRVMgP1xuICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LnBvaW50c1RvSW5jaGVzKCBjaG9zZW5TaXplICkgOlxuICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LnBvaW50c1RvQ2VudGltZXRlcnMoIGNob3NlblNpemUgKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRTaXplID0gY29udmVydGVkU2l6ZS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICAgIHZhciB1bml0U3VmZml4ID0gc2VsZi5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gdW5pdHMuSU5DSEVTID9cbiAgICAgICAgICAgICAgICAgICAgJ2luY2hlcycgOiAnY20nO1xuICAgICAgICAgICAgICAgIGh0bWwgPSAncHQgJm5ic3A7KCcrIGNvbnZlcnRlZFNpemUgKycgJysgdW5pdFN1ZmZpeCArJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0sIHNlbGYsIHtkZWZlckV2YWx1YXRpb246dHJ1ZX0pO1xuXG4gICAgICAgIHNlbGYubW92ZUVsZW1lbnRVcCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wTGlzdCA9IHNlbGYuZWxlbWVudHMoKS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3MgPSAkLmluQXJyYXkoZWwsIHRlbXBMaXN0KTtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gY3VycmVudFBvcyAtIDE7XG4gICAgICAgICAgICAgIHRlbXBMaXN0W2N1cnJlbnRQb3NdID0gdGVtcExpc3RbcHJldmlvdXNQb3NdO1xuICAgICAgICAgICAgICB0ZW1wTGlzdFtwcmV2aW91c1Bvc10gPSBlbDtcbiAgICAgICAgICAgICAgc2VsZi5lbGVtZW50cyh0ZW1wTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5tb3ZlRWxlbWVudERvd24gPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICB2YXIgdGVtcExpc3QgPSBzZWxmLmVsZW1lbnRzKCkuc2xpY2UoMCk7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zID0gJC5pbkFycmF5KGVsLCB0ZW1wTGlzdCk7XG4gICAgICAgICAgICAgIHZhciBuZXh0UG9zID0gY3VycmVudFBvcyArIDE7XG4gICAgICAgICAgICAgIHRlbXBMaXN0W2N1cnJlbnRQb3NdID0gdGVtcExpc3RbbmV4dFBvc107XG4gICAgICAgICAgICAgIHRlbXBMaXN0W25leHRQb3NdID0gZWw7XG4gICAgICAgICAgICAgIHNlbGYuZWxlbWVudHModGVtcExpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY29uZmlybVJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lLCByZW1vdmVNZXRob2Q7XG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBJbGx1c3RyYXRlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhpcyB0cmVlPyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlSWxsdXN0cmF0ZWRUcmVlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgU3VwcG9ydGluZ0RhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhpcyBkYXRhc2V0PyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU3VwcG9ydGluZ0RhdGFzZXQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBPcm5hbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHJlbW92ZSB0aGlzIG9ybmFtZW50PyBUaGlzIGNhbm5vdCBiZSB1bmRvbmUhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlT3JuYW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNvbmZpcm1SZW1vdmVFbGVtZW50KCk6IHVuZXhwZWN0ZWQgZWxlbWVudCB0eXBlOiAnXCIrIGVsLm1ldGFkYXRhLnR5cGUoKSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJbnN0ZWFkIG9mIGV4cGxpY2l0bHkgZGVmaW5pbmcgYWxsIHBvc3NpYmxlIG1lbWJlcnMsIGxldCdzXG4gICAgICAgICAqIHRydXN0IHRoZSBrby5tYXBwaW5nIHBsdWdpbiB0byBoYW5kbGUgbG9hZGluZyBhbmQgc2F2aW5nIFxuICAgICAgICAgKiBpbGx1c3RyYXRpb24gZGF0YSBmcm9tIEpTKE9OKSwgd2l0aCBtYXBwaW5nIG9wdGlvbnMgdG8gaGFuZGxlXG4gICAgICAgICAqIGFueSBleGNlcHRpb25hbCBzdHVmZi5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBtYXBwaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8qIFVzZSB0byBoYW5kbGUgc3BlY2lhbCBjYXNlczpcbiAgICAgICAgICAgICAqICAnaWdub3JlJyB0byBrZWVwIHNvbWUgY2x1dHRlciBvdXQgb2YgdGhlIHNhdmVkIG1vZGVsXG4gICAgICAgICAgICAgKiAgJ2luY2x1ZGUnIHRvIGZvcmNlIHZpZXctbW9kZWwgcHJvcGVydGllcyB0byBiZSBzYXZlZFxuICAgICAgICAgICAgICogICdjb3B5JyB0byBrZWVwIHNpbXBsZSB2YWx1ZXMgc2ltcGxlICh2cy4gb2JzZXJ2YWJsZSlcbiAgICAgICAgICAgICAqICAnb2JzZXJ2ZScgT05MWSBpZiBpdCdzIGVhc2llciB0byB3aGl0ZWxpc3QgdGhlIG9ic2VydmFibGVzXG4gICAgICAgICAgICAgKiAgJ2NyZWF0ZScgbWFwIHNvbWUgZWxlbWVudHMgdG8gb2JqZWN0IGNsYXNzZXNcbiAgICAgICAgICAgICAqICAndXBkYXRlJz8gY29udmVydCBEYXRlcyB0byBJU08gZGF0ZS1zdHJpbmdzLCBpbnRzIHRvIGZsb2F0c1xuICAgICAgICAgICAgICogICdrZXknOiBwaW4gZWxlbWVudHMgdG8gc3BlY2lmaWVkIGtleXNcbiAgICAgICAgICAgICAqIFNlZSBodHRwOi8va25vY2tvdXRqcy5jb20vZG9jdW1lbnRhdGlvbi9wbHVnaW5zLW1hcHBpbmcuaHRtbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnaWdub3JlJzogWyAnY29uc3RydWN0b3InIF0sXG4gICAgICAgICAgICAnaW5jbHVkZSc6IFsgXSxcbiAgICAgICAgICAgICdjb3B5JzogWyAndmVnYVNwZWMnIF0sXG4gICAgICAgICAgICAvLyAnb2JzZXJ2ZSc6IFsgXSwgLy8gV0FSTklORzogdXNpbmcgdGhpcyBmbGlwcyBkZWZhdWx0IG1hcHBpbmchXG4gICAgICAgICAgICAnZWxlbWVudHMnOiB7XG4gICAgICAgICAgICAgICAgJ2NyZWF0ZSc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZXNlIGFzIG9iamVjdCBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhUGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaWxsdXN0cmF0aW9uID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGRhdGEubWV0YWRhdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyBpbGx1c3RyYXRpb24gdG8gZ2V0IElEcyBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0lsbHVzdHJhdGVkVHJlZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbGx1c3RyYXRlZFRyZWUoX2lsbHVzdHJhdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdTdXBwb3J0aW5nRGF0YXNldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdXBwb3J0aW5nRGF0YXNldChfaWxsdXN0cmF0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09ybmFtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9ybmFtZW50KF9pbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBlbGVtZW50IHR5cGUgJ1wiKyBkYXRhLm1ldGFkYXRhLnR5cGUgK1wiJyEgQ3JlYXRpbmcgYSBnZW5lcmljIG9ic2VydmFibGUuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby5vYnNlcnZhYmxlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2tleSc6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlICdpZCcgYXR0cmlidXRlIHRvIHBpbiB0aGVzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIE1hcCBpbmNvbWluZyBkYXRhIGZyb20gYSBKUyBvYmplY3QuIE5PVEUgdGhhdCB3ZSBjYW4gYWxzbyBkbyBcbiAgICAgICAgICogdGhpcyBwaWVjZW1lYWwgdG8gKGZvciBleGFtcGxlKSBhcHBseSBuZXcgc3R5bGVzIHRvIGFuIGlsbHVzdHJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogQWRkIHNvbWUgdmFsaWNhdGlvbiBvciBvdGhlciBzYW5pdHkgY2hlY2tzIGFmdGVyIG1hcHBpbmcsIHRvXG4gICAgICAgICAqIG1ha2Ugc3VyZSB3ZSdyZSBub3QgZ2V0dGluZyBub25zZW5zZSBmcm9tIHRoZSBzYXZlZCBtb2RlbD9cbiAgICAgICAgICovXG4gICAgICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIG1hcHBpbmdPcHRpb25zLCBzZWxmKTtcblxuICAgICAgICAvLyBBZGQgdmFsaWRhdGlvbiBmb3IgZmllbGRzIHRoYXQgbmVlZCBpdFxuICAgICAgICBzZWxmLm1ldGFkYXRhLm5hbWUuZXh0ZW5kKHtyZXF1aXJlZDogdHJ1ZX0pO1xuXG4gICAgICAgIC8vIFJlc2V0IHNlcmlhbCBlbGVtZW50IElEcyBmb3IgdGhpcyBpbGx1c3RyYXRpb25cbiAgICAgICAgaW5pdFNlcmlhbEVsZW1lbnRJRHMoKTtcblxuICAgICAgICBzZWxmLmV4cG9ydE1vZGVsQXNPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBrby5tYXBwaW5nLnRvSlMoc2VsZik7XG4gICAgICAgICAgICAvLyBUT0RPOiBhbnkgY2xlYW51cCBoZXJlP1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmV4cG9ydE1vZGVsQXNKU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGtvLm1hcHBpbmcudG9KU09OKHNlbGYpO1xuICAgICAgICAgICAgLy8gVE9ETzogYW55IGNsZWFudXAgaGVyZT9cbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9O1xuXG4gICAgfVxuICAgIC8qIGRlZmluZSBQVUJMSUMgbWV0aG9kcyAodGhhdCBkb24ndCBuZWVkIHByaXZhdGUgZGF0YSkgaW4gaXRzIHByb3RvdHlwZSAqL1xuICAgIElsbHVzdHJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBJbGx1c3RyYXRpb24sXG5cbiAgICAgICAgYXBwbHlTdHlsZUd1aWRlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBrby5tYXBwaW5nLmZyb21KUyhkYXRhLCBJbGx1c3RyYXRpb24ubWFwcGluZ09wdGlvbnMsIHNlbGYuc3R5bGVHdWlkZSk7XG5cbiAgICAgICAgICAgIC8qIFNvbWUgcHJvcGVydGllcyBhcmUgKmZvcmNlZCogKHJhdGhlciB0aGVuIHN1Z2dlc3RlZCkgdG8gY29tcGx5XG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBhY3RpdmUgc3R5bGUgZ3VpZGUuIFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IFJlY29uc2lkZXIgdGhpcyEgRWFjaCBmaWVsZCBzaG91bGQgcHJvYmFibHkgYmUgZGVmaW5lZFxuICAgICAgICAgICAgICogZWl0aGVyIGFzIGEgY29uc3RyYWludCBPUiBhIHBlci1pbGx1c3RyYXRpb24gKiBzdHlsZSBhc3NlcnRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBmb3JjZWRTdHlsZXMgPSBbXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgICAgICAgICAgJ2JvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2VkZ2VDb2xvcicsXG4gICAgICAgICAgICAgICAgJ2VkZ2VUaGlja25lc3MnLFxuICAgICAgICAgICAgICAgICdub2RlQ29sb3InLFxuICAgICAgICAgICAgICAgICdub2RlU2hhcGUnXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgJC5lYWNoKGZvcmNlZFN0eWxlcywgZnVuY3Rpb24oaSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN0eWxlW3Byb3BOYW1lXSggc2VsZi5zdHlsZUd1aWRlLmNvbnN0cmFpbnRzW3Byb3BOYW1lXSgpICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VsZi51cGRhdGVQcmludFNpemVDaG9vc2VyKCk7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZUZvbnRGYW1pbHlDaG9vc2VyKCk7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRJbGx1c3RyYXRlZFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHRyZWUgPSBuZXcgSWxsdXN0cmF0ZWRUcmVlKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50cy5wdXNoKHRyZWUpO1xuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSWxsdXN0cmF0ZWRUcmVlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmVsZW1lbnRzLnJlbW92ZSh0cmVlKTtcbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgZGVsZXRlIHRyZWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkU3VwcG9ydGluZ0RhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRzICA9IG5ldyBTdXBwb3J0aW5nRGF0YXNldChzZWxmKTtcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucHVzaChkcyk7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIHJldHVybiBkcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlU3VwcG9ydGluZ0RhdGFzZXQ6IGZ1bmN0aW9uKGRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmVsZW1lbnRzLnJlbW92ZShkcyk7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRPcm5hbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb2JqICA9IG5ldyBPcm5hbWVudChzZWxmKTtcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucHVzaChvYmopO1xuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVPcm5hbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmVsZW1lbnRzLnJlbW92ZShvYmopO1xuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgICAgICBkZWxldGUgb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIEZvciBhIGdpdmVuIG5vZGUsIHJldHJpZXZlIHRoZSBiZXN0IHBvc3NpYmxlIGxhYmVsIGZpZWxkXG4gICAgICAgICAqIChvcHRpb25hbGx5IGZyb20gYSByYW5rZWQgbGlzdCBvZiBmaWVsZHMpIG9yIGl0cyB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIENVUlJFTlRMWSBVTlVTRUQsIGJ1dCBtYXkgYmUgdXNlZnVsIGlmIHdlIHdhbnQgdG8gc3VwcG9ydFxuICAgICAgICAgKiBmYWxsYmFjayBsYWJlbGluZyBiYXNlZCBvbiBhIHJhbmtlZCBsaXN0IG9mIHNvdXJjZXMsIGZvciBleGFtcGxlXG4gICAgICAgICAqICAgWydleHBsaWNpdExhYmVsJywgJ290dFRheG9uTmFtZScsICdvcmlnaW5hbExhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGdldFByZWZlcnJlZExhYmVsRmllbGQ6IGZ1bmN0aW9uKG5vZGUsIHJhbmtlZEZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCFyYW5rZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICByYW5rZWRGaWVsZHMgPSBbJ2V4cGxpY2l0TGFiZWwnLCdvdHRUYXhvbk5hbWUnLCdvcmlnaW5hbExhYmVsJywnb3R0SWQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3VuZE5vbkVtcHR5TGFiZWwgPSAnZXhwbGljaXRMYWJlbCc7ICAvLyBhIGhhcm1sZXNzIGRlZmF1bHRcbiAgICAgICAgICAgICQuZWFjaChyYW5rZWRGaWVsZHMsIGZ1bmN0aW9uKGksZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZE5vbkVtcHR5TGFiZWwgPSBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIHN0b3AgY2hlY2tpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVzaW5nIGxhYmVsIGZpZWxkICdcIisgZm91bmROb25FbXB0eUxhYmVsICtcIicgZm9yIHRoaXMgbm9kZTpcIik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmROb25FbXB0eUxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcmVmZXJyZWRMYWJlbFRleHQ6IGZ1bmN0aW9uKG5vZGUsIHJhbmtlZEZpZWxkcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByZWZlcnJlZEZpZWxkID0gc2VsZi5nZXRQcmVmZXJyZWRMYWJlbEZpZWxkKG5vZGUsIHJhbmtlZEZpZWxkcyk7XG4gICAgICAgICAgICB2YXIgcHJlZmVycmVkVGV4dCA9IG5vZGVbcHJlZmVycmVkRmllbGRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVmZXJyZWRUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmZXJyZWRUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgIH0sXG5cbiAgICAgICAgLyogRm9yIGEgZ2l2ZW4gZWxlbWVudCAoZWcsIGEgdHJlZSwgbm9kZSwgZWRnZSwgb3JuYW1lbnQsIG9yIHRoZVxuICAgICAgICAgKiBpbGx1c3RyYXRpb24gaXRzZWxmKSwgZ2V0IHRoZSBtb3N0IFwibG9jYWxcIiBtYXRjaGluZyBzdHlsZSB2YWx1ZSBmb3JcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS4gQnkgZGVmYXVsdCwgdGhpcyBzaG91bGQgY29uZm9ybSB0byB0aGUgXG4gICAgICAgICAqIGlsbHVzdHJhdGlvbiBpdHNlbGYsIG9yIGl0cyBhY3RpdmUgc3R5bGUgZ3VpZGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFZmZlY3RpdmVTdHlsZTogZnVuY3Rpb24ob2JqLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCdzdHlsZScgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lIGluIG9iai5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgb2JzZXJ2YWJsZXMgb3Igc2ltcGxlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG9iai5zdHlsZVtwcm9wTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWluZWRWYWx1ZSA9IHNlbGYuZ2V0Q29uc3RyYWluZWRTdHlsZShwcm9wTmFtZSwgcmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RyYWluZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSB3YXNuJ3QgZm91bmQgbG9jYWxseTsgY2hlY2sgdGhlIG5leHQgXCJpbm5lcm1vc3RcIiBjb250ZXh0IFxuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIElsbHVzdHJhdGVkVHJlZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldEVmZmVjdGl2ZVN0eWxlKHNlbGYsIHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgSWxsdXN0cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdldEVmZmVjdGl2ZVN0eWxlKCk6IHN0eWxlICdcIisgcHJvcE5hbWUgK1wiJyBub3QgZm91bmQgaW4gdGhpcyB0cmVlJ3Mgc3R5bGU6XCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Iob2JqLnN0eWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFN1cHBvcnRpbmdEYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdldEVmZmVjdGl2ZVN0eWxlKCk6IFN1cHBvcnRpbmdEYXRhc2V0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE9ybmFtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdldEVmZmVjdGl2ZVN0eWxlKCk6IE9ybmFtZW50IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJnZXRFZmZlY3RpdmVTdHlsZSgpOiB1bmV4cGVjdGVkIGNvbnRleHQgb2JqZWN0OlwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRDb25zdHJhaW5lZFN0eWxlOiBmdW5jdGlvbiAocHJvcE5hbWUsIHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzd2l0Y2gocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdlZGdlVGhpY2tuZXNzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib3JkZXJUaGlja25lc3MnOlxuICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhlc2UgYXJlIGluIGNvbW1vbiB1bml0cyAocHQ/KVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpbm5lc3QgPSBzZWxmLnN0eWxlR3VpZGUuY29uc3RyYWludHMubWluaW11bUxpbmVUaGlja25lc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJhd1ZhbHVlLCB0aGlubmVzdCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIChtYW55KSBtb3JlIGNhc2VzIGhlcmUsIG9yIGNvbnN0cmFpbiBlbHNld2hlcmUuLlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGFueXRoaW5nIGdvZXMsIHJldHVybiB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVZlZ2FTcGVjOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAvKiBTd2VlcCB0aGUgSWxsdXN0cmF0aW9uIG1vZGVsIGFuZCAocmUpZ2VuZXJhdGVkIGEgZnVsbCBWZWdhIHNwZWMuXG4gICAgICAgICAgICAgKiBUaGlzIGRyaXZlcyB0aGUgZDMgdmlzdWFsaXphdGlvbiBpbiB0aGUgZWRpdG9yIHZpZXdwb3J0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3BlYyA9IHNlbGYudmVnYVNwZWM7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBncm91cHMgYW5kIG1hcmtzLCBhbmQgcmVzdG9yZSB0aGUgZW1wdHkgaWxsdXN0cmF0aW9uLWVsZW1lbnRzIGdyb3VwXG4gICAgICAgICAgICBzcGVjLm1hcmtzID0gWyBdO1xuICAgICAgICAgICAgLy8gcmVja29uIHRoZSBjdXJyZW50IHdpZHRoIGFuZCBoZWlnaHQgYXMgaW50ZXJuYWwgcHhcbiAgICAgICAgICAgIHZhciBweFByaW50V2lkdGggPSBzdHlsaXN0LnBoeXNpY2FsVW5pdHNUb1BpeGVscyhzZWxmLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpLCBzdHlsaXN0LmludGVybmFsX3BwaSk7XG4gICAgICAgICAgICB2YXIgcHhQcmludEhlaWdodCA9IHN0eWxpc3QucGh5c2ljYWxVbml0c1RvUGl4ZWxzKHNlbGYuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpLCBzdHlsaXN0LmludGVybmFsX3BwaSk7XG4gICAgICAgICAgICB2YXIgaWxsdXN0cmF0aW9uRWxlbWVudHNHcm91cCA9IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJncm91cFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlsbHVzdHJhdGlvbi1lbGVtZW50c1wiLCAgLy8gYmVjb21lcyBtYXJrZXIgY2xhc3MgLmlsbHVzdHJhdGlvbi1lbGVtZW50c1xuICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZW50ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IHtcInZhbHVlXCI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IHtcInZhbHVlXCI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjoge1widmFsdWVcIjogcHhQcmludEhlaWdodCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB7XCJ2YWx1ZVwiOiBweFByaW50V2lkdGggfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNjYWxlc1wiOiBbIF0sXG4gICAgICAgICAgICAgICAgXCJheGVzXCI6IFsgXSxcbiAgICAgICAgICAgICAgICBcIm1hcmtzXCI6IFsgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNwZWMubWFya3MucHVzaCggaWxsdXN0cmF0aW9uRWxlbWVudHNHcm91cCApO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBhbmQgcmVidWlsZCBkYXRhIGJhc2VkIG9uIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgICAgIHNwZWMuZGF0YSA9IFsgXTtcblxuICAgICAgICAgICAgJC5lYWNoKHNlbGYuZWxlbWVudHMoKSwgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYXBwcm9wcmlhdGUgZGF0YSAqYW5kKiBtYXJrcyBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBJbGx1c3RyYXRlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2VOYW1lID0gZWwuaWQoKTsgIC8vIFwidHJlZS0zXCIgb3Igc2ltaWxhclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IGRhdGFTb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6IHtcInR5cGVcIjpcInRyZWVqc29uXCJ9LCAgLy8gaW5pdGlhbCBtYXRjaCBmb3IgSlNPTiBvYmplY3QsIHZzLiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJncyBmb3IgXCJ0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvblwiLCBcInRyZWVQb3NpdGlvblwiIG9yIFwidHJlZUlEXCI/XG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCBhbGwgcG9zc2libGUgcHJvcGVydGllcyAoY29tbW9uIHRvIGJ5IGFsbCBmb3JtYXRzPylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtZXJnZSBzdXBwb3J0aW5nIGRhdGEgZnJvbSBvdGhlciBmaWxlcz8gb3IgZG8gdGhhdCBkb3duc3RyZWFtP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpbmFsIHRhaWxvcmluZyB0byBwaHlsb2dyYW0gbGF5b3V0IChvbmUsIG9yIHNldmVyYWw/KVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyogRGVmaW5lIGRhdGEgc291cmNlIGZvciB0aGlzIGVsZW1lbnQgKGFsbG93IGZvciBpbmxpbmUgdHJlZSBkYXRhPyBpbiBcbiAgICAgICAgICAgICAgICAgICAgICogZXhpc3RpbmcgZGF0YXNldHM/IG90aGVyIGtpbmRzIG9mIHNvdXJjZXM/KVxuICAgICAgICAgICAgICAgICAgICAgKiBOT1RFIHRoYXQgd2Ugc2hvdWxkIHVzZSBjYWNoZWQgZGF0YSB3aGVuIHBvc3NpYmxlLCB0byBhdm9pZCBcbiAgICAgICAgICAgICAgICAgICAgICogYW4gQUpBWCBmZXRjaCBlYWNoIHRpbWUgd2UgdHdlYWsgdGhlIHZpc3VhbCBwcmVzZW50YXRpb24gb2YgYSB0cmVlIVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVTb3VyY2VDYWNoZUtleSA9ICdpbnB1dC9FTEVNRU5ULVNPVVJDRS0nO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJz09PSBzb3VyY2UgZm9yIGVsZW1lbnQgXCInKyBkYXRhU291cmNlTmFtZSArJ1wiID09PScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyAgdHlwZTogJysgZWwubWV0YWRhdGEuc291cmNlLnR5cGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignICB2YWx1ZTogJysgZWwubWV0YWRhdGEuc291cmNlLnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsLm1ldGFkYXRhLnNvdXJjZS50eXBlKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRhdGFTb3VyY2VUeXBlcy5CVUlMVF9JTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZGF0YVNvdXJjZVR5cGVzLlVSTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlU291cmNlQ2FjaGVLZXkgKz0gJC50cmltKGVsLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRDYWNoZWREYXRhKCB0cmVlU291cmNlQ2FjaGVLZXkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTi5CLiBUaGlzIGRhdGEgd2lsbCBiZSBzYWZlbHkgY2xvbmVkIGJ5IFZlZ2Egd2hlbiBzcGVjIGlzIHBhcnNlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudmFsdWVzID0gY2FjaGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudXJsID0gZWwubWV0YWRhdGEuc291cmNlLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBkYXRhU291cmNlVHlwZXMuVVBMT0FEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VWYWx1ZSA9ICQudHJpbShlbC5tZXRhZGF0YS5zb3VyY2UudmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVwZGF0ZVZlZ2FTcGVjKCk6IGlnbm9yaW5nIGVtcHR5IHBhc3RlL3VwbG9hZHMgZm9yIG5vd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciB0cmVlU291cmNlQ2FjaGVLZXkgPSAoJ1BBU1RFRC1TT1VSQ0UtJyArIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZVNvdXJjZUNhY2hlS2V5ID0gKCdpbnB1dC9QQVNURUQtVFJFRS0nICsgc291cmNlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0Q2FjaGVkRGF0YSggdHJlZVNvdXJjZUNhY2hlS2V5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE4uQi4gVGhpcyBkYXRhIHdpbGwgYmUgc2FmZWx5IGNsb25lZCBieSBWZWdhIHdoZW4gc3BlYyBpcyBwYXJzZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVEYXRhLnZhbHVlcyA9IGNhY2hlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0aWxsIHdhaXRpbmcgZm9yIHBhc3RlZCB0ZXh0IChOZXdpY2s/KSBvZiAnXCIrIGVsLm1ldGFkYXRhLm5hbWUoKSArXCIndG8gYmUgY29udmVydGVkLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCBjYXNlcyBmb3Igb3RoZXIgZGF0YSBzb3VyY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIHNvdXJjZSB0eXBlIGZvciB0cmVlIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIEJ1aWxkIGFuIGFwcHJvcHJpYXRlIGNoYWluIG9mIGRhdGEgdHJhbnNmb3JtcyAqL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBzb3VyY2UgZGF0YSwgaWYgbm90IGFscmVhZHkgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3Rhc2hcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNhY2hlU2V0dGVyXCI6ICdUcmVlSWxsdXN0cmF0b3Iuc2V0Q2FjaGVkRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiOiB0cmVlU291cmNlQ2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZsdXNoXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5leHQgdHJhbnNmb3JtIGltcG9ydHMgZGF0YSBmcm9tIGl0cyBzb3VyY2UgZm9ybWF0IHRvIG91ciBiYXNpYyBwaHlsb1RyZWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWUpIHsgICAvLyBUT0RPOiBQaXZvdCB0byBvdGhlciBpbXBvcnRlcnMgKGUuZy4gTkVYVVMpLCBhcyBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIm5leHNvblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyZWVzQ29sbGVjdGlvblBvc2l0aW9uXCI6MCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmVlUG9zaXRpb25cIjowLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhbmNoUm90YXRpb25cIjogZWwuYnJhbmNoUm90YXRpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVMYWJlbEZpZWxkXCI6IGVsLm5vZGVMYWJlbEZpZWxkKCkgICAvLyBuZWVkZWQgZm9yIGFscGhhYmV0aWNhbCBicmFuY2ggcm90YXRpb24hXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNoYXBlIHRoZSBwaHlsb1RyZWUgdXNpbmcgcHJlZmVycmVkIHRyZWUgbGF5b3V0IGFuZCBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoeWxvZ3JhbVRyYW5zZm9ybSA9IHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJwaHlsb2dyYW1cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1wibGF5b3V0XCI6IFwiY2FydGVzaWFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1wiYnJhbmNoU3R5bGVcIjogXCJkaWFnb25hbFwiLCAgLy8gb3RoZXIgb3B0aW9ucyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYWRpYWxBcmNcIjogZWwucmFkaWFsQXJjKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJhZGlhbFN3ZWVwXCI6IGVsLnJhZGlhbFN3ZWVwKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJyYW5jaExlbmd0aHNcIjogXCJcIiwgIC8vIGVtcHR5L2ZhbHNlLCBvciBhIHByb3BlcnR5IG5hbWUgdG8gY29tcGFyZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogZWwud2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IGVsLmhlaWdodCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmFkaXVzXCI6IGVsLnJhZGl1cygpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGlwc0FsaWdubWVudFwiOiBlbC50aXBzQWxpZ25tZW50KClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEudHJhbnNmb3JtLnB1c2goIHBoeWxvZ3JhbVRyYW5zZm9ybSApO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsLmxheW91dCgpKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0cmVlTGF5b3V0cy5SRUNUQU5HTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGh5bG9ncmFtVHJhbnNmb3JtLmxheW91dCA9ICdjYXJ0ZXNpYW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0cmVlTGF5b3V0cy5DSVJDTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGh5bG9ncmFtVHJhbnNmb3JtLmxheW91dCA9ICdyYWRpYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0cmVlTGF5b3V0cy5UUklBTkdMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHlsb2dyYW1UcmFuc2Zvcm0ubGF5b3V0ID0gJ2NsYWRvZ3JhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzcGVjLmRhdGEucHVzaCh0cmVlRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGxhYmVsIHByb3BlcnRpZXMgKGVzcC4gcG9zaXRpb25pbmcpIGJhc2VkIG9uIHRoZSBjaG9zZW4gbGF5b3V0XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gc2VsZi5zdHlsZUd1aWRlLmNvbnN0cmFpbnRzLm1pbmltdW1UZXh0U2l6ZSgpOyAgIC8vIFRPRE86IGFkanVzdGFibGUgZm9udCBzaXplIChjb252ZXJ0IHB0IHRvIHB4KVxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0ICogMC40OyAgIC8vIFRPRE86IGFkanVzdGFibGUgZm9udCBzaXplIChjb252ZXJ0IHB0IHRvIHB4KVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbExhYmVsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udFNpemVcIjoge1widmFsdWVcIjogdGV4dEhlaWdodH0gXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwubGF5b3V0KCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRyZWVMYXlvdXRzLlJFQ1RBTkdMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdHJlZUxheW91dHMuVFJJQU5HTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGFiZWwgb2Zmc2V0cyBkZXBlbmQgb24gb3JpZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxOdWRnZVgsIGxhYmVsTnVkZ2VZLCBsYWJlbEFsaWduLCBsYWJlbFJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTGFiZWxHYXAgPSA2OyAgLy8gVE9ETzogYmFzZSB0aGlzIG9uIGZvbnQgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwudGlwc0FsaWdubWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYWxpZ25tZW50cy5UT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIHRoZSBvZGQgbWFwcGluZyBvZiBYIGFuZCBZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE51ZGdlWCA9IG5vZGVMYWJlbEdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VZID0gaGFsZlRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxSb3RhdGlvbiA9IC05MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGFsaWdubWVudHMuUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE51ZGdlWCA9IG5vZGVMYWJlbEdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VZID0gaGFsZlRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxSb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhbGlnbm1lbnRzLkJPVFRPTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTnVkZ2VYID0gbm9kZUxhYmVsR2FwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOdWRnZVkgPSBoYWxmVGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhbGlnbm1lbnRzLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE51ZGdlWCA9IC1ub2RlTGFiZWxHYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE51ZGdlWSA9IGhhbGZUZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgc2ltcGxlIHByb3BlcnRpZXMgZm9yIGNhcnRlc2lhbiAvIHJlY3Rhbmd1bGFyIGxheW91dHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChpbml0aWFsTGFiZWxQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiB7XCJmaWVsZFwiOiBcInhcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiB7XCJmaWVsZFwiOiBcInlcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHhcIjoge1widmFsdWVcIjogbGFiZWxOdWRnZVh9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR5XCI6IHtcInZhbHVlXCI6IGxhYmVsTnVkZ2VZfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGlnblwiOiB7XCJ2YWx1ZVwiOiBsYWJlbEFsaWdufSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmdsZVwiOiB7XCJ2YWx1ZVwiOiBsYWJlbFJvdGF0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRyZWVMYXlvdXRzLkNJUkNMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFkZCBwcm9wZXJ0aWVzIGZvciByYWRpYWwvcG9sYXIgbGF5b3V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFJhZGl1cyBhbmQgdGhldGEgKGFuZ2xlIGZyb20gb3JpZ2luLCBpbiByYWRpYW5zKSBhcmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhbHRlcm5hdGl2ZXMgdG8gWCBhbmQgWSBmb3IgcG9sYXIgcHJvamVjdGlvbiwgYW5kIGFzc3VtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB0aGUgeCBhbmQgeSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB0aGUgb3JpZ2luIG9yIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogb2YgdGhlIGxheW91dCwgaWUsIHRoZSByb290IG5vZGUuIFNlZSBkaXNjdXNzaW9uIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL3RyaWZhY3RhL3ZlZ2EvcHVsbC8xODdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKGluaXRpYWxMYWJlbFByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IHtcInZhbHVlXCI6IDB9LCAgLy8gdGhpcyBpcyBvcmlnaW4gZm9yIHJhZGlhbC9wb2xhciBwcm9qZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiB7XCJ2YWx1ZVwiOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyYWRpdXNcIjoge1wiZmllbGRcIjogXCJyYWRpdXNcIn0sICAvLyBweCBmcm9tIG9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRoZXRhXCI6IHtcImZpZWxkXCI6IFwidGhldGFcIn0sICAvLyBpbiByYWRpYW5zICh3aGF0IGRpcmVjdGlvbiBmcm9tIG9yaWdpbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGlnblwiOiB7XCJmaWVsZFwiOiAnYWxpZ24nfSwgIC8vIE5PVEUgdGhhdCBzb21lIGxhYmVscyBhcmUgZmxpcHBlZCAxODBkZWcgZm9yIGxlZ2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmdsZVwiOiB7XCJmaWVsZFwiOiBcImFuZ2xlXCJ9ICAgLy8gaW4gZGVncmVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgbmV3IHRyZWVzIGluIHRoZSBjZW50ZXIgb2YgdGhlIHByaW50YWJsZSBhcmVhIChzbGlnaHRseSBzdGFnZ2VyZWQgZm9yIGNsYXJpdHkpXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlTWFya3MgPSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBlbC5pZCgpLCAgLy8gYmVjb21lcyBtYXJrZXIgY2xhc3MgLnRyZWUtMyBvciBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW50ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjoge1widmFsdWVcIjogZWwucm9vdFgoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiB7XCJ2YWx1ZVwiOiBlbC5yb290WSgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1widHJhbnNmb3JtXCI6IHtcInZhbHVlXCI6XCJzY2FsZSg4MDAsMzAwKVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1widHJhbnNmb3JtXCI6IHtcInZhbHVlXCI6XCJyb3RhdGUoMjUpIHNjYWxlKDIwLDIwKVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmtzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IC8qIHBhdGhzZm9yIHRyZWUgZWRnZXMgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOLkIuIFRoaXMgZXhwZWN0cyBwcmUtZXhpc3RpbmcgbGlua3Mgd2l0aCAnc291cmNlJyBhbmQgJ3RhcmdldCcgcHJvcGVydGllcyEgVGhlICdsaW5rJyB0cmFuc2Zvcm0gaXMgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0IHRvIHByb3ZpZGUgYSByZW5kZXJlZCBwYXRoIG9mIHRoZSBkZXNpcmVkIHR5cGUuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1wiZnJvbVwiOiB7XCJkYXRhXCI6IFwicGh5bG9UcmVlXCIsIFwicHJvcGVydHlcIjogXCJsaW5rc1wiLCBcInRyYW5zZm9ybVwiOiBbe1widHlwZVwiOiBcImxpbmtcIiwgXCJzaGFwZVwiOiBcImxpbmVcIn1dfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnJvbVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhU291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcInR5cGVcIjpcInBsdWNrXCIsIFwiZmllbGRcIjpcInBoeWxvRWRnZXNcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvdyBkbyBhcHBseSB0aGUgJ3RpbWUnIHNjYWxlIGhlcmU/IFRSWSBicnV0ZS1mb3JjaW5nIHggYW5kIHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8ve1widHlwZVwiOlwiZm9ybXVsYVwiLCBcImZpZWxkXCI6XCJzb3VyY2UueFwiLCBcImV4cHJcIjpcImQuc291cmNlLnlcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy97XCJ0eXBlXCI6XCJmb3JtdWxhXCIsIFwiZmllbGRcIjpcInRhcmdldC54XCIsIFwiZXhwclwiOlwiZC50YXJnZXQueVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7XCJ0eXBlXCI6XCJsaW5rXCIsIFwic2hhcGVcIjpcImxpbmVcIiB9ICAvLyBsaW5lIHwgY3VydmUgfCBkaWFnb25hbCB8IGRpYWdvbmFsWCB8IGRpYWdvbmFsWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcInR5cGVcIjpcInBoeWxvZ3JhbUxpbmtcIiwgXCJzaGFwZVwiOlwicmlnaHRBbmdsZURpYWdvbmFsXCIgfSAgLy8gcmlnaHRBbmdsZURpYWdvbmFsIHwgcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXRoXCI6IHtcImZpZWxkXCI6IFwicGF0aFwifSwgLy8gLCBcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6XCJ4XCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiB7XCJ2YWx1ZVwiOiBzZWxmLmdldEVmZmVjdGl2ZVN0eWxlKGVsLCAnZWRnZUNvbG9yJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjoge1widmFsdWVcIjogc2VsZi5nZXRFZmZlY3RpdmVTdHlsZShlbCwgJ2VkZ2VUaGlja25lc3MnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJob3ZlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcInN0cm9rZVwiOiB7XCJ2YWx1ZVwiOiBcInJlZFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvKiBncm91cCBub2RlL2xhYmVsIHBhaXJzLCBmb3IgZWFzaWVyIGV2ZW50IGJpbmRpbmcgbGF0ZXIgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOlwiZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFya3NcIjpbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzeW1ib2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IHtcImRhdGFcIjogZGF0YVNvdXJjZU5hbWUsIFwidHJhbnNmb3JtXCI6IFt7XCJ0eXBlXCI6XCJwbHVja1wiLCBcImZpZWxkXCI6XCJwaHlsb05vZGVzXCIgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW50ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiB7XCJYWHNjYWxlXCI6IFwieFwiLCBcImZpZWxkXCI6IFwieFwiLCBcIm11bHRcIjoxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInlcIjoge1wiWFhzY2FsZVwiOiBcInlcIiwgXCJmaWVsZFwiOiBcInlcIiwgXCJtdWx0XCI6MX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiB7XCJ2YWx1ZVwiOlwiY2lyY2xlXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2l6ZVwiOiB7XCJ2YWx1ZVwiOiA4fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxcIjoge1widmFsdWVcIjogXCJibGFja1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaG92ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZmlsbFwiOiB7XCJ2YWx1ZVwiOiBcInJlZFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiBlbmQgb2Ygbm9kZSBtYXJrcyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICAvLyBsYWJlbCBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnJvbVwiOiB7XCJkYXRhXCI6IGRhdGFTb3VyY2VOYW1lLCBcInRyYW5zZm9ybVwiOiBbe1widHlwZVwiOlwicGx1Y2tcIiwgXCJmaWVsZFwiOlwicGh5bG9Ob2Rlc1wiIH1dIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVudGVyXCI6IGluaXRpYWxMYWJlbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHtcImZpZWxkXCI6IGVsLm5vZGVMYWJlbEZpZWxkKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxcIjoge1widmFsdWVcIjpcImJsYWNrXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJob3ZlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IHtcInZhbHVlXCI6IFwicmVkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiBlbmQgb2YgbGFiZWwgbWFya3MgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLyogZW5kIG9mIGdyb3VwZWQgbm9kZStsYWJlbCAqLyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8qIGdyb3VwIHRyZWUgaG90c3BvdCBhbmQgaGFuZGxlcyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjpcImdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhbmRsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJrc1wiOltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgIC8qIGhvdHNwb3QgZm9yIGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgdGhlIHRyZWUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0cmVlLWhvdHNwb3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGFTb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zZm9ybVwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XCJ0eXBlXCI6XCJwbHVja1wiLCBcImZpZWxkXCI6XCJob3RzcG90XCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhdGhcIjoge1wiZmllbGRcIjogXCJwYXRoXCJ9LCAgLy8gVE9ETzogQ2FuIHdlIG1ha2UgdGhpcyBkeW5hbWljLCBwZXJoYXBzIGEgY2FsbGFibGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiB7XCJ2YWx1ZVwiOiBcIiMwZjBcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IHtcInZhbHVlXCI6IFwiMXB4XCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VPcGFjaXR5XCI6IHtcInZhbHVlXCI6IFwiMC4wXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IHtcInZhbHVlXCI6IFwiIzAwMFwifSwgIC8qIG92ZXJyaWRlIHRoaXMgaW4gQ1NTICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IHtcInZhbHVlXCI6IFwiMC4wXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaG92ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cIm9wYWNpdHlcIjoge1widmFsdWVcIjogXCIwLjFcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICAvKiBjb3JuZXIgaGFuZGxlcyBmb3Igc2l6ZSBhbmQgYW5nbGUgYWRqdXN0bWVudHMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ2ZXJ0ZXgtaGFuZGxlIGFjdHVhbC1zaXplXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3ltYm9sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcm9tXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGFTb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zZm9ybVwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1widHlwZVwiOlwicGx1Y2tcIiwgXCJmaWVsZFwiOlwidmVydGV4SGFuZGxlc1wiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbnRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjoge1wiZmllbGRcIjpcIm5hbWVcIn0sICAvKiBhc3NpZ25lZCB0byBkYXR1bSwgbm90IHRvIG1hcmshICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvb2x0aXBcIjoge1wiZmllbGRcIjpcInRvb2x0aXBcIn0sICAvKiBhc3NpZ25lZCB0byBkYXR1bSwgbm90IHRvIG1hcmshICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IHtcImZpZWxkXCI6IFwic2hhcGVcIn0sIC8qIGRlZmF1bHQgc2hhcGUgaXMgXCJjaXJjbGVcIiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaXplXCI6IHtcImZpZWxkXCI6IFwic2l6ZVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbFwiOiB7XCJ2YWx1ZVwiOiBcIiMwMDBcIn0sICAvKiBvdmVycmlkZSB0aGlzIGluIENTUyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB7XCJ2YWx1ZVwiOiBcIjAuMFwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcInZhbHVlXCI6IFwiI2YwMFwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjoge1widmFsdWVcIjogXCI2XCJ9LCAgLyogaGlkZGVuIGhpdCBhcmVhICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjoge1widmFsdWVcIjogXCIwLjBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IHtcImZpZWxkXCI6IFwieFwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiB7XCJmaWVsZFwiOiBcInlcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaG92ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cIm9wYWNpdHlcIjoge1widmFsdWVcIjogXCIwLjFcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdIC8qIGVuZCBvZiBpbm5lciBncm91cCBtYXJrcyAqL1xuICAgICAgICAgICAgICAgICAgICB9OyAvKiBlbmQgb2YgaW5uZXIgZ3JvdXAgKi9cblxuICAgICAgICAgICAgICAgICAgICBpbGx1c3RyYXRpb25FbGVtZW50c0dyb3VwLm1hcmtzLnB1c2goIHRyZWVNYXJrcyApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIFN1cHBvcnRpbmdEYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXBkYXRlVmVnYVNwZWMoKTogaWdub3JpbmcgZGF0YXNldHMgZm9yIG5vd1wiKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBPcm5hbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVwZGF0ZVZlZ2FTcGVjKCk6IGlnbm9yaW5nIG9ybmFtZW50cyBmb3Igbm93XCIpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInVwZGF0ZVZlZ2FTcGVjKCk6IHVuZXhwZWN0ZWQgZWxlbWVudCB0eXBlOiAnXCIrIGVsLm1ldGFkYXRhLnR5cGUoKSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBkZWZpbmUgY3VzdG9tIHN0eWxlcyBmb3IgbWFueSBkaWZmZXJlbnQgZWxlbWVudHMgb2ZcbiAgICAgKiB0aGUgc2NlbmUgZ3JhcGgsIGUuZy4sIGEgdHJlZSwgbm9kZSwgb3IgY2FwdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgU2NlbmVHcmFwaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBTY2VuZUdyYXBoKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjZW5lR3JhcGgoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2FmZWx5IHJlZmVyIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRPRE86IEJhc2VkIG9uIHRoZSBlbGVtZW50IHR5cGUsIG9mZmVyIGFwcHJvcHJpYXRlIHN0eWxlcyBhbmQgY29uc3RyYWludHNcbiAgICAgICAgLy8gVE9ETzogSW5jbHVkZSBvcHRpb25zIHRvIG1hcCBzZWxlY3RlZCBkYXRhIHRvIHZpc3VhbCBzdHlsZVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICB2YXIgSWxsdXN0cmF0ZWRUcmVlID0gZnVuY3Rpb24oaWxsdXN0cmF0aW9uLCBkYXRhKSB7XG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgSWxsdXN0cmF0ZWRUcmVlKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElsbHVzdHJhdGVkVHJlZShpbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZihkYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIFwiZW1wdHlcIiB0cmVlIG9iamVjdCBhYm92ZVxuICAgICAgICAgICAgZGF0YSA9IGdldE5ld0lsbHVzdHJhdGVkVHJlZU1vZGVsKGlsbHVzdHJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gcG9pbnQgYmFjayB0byBteSBwYXJlbnQgaWxsdXN0cmF0aW9uP1xuICAgICAgICAvL3NlbGYuaWxsdXN0cmF0aW9uID0gaWxsdXN0cmF0aW9uO1xuXG4gICAgICAgIC8qIEFwcGx5IGhhcmQgY29uc3RyYWludHMgdG8gc29tZSBwcm9wZXJ0aWVzIGFuZCB3cmFwIHRoZWlyIGZpZWxkc1xuICAgICAgICAgKiBhY2NvcmRpbmdseS4gV2UgZG8gdGhpcyBieSBiaW5kaW5nIGVhY2ggYmFzaWMgcHJvcGVydHkgdG8gYVxuICAgICAgICAgKiB3cml0YWJsZSBjb21wdXRlZCBvYnNlcnZhYmxlIHRoYXQgYXBwbGllcyBhbnkgY29uc3RyYWludHMgYmVmb3JlXG4gICAgICAgICAqIHVwZGF0aW5nIGl0cyB2YWx1ZSwgcHJvdGVjdGluZyB1cyBmcm9tIG91dC1vZi1ib3VuZHMgb3Igbm9uc2Vuc2ljYWxcbiAgICAgICAgICogdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRyZWVTaXplQ29uc3RyYWludCA9IHtcbiAgICAgICAgICAgICd0eXBlJzogTnVtYmVyLFxuICAgICAgICAgICAgJ21pbic6IHN0eWxpc3QuaW5jaGVzVG9QaXhlbHMoIDAuMjUsIHN0eWxpc3QuaW50ZXJuYWxfcHBpKSwgIC8vIDEvNFwiIHRyZWUgc2VlbXMgbGlrZSBhIHJlYXNvbmFibGUgbWluaW11bVxuICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgZm9yIGEgbWluaW11bSBpbiB0aGUgY3VycmVudCBzdHlsZSBndWlkZT9cbiAgICAgICAgICAgICdtYXgnOiBzdHlsaXN0LmluY2hlc1RvUGl4ZWxzKCAxMDAwLCBzdHlsaXN0LmludGVybmFsX3BwaSkgIC8vIHN0b3AgYXQgMTAwMCBpbmNoZXMgd2lkZVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuY29uc3RyYWluZWRXaWR0aCA9IHdyYXBGaWVsZFdpdGhDb25zdHJhaW50cyhzZWxmLCAnd2lkdGgnLCB0cmVlU2l6ZUNvbnN0cmFpbnQpO1xuICAgICAgICBzZWxmLmNvbnN0cmFpbmVkSGVpZ2h0ID0gd3JhcEZpZWxkV2l0aENvbnN0cmFpbnRzKHNlbGYsICdoZWlnaHQnLCB0cmVlU2l6ZUNvbnN0cmFpbnQpO1xuICAgICAgICBzZWxmLmNvbnN0cmFpbmVkUmFkaXVzID0gd3JhcEZpZWxkV2l0aENvbnN0cmFpbnRzKHNlbGYsICdyYWRpdXMnLCB0cmVlU2l6ZUNvbnN0cmFpbnQpO1xuXG4gICAgICAgIC8vIEJpbmQgc29tZSBmaWVsZHMgdG8gd3JpdGFibGUgY29tcHV0ZWQgb2JzZXJ2YWJsZXMsIHNvIHVzZXJzIGNhbiBcInRoaW5rIGluIHBoeXNpY2FsIHVuaXRzXCJcbiAgICAgICAgc2VsZi5waHlzaWNhbFdpZHRoID0gd3JhcEZpZWxkV2l0aFBoeXNpY2FsVW5pdHMoc2VsZiwgJ2NvbnN0cmFpbmVkV2lkdGgnKTtcbiAgICAgICAgc2VsZi5waHlzaWNhbEhlaWdodCA9IHdyYXBGaWVsZFdpdGhQaHlzaWNhbFVuaXRzKHNlbGYsICdjb25zdHJhaW5lZEhlaWdodCcpO1xuICAgICAgICBzZWxmLnBoeXNpY2FsUmFkaXVzID0gd3JhcEZpZWxkV2l0aFBoeXNpY2FsVW5pdHMoc2VsZiwgJ2NvbnN0cmFpbmVkUmFkaXVzJyk7XG4gICAgICAgIHNlbGYucGh5c2ljYWxSb290WCA9IHdyYXBGaWVsZFdpdGhQaHlzaWNhbFVuaXRzKHNlbGYsICdyb290WCcpO1xuICAgICAgICBzZWxmLnBoeXNpY2FsUm9vdFkgPSB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyhzZWxmLCAncm9vdFknKTtcblxuICAgICAgICBrby5tYXBwaW5nLmZyb21KUyhkYXRhLCBJbGx1c3RyYXRpb24ubWFwcGluZ09wdGlvbnMsIHNlbGYpO1xuXG4gICAgICAgIC8vIChVbilidW5kbGUgJ3N0YXJ0QW5nbGUnIGFuZCAnZW5kQW5nbGUnIHZhbHVlcyB1c2VkIGluIHJhZGlhbEFyY1xuICAgICAgICBzZWxmLnN0YXJ0QW5nbGUgPSBrby5jb21wdXRlZCh7XG4gICAgICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yYWRpYWxBcmMoKVswXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJjID0gc2VsZi5yYWRpYWxBcmMoKTtcbiAgICAgICAgICAgICAgICBhcmNbMF0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHNlbGYucmFkaWFsQXJjKGFyYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmZXJFdmFsdWF0aW9uOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmVuZEFuZ2xlID0ga28uY29tcHV0ZWQoe1xuICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmFkaWFsQXJjKClbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyYyA9IHNlbGYucmFkaWFsQXJjKCk7XG4gICAgICAgICAgICAgICAgYXJjWzFdID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJhZGlhbEFyYyhhcmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmVyRXZhbHVhdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdmFsaWRhdGlvbiBmb3IgZmllbGRzIHRoYXQgbmVlZCBpdFxuICAgICAgICBzZWxmLm1ldGFkYXRhLm5hbWUuZXh0ZW5kKHtyZXF1aXJlZDogdHJ1ZX0pO1xuXG4gICAgICAgIC8vIGNhcHR1cmUgaG90c3BvdCBhbmQgaGFuZGxlIGxvZ2ljP1xuICAgICAgICBzZWxmLmhvdHNwb3QgPSBkYXRhLmhvdHNwb3Q7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBJbGx1c3RyYXRlZFRyZWUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogSWxsdXN0cmF0ZWRUcmVlLFxuXG4gICAgICAgIHVzZUNob3NlbkxheW91dDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbiB0cmVlTGF5b3V0cykge1xuICAgICAgICAgICAgICAgIHNlbGYubGF5b3V0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUNob3NlbkxheW91dCgpOiBVbmtub3duIHRyZWUgbGF5b3V0ICdcIisgbmV3VmFsdWUgK1wiJyFcIik7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgIH1cbiAgICAgICAgLFxuICAgICAgICB1c2VDaG9zZW5UcmVlRGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwaWNrIHVwIGxhdGVzdCBkYXRhIGZyb20gYm91bmQgd2lkZ2V0c1xuICAgICAgICAgICAgdmFyICRjaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWNob29zZXInKTtcbiAgICAgICAgICAgIHZhciAkb3BlbnRyZWVJRHNQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1vcGVudHJlZWlkcy1wYW5lbCcpO1xuICAgICAgICAgICAgdmFyICRuZXhzb25VcmxQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1uZXhzb251cmwtcGFuZWwnKTtcbiAgICAgICAgICAgIHZhciAkZmlsZVVwbG9hZFBhbmVsID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLXVwbG9hZC1wYW5lbCcpO1xuICAgICAgICAgICAgdmFyICRmaWxlRm9ybWF0Q2hvb3NlciA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1mb3JtYXQnKTtcbiAgICAgICAgICAgIHZhciBjaG9zZW5Tb3VyY2UgPSAkY2hvb3Nlci52YWwoKTtcbiAgICAgICAgICAgIHN3aXRjaChjaG9zZW5Tb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvKiBNYXRjaCBhZ2FpbnN0IHN0cmluZ3MgZGVmaW5lZCBpbiBgc3R5bGlzdC5qc2AuIFdlJ2xsIHN0YXJ0XG4gICAgICAgICAgICAgICAgICogd2l0aCBzb21lIHNwZWNpYWwgY2FzZXMgdGhhdCBkcml2ZSBjaGFuZ2VzIHRvIHRoZSBVSS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgT3BlblRyZWUgc3R1ZHkgYW5kIHRyZWUgaWRzXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHVkeUlEID0gc2VsZi5tZXRhZGF0YS5zb3VyY2UucGh5bGVzeXN0ZW1TdHVkeUlEKCk7IFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZUlEID0gc2VsZi5tZXRhZGF0YS5zb3VyY2UucGh5bGVzeXN0ZW1UcmVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVOZXhzb25VUkwgPSAnaHR0cHM6Ly9hcGkub3BlbnRyZWVvZmxpZmUub3JnL3BoeWxlc3lzdGVtL3YxL3N0dWR5LydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBzdHVkeUlEICsnL3RyZWUvJysgdHJlZUlEICsnP291dHB1dF9uZXhtbDJqc29uPTEuMC4wJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoIHRyZWVOZXhzb25VUkwgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgVVJMIHRvIE5leFNPTiAxLjBcIjpcbiAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkbmV4c29uVXJsUGFuZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRvdGhlckZpZWxkID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLW5leHNvbnVybCcpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSggJC50cmltKCRvdGhlckZpZWxkLnZhbCgpKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlciBVUkwgdG8gYSBHaXRIdWIgZ2lzdFwiOlxuICAgICAgICAgICAgICAgICAgICAkb3BlbnRyZWVJRHNQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICRuZXhzb25VcmxQYW5lbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICRmaWxlVXBsb2FkUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1ldGFkYXRhLnNvdXJjZS50eXBlKGRhdGFTb3VyY2VUeXBlcy5VUkwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgJG90aGVyRmllbGQgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtbmV4c29udXJsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBVc2UgYW5vdGhlciBmaWVsZCBmb3IgR2lzdCBVUkxzP1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSggJC50cmltKCRvdGhlckZpZWxkLnZhbCgpKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlciBvciB1cGxvYWQgdHJlZSBkYXRhXCI6XG4gICAgICAgICAgICAgICAgLy9jYXNlIFwiVXBsb2FkIHRyZWUgZGF0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJOZXdpY2sgc3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIk5ld2ljayBzdHJpbmcgd2l0aCBleHRyYSBkYXRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIk5FWFVTXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIFwicGFzdGVkIHRleHRcIiBmaWVsZCBmb3IgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgdmFyICRwYXN0ZWRGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1wYXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgJHBhc3RlZEZpZWxkLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ2NvbG9yJywnI2FhYScpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLnNob3coKTtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goY2hvc2VuU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTmV3aWNrIHN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5ld2ljayBzdHJpbmcgd2l0aCBleHRyYSBkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZpbGVGb3JtYXRDaG9vc2VyLnZhbCgnbmV3aWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTkVYVVNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZmlsZUZvcm1hdENob29zZXIudmFsKCduZXh1cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTmVYTUwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmaWxlRm9ybWF0Q2hvb3Nlci52YWwoJ25leG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwaHlsbyAoUiBkYXRhIGZyYW1lKSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZpbGVGb3JtYXRDaG9vc2VyLnZhbCgncGh5bG8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGZpbGVGb3JtYXRDaG9vc2VyLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBIYW5kbGUgY29tbW9uIGNhc2VzIGZvciBsaXN0ZWQgdHJlZSBzb3VyY2VzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBleHBsaWNpdCBcImZldGNoXCIgVVJMcyBmb3IgZGF0YSBvbiB0aGUgd2ViXG4gICAgICAgICAgICAgICAgICAgICAqICAtIEp1cHl0ZXIga2VybmVsIHZhbHVlcyBmcm9tIGEgaG9zdGluZyBub3RlYm9va1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhlIG1hdGNoaW5nIFVSTCBhdCBhbnkgbGV2ZWwgb2YgdGhpcyB0cmVlIG9mICpvYnNlcnZhYmxlKiBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RMaXN0cyA9IFtzdHlsaXN0LmF2YWlsYWJsZVRyZWVzKCldO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goc3R5bGlzdC5hdmFpbGFibGVUcmVlcygpLCBmdW5jdGlvbihpLCB0ZXN0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdjaGlsZHJlbicgaW4gdGVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0TGlzdHMucHVzaCh0ZXN0SXRlbS5jaGlsZHJlbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCh0ZXN0TGlzdHMsIGZ1bmN0aW9uKGksIHRlc3RMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBU1NVTUVTIHVuaXF1ZSBkaXNwbGF5IHRleHQgZm9yIGFsbCBpdGVtcyBpbiBuZXN0ZWQgbGlzdCFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFRyZWVzID0gJC5ncmVwKHRlc3RMaXN0LCBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ubmFtZSgpID09PSBjaG9zZW5Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRyZWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlSW5mbyA9IHNlbGVjdGVkVHJlZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyZWVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyB0cmVlIGZvdW5kIHVuZGVyICdcIisgY2hvc2VuU291cmNlICtcIichXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndXJsJyBpbiB0cmVlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRmaWxlVXBsb2FkUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCB0cmVlSW5mby51cmwoKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdrZXJuZWwnIGluIHRyZWVJbmZvKSB7IC8vIG9yICdrZXJuZWwnPyAnbmJrZXJuZWwnP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoaXMgaXMgJ3B5dGhvbicgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgdGhlIGZvcm1hdCBjaG9vc2VyIHdoaWxlIHdlIHRyeSB0byBndWVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dEZvcm1hdENob29zZXIgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXRGb3JtYXRDaG9vc2VyLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIFwicGFzdGVkIHRleHRcIiBmaWVsZCAoZGlzcGxheSBvbmx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRwYXN0ZWRGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1wYXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwYXN0ZWRGaWVsZC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdjb2xvcicsJycpOyAvLyByZXN0b3JlIGRlZmF1bHQgdGV4dCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBGb3IgYSBtdWx0aS1rZXJuZWwgbm90ZWJvb2ssIGV4cGVjdCBhIHNwZWNpZmljIGtlcm5lbC1pZCwgZWcgJ3B5dGhvbjInXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmJWYXJOYW1lID0gdHJlZUluZm8ubmFtZSgpLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LnN0b3JhZ2VbIHN0b3JhZ2VCYWNrZW5kcy5KVVBZVEVSX05PVEVCT09LIF0uZ2V0VHJlZVNvdXJjZURhdGEobmJWYXJOYW1lLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2V0VHJlZVNvdXJjZURhdGEgcmV0dXJuaW5nIGZvciB0cmVlIFwiJysgdHJlZUluZm8ubmFtZSgpICsnXCIuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlU291cmNlRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRvIGludGVycHJldCB0aGlzIGFzIHRyZWUgc291cmNlIGRhdGEsIHdlJ2xsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZWVkIHRvIGZpZ3VyZSBvdXQgaXRzIGZvcm1hdC4gUGFzcyBpdCB0byBhIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXJpZXMgb2YgXCJzbmlmZmVyc1wiIHRvIGlkZW50aWZ5IE5ld2ljaywgTmV4c29uLCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBwdXNoIHRoaXMgc291cmNlIGludG8gcGVyc2lzdGVudCBzdG9yYWdlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy9zZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSh0cmVlU291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zvcm1hdCA9IG1vc3RMaWtlbHlEYXRhRm9ybWF0KHRyZWVTb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0Rm9ybWF0Q2hvb3Nlci52YWwobWF0Y2hpbmdGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IHNvbWV0aGluZyBmcmllbmRseSBpbiB0aGUgKGRpc2FibGVkKSB0ZXh0IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlU291cmNlQXNUZXh0ID0gKHR5cGVvZiB0cmVlU291cmNlRGF0YSA9PT0gJ3N0cmluZycpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVTb3VyY2VEYXRhIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRyZWVTb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHBhc3RlZEZpZWxkLnZhbCh0cmVlU291cmNlQXNUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gcmVzcG9uc2UuZXJyb3IgfHwgXCJObyBkYXRhIHJldHVybmVkICh1bnNwZWNpZmllZCBlcnJvcikhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0Rm9ybWF0Q2hvb3Nlci5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgdGhpcyBzdHJpbmcgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBzcGVjaWFsIGNhc2VzIGFib3ZlIVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gVVJMIG9yIGtlcm5lbCBmb3VuZCBmb3IgJ1wiKyBjaG9zZW5Tb3VyY2UgK1wiJyFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICB9XG4gICAgICAgICxcbiAgICAgICAgdXNlQ2hvc2VuTGFiZWxGaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwaWNrIHVwIGxhdGVzdCBkYXRhIGZyb20gYm91bmQgd2lkZ2V0c1xuICAgICAgICAgICAgdmFyICRjaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1sYWJlbGZpZWxkLWNob29zZXInKTtcbiAgICAgICAgICAgIHNlbGYubm9kZUxhYmVsVGV4dEZpZWxkID0gJGNob29zZXIudmFsKCk7XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgfVxuICAgICAgICAsXG4gICAgICAgIGNvbnZlcnRTb3VyY2VEYXRhVG9OZXhzb246IGZ1bmN0aW9uKHRyZWVJRCwgc3JjVGV4dCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwYXN0ZWQvdXBsb2FkZWQgc291cmNlIGRhdGEgdG8gbmV4c29uLCB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGNvbnZlcnNpb24gbWV0aG9kcyBpbiB0aGUgbWFpbiBvcGVuIHRyZWUgY3VyYXRpb24gdG9vbC4gIFxuICAgICAgICAgICAgLy8gTi5CLiBUaGlzIGlzIHVzZWQgZm9yIG5ld2x5IHBhc3RlZC91cGxvYWRlZCB0ZXh0IGFzIHdlbGwgYXMgZm9yXG4gICAgICAgICAgICAvLyBzb3VyY2UgZGF0YSBsb2FkZWQgZnJvbSBhbiBleGlzdGluZyBpbGx1c3RyYXRpb24uXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7ICAvLyB0aGUgdHJlZSBpbiBxdWVzdGlvblxuXG4gICAgICAgIH1cbiAgICAgICAgLFxuICAgICAgICBjb252ZXJ0UGFzdGVkRGF0YVRvVHJlZTogZnVuY3Rpb24odHJlZUlEKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gY29udmVydCBwYXN0ZWQvdXBsb2FkZWQgdGV4dCB0byBuZXhzb24sIHVzaW5nIHRoZSBjb252ZXJzaW9uXG4gICAgICAgICAgICAvLyBtZXRob2RzIGluIHRoZSBtYWluIG9wZW4gdHJlZSBjdXJhdGlvbiB0b29sLlxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAgLy8gdGhlIHRyZWUgaW4gcXVlc3Rpb25cbiAgICAgICAgICAgIHZhciAkcGFzdGVkRmllbGQgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtcGFzdGVkJyk7XG4gICAgICAgICAgICB2YXIgcGFzdGVkVGV4dCA9ICQudHJpbSgkcGFzdGVkRmllbGQudmFsKCkpO1xuICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoXCJQbGVhc2UgcGFzdGUgTmV3aWNrIG9yIG90aGVyIHRleHQgaW50byB0aGUgdGV4dCBhcmVhIHByb3ZpZGVkLCB0aGVuIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2xlYXIgYW55IGNhY2hlZCBhbmQgaW50ZXJuYWwgdmFsdWVzIHJlZ2FyZGxlc3MsIHRvIGhpZGUgYW4gb2xkIHRyZWU/XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jb252ZXJ0U291cmNlRGF0YVRvTmV4c29uKHRyZWVJRCwgcGFzdGVkVGV4dCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCBwYXN0ZWRUZXh0ICk7XG4gICAgICAgICAgICBzZWxmLm1ldGFkYXRhLnNvdXJjZS50eXBlKGRhdGFTb3VyY2VUeXBlcy5VUExPQUQpO1xuICAgICAgICAgICAgLy92YXIgdHJlZVNvdXJjZUNhY2hlS2V5ID0gKCdQQVNURUQtU09VUkNFLScgKyAkLnRyaW0oc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoKSkpO1xuICAgICAgICAgICAgdmFyIHRyZWVTb3VyY2VDYWNoZUtleSA9ICgnaW5wdXQvUEFTVEVELVRSRUUtJyArICQudHJpbShzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSgpKSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJy4uLmNvbnZlcnRpbmcgcGFzdGVkIGRhdGEgdG8gdHJlZS4uLicpO1xuICAgICAgICAgICAgLy8gVE9ETzogYnVpbGQgdXAgY2FjaGUga2V5IHdpdGggZm9ybWF0ICsgY29udGVudD9cbiAgICAgICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldENhY2hlZERhdGEoIHRyZWVTb3VyY2VDYWNoZUtleSApO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTi5CLiBUaGlzIGRhdGEgd2lsbCBiZSBzYWZlbHkgY2xvbmVkIGJ5IFZlZ2Egd2hlbiBzcGVjIGlzIHBhcnNlZCFcbiAgICAgICAgICAgICAgICAvLyBOT1RFIHRoYXQgd2Ugc2hvdWxkIHN0aWxsIHJlZnJlc2ggaW1tZWRpYXRlbHksIGluIGNhc2UgdGhlIGNhY2hlZCB0cmVlIGRhdGEgd2FzIGxvYWRlZFxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZWQgZm9yIGFub3RoZXIgdHJlZSwgb3IgYW4gZWFybGllciB2ZXJzaW9uIG9mIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgIHNlbGYubm9kZUxhYmVsRmllbGQoJ2V4cGxpY2l0TGFiZWwnKTtcbiAgICAgICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvcGVudHJlZSB3ZWIgc2VydmljZXMgdG8gY29udmVydCB0byBuZXhzb25cbiAgICAgICAgICAgICAgICAvL1RPRE86IEFwcGx5IG90aGVyIHBhc3RlZCBmb3JtYXRzIChhbmQgUkVNRU1CRVIgVEhFTSBpbiB0aGUgc2F2ZWQgaWxsdXN0cmF0aW9uISlcbiAgICAgICAgICAgICAgICB2YXIgJGlucHV0Rm9ybWF0Q2hvb3NlciA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1mb3JtYXQnKTtcbiAgICAgICAgICAgICAgICAvLyRpbnB1dEZvcm1hdENob29zZXIuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRGb3JtYXQgPSAkaW5wdXRGb3JtYXRDaG9vc2VyLnZhbCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dEZvcm1hdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJQbGVhc2UgY2hvb3NlIHRoZSBmb3JtYXQgb2YgdGhpcyB0cmVlIGRhdGEsIHRoZW4gdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyb3NzRG9tYWluOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGV2dHJlZS5vcGVudHJlZW9mbGlmZS5vcmcvY3VyYXRvci90b19uZXhzb24nLFxuICAgICAgICAgICAgICAgICAgICAvKiBOT1RFIHRoYXQgaWRQcmVmaXggYW5kIGZpcnN0QXZhaWxhYmxlKklEIGFyZ3MgYXJlXG4gICAgICAgICAgICAgICAgICAgICAqIGN1cnJlbnRseSByZXF1aXJlZCB0byBnZXQgd2VsbC1mb3JtZWQgTmV4c29uIVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKCd7XCJvdXRwdXRcIjogXCJvdDpuZXhzb25cIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJhdXRoX3Rva2VuXCI6IFwiQU5PTllNT1VTXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiaWRQcmVmaXhcIjogXCJcIiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVFZGdlSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVOb2RlSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVPVFVJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZU9UVXNJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZVRyZWVJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZVRyZWVzSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVBbm5vdGF0aW9uSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVBZ2VudElEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlTWVzc2FnZUlEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImlucHV0Rm9ybWF0XCI6ICcrIEpTT04uc3RyaW5naWZ5KGlucHV0Rm9ybWF0KSArJywgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJjb250ZW50XCI6ICcrIEpTT04uc3RyaW5naWZ5KCQudHJpbShzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSgpKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB9JyksXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCBqcVhIUiwgdGV4dFN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBlcnJvcnMgb3IgbWFsZm9ybWVkIGRhdGEsIGlmIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMgIT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqcVhIUi5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ham9yIHNlcnZlci1zaWRlIGVycm9yLCBqdXN0IHNob3cgcmF3IHJlc3BvbnNlIGZvciB0ZWNoIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yICgnKyBqcVhIUi5zdGF0dXMgKycpIGNvbnZlcnRpbmcgdGhpcyB0cmVlIHRvIE5leHNvbjpcXG5cXG4nKyBqcVhIUi5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VydmVyIGJsb2NrZWQgdGhlIHNhdmUgZHVlIHRvIG1ham9yIHZhbGlkYXRpb24gZXJyb3JzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJC5wYXJzZUpTT04oanFYSFIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBwcm9wZXJseSBwYXJzZWQgSlNPTiwgc2hvdyBpdCBtb3JlIHNlbnNpYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGJ1dCBmb3Igbm93LCByZXBlYXQgdGhlIGNydWRlIGZlZWRiYWNrIHVzZWQgYWJvdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yICgnKyBqcVhIUi5zdGF0dXMgKycpIGNvbnZlcnRpbmcgdGhpcyB0cmVlIHRvIE5leHNvbjpcXG5cXG4nKyBqcVhIUi5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXN0ZWQgdHJlZSB3YXMgY29udmVydGVkIHN1Y2Nlc3NmdWxseTsgY2FwdHVyZSB0aGUgTmV4c29uIGFzIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICQucGFyc2VKU09OKGpxWEhSLnJlc3BvbnNlVGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeCBhbnkgcXVpcmtzIHRvIGNvbmZvcm0gdG8gb3VyIGV4cGVjdGVkIE5leHNvbiBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeFVwQ29udmVydGVkTmV4c29uKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBpdCBpbiB0aGUgY2FjaGUsIGF0IHRoZSBrZXkgZGVmaW5lZCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcuLi5zdG9yaW5nIHBhc3RlZCBkYXRhIGluIGNhY2hlLi4uIGtleT0nKyB0cmVlU291cmNlQ2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2FjaGVkRGF0YSggdHJlZVNvdXJjZUNhY2hlS2V5LCBkYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBub2RlLWxhYmVsIGZpZWxkIHRvIHNob3cgXCJleHBsaWNpdFwiIGxhYmVscyAoVE9ETzogZm9yIE5ld2ljayBvbmx5PylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubm9kZUxhYmVsRmllbGQoJ2V4cGxpY2l0TGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLFxuICAgICAgICB1c2VDaG9zZW5UaXBzQWxpZ25tZW50OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIGluIGFsaWdubWVudHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpcHNBbGlnbm1lbnQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlQ2hvc2VuVGlwc0FsaWdubWVudCgpOiBVbmtub3duIHRpcHMgYWxpZ25tZW50ICdcIisgbmV3VmFsdWUgK1wiJyFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgfVxuICAgICAgICAsXG4gICAgICAgIHVzZUNob3NlblJhZGlhbFN3ZWVwOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIGluIHN3ZWVwRGlyZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHNlbGYucmFkaWFsU3dlZXAobmV3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlQ2hvc2VuUmFkaWFsU3dlZXAoKTogVW5rbm93biBzd2VlcCBkaXJlY3Rpb24gJ1wiKyBuZXdWYWx1ZSArXCInIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBTdXBwb3J0aW5nRGF0YXNldCA9IGZ1bmN0aW9uKGlsbHVzdHJhdGlvbiwgZGF0YSkge1xuICAgICAgICBpZiAoICEodGhpcyBpbnN0YW5jZW9mIFN1cHBvcnRpbmdEYXRhc2V0KSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1JU1NJTkcgJ25ldycga2V5d29yZCwgcGF0Y2hpbmcgdGhpcyBub3dcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1cHBvcnRpbmdEYXRhc2V0KGlsbHVzdHJhdGlvbiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEgfHwgdHlwZW9mKGRhdGEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gbG9hZCB0aGUgXCJlbXB0eVwiIGRhdGFzZXQgb2JqZWN0IGFib3ZlXG4gICAgICAgICAgICBkYXRhID0gZ2V0TmV3U3VwcG9ydGluZ0RhdGFzZXRNb2RlbChpbGx1c3RyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2FmZWx5IHJlZmVyIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBrby5tYXBwaW5nLmZyb21KUyhkYXRhLCBJbGx1c3RyYXRpb24ubWFwcGluZ09wdGlvbnMsIHNlbGYpO1xuXG4gICAgICAgIC8vIFRPRE86IEJhc2VkIG9uIHRoZSBlbGVtZW50IHR5cGUsIG9mZmVyIGFwcHJvcHJpYXRlIHN0eWxlcyBhbmQgY29uc3RyYWludHNcbiAgICAgICAgLy8gVE9ETzogSW5jbHVkZSBvcHRpb25zIHRvIG1hcCBzZWxlY3RlZCBkYXRhIHRvIHZpc3VhbCBzdHlsZVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgU3VwcG9ydGluZ0RhdGFzZXQucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogU3VwcG9ydGluZ0RhdGFzZXQsXG5cbiAgICAgICAgdXNlQ2hvc2VuRGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwaWNrIHVwIGxhdGVzdCBkYXRhIGZyb20gYm91bmQgd2lkZ2V0c1xuICAgICAgICAgICAgdmFyICRjaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWNob29zZXInKTtcbiAgICAgICAgICAgIHZhciAkb3BlbnRyZWVJRHNQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1vcGVudHJlZWlkcy1wYW5lbCcpO1xuICAgICAgICAgICAgdmFyICRuZXhzb25VcmxQYW5lbCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1uZXhzb251cmwtcGFuZWwnKTtcbiAgICAgICAgICAgIHZhciAkZmlsZVVwbG9hZFBhbmVsID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLXVwbG9hZC1wYW5lbCcpO1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGVzZSB3aXRoIGFwcHJvcHJpYXRlIHBhbmVscyE/XG4gICAgICAgICAgICB2YXIgY2hvc2VuU291cmNlID0gJGNob29zZXIudmFsKCk7XG4gICAgICAgICAgICBzd2l0Y2goY2hvc2VuU291cmNlKSB7XG4gICAgICAgICAgICAgICAgLyogTWF0Y2ggYWdhaW5zdCBzdHJpbmdzIGRlZmluZWQgaW4gYHN0eWxpc3QuanNgLiBXZSdsbCBzdGFydFxuICAgICAgICAgICAgICAgICAqIHdpdGggc29tZSBzcGVjaWFsIGNhc2VzIHRoYXQgZHJpdmUgY2hhbmdlcyB0byB0aGUgVUkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgT3BlblRyZWUgc3R1ZHkgYW5kIHRyZWUgaWRzXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHVkeUlEID0gc2VsZi5tZXRhZGF0YS5zb3VyY2UucGh5bGVzeXN0ZW1TdHVkeUlEKCk7IFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZUlEID0gc2VsZi5tZXRhZGF0YS5zb3VyY2UucGh5bGVzeXN0ZW1UcmVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVOZXhzb25VUkwgPSAnaHR0cHM6Ly9hcGkub3BlbnRyZWVvZmxpZmUub3JnL3BoeWxlc3lzdGVtL3YxL3N0dWR5LydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBzdHVkeUlEICsnL3RyZWUvJysgdHJlZUlEICsnP291dHB1dF9uZXhtbDJqc29uPTEuMC4wJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoIHRyZWVOZXhzb25VUkwgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlciBVUkwgdG8gZGF0YSBmaWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHNvblVybFBhbmVsLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkb3RoZXJGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1uZXhzb251cmwnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoICQudHJpbSgkb3RoZXJGaWVsZC52YWwoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgVVJMIHRvIGEgR2l0SHViIGdpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgJG9wZW50cmVlSURzUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkbmV4c29uVXJsUGFuZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudHlwZShkYXRhU291cmNlVHlwZXMuVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRvdGhlckZpZWxkID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLW5leHNvbnVybCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVXNlIGFub3RoZXIgZmllbGQgZm9yIEdpc3QgVVJMcz9cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoICQudHJpbSgkb3RoZXJGaWVsZC52YWwoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXIgb3IgdXBsb2FkIGRhdGFcIjpcbiAgICAgICAgICAgICAgICAvL2Nhc2UgXCJOZXdpY2sgc3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgLy9jYXNlIFwiTmV3aWNrIHN0cmluZyB3aXRoIGV4dHJhIGRhdGFcIjpcbiAgICAgICAgICAgICAgICAvL2Nhc2UgXCJORVhVU1wiOlxuICAgICAgICAgICAgICAgICAgICAkb3BlbnRyZWVJRHNQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICRuZXhzb25VcmxQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBcInBhc3RlZCB0ZXh0XCIgZmllbGQgZm9yIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHZhciAkcGFzdGVkRmllbGQgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtcGFzdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICRwYXN0ZWRGaWVsZC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdjb2xvcicsJyNhYWEnKTtcbiAgICAgICAgICAgICAgICAgICAgJGZpbGVVcGxvYWRQYW5lbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogSGFuZGxlIGNvbW1vbiBjYXNlcyBmb3IgbGlzdGVkIHRyZWUgc291cmNlczpcbiAgICAgICAgICAgICAgICAgICAgICogIC0gZXhwbGljaXQgXCJmZXRjaFwiIFVSTHMgZm9yIGRhdGEgb24gdGhlIHdlYlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBKdXB5dGVyIGtlcm5lbCB2YWx1ZXMgZnJvbSBhIGhvc3Rpbmcgbm90ZWJvb2tcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIHRoZSBtYXRjaGluZyBVUkwgYXQgYW55IGxldmVsIG9mIHRoaXMgdHJlZSBvZiAqb2JzZXJ2YWJsZSogYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0TGlzdHMgPSBbc3R5bGlzdC5hdmFpbGFibGVUcmVlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHN0eWxpc3QuYXZhaWxhYmxlVHJlZXMoKSwgZnVuY3Rpb24oaSwgdGVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRyZW4nIGluIHRlc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExpc3RzLnB1c2godGVzdEl0ZW0uY2hpbGRyZW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZUluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2godGVzdExpc3RzLCBmdW5jdGlvbihpLCB0ZXN0TGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVNTVU1FUyB1bmlxdWUgZGlzcGxheSB0ZXh0IGZvciBhbGwgaXRlbXMgaW4gbmVzdGVkIGxpc3QhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRUcmVlcyA9ICQuZ3JlcCh0ZXN0TGlzdCwgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLm5hbWUoKSA9PT0gY2hvc2VuU291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRUcmVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZUluZm8gPSBzZWxlY3RlZFRyZWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmVlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBmb3VuZCB1bmRlciAnXCIrIGNob3NlblNvdXJjZSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3VybCcgaW4gdHJlZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRuZXhzb25VcmxQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZmlsZVVwbG9hZFBhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSggdHJlZUluZm8udXJsKCkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgna2VybmVsJyBpbiB0cmVlSW5mbykgeyAvLyBvciAna2VybmVsJz8gJ25ia2VybmVsJz9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGlzIGlzICdweXRob24nIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICRvcGVudHJlZUlEc1BhbmVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRuZXhzb25VcmxQYW5lbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBmb3JtYXQgY2hvb3NlciB3aGlsZSB3ZSB0cnkgdG8gZ3Vlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXRGb3JtYXRDaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWZvcm1hdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0Rm9ybWF0Q2hvb3Nlci5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBcInBhc3RlZCB0ZXh0XCIgZmllbGQgKGRpc3BsYXkgb25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkcGFzdGVkRmllbGQgPSAkKCcjJysgc2VsZi5pZCgpICsnLWRhdGFzb3VyY2UtcGFzdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcGFzdGVkRmllbGQuYXR0cignZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnY29sb3InLCcnKTsgLy8gcmVzdG9yZSBkZWZhdWx0IHRleHQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICRmaWxlVXBsb2FkUGFuZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRm9yIGEgbXVsdGkta2VybmVsIG5vdGVib29rLCBleHBlY3QgYSBzcGVjaWZpYyBrZXJuZWwtaWQsIGVnICdweXRob24yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5iVmFyTmFtZSA9IHRyZWVJbmZvLm5hbWUoKS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5zdG9yYWdlWyBzdG9yYWdlQmFja2VuZHMuSlVQWVRFUl9OT1RFQk9PSyBdLmdldFRyZWVTb3VyY2VEYXRhKG5iVmFyTmFtZSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dldFRyZWVTb3VyY2VEYXRhIHJldHVybmluZyBmb3IgdHJlZSBcIicrIHRyZWVJbmZvLm5hbWUoKSArJ1wiLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdkYXRhJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZVNvdXJjZURhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUbyBpbnRlcnByZXQgdGhpcyBhcyB0cmVlIHNvdXJjZSBkYXRhLCB3ZSdsbCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmVlZCB0byBmaWd1cmUgb3V0IGl0cyBmb3JtYXQuIFBhc3MgaXQgdG8gYSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2VyaWVzIG9mIFwic25pZmZlcnNcIiB0byBpZGVudGlmeSBOZXdpY2ssIE5leHNvbiwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcHVzaCB0aGlzIHNvdXJjZSBpbnRvIHBlcnNpc3RlbnQgc3RvcmFnZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUodHJlZVNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdGb3JtYXQgPSBtb3N0TGlrZWx5RGF0YUZvcm1hdCh0cmVlU291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dEZvcm1hdENob29zZXIudmFsKG1hdGNoaW5nRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyBzb21ldGhpbmcgZnJpZW5kbHkgaW4gdGhlIChkaXNhYmxlZCkgdGV4dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZVNvdXJjZUFzVGV4dCA9ICh0eXBlb2YgdHJlZVNvdXJjZURhdGEgPT09ICdzdHJpbmcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlU291cmNlRGF0YSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0cmVlU291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRwYXN0ZWRGaWVsZC52YWwodHJlZVNvdXJjZUFzVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dEZvcm1hdENob29zZXIuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoaXMgc3RyaW5nIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgc3BlY2lhbCBjYXNlcyBhYm92ZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIFVSTCBvciBrZXJuZWwgZm91bmQgZm9yICdcIisgY2hvc2VuU291cmNlICtcIichXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsaXN0LnJlZnJlc2hWaXooKTtcbiAgICAgICAgfVxuICAgICAgICAsXG4gICAgICAgIGNhcHR1cmVQYXN0ZWREYXRhOiBmdW5jdGlvbihkYXRhc2V0SUQpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBjb252ZXJ0IHBhc3RlZC91cGxvYWRlZCB0ZXh0IHRvIG5leHNvbiwgdXNpbmcgdGhlIGNvbnZlcnNpb25cbiAgICAgICAgICAgIC8vIG1ldGhvZHMgaW4gdGhlIG1haW4gb3BlbiB0cmVlIGN1cmF0aW9uIHRvb2wuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7ICAvLyB0aGUgdHJlZSBpbiBxdWVzdGlvblxuICAgICAgICAgICAgdmFyICRwYXN0ZWRGaWVsZCA9ICQoJyMnKyBzZWxmLmlkKCkgKyctZGF0YXNvdXJjZS1wYXN0ZWQnKTtcbiAgICAgICAgICAgIHZhciBwYXN0ZWRUZXh0ID0gJC50cmltKCRwYXN0ZWRGaWVsZC52YWwoKSk7XG4gICAgICAgICAgICBpZiAocGFzdGVkVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBwYXN0ZSBOZXdpY2sgb3Igb3RoZXIgdGV4dCBpbnRvIHRoZSB0ZXh0IGFyZWEgcHJvdmlkZWQsIHRoZW4gdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjbGVhciBhbnkgY2FjaGVkIGFuZCBpbnRlcm5hbCB2YWx1ZXMgcmVnYXJkbGVzcywgdG8gaGlkZSBhbiBvbGQgdHJlZT9cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmNvbnZlcnRTb3VyY2VEYXRhVG9OZXhzb24oZGF0YXNldElELCBwYXN0ZWRUZXh0KTtcblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgc2VsZi5tZXRhZGF0YS5zb3VyY2UudmFsdWUoIHBhc3RlZFRleHQgKTtcbiAgICAgICAgICAgIHNlbGYubWV0YWRhdGEuc291cmNlLnR5cGUoZGF0YVNvdXJjZVR5cGVzLlVQTE9BRCk7XG4gICAgICAgICAgICAvL3ZhciB0cmVlU291cmNlQ2FjaGVLZXkgPSAoJ1BBU1RFRC1TT1VSQ0UtJyArICQudHJpbShzZWxmLm1ldGFkYXRhLnNvdXJjZS52YWx1ZSgpKSk7XG4gICAgICAgICAgICB2YXIgdHJlZVNvdXJjZUNhY2hlS2V5ID0gKCdpbnB1dC9QQVNURUQtVFJFRS0nICsgJC50cmltKHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCkpKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignLi4uY29udmVydGluZyBwYXN0ZWQgZGF0YSB0byB0cmVlLi4uJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBidWlsZCB1cCBjYWNoZSBrZXkgd2l0aCBmb3JtYXQgKyBjb250ZW50P1xuICAgICAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0Q2FjaGVkRGF0YSggdHJlZVNvdXJjZUNhY2hlS2V5ICk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBOLkIuIFRoaXMgZGF0YSB3aWxsIGJlIHNhZmVseSBjbG9uZWQgYnkgVmVnYSB3aGVuIHNwZWMgaXMgcGFyc2VkIVxuICAgICAgICAgICAgICAgIC8vIE5PVEUgdGhhdCB3ZSBzaG91bGQgc3RpbGwgcmVmcmVzaCBpbW1lZGlhdGVseSwgaW4gY2FzZSB0aGUgY2FjaGVkIHRyZWUgZGF0YSB3YXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlZCBmb3IgYW5vdGhlciB0cmVlLCBvciBhbiBlYXJsaWVyIHZlcnNpb24gb2YgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgc2VsZi5ub2RlTGFiZWxGaWVsZCgnZXhwbGljaXRMYWJlbCcpO1xuICAgICAgICAgICAgICAgIHN0eWxpc3QucmVmcmVzaFZpeigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9wZW50cmVlIHdlYiBzZXJ2aWNlcyB0byBjb252ZXJ0IHRvIG5leHNvblxuICAgICAgICAgICAgICAgIC8vVE9ETzogQXBwbHkgb3RoZXIgcGFzdGVkIGZvcm1hdHMgKGFuZCBSRU1FTUJFUiBUSEVNIGluIHRoZSBzYXZlZCBpbGx1c3RyYXRpb24hKVxuICAgICAgICAgICAgICAgIHZhciAkaW5wdXRGb3JtYXRDaG9vc2VyID0gJCgnIycrIHNlbGYuaWQoKSArJy1kYXRhc291cmNlLWZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIC8vJGlucHV0Rm9ybWF0Q2hvb3Nlci5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dEZvcm1hdCA9ICRpbnB1dEZvcm1hdENob29zZXIudmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Rm9ybWF0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBjaG9vc2UgdGhlIGZvcm1hdCBvZiB0aGlzIHRyZWUgZGF0YSwgdGhlbiB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gY3Jvc3NEb21haW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9kZXZ0cmVlLm9wZW50cmVlb2ZsaWZlLm9yZy9jdXJhdG9yL3RvX25leHNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8qIE5PVEUgdGhhdCBpZFByZWZpeCBhbmQgZmlyc3RBdmFpbGFibGUqSUQgYXJncyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICogY3VycmVudGx5IHJlcXVpcmVkIHRvIGdldCB3ZWxsLWZvcm1lZCBOZXhzb24hXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoJ3tcIm91dHB1dFwiOiBcIm90Om5leHNvblwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImF1dGhfdG9rZW5cIjogXCJBTk9OWU1PVVNcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJpZFByZWZpeFwiOiBcIlwiLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUVkZ2VJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZU5vZGVJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZU9UVUlEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlT1RVc0lEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlVHJlZUlEXCI6IFwiMVwiLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImZpcnN0QXZhaWxhYmxlVHJlZXNJRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUFubm90YXRpb25JRFwiOiBcIjFcIiwgJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJmaXJzdEF2YWlsYWJsZUFnZW50SURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiZmlyc3RBdmFpbGFibGVNZXNzYWdlSURcIjogXCIxXCIsICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiaW5wdXRGb3JtYXRcIjogJysgSlNPTi5zdHJpbmdpZnkoaW5wdXRGb3JtYXQpICsnLCAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImNvbnRlbnRcIjogJysgSlNPTi5zdHJpbmdpZnkoJC50cmltKHNlbGYubWV0YWRhdGEuc291cmNlLnZhbHVlKCkpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnIH0nKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IGVycm9ycyBvciBtYWxmb3JtZWQgZGF0YSwgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFqb3Igc2VydmVyLXNpZGUgZXJyb3IsIGp1c3Qgc2hvdyByYXcgcmVzcG9uc2UgZm9yIHRlY2ggc3VwcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgKCcrIGpxWEhSLnN0YXR1cyArJykgY29udmVydGluZyB0aGlzIHRyZWUgdG8gTmV4c29uOlxcblxcbicrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgYmxvY2tlZCB0aGUgc2F2ZSBkdWUgdG8gbWFqb3IgdmFsaWRhdGlvbiBlcnJvcnMhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLnBhcnNlSlNPTihqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHByb3Blcmx5IHBhcnNlZCBKU09OLCBzaG93IGl0IG1vcmUgc2Vuc2libHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoYnV0IGZvciBub3csIHJlcGVhdCB0aGUgY3J1ZGUgZmVlZGJhY2sgdXNlZCBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgKCcrIGpxWEhSLnN0YXR1cyArJykgY29udmVydGluZyB0aGlzIHRyZWUgdG8gTmV4c29uOlxcblxcbicrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3RlZCB0cmVlIHdhcyBjb252ZXJ0ZWQgc3VjY2Vzc2Z1bGx5OyBjYXB0dXJlIHRoZSBOZXhzb24gYXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJC5wYXJzZUpTT04oanFYSFIucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4IGFueSBxdWlya3MgdG8gY29uZm9ybSB0byBvdXIgZXhwZWN0ZWQgTmV4c29uIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZml4VXBDb252ZXJ0ZWROZXhzb24oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGl0IGluIHRoZSBjYWNoZSwgYXQgdGhlIGtleSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJy4uLnN0b3JpbmcgcGFzdGVkIGRhdGEgaW4gY2FjaGUuLi4ga2V5PScrIHRyZWVTb3VyY2VDYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDYWNoZWREYXRhKCB0cmVlU291cmNlQ2FjaGVLZXksIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIG5vZGUtbGFiZWwgZmllbGQgdG8gc2hvdyBcImV4cGxpY2l0XCIgbGFiZWxzIChUT0RPOiBmb3IgTmV3aWNrIG9ubHk/KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ub2RlTGFiZWxGaWVsZCgnZXhwbGljaXRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5yZWZyZXNoVml6KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgT3JuYW1lbnQgPSBmdW5jdGlvbihpbGx1c3RyYXRpb24sIGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBPcm5hbWVudCkgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNSVNTSU5HICduZXcnIGtleXdvcmQsIHBhdGNoaW5nIHRoaXMgbm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcm5hbWVudChpbGx1c3RyYXRpb24sIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZihkYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgdGhlIFwiZW1wdHlcIiBvcm5hbWVudCBvYmplY3QgYWJvdmVcbiAgICAgICAgICAgIGRhdGEgPSBnZXROZXdPcm5hbWVudE1vZGVsKGlsbHVzdHJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIElsbHVzdHJhdGlvbi5tYXBwaW5nT3B0aW9ucywgc2VsZik7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuXG4gICAgLyogV2UgbmVlZCB0byBiZSBhYmxlIHRvIGRlZmluZSBjdXN0b20gc3R5bGVzIGZvciBtYW55IGRpZmZlcmVudCBlbGVtZW50cyBvZlxuICAgICAqIHRoZSBzY2VuZSBncmFwaCwgZS5nLiwgYSB0cmVlLCBub2RlLCBvciBjYXB0aW9uLlxuICAgICAqL1xuICAgIHZhciBTdHlsZU92ZXJyaWRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZU92ZXJyaWRlcykgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNSVNTSU5HICduZXcnIGtleXdvcmQsIHBhdGNoaW5nIHRoaXMgbm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZU92ZXJyaWRlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYWZlbHkgcmVmZXIgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gVE9ETzogQmFzZWQgb24gdGhlIGVsZW1lbnQgdHlwZSwgb2ZmZXIgYXBwcm9wcmlhdGUgc3R5bGVzIGFuZCBjb25zdHJhaW50c1xuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIG9wdGlvbnMgdG8gbWFwIHNlbGVjdGVkIGRhdGEgdG8gdmlzdWFsIHN0eWxlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8qIFdlJ2xsIG9mdGVuIHdhbnQgdG8gc2hvdyB2YWx1ZXMgdXNpbmcgdGhlIGNob3NlbiBwaHlzaWNhbCB1bml0cyAoaW5jaGVzXG4gICAgICogb3IgY20pLCBidXQgc3RvcmUgdGhlbSBhcyBpbnRlcm5hbCBTVkcgcGl4ZWxzLiBUaGlzIG1ha2VzIGl0IGVhc3kgdG9cbiAgICAgKiBkZWNsYXJlIHRoZXNlIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMsIGVnLCB3cmFwIHdpZHRoID0+ICdwaHlzaWNhbFdpZHRoJ1xuICAgICAqL1xuICAgIHZhciB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyA9IGZ1bmN0aW9uKG9iaiwgZmllbGROYW1lLCBwcmVjaXNpb24pIHtcbiAgICAgICAgLy8gRGlzcGxheSB1c2luZyBzZWxlY3RlZCBwcmVjaXNpb24gKG51bWJlciBvZiBwbGFjZXMpLCB3aXRoIGh1bmRyZWR0aHMgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gRVhBTVBMRTogc2VsZi5waHlzaWNhbFdpZHRoID0gd3JhcEZpZWxkV2l0aFBoeXNpY2FsVW5pdHMoc2VsZiwgJ3dpZHRoJyk7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAyO1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoe1xuICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBoeXNpY2FsVmFsdWUgPSBzdHlsaXN0LnBpeGVsc1RvUGh5c2ljYWxVbml0cyhvYmpbIGZpZWxkTmFtZSBdKCksIHN0eWxpc3QuaW50ZXJuYWxfcHBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKE1hdGgucm91bmQocGh5c2ljYWxWYWx1ZSArIFwiZStcIiArIHByZWNpc2lvbikgKyBcImUtXCIgKyBwcmVjaXNpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG9ialsgZmllbGROYW1lIF0oIHN0eWxpc3QucGh5c2ljYWxVbml0c1RvUGl4ZWxzKHZhbHVlLCBzdHlsaXN0LmludGVybmFsX3BwaSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bmVyOiBvYmosXG4gICAgICAgICAgICBkZWZlckV2YWx1YXRpb246IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKiBBcHBseSBoYXJkIGNvbnN0cmFpbnRzIHRvIHByb3Bvc2VkIHZhbHVlcy4gVGhlc2UgbWlnaHQgYmUgdW5pdmVyc2FsXG4gICAgICogdmFsdWVzIChlLmcuIG1pbmltdW0gbGVnaWJsZSB0ZXh0IGhlaWdodCA9IDVweCksIG9yIHNldCB3aXRoaW4gYW4gYWN0aXZlXG4gICAgICogc3R5bGUgZ3VpZGUgKGUuZy4sIGZpZ3VyZXMgaW4gX1N5c3RlbWF0aWMgQmlvbG9neV8gbXVzdCB1c2UgZm9udCBzaXplc1xuICAgICAqIGZyb20gMTBweCB0byA2NHB4KS5cbiAgICAgKlxuICAgICAqIE5PVEUgdGhhdCB0aGVzZSB3cmFwcGVycyBjYW4gYmUgbmVzdGVkIGxpa2Ugc287XG4gICAgICogICBzZWxmLmNvbnN0cmFpbmVkV2lkdGggPSB3cmFwRmllbGRXaXRoQ29uc3RyYWludHMoc2VsZiwgJ3dpZHRoJyk7XG4gICAgICogICBzZWxmLnBoeXNpY2FsV2lkdGggPSB3cmFwRmllbGRXaXRoUGh5c2ljYWxVbml0cyhzZWxmLCAnY29uc3RyYWluZWRXaWR0aCcpO1xuICAgICAqIFRoaXMgbGV0cyB1cyBnZXQvc2V0IHdpdGggY29uc3RyYWludHMsIHVzaW5nIGVpdGhlciBweCBvciBwaHlzaWNhbCB1bml0cy5cbiAgICAgKi9cbiAgICB2YXIgd3JhcEZpZWxkV2l0aENvbnN0cmFpbnRzID0gZnVuY3Rpb24ob2JqLCBmaWVsZE5hbWUsIGNvbnN0cmFpbnRzLCBwcmVjaXNpb24pIHtcbiAgICAgICAgLy8gRGlzcGxheSB1c2luZyBzZWxlY3RlZCBwcmVjaXNpb24gKG51bWJlciBvZiBwbGFjZXMpLCB3aXRoIGh1bmRyZWR0aHMgYnkgZGVmYXVsdC5cbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDI7XG4gICAgICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ3cmFwRmllbGRXaXRoQ29uc3RyYWludHMoKSBleHBlY3RzIGEgY29uc3RyYWludHMgb2JqZWN0IVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGtvLmNvbXB1dGVkKHtcbiAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGVyZSwganVzdCBjYWxsIHRoZSB3cmFwcGVkIGZpZWxkXG4gICAgICAgICAgICAgICAgLy8vY29uc29sZS5sb2coXCJSRUFESU5HIGZyb20gY29uc3RyYWluZWQgJ1wiKyBmaWVsZE5hbWUgK1wiJyFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialsgZmllbGROYW1lIF0oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcnByZXQgYW5kIGFwcGx5IHRoZSBzcGVjaWZpZWQgY29uc3RyYWludHMsIHBlcmhhcHMgc2lnbmFsaW5nXG4gICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGUgcHJvcG9zZWQgdmFsdWUgaXMgYWxsb3dlZC5cbiAgICAgICAgICAgICAgICAvLy9jb25zb2xlLmxvZyhcIldSSVRJTkcgdG8gYSBjb25zdHJhaW5lZCAnXCIrIGZpZWxkTmFtZSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRzVHlwZSA9IGNvbnN0cmFpbnRzLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgd2hpdGVsaXN0IG9mIGFjY2VwdGFibGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKCd3aGl0ZWxpc3QnIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2NlcHRhYmxlVmFsdWVzID0gY29uc3RyYWludHMud2hpdGVsaXN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRQb3NpdGlvbiA9IGFjY2VwdGFibGVWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRyaW0gd2hpdGVzcGFjZT8gZm9yY2UgdG8gdXBwZXIgY2FzZT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kUG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3QgdGhlIHByb3Bvc2VkIHZhbHVlOyByZS1hc3NlcnQgdGhlIG9sZCB2YWx1ZSBmb3IgVUkgcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqWyBmaWVsZE5hbWUgXS52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdHNUeXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgbWluaW11bSwgbWF4aW11bSwgcHJlY2lzaW9uPyBjb2VyY2UgYW5kIGJsb2NrIE5hTlxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTiggbmV3VmFsdWUgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0IHRoZSBwcm9wb3NlZCB2YWx1ZTsgcmUtYXNzZXJ0IHRoZSBvbGQgdmFsdWUgZm9yIFVJIHJlZnJlc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialsgZmllbGROYW1lIF0udmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdtaW4nIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluVmFsdWUgPSBOdW1iZXIoY29uc3RyYWludHMubWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5tYXgoIG1pblZhbHVlLCBuZXdWYWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnbWF4JyBpbiBjb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyKGNvbnN0cmFpbnRzLm1heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IE1hdGgubWluKCBtYXhWYWx1ZSwgbmV3VmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRzVHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgc3RyaW5nLXNwZWNpZmljIGNvbnN0cmFpbnRzIGhlcmUgKG1pbi4gY2hhcnMsIGV0Yy4pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RpbGwgaGVyZT8gVXBkYXRlIHRoZSB2YWx1ZSAod2hpY2ggbWF5ICpub3QqIGhhdmUgY2hhbmdlZCkgYW5kIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgb2JqWyBmaWVsZE5hbWUgXSggbmV3VmFsdWUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvd25lcjogb2JqLFxuICAgICAgICAgICAgZGVmZXJFdmFsdWF0aW9uOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyogTmV3aWNrIChhbmQgb3RoZXI/KSBmb3JtYXRzIGNvbnZlcnRlZCBOZXhzb24gbWF5IGJlIG1pc3Npbmcgc29tZVxuICAgICAqIGVsZW1lbnRzIHdlIGV4cGVjdC4gQWRkIHRoZXNlIG5vdy4gKi9cbiAgICB2YXIgZml4VXBDb252ZXJ0ZWROZXhzb24gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vICdkYXRhJyBpcyBuZXhtbCBpbiB0eXBpY2FsIEpTT04gd3JhcHBlclxuICAgICAgICB2YXIgbmV4bWwgPSBkYXRhLmRhdGEubmV4bWw7XG4gICAgICAgIHZhciBub2RlSGFzQ2hpbGRyZW4gPSBmdW5jdGlvbihub2RlLCB0cmVlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgJC5lYWNoKHRyZWUuZWRnZSwgZnVuY3Rpb24oaSxlZGdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VbJ0Bzb3VyY2UnXSA9PT0gbm9kZVsnQGlkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRGb3VuZDtcbiAgICAgICAgfTtcbiAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLHRyZWVDb2xsZWN0aW9uKSB7IC8vIG1hcmsgY2hpbGRsZXNzIG5vZGVzIHdpdGggJ290OmlzbGVhZidcbiAgICAgICAgICAgICQuZWFjaCh0cmVlQ29sbGVjdGlvbi50cmVlLCBmdW5jdGlvbihpLCB0cmVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWZOb2RlcyA9ICQuZ3JlcCh0cmVlLm5vZGUsIGZ1bmN0aW9uKG5vZGUpIHsgXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSGFzQ2hpbGRyZW4obm9kZSx0cmVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IGludGVybmFsIG5vZGVzP1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsnXm90OmlzTGVhZiddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIFVzZSBzbmlmZmVycyB0byBkZXRlcm1pbmUgdGhlIG1vc3QgbGlrZWx5IGZvcm1hdCBvZiBpbnB1dCB0cmVlIGRhdGEgKi9cbiAgICB2YXIgbW9zdExpa2VseURhdGFGb3JtYXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodXRpbHMuaXNQcm9iYWJseU5ld2ljayhkYXRhKSkgeyByZXR1cm4gICduZXdpY2snOyB9XG4gICAgICAgIGlmICh1dGlscy5pc1Byb2JhYmx5TkVYVVMoZGF0YSkpICB7IHJldHVybiAgJ25leHVzJzsgfVxuICAgICAgICBpZiAodXRpbHMuaXNQcm9iYWJseVJQaHlsbyhkYXRhKSkgIHsgcmV0dXJuICAncGh5bG8nOyB9XG4gICAgICAgIGlmICh1dGlscy5pc1Byb2JhYmx5TmVYTUwoZGF0YSkpICB7IHJldHVybiAgJ25leG1sJzsgfVxuICAgICAgICByZXR1cm4gJyc7ICAvLyBmb3JtYXQgdW5rbm93blxuICAgIH1cblxuICAgIC8qIGV4cG9zZSBjbGFzcyBjb25zdHJ1Y3RvcnMgKGFuZCBzdGF0aWMgbWV0aG9kcykgZm9yIGluc3RhbnRpYXRpb24gKi9cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBleHBvc2UgZW51bWVyYXRpb25zXG4gICAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgICAgY29sb3JEZXB0aHM6IGNvbG9yRGVwdGhzLFxuICAgICAgICB0cmVlTGF5b3V0czogdHJlZUxheW91dHMsXG4gICAgICAgIGJyYW5jaFJvdGF0aW9uTWV0aG9kczogYnJhbmNoUm90YXRpb25NZXRob2RzLFxuICAgICAgICBhbGlnbm1lbnRzOiBhbGlnbm1lbnRzLFxuICAgICAgICBzd2VlcERpcmVjdGlvbnM6IHN3ZWVwRGlyZWN0aW9ucyxcbiAgICAgICAgZGF0YVNvdXJjZVR5cGVzOiBkYXRhU291cmNlVHlwZXMsXG4gICAgICAgIHZlcnNpb25UeXBlczogdmVyc2lvblR5cGVzLFxuICAgICAgICBob3N0QXBwbGljYXRpb25zOiBob3N0QXBwbGljYXRpb25zLFxuICAgICAgICBzdG9yYWdlQmFja2VuZHM6IHN0b3JhZ2VCYWNrZW5kcyxcbiAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICBzZXRDYWNoZWREYXRhOiBzZXRDYWNoZWREYXRhLFxuICAgICAgICBnZXRDYWNoZWREYXRhOiBnZXRDYWNoZWREYXRhLFxuICAgICAgICBjbGVhckNhY2hlZERhdGE6IGNsZWFyQ2FjaGVkRGF0YSxcbiAgICAgICAgZmx1c2hDYWNoZTogZmx1c2hDYWNoZSxcbiAgICAgICAgZ2F0aGVyQWxsQ2FjaGVkRGF0YTogZ2F0aGVyQWxsQ2FjaGVkRGF0YSxcbiAgICAgICAgZ2F0aGVyU3RhdGljSW5wdXREYXRhOiBnYXRoZXJTdGF0aWNJbnB1dERhdGEsXG4gICAgICAgIGdhdGhlckFsbElucHV0RGF0YTogZ2F0aGVyQWxsSW5wdXREYXRhLFxuICAgICAgICBnYXRoZXJBbGxUcmFuc2Zvcm1EYXRhOiBnYXRoZXJBbGxUcmFuc2Zvcm1EYXRhLFxuICAgICAgICBnYXRoZXJBbGxPdXRwdXREYXRhOiBnYXRoZXJBbGxPdXRwdXREYXRhLFxuXG4gICAgICAgIC8vIGV4cG9zZSB2aWV3LW1vZGVsIGNsYXNzZXNcbiAgICAgICAgSWxsdXN0cmF0aW9uOiBJbGx1c3RyYXRpb24sXG4gICAgICAgIFNjZW5lR3JhcGg6IFNjZW5lR3JhcGgsXG4gICAgICAgIElsbHVzdHJhdGVkVHJlZTogSWxsdXN0cmF0ZWRUcmVlLFxuICAgICAgICBTdXBwb3J0aW5nRGF0YXNldDogU3VwcG9ydGluZ0RhdGFzZXQsXG4gICAgICAgIE9ybmFtZW50OiBPcm5hbWVudCxcbiAgICAgICAgU3R5bGVPdmVycmlkZXM6IFN0eWxlT3ZlcnJpZGVzXG4gICAgfTtcbn0od2luZG93LCBkb2N1bWVudCwgJCwga28sIHN0eWxpc3QpO1xuXG5mb3IgKHZhciBuYW1lIGluIFRyZWVJbGx1c3RyYXRvcikge1xuICAgIGV4cG9ydHNbIG5hbWUgXSA9IFRyZWVJbGx1c3RyYXRvclsgbmFtZSBdO1xufVxuIiwiOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLyohIGpRdWVyeSB2MS44LjMganF1ZXJ5LmNvbSB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xyXG4oZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBfKGUpe3ZhciB0PU1bZV09e307cmV0dXJuIHYuZWFjaChlLnNwbGl0KHkpLGZ1bmN0aW9uKGUsbil7dFtuXT0hMH0pLHR9ZnVuY3Rpb24gSChlLG4scil7aWYocj09PXQmJmUubm9kZVR5cGU9PT0xKXt2YXIgaT1cImRhdGEtXCIrbi5yZXBsYWNlKFAsXCItJDFcIikudG9Mb3dlckNhc2UoKTtyPWUuZ2V0QXR0cmlidXRlKGkpO2lmKHR5cGVvZiByPT1cInN0cmluZ1wiKXt0cnl7cj1yPT09XCJ0cnVlXCI/ITA6cj09PVwiZmFsc2VcIj8hMTpyPT09XCJudWxsXCI/bnVsbDorcitcIlwiPT09cj8rcjpELnRlc3Qocik/di5wYXJzZUpTT04ocik6cn1jYXRjaChzKXt9di5kYXRhKGUsbixyKX1lbHNlIHI9dH1yZXR1cm4gcn1mdW5jdGlvbiBCKGUpe3ZhciB0O2Zvcih0IGluIGUpe2lmKHQ9PT1cImRhdGFcIiYmdi5pc0VtcHR5T2JqZWN0KGVbdF0pKWNvbnRpbnVlO2lmKHQhPT1cInRvSlNPTlwiKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIGV0KCl7cmV0dXJuITF9ZnVuY3Rpb24gdHQoKXtyZXR1cm4hMH1mdW5jdGlvbiB1dChlKXtyZXR1cm4hZXx8IWUucGFyZW50Tm9kZXx8ZS5wYXJlbnROb2RlLm5vZGVUeXBlPT09MTF9ZnVuY3Rpb24gYXQoZSx0KXtkbyBlPWVbdF07d2hpbGUoZSYmZS5ub2RlVHlwZSE9PTEpO3JldHVybiBlfWZ1bmN0aW9uIGZ0KGUsdCxuKXt0PXR8fDA7aWYodi5pc0Z1bmN0aW9uKHQpKXJldHVybiB2LmdyZXAoZSxmdW5jdGlvbihlLHIpe3ZhciBpPSEhdC5jYWxsKGUscixlKTtyZXR1cm4gaT09PW59KTtpZih0Lm5vZGVUeXBlKXJldHVybiB2LmdyZXAoZSxmdW5jdGlvbihlLHIpe3JldHVybiBlPT09dD09PW59KTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7dmFyIHI9di5ncmVwKGUsZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT0xfSk7aWYoaXQudGVzdCh0KSlyZXR1cm4gdi5maWx0ZXIodCxyLCFuKTt0PXYuZmlsdGVyKHQscil9cmV0dXJuIHYuZ3JlcChlLGZ1bmN0aW9uKGUscil7cmV0dXJuIHYuaW5BcnJheShlLHQpPj0wPT09bn0pfWZ1bmN0aW9uIGx0KGUpe3ZhciB0PWN0LnNwbGl0KFwifFwiKSxuPWUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2lmKG4uY3JlYXRlRWxlbWVudCl3aGlsZSh0Lmxlbmd0aCluLmNyZWF0ZUVsZW1lbnQodC5wb3AoKSk7cmV0dXJuIG59ZnVuY3Rpb24gTHQoZSx0KXtyZXR1cm4gZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0KVswXXx8ZS5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0KSl9ZnVuY3Rpb24gQXQoZSx0KXtpZih0Lm5vZGVUeXBlIT09MXx8IXYuaGFzRGF0YShlKSlyZXR1cm47dmFyIG4scixpLHM9di5fZGF0YShlKSxvPXYuX2RhdGEodCxzKSx1PXMuZXZlbnRzO2lmKHUpe2RlbGV0ZSBvLmhhbmRsZSxvLmV2ZW50cz17fTtmb3IobiBpbiB1KWZvcihyPTAsaT11W25dLmxlbmd0aDtyPGk7cisrKXYuZXZlbnQuYWRkKHQsbix1W25dW3JdKX1vLmRhdGEmJihvLmRhdGE9di5leHRlbmQoe30sby5kYXRhKSl9ZnVuY3Rpb24gT3QoZSx0KXt2YXIgbjtpZih0Lm5vZGVUeXBlIT09MSlyZXR1cm47dC5jbGVhckF0dHJpYnV0ZXMmJnQuY2xlYXJBdHRyaWJ1dGVzKCksdC5tZXJnZUF0dHJpYnV0ZXMmJnQubWVyZ2VBdHRyaWJ1dGVzKGUpLG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLG49PT1cIm9iamVjdFwiPyh0LnBhcmVudE5vZGUmJih0Lm91dGVySFRNTD1lLm91dGVySFRNTCksdi5zdXBwb3J0Lmh0bWw1Q2xvbmUmJmUuaW5uZXJIVE1MJiYhdi50cmltKHQuaW5uZXJIVE1MKSYmKHQuaW5uZXJIVE1MPWUuaW5uZXJIVE1MKSk6bj09PVwiaW5wdXRcIiYmRXQudGVzdChlLnR5cGUpPyh0LmRlZmF1bHRDaGVja2VkPXQuY2hlY2tlZD1lLmNoZWNrZWQsdC52YWx1ZSE9PWUudmFsdWUmJih0LnZhbHVlPWUudmFsdWUpKTpuPT09XCJvcHRpb25cIj90LnNlbGVjdGVkPWUuZGVmYXVsdFNlbGVjdGVkOm49PT1cImlucHV0XCJ8fG49PT1cInRleHRhcmVhXCI/dC5kZWZhdWx0VmFsdWU9ZS5kZWZhdWx0VmFsdWU6bj09PVwic2NyaXB0XCImJnQudGV4dCE9PWUudGV4dCYmKHQudGV4dD1lLnRleHQpLHQucmVtb3ZlQXR0cmlidXRlKHYuZXhwYW5kbyl9ZnVuY3Rpb24gTXQoZSl7cmV0dXJuIHR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lIT1cInVuZGVmaW5lZFwiP2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpOnR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwhPVwidW5kZWZpbmVkXCI/ZS5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKTpbXX1mdW5jdGlvbiBfdChlKXtFdC50ZXN0KGUudHlwZSkmJihlLmRlZmF1bHRDaGVja2VkPWUuY2hlY2tlZCl9ZnVuY3Rpb24gUXQoZSx0KXtpZih0IGluIGUpcmV0dXJuIHQ7dmFyIG49dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpLHI9dCxpPUp0Lmxlbmd0aDt3aGlsZShpLS0pe3Q9SnRbaV0rbjtpZih0IGluIGUpcmV0dXJuIHR9cmV0dXJuIHJ9ZnVuY3Rpb24gR3QoZSx0KXtyZXR1cm4gZT10fHxlLHYuY3NzKGUsXCJkaXNwbGF5XCIpPT09XCJub25lXCJ8fCF2LmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCxlKX1mdW5jdGlvbiBZdChlLHQpe3ZhciBuLHIsaT1bXSxzPTAsbz1lLmxlbmd0aDtmb3IoO3M8bztzKyspe249ZVtzXTtpZighbi5zdHlsZSljb250aW51ZTtpW3NdPXYuX2RhdGEobixcIm9sZGRpc3BsYXlcIiksdD8oIWlbc10mJm4uc3R5bGUuZGlzcGxheT09PVwibm9uZVwiJiYobi5zdHlsZS5kaXNwbGF5PVwiXCIpLG4uc3R5bGUuZGlzcGxheT09PVwiXCImJkd0KG4pJiYoaVtzXT12Ll9kYXRhKG4sXCJvbGRkaXNwbGF5XCIsbm4obi5ub2RlTmFtZSkpKSk6KHI9RHQobixcImRpc3BsYXlcIiksIWlbc10mJnIhPT1cIm5vbmVcIiYmdi5fZGF0YShuLFwib2xkZGlzcGxheVwiLHIpKX1mb3Iocz0wO3M8bztzKyspe249ZVtzXTtpZighbi5zdHlsZSljb250aW51ZTtpZighdHx8bi5zdHlsZS5kaXNwbGF5PT09XCJub25lXCJ8fG4uc3R5bGUuZGlzcGxheT09PVwiXCIpbi5zdHlsZS5kaXNwbGF5PXQ/aVtzXXx8XCJcIjpcIm5vbmVcIn1yZXR1cm4gZX1mdW5jdGlvbiBadChlLHQsbil7dmFyIHI9UnQuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMV0tKG58fDApKSsoclsyXXx8XCJweFwiKTp0fWZ1bmN0aW9uIGVuKGUsdCxuLHIpe3ZhciBpPW49PT0ocj9cImJvcmRlclwiOlwiY29udGVudFwiKT80OnQ9PT1cIndpZHRoXCI/MTowLHM9MDtmb3IoO2k8NDtpKz0yKW49PT1cIm1hcmdpblwiJiYocys9di5jc3MoZSxuKyR0W2ldLCEwKSkscj8obj09PVwiY29udGVudFwiJiYocy09cGFyc2VGbG9hdChEdChlLFwicGFkZGluZ1wiKyR0W2ldKSl8fDApLG4hPT1cIm1hcmdpblwiJiYocy09cGFyc2VGbG9hdChEdChlLFwiYm9yZGVyXCIrJHRbaV0rXCJXaWR0aFwiKSl8fDApKToocys9cGFyc2VGbG9hdChEdChlLFwicGFkZGluZ1wiKyR0W2ldKSl8fDAsbiE9PVwicGFkZGluZ1wiJiYocys9cGFyc2VGbG9hdChEdChlLFwiYm9yZGVyXCIrJHRbaV0rXCJXaWR0aFwiKSl8fDApKTtyZXR1cm4gc31mdW5jdGlvbiB0bihlLHQsbil7dmFyIHI9dD09PVwid2lkdGhcIj9lLm9mZnNldFdpZHRoOmUub2Zmc2V0SGVpZ2h0LGk9ITAscz12LnN1cHBvcnQuYm94U2l6aW5nJiZ2LmNzcyhlLFwiYm94U2l6aW5nXCIpPT09XCJib3JkZXItYm94XCI7aWYocjw9MHx8cj09bnVsbCl7cj1EdChlLHQpO2lmKHI8MHx8cj09bnVsbClyPWUuc3R5bGVbdF07aWYoVXQudGVzdChyKSlyZXR1cm4gcjtpPXMmJih2LnN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGV8fHI9PT1lLnN0eWxlW3RdKSxyPXBhcnNlRmxvYXQocil8fDB9cmV0dXJuIHIrZW4oZSx0LG58fChzP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpLGkpK1wicHhcIn1mdW5jdGlvbiBubihlKXtpZihXdFtlXSlyZXR1cm4gV3RbZV07dmFyIHQ9dihcIjxcIitlK1wiPlwiKS5hcHBlbmRUbyhpLmJvZHkpLG49dC5jc3MoXCJkaXNwbGF5XCIpO3QucmVtb3ZlKCk7aWYobj09PVwibm9uZVwifHxuPT09XCJcIil7UHQ9aS5ib2R5LmFwcGVuZENoaWxkKFB0fHx2LmV4dGVuZChpLmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIikse2ZyYW1lQm9yZGVyOjAsd2lkdGg6MCxoZWlnaHQ6MH0pKTtpZighSHR8fCFQdC5jcmVhdGVFbGVtZW50KUh0PShQdC5jb250ZW50V2luZG93fHxQdC5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50LEh0LndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpLEh0LmNsb3NlKCk7dD1IdC5ib2R5LmFwcGVuZENoaWxkKEh0LmNyZWF0ZUVsZW1lbnQoZSkpLG49RHQodCxcImRpc3BsYXlcIiksaS5ib2R5LnJlbW92ZUNoaWxkKFB0KX1yZXR1cm4gV3RbZV09bixufWZ1bmN0aW9uIGZuKGUsdCxuLHIpe3ZhciBpO2lmKHYuaXNBcnJheSh0KSl2LmVhY2godCxmdW5jdGlvbih0LGkpe258fHNuLnRlc3QoZSk/cihlLGkpOmZuKGUrXCJbXCIrKHR5cGVvZiBpPT1cIm9iamVjdFwiP3Q6XCJcIikrXCJdXCIsaSxuLHIpfSk7ZWxzZSBpZighbiYmdi50eXBlKHQpPT09XCJvYmplY3RcIilmb3IoaSBpbiB0KWZuKGUrXCJbXCIraStcIl1cIix0W2ldLG4scik7ZWxzZSByKGUsdCl9ZnVuY3Rpb24gQ24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7dHlwZW9mIHQhPVwic3RyaW5nXCImJihuPXQsdD1cIipcIik7dmFyIHIsaSxzLG89dC50b0xvd2VyQ2FzZSgpLnNwbGl0KHkpLHU9MCxhPW8ubGVuZ3RoO2lmKHYuaXNGdW5jdGlvbihuKSlmb3IoO3U8YTt1Kyspcj1vW3VdLHM9L15cXCsvLnRlc3QocikscyYmKHI9ci5zdWJzdHIoMSl8fFwiKlwiKSxpPWVbcl09ZVtyXXx8W10saVtzP1widW5zaGlmdFwiOlwicHVzaFwiXShuKX19ZnVuY3Rpb24ga24oZSxuLHIsaSxzLG8pe3M9c3x8bi5kYXRhVHlwZXNbMF0sbz1vfHx7fSxvW3NdPSEwO3ZhciB1LGE9ZVtzXSxmPTAsbD1hP2EubGVuZ3RoOjAsYz1lPT09U247Zm9yKDtmPGwmJihjfHwhdSk7ZisrKXU9YVtmXShuLHIsaSksdHlwZW9mIHU9PVwic3RyaW5nXCImJighY3x8b1t1XT91PXQ6KG4uZGF0YVR5cGVzLnVuc2hpZnQodSksdT1rbihlLG4scixpLHUsbykpKTtyZXR1cm4oY3x8IXUpJiYhb1tcIipcIl0mJih1PWtuKGUsbixyLGksXCIqXCIsbykpLHV9ZnVuY3Rpb24gTG4oZSxuKXt2YXIgcixpLHM9di5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihyIGluIG4pbltyXSE9PXQmJigoc1tyXT9lOml8fChpPXt9KSlbcl09bltyXSk7aSYmdi5leHRlbmQoITAsZSxpKX1mdW5jdGlvbiBBbihlLG4scil7dmFyIGkscyxvLHUsYT1lLmNvbnRlbnRzLGY9ZS5kYXRhVHlwZXMsbD1lLnJlc3BvbnNlRmllbGRzO2ZvcihzIGluIGwpcyBpbiByJiYobltsW3NdXT1yW3NdKTt3aGlsZShmWzBdPT09XCIqXCIpZi5zaGlmdCgpLGk9PT10JiYoaT1lLm1pbWVUeXBlfHxuLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpKTtpZihpKWZvcihzIGluIGEpaWYoYVtzXSYmYVtzXS50ZXN0KGkpKXtmLnVuc2hpZnQocyk7YnJlYWt9aWYoZlswXWluIHIpbz1mWzBdO2Vsc2V7Zm9yKHMgaW4gcil7aWYoIWZbMF18fGUuY29udmVydGVyc1tzK1wiIFwiK2ZbMF1dKXtvPXM7YnJlYWt9dXx8KHU9cyl9bz1vfHx1fWlmKG8pcmV0dXJuIG8hPT1mWzBdJiZmLnVuc2hpZnQobykscltvXX1mdW5jdGlvbiBPbihlLHQpe3ZhciBuLHIsaSxzLG89ZS5kYXRhVHlwZXMuc2xpY2UoKSx1PW9bMF0sYT17fSxmPTA7ZS5kYXRhRmlsdGVyJiYodD1lLmRhdGFGaWx0ZXIodCxlLmRhdGFUeXBlKSk7aWYob1sxXSlmb3IobiBpbiBlLmNvbnZlcnRlcnMpYVtuLnRvTG93ZXJDYXNlKCldPWUuY29udmVydGVyc1tuXTtmb3IoO2k9b1srK2ZdOylpZihpIT09XCIqXCIpe2lmKHUhPT1cIipcIiYmdSE9PWkpe249YVt1K1wiIFwiK2ldfHxhW1wiKiBcIitpXTtpZighbilmb3IociBpbiBhKXtzPXIuc3BsaXQoXCIgXCIpO2lmKHNbMV09PT1pKXtuPWFbdStcIiBcIitzWzBdXXx8YVtcIiogXCIrc1swXV07aWYobil7bj09PSEwP249YVtyXTphW3JdIT09ITAmJihpPXNbMF0sby5zcGxpY2UoZi0tLDAsaSkpO2JyZWFrfX19aWYobiE9PSEwKWlmKG4mJmVbXCJ0aHJvd3NcIl0pdD1uKHQpO2Vsc2UgdHJ5e3Q9bih0KX1jYXRjaChsKXtyZXR1cm57c3RhdGU6XCJwYXJzZXJlcnJvclwiLGVycm9yOm4/bDpcIk5vIGNvbnZlcnNpb24gZnJvbSBcIit1K1wiIHRvIFwiK2l9fX11PWl9cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6dH19ZnVuY3Rpb24gRm4oKXt0cnl7cmV0dXJuIG5ldyBlLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKHQpe319ZnVuY3Rpb24gSW4oKXt0cnl7cmV0dXJuIG5ldyBlLkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaCh0KXt9fWZ1bmN0aW9uICRuKCl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtxbj10fSwwKSxxbj12Lm5vdygpfWZ1bmN0aW9uIEpuKGUsdCl7di5lYWNoKHQsZnVuY3Rpb24odCxuKXt2YXIgcj0oVm5bdF18fFtdKS5jb25jYXQoVm5bXCIqXCJdKSxpPTAscz1yLmxlbmd0aDtmb3IoO2k8cztpKyspaWYocltpXS5jYWxsKGUsdCxuKSlyZXR1cm59KX1mdW5jdGlvbiBLbihlLHQsbil7dmFyIHIsaT0wLHM9MCxvPVhuLmxlbmd0aCx1PXYuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24oKXtkZWxldGUgYS5lbGVtfSksYT1mdW5jdGlvbigpe3ZhciB0PXFufHwkbigpLG49TWF0aC5tYXgoMCxmLnN0YXJ0VGltZStmLmR1cmF0aW9uLXQpLHI9bi9mLmR1cmF0aW9ufHwwLGk9MS1yLHM9MCxvPWYudHdlZW5zLmxlbmd0aDtmb3IoO3M8bztzKyspZi50d2VlbnNbc10ucnVuKGkpO3JldHVybiB1Lm5vdGlmeVdpdGgoZSxbZixpLG5dKSxpPDEmJm8/bjoodS5yZXNvbHZlV2l0aChlLFtmXSksITEpfSxmPXUucHJvbWlzZSh7ZWxlbTplLHByb3BzOnYuZXh0ZW5kKHt9LHQpLG9wdHM6di5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e319LG4pLG9yaWdpbmFsUHJvcGVydGllczp0LG9yaWdpbmFsT3B0aW9uczpuLHN0YXJ0VGltZTpxbnx8JG4oKSxkdXJhdGlvbjpuLmR1cmF0aW9uLHR3ZWVuczpbXSxjcmVhdGVUd2VlbjpmdW5jdGlvbih0LG4scil7dmFyIGk9di5Ud2VlbihlLGYub3B0cyx0LG4sZi5vcHRzLnNwZWNpYWxFYXNpbmdbdF18fGYub3B0cy5lYXNpbmcpO3JldHVybiBmLnR3ZWVucy5wdXNoKGkpLGl9LHN0b3A6ZnVuY3Rpb24odCl7dmFyIG49MCxyPXQ/Zi50d2VlbnMubGVuZ3RoOjA7Zm9yKDtuPHI7bisrKWYudHdlZW5zW25dLnJ1bigxKTtyZXR1cm4gdD91LnJlc29sdmVXaXRoKGUsW2YsdF0pOnUucmVqZWN0V2l0aChlLFtmLHRdKSx0aGlzfX0pLGw9Zi5wcm9wcztRbihsLGYub3B0cy5zcGVjaWFsRWFzaW5nKTtmb3IoO2k8bztpKyspe3I9WG5baV0uY2FsbChmLGUsbCxmLm9wdHMpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIEpuKGYsbCksdi5pc0Z1bmN0aW9uKGYub3B0cy5zdGFydCkmJmYub3B0cy5zdGFydC5jYWxsKGUsZiksdi5meC50aW1lcih2LmV4dGVuZChhLHthbmltOmYscXVldWU6Zi5vcHRzLnF1ZXVlLGVsZW06ZX0pKSxmLnByb2dyZXNzKGYub3B0cy5wcm9ncmVzcykuZG9uZShmLm9wdHMuZG9uZSxmLm9wdHMuY29tcGxldGUpLmZhaWwoZi5vcHRzLmZhaWwpLmFsd2F5cyhmLm9wdHMuYWx3YXlzKX1mdW5jdGlvbiBRbihlLHQpe3ZhciBuLHIsaSxzLG87Zm9yKG4gaW4gZSl7cj12LmNhbWVsQ2FzZShuKSxpPXRbcl0scz1lW25dLHYuaXNBcnJheShzKSYmKGk9c1sxXSxzPWVbbl09c1swXSksbiE9PXImJihlW3JdPXMsZGVsZXRlIGVbbl0pLG89di5jc3NIb29rc1tyXTtpZihvJiZcImV4cGFuZFwiaW4gbyl7cz1vLmV4cGFuZChzKSxkZWxldGUgZVtyXTtmb3IobiBpbiBzKW4gaW4gZXx8KGVbbl09c1tuXSx0W25dPWkpfWVsc2UgdFtyXT1pfX1mdW5jdGlvbiBHbihlLHQsbil7dmFyIHIsaSxzLG8sdSxhLGYsbCxjLGg9dGhpcyxwPWUuc3R5bGUsZD17fSxtPVtdLGc9ZS5ub2RlVHlwZSYmR3QoZSk7bi5xdWV1ZXx8KGw9di5fcXVldWVIb29rcyhlLFwiZnhcIiksbC51bnF1ZXVlZD09bnVsbCYmKGwudW5xdWV1ZWQ9MCxjPWwuZW1wdHkuZmlyZSxsLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXtsLnVucXVldWVkfHxjKCl9KSxsLnVucXVldWVkKyssaC5hbHdheXMoZnVuY3Rpb24oKXtoLmFsd2F5cyhmdW5jdGlvbigpe2wudW5xdWV1ZWQtLSx2LnF1ZXVlKGUsXCJmeFwiKS5sZW5ndGh8fGwuZW1wdHkuZmlyZSgpfSl9KSksZS5ub2RlVHlwZT09PTEmJihcImhlaWdodFwiaW4gdHx8XCJ3aWR0aFwiaW4gdCkmJihuLm92ZXJmbG93PVtwLm92ZXJmbG93LHAub3ZlcmZsb3dYLHAub3ZlcmZsb3dZXSx2LmNzcyhlLFwiZGlzcGxheVwiKT09PVwiaW5saW5lXCImJnYuY3NzKGUsXCJmbG9hdFwiKT09PVwibm9uZVwiJiYoIXYuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0fHxubihlLm5vZGVOYW1lKT09PVwiaW5saW5lXCI/cC5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCI6cC56b29tPTEpKSxuLm92ZXJmbG93JiYocC5vdmVyZmxvdz1cImhpZGRlblwiLHYuc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzfHxoLmRvbmUoZnVuY3Rpb24oKXtwLm92ZXJmbG93PW4ub3ZlcmZsb3dbMF0scC5vdmVyZmxvd1g9bi5vdmVyZmxvd1sxXSxwLm92ZXJmbG93WT1uLm92ZXJmbG93WzJdfSkpO2ZvcihyIGluIHQpe3M9dFtyXTtpZihVbi5leGVjKHMpKXtkZWxldGUgdFtyXSxhPWF8fHM9PT1cInRvZ2dsZVwiO2lmKHM9PT0oZz9cImhpZGVcIjpcInNob3dcIikpY29udGludWU7bS5wdXNoKHIpfX1vPW0ubGVuZ3RoO2lmKG8pe3U9di5fZGF0YShlLFwiZnhzaG93XCIpfHx2Ll9kYXRhKGUsXCJmeHNob3dcIix7fSksXCJoaWRkZW5cImluIHUmJihnPXUuaGlkZGVuKSxhJiYodS5oaWRkZW49IWcpLGc/dihlKS5zaG93KCk6aC5kb25lKGZ1bmN0aW9uKCl7dihlKS5oaWRlKCl9KSxoLmRvbmUoZnVuY3Rpb24oKXt2YXIgdDt2LnJlbW92ZURhdGEoZSxcImZ4c2hvd1wiLCEwKTtmb3IodCBpbiBkKXYuc3R5bGUoZSx0LGRbdF0pfSk7Zm9yKHI9MDtyPG87cisrKWk9bVtyXSxmPWguY3JlYXRlVHdlZW4oaSxnP3VbaV06MCksZFtpXT11W2ldfHx2LnN0eWxlKGUsaSksaSBpbiB1fHwodVtpXT1mLnN0YXJ0LGcmJihmLmVuZD1mLnN0YXJ0LGYuc3RhcnQ9aT09PVwid2lkdGhcInx8aT09PVwiaGVpZ2h0XCI/MTowKSl9fWZ1bmN0aW9uIFluKGUsdCxuLHIsaSl7cmV0dXJuIG5ldyBZbi5wcm90b3R5cGUuaW5pdChlLHQsbixyLGkpfWZ1bmN0aW9uIFpuKGUsdCl7dmFyIG4scj17aGVpZ2h0OmV9LGk9MDt0PXQ/MTowO2Zvcig7aTw0O2krPTItdCluPSR0W2ldLHJbXCJtYXJnaW5cIituXT1yW1wicGFkZGluZ1wiK25dPWU7cmV0dXJuIHQmJihyLm9wYWNpdHk9ci53aWR0aD1lKSxyfWZ1bmN0aW9uIHRyKGUpe3JldHVybiB2LmlzV2luZG93KGUpP2U6ZS5ub2RlVHlwZT09PTk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6ITF9dmFyIG4scixpPWUuZG9jdW1lbnQscz1lLmxvY2F0aW9uLG89ZS5uYXZpZ2F0b3IsdT1lLmpRdWVyeSxhPWUuJCxmPUFycmF5LnByb3RvdHlwZS5wdXNoLGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLGM9QXJyYXkucHJvdG90eXBlLmluZGV4T2YsaD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLHA9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxkPVN0cmluZy5wcm90b3R5cGUudHJpbSx2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyB2LmZuLmluaXQoZSx0LG4pfSxtPS9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2UsZz0vXFxTLyx5PS9cXHMrLyxiPS9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyx3PS9eKD86W14jPF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKikkKS8sRT0vXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8sUz0vXltcXF0sOnt9XFxzXSokLyx4PS8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxUPS9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1W1xcZGEtZkEtRl17NH0pL2csTj0vXCJbXlwiXFxcXFxcclxcbl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/KD86XFxkXFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpL2csQz0vXi1tcy0vLGs9Ly0oW1xcZGEtel0pL2dpLEw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4odCtcIlwiKS50b1VwcGVyQ2FzZSgpfSxBPWZ1bmN0aW9uKCl7aS5hZGRFdmVudExpc3RlbmVyPyhpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsQSwhMSksdi5yZWFkeSgpKTppLnJlYWR5U3RhdGU9PT1cImNvbXBsZXRlXCImJihpLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsQSksdi5yZWFkeSgpKX0sTz17fTt2LmZuPXYucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp2LGluaXQ6ZnVuY3Rpb24oZSxuLHIpe3ZhciBzLG8sdSxhO2lmKCFlKXJldHVybiB0aGlzO2lmKGUubm9kZVR5cGUpcmV0dXJuIHRoaXMuY29udGV4dD10aGlzWzBdPWUsdGhpcy5sZW5ndGg9MSx0aGlzO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtlLmNoYXJBdCgwKT09PVwiPFwiJiZlLmNoYXJBdChlLmxlbmd0aC0xKT09PVwiPlwiJiZlLmxlbmd0aD49Mz9zPVtudWxsLGUsbnVsbF06cz13LmV4ZWMoZSk7aWYocyYmKHNbMV18fCFuKSl7aWYoc1sxXSlyZXR1cm4gbj1uIGluc3RhbmNlb2Ygdj9uWzBdOm4sYT1uJiZuLm5vZGVUeXBlP24ub3duZXJEb2N1bWVudHx8bjppLGU9di5wYXJzZUhUTUwoc1sxXSxhLCEwKSxFLnRlc3Qoc1sxXSkmJnYuaXNQbGFpbk9iamVjdChuKSYmdGhpcy5hdHRyLmNhbGwoZSxuLCEwKSx2Lm1lcmdlKHRoaXMsZSk7bz1pLmdldEVsZW1lbnRCeUlkKHNbMl0pO2lmKG8mJm8ucGFyZW50Tm9kZSl7aWYoby5pZCE9PXNbMl0pcmV0dXJuIHIuZmluZChlKTt0aGlzLmxlbmd0aD0xLHRoaXNbMF09b31yZXR1cm4gdGhpcy5jb250ZXh0PWksdGhpcy5zZWxlY3Rvcj1lLHRoaXN9cmV0dXJuIW58fG4uanF1ZXJ5PyhufHxyKS5maW5kKGUpOnRoaXMuY29uc3RydWN0b3IobikuZmluZChlKX1yZXR1cm4gdi5pc0Z1bmN0aW9uKGUpP3IucmVhZHkoZSk6KGUuc2VsZWN0b3IhPT10JiYodGhpcy5zZWxlY3Rvcj1lLnNlbGVjdG9yLHRoaXMuY29udGV4dD1lLmNvbnRleHQpLHYubWFrZUFycmF5KGUsdGhpcykpfSxzZWxlY3RvcjpcIlwiLGpxdWVyeTpcIjEuOC4zXCIsbGVuZ3RoOjAsc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH0sdG9BcnJheTpmdW5jdGlvbigpe3JldHVybiBsLmNhbGwodGhpcyl9LGdldDpmdW5jdGlvbihlKXtyZXR1cm4gZT09bnVsbD90aGlzLnRvQXJyYXkoKTplPDA/dGhpc1t0aGlzLmxlbmd0aCtlXTp0aGlzW2VdfSxwdXNoU3RhY2s6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXYubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGUpO3JldHVybiByLnByZXZPYmplY3Q9dGhpcyxyLmNvbnRleHQ9dGhpcy5jb250ZXh0LHQ9PT1cImZpbmRcIj9yLnNlbGVjdG9yPXRoaXMuc2VsZWN0b3IrKHRoaXMuc2VsZWN0b3I/XCIgXCI6XCJcIikrbjp0JiYoci5zZWxlY3Rvcj10aGlzLnNlbGVjdG9yK1wiLlwiK3QrXCIoXCIrbitcIilcIikscn0sZWFjaDpmdW5jdGlvbihlLHQpe3JldHVybiB2LmVhY2godGhpcyxlLHQpfSxyZWFkeTpmdW5jdGlvbihlKXtyZXR1cm4gdi5yZWFkeS5wcm9taXNlKCkuZG9uZShlKSx0aGlzfSxlcTpmdW5jdGlvbihlKXtyZXR1cm4gZT0rZSxlPT09LTE/dGhpcy5zbGljZShlKTp0aGlzLnNsaWNlKGUsZSsxKX0sZmlyc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgwKX0sbGFzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKC0xKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobC5hcHBseSh0aGlzLGFyZ3VtZW50cyksXCJzbGljZVwiLGwuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIsXCIpKX0sbWFwOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayh2Lm1hcCh0aGlzLGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUuY2FsbCh0LG4sdCl9KSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IobnVsbCl9LHB1c2g6Zixzb3J0OltdLnNvcnQsc3BsaWNlOltdLnNwbGljZX0sdi5mbi5pbml0LnByb3RvdHlwZT12LmZuLHYuZXh0ZW5kPXYuZm4uZXh0ZW5kPWZ1bmN0aW9uKCl7dmFyIGUsbixyLGkscyxvLHU9YXJndW1lbnRzWzBdfHx7fSxhPTEsZj1hcmd1bWVudHMubGVuZ3RoLGw9ITE7dHlwZW9mIHU9PVwiYm9vbGVhblwiJiYobD11LHU9YXJndW1lbnRzWzFdfHx7fSxhPTIpLHR5cGVvZiB1IT1cIm9iamVjdFwiJiYhdi5pc0Z1bmN0aW9uKHUpJiYodT17fSksZj09PWEmJih1PXRoaXMsLS1hKTtmb3IoO2E8ZjthKyspaWYoKGU9YXJndW1lbnRzW2FdKSE9bnVsbClmb3IobiBpbiBlKXtyPXVbbl0saT1lW25dO2lmKHU9PT1pKWNvbnRpbnVlO2wmJmkmJih2LmlzUGxhaW5PYmplY3QoaSl8fChzPXYuaXNBcnJheShpKSkpPyhzPyhzPSExLG89ciYmdi5pc0FycmF5KHIpP3I6W10pOm89ciYmdi5pc1BsYWluT2JqZWN0KHIpP3I6e30sdVtuXT12LmV4dGVuZChsLG8saSkpOmkhPT10JiYodVtuXT1pKX1yZXR1cm4gdX0sdi5leHRlbmQoe25vQ29uZmxpY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIGUuJD09PXYmJihlLiQ9YSksdCYmZS5qUXVlcnk9PT12JiYoZS5qUXVlcnk9dSksdn0saXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rpb24oZSl7ZT92LnJlYWR5V2FpdCsrOnYucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihlKXtpZihlPT09ITA/LS12LnJlYWR5V2FpdDp2LmlzUmVhZHkpcmV0dXJuO2lmKCFpLmJvZHkpcmV0dXJuIHNldFRpbWVvdXQodi5yZWFkeSwxKTt2LmlzUmVhZHk9ITA7aWYoZSE9PSEwJiYtLXYucmVhZHlXYWl0PjApcmV0dXJuO3IucmVzb2x2ZVdpdGgoaSxbdl0pLHYuZm4udHJpZ2dlciYmdihpKS50cmlnZ2VyKFwicmVhZHlcIikub2ZmKFwicmVhZHlcIil9LGlzRnVuY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIHYudHlwZShlKT09PVwiZnVuY3Rpb25cIn0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gdi50eXBlKGUpPT09XCJhcnJheVwifSxpc1dpbmRvdzpmdW5jdGlvbihlKXtyZXR1cm4gZSE9bnVsbCYmZT09ZS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihlKXtyZXR1cm4haXNOYU4ocGFyc2VGbG9hdChlKSkmJmlzRmluaXRlKGUpfSx0eXBlOmZ1bmN0aW9uKGUpe3JldHVybiBlPT1udWxsP1N0cmluZyhlKTpPW2guY2FsbChlKV18fFwib2JqZWN0XCJ9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7aWYoIWV8fHYudHlwZShlKSE9PVwib2JqZWN0XCJ8fGUubm9kZVR5cGV8fHYuaXNXaW5kb3coZSkpcmV0dXJuITE7dHJ5e2lmKGUuY29uc3RydWN0b3ImJiFwLmNhbGwoZSxcImNvbnN0cnVjdG9yXCIpJiYhcC5jYWxsKGUuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKSlyZXR1cm4hMX1jYXRjaChuKXtyZXR1cm4hMX12YXIgcjtmb3IociBpbiBlKTtyZXR1cm4gcj09PXR8fHAuY2FsbChlLHIpfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0O2Zvcih0IGluIGUpcmV0dXJuITE7cmV0dXJuITB9LGVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihlKX0scGFyc2VIVE1MOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtyZXR1cm4hZXx8dHlwZW9mIGUhPVwic3RyaW5nXCI/bnVsbDoodHlwZW9mIHQ9PVwiYm9vbGVhblwiJiYobj10LHQ9MCksdD10fHxpLChyPUUuZXhlYyhlKSk/W3QuY3JlYXRlRWxlbWVudChyWzFdKV06KHI9di5idWlsZEZyYWdtZW50KFtlXSx0LG4/bnVsbDpbXSksdi5tZXJnZShbXSwoci5jYWNoZWFibGU/di5jbG9uZShyLmZyYWdtZW50KTpyLmZyYWdtZW50KS5jaGlsZE5vZGVzKSkpfSxwYXJzZUpTT046ZnVuY3Rpb24odCl7aWYoIXR8fHR5cGVvZiB0IT1cInN0cmluZ1wiKXJldHVybiBudWxsO3Q9di50cmltKHQpO2lmKGUuSlNPTiYmZS5KU09OLnBhcnNlKXJldHVybiBlLkpTT04ucGFyc2UodCk7aWYoUy50ZXN0KHQucmVwbGFjZShULFwiQFwiKS5yZXBsYWNlKE4sXCJdXCIpLnJlcGxhY2UoeCxcIlwiKSkpcmV0dXJuKG5ldyBGdW5jdGlvbihcInJldHVybiBcIit0KSkoKTt2LmVycm9yKFwiSW52YWxpZCBKU09OOiBcIit0KX0scGFyc2VYTUw6ZnVuY3Rpb24obil7dmFyIHIsaTtpZighbnx8dHlwZW9mIG4hPVwic3RyaW5nXCIpcmV0dXJuIG51bGw7dHJ5e2UuRE9NUGFyc2VyPyhpPW5ldyBET01QYXJzZXIscj1pLnBhcnNlRnJvbVN0cmluZyhuLFwidGV4dC94bWxcIikpOihyPW5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSxyLmFzeW5jPVwiZmFsc2VcIixyLmxvYWRYTUwobikpfWNhdGNoKHMpe3I9dH1yZXR1cm4oIXJ8fCFyLmRvY3VtZW50RWxlbWVudHx8ci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCkmJnYuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrbikscn0sbm9vcDpmdW5jdGlvbigpe30sZ2xvYmFsRXZhbDpmdW5jdGlvbih0KXt0JiZnLnRlc3QodCkmJihlLmV4ZWNTY3JpcHR8fGZ1bmN0aW9uKHQpe2UuZXZhbC5jYWxsKGUsdCl9KSh0KX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoQyxcIm1zLVwiKS5yZXBsYWNlKGssTCl9LG5vZGVOYW1lOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXQudG9Mb3dlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihlLG4scil7dmFyIGkscz0wLG89ZS5sZW5ndGgsdT1vPT09dHx8di5pc0Z1bmN0aW9uKGUpO2lmKHIpe2lmKHUpe2ZvcihpIGluIGUpaWYobi5hcHBseShlW2ldLHIpPT09ITEpYnJlYWt9ZWxzZSBmb3IoO3M8bzspaWYobi5hcHBseShlW3MrK10scik9PT0hMSlicmVha31lbHNlIGlmKHUpe2ZvcihpIGluIGUpaWYobi5jYWxsKGVbaV0saSxlW2ldKT09PSExKWJyZWFrfWVsc2UgZm9yKDtzPG87KWlmKG4uY2FsbChlW3NdLHMsZVtzKytdKT09PSExKWJyZWFrO3JldHVybiBlfSx0cmltOmQmJiFkLmNhbGwoXCJcXHVmZWZmXFx1MDBhMFwiKT9mdW5jdGlvbihlKXtyZXR1cm4gZT09bnVsbD9cIlwiOmQuY2FsbChlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PW51bGw/XCJcIjooZStcIlwiKS5yZXBsYWNlKGIsXCJcIil9LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuLHI9dHx8W107cmV0dXJuIGUhPW51bGwmJihuPXYudHlwZShlKSxlLmxlbmd0aD09bnVsbHx8bj09PVwic3RyaW5nXCJ8fG49PT1cImZ1bmN0aW9uXCJ8fG49PT1cInJlZ2V4cFwifHx2LmlzV2luZG93KGUpP2YuY2FsbChyLGUpOnYubWVyZ2UocixlKSkscn0saW5BcnJheTpmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYodCl7aWYoYylyZXR1cm4gYy5jYWxsKHQsZSxuKTtyPXQubGVuZ3RoLG49bj9uPDA/TWF0aC5tYXgoMCxyK24pOm46MDtmb3IoO248cjtuKyspaWYobiBpbiB0JiZ0W25dPT09ZSlyZXR1cm4gbn1yZXR1cm4tMX0sbWVyZ2U6ZnVuY3Rpb24oZSxuKXt2YXIgcj1uLmxlbmd0aCxpPWUubGVuZ3RoLHM9MDtpZih0eXBlb2Ygcj09XCJudW1iZXJcIilmb3IoO3M8cjtzKyspZVtpKytdPW5bc107ZWxzZSB3aGlsZShuW3NdIT09dCllW2krK109bltzKytdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9W10scz0wLG89ZS5sZW5ndGg7bj0hIW47Zm9yKDtzPG87cysrKXI9ISF0KGVbc10scyksbiE9PXImJmkucHVzaChlW3NdKTtyZXR1cm4gaX0sbWFwOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxzLG89W10sdT0wLGE9ZS5sZW5ndGgsZj1lIGluc3RhbmNlb2Ygdnx8YSE9PXQmJnR5cGVvZiBhPT1cIm51bWJlclwiJiYoYT4wJiZlWzBdJiZlW2EtMV18fGE9PT0wfHx2LmlzQXJyYXkoZSkpO2lmKGYpZm9yKDt1PGE7dSsrKWk9bihlW3VdLHUsciksaSE9bnVsbCYmKG9bby5sZW5ndGhdPWkpO2Vsc2UgZm9yKHMgaW4gZSlpPW4oZVtzXSxzLHIpLGkhPW51bGwmJihvW28ubGVuZ3RoXT1pKTtyZXR1cm4gby5jb25jYXQuYXBwbHkoW10sbyl9LGd1aWQ6MSxwcm94eTpmdW5jdGlvbihlLG4pe3ZhciByLGkscztyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCImJihyPWVbbl0sbj1lLGU9ciksdi5pc0Z1bmN0aW9uKGUpPyhpPWwuY2FsbChhcmd1bWVudHMsMikscz1mdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KG4saS5jb25jYXQobC5jYWxsKGFyZ3VtZW50cykpKX0scy5ndWlkPWUuZ3VpZD1lLmd1aWR8fHYuZ3VpZCsrLHMpOnR9LGFjY2VzczpmdW5jdGlvbihlLG4scixpLHMsbyx1KXt2YXIgYSxmPXI9PW51bGwsbD0wLGM9ZS5sZW5ndGg7aWYociYmdHlwZW9mIHI9PVwib2JqZWN0XCIpe2ZvcihsIGluIHIpdi5hY2Nlc3MoZSxuLGwscltsXSwxLG8saSk7cz0xfWVsc2UgaWYoaSE9PXQpe2E9dT09PXQmJnYuaXNGdW5jdGlvbihpKSxmJiYoYT8oYT1uLG49ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBhLmNhbGwodihlKSxuKX0pOihuLmNhbGwoZSxpKSxuPW51bGwpKTtpZihuKWZvcig7bDxjO2wrKyluKGVbbF0scixhP2kuY2FsbChlW2xdLGwsbihlW2xdLHIpKTppLHUpO3M9MX1yZXR1cm4gcz9lOmY/bi5jYWxsKGUpOmM/bihlWzBdLHIpOm99LG5vdzpmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfX0pLHYucmVhZHkucHJvbWlzZT1mdW5jdGlvbih0KXtpZighcil7cj12LkRlZmVycmVkKCk7aWYoaS5yZWFkeVN0YXRlPT09XCJjb21wbGV0ZVwiKXNldFRpbWVvdXQodi5yZWFkeSwxKTtlbHNlIGlmKGkuYWRkRXZlbnRMaXN0ZW5lcilpLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsQSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHYucmVhZHksITEpO2Vsc2V7aS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLEEpLGUuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIix2LnJlYWR5KTt2YXIgbj0hMTt0cnl7bj1lLmZyYW1lRWxlbWVudD09bnVsbCYmaS5kb2N1bWVudEVsZW1lbnR9Y2F0Y2gocyl7fW4mJm4uZG9TY3JvbGwmJmZ1bmN0aW9uIG8oKXtpZighdi5pc1JlYWR5KXt0cnl7bi5kb1Njcm9sbChcImxlZnRcIil9Y2F0Y2goZSl7cmV0dXJuIHNldFRpbWVvdXQobyw1MCl9di5yZWFkeSgpfX0oKX19cmV0dXJuIHIucHJvbWlzZSh0KX0sdi5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe09bXCJbb2JqZWN0IFwiK3QrXCJdXCJdPXQudG9Mb3dlckNhc2UoKX0pLG49dihpKTt2YXIgTT17fTt2LkNhbGxiYWNrcz1mdW5jdGlvbihlKXtlPXR5cGVvZiBlPT1cInN0cmluZ1wiP01bZV18fF8oZSk6di5leHRlbmQoe30sZSk7dmFyIG4scixpLHMsbyx1LGE9W10sZj0hZS5vbmNlJiZbXSxsPWZ1bmN0aW9uKHQpe249ZS5tZW1vcnkmJnQscj0hMCx1PXN8fDAscz0wLG89YS5sZW5ndGgsaT0hMDtmb3IoO2EmJnU8bzt1KyspaWYoYVt1XS5hcHBseSh0WzBdLHRbMV0pPT09ITEmJmUuc3RvcE9uRmFsc2Upe249ITE7YnJlYWt9aT0hMSxhJiYoZj9mLmxlbmd0aCYmbChmLnNoaWZ0KCkpOm4/YT1bXTpjLmRpc2FibGUoKSl9LGM9e2FkZDpmdW5jdGlvbigpe2lmKGEpe3ZhciB0PWEubGVuZ3RoOyhmdW5jdGlvbiByKHQpe3YuZWFjaCh0LGZ1bmN0aW9uKHQsbil7dmFyIGk9di50eXBlKG4pO2k9PT1cImZ1bmN0aW9uXCI/KCFlLnVuaXF1ZXx8IWMuaGFzKG4pKSYmYS5wdXNoKG4pOm4mJm4ubGVuZ3RoJiZpIT09XCJzdHJpbmdcIiYmcihuKX0pfSkoYXJndW1lbnRzKSxpP289YS5sZW5ndGg6biYmKHM9dCxsKG4pKX1yZXR1cm4gdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIGEmJnYuZWFjaChhcmd1bWVudHMsZnVuY3Rpb24oZSx0KXt2YXIgbjt3aGlsZSgobj12LmluQXJyYXkodCxhLG4pKT4tMSlhLnNwbGljZShuLDEpLGkmJihuPD1vJiZvLS0sbjw9dSYmdS0tKX0pLHRoaXN9LGhhczpmdW5jdGlvbihlKXtyZXR1cm4gdi5pbkFycmF5KGUsYSk+LTF9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIGE9W10sdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBhPWY9bj10LHRoaXN9LGRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIWF9LGxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gZj10LG58fGMuZGlzYWJsZSgpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiFmfSxmaXJlV2l0aDpmdW5jdGlvbihlLHQpe3JldHVybiB0PXR8fFtdLHQ9W2UsdC5zbGljZT90LnNsaWNlKCk6dF0sYSYmKCFyfHxmKSYmKGk/Zi5wdXNoKHQpOmwodCkpLHRoaXN9LGZpcmU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5maXJlV2l0aCh0aGlzLGFyZ3VtZW50cyksdGhpc30sZmlyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXJ9fTtyZXR1cm4gY30sdi5leHRlbmQoe0RlZmVycmVkOmZ1bmN0aW9uKGUpe3ZhciB0PVtbXCJyZXNvbHZlXCIsXCJkb25lXCIsdi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLHYuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXCJyZWplY3RlZFwiXSxbXCJub3RpZnlcIixcInByb2dyZXNzXCIsdi5DYWxsYmFja3MoXCJtZW1vcnlcIildXSxuPVwicGVuZGluZ1wiLHI9e3N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG59LGFsd2F5czpmdW5jdGlvbigpe3JldHVybiBpLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksdGhpc30sdGhlbjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cztyZXR1cm4gdi5EZWZlcnJlZChmdW5jdGlvbihuKXt2LmVhY2godCxmdW5jdGlvbih0LHIpe3ZhciBzPXJbMF0sbz1lW3RdO2lbclsxXV0odi5pc0Z1bmN0aW9uKG8pP2Z1bmN0aW9uKCl7dmFyIGU9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmdi5pc0Z1bmN0aW9uKGUucHJvbWlzZSk/ZS5wcm9taXNlKCkuZG9uZShuLnJlc29sdmUpLmZhaWwobi5yZWplY3QpLnByb2dyZXNzKG4ubm90aWZ5KTpuW3MrXCJXaXRoXCJdKHRoaXM9PT1pP246dGhpcyxbZV0pfTpuW3NdKX0pLGU9bnVsbH0pLnByb21pc2UoKX0scHJvbWlzZTpmdW5jdGlvbihlKXtyZXR1cm4gZSE9bnVsbD92LmV4dGVuZChlLHIpOnJ9fSxpPXt9O3JldHVybiByLnBpcGU9ci50aGVuLHYuZWFjaCh0LGZ1bmN0aW9uKGUscyl7dmFyIG89c1syXSx1PXNbM107cltzWzFdXT1vLmFkZCx1JiZvLmFkZChmdW5jdGlvbigpe249dX0sdFtlXjFdWzJdLmRpc2FibGUsdFsyXVsyXS5sb2NrKSxpW3NbMF1dPW8uZmlyZSxpW3NbMF0rXCJXaXRoXCJdPW8uZmlyZVdpdGh9KSxyLnByb21pc2UoaSksZSYmZS5jYWxsKGksaSksaX0sd2hlbjpmdW5jdGlvbihlKXt2YXIgdD0wLG49bC5jYWxsKGFyZ3VtZW50cykscj1uLmxlbmd0aCxpPXIhPT0xfHxlJiZ2LmlzRnVuY3Rpb24oZS5wcm9taXNlKT9yOjAscz1pPT09MT9lOnYuRGVmZXJyZWQoKSxvPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7dFtlXT10aGlzLG5bZV09YXJndW1lbnRzLmxlbmd0aD4xP2wuY2FsbChhcmd1bWVudHMpOnIsbj09PXU/cy5ub3RpZnlXaXRoKHQsbik6LS1pfHxzLnJlc29sdmVXaXRoKHQsbil9fSx1LGEsZjtpZihyPjEpe3U9bmV3IEFycmF5KHIpLGE9bmV3IEFycmF5KHIpLGY9bmV3IEFycmF5KHIpO2Zvcig7dDxyO3QrKyluW3RdJiZ2LmlzRnVuY3Rpb24oblt0XS5wcm9taXNlKT9uW3RdLnByb21pc2UoKS5kb25lKG8odCxmLG4pKS5mYWlsKHMucmVqZWN0KS5wcm9ncmVzcyhvKHQsYSx1KSk6LS1pfXJldHVybiBpfHxzLnJlc29sdmVXaXRoKGYsbikscy5wcm9taXNlKCl9fSksdi5zdXBwb3J0PWZ1bmN0aW9uKCl7dmFyIHQsbixyLHMsbyx1LGEsZixsLGMsaCxwPWkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtwLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLFwidFwiKSxwLmlubmVySFRNTD1cIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiLG49cC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikscj1wLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKVswXTtpZighbnx8IXJ8fCFuLmxlbmd0aClyZXR1cm57fTtzPWkuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxvPXMuYXBwZW5kQ2hpbGQoaS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKSx1PXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXSxyLnN0eWxlLmNzc1RleHQ9XCJ0b3A6MXB4O2Zsb2F0OmxlZnQ7b3BhY2l0eTouNVwiLHQ9e2xlYWRpbmdXaGl0ZXNwYWNlOnAuZmlyc3RDaGlsZC5ub2RlVHlwZT09PTMsdGJvZHk6IXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsaHRtbFNlcmlhbGl6ZTohIXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxzdHlsZTovdG9wLy50ZXN0KHIuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpLGhyZWZOb3JtYWxpemVkOnIuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKT09PVwiL2FcIixvcGFjaXR5Oi9eMC41Ly50ZXN0KHIuc3R5bGUub3BhY2l0eSksY3NzRmxvYXQ6ISFyLnN0eWxlLmNzc0Zsb2F0LGNoZWNrT246dS52YWx1ZT09PVwib25cIixvcHRTZWxlY3RlZDpvLnNlbGVjdGVkLGdldFNldEF0dHJpYnV0ZTpwLmNsYXNzTmFtZSE9PVwidFwiLGVuY3R5cGU6ISFpLmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGUsaHRtbDVDbG9uZTppLmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCEwKS5vdXRlckhUTUwhPT1cIjw6bmF2PjwvOm5hdj5cIixib3hNb2RlbDppLmNvbXBhdE1vZGU9PT1cIkNTUzFDb21wYXRcIixzdWJtaXRCdWJibGVzOiEwLGNoYW5nZUJ1YmJsZXM6ITAsZm9jdXNpbkJ1YmJsZXM6ITEsZGVsZXRlRXhwYW5kbzohMCxub0Nsb25lRXZlbnQ6ITAsaW5saW5lQmxvY2tOZWVkc0xheW91dDohMSxzaHJpbmtXcmFwQmxvY2tzOiExLHJlbGlhYmxlTWFyZ2luUmlnaHQ6ITAsYm94U2l6aW5nUmVsaWFibGU6ITAscGl4ZWxQb3NpdGlvbjohMX0sdS5jaGVja2VkPSEwLHQubm9DbG9uZUNoZWNrZWQ9dS5jbG9uZU5vZGUoITApLmNoZWNrZWQscy5kaXNhYmxlZD0hMCx0Lm9wdERpc2FibGVkPSFvLmRpc2FibGVkO3RyeXtkZWxldGUgcC50ZXN0fWNhdGNoKGQpe3QuZGVsZXRlRXhwYW5kbz0hMX0hcC5hZGRFdmVudExpc3RlbmVyJiZwLmF0dGFjaEV2ZW50JiZwLmZpcmVFdmVudCYmKHAuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsaD1mdW5jdGlvbigpe3Qubm9DbG9uZUV2ZW50PSExfSkscC5jbG9uZU5vZGUoITApLmZpcmVFdmVudChcIm9uY2xpY2tcIikscC5kZXRhY2hFdmVudChcIm9uY2xpY2tcIixoKSksdT1pLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSx1LnZhbHVlPVwidFwiLHUuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksdC5yYWRpb1ZhbHVlPXUudmFsdWU9PT1cInRcIix1LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIiksdS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJ0XCIpLHAuYXBwZW5kQ2hpbGQodSksYT1pLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxhLmFwcGVuZENoaWxkKHAubGFzdENoaWxkKSx0LmNoZWNrQ2xvbmU9YS5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsdC5hcHBlbmRDaGVja2VkPXUuY2hlY2tlZCxhLnJlbW92ZUNoaWxkKHUpLGEuYXBwZW5kQ2hpbGQocCk7aWYocC5hdHRhY2hFdmVudClmb3IobCBpbntzdWJtaXQ6ITAsY2hhbmdlOiEwLGZvY3VzaW46ITB9KWY9XCJvblwiK2wsYz1mIGluIHAsY3x8KHAuc2V0QXR0cmlidXRlKGYsXCJyZXR1cm47XCIpLGM9dHlwZW9mIHBbZl09PVwiZnVuY3Rpb25cIiksdFtsK1wiQnViYmxlc1wiXT1jO3JldHVybiB2KGZ1bmN0aW9uKCl7dmFyIG4scixzLG8sdT1cInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO292ZXJmbG93OmhpZGRlbjtcIixhPWkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO2lmKCFhKXJldHVybjtuPWkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuLnN0eWxlLmNzc1RleHQ9XCJ2aXNpYmlsaXR5OmhpZGRlbjtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOnN0YXRpYzt0b3A6MDttYXJnaW4tdG9wOjFweFwiLGEuaW5zZXJ0QmVmb3JlKG4sYS5maXJzdENoaWxkKSxyPWkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuLmFwcGVuZENoaWxkKHIpLHIuaW5uZXJIVE1MPVwiPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiLHM9ci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRkXCIpLHNbMF0uc3R5bGUuY3NzVGV4dD1cInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5Om5vbmVcIixjPXNbMF0ub2Zmc2V0SGVpZ2h0PT09MCxzWzBdLnN0eWxlLmRpc3BsYXk9XCJcIixzWzFdLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdC5yZWxpYWJsZUhpZGRlbk9mZnNldHM9YyYmc1swXS5vZmZzZXRIZWlnaHQ9PT0wLHIuaW5uZXJIVE1MPVwiXCIsci5zdHlsZS5jc3NUZXh0PVwiYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MXB4O2JvcmRlcjoxcHg7ZGlzcGxheTpibG9jazt3aWR0aDo0cHg7bWFyZ2luLXRvcDoxJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MSU7XCIsdC5ib3hTaXppbmc9ci5vZmZzZXRXaWR0aD09PTQsdC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldD1hLm9mZnNldFRvcCE9PTEsZS5nZXRDb21wdXRlZFN0eWxlJiYodC5waXhlbFBvc2l0aW9uPShlLmdldENvbXB1dGVkU3R5bGUocixudWxsKXx8e30pLnRvcCE9PVwiMSVcIix0LmJveFNpemluZ1JlbGlhYmxlPShlLmdldENvbXB1dGVkU3R5bGUocixudWxsKXx8e3dpZHRoOlwiNHB4XCJ9KS53aWR0aD09PVwiNHB4XCIsbz1pLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksby5zdHlsZS5jc3NUZXh0PXIuc3R5bGUuY3NzVGV4dD11LG8uc3R5bGUubWFyZ2luUmlnaHQ9by5zdHlsZS53aWR0aD1cIjBcIixyLnN0eWxlLndpZHRoPVwiMXB4XCIsci5hcHBlbmRDaGlsZChvKSx0LnJlbGlhYmxlTWFyZ2luUmlnaHQ9IXBhcnNlRmxvYXQoKGUuZ2V0Q29tcHV0ZWRTdHlsZShvLG51bGwpfHx7fSkubWFyZ2luUmlnaHQpKSx0eXBlb2Ygci5zdHlsZS56b29tIT1cInVuZGVmaW5lZFwiJiYoci5pbm5lckhUTUw9XCJcIixyLnN0eWxlLmNzc1RleHQ9dStcIndpZHRoOjFweDtwYWRkaW5nOjFweDtkaXNwbGF5OmlubGluZTt6b29tOjFcIix0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQ9ci5vZmZzZXRXaWR0aD09PTMsci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixyLnN0eWxlLm92ZXJmbG93PVwidmlzaWJsZVwiLHIuaW5uZXJIVE1MPVwiPGRpdj48L2Rpdj5cIixyLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9XCI1cHhcIix0LnNocmlua1dyYXBCbG9ja3M9ci5vZmZzZXRXaWR0aCE9PTMsbi5zdHlsZS56b29tPTEpLGEucmVtb3ZlQ2hpbGQobiksbj1yPXM9bz1udWxsfSksYS5yZW1vdmVDaGlsZChwKSxuPXI9cz1vPXU9YT1wPW51bGwsdH0oKTt2YXIgRD0vKD86XFx7W1xcc1xcU10qXFx9fFxcW1tcXHNcXFNdKlxcXSkkLyxQPS8oW0EtWl0pL2c7di5leHRlbmQoe2NhY2hlOnt9LGRlbGV0ZWRJZHM6W10sdXVpZDowLGV4cGFuZG86XCJqUXVlcnlcIisodi5mbi5qcXVlcnkrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksbm9EYXRhOntlbWJlZDohMCxvYmplY3Q6XCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIixhcHBsZXQ6ITB9LGhhc0RhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZS5ub2RlVHlwZT92LmNhY2hlW2Vbdi5leHBhbmRvXV06ZVt2LmV4cGFuZG9dLCEhZSYmIUIoZSl9LGRhdGE6ZnVuY3Rpb24oZSxuLHIsaSl7aWYoIXYuYWNjZXB0RGF0YShlKSlyZXR1cm47dmFyIHMsbyx1PXYuZXhwYW5kbyxhPXR5cGVvZiBuPT1cInN0cmluZ1wiLGY9ZS5ub2RlVHlwZSxsPWY/di5jYWNoZTplLGM9Zj9lW3VdOmVbdV0mJnU7aWYoKCFjfHwhbFtjXXx8IWkmJiFsW2NdLmRhdGEpJiZhJiZyPT09dClyZXR1cm47Y3x8KGY/ZVt1XT1jPXYuZGVsZXRlZElkcy5wb3AoKXx8di5ndWlkKys6Yz11KSxsW2NdfHwobFtjXT17fSxmfHwobFtjXS50b0pTT049di5ub29wKSk7aWYodHlwZW9mIG49PVwib2JqZWN0XCJ8fHR5cGVvZiBuPT1cImZ1bmN0aW9uXCIpaT9sW2NdPXYuZXh0ZW5kKGxbY10sbik6bFtjXS5kYXRhPXYuZXh0ZW5kKGxbY10uZGF0YSxuKTtyZXR1cm4gcz1sW2NdLGl8fChzLmRhdGF8fChzLmRhdGE9e30pLHM9cy5kYXRhKSxyIT09dCYmKHNbdi5jYW1lbENhc2UobildPXIpLGE/KG89c1tuXSxvPT1udWxsJiYobz1zW3YuY2FtZWxDYXNlKG4pXSkpOm89cyxvfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCxuKXtpZighdi5hY2NlcHREYXRhKGUpKXJldHVybjt2YXIgcixpLHMsbz1lLm5vZGVUeXBlLHU9bz92LmNhY2hlOmUsYT1vP2Vbdi5leHBhbmRvXTp2LmV4cGFuZG87aWYoIXVbYV0pcmV0dXJuO2lmKHQpe3I9bj91W2FdOnVbYV0uZGF0YTtpZihyKXt2LmlzQXJyYXkodCl8fCh0IGluIHI/dD1bdF06KHQ9di5jYW1lbENhc2UodCksdCBpbiByP3Q9W3RdOnQ9dC5zcGxpdChcIiBcIikpKTtmb3IoaT0wLHM9dC5sZW5ndGg7aTxzO2krKylkZWxldGUgclt0W2ldXTtpZighKG4/Qjp2LmlzRW1wdHlPYmplY3QpKHIpKXJldHVybn19aWYoIW4pe2RlbGV0ZSB1W2FdLmRhdGE7aWYoIUIodVthXSkpcmV0dXJufW8/di5jbGVhbkRhdGEoW2VdLCEwKTp2LnN1cHBvcnQuZGVsZXRlRXhwYW5kb3x8dSE9dS53aW5kb3c/ZGVsZXRlIHVbYV06dVthXT1udWxsfSxfZGF0YTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHYuZGF0YShlLHQsbiwhMCl9LGFjY2VwdERhdGE6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZSYmdi5ub0RhdGFbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4hdHx8dCE9PSEwJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIik9PT10fX0pLHYuZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxzLG8sdSxhPXRoaXNbMF0sZj0wLGw9bnVsbDtpZihlPT09dCl7aWYodGhpcy5sZW5ndGgpe2w9di5kYXRhKGEpO2lmKGEubm9kZVR5cGU9PT0xJiYhdi5fZGF0YShhLFwicGFyc2VkQXR0cnNcIikpe3M9YS5hdHRyaWJ1dGVzO2Zvcih1PXMubGVuZ3RoO2Y8dTtmKyspbz1zW2ZdLm5hbWUsby5pbmRleE9mKFwiZGF0YS1cIil8fChvPXYuY2FtZWxDYXNlKG8uc3Vic3RyaW5nKDUpKSxIKGEsbyxsW29dKSk7di5fZGF0YShhLFwicGFyc2VkQXR0cnNcIiwhMCl9fXJldHVybiBsfXJldHVybiB0eXBlb2YgZT09XCJvYmplY3RcIj90aGlzLmVhY2goZnVuY3Rpb24oKXt2LmRhdGEodGhpcyxlKX0pOihyPWUuc3BsaXQoXCIuXCIsMiksclsxXT1yWzFdP1wiLlwiK3JbMV06XCJcIixpPXJbMV0rXCIhXCIsdi5hY2Nlc3ModGhpcyxmdW5jdGlvbihuKXtpZihuPT09dClyZXR1cm4gbD10aGlzLnRyaWdnZXJIYW5kbGVyKFwiZ2V0RGF0YVwiK2ksW3JbMF1dKSxsPT09dCYmYSYmKGw9di5kYXRhKGEsZSksbD1IKGEsZSxsKSksbD09PXQmJnJbMV0/dGhpcy5kYXRhKHJbMF0pOmw7clsxXT1uLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXYodGhpcyk7dC50cmlnZ2VySGFuZGxlcihcInNldERhdGFcIitpLHIpLHYuZGF0YSh0aGlzLGUsbiksdC50cmlnZ2VySGFuZGxlcihcImNoYW5nZURhdGFcIitpLHIpfSl9LG51bGwsbixhcmd1bWVudHMubGVuZ3RoPjEsbnVsbCwhMSkpfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2LnJlbW92ZURhdGEodGhpcyxlKX0pfX0pLHYuZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoZSlyZXR1cm4gdD0odHx8XCJmeFwiKStcInF1ZXVlXCIscj12Ll9kYXRhKGUsdCksbiYmKCFyfHx2LmlzQXJyYXkobik/cj12Ll9kYXRhKGUsdCx2Lm1ha2VBcnJheShuKSk6ci5wdXNoKG4pKSxyfHxbXX0sZGVxdWV1ZTpmdW5jdGlvbihlLHQpe3Q9dHx8XCJmeFwiO3ZhciBuPXYucXVldWUoZSx0KSxyPW4ubGVuZ3RoLGk9bi5zaGlmdCgpLHM9di5fcXVldWVIb29rcyhlLHQpLG89ZnVuY3Rpb24oKXt2LmRlcXVldWUoZSx0KX07aT09PVwiaW5wcm9ncmVzc1wiJiYoaT1uLnNoaWZ0KCksci0tKSxpJiYodD09PVwiZnhcIiYmbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSxkZWxldGUgcy5zdG9wLGkuY2FsbChlLG8scykpLCFyJiZzJiZzLmVtcHR5LmZpcmUoKX0sX3F1ZXVlSG9va3M6ZnVuY3Rpb24oZSx0KXt2YXIgbj10K1wicXVldWVIb29rc1wiO3JldHVybiB2Ll9kYXRhKGUsbil8fHYuX2RhdGEoZSxuLHtlbXB0eTp2LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe3YucmVtb3ZlRGF0YShlLHQrXCJxdWV1ZVwiLCEwKSx2LnJlbW92ZURhdGEoZSxuLCEwKX0pfSl9fSksdi5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGUsbil7dmFyIHI9MjtyZXR1cm4gdHlwZW9mIGUhPVwic3RyaW5nXCImJihuPWUsZT1cImZ4XCIsci0tKSxhcmd1bWVudHMubGVuZ3RoPHI/di5xdWV1ZSh0aGlzWzBdLGUpOm49PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9di5xdWV1ZSh0aGlzLGUsbik7di5fcXVldWVIb29rcyh0aGlzLGUpLGU9PT1cImZ4XCImJnRbMF0hPT1cImlucHJvZ3Jlc3NcIiYmdi5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVxdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7di5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVsYXk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT12LmZ4P3YuZnguc3BlZWRzW2VdfHxlOmUsdD10fHxcImZ4XCIsdGhpcy5xdWV1ZSh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9c2V0VGltZW91dCh0LGUpO24uc3RvcD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChyKX19KX0sY2xlYXJRdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5xdWV1ZShlfHxcImZ4XCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGUsbil7dmFyIHIsaT0xLHM9di5EZWZlcnJlZCgpLG89dGhpcyx1PXRoaXMubGVuZ3RoLGE9ZnVuY3Rpb24oKXstLWl8fHMucmVzb2x2ZVdpdGgobyxbb10pfTt0eXBlb2YgZSE9XCJzdHJpbmdcIiYmKG49ZSxlPXQpLGU9ZXx8XCJmeFwiO3doaWxlKHUtLSlyPXYuX2RhdGEob1t1XSxlK1wicXVldWVIb29rc1wiKSxyJiZyLmVtcHR5JiYoaSsrLHIuZW1wdHkuYWRkKGEpKTtyZXR1cm4gYSgpLHMucHJvbWlzZShuKX19KTt2YXIgaixGLEkscT0vW1xcdFxcclxcbl0vZyxSPS9cXHIvZyxVPS9eKD86YnV0dG9ufGlucHV0KSQvaSx6PS9eKD86YnV0dG9ufGlucHV0fG9iamVjdHxzZWxlY3R8dGV4dGFyZWEpJC9pLFc9L15hKD86cmVhfCkkL2ksWD0vXig/OmF1dG9mb2N1c3xhdXRvcGxheXxhc3luY3xjaGVja2VkfGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkfHNlbGVjdGVkKSQvaSxWPXYuc3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGU7di5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdi5hY2Nlc3ModGhpcyx2LmF0dHIsZSx0LGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3YucmVtb3ZlQXR0cih0aGlzLGUpfSl9LHByb3A6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdi5hY2Nlc3ModGhpcyx2LnByb3AsZSx0LGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9di5wcm9wRml4W2VdfHxlLHRoaXMuZWFjaChmdW5jdGlvbigpe3RyeXt0aGlzW2VdPXQsZGVsZXRlIHRoaXNbZV19Y2F0Y2gobil7fX0pfSxhZGRDbGFzczpmdW5jdGlvbihlKXt2YXIgdCxuLHIsaSxzLG8sdTtpZih2LmlzRnVuY3Rpb24oZSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbih0KXt2KHRoaXMpLmFkZENsYXNzKGUuY2FsbCh0aGlzLHQsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGUmJnR5cGVvZiBlPT1cInN0cmluZ1wiKXt0PWUuc3BsaXQoeSk7Zm9yKG49MCxyPXRoaXMubGVuZ3RoO248cjtuKyspe2k9dGhpc1tuXTtpZihpLm5vZGVUeXBlPT09MSlpZighaS5jbGFzc05hbWUmJnQubGVuZ3RoPT09MSlpLmNsYXNzTmFtZT1lO2Vsc2V7cz1cIiBcIitpLmNsYXNzTmFtZStcIiBcIjtmb3Iobz0wLHU9dC5sZW5ndGg7bzx1O28rKylzLmluZGV4T2YoXCIgXCIrdFtvXStcIiBcIik8MCYmKHMrPXRbb10rXCIgXCIpO2kuY2xhc3NOYW1lPXYudHJpbShzKX19fXJldHVybiB0aGlzfSxyZW1vdmVDbGFzczpmdW5jdGlvbihlKXt2YXIgbixyLGkscyxvLHUsYTtpZih2LmlzRnVuY3Rpb24oZSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbih0KXt2KHRoaXMpLnJlbW92ZUNsYXNzKGUuY2FsbCh0aGlzLHQsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGUmJnR5cGVvZiBlPT1cInN0cmluZ1wifHxlPT09dCl7bj0oZXx8XCJcIikuc3BsaXQoeSk7Zm9yKHU9MCxhPXRoaXMubGVuZ3RoO3U8YTt1Kyspe2k9dGhpc1t1XTtpZihpLm5vZGVUeXBlPT09MSYmaS5jbGFzc05hbWUpe3I9KFwiIFwiK2kuY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKHEsXCIgXCIpO2ZvcihzPTAsbz1uLmxlbmd0aDtzPG87cysrKXdoaWxlKHIuaW5kZXhPZihcIiBcIituW3NdK1wiIFwiKT49MClyPXIucmVwbGFjZShcIiBcIituW3NdK1wiIFwiLFwiIFwiKTtpLmNsYXNzTmFtZT1lP3YudHJpbShyKTpcIlwifX19cmV0dXJuIHRoaXN9LHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKGUsdCl7dmFyIG49dHlwZW9mIGUscj10eXBlb2YgdD09XCJib29sZWFuXCI7cmV0dXJuIHYuaXNGdW5jdGlvbihlKT90aGlzLmVhY2goZnVuY3Rpb24obil7dih0aGlzKS50b2dnbGVDbGFzcyhlLmNhbGwodGhpcyxuLHRoaXMuY2xhc3NOYW1lLHQpLHQpfSk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYobj09PVwic3RyaW5nXCIpe3ZhciBpLHM9MCxvPXYodGhpcyksdT10LGE9ZS5zcGxpdCh5KTt3aGlsZShpPWFbcysrXSl1PXI/dTohby5oYXNDbGFzcyhpKSxvW3U/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0oaSl9ZWxzZSBpZihuPT09XCJ1bmRlZmluZWRcInx8bj09PVwiYm9vbGVhblwiKXRoaXMuY2xhc3NOYW1lJiZ2Ll9kYXRhKHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIsdGhpcy5jbGFzc05hbWUpLHRoaXMuY2xhc3NOYW1lPXRoaXMuY2xhc3NOYW1lfHxlPT09ITE/XCJcIjp2Ll9kYXRhKHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIpfHxcIlwifSl9LGhhc0NsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0PVwiIFwiK2UrXCIgXCIsbj0wLHI9dGhpcy5sZW5ndGg7Zm9yKDtuPHI7bisrKWlmKHRoaXNbbl0ubm9kZVR5cGU9PT0xJiYoXCIgXCIrdGhpc1tuXS5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UocSxcIiBcIikuaW5kZXhPZih0KT49MClyZXR1cm4hMDtyZXR1cm4hMX0sdmFsOmZ1bmN0aW9uKGUpe3ZhciBuLHIsaSxzPXRoaXNbMF07aWYoIWFyZ3VtZW50cy5sZW5ndGgpe2lmKHMpcmV0dXJuIG49di52YWxIb29rc1tzLnR5cGVdfHx2LnZhbEhvb2tzW3Mubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sbiYmXCJnZXRcImluIG4mJihyPW4uZ2V0KHMsXCJ2YWx1ZVwiKSkhPT10P3I6KHI9cy52YWx1ZSx0eXBlb2Ygcj09XCJzdHJpbmdcIj9yLnJlcGxhY2UoUixcIlwiKTpyPT1udWxsP1wiXCI6cik7cmV0dXJufXJldHVybiBpPXYuaXNGdW5jdGlvbihlKSx0aGlzLmVhY2goZnVuY3Rpb24ocil7dmFyIHMsbz12KHRoaXMpO2lmKHRoaXMubm9kZVR5cGUhPT0xKXJldHVybjtpP3M9ZS5jYWxsKHRoaXMscixvLnZhbCgpKTpzPWUscz09bnVsbD9zPVwiXCI6dHlwZW9mIHM9PVwibnVtYmVyXCI/cys9XCJcIjp2LmlzQXJyYXkocykmJihzPXYubWFwKHMsZnVuY3Rpb24oZSl7cmV0dXJuIGU9PW51bGw/XCJcIjplK1wiXCJ9KSksbj12LnZhbEhvb2tzW3RoaXMudHlwZV18fHYudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtpZighbnx8IShcInNldFwiaW4gbil8fG4uc2V0KHRoaXMscyxcInZhbHVlXCIpPT09dCl0aGlzLnZhbHVlPXN9KX19KSx2LmV4dGVuZCh7dmFsSG9va3M6e29wdGlvbjp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUuYXR0cmlidXRlcy52YWx1ZTtyZXR1cm4hdHx8dC5zcGVjaWZpZWQ/ZS52YWx1ZTplLnRleHR9fSxzZWxlY3Q6e2dldDpmdW5jdGlvbihlKXt2YXIgdCxuLHI9ZS5vcHRpb25zLGk9ZS5zZWxlY3RlZEluZGV4LHM9ZS50eXBlPT09XCJzZWxlY3Qtb25lXCJ8fGk8MCxvPXM/bnVsbDpbXSx1PXM/aSsxOnIubGVuZ3RoLGE9aTwwP3U6cz9pOjA7Zm9yKDthPHU7YSsrKXtuPXJbYV07aWYoKG4uc2VsZWN0ZWR8fGE9PT1pKSYmKHYuc3VwcG9ydC5vcHREaXNhYmxlZD8hbi5kaXNhYmxlZDpuLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpPT09bnVsbCkmJighbi5wYXJlbnROb2RlLmRpc2FibGVkfHwhdi5ub2RlTmFtZShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe3Q9dihuKS52YWwoKTtpZihzKXJldHVybiB0O28ucHVzaCh0KX19cmV0dXJuIG99LHNldDpmdW5jdGlvbihlLHQpe3ZhciBuPXYubWFrZUFycmF5KHQpO3JldHVybiB2KGUpLmZpbmQoXCJvcHRpb25cIikuZWFjaChmdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWQ9di5pbkFycmF5KHYodGhpcykudmFsKCksbik+PTB9KSxuLmxlbmd0aHx8KGUuc2VsZWN0ZWRJbmRleD0tMSksbn19fSxhdHRyRm46e30sYXR0cjpmdW5jdGlvbihlLG4scixpKXt2YXIgcyxvLHUsYT1lLm5vZGVUeXBlO2lmKCFlfHxhPT09M3x8YT09PTh8fGE9PT0yKXJldHVybjtpZihpJiZ2LmlzRnVuY3Rpb24odi5mbltuXSkpcmV0dXJuIHYoZSlbbl0ocik7aWYodHlwZW9mIGUuZ2V0QXR0cmlidXRlPT1cInVuZGVmaW5lZFwiKXJldHVybiB2LnByb3AoZSxuLHIpO3U9YSE9PTF8fCF2LmlzWE1MRG9jKGUpLHUmJihuPW4udG9Mb3dlckNhc2UoKSxvPXYuYXR0ckhvb2tzW25dfHwoWC50ZXN0KG4pP0Y6aikpO2lmKHIhPT10KXtpZihyPT09bnVsbCl7di5yZW1vdmVBdHRyKGUsbik7cmV0dXJufXJldHVybiBvJiZcInNldFwiaW4gbyYmdSYmKHM9by5zZXQoZSxyLG4pKSE9PXQ/czooZS5zZXRBdHRyaWJ1dGUobixyK1wiXCIpLHIpfXJldHVybiBvJiZcImdldFwiaW4gbyYmdSYmKHM9by5nZXQoZSxuKSkhPT1udWxsP3M6KHM9ZS5nZXRBdHRyaWJ1dGUobikscz09PW51bGw/dDpzKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxzLG89MDtpZih0JiZlLm5vZGVUeXBlPT09MSl7cj10LnNwbGl0KHkpO2Zvcig7bzxyLmxlbmd0aDtvKyspaT1yW29dLGkmJihuPXYucHJvcEZpeFtpXXx8aSxzPVgudGVzdChpKSxzfHx2LmF0dHIoZSxpLFwiXCIpLGUucmVtb3ZlQXR0cmlidXRlKFY/aTpuKSxzJiZuIGluIGUmJihlW25dPSExKSl9fSxhdHRySG9va3M6e3R5cGU6e3NldDpmdW5jdGlvbihlLHQpe2lmKFUudGVzdChlLm5vZGVOYW1lKSYmZS5wYXJlbnROb2RlKXYuZXJyb3IoXCJ0eXBlIHByb3BlcnR5IGNhbid0IGJlIGNoYW5nZWRcIik7ZWxzZSBpZighdi5zdXBwb3J0LnJhZGlvVmFsdWUmJnQ9PT1cInJhZGlvXCImJnYubm9kZU5hbWUoZSxcImlucHV0XCIpKXt2YXIgbj1lLnZhbHVlO3JldHVybiBlLnNldEF0dHJpYnV0ZShcInR5cGVcIix0KSxuJiYoZS52YWx1ZT1uKSx0fX19LHZhbHVlOntnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaiYmdi5ub2RlTmFtZShlLFwiYnV0dG9uXCIpP2ouZ2V0KGUsdCk6dCBpbiBlP2UudmFsdWU6bnVsbH0sc2V0OmZ1bmN0aW9uKGUsdCxuKXtpZihqJiZ2Lm5vZGVOYW1lKGUsXCJidXR0b25cIikpcmV0dXJuIGouc2V0KGUsdCxuKTtlLnZhbHVlPXR9fX0scHJvcEZpeDp7dGFiaW5kZXg6XCJ0YWJJbmRleFwiLHJlYWRvbmx5OlwicmVhZE9ubHlcIixcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwiLG1heGxlbmd0aDpcIm1heExlbmd0aFwiLGNlbGxzcGFjaW5nOlwiY2VsbFNwYWNpbmdcIixjZWxscGFkZGluZzpcImNlbGxQYWRkaW5nXCIscm93c3BhbjpcInJvd1NwYW5cIixjb2xzcGFuOlwiY29sU3BhblwiLHVzZW1hcDpcInVzZU1hcFwiLGZyYW1lYm9yZGVyOlwiZnJhbWVCb3JkZXJcIixjb250ZW50ZWRpdGFibGU6XCJjb250ZW50RWRpdGFibGVcIn0scHJvcDpmdW5jdGlvbihlLG4scil7dmFyIGkscyxvLHU9ZS5ub2RlVHlwZTtpZighZXx8dT09PTN8fHU9PT04fHx1PT09MilyZXR1cm47cmV0dXJuIG89dSE9PTF8fCF2LmlzWE1MRG9jKGUpLG8mJihuPXYucHJvcEZpeFtuXXx8bixzPXYucHJvcEhvb2tzW25dKSxyIT09dD9zJiZcInNldFwiaW4gcyYmKGk9cy5zZXQoZSxyLG4pKSE9PXQ/aTplW25dPXI6cyYmXCJnZXRcImluIHMmJihpPXMuZ2V0KGUsbikpIT09bnVsbD9pOmVbbl19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihlKXt2YXIgbj1lLmdldEF0dHJpYnV0ZU5vZGUoXCJ0YWJpbmRleFwiKTtyZXR1cm4gbiYmbi5zcGVjaWZpZWQ/cGFyc2VJbnQobi52YWx1ZSwxMCk6ei50ZXN0KGUubm9kZU5hbWUpfHxXLnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOnR9fX19KSxGPXtnZXQ6ZnVuY3Rpb24oZSxuKXt2YXIgcixpPXYucHJvcChlLG4pO3JldHVybiBpPT09ITB8fHR5cGVvZiBpIT1cImJvb2xlYW5cIiYmKHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSYmci5ub2RlVmFsdWUhPT0hMT9uLnRvTG93ZXJDYXNlKCk6dH0sc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtyZXR1cm4gdD09PSExP3YucmVtb3ZlQXR0cihlLG4pOihyPXYucHJvcEZpeFtuXXx8bixyIGluIGUmJihlW3JdPSEwKSxlLnNldEF0dHJpYnV0ZShuLG4udG9Mb3dlckNhc2UoKSkpLG59fSxWfHwoST17bmFtZTohMCxpZDohMCxjb29yZHM6ITB9LGo9di52YWxIb29rcy5idXR0b249e2dldDpmdW5jdGlvbihlLG4pe3ZhciByO3JldHVybiByPWUuZ2V0QXR0cmlidXRlTm9kZShuKSxyJiYoSVtuXT9yLnZhbHVlIT09XCJcIjpyLnNwZWNpZmllZCk/ci52YWx1ZTp0fSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUuZ2V0QXR0cmlidXRlTm9kZShuKTtyZXR1cm4gcnx8KHI9aS5jcmVhdGVBdHRyaWJ1dGUobiksZS5zZXRBdHRyaWJ1dGVOb2RlKHIpKSxyLnZhbHVlPXQrXCJcIn19LHYuZWFjaChbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLGZ1bmN0aW9uKGUsdCl7di5hdHRySG9va3NbdF09di5leHRlbmQodi5hdHRySG9va3NbdF0se3NldDpmdW5jdGlvbihlLG4pe2lmKG49PT1cIlwiKXJldHVybiBlLnNldEF0dHJpYnV0ZSh0LFwiYXV0b1wiKSxufX0pfSksdi5hdHRySG9va3MuY29udGVudGVkaXRhYmxlPXtnZXQ6ai5nZXQsc2V0OmZ1bmN0aW9uKGUsdCxuKXt0PT09XCJcIiYmKHQ9XCJmYWxzZVwiKSxqLnNldChlLHQsbil9fSksdi5zdXBwb3J0LmhyZWZOb3JtYWxpemVkfHx2LmVhY2goW1wiaHJlZlwiLFwic3JjXCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLGZ1bmN0aW9uKGUsbil7di5hdHRySG9va3Nbbl09di5leHRlbmQodi5hdHRySG9va3Nbbl0se2dldDpmdW5jdGlvbihlKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShuLDIpO3JldHVybiByPT09bnVsbD90OnJ9fSl9KSx2LnN1cHBvcnQuc3R5bGV8fCh2LmF0dHJIb29rcy5zdHlsZT17Z2V0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnN0eWxlLmNzc1RleHQudG9Mb3dlckNhc2UoKXx8dH0sc2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuc3R5bGUuY3NzVGV4dD10K1wiXCJ9fSksdi5zdXBwb3J0Lm9wdFNlbGVjdGVkfHwodi5wcm9wSG9va3Muc2VsZWN0ZWQ9di5leHRlbmQodi5wcm9wSG9va3Muc2VsZWN0ZWQse2dldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJih0LnNlbGVjdGVkSW5kZXgsdC5wYXJlbnROb2RlJiZ0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCksbnVsbH19KSksdi5zdXBwb3J0LmVuY3R5cGV8fCh2LnByb3BGaXguZW5jdHlwZT1cImVuY29kaW5nXCIpLHYuc3VwcG9ydC5jaGVja09ufHx2LmVhY2goW1wicmFkaW9cIixcImNoZWNrYm94XCJdLGZ1bmN0aW9uKCl7di52YWxIb29rc1t0aGlzXT17Z2V0OmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpPT09bnVsbD9cIm9uXCI6ZS52YWx1ZX19fSksdi5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe3YudmFsSG9va3NbdGhpc109di5leHRlbmQodi52YWxIb29rc1t0aGlzXSx7c2V0OmZ1bmN0aW9uKGUsdCl7aWYodi5pc0FycmF5KHQpKXJldHVybiBlLmNoZWNrZWQ9di5pbkFycmF5KHYoZSkudmFsKCksdCk+PTB9fSl9KTt2YXIgJD0vXig/OnRleHRhcmVhfGlucHV0fHNlbGVjdCkkL2ksSj0vXihbXlxcLl0qfCkoPzpcXC4oLispfCkkLyxLPS8oPzpefFxccylob3ZlcihcXC5cXFMrfClcXGIvLFE9L15rZXkvLEc9L14oPzptb3VzZXxjb250ZXh0bWVudSl8Y2xpY2svLFk9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFo9ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZXZlbnQuc3BlY2lhbC5ob3Zlcj9lOmUucmVwbGFjZShLLFwibW91c2VlbnRlciQxIG1vdXNlbGVhdmUkMVwiKX07di5ldmVudD17YWRkOmZ1bmN0aW9uKGUsbixyLGkscyl7dmFyIG8sdSxhLGYsbCxjLGgscCxkLG0sZztpZihlLm5vZGVUeXBlPT09M3x8ZS5ub2RlVHlwZT09PTh8fCFufHwhcnx8IShvPXYuX2RhdGEoZSkpKXJldHVybjtyLmhhbmRsZXImJihkPXIscj1kLmhhbmRsZXIscz1kLnNlbGVjdG9yKSxyLmd1aWR8fChyLmd1aWQ9di5ndWlkKyspLGE9by5ldmVudHMsYXx8KG8uZXZlbnRzPWE9e30pLHU9by5oYW5kbGUsdXx8KG8uaGFuZGxlPXU9ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiB2PT1cInVuZGVmaW5lZFwifHwhIWUmJnYuZXZlbnQudHJpZ2dlcmVkPT09ZS50eXBlP3Q6di5ldmVudC5kaXNwYXRjaC5hcHBseSh1LmVsZW0sYXJndW1lbnRzKX0sdS5lbGVtPWUpLG49di50cmltKFoobikpLnNwbGl0KFwiIFwiKTtmb3IoZj0wO2Y8bi5sZW5ndGg7ZisrKXtsPUouZXhlYyhuW2ZdKXx8W10sYz1sWzFdLGg9KGxbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZz12LmV2ZW50LnNwZWNpYWxbY118fHt9LGM9KHM/Zy5kZWxlZ2F0ZVR5cGU6Zy5iaW5kVHlwZSl8fGMsZz12LmV2ZW50LnNwZWNpYWxbY118fHt9LHA9di5leHRlbmQoe3R5cGU6YyxvcmlnVHlwZTpsWzFdLGRhdGE6aSxoYW5kbGVyOnIsZ3VpZDpyLmd1aWQsc2VsZWN0b3I6cyxuZWVkc0NvbnRleHQ6cyYmdi5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KHMpLG5hbWVzcGFjZTpoLmpvaW4oXCIuXCIpfSxkKSxtPWFbY107aWYoIW0pe209YVtjXT1bXSxtLmRlbGVnYXRlQ291bnQ9MDtpZighZy5zZXR1cHx8Zy5zZXR1cC5jYWxsKGUsaSxoLHUpPT09ITEpZS5hZGRFdmVudExpc3RlbmVyP2UuYWRkRXZlbnRMaXN0ZW5lcihjLHUsITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoXCJvblwiK2MsdSl9Zy5hZGQmJihnLmFkZC5jYWxsKGUscCkscC5oYW5kbGVyLmd1aWR8fChwLmhhbmRsZXIuZ3VpZD1yLmd1aWQpKSxzP20uc3BsaWNlKG0uZGVsZWdhdGVDb3VudCsrLDAscCk6bS5wdXNoKHApLHYuZXZlbnQuZ2xvYmFsW2NdPSEwfWU9bnVsbH0sZ2xvYmFsOnt9LHJlbW92ZTpmdW5jdGlvbihlLHQsbixyLGkpe3ZhciBzLG8sdSxhLGYsbCxjLGgscCxkLG0sZz12Lmhhc0RhdGEoZSkmJnYuX2RhdGEoZSk7aWYoIWd8fCEoaD1nLmV2ZW50cykpcmV0dXJuO3Q9di50cmltKFoodHx8XCJcIikpLnNwbGl0KFwiIFwiKTtmb3Iocz0wO3M8dC5sZW5ndGg7cysrKXtvPUouZXhlYyh0W3NdKXx8W10sdT1hPW9bMV0sZj1vWzJdO2lmKCF1KXtmb3IodSBpbiBoKXYuZXZlbnQucmVtb3ZlKGUsdSt0W3NdLG4sciwhMCk7Y29udGludWV9cD12LmV2ZW50LnNwZWNpYWxbdV18fHt9LHU9KHI/cC5kZWxlZ2F0ZVR5cGU6cC5iaW5kVHlwZSl8fHUsZD1oW3VdfHxbXSxsPWQubGVuZ3RoLGY9Zj9uZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIrZi5zcGxpdChcIi5cIikuc29ydCgpLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspbT1kW2NdLChpfHxhPT09bS5vcmlnVHlwZSkmJighbnx8bi5ndWlkPT09bS5ndWlkKSYmKCFmfHxmLnRlc3QobS5uYW1lc3BhY2UpKSYmKCFyfHxyPT09bS5zZWxlY3Rvcnx8cj09PVwiKipcIiYmbS5zZWxlY3RvcikmJihkLnNwbGljZShjLS0sMSksbS5zZWxlY3RvciYmZC5kZWxlZ2F0ZUNvdW50LS0scC5yZW1vdmUmJnAucmVtb3ZlLmNhbGwoZSxtKSk7ZC5sZW5ndGg9PT0wJiZsIT09ZC5sZW5ndGgmJigoIXAudGVhcmRvd258fHAudGVhcmRvd24uY2FsbChlLGYsZy5oYW5kbGUpPT09ITEpJiZ2LnJlbW92ZUV2ZW50KGUsdSxnLmhhbmRsZSksZGVsZXRlIGhbdV0pfXYuaXNFbXB0eU9iamVjdChoKSYmKGRlbGV0ZSBnLmhhbmRsZSx2LnJlbW92ZURhdGEoZSxcImV2ZW50c1wiLCEwKSl9LGN1c3RvbUV2ZW50OntnZXREYXRhOiEwLHNldERhdGE6ITAsY2hhbmdlRGF0YTohMH0sdHJpZ2dlcjpmdW5jdGlvbihuLHIscyxvKXtpZighc3x8cy5ub2RlVHlwZSE9PTMmJnMubm9kZVR5cGUhPT04KXt2YXIgdSxhLGYsbCxjLGgscCxkLG0sZyx5PW4udHlwZXx8bixiPVtdO2lmKFkudGVzdCh5K3YuZXZlbnQudHJpZ2dlcmVkKSlyZXR1cm47eS5pbmRleE9mKFwiIVwiKT49MCYmKHk9eS5zbGljZSgwLC0xKSxhPSEwKSx5LmluZGV4T2YoXCIuXCIpPj0wJiYoYj15LnNwbGl0KFwiLlwiKSx5PWIuc2hpZnQoKSxiLnNvcnQoKSk7aWYoKCFzfHx2LmV2ZW50LmN1c3RvbUV2ZW50W3ldKSYmIXYuZXZlbnQuZ2xvYmFsW3ldKXJldHVybjtuPXR5cGVvZiBuPT1cIm9iamVjdFwiP25bdi5leHBhbmRvXT9uOm5ldyB2LkV2ZW50KHksbik6bmV3IHYuRXZlbnQoeSksbi50eXBlPXksbi5pc1RyaWdnZXI9ITAsbi5leGNsdXNpdmU9YSxuLm5hbWVzcGFjZT1iLmpvaW4oXCIuXCIpLG4ubmFtZXNwYWNlX3JlPW4ubmFtZXNwYWNlP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitiLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLGg9eS5pbmRleE9mKFwiOlwiKTwwP1wib25cIit5OlwiXCI7aWYoIXMpe3U9di5jYWNoZTtmb3IoZiBpbiB1KXVbZl0uZXZlbnRzJiZ1W2ZdLmV2ZW50c1t5XSYmdi5ldmVudC50cmlnZ2VyKG4scix1W2ZdLmhhbmRsZS5lbGVtLCEwKTtyZXR1cm59bi5yZXN1bHQ9dCxuLnRhcmdldHx8KG4udGFyZ2V0PXMpLHI9ciE9bnVsbD92Lm1ha2VBcnJheShyKTpbXSxyLnVuc2hpZnQobikscD12LmV2ZW50LnNwZWNpYWxbeV18fHt9O2lmKHAudHJpZ2dlciYmcC50cmlnZ2VyLmFwcGx5KHMscik9PT0hMSlyZXR1cm47bT1bW3MscC5iaW5kVHlwZXx8eV1dO2lmKCFvJiYhcC5ub0J1YmJsZSYmIXYuaXNXaW5kb3cocykpe2c9cC5kZWxlZ2F0ZVR5cGV8fHksbD1ZLnRlc3QoZyt5KT9zOnMucGFyZW50Tm9kZTtmb3IoYz1zO2w7bD1sLnBhcmVudE5vZGUpbS5wdXNoKFtsLGddKSxjPWw7Yz09PShzLm93bmVyRG9jdW1lbnR8fGkpJiZtLnB1c2goW2MuZGVmYXVsdFZpZXd8fGMucGFyZW50V2luZG93fHxlLGddKX1mb3IoZj0wO2Y8bS5sZW5ndGgmJiFuLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZisrKWw9bVtmXVswXSxuLnR5cGU9bVtmXVsxXSxkPSh2Ll9kYXRhKGwsXCJldmVudHNcIil8fHt9KVtuLnR5cGVdJiZ2Ll9kYXRhKGwsXCJoYW5kbGVcIiksZCYmZC5hcHBseShsLHIpLGQ9aCYmbFtoXSxkJiZ2LmFjY2VwdERhdGEobCkmJmQuYXBwbHkmJmQuYXBwbHkobCxyKT09PSExJiZuLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIG4udHlwZT15LCFvJiYhbi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmKCFwLl9kZWZhdWx0fHxwLl9kZWZhdWx0LmFwcGx5KHMub3duZXJEb2N1bWVudCxyKT09PSExKSYmKHkhPT1cImNsaWNrXCJ8fCF2Lm5vZGVOYW1lKHMsXCJhXCIpKSYmdi5hY2NlcHREYXRhKHMpJiZoJiZzW3ldJiYoeSE9PVwiZm9jdXNcIiYmeSE9PVwiYmx1clwifHxuLnRhcmdldC5vZmZzZXRXaWR0aCE9PTApJiYhdi5pc1dpbmRvdyhzKSYmKGM9c1toXSxjJiYoc1toXT1udWxsKSx2LmV2ZW50LnRyaWdnZXJlZD15LHNbeV0oKSx2LmV2ZW50LnRyaWdnZXJlZD10LGMmJihzW2hdPWMpKSxuLnJlc3VsdH1yZXR1cm59LGRpc3BhdGNoOmZ1bmN0aW9uKG4pe249di5ldmVudC5maXgobnx8ZS5ldmVudCk7dmFyIHIsaSxzLG8sdSxhLGYsYyxoLHAsZD0odi5fZGF0YSh0aGlzLFwiZXZlbnRzXCIpfHx7fSlbbi50eXBlXXx8W10sbT1kLmRlbGVnYXRlQ291bnQsZz1sLmNhbGwoYXJndW1lbnRzKSx5PSFuLmV4Y2x1c2l2ZSYmIW4ubmFtZXNwYWNlLGI9di5ldmVudC5zcGVjaWFsW24udHlwZV18fHt9LHc9W107Z1swXT1uLG4uZGVsZWdhdGVUYXJnZXQ9dGhpcztpZihiLnByZURpc3BhdGNoJiZiLnByZURpc3BhdGNoLmNhbGwodGhpcyxuKT09PSExKXJldHVybjtpZihtJiYoIW4uYnV0dG9ufHxuLnR5cGUhPT1cImNsaWNrXCIpKWZvcihzPW4udGFyZ2V0O3MhPXRoaXM7cz1zLnBhcmVudE5vZGV8fHRoaXMpaWYocy5kaXNhYmxlZCE9PSEwfHxuLnR5cGUhPT1cImNsaWNrXCIpe3U9e30sZj1bXTtmb3Iocj0wO3I8bTtyKyspYz1kW3JdLGg9Yy5zZWxlY3Rvcix1W2hdPT09dCYmKHVbaF09Yy5uZWVkc0NvbnRleHQ/dihoLHRoaXMpLmluZGV4KHMpPj0wOnYuZmluZChoLHRoaXMsbnVsbCxbc10pLmxlbmd0aCksdVtoXSYmZi5wdXNoKGMpO2YubGVuZ3RoJiZ3LnB1c2goe2VsZW06cyxtYXRjaGVzOmZ9KX1kLmxlbmd0aD5tJiZ3LnB1c2goe2VsZW06dGhpcyxtYXRjaGVzOmQuc2xpY2UobSl9KTtmb3Iocj0wO3I8dy5sZW5ndGgmJiFuLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7cisrKXthPXdbcl0sbi5jdXJyZW50VGFyZ2V0PWEuZWxlbTtmb3IoaT0wO2k8YS5tYXRjaGVzLmxlbmd0aCYmIW4uaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtpKyspe2M9YS5tYXRjaGVzW2ldO2lmKHl8fCFuLm5hbWVzcGFjZSYmIWMubmFtZXNwYWNlfHxuLm5hbWVzcGFjZV9yZSYmbi5uYW1lc3BhY2VfcmUudGVzdChjLm5hbWVzcGFjZSkpbi5kYXRhPWMuZGF0YSxuLmhhbmRsZU9iaj1jLG89KCh2LmV2ZW50LnNwZWNpYWxbYy5vcmlnVHlwZV18fHt9KS5oYW5kbGV8fGMuaGFuZGxlcikuYXBwbHkoYS5lbGVtLGcpLG8hPT10JiYobi5yZXN1bHQ9byxvPT09ITEmJihuLnByZXZlbnREZWZhdWx0KCksbi5zdG9wUHJvcGFnYXRpb24oKSkpfX1yZXR1cm4gYi5wb3N0RGlzcGF0Y2gmJmIucG9zdERpc3BhdGNoLmNhbGwodGhpcyxuKSxuLnJlc3VsdH0scHJvcHM6XCJhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLGZpeEhvb2tzOnt9LGtleUhvb2tzOntwcm9wczpcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksZmlsdGVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUud2hpY2g9PW51bGwmJihlLndoaWNoPXQuY2hhckNvZGUhPW51bGw/dC5jaGFyQ29kZTp0LmtleUNvZGUpLGV9fSxtb3VzZUhvb2tzOntwcm9wczpcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBmcm9tRWxlbWVudCBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oZSxuKXt2YXIgcixzLG8sdT1uLmJ1dHRvbixhPW4uZnJvbUVsZW1lbnQ7cmV0dXJuIGUucGFnZVg9PW51bGwmJm4uY2xpZW50WCE9bnVsbCYmKHI9ZS50YXJnZXQub3duZXJEb2N1bWVudHx8aSxzPXIuZG9jdW1lbnRFbGVtZW50LG89ci5ib2R5LGUucGFnZVg9bi5jbGllbnRYKyhzJiZzLnNjcm9sbExlZnR8fG8mJm8uc2Nyb2xsTGVmdHx8MCktKHMmJnMuY2xpZW50TGVmdHx8byYmby5jbGllbnRMZWZ0fHwwKSxlLnBhZ2VZPW4uY2xpZW50WSsocyYmcy5zY3JvbGxUb3B8fG8mJm8uc2Nyb2xsVG9wfHwwKS0ocyYmcy5jbGllbnRUb3B8fG8mJm8uY2xpZW50VG9wfHwwKSksIWUucmVsYXRlZFRhcmdldCYmYSYmKGUucmVsYXRlZFRhcmdldD1hPT09ZS50YXJnZXQ/bi50b0VsZW1lbnQ6YSksIWUud2hpY2gmJnUhPT10JiYoZS53aGljaD11JjE/MTp1JjI/Mzp1JjQ/MjowKSxlfX0sZml4OmZ1bmN0aW9uKGUpe2lmKGVbdi5leHBhbmRvXSlyZXR1cm4gZTt2YXIgdCxuLHI9ZSxzPXYuZXZlbnQuZml4SG9va3NbZS50eXBlXXx8e30sbz1zLnByb3BzP3RoaXMucHJvcHMuY29uY2F0KHMucHJvcHMpOnRoaXMucHJvcHM7ZT12LkV2ZW50KHIpO2Zvcih0PW8ubGVuZ3RoO3Q7KW49b1stLXRdLGVbbl09cltuXTtyZXR1cm4gZS50YXJnZXR8fChlLnRhcmdldD1yLnNyY0VsZW1lbnR8fGkpLGUudGFyZ2V0Lm5vZGVUeXBlPT09MyYmKGUudGFyZ2V0PWUudGFyZ2V0LnBhcmVudE5vZGUpLGUubWV0YUtleT0hIWUubWV0YUtleSxzLmZpbHRlcj9zLmZpbHRlcihlLHIpOmV9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxmb2N1czp7ZGVsZWdhdGVUeXBlOlwiZm9jdXNpblwifSxibHVyOntkZWxlZ2F0ZVR5cGU6XCJmb2N1c291dFwifSxiZWZvcmV1bmxvYWQ6e3NldHVwOmZ1bmN0aW9uKGUsdCxuKXt2LmlzV2luZG93KHRoaXMpJiYodGhpcy5vbmJlZm9yZXVubG9hZD1uKX0sdGVhcmRvd246ZnVuY3Rpb24oZSx0KXt0aGlzLm9uYmVmb3JldW5sb2FkPT09dCYmKHRoaXMub25iZWZvcmV1bmxvYWQ9bnVsbCl9fX0sc2ltdWxhdGU6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9di5leHRlbmQobmV3IHYuRXZlbnQsbix7dHlwZTplLGlzU2ltdWxhdGVkOiEwLG9yaWdpbmFsRXZlbnQ6e319KTtyP3YuZXZlbnQudHJpZ2dlcihpLG51bGwsdCk6di5ldmVudC5kaXNwYXRjaC5jYWxsKHQsaSksaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmbi5wcmV2ZW50RGVmYXVsdCgpfX0sdi5ldmVudC5oYW5kbGU9di5ldmVudC5kaXNwYXRjaCx2LnJlbW92ZUV2ZW50PWkucmVtb3ZlRXZlbnRMaXN0ZW5lcj9mdW5jdGlvbihlLHQsbil7ZS5yZW1vdmVFdmVudExpc3RlbmVyJiZlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxuLCExKX06ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVwib25cIit0O2UuZGV0YWNoRXZlbnQmJih0eXBlb2YgZVtyXT09XCJ1bmRlZmluZWRcIiYmKGVbcl09bnVsbCksZS5kZXRhY2hFdmVudChyLG4pKX0sdi5FdmVudD1mdW5jdGlvbihlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHYuRXZlbnQpKXJldHVybiBuZXcgdi5FdmVudChlLHQpO2UmJmUudHlwZT8odGhpcy5vcmlnaW5hbEV2ZW50PWUsdGhpcy50eXBlPWUudHlwZSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1lLmRlZmF1bHRQcmV2ZW50ZWR8fGUucmV0dXJuVmFsdWU9PT0hMXx8ZS5nZXRQcmV2ZW50RGVmYXVsdCYmZS5nZXRQcmV2ZW50RGVmYXVsdCgpP3R0OmV0KTp0aGlzLnR5cGU9ZSx0JiZ2LmV4dGVuZCh0aGlzLHQpLHRoaXMudGltZVN0YW1wPWUmJmUudGltZVN0YW1wfHx2Lm5vdygpLHRoaXNbdi5leHBhbmRvXT0hMH0sdi5FdmVudC5wcm90b3R5cGU9e3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9dHQ7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O2lmKCFlKXJldHVybjtlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXR0O3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDtpZighZSlyZXR1cm47ZS5zdG9wUHJvcGFnYXRpb24mJmUuc3RvcFByb3BhZ2F0aW9uKCksZS5jYW5jZWxCdWJibGU9ITB9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dHQsdGhpcy5zdG9wUHJvcGFnYXRpb24oKX0saXNEZWZhdWx0UHJldmVudGVkOmV0LGlzUHJvcGFnYXRpb25TdG9wcGVkOmV0LGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOmV0fSx2LmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIn0sZnVuY3Rpb24oZSx0KXt2LmV2ZW50LnNwZWNpYWxbZV09e2RlbGVnYXRlVHlwZTp0LGJpbmRUeXBlOnQsaGFuZGxlOmZ1bmN0aW9uKGUpe3ZhciBuLHI9dGhpcyxpPWUucmVsYXRlZFRhcmdldCxzPWUuaGFuZGxlT2JqLG89cy5zZWxlY3RvcjtpZighaXx8aSE9PXImJiF2LmNvbnRhaW5zKHIsaSkpZS50eXBlPXMub3JpZ1R5cGUsbj1zLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGUudHlwZT10O3JldHVybiBufX19KSx2LnN1cHBvcnQuc3VibWl0QnViYmxlc3x8KHYuZXZlbnQuc3BlY2lhbC5zdWJtaXQ9e3NldHVwOmZ1bmN0aW9uKCl7aWYodi5ub2RlTmFtZSh0aGlzLFwiZm9ybVwiKSlyZXR1cm4hMTt2LmV2ZW50LmFkZCh0aGlzLFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQscj12Lm5vZGVOYW1lKG4sXCJpbnB1dFwiKXx8di5ub2RlTmFtZShuLFwiYnV0dG9uXCIpP24uZm9ybTp0O3ImJiF2Ll9kYXRhKHIsXCJfc3VibWl0X2F0dGFjaGVkXCIpJiYodi5ldmVudC5hZGQocixcInN1Ym1pdC5fc3VibWl0XCIsZnVuY3Rpb24oZSl7ZS5fc3VibWl0X2J1YmJsZT0hMH0pLHYuX2RhdGEocixcIl9zdWJtaXRfYXR0YWNoZWRcIiwhMCkpfSl9LHBvc3REaXNwYXRjaDpmdW5jdGlvbihlKXtlLl9zdWJtaXRfYnViYmxlJiYoZGVsZXRlIGUuX3N1Ym1pdF9idWJibGUsdGhpcy5wYXJlbnROb2RlJiYhZS5pc1RyaWdnZXImJnYuZXZlbnQuc2ltdWxhdGUoXCJzdWJtaXRcIix0aGlzLnBhcmVudE5vZGUsZSwhMCkpfSx0ZWFyZG93bjpmdW5jdGlvbigpe2lmKHYubm9kZU5hbWUodGhpcyxcImZvcm1cIikpcmV0dXJuITE7di5ldmVudC5yZW1vdmUodGhpcyxcIi5fc3VibWl0XCIpfX0pLHYuc3VwcG9ydC5jaGFuZ2VCdWJibGVzfHwodi5ldmVudC5zcGVjaWFsLmNoYW5nZT17c2V0dXA6ZnVuY3Rpb24oKXtpZigkLnRlc3QodGhpcy5ub2RlTmFtZSkpe2lmKHRoaXMudHlwZT09PVwiY2hlY2tib3hcInx8dGhpcy50eXBlPT09XCJyYWRpb1wiKXYuZXZlbnQuYWRkKHRoaXMsXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7ZS5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZT09PVwiY2hlY2tlZFwiJiYodGhpcy5fanVzdF9jaGFuZ2VkPSEwKX0pLHYuZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7dGhpcy5fanVzdF9jaGFuZ2VkJiYhZS5pc1RyaWdnZXImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITEpLHYuZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLGUsITApfSk7cmV0dXJuITF9di5ldmVudC5hZGQodGhpcyxcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIixmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDskLnRlc3QodC5ub2RlTmFtZSkmJiF2Ll9kYXRhKHQsXCJfY2hhbmdlX2F0dGFjaGVkXCIpJiYodi5ldmVudC5hZGQodCxcImNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlJiYhZS5pc1NpbXVsYXRlZCYmIWUuaXNUcmlnZ2VyJiZ2LmV2ZW50LnNpbXVsYXRlKFwiY2hhbmdlXCIsdGhpcy5wYXJlbnROb2RlLGUsITApfSksdi5fZGF0YSh0LFwiX2NoYW5nZV9hdHRhY2hlZFwiLCEwKSl9KX0saGFuZGxlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0O2lmKHRoaXMhPT10fHxlLmlzU2ltdWxhdGVkfHxlLmlzVHJpZ2dlcnx8dC50eXBlIT09XCJyYWRpb1wiJiZ0LnR5cGUhPT1cImNoZWNrYm94XCIpcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3JldHVybiB2LmV2ZW50LnJlbW92ZSh0aGlzLFwiLl9jaGFuZ2VcIiksISQudGVzdCh0aGlzLm5vZGVOYW1lKX19KSx2LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXN8fHYuZWFjaCh7Zm9jdXM6XCJmb2N1c2luXCIsYmx1cjpcImZvY3Vzb3V0XCJ9LGZ1bmN0aW9uKGUsdCl7dmFyIG49MCxyPWZ1bmN0aW9uKGUpe3YuZXZlbnQuc2ltdWxhdGUodCxlLnRhcmdldCx2LmV2ZW50LmZpeChlKSwhMCl9O3YuZXZlbnQuc3BlY2lhbFt0XT17c2V0dXA6ZnVuY3Rpb24oKXtuKys9PT0wJiZpLmFkZEV2ZW50TGlzdGVuZXIoZSxyLCEwKX0sdGVhcmRvd246ZnVuY3Rpb24oKXstLW49PT0wJiZpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxyLCEwKX19fSksdi5mbi5leHRlbmQoe29uOmZ1bmN0aW9uKGUsbixyLGkscyl7dmFyIG8sdTtpZih0eXBlb2YgZT09XCJvYmplY3RcIil7dHlwZW9mIG4hPVwic3RyaW5nXCImJihyPXJ8fG4sbj10KTtmb3IodSBpbiBlKXRoaXMub24odSxuLHIsZVt1XSxzKTtyZXR1cm4gdGhpc31yPT1udWxsJiZpPT1udWxsPyhpPW4scj1uPXQpOmk9PW51bGwmJih0eXBlb2Ygbj09XCJzdHJpbmdcIj8oaT1yLHI9dCk6KGk9cixyPW4sbj10KSk7aWYoaT09PSExKWk9ZXQ7ZWxzZSBpZighaSlyZXR1cm4gdGhpcztyZXR1cm4gcz09PTEmJihvPWksaT1mdW5jdGlvbihlKXtyZXR1cm4gdigpLm9mZihlKSxvLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saS5ndWlkPW8uZ3VpZHx8KG8uZ3VpZD12Lmd1aWQrKykpLHRoaXMuZWFjaChmdW5jdGlvbigpe3YuZXZlbnQuYWRkKHRoaXMsZSxpLHIsbil9KX0sb25lOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLm9uKGUsdCxuLHIsMSl9LG9mZjpmdW5jdGlvbihlLG4scil7dmFyIGkscztpZihlJiZlLnByZXZlbnREZWZhdWx0JiZlLmhhbmRsZU9iailyZXR1cm4gaT1lLmhhbmRsZU9iaix2KGUuZGVsZWdhdGVUYXJnZXQpLm9mZihpLm5hbWVzcGFjZT9pLm9yaWdUeXBlK1wiLlwiK2kubmFtZXNwYWNlOmkub3JpZ1R5cGUsaS5zZWxlY3RvcixpLmhhbmRsZXIpLHRoaXM7aWYodHlwZW9mIGU9PVwib2JqZWN0XCIpe2ZvcihzIGluIGUpdGhpcy5vZmYocyxuLGVbc10pO3JldHVybiB0aGlzfWlmKG49PT0hMXx8dHlwZW9mIG49PVwiZnVuY3Rpb25cIilyPW4sbj10O3JldHVybiByPT09ITEmJihyPWV0KSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2LmV2ZW50LnJlbW92ZSh0aGlzLGUscixuKX0pfSxiaW5kOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5vbihlLG51bGwsdCxuKX0sdW5iaW5kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub2ZmKGUsbnVsbCx0KX0sbGl2ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHYodGhpcy5jb250ZXh0KS5vbihlLHRoaXMuc2VsZWN0b3IsdCxuKSx0aGlzfSxkaWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdih0aGlzLmNvbnRleHQpLm9mZihlLHRoaXMuc2VsZWN0b3J8fFwiKipcIix0KSx0aGlzfSxkZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbih0LGUsbixyKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg9PT0xP3RoaXMub2ZmKGUsXCIqKlwiKTp0aGlzLm9mZih0LGV8fFwiKipcIixuKX0sdHJpZ2dlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2LmV2ZW50LnRyaWdnZXIoZSx0LHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGUsdCl7aWYodGhpc1swXSlyZXR1cm4gdi5ldmVudC50cmlnZ2VyKGUsdCx0aGlzWzBdLCEwKX0sdG9nZ2xlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cyxuPWUuZ3VpZHx8di5ndWlkKysscj0wLGk9ZnVuY3Rpb24obil7dmFyIGk9KHYuX2RhdGEodGhpcyxcImxhc3RUb2dnbGVcIitlLmd1aWQpfHwwKSVyO3JldHVybiB2Ll9kYXRhKHRoaXMsXCJsYXN0VG9nZ2xlXCIrZS5ndWlkLGkrMSksbi5wcmV2ZW50RGVmYXVsdCgpLHRbaV0uYXBwbHkodGhpcyxhcmd1bWVudHMpfHwhMX07aS5ndWlkPW47d2hpbGUocjx0Lmxlbmd0aCl0W3IrK10uZ3VpZD1uO3JldHVybiB0aGlzLmNsaWNrKGkpfSxob3ZlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm1vdXNlZW50ZXIoZSkubW91c2VsZWF2ZSh0fHxlKX19KSx2LmVhY2goXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGUsdCl7di5mblt0XT1mdW5jdGlvbihlLG4pe3JldHVybiBuPT1udWxsJiYobj1lLGU9bnVsbCksYXJndW1lbnRzLmxlbmd0aD4wP3RoaXMub24odCxudWxsLGUsbik6dGhpcy50cmlnZ2VyKHQpfSxRLnRlc3QodCkmJih2LmV2ZW50LmZpeEhvb2tzW3RdPXYuZXZlbnQua2V5SG9va3MpLEcudGVzdCh0KSYmKHYuZXZlbnQuZml4SG9va3NbdF09di5ldmVudC5tb3VzZUhvb2tzKX0pLGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbnQoZSx0LG4scil7bj1ufHxbXSx0PXR8fGc7dmFyIGkscyxhLGYsbD10Lm5vZGVUeXBlO2lmKCFlfHx0eXBlb2YgZSE9XCJzdHJpbmdcIilyZXR1cm4gbjtpZihsIT09MSYmbCE9PTkpcmV0dXJuW107YT1vKHQpO2lmKCFhJiYhcilpZihpPVIuZXhlYyhlKSlpZihmPWlbMV0pe2lmKGw9PT05KXtzPXQuZ2V0RWxlbWVudEJ5SWQoZik7aWYoIXN8fCFzLnBhcmVudE5vZGUpcmV0dXJuIG47aWYocy5pZD09PWYpcmV0dXJuIG4ucHVzaChzKSxufWVsc2UgaWYodC5vd25lckRvY3VtZW50JiYocz10Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZikpJiZ1KHQscykmJnMuaWQ9PT1mKXJldHVybiBuLnB1c2gocyksbn1lbHNle2lmKGlbMl0pcmV0dXJuIFMuYXBwbHkobix4LmNhbGwodC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKSwwKSksbjtpZigoZj1pWzNdKSYmWiYmdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBTLmFwcGx5KG4seC5jYWxsKHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmKSwwKSksbn1yZXR1cm4gdnQoZS5yZXBsYWNlKGosXCIkMVwiKSx0LG4scixhKX1mdW5jdGlvbiBydChlKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBuPT09XCJpbnB1dFwiJiZ0LnR5cGU9PT1lfX1mdW5jdGlvbiBpdChlKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybihuPT09XCJpbnB1dFwifHxuPT09XCJidXR0b25cIikmJnQudHlwZT09PWV9fWZ1bmN0aW9uIHN0KGUpe3JldHVybiBOKGZ1bmN0aW9uKHQpe3JldHVybiB0PSt0LE4oZnVuY3Rpb24obixyKXt2YXIgaSxzPWUoW10sbi5sZW5ndGgsdCksbz1zLmxlbmd0aDt3aGlsZShvLS0pbltpPXNbb11dJiYobltpXT0hKHJbaV09bltpXSkpfSl9KX1mdW5jdGlvbiBvdChlLHQsbil7aWYoZT09PXQpcmV0dXJuIG47dmFyIHI9ZS5uZXh0U2libGluZzt3aGlsZShyKXtpZihyPT09dClyZXR1cm4tMTtyPXIubmV4dFNpYmxpbmd9cmV0dXJuIDF9ZnVuY3Rpb24gdXQoZSx0KXt2YXIgbixyLHMsbyx1LGEsZixsPUxbZF1bZStcIiBcIl07aWYobClyZXR1cm4gdD8wOmwuc2xpY2UoMCk7dT1lLGE9W10sZj1pLnByZUZpbHRlcjt3aGlsZSh1KXtpZighbnx8KHI9Ri5leGVjKHUpKSlyJiYodT11LnNsaWNlKHJbMF0ubGVuZ3RoKXx8dSksYS5wdXNoKHM9W10pO249ITE7aWYocj1JLmV4ZWModSkpcy5wdXNoKG49bmV3IG0oci5zaGlmdCgpKSksdT11LnNsaWNlKG4ubGVuZ3RoKSxuLnR5cGU9clswXS5yZXBsYWNlKGosXCIgXCIpO2ZvcihvIGluIGkuZmlsdGVyKShyPUpbb10uZXhlYyh1KSkmJighZltvXXx8KHI9ZltvXShyKSkpJiYocy5wdXNoKG49bmV3IG0oci5zaGlmdCgpKSksdT11LnNsaWNlKG4ubGVuZ3RoKSxuLnR5cGU9byxuLm1hdGNoZXM9cik7aWYoIW4pYnJlYWt9cmV0dXJuIHQ/dS5sZW5ndGg6dT9udC5lcnJvcihlKTpMKGUsYSkuc2xpY2UoMCl9ZnVuY3Rpb24gYXQoZSx0LHIpe3ZhciBpPXQuZGlyLHM9ciYmdC5kaXI9PT1cInBhcmVudE5vZGVcIixvPXcrKztyZXR1cm4gdC5maXJzdD9mdW5jdGlvbih0LG4scil7d2hpbGUodD10W2ldKWlmKHN8fHQubm9kZVR5cGU9PT0xKXJldHVybiBlKHQsbixyKX06ZnVuY3Rpb24odCxyLHUpe2lmKCF1KXt2YXIgYSxmPWIrXCIgXCIrbytcIiBcIixsPWYrbjt3aGlsZSh0PXRbaV0paWYoc3x8dC5ub2RlVHlwZT09PTEpe2lmKChhPXRbZF0pPT09bClyZXR1cm4gdC5zaXpzZXQ7aWYodHlwZW9mIGE9PVwic3RyaW5nXCImJmEuaW5kZXhPZihmKT09PTApe2lmKHQuc2l6c2V0KXJldHVybiB0fWVsc2V7dFtkXT1sO2lmKGUodCxyLHUpKXJldHVybiB0LnNpenNldD0hMCx0O3Quc2l6c2V0PSExfX19ZWxzZSB3aGlsZSh0PXRbaV0paWYoc3x8dC5ub2RlVHlwZT09PTEpaWYoZSh0LHIsdSkpcmV0dXJuIHR9fWZ1bmN0aW9uIGZ0KGUpe3JldHVybiBlLmxlbmd0aD4xP2Z1bmN0aW9uKHQsbixyKXt2YXIgaT1lLmxlbmd0aDt3aGlsZShpLS0paWYoIWVbaV0odCxuLHIpKXJldHVybiExO3JldHVybiEwfTplWzBdfWZ1bmN0aW9uIGx0KGUsdCxuLHIsaSl7dmFyIHMsbz1bXSx1PTAsYT1lLmxlbmd0aCxmPXQhPW51bGw7Zm9yKDt1PGE7dSsrKWlmKHM9ZVt1XSlpZighbnx8bihzLHIsaSkpby5wdXNoKHMpLGYmJnQucHVzaCh1KTtyZXR1cm4gb31mdW5jdGlvbiBjdChlLHQsbixyLGkscyl7cmV0dXJuIHImJiFyW2RdJiYocj1jdChyKSksaSYmIWlbZF0mJihpPWN0KGkscykpLE4oZnVuY3Rpb24ocyxvLHUsYSl7dmFyIGYsbCxjLGg9W10scD1bXSxkPW8ubGVuZ3RoLHY9c3x8ZHQodHx8XCIqXCIsdS5ub2RlVHlwZT9bdV06dSxbXSksbT1lJiYoc3x8IXQpP2x0KHYsaCxlLHUsYSk6dixnPW4/aXx8KHM/ZTpkfHxyKT9bXTpvOm07biYmbihtLGcsdSxhKTtpZihyKXtmPWx0KGcscCkscihmLFtdLHUsYSksbD1mLmxlbmd0aDt3aGlsZShsLS0paWYoYz1mW2xdKWdbcFtsXV09IShtW3BbbF1dPWMpfWlmKHMpe2lmKGl8fGUpe2lmKGkpe2Y9W10sbD1nLmxlbmd0aDt3aGlsZShsLS0pKGM9Z1tsXSkmJmYucHVzaChtW2xdPWMpO2kobnVsbCxnPVtdLGYsYSl9bD1nLmxlbmd0aDt3aGlsZShsLS0pKGM9Z1tsXSkmJihmPWk/VC5jYWxsKHMsYyk6aFtsXSk+LTEmJihzW2ZdPSEob1tmXT1jKSl9fWVsc2UgZz1sdChnPT09bz9nLnNwbGljZShkLGcubGVuZ3RoKTpnKSxpP2kobnVsbCxvLGcsYSk6Uy5hcHBseShvLGcpfSl9ZnVuY3Rpb24gaHQoZSl7dmFyIHQsbixyLHM9ZS5sZW5ndGgsbz1pLnJlbGF0aXZlW2VbMF0udHlwZV0sdT1vfHxpLnJlbGF0aXZlW1wiIFwiXSxhPW8/MTowLGY9YXQoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT10fSx1LCEwKSxsPWF0KGZ1bmN0aW9uKGUpe3JldHVybiBULmNhbGwodCxlKT4tMX0sdSwhMCksaD1bZnVuY3Rpb24oZSxuLHIpe3JldHVybiFvJiYocnx8biE9PWMpfHwoKHQ9bikubm9kZVR5cGU/ZihlLG4scik6bChlLG4scikpfV07Zm9yKDthPHM7YSsrKWlmKG49aS5yZWxhdGl2ZVtlW2FdLnR5cGVdKWg9W2F0KGZ0KGgpLG4pXTtlbHNle249aS5maWx0ZXJbZVthXS50eXBlXS5hcHBseShudWxsLGVbYV0ubWF0Y2hlcyk7aWYobltkXSl7cj0rK2E7Zm9yKDtyPHM7cisrKWlmKGkucmVsYXRpdmVbZVtyXS50eXBlXSlicmVhaztyZXR1cm4gY3QoYT4xJiZmdChoKSxhPjEmJmUuc2xpY2UoMCxhLTEpLmpvaW4oXCJcIikucmVwbGFjZShqLFwiJDFcIiksbixhPHImJmh0KGUuc2xpY2UoYSxyKSkscjxzJiZodChlPWUuc2xpY2UocikpLHI8cyYmZS5qb2luKFwiXCIpKX1oLnB1c2gobil9cmV0dXJuIGZ0KGgpfWZ1bmN0aW9uIHB0KGUsdCl7dmFyIHI9dC5sZW5ndGg+MCxzPWUubGVuZ3RoPjAsbz1mdW5jdGlvbih1LGEsZixsLGgpe3ZhciBwLGQsdixtPVtdLHk9MCx3PVwiMFwiLHg9dSYmW10sVD1oIT1udWxsLE49YyxDPXV8fHMmJmkuZmluZC5UQUcoXCIqXCIsaCYmYS5wYXJlbnROb2RlfHxhKSxrPWIrPU49PW51bGw/MTpNYXRoLkU7VCYmKGM9YSE9PWcmJmEsbj1vLmVsKTtmb3IoOyhwPUNbd10pIT1udWxsO3crKyl7aWYocyYmcCl7Zm9yKGQ9MDt2PWVbZF07ZCsrKWlmKHYocCxhLGYpKXtsLnB1c2gocCk7YnJlYWt9VCYmKGI9ayxuPSsrby5lbCl9ciYmKChwPSF2JiZwKSYmeS0tLHUmJngucHVzaChwKSl9eSs9dztpZihyJiZ3IT09eSl7Zm9yKGQ9MDt2PXRbZF07ZCsrKXYoeCxtLGEsZik7aWYodSl7aWYoeT4wKXdoaWxlKHctLSkheFt3XSYmIW1bd10mJihtW3ddPUUuY2FsbChsKSk7bT1sdChtKX1TLmFwcGx5KGwsbSksVCYmIXUmJm0ubGVuZ3RoPjAmJnkrdC5sZW5ndGg+MSYmbnQudW5pcXVlU29ydChsKX1yZXR1cm4gVCYmKGI9ayxjPU4pLHh9O3JldHVybiBvLmVsPTAscj9OKG8pOm99ZnVuY3Rpb24gZHQoZSx0LG4pe3ZhciByPTAsaT10Lmxlbmd0aDtmb3IoO3I8aTtyKyspbnQoZSx0W3JdLG4pO3JldHVybiBufWZ1bmN0aW9uIHZ0KGUsdCxuLHIscyl7dmFyIG8sdSxmLGwsYyxoPXV0KGUpLHA9aC5sZW5ndGg7aWYoIXImJmgubGVuZ3RoPT09MSl7dT1oWzBdPWhbMF0uc2xpY2UoMCk7aWYodS5sZW5ndGg+MiYmKGY9dVswXSkudHlwZT09PVwiSURcIiYmdC5ub2RlVHlwZT09PTkmJiFzJiZpLnJlbGF0aXZlW3VbMV0udHlwZV0pe3Q9aS5maW5kLklEKGYubWF0Y2hlc1swXS5yZXBsYWNlKCQsXCJcIiksdCxzKVswXTtpZighdClyZXR1cm4gbjtlPWUuc2xpY2UodS5zaGlmdCgpLmxlbmd0aCl9Zm9yKG89Si5QT1MudGVzdChlKT8tMTp1Lmxlbmd0aC0xO28+PTA7by0tKXtmPXVbb107aWYoaS5yZWxhdGl2ZVtsPWYudHlwZV0pYnJlYWs7aWYoYz1pLmZpbmRbbF0paWYocj1jKGYubWF0Y2hlc1swXS5yZXBsYWNlKCQsXCJcIiksei50ZXN0KHVbMF0udHlwZSkmJnQucGFyZW50Tm9kZXx8dCxzKSl7dS5zcGxpY2UobywxKSxlPXIubGVuZ3RoJiZ1LmpvaW4oXCJcIik7aWYoIWUpcmV0dXJuIFMuYXBwbHkobix4LmNhbGwociwwKSksbjticmVha319fXJldHVybiBhKGUsaCkocix0LHMsbix6LnRlc3QoZSkpLG59ZnVuY3Rpb24gbXQoKXt9dmFyIG4scixpLHMsbyx1LGEsZixsLGMsaD0hMCxwPVwidW5kZWZpbmVkXCIsZD0oXCJzaXpjYWNoZVwiK01hdGgucmFuZG9tKCkpLnJlcGxhY2UoXCIuXCIsXCJcIiksbT1TdHJpbmcsZz1lLmRvY3VtZW50LHk9Zy5kb2N1bWVudEVsZW1lbnQsYj0wLHc9MCxFPVtdLnBvcCxTPVtdLnB1c2gseD1bXS5zbGljZSxUPVtdLmluZGV4T2Z8fGZ1bmN0aW9uKGUpe3ZhciB0PTAsbj10aGlzLmxlbmd0aDtmb3IoO3Q8bjt0KyspaWYodGhpc1t0XT09PWUpcmV0dXJuIHQ7cmV0dXJuLTF9LE49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVtkXT10PT1udWxsfHx0LGV9LEM9ZnVuY3Rpb24oKXt2YXIgZT17fSx0PVtdO3JldHVybiBOKGZ1bmN0aW9uKG4scil7cmV0dXJuIHQucHVzaChuKT5pLmNhY2hlTGVuZ3RoJiZkZWxldGUgZVt0LnNoaWZ0KCldLGVbbitcIiBcIl09cn0sZSl9LGs9QygpLEw9QygpLEE9QygpLE89XCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLE09XCIoPzpcXFxcXFxcXC58Wy1cXFxcd118W15cXFxceDAwLVxcXFx4YTBdKStcIixfPU0ucmVwbGFjZShcIndcIixcIncjXCIpLEQ9XCIoWypeJHwhfl0/PSlcIixQPVwiXFxcXFtcIitPK1wiKihcIitNK1wiKVwiK08rXCIqKD86XCIrRCtPK1wiKig/OihbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDN8KFwiK18rXCIpfCl8KVwiK08rXCIqXFxcXF1cIixIPVwiOihcIitNK1wiKSg/OlxcXFwoKD86KFsnXFxcIl0pKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqPylcXFxcMnwoW14oKVtcXFxcXV0qfCg/Oig/OlwiK1ArXCIpfFteOl18XFxcXFxcXFwuKSp8LiopKVxcXFwpfClcIixCPVwiOihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiK08rXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiK08rXCIqXFxcXCl8KSg/PVteLV18JClcIixqPW5ldyBSZWdFeHAoXCJeXCIrTytcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrTytcIiskXCIsXCJnXCIpLEY9bmV3IFJlZ0V4cChcIl5cIitPK1wiKixcIitPK1wiKlwiKSxJPW5ldyBSZWdFeHAoXCJeXCIrTytcIiooW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZj4rfl0pXCIrTytcIipcIikscT1uZXcgUmVnRXhwKEgpLFI9L14oPzojKFtcXHdcXC1dKyl8KFxcdyspfFxcLihbXFx3XFwtXSspKSQvLFU9L146bm90Lyx6PS9bXFx4MjBcXHRcXHJcXG5cXGZdKlsrfl0vLFc9Lzpub3RcXCgkLyxYPS9oXFxkL2ksVj0vaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbi9pLCQ9L1xcXFwoPyFcXFxcKS9nLEo9e0lEOm5ldyBSZWdFeHAoXCJeIyhcIitNK1wiKVwiKSxDTEFTUzpuZXcgUmVnRXhwKFwiXlxcXFwuKFwiK00rXCIpXCIpLE5BTUU6bmV3IFJlZ0V4cChcIl5cXFxcW25hbWU9WydcXFwiXT8oXCIrTStcIilbJ1xcXCJdP1xcXFxdXCIpLFRBRzpuZXcgUmVnRXhwKFwiXihcIitNLnJlcGxhY2UoXCJ3XCIsXCJ3KlwiKStcIilcIiksQVRUUjpuZXcgUmVnRXhwKFwiXlwiK1ApLFBTRVVETzpuZXcgUmVnRXhwKFwiXlwiK0gpLFBPUzpuZXcgUmVnRXhwKEIsXCJpXCIpLENISUxEOm5ldyBSZWdFeHAoXCJeOihvbmx5fG50aHxmaXJzdHxsYXN0KS1jaGlsZCg/OlxcXFwoXCIrTytcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK08rXCIqKD86KFsrLV18KVwiK08rXCIqKFxcXFxkKyl8KSlcIitPK1wiKlxcXFwpfClcIixcImlcIiksbmVlZHNDb250ZXh0Om5ldyBSZWdFeHAoXCJeXCIrTytcIipbPit+XXxcIitCLFwiaVwiKX0sSz1mdW5jdGlvbihlKXt2YXIgdD1nLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dHJ5e3JldHVybiBlKHQpfWNhdGNoKG4pe3JldHVybiExfWZpbmFsbHl7dD1udWxsfX0sUT1LKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGVuZENoaWxkKGcuY3JlYXRlQ29tbWVudChcIlwiKSksIWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aH0pLEc9SyhmdW5jdGlvbihlKXtyZXR1cm4gZS5pbm5lckhUTUw9XCI8YSBocmVmPScjJz48L2E+XCIsZS5maXJzdENoaWxkJiZ0eXBlb2YgZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSE9PXAmJmUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpPT09XCIjXCJ9KSxZPUsoZnVuY3Rpb24oZSl7ZS5pbm5lckhUTUw9XCI8c2VsZWN0Pjwvc2VsZWN0PlwiO3ZhciB0PXR5cGVvZiBlLmxhc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtyZXR1cm4gdCE9PVwiYm9vbGVhblwiJiZ0IT09XCJzdHJpbmdcIn0pLFo9SyhmdW5jdGlvbihlKXtyZXR1cm4gZS5pbm5lckhUTUw9XCI8ZGl2IGNsYXNzPSdoaWRkZW4gZSc+PC9kaXY+PGRpdiBjbGFzcz0naGlkZGVuJz48L2Rpdj5cIiwhZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lfHwhZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGg/ITE6KGUubGFzdENoaWxkLmNsYXNzTmFtZT1cImVcIixlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aD09PTIpfSksZXQ9SyhmdW5jdGlvbihlKXtlLmlkPWQrMCxlLmlubmVySFRNTD1cIjxhIG5hbWU9J1wiK2QrXCInPjwvYT48ZGl2IG5hbWU9J1wiK2QrXCInPjwvZGl2PlwiLHkuaW5zZXJ0QmVmb3JlKGUseS5maXJzdENoaWxkKTt2YXIgdD1nLmdldEVsZW1lbnRzQnlOYW1lJiZnLmdldEVsZW1lbnRzQnlOYW1lKGQpLmxlbmd0aD09PTIrZy5nZXRFbGVtZW50c0J5TmFtZShkKzApLmxlbmd0aDtyZXR1cm4gcj0hZy5nZXRFbGVtZW50QnlJZChkKSx5LnJlbW92ZUNoaWxkKGUpLHR9KTt0cnl7eC5jYWxsKHkuY2hpbGROb2RlcywwKVswXS5ub2RlVHlwZX1jYXRjaCh0dCl7eD1mdW5jdGlvbihlKXt2YXIgdCxuPVtdO2Zvcig7dD10aGlzW2VdO2UrKyluLnB1c2godCk7cmV0dXJuIG59fW50Lm1hdGNoZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnQoZSxudWxsLG51bGwsdCl9LG50Lm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihlLHQpe3JldHVybiBudCh0LG51bGwsbnVsbCxbZV0pLmxlbmd0aD4wfSxzPW50LmdldFRleHQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIlwiLHI9MCxpPWUubm9kZVR5cGU7aWYoaSl7aWYoaT09PTF8fGk9PT05fHxpPT09MTEpe2lmKHR5cGVvZiBlLnRleHRDb250ZW50PT1cInN0cmluZ1wiKXJldHVybiBlLnRleHRDb250ZW50O2ZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZyluKz1zKGUpfWVsc2UgaWYoaT09PTN8fGk9PT00KXJldHVybiBlLm5vZGVWYWx1ZX1lbHNlIGZvcig7dD1lW3JdO3IrKyluKz1zKHQpO3JldHVybiBufSxvPW50LmlzWE1MPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJihlLm93bmVyRG9jdW1lbnR8fGUpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gdD90Lm5vZGVOYW1lIT09XCJIVE1MXCI6ITF9LHU9bnQuY29udGFpbnM9eS5jb250YWlucz9mdW5jdGlvbihlLHQpe3ZhciBuPWUubm9kZVR5cGU9PT05P2UuZG9jdW1lbnRFbGVtZW50OmUscj10JiZ0LnBhcmVudE5vZGU7cmV0dXJuIGU9PT1yfHwhIShyJiZyLm5vZGVUeXBlPT09MSYmbi5jb250YWlucyYmbi5jb250YWlucyhyKSl9OnkuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCYmISEoZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSYxNil9OmZ1bmN0aW9uKGUsdCl7d2hpbGUodD10LnBhcmVudE5vZGUpaWYodD09PWUpcmV0dXJuITA7cmV0dXJuITF9LG50LmF0dHI9ZnVuY3Rpb24oZSx0KXt2YXIgbixyPW8oZSk7cmV0dXJuIHJ8fCh0PXQudG9Mb3dlckNhc2UoKSksKG49aS5hdHRySGFuZGxlW3RdKT9uKGUpOnJ8fFk/ZS5nZXRBdHRyaWJ1dGUodCk6KG49ZS5nZXRBdHRyaWJ1dGVOb2RlKHQpLG4/dHlwZW9mIGVbdF09PVwiYm9vbGVhblwiP2VbdF0/dDpudWxsOm4uc3BlY2lmaWVkP24udmFsdWU6bnVsbDpudWxsKX0saT1udC5zZWxlY3RvcnM9e2NhY2hlTGVuZ3RoOjUwLGNyZWF0ZVBzZXVkbzpOLG1hdGNoOkosYXR0ckhhbmRsZTpHP3t9OntocmVmOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcImhyZWZcIiwyKX0sdHlwZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpfX0sZmluZDp7SUQ6cj9mdW5jdGlvbihlLHQsbil7aWYodHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQhPT1wJiYhbil7dmFyIHI9dC5nZXRFbGVtZW50QnlJZChlKTtyZXR1cm4gciYmci5wYXJlbnROb2RlP1tyXTpbXX19OmZ1bmN0aW9uKGUsbixyKXtpZih0eXBlb2Ygbi5nZXRFbGVtZW50QnlJZCE9PXAmJiFyKXt2YXIgaT1uLmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiBpP2kuaWQ9PT1lfHx0eXBlb2YgaS5nZXRBdHRyaWJ1dGVOb2RlIT09cCYmaS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikudmFsdWU9PT1lP1tpXTp0OltdfX0sVEFHOlE/ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgdC5nZXRFbGVtZW50c0J5VGFnTmFtZSE9PXApcmV0dXJuIHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSl9OmZ1bmN0aW9uKGUsdCl7dmFyIG49dC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKTtpZihlPT09XCIqXCIpe3ZhciByLGk9W10scz0wO2Zvcig7cj1uW3NdO3MrKylyLm5vZGVUeXBlPT09MSYmaS5wdXNoKHIpO3JldHVybiBpfXJldHVybiBufSxOQU1FOmV0JiZmdW5jdGlvbihlLHQpe2lmKHR5cGVvZiB0LmdldEVsZW1lbnRzQnlOYW1lIT09cClyZXR1cm4gdC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKX0sQ0xBU1M6WiYmZnVuY3Rpb24oZSx0LG4pe2lmKHR5cGVvZiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUhPT1wJiYhbilyZXR1cm4gdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGUpfX0scmVsYXRpdmU6e1wiPlwiOntkaXI6XCJwYXJlbnROb2RlXCIsZmlyc3Q6ITB9LFwiIFwiOntkaXI6XCJwYXJlbnROb2RlXCJ9LFwiK1wiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIixmaXJzdDohMH0sXCJ+XCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wifX0scHJlRmlsdGVyOntBVFRSOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0ucmVwbGFjZSgkLFwiXCIpLGVbM109KGVbNF18fGVbNV18fFwiXCIpLnJlcGxhY2UoJCxcIlwiKSxlWzJdPT09XCJ+PVwiJiYoZVszXT1cIiBcIitlWzNdK1wiIFwiKSxlLnNsaWNlKDAsNCl9LENISUxEOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0udG9Mb3dlckNhc2UoKSxlWzFdPT09XCJudGhcIj8oZVsyXXx8bnQuZXJyb3IoZVswXSksZVszXT0rKGVbM10/ZVs0XSsoZVs1XXx8MSk6MiooZVsyXT09PVwiZXZlblwifHxlWzJdPT09XCJvZGRcIikpLGVbNF09KyhlWzZdK2VbN118fGVbMl09PT1cIm9kZFwiKSk6ZVsyXSYmbnQuZXJyb3IoZVswXSksZX0sUFNFVURPOmZ1bmN0aW9uKGUpe3ZhciB0LG47aWYoSi5DSElMRC50ZXN0KGVbMF0pKXJldHVybiBudWxsO2lmKGVbM10pZVsyXT1lWzNdO2Vsc2UgaWYodD1lWzRdKXEudGVzdCh0KSYmKG49dXQodCwhMCkpJiYobj10LmluZGV4T2YoXCIpXCIsdC5sZW5ndGgtbiktdC5sZW5ndGgpJiYodD10LnNsaWNlKDAsbiksZVswXT1lWzBdLnNsaWNlKDAsbikpLGVbMl09dDtyZXR1cm4gZS5zbGljZSgwLDMpfX0sZmlsdGVyOntJRDpyP2Z1bmN0aW9uKGUpe3JldHVybiBlPWUucmVwbGFjZSgkLFwiXCIpLGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEF0dHJpYnV0ZShcImlkXCIpPT09ZX19OmZ1bmN0aW9uKGUpe3JldHVybiBlPWUucmVwbGFjZSgkLFwiXCIpLGZ1bmN0aW9uKHQpe3ZhciBuPXR5cGVvZiB0LmdldEF0dHJpYnV0ZU5vZGUhPT1wJiZ0LmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtyZXR1cm4gbiYmbi52YWx1ZT09PWV9fSxUQUc6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1cIipcIj9mdW5jdGlvbigpe3JldHVybiEwfTooZT1lLnJlcGxhY2UoJCxcIlwiKS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vZGVOYW1lJiZ0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1lfSl9LENMQVNTOmZ1bmN0aW9uKGUpe3ZhciB0PWtbZF1bZStcIiBcIl07cmV0dXJuIHR8fCh0PW5ldyBSZWdFeHAoXCIoXnxcIitPK1wiKVwiK2UrXCIoXCIrTytcInwkKVwiKSkmJmsoZSxmdW5jdGlvbihlKXtyZXR1cm4gdC50ZXN0KGUuY2xhc3NOYW1lfHx0eXBlb2YgZS5nZXRBdHRyaWJ1dGUhPT1wJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocixpKXt2YXIgcz1udC5hdHRyKHIsZSk7cmV0dXJuIHM9PW51bGw/dD09PVwiIT1cIjp0PyhzKz1cIlwiLHQ9PT1cIj1cIj9zPT09bjp0PT09XCIhPVwiP3MhPT1uOnQ9PT1cIl49XCI/biYmcy5pbmRleE9mKG4pPT09MDp0PT09XCIqPVwiP24mJnMuaW5kZXhPZihuKT4tMTp0PT09XCIkPVwiP24mJnMuc3Vic3RyKHMubGVuZ3RoLW4ubGVuZ3RoKT09PW46dD09PVwifj1cIj8oXCIgXCIrcytcIiBcIikuaW5kZXhPZihuKT4tMTp0PT09XCJ8PVwiP3M9PT1ufHxzLnN1YnN0cigwLG4ubGVuZ3RoKzEpPT09bitcIi1cIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZT09PVwibnRoXCI/ZnVuY3Rpb24oZSl7dmFyIHQsaSxzPWUucGFyZW50Tm9kZTtpZihuPT09MSYmcj09PTApcmV0dXJuITA7aWYocyl7aT0wO2Zvcih0PXMuZmlyc3RDaGlsZDt0O3Q9dC5uZXh0U2libGluZylpZih0Lm5vZGVUeXBlPT09MSl7aSsrO2lmKGU9PT10KWJyZWFrfX1yZXR1cm4gaS09cixpPT09bnx8aSVuPT09MCYmaS9uPj0wfTpmdW5jdGlvbih0KXt2YXIgbj10O3N3aXRjaChlKXtjYXNlXCJvbmx5XCI6Y2FzZVwiZmlyc3RcIjp3aGlsZShuPW4ucHJldmlvdXNTaWJsaW5nKWlmKG4ubm9kZVR5cGU9PT0xKXJldHVybiExO2lmKGU9PT1cImZpcnN0XCIpcmV0dXJuITA7bj10O2Nhc2VcImxhc3RcIjp3aGlsZShuPW4ubmV4dFNpYmxpbmcpaWYobi5ub2RlVHlwZT09PTEpcmV0dXJuITE7cmV0dXJuITB9fX0sUFNFVURPOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1pLnBzZXVkb3NbZV18fGkuc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldfHxudC5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrZSk7cmV0dXJuIHJbZF0/cih0KTpyLmxlbmd0aD4xPyhuPVtlLGUsXCJcIix0XSxpLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoZS50b0xvd2VyQ2FzZSgpKT9OKGZ1bmN0aW9uKGUsbil7dmFyIGkscz1yKGUsdCksbz1zLmxlbmd0aDt3aGlsZShvLS0paT1ULmNhbGwoZSxzW29dKSxlW2ldPSEobltpXT1zW29dKX0pOmZ1bmN0aW9uKGUpe3JldHVybiByKGUsMCxuKX0pOnJ9fSxwc2V1ZG9zOntub3Q6TihmdW5jdGlvbihlKXt2YXIgdD1bXSxuPVtdLHI9YShlLnJlcGxhY2UoaixcIiQxXCIpKTtyZXR1cm4gcltkXT9OKGZ1bmN0aW9uKGUsdCxuLGkpe3ZhciBzLG89cihlLG51bGwsaSxbXSksdT1lLmxlbmd0aDt3aGlsZSh1LS0paWYocz1vW3VdKWVbdV09ISh0W3VdPXMpfSk6ZnVuY3Rpb24oZSxpLHMpe3JldHVybiB0WzBdPWUscih0LG51bGwscyxuKSwhbi5wb3AoKX19KSxoYXM6TihmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG50KGUsdCkubGVuZ3RoPjB9fSksY29udGFpbnM6TihmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuKHQudGV4dENvbnRlbnR8fHQuaW5uZXJUZXh0fHxzKHQpKS5pbmRleE9mKGUpPi0xfX0pLGVuYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMX0sZGlzYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMH0sY2hlY2tlZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHQ9PT1cImlucHV0XCImJiEhZS5jaGVja2VkfHx0PT09XCJvcHRpb25cIiYmISFlLnNlbGVjdGVkfSxzZWxlY3RlZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCxlLnNlbGVjdGVkPT09ITB9LHBhcmVudDpmdW5jdGlvbihlKXtyZXR1cm4haS5wc2V1ZG9zLmVtcHR5KGUpfSxlbXB0eTpmdW5jdGlvbihlKXt2YXIgdDtlPWUuZmlyc3RDaGlsZDt3aGlsZShlKXtpZihlLm5vZGVOYW1lPlwiQFwifHwodD1lLm5vZGVUeXBlKT09PTN8fHQ9PT00KXJldHVybiExO2U9ZS5uZXh0U2libGluZ31yZXR1cm4hMH0saGVhZGVyOmZ1bmN0aW9uKGUpe3JldHVybiBYLnRlc3QoZS5ub2RlTmFtZSl9LHRleHQ6ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJpbnB1dFwiJiYodD1lLnR5cGUpPT09XCJ0ZXh0XCImJigobj1lLmdldEF0dHJpYnV0ZShcInR5cGVcIikpPT1udWxsfHxuLnRvTG93ZXJDYXNlKCk9PT10KX0scmFkaW86cnQoXCJyYWRpb1wiKSxjaGVja2JveDpydChcImNoZWNrYm94XCIpLGZpbGU6cnQoXCJmaWxlXCIpLHBhc3N3b3JkOnJ0KFwicGFzc3dvcmRcIiksaW1hZ2U6cnQoXCJpbWFnZVwiKSxzdWJtaXQ6aXQoXCJzdWJtaXRcIikscmVzZXQ6aXQoXCJyZXNldFwiKSxidXR0b246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJpbnB1dFwiJiZlLnR5cGU9PT1cImJ1dHRvblwifHx0PT09XCJidXR0b25cIn0saW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFYudGVzdChlLm5vZGVOYW1lKX0sZm9jdXM6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vd25lckRvY3VtZW50O3JldHVybiBlPT09dC5hY3RpdmVFbGVtZW50JiYoIXQuaGFzRm9jdXN8fHQuaGFzRm9jdXMoKSkmJiEhKGUudHlwZXx8ZS5ocmVmfHx+ZS50YWJJbmRleCl9LGFjdGl2ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50fSxmaXJzdDpzdChmdW5jdGlvbigpe3JldHVyblswXX0pLGxhc3Q6c3QoZnVuY3Rpb24oZSx0KXtyZXR1cm5bdC0xXX0pLGVxOnN0KGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm5bbjwwP24rdDpuXX0pLGV2ZW46c3QoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPHQ7bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxvZGQ6c3QoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MTtuPHQ7bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxsdDpzdChmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPW48MD9uK3Q6bjstLXI+PTA7KWUucHVzaChyKTtyZXR1cm4gZX0pLGd0OnN0KGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9bjwwP24rdDpuOysrcjx0OyllLnB1c2gocik7cmV0dXJuIGV9KX19LGY9eS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe3JldHVybiBlPT09dD8obD0hMCwwKTooIWUuY29tcGFyZURvY3VtZW50UG9zaXRpb258fCF0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uP2UuY29tcGFyZURvY3VtZW50UG9zaXRpb246ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSY0KT8tMToxfTpmdW5jdGlvbihlLHQpe2lmKGU9PT10KXJldHVybiBsPSEwLDA7aWYoZS5zb3VyY2VJbmRleCYmdC5zb3VyY2VJbmRleClyZXR1cm4gZS5zb3VyY2VJbmRleC10LnNvdXJjZUluZGV4O3ZhciBuLHIsaT1bXSxzPVtdLG89ZS5wYXJlbnROb2RlLHU9dC5wYXJlbnROb2RlLGE9bztpZihvPT09dSlyZXR1cm4gb3QoZSx0KTtpZighbylyZXR1cm4tMTtpZighdSlyZXR1cm4gMTt3aGlsZShhKWkudW5zaGlmdChhKSxhPWEucGFyZW50Tm9kZTthPXU7d2hpbGUoYSlzLnVuc2hpZnQoYSksYT1hLnBhcmVudE5vZGU7bj1pLmxlbmd0aCxyPXMubGVuZ3RoO2Zvcih2YXIgZj0wO2Y8biYmZjxyO2YrKylpZihpW2ZdIT09c1tmXSlyZXR1cm4gb3QoaVtmXSxzW2ZdKTtyZXR1cm4gZj09PW4/b3QoZSxzW2ZdLC0xKTpvdChpW2ZdLHQsMSl9LFswLDBdLnNvcnQoZiksaD0hbCxudC51bmlxdWVTb3J0PWZ1bmN0aW9uKGUpe3ZhciB0LG49W10scj0xLGk9MDtsPWgsZS5zb3J0KGYpO2lmKGwpe2Zvcig7dD1lW3JdO3IrKyl0PT09ZVtyLTFdJiYoaT1uLnB1c2gocikpO3doaWxlKGktLSllLnNwbGljZShuW2ldLDEpfXJldHVybiBlfSxudC5lcnJvcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIitlKX0sYT1udC5jb21waWxlPWZ1bmN0aW9uKGUsdCl7dmFyIG4scj1bXSxpPVtdLHM9QVtkXVtlK1wiIFwiXTtpZighcyl7dHx8KHQ9dXQoZSkpLG49dC5sZW5ndGg7d2hpbGUobi0tKXM9aHQodFtuXSksc1tkXT9yLnB1c2gocyk6aS5wdXNoKHMpO3M9QShlLHB0KGkscikpfXJldHVybiBzfSxnLnF1ZXJ5U2VsZWN0b3JBbGwmJmZ1bmN0aW9uKCl7dmFyIGUsdD12dCxuPS8nfFxcXFwvZyxyPS9cXD1bXFx4MjBcXHRcXHJcXG5cXGZdKihbXidcIlxcXV0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFxdL2csaT1bXCI6Zm9jdXNcIl0scz1bXCI6YWN0aXZlXCJdLHU9eS5tYXRjaGVzU2VsZWN0b3J8fHkubW96TWF0Y2hlc1NlbGVjdG9yfHx5LndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8eS5vTWF0Y2hlc1NlbGVjdG9yfHx5Lm1zTWF0Y2hlc1NlbGVjdG9yO0soZnVuY3Rpb24oZSl7ZS5pbm5lckhUTUw9XCI8c2VsZWN0PjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIsZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fGkucHVzaChcIlxcXFxbXCIrTytcIiooPzpjaGVja2VkfGRpc2FibGVkfGlzbWFwfG11bHRpcGxlfHJlYWRvbmx5fHNlbGVjdGVkfHZhbHVlKVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fGkucHVzaChcIjpjaGVja2VkXCIpfSksSyhmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxwIHRlc3Q9Jyc+PC9wPlwiLGUucXVlcnlTZWxlY3RvckFsbChcIlt0ZXN0Xj0nJ11cIikubGVuZ3RoJiZpLnB1c2goXCJbKl4kXT1cIitPK1wiKig/OlxcXCJcXFwifCcnKVwiKSxlLmlubmVySFRNTD1cIjxpbnB1dCB0eXBlPSdoaWRkZW4nLz5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGh8fGkucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIil9KSxpPW5ldyBSZWdFeHAoaS5qb2luKFwifFwiKSksdnQ9ZnVuY3Rpb24oZSxyLHMsbyx1KXtpZighbyYmIXUmJiFpLnRlc3QoZSkpe3ZhciBhLGYsbD0hMCxjPWQsaD1yLHA9ci5ub2RlVHlwZT09PTkmJmU7aWYoci5ub2RlVHlwZT09PTEmJnIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9PVwib2JqZWN0XCIpe2E9dXQoZSksKGw9ci5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/Yz1sLnJlcGxhY2UobixcIlxcXFwkJlwiKTpyLnNldEF0dHJpYnV0ZShcImlkXCIsYyksYz1cIltpZD0nXCIrYytcIiddIFwiLGY9YS5sZW5ndGg7d2hpbGUoZi0tKWFbZl09YythW2ZdLmpvaW4oXCJcIik7aD16LnRlc3QoZSkmJnIucGFyZW50Tm9kZXx8cixwPWEuam9pbihcIixcIil9aWYocCl0cnl7cmV0dXJuIFMuYXBwbHkocyx4LmNhbGwoaC5xdWVyeVNlbGVjdG9yQWxsKHApLDApKSxzfWNhdGNoKHYpe31maW5hbGx5e2x8fHIucmVtb3ZlQXR0cmlidXRlKFwiaWRcIil9fXJldHVybiB0KGUscixzLG8sdSl9LHUmJihLKGZ1bmN0aW9uKHQpe2U9dS5jYWxsKHQsXCJkaXZcIik7dHJ5e3UuY2FsbCh0LFwiW3Rlc3QhPScnXTpzaXp6bGVcIikscy5wdXNoKFwiIT1cIixIKX1jYXRjaChuKXt9fSkscz1uZXcgUmVnRXhwKHMuam9pbihcInxcIikpLG50Lm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbih0LG4pe249bi5yZXBsYWNlKHIsXCI9JyQxJ11cIik7aWYoIW8odCkmJiFzLnRlc3QobikmJiFpLnRlc3QobikpdHJ5e3ZhciBhPXUuY2FsbCh0LG4pO2lmKGF8fGV8fHQuZG9jdW1lbnQmJnQuZG9jdW1lbnQubm9kZVR5cGUhPT0xMSlyZXR1cm4gYX1jYXRjaChmKXt9cmV0dXJuIG50KG4sbnVsbCxudWxsLFt0XSkubGVuZ3RoPjB9KX0oKSxpLnBzZXVkb3MubnRoPWkucHNldWRvcy5lcSxpLmZpbHRlcnM9bXQucHJvdG90eXBlPWkucHNldWRvcyxpLnNldEZpbHRlcnM9bmV3IG10LG50LmF0dHI9di5hdHRyLHYuZmluZD1udCx2LmV4cHI9bnQuc2VsZWN0b3JzLHYuZXhwcltcIjpcIl09di5leHByLnBzZXVkb3Msdi51bmlxdWU9bnQudW5pcXVlU29ydCx2LnRleHQ9bnQuZ2V0VGV4dCx2LmlzWE1MRG9jPW50LmlzWE1MLHYuY29udGFpbnM9bnQuY29udGFpbnN9KGUpO3ZhciBudD0vVW50aWwkLyxydD0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxpdD0vXi5bXjojXFxbXFwuLF0qJC8sc3Q9di5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxvdD17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTt2LmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihlKXt2YXIgdCxuLHIsaSxzLG8sdT10aGlzO2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXJldHVybiB2KGUpLmZpbHRlcihmdW5jdGlvbigpe2Zvcih0PTAsbj11Lmxlbmd0aDt0PG47dCsrKWlmKHYuY29udGFpbnModVt0XSx0aGlzKSlyZXR1cm4hMH0pO289dGhpcy5wdXNoU3RhY2soXCJcIixcImZpbmRcIixlKTtmb3IodD0wLG49dGhpcy5sZW5ndGg7dDxuO3QrKyl7cj1vLmxlbmd0aCx2LmZpbmQoZSx0aGlzW3RdLG8pO2lmKHQ+MClmb3IoaT1yO2k8by5sZW5ndGg7aSsrKWZvcihzPTA7czxyO3MrKylpZihvW3NdPT09b1tpXSl7by5zcGxpY2UoaS0tLDEpO2JyZWFrfX1yZXR1cm4gb30saGFzOmZ1bmN0aW9uKGUpe3ZhciB0LG49dihlLHRoaXMpLHI9bi5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHQ9MDt0PHI7dCsrKWlmKHYuY29udGFpbnModGhpcyxuW3RdKSlyZXR1cm4hMH0pfSxub3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsZSwhMSksXCJub3RcIixlKX0sZmlsdGVyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayhmdCh0aGlzLGUsITApLFwiZmlsdGVyXCIsZSl9LGlzOmZ1bmN0aW9uKGUpe3JldHVybiEhZSYmKHR5cGVvZiBlPT1cInN0cmluZ1wiP3N0LnRlc3QoZSk/dihlLHRoaXMuY29udGV4dCkuaW5kZXgodGhpc1swXSk+PTA6di5maWx0ZXIoZSx0aGlzKS5sZW5ndGg+MDp0aGlzLmZpbHRlcihlKS5sZW5ndGg+MCl9LGNsb3Nlc3Q6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10aGlzLmxlbmd0aCxzPVtdLG89c3QudGVzdChlKXx8dHlwZW9mIGUhPVwic3RyaW5nXCI/dihlLHR8fHRoaXMuY29udGV4dCk6MDtmb3IoO3I8aTtyKyspe249dGhpc1tyXTt3aGlsZShuJiZuLm93bmVyRG9jdW1lbnQmJm4hPT10JiZuLm5vZGVUeXBlIT09MTEpe2lmKG8/by5pbmRleChuKT4tMTp2LmZpbmQubWF0Y2hlc1NlbGVjdG9yKG4sZSkpe3MucHVzaChuKTticmVha31uPW4ucGFyZW50Tm9kZX19cmV0dXJuIHM9cy5sZW5ndGg+MT92LnVuaXF1ZShzKTpzLHRoaXMucHVzaFN0YWNrKHMsXCJjbG9zZXN0XCIsZSl9LGluZGV4OmZ1bmN0aW9uKGUpe3JldHVybiBlP3R5cGVvZiBlPT1cInN0cmluZ1wiP3YuaW5BcnJheSh0aGlzWzBdLHYoZSkpOnYuaW5BcnJheShlLmpxdWVyeT9lWzBdOmUsdGhpcyk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGUsdCl7dmFyIG49dHlwZW9mIGU9PVwic3RyaW5nXCI/dihlLHQpOnYubWFrZUFycmF5KGUmJmUubm9kZVR5cGU/W2VdOmUpLHI9di5tZXJnZSh0aGlzLmdldCgpLG4pO3JldHVybiB0aGlzLnB1c2hTdGFjayh1dChuWzBdKXx8dXQoclswXSk/cjp2LnVuaXF1ZShyKSl9LGFkZEJhY2s6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkKGU9PW51bGw/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpfX0pLHYuZm4uYW5kU2VsZj12LmZuLmFkZEJhY2ssdi5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiZ0Lm5vZGVUeXBlIT09MTE/dDpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGUpe3JldHVybiB2LmRpcihlLFwicGFyZW50Tm9kZVwiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdi5kaXIoZSxcInBhcmVudE5vZGVcIixuKX0sbmV4dDpmdW5jdGlvbihlKXtyZXR1cm4gYXQoZSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2OmZ1bmN0aW9uKGUpe3JldHVybiBhdChlLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0QWxsOmZ1bmN0aW9uKGUpe3JldHVybiB2LmRpcihlLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZGlyKGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHYuZGlyKGUsXCJuZXh0U2libGluZ1wiLG4pfSxwcmV2VW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2LmRpcihlLFwicHJldmlvdXNTaWJsaW5nXCIsbil9LHNpYmxpbmdzOmZ1bmN0aW9uKGUpe3JldHVybiB2LnNpYmxpbmcoKGUucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsZSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGUpe3JldHVybiB2LnNpYmxpbmcoZS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIHYubm9kZU5hbWUoZSxcImlmcmFtZVwiKT9lLmNvbnRlbnREb2N1bWVudHx8ZS5jb250ZW50V2luZG93LmRvY3VtZW50OnYubWVyZ2UoW10sZS5jaGlsZE5vZGVzKX19LGZ1bmN0aW9uKGUsdCl7di5mbltlXT1mdW5jdGlvbihuLHIpe3ZhciBpPXYubWFwKHRoaXMsdCxuKTtyZXR1cm4gbnQudGVzdChlKXx8KHI9biksciYmdHlwZW9mIHI9PVwic3RyaW5nXCImJihpPXYuZmlsdGVyKHIsaSkpLGk9dGhpcy5sZW5ndGg+MSYmIW90W2VdP3YudW5pcXVlKGkpOmksdGhpcy5sZW5ndGg+MSYmcnQudGVzdChlKSYmKGk9aS5yZXZlcnNlKCkpLHRoaXMucHVzaFN0YWNrKGksZSxsLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSl9fSksdi5leHRlbmQoe2ZpbHRlcjpmdW5jdGlvbihlLHQsbil7cmV0dXJuIG4mJihlPVwiOm5vdChcIitlK1wiKVwiKSx0Lmxlbmd0aD09PTE/di5maW5kLm1hdGNoZXNTZWxlY3Rvcih0WzBdLGUpP1t0WzBdXTpbXTp2LmZpbmQubWF0Y2hlcyhlLHQpfSxkaXI6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpPVtdLHM9ZVtuXTt3aGlsZShzJiZzLm5vZGVUeXBlIT09OSYmKHI9PT10fHxzLm5vZGVUeXBlIT09MXx8IXYocykuaXMocikpKXMubm9kZVR5cGU9PT0xJiZpLnB1c2gocykscz1zW25dO3JldHVybiBpfSxzaWJsaW5nOmZ1bmN0aW9uKGUsdCl7dmFyIG49W107Zm9yKDtlO2U9ZS5uZXh0U2libGluZyllLm5vZGVUeXBlPT09MSYmZSE9PXQmJm4ucHVzaChlKTtyZXR1cm4gbn19KTt2YXIgY3Q9XCJhYmJyfGFydGljbGV8YXNpZGV8YXVkaW98YmRpfGNhbnZhc3xkYXRhfGRhdGFsaXN0fGRldGFpbHN8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGhlYWRlcnxoZ3JvdXB8bWFya3xtZXRlcnxuYXZ8b3V0cHV0fHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0aW1lfHZpZGVvXCIsaHQ9LyBqUXVlcnlcXGQrPVwiKD86bnVsbHxcXGQrKVwiL2cscHQ9L15cXHMrLyxkdD0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksdnQ9LzwoW1xcdzpdKykvLG10PS88dGJvZHkvaSxndD0vPHwmIz9cXHcrOy8seXQ9LzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxidD0vPCg/OnNjcmlwdHxvYmplY3R8ZW1iZWR8b3B0aW9ufHN0eWxlKS9pLHd0PW5ldyBSZWdFeHAoXCI8KD86XCIrY3QrXCIpW1xcXFxzLz5dXCIsXCJpXCIpLEV0PS9eKD86Y2hlY2tib3h8cmFkaW8pJC8sU3Q9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSx4dD0vXFwvKGphdmF8ZWNtYSlzY3JpcHQvaSxUdD0vXlxccyo8ISg/OlxcW0NEQVRBXFxbfFxcLVxcLSl8W1xcXVxcLV17Mn0+XFxzKiQvZyxOdD17b3B0aW9uOlsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLGxlZ2VuZDpbMSxcIjxmaWVsZHNldD5cIixcIjwvZmllbGRzZXQ+XCJdLHRoZWFkOlsxLFwiPHRhYmxlPlwiLFwiPC90YWJsZT5cIl0sdHI6WzIsXCI8dGFibGU+PHRib2R5PlwiLFwiPC90Ym9keT48L3RhYmxlPlwiXSx0ZDpbMyxcIjx0YWJsZT48dGJvZHk+PHRyPlwiLFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLGNvbDpbMixcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLGFyZWE6WzEsXCI8bWFwPlwiLFwiPC9tYXA+XCJdLF9kZWZhdWx0OlswLFwiXCIsXCJcIl19LEN0PWx0KGkpLGt0PUN0LmFwcGVuZENoaWxkKGkuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7TnQub3B0Z3JvdXA9TnQub3B0aW9uLE50LnRib2R5PU50LnRmb290PU50LmNvbGdyb3VwPU50LmNhcHRpb249TnQudGhlYWQsTnQudGg9TnQudGQsdi5zdXBwb3J0Lmh0bWxTZXJpYWxpemV8fChOdC5fZGVmYXVsdD1bMSxcIlg8ZGl2PlwiLFwiPC9kaXY+XCJdKSx2LmZuLmV4dGVuZCh7dGV4dDpmdW5jdGlvbihlKXtyZXR1cm4gdi5hY2Nlc3ModGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZT09PXQ/di50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5hcHBlbmQoKHRoaXNbMF0mJnRoaXNbMF0ub3duZXJEb2N1bWVudHx8aSkuY3JlYXRlVGV4dE5vZGUoZSkpfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LHdyYXBBbGw6ZnVuY3Rpb24oZSl7aWYodi5pc0Z1bmN0aW9uKGUpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7dih0aGlzKS53cmFwQWxsKGUuY2FsbCh0aGlzLHQpKX0pO2lmKHRoaXNbMF0pe3ZhciB0PXYoZSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKTt0aGlzWzBdLnBhcmVudE5vZGUmJnQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLHQubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aGlsZShlLmZpcnN0Q2hpbGQmJmUuZmlyc3RDaGlsZC5ub2RlVHlwZT09PTEpZT1lLmZpcnN0Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcyl9cmV0dXJuIHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihlKXtyZXR1cm4gdi5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbih0KXt2KHRoaXMpLndyYXBJbm5lcihlLmNhbGwodGhpcyx0KSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD12KHRoaXMpLG49dC5jb250ZW50cygpO24ubGVuZ3RoP24ud3JhcEFsbChlKTp0LmFwcGVuZChlKX0pfSx3cmFwOmZ1bmN0aW9uKGUpe3ZhciB0PXYuaXNGdW5jdGlvbihlKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3YodGhpcykud3JhcEFsbCh0P2UuY2FsbCh0aGlzLG4pOmUpfSl9LHVud3JhcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXt2Lm5vZGVOYW1lKHRoaXMsXCJib2R5XCIpfHx2KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KS5lbmQoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCEwLGZ1bmN0aW9uKGUpeyh0aGlzLm5vZGVUeXBlPT09MXx8dGhpcy5ub2RlVHlwZT09PTExKSYmdGhpcy5hcHBlbmRDaGlsZChlKX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCEwLGZ1bmN0aW9uKGUpeyh0aGlzLm5vZGVUeXBlPT09MXx8dGhpcy5ub2RlVHlwZT09PTExKSYmdGhpcy5pbnNlcnRCZWZvcmUoZSx0aGlzLmZpcnN0Q2hpbGQpfSl9LGJlZm9yZTpmdW5jdGlvbigpe2lmKCF1dCh0aGlzWzBdKSlyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsITEsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHRoaXMpfSk7aWYoYXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9di5jbGVhbihhcmd1bWVudHMpO3JldHVybiB0aGlzLnB1c2hTdGFjayh2Lm1lcmdlKGUsdGhpcyksXCJiZWZvcmVcIix0aGlzLnNlbGVjdG9yKX19LGFmdGVyOmZ1bmN0aW9uKCl7aWYoIXV0KHRoaXNbMF0pKXJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywhMSxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcy5uZXh0U2libGluZyl9KTtpZihhcmd1bWVudHMubGVuZ3RoKXt2YXIgZT12LmNsZWFuKGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHYubWVyZ2UodGhpcyxlKSxcImFmdGVyXCIsdGhpcy5zZWxlY3Rvcil9fSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTA7Zm9yKDsobj10aGlzW3JdKSE9bnVsbDtyKyspaWYoIWV8fHYuZmlsdGVyKGUsW25dKS5sZW5ndGgpIXQmJm4ubm9kZVR5cGU9PT0xJiYodi5jbGVhbkRhdGEobi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpLHYuY2xlYW5EYXRhKFtuXSkpLG4ucGFyZW50Tm9kZSYmbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3ZhciBlLHQ9MDtmb3IoOyhlPXRoaXNbdF0pIT1udWxsO3QrKyl7ZS5ub2RlVHlwZT09PTEmJnYuY2xlYW5EYXRhKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTt3aGlsZShlLmZpcnN0Q2hpbGQpZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpfXJldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihlLHQpe3JldHVybiBlPWU9PW51bGw/ITE6ZSx0PXQ9PW51bGw/ZTp0LHRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHYuY2xvbmUodGhpcyxlLHQpfSl9LGh0bWw6ZnVuY3Rpb24oZSl7cmV0dXJuIHYuYWNjZXNzKHRoaXMsZnVuY3Rpb24oZSl7dmFyIG49dGhpc1swXXx8e30scj0wLGk9dGhpcy5sZW5ndGg7aWYoZT09PXQpcmV0dXJuIG4ubm9kZVR5cGU9PT0xP24uaW5uZXJIVE1MLnJlcGxhY2UoaHQsXCJcIik6dDtpZih0eXBlb2YgZT09XCJzdHJpbmdcIiYmIXl0LnRlc3QoZSkmJih2LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZXx8IXd0LnRlc3QoZSkpJiYodi5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlfHwhcHQudGVzdChlKSkmJiFOdFsodnQuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXtlPWUucmVwbGFjZShkdCxcIjwkMT48LyQyPlwiKTt0cnl7Zm9yKDtyPGk7cisrKW49dGhpc1tyXXx8e30sbi5ub2RlVHlwZT09PTEmJih2LmNsZWFuRGF0YShuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSksbi5pbm5lckhUTUw9ZSk7bj0wfWNhdGNoKHMpe319biYmdGhpcy5lbXB0eSgpLmFwcGVuZChlKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbihlKXtyZXR1cm4gdXQodGhpc1swXSk/dGhpcy5sZW5ndGg/dGhpcy5wdXNoU3RhY2sodih2LmlzRnVuY3Rpb24oZSk/ZSgpOmUpLFwicmVwbGFjZVdpdGhcIixlKTp0aGlzOnYuaXNGdW5jdGlvbihlKT90aGlzLmVhY2goZnVuY3Rpb24odCl7dmFyIG49dih0aGlzKSxyPW4uaHRtbCgpO24ucmVwbGFjZVdpdGgoZS5jYWxsKHRoaXMsdCxyKSl9KToodHlwZW9mIGUhPVwic3RyaW5nXCImJihlPXYoZSkuZGV0YWNoKCkpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXRoaXMubmV4dFNpYmxpbmcsbj10aGlzLnBhcmVudE5vZGU7dih0aGlzKS5yZW1vdmUoKSx0P3YodCkuYmVmb3JlKGUpOnYobikuYXBwZW5kKGUpfSkpfSxkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVtb3ZlKGUsITApfSxkb21NYW5pcDpmdW5jdGlvbihlLG4scil7ZT1bXS5jb25jYXQuYXBwbHkoW10sZSk7dmFyIGkscyxvLHUsYT0wLGY9ZVswXSxsPVtdLGM9dGhpcy5sZW5ndGg7aWYoIXYuc3VwcG9ydC5jaGVja0Nsb25lJiZjPjEmJnR5cGVvZiBmPT1cInN0cmluZ1wiJiZTdC50ZXN0KGYpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2KHRoaXMpLmRvbU1hbmlwKGUsbixyKX0pO2lmKHYuaXNGdW5jdGlvbihmKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpe3ZhciBzPXYodGhpcyk7ZVswXT1mLmNhbGwodGhpcyxpLG4/cy5odG1sKCk6dCkscy5kb21NYW5pcChlLG4scil9KTtpZih0aGlzWzBdKXtpPXYuYnVpbGRGcmFnbWVudChlLHRoaXMsbCksbz1pLmZyYWdtZW50LHM9by5maXJzdENoaWxkLG8uY2hpbGROb2Rlcy5sZW5ndGg9PT0xJiYobz1zKTtpZihzKXtuPW4mJnYubm9kZU5hbWUocyxcInRyXCIpO2Zvcih1PWkuY2FjaGVhYmxlfHxjLTE7YTxjO2ErKylyLmNhbGwobiYmdi5ub2RlTmFtZSh0aGlzW2FdLFwidGFibGVcIik/THQodGhpc1thXSxcInRib2R5XCIpOnRoaXNbYV0sYT09PXU/bzp2LmNsb25lKG8sITAsITApKX1vPXM9bnVsbCxsLmxlbmd0aCYmdi5lYWNoKGwsZnVuY3Rpb24oZSx0KXt0LnNyYz92LmFqYXg/di5hamF4KHt1cmw6dC5zcmMsdHlwZTpcIkdFVFwiLGRhdGFUeXBlOlwic2NyaXB0XCIsYXN5bmM6ITEsZ2xvYmFsOiExLFwidGhyb3dzXCI6ITB9KTp2LmVycm9yKFwibm8gYWpheFwiKTp2Lmdsb2JhbEV2YWwoKHQudGV4dHx8dC50ZXh0Q29udGVudHx8dC5pbm5lckhUTUx8fFwiXCIpLnJlcGxhY2UoVHQsXCJcIikpLHQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpfSl9cmV0dXJuIHRoaXN9fSksdi5idWlsZEZyYWdtZW50PWZ1bmN0aW9uKGUsbixyKXt2YXIgcyxvLHUsYT1lWzBdO3JldHVybiBuPW58fGksbj0hbi5ub2RlVHlwZSYmblswXXx8bixuPW4ub3duZXJEb2N1bWVudHx8bixlLmxlbmd0aD09PTEmJnR5cGVvZiBhPT1cInN0cmluZ1wiJiZhLmxlbmd0aDw1MTImJm49PT1pJiZhLmNoYXJBdCgwKT09PVwiPFwiJiYhYnQudGVzdChhKSYmKHYuc3VwcG9ydC5jaGVja0Nsb25lfHwhU3QudGVzdChhKSkmJih2LnN1cHBvcnQuaHRtbDVDbG9uZXx8IXd0LnRlc3QoYSkpJiYobz0hMCxzPXYuZnJhZ21lbnRzW2FdLHU9cyE9PXQpLHN8fChzPW4uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHYuY2xlYW4oZSxuLHMsciksbyYmKHYuZnJhZ21lbnRzW2FdPXUmJnMpKSx7ZnJhZ21lbnQ6cyxjYWNoZWFibGU6b319LHYuZnJhZ21lbnRzPXt9LHYuZWFjaCh7YXBwZW5kVG86XCJhcHBlbmRcIixwcmVwZW5kVG86XCJwcmVwZW5kXCIsaW5zZXJ0QmVmb3JlOlwiYmVmb3JlXCIsaW5zZXJ0QWZ0ZXI6XCJhZnRlclwiLHJlcGxhY2VBbGw6XCJyZXBsYWNlV2l0aFwifSxmdW5jdGlvbihlLHQpe3YuZm5bZV09ZnVuY3Rpb24obil7dmFyIHIsaT0wLHM9W10sbz12KG4pLHU9by5sZW5ndGgsYT10aGlzLmxlbmd0aD09PTEmJnRoaXNbMF0ucGFyZW50Tm9kZTtpZigoYT09bnVsbHx8YSYmYS5ub2RlVHlwZT09PTExJiZhLmNoaWxkTm9kZXMubGVuZ3RoPT09MSkmJnU9PT0xKXJldHVybiBvW3RdKHRoaXNbMF0pLHRoaXM7Zm9yKDtpPHU7aSsrKXI9KGk+MD90aGlzLmNsb25lKCEwKTp0aGlzKS5nZXQoKSx2KG9baV0pW3RdKHIpLHM9cy5jb25jYXQocik7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHMsZSxvLnNlbGVjdG9yKX19KSx2LmV4dGVuZCh7Y2xvbmU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGkscyxvO3Yuc3VwcG9ydC5odG1sNUNsb25lfHx2LmlzWE1MRG9jKGUpfHwhd3QudGVzdChcIjxcIitlLm5vZGVOYW1lK1wiPlwiKT9vPWUuY2xvbmVOb2RlKCEwKTooa3QuaW5uZXJIVE1MPWUub3V0ZXJIVE1MLGt0LnJlbW92ZUNoaWxkKG89a3QuZmlyc3RDaGlsZCkpO2lmKCghdi5zdXBwb3J0Lm5vQ2xvbmVFdmVudHx8IXYuc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCkmJihlLm5vZGVUeXBlPT09MXx8ZS5ub2RlVHlwZT09PTExKSYmIXYuaXNYTUxEb2MoZSkpe090KGUsbykscj1NdChlKSxpPU10KG8pO2ZvcihzPTA7cltzXTsrK3MpaVtzXSYmT3QocltzXSxpW3NdKX1pZih0KXtBdChlLG8pO2lmKG4pe3I9TXQoZSksaT1NdChvKTtmb3Iocz0wO3Jbc107KytzKUF0KHJbc10saVtzXSl9fXJldHVybiByPWk9bnVsbCxvfSxjbGVhbjpmdW5jdGlvbihlLHQsbixyKXt2YXIgcyxvLHUsYSxmLGwsYyxoLHAsZCxtLGcseT10PT09aSYmQ3QsYj1bXTtpZighdHx8dHlwZW9mIHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudD09XCJ1bmRlZmluZWRcIil0PWk7Zm9yKHM9MDsodT1lW3NdKSE9bnVsbDtzKyspe3R5cGVvZiB1PT1cIm51bWJlclwiJiYodSs9XCJcIik7aWYoIXUpY29udGludWU7aWYodHlwZW9mIHU9PVwic3RyaW5nXCIpaWYoIWd0LnRlc3QodSkpdT10LmNyZWF0ZVRleHROb2RlKHUpO2Vsc2V7eT15fHxsdCh0KSxjPXQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx5LmFwcGVuZENoaWxkKGMpLHU9dS5yZXBsYWNlKGR0LFwiPCQxPjwvJDI+XCIpLGE9KHZ0LmV4ZWModSl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLGY9TnRbYV18fE50Ll9kZWZhdWx0LGw9ZlswXSxjLmlubmVySFRNTD1mWzFdK3UrZlsyXTt3aGlsZShsLS0pYz1jLmxhc3RDaGlsZDtpZighdi5zdXBwb3J0LnRib2R5KXtoPW10LnRlc3QodSkscD1hPT09XCJ0YWJsZVwiJiYhaD9jLmZpcnN0Q2hpbGQmJmMuZmlyc3RDaGlsZC5jaGlsZE5vZGVzOmZbMV09PT1cIjx0YWJsZT5cIiYmIWg/Yy5jaGlsZE5vZGVzOltdO2ZvcihvPXAubGVuZ3RoLTE7bz49MDstLW8pdi5ub2RlTmFtZShwW29dLFwidGJvZHlcIikmJiFwW29dLmNoaWxkTm9kZXMubGVuZ3RoJiZwW29dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocFtvXSl9IXYuc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSYmcHQudGVzdCh1KSYmYy5pbnNlcnRCZWZvcmUodC5jcmVhdGVUZXh0Tm9kZShwdC5leGVjKHUpWzBdKSxjLmZpcnN0Q2hpbGQpLHU9Yy5jaGlsZE5vZGVzLGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKX11Lm5vZGVUeXBlP2IucHVzaCh1KTp2Lm1lcmdlKGIsdSl9YyYmKHU9Yz15PW51bGwpO2lmKCF2LnN1cHBvcnQuYXBwZW5kQ2hlY2tlZClmb3Iocz0wOyh1PWJbc10pIT1udWxsO3MrKyl2Lm5vZGVOYW1lKHUsXCJpbnB1dFwiKT9fdCh1KTp0eXBlb2YgdS5nZXRFbGVtZW50c0J5VGFnTmFtZSE9XCJ1bmRlZmluZWRcIiYmdi5ncmVwKHUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSxfdCk7aWYobil7bT1mdW5jdGlvbihlKXtpZighZS50eXBlfHx4dC50ZXN0KGUudHlwZSkpcmV0dXJuIHI/ci5wdXNoKGUucGFyZW50Tm9kZT9lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk6ZSk6bi5hcHBlbmRDaGlsZChlKX07Zm9yKHM9MDsodT1iW3NdKSE9bnVsbDtzKyspaWYoIXYubm9kZU5hbWUodSxcInNjcmlwdFwiKXx8IW0odSkpbi5hcHBlbmRDaGlsZCh1KSx0eXBlb2YgdS5nZXRFbGVtZW50c0J5VGFnTmFtZSE9XCJ1bmRlZmluZWRcIiYmKGc9di5ncmVwKHYubWVyZ2UoW10sdS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSksbSksYi5zcGxpY2UuYXBwbHkoYixbcysxLDBdLmNvbmNhdChnKSkscys9Zy5sZW5ndGgpfXJldHVybiBifSxjbGVhbkRhdGE6ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGkscyxvPTAsdT12LmV4cGFuZG8sYT12LmNhY2hlLGY9di5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8sbD12LmV2ZW50LnNwZWNpYWw7Zm9yKDsoaT1lW29dKSE9bnVsbDtvKyspaWYodHx8di5hY2NlcHREYXRhKGkpKXtyPWlbdV0sbj1yJiZhW3JdO2lmKG4pe2lmKG4uZXZlbnRzKWZvcihzIGluIG4uZXZlbnRzKWxbc10/di5ldmVudC5yZW1vdmUoaSxzKTp2LnJlbW92ZUV2ZW50KGkscyxuLmhhbmRsZSk7YVtyXSYmKGRlbGV0ZSBhW3JdLGY/ZGVsZXRlIGlbdV06aS5yZW1vdmVBdHRyaWJ1dGU/aS5yZW1vdmVBdHRyaWJ1dGUodSk6aVt1XT1udWxsLHYuZGVsZXRlZElkcy5wdXNoKHIpKX19fX0pLGZ1bmN0aW9uKCl7dmFyIGUsdDt2LnVhTWF0Y2g9ZnVuY3Rpb24oZSl7ZT1lLnRvTG93ZXJDYXNlKCk7dmFyIHQ9LyhjaHJvbWUpWyBcXC9dKFtcXHcuXSspLy5leGVjKGUpfHwvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLmV4ZWMoZSl8fC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvLmV4ZWMoZSl8fC8obXNpZSkgKFtcXHcuXSspLy5leGVjKGUpfHxlLmluZGV4T2YoXCJjb21wYXRpYmxlXCIpPDAmJi8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWMoZSl8fFtdO3JldHVybnticm93c2VyOnRbMV18fFwiXCIsdmVyc2lvbjp0WzJdfHxcIjBcIn19LGU9di51YU1hdGNoKG8udXNlckFnZW50KSx0PXt9LGUuYnJvd3NlciYmKHRbZS5icm93c2VyXT0hMCx0LnZlcnNpb249ZS52ZXJzaW9uKSx0LmNocm9tZT90LndlYmtpdD0hMDp0LndlYmtpdCYmKHQuc2FmYXJpPSEwKSx2LmJyb3dzZXI9dCx2LnN1Yj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtyZXR1cm4gbmV3IGUuZm4uaW5pdCh0LG4pfXYuZXh0ZW5kKCEwLGUsdGhpcyksZS5zdXBlcmNsYXNzPXRoaXMsZS5mbj1lLnByb3RvdHlwZT10aGlzKCksZS5mbi5jb25zdHJ1Y3Rvcj1lLGUuc3ViPXRoaXMuc3ViLGUuZm4uaW5pdD1mdW5jdGlvbihyLGkpe3JldHVybiBpJiZpIGluc3RhbmNlb2YgdiYmIShpIGluc3RhbmNlb2YgZSkmJihpPWUoaSkpLHYuZm4uaW5pdC5jYWxsKHRoaXMscixpLHQpfSxlLmZuLmluaXQucHJvdG90eXBlPWUuZm47dmFyIHQ9ZShpKTtyZXR1cm4gZX19KCk7dmFyIER0LFB0LEh0LEJ0PS9hbHBoYVxcKFteKV0qXFwpL2ksanQ9L29wYWNpdHk9KFteKV0qKS8sRnQ9L14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvLEl0PS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxxdD0vXm1hcmdpbi8sUnQ9bmV3IFJlZ0V4cChcIl4oXCIrbStcIikoLiopJFwiLFwiaVwiKSxVdD1uZXcgUmVnRXhwKFwiXihcIittK1wiKSg/IXB4KVthLXolXSskXCIsXCJpXCIpLHp0PW5ldyBSZWdFeHAoXCJeKFstK10pPShcIittK1wiKVwiLFwiaVwiKSxXdD17Qk9EWTpcImJsb2NrXCJ9LFh0PXtwb3NpdGlvbjpcImFic29sdXRlXCIsdmlzaWJpbGl0eTpcImhpZGRlblwiLGRpc3BsYXk6XCJibG9ja1wifSxWdD17bGV0dGVyU3BhY2luZzowLGZvbnRXZWlnaHQ6NDAwfSwkdD1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0sSnQ9W1wiV2Via2l0XCIsXCJPXCIsXCJNb3pcIixcIm1zXCJdLEt0PXYuZm4udG9nZ2xlO3YuZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdi5hY2Nlc3ModGhpcyxmdW5jdGlvbihlLG4scil7cmV0dXJuIHIhPT10P3Yuc3R5bGUoZSxuLHIpOnYuY3NzKGUsbil9LGUsbixhcmd1bWVudHMubGVuZ3RoPjEpfSxzaG93OmZ1bmN0aW9uKCl7cmV0dXJuIFl0KHRoaXMsITApfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIFl0KHRoaXMpfSx0b2dnbGU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2YgZT09XCJib29sZWFuXCI7cmV0dXJuIHYuaXNGdW5jdGlvbihlKSYmdi5pc0Z1bmN0aW9uKHQpP0t0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmVhY2goZnVuY3Rpb24oKXsobj9lOkd0KHRoaXMpKT92KHRoaXMpLnNob3coKTp2KHRoaXMpLmhpZGUoKX0pfX0pLHYuZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGUsdCl7aWYodCl7dmFyIG49RHQoZSxcIm9wYWNpdHlcIik7cmV0dXJuIG49PT1cIlwiP1wiMVwiOm59fX19LGNzc051bWJlcjp7ZmlsbE9wYWNpdHk6ITAsZm9udFdlaWdodDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JwaGFuczohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITB9LGNzc1Byb3BzOntcImZsb2F0XCI6di5zdXBwb3J0LmNzc0Zsb2F0P1wiY3NzRmxvYXRcIjpcInN0eWxlRmxvYXRcIn0sc3R5bGU6ZnVuY3Rpb24oZSxuLHIsaSl7aWYoIWV8fGUubm9kZVR5cGU9PT0zfHxlLm5vZGVUeXBlPT09OHx8IWUuc3R5bGUpcmV0dXJuO3ZhciBzLG8sdSxhPXYuY2FtZWxDYXNlKG4pLGY9ZS5zdHlsZTtuPXYuY3NzUHJvcHNbYV18fCh2LmNzc1Byb3BzW2FdPVF0KGYsYSkpLHU9di5jc3NIb29rc1tuXXx8di5jc3NIb29rc1thXTtpZihyPT09dClyZXR1cm4gdSYmXCJnZXRcImluIHUmJihzPXUuZ2V0KGUsITEsaSkpIT09dD9zOmZbbl07bz10eXBlb2YgcixvPT09XCJzdHJpbmdcIiYmKHM9enQuZXhlYyhyKSkmJihyPShzWzFdKzEpKnNbMl0rcGFyc2VGbG9hdCh2LmNzcyhlLG4pKSxvPVwibnVtYmVyXCIpO2lmKHI9PW51bGx8fG89PT1cIm51bWJlclwiJiZpc05hTihyKSlyZXR1cm47bz09PVwibnVtYmVyXCImJiF2LmNzc051bWJlclthXSYmKHIrPVwicHhcIik7aWYoIXV8fCEoXCJzZXRcImluIHUpfHwocj11LnNldChlLHIsaSkpIT09dCl0cnl7ZltuXT1yfWNhdGNoKGwpe319LGNzczpmdW5jdGlvbihlLG4scixpKXt2YXIgcyxvLHUsYT12LmNhbWVsQ2FzZShuKTtyZXR1cm4gbj12LmNzc1Byb3BzW2FdfHwodi5jc3NQcm9wc1thXT1RdChlLnN0eWxlLGEpKSx1PXYuY3NzSG9va3Nbbl18fHYuY3NzSG9va3NbYV0sdSYmXCJnZXRcImluIHUmJihzPXUuZ2V0KGUsITAsaSkpLHM9PT10JiYocz1EdChlLG4pKSxzPT09XCJub3JtYWxcIiYmbiBpbiBWdCYmKHM9VnRbbl0pLHJ8fGkhPT10PyhvPXBhcnNlRmxvYXQocykscnx8di5pc051bWVyaWMobyk/b3x8MDpzKTpzfSxzd2FwOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLHM9e307Zm9yKGkgaW4gdClzW2ldPWUuc3R5bGVbaV0sZS5zdHlsZVtpXT10W2ldO3I9bi5jYWxsKGUpO2ZvcihpIGluIHQpZS5zdHlsZVtpXT1zW2ldO3JldHVybiByfX0pLGUuZ2V0Q29tcHV0ZWRTdHlsZT9EdD1mdW5jdGlvbih0LG4pe3ZhciByLGkscyxvLHU9ZS5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCksYT10LnN0eWxlO3JldHVybiB1JiYocj11LmdldFByb3BlcnR5VmFsdWUobil8fHVbbl0scj09PVwiXCImJiF2LmNvbnRhaW5zKHQub3duZXJEb2N1bWVudCx0KSYmKHI9di5zdHlsZSh0LG4pKSxVdC50ZXN0KHIpJiZxdC50ZXN0KG4pJiYoaT1hLndpZHRoLHM9YS5taW5XaWR0aCxvPWEubWF4V2lkdGgsYS5taW5XaWR0aD1hLm1heFdpZHRoPWEud2lkdGg9cixyPXUud2lkdGgsYS53aWR0aD1pLGEubWluV2lkdGg9cyxhLm1heFdpZHRoPW8pKSxyfTppLmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUmJihEdD1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaT1lLmN1cnJlbnRTdHlsZSYmZS5jdXJyZW50U3R5bGVbdF0scz1lLnN0eWxlO3JldHVybiBpPT1udWxsJiZzJiZzW3RdJiYoaT1zW3RdKSxVdC50ZXN0KGkpJiYhRnQudGVzdCh0KSYmKG49cy5sZWZ0LHI9ZS5ydW50aW1lU3R5bGUmJmUucnVudGltZVN0eWxlLmxlZnQsciYmKGUucnVudGltZVN0eWxlLmxlZnQ9ZS5jdXJyZW50U3R5bGUubGVmdCkscy5sZWZ0PXQ9PT1cImZvbnRTaXplXCI/XCIxZW1cIjppLGk9cy5waXhlbExlZnQrXCJweFwiLHMubGVmdD1uLHImJihlLnJ1bnRpbWVTdHlsZS5sZWZ0PXIpKSxpPT09XCJcIj9cImF1dG9cIjppfSksdi5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oZSx0KXt2LmNzc0hvb2tzW3RdPXtnZXQ6ZnVuY3Rpb24oZSxuLHIpe2lmKG4pcmV0dXJuIGUub2Zmc2V0V2lkdGg9PT0wJiZJdC50ZXN0KER0KGUsXCJkaXNwbGF5XCIpKT92LnN3YXAoZSxYdCxmdW5jdGlvbigpe3JldHVybiB0bihlLHQscil9KTp0bihlLHQscil9LHNldDpmdW5jdGlvbihlLG4scil7cmV0dXJuIFp0KGUsbixyP2VuKGUsdCxyLHYuc3VwcG9ydC5ib3hTaXppbmcmJnYuY3NzKGUsXCJib3hTaXppbmdcIik9PT1cImJvcmRlci1ib3hcIik6MCl9fX0pLHYuc3VwcG9ydC5vcGFjaXR5fHwodi5jc3NIb29rcy5vcGFjaXR5PXtnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4ganQudGVzdCgodCYmZS5jdXJyZW50U3R5bGU/ZS5jdXJyZW50U3R5bGUuZmlsdGVyOmUuc3R5bGUuZmlsdGVyKXx8XCJcIik/LjAxKnBhcnNlRmxvYXQoUmVnRXhwLiQxKStcIlwiOnQ/XCIxXCI6XCJcIn0sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5zdHlsZSxyPWUuY3VycmVudFN0eWxlLGk9di5pc051bWVyaWModCk/XCJhbHBoYShvcGFjaXR5PVwiK3QqMTAwK1wiKVwiOlwiXCIscz1yJiZyLmZpbHRlcnx8bi5maWx0ZXJ8fFwiXCI7bi56b29tPTE7aWYodD49MSYmdi50cmltKHMucmVwbGFjZShCdCxcIlwiKSk9PT1cIlwiJiZuLnJlbW92ZUF0dHJpYnV0ZSl7bi5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7aWYociYmIXIuZmlsdGVyKXJldHVybn1uLmZpbHRlcj1CdC50ZXN0KHMpP3MucmVwbGFjZShCdCxpKTpzK1wiIFwiK2l9fSksdihmdW5jdGlvbigpe3Yuc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0fHwodi5jc3NIb29rcy5tYXJnaW5SaWdodD17Z2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHYuc3dhcChlLHtkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCJ9LGZ1bmN0aW9uKCl7aWYodClyZXR1cm4gRHQoZSxcIm1hcmdpblJpZ2h0XCIpfSl9fSksIXYuc3VwcG9ydC5waXhlbFBvc2l0aW9uJiZ2LmZuLnBvc2l0aW9uJiZ2LmVhY2goW1widG9wXCIsXCJsZWZ0XCJdLGZ1bmN0aW9uKGUsdCl7di5jc3NIb29rc1t0XT17Z2V0OmZ1bmN0aW9uKGUsbil7aWYobil7dmFyIHI9RHQoZSx0KTtyZXR1cm4gVXQudGVzdChyKT92KGUpLnBvc2l0aW9uKClbdF0rXCJweFwiOnJ9fX19KX0pLHYuZXhwciYmdi5leHByLmZpbHRlcnMmJih2LmV4cHIuZmlsdGVycy5oaWRkZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGUub2Zmc2V0V2lkdGg9PT0wJiZlLm9mZnNldEhlaWdodD09PTB8fCF2LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzJiYoZS5zdHlsZSYmZS5zdHlsZS5kaXNwbGF5fHxEdChlLFwiZGlzcGxheVwiKSk9PT1cIm5vbmVcIn0sdi5leHByLmZpbHRlcnMudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4hdi5leHByLmZpbHRlcnMuaGlkZGVuKGUpfSksdi5lYWNoKHttYXJnaW46XCJcIixwYWRkaW5nOlwiXCIsYm9yZGVyOlwiV2lkdGhcIn0sZnVuY3Rpb24oZSx0KXt2LmNzc0hvb2tzW2UrdF09e2V4cGFuZDpmdW5jdGlvbihuKXt2YXIgcixpPXR5cGVvZiBuPT1cInN0cmluZ1wiP24uc3BsaXQoXCIgXCIpOltuXSxzPXt9O2ZvcihyPTA7cjw0O3IrKylzW2UrJHRbcl0rdF09aVtyXXx8aVtyLTJdfHxpWzBdO3JldHVybiBzfX0scXQudGVzdChlKXx8KHYuY3NzSG9va3NbZSt0XS5zZXQ9WnQpfSk7dmFyIHJuPS8lMjAvZyxzbj0vXFxbXFxdJC8sb249L1xccj9cXG4vZyx1bj0vXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8aGlkZGVufG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2ksYW49L14oPzpzZWxlY3R8dGV4dGFyZWEpL2k7di5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiB2LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSl9LHNlcmlhbGl6ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudHM/di5tYWtlQXJyYXkodGhpcy5lbGVtZW50cyk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWUmJiF0aGlzLmRpc2FibGVkJiYodGhpcy5jaGVja2VkfHxhbi50ZXN0KHRoaXMubm9kZU5hbWUpfHx1bi50ZXN0KHRoaXMudHlwZSkpfSkubWFwKGZ1bmN0aW9uKGUsdCl7dmFyIG49dih0aGlzKS52YWwoKTtyZXR1cm4gbj09bnVsbD9udWxsOnYuaXNBcnJheShuKT92Lm1hcChuLGZ1bmN0aW9uKGUsbil7cmV0dXJue25hbWU6dC5uYW1lLHZhbHVlOmUucmVwbGFjZShvbixcIlxcclxcblwiKX19KTp7bmFtZTp0Lm5hbWUsdmFsdWU6bi5yZXBsYWNlKG9uLFwiXFxyXFxuXCIpfX0pLmdldCgpfX0pLHYucGFyYW09ZnVuY3Rpb24oZSxuKXt2YXIgcixpPVtdLHM9ZnVuY3Rpb24oZSx0KXt0PXYuaXNGdW5jdGlvbih0KT90KCk6dD09bnVsbD9cIlwiOnQsaVtpLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudCh0KX07bj09PXQmJihuPXYuYWpheFNldHRpbmdzJiZ2LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCk7aWYodi5pc0FycmF5KGUpfHxlLmpxdWVyeSYmIXYuaXNQbGFpbk9iamVjdChlKSl2LmVhY2goZSxmdW5jdGlvbigpe3ModGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IociBpbiBlKWZuKHIsZVtyXSxuLHMpO3JldHVybiBpLmpvaW4oXCImXCIpLnJlcGxhY2Uocm4sXCIrXCIpfTt2YXIgbG4sY24saG49LyMuKiQvLHBuPS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL21nLGRuPS9eKD86YWJvdXR8YXBwfGFwcFxcLXN0b3JhZ2V8LitcXC1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyx2bj0vXig/OkdFVHxIRUFEKSQvLG1uPS9eXFwvXFwvLyxnbj0vXFw/Lyx5bj0vPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSxibj0vKFs/Jl0pXz1bXiZdKi8sd249L14oW1xcd1xcK1xcLlxcLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sRW49di5mbi5sb2FkLFNuPXt9LHhuPXt9LFRuPVtcIiovXCJdK1tcIipcIl07dHJ5e2NuPXMuaHJlZn1jYXRjaChObil7Y249aS5jcmVhdGVFbGVtZW50KFwiYVwiKSxjbi5ocmVmPVwiXCIsY249Y24uaHJlZn1sbj13bi5leGVjKGNuLnRvTG93ZXJDYXNlKCkpfHxbXSx2LmZuLmxvYWQ9ZnVuY3Rpb24oZSxuLHIpe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiJiZFbilyZXR1cm4gRW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCF0aGlzLmxlbmd0aClyZXR1cm4gdGhpczt2YXIgaSxzLG8sdT10aGlzLGE9ZS5pbmRleE9mKFwiIFwiKTtyZXR1cm4gYT49MCYmKGk9ZS5zbGljZShhLGUubGVuZ3RoKSxlPWUuc2xpY2UoMCxhKSksdi5pc0Z1bmN0aW9uKG4pPyhyPW4sbj10KTpuJiZ0eXBlb2Ygbj09XCJvYmplY3RcIiYmKHM9XCJQT1NUXCIpLHYuYWpheCh7dXJsOmUsdHlwZTpzLGRhdGFUeXBlOlwiaHRtbFwiLGRhdGE6bixjb21wbGV0ZTpmdW5jdGlvbihlLHQpe3ImJnUuZWFjaChyLG98fFtlLnJlc3BvbnNlVGV4dCx0LGVdKX19KS5kb25lKGZ1bmN0aW9uKGUpe289YXJndW1lbnRzLHUuaHRtbChpP3YoXCI8ZGl2PlwiKS5hcHBlbmQoZS5yZXBsYWNlKHluLFwiXCIpKS5maW5kKGkpOmUpfSksdGhpc30sdi5lYWNoKFwiYWpheFN0YXJ0IGFqYXhTdG9wIGFqYXhDb21wbGV0ZSBhamF4RXJyb3IgYWpheFN1Y2Nlc3MgYWpheFNlbmRcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXt2LmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSksdi5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihlLG4pe3Zbbl09ZnVuY3Rpb24oZSxyLGkscyl7cmV0dXJuIHYuaXNGdW5jdGlvbihyKSYmKHM9c3x8aSxpPXIscj10KSx2LmFqYXgoe3R5cGU6bix1cmw6ZSxkYXRhOnIsc3VjY2VzczppLGRhdGFUeXBlOnN9KX19KSx2LmV4dGVuZCh7Z2V0U2NyaXB0OmZ1bmN0aW9uKGUsbil7cmV0dXJuIHYuZ2V0KGUsdCxuLFwic2NyaXB0XCIpfSxnZXRKU09OOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdi5nZXQoZSx0LG4sXCJqc29uXCIpfSxhamF4U2V0dXA6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD9MbihlLHYuYWpheFNldHRpbmdzKToodD1lLGU9di5hamF4U2V0dGluZ3MpLExuKGUsdCksZX0sYWpheFNldHRpbmdzOnt1cmw6Y24saXNMb2NhbDpkbi50ZXN0KGxuWzFdKSxnbG9iYWw6ITAsdHlwZTpcIkdFVFwiLGNvbnRlbnRUeXBlOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIscHJvY2Vzc0RhdGE6ITAsYXN5bmM6ITAsYWNjZXB0czp7eG1sOlwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLGh0bWw6XCJ0ZXh0L2h0bWxcIix0ZXh0OlwidGV4dC9wbGFpblwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIixcIipcIjpUbn0sY29udGVudHM6e3htbDoveG1sLyxodG1sOi9odG1sLyxqc29uOi9qc29uL30scmVzcG9uc2VGaWVsZHM6e3htbDpcInJlc3BvbnNlWE1MXCIsdGV4dDpcInJlc3BvbnNlVGV4dFwifSxjb252ZXJ0ZXJzOntcIiogdGV4dFwiOmUuU3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjp2LnBhcnNlSlNPTixcInRleHQgeG1sXCI6di5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e2NvbnRleHQ6ITAsdXJsOiEwfX0sYWpheFByZWZpbHRlcjpDbihTbiksYWpheFRyYW5zcG9ydDpDbih4biksYWpheDpmdW5jdGlvbihlLG4pe2Z1bmN0aW9uIFQoZSxuLHMsYSl7dmFyIGwseSxiLHcsUyxUPW47aWYoRT09PTIpcmV0dXJuO0U9Mix1JiZjbGVhclRpbWVvdXQodSksbz10LGk9YXx8XCJcIix4LnJlYWR5U3RhdGU9ZT4wPzQ6MCxzJiYodz1BbihjLHgscykpO2lmKGU+PTIwMCYmZTwzMDB8fGU9PT0zMDQpYy5pZk1vZGlmaWVkJiYoUz14LmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSxTJiYodi5sYXN0TW9kaWZpZWRbcl09UyksUz14LmdldFJlc3BvbnNlSGVhZGVyKFwiRXRhZ1wiKSxTJiYodi5ldGFnW3JdPVMpKSxlPT09MzA0PyhUPVwibm90bW9kaWZpZWRcIixsPSEwKToobD1PbihjLHcpLFQ9bC5zdGF0ZSx5PWwuZGF0YSxiPWwuZXJyb3IsbD0hYik7ZWxzZXtiPVQ7aWYoIVR8fGUpVD1cImVycm9yXCIsZTwwJiYoZT0wKX14LnN0YXR1cz1lLHguc3RhdHVzVGV4dD0obnx8VCkrXCJcIixsP2QucmVzb2x2ZVdpdGgoaCxbeSxULHhdKTpkLnJlamVjdFdpdGgoaCxbeCxULGJdKSx4LnN0YXR1c0NvZGUoZyksZz10LGYmJnAudHJpZ2dlcihcImFqYXhcIisobD9cIlN1Y2Nlc3NcIjpcIkVycm9yXCIpLFt4LGMsbD95OmJdKSxtLmZpcmVXaXRoKGgsW3gsVF0pLGYmJihwLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIixbeCxjXSksLS12LmFjdGl2ZXx8di5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpfXR5cGVvZiBlPT1cIm9iamVjdFwiJiYobj1lLGU9dCksbj1ufHx7fTt2YXIgcixpLHMsbyx1LGEsZixsLGM9di5hamF4U2V0dXAoe30sbiksaD1jLmNvbnRleHR8fGMscD1oIT09YyYmKGgubm9kZVR5cGV8fGggaW5zdGFuY2VvZiB2KT92KGgpOnYuZXZlbnQsZD12LkRlZmVycmVkKCksbT12LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLGc9Yy5zdGF0dXNDb2RlfHx7fSxiPXt9LHc9e30sRT0wLFM9XCJjYW5jZWxlZFwiLHg9e3JlYWR5U3RhdGU6MCxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGUsdCl7aWYoIUUpe3ZhciBuPWUudG9Mb3dlckNhc2UoKTtlPXdbbl09d1tuXXx8ZSxiW2VdPXR9cmV0dXJuIHRoaXN9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiBFPT09Mj9pOm51bGx9LGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGUpe3ZhciBuO2lmKEU9PT0yKXtpZighcyl7cz17fTt3aGlsZShuPXBuLmV4ZWMoaSkpc1tuWzFdLnRvTG93ZXJDYXNlKCldPW5bMl19bj1zW2UudG9Mb3dlckNhc2UoKV19cmV0dXJuIG49PT10P251bGw6bn0sb3ZlcnJpZGVNaW1lVHlwZTpmdW5jdGlvbihlKXtyZXR1cm4gRXx8KGMubWltZVR5cGU9ZSksdGhpc30sYWJvcnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZXx8UyxvJiZvLmFib3J0KGUpLFQoMCxlKSx0aGlzfX07ZC5wcm9taXNlKHgpLHguc3VjY2Vzcz14LmRvbmUseC5lcnJvcj14LmZhaWwseC5jb21wbGV0ZT1tLmFkZCx4LnN0YXR1c0NvZGU9ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIHQ7aWYoRTwyKWZvcih0IGluIGUpZ1t0XT1bZ1t0XSxlW3RdXTtlbHNlIHQ9ZVt4LnN0YXR1c10seC5hbHdheXModCl9cmV0dXJuIHRoaXN9LGMudXJsPSgoZXx8Yy51cmwpK1wiXCIpLnJlcGxhY2UoaG4sXCJcIikucmVwbGFjZShtbixsblsxXStcIi8vXCIpLGMuZGF0YVR5cGVzPXYudHJpbShjLmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5zcGxpdCh5KSxjLmNyb3NzRG9tYWluPT1udWxsJiYoYT13bi5leGVjKGMudXJsLnRvTG93ZXJDYXNlKCkpLGMuY3Jvc3NEb21haW49ISghYXx8YVsxXT09PWxuWzFdJiZhWzJdPT09bG5bMl0mJihhWzNdfHwoYVsxXT09PVwiaHR0cDpcIj84MDo0NDMpKT09KGxuWzNdfHwobG5bMV09PT1cImh0dHA6XCI/ODA6NDQzKSkpKSxjLmRhdGEmJmMucHJvY2Vzc0RhdGEmJnR5cGVvZiBjLmRhdGEhPVwic3RyaW5nXCImJihjLmRhdGE9di5wYXJhbShjLmRhdGEsYy50cmFkaXRpb25hbCkpLGtuKFNuLGMsbix4KTtpZihFPT09MilyZXR1cm4geDtmPWMuZ2xvYmFsLGMudHlwZT1jLnR5cGUudG9VcHBlckNhc2UoKSxjLmhhc0NvbnRlbnQ9IXZuLnRlc3QoYy50eXBlKSxmJiZ2LmFjdGl2ZSsrPT09MCYmdi5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO2lmKCFjLmhhc0NvbnRlbnQpe2MuZGF0YSYmKGMudXJsKz0oZ24udGVzdChjLnVybCk/XCImXCI6XCI/XCIpK2MuZGF0YSxkZWxldGUgYy5kYXRhKSxyPWMudXJsO2lmKGMuY2FjaGU9PT0hMSl7dmFyIE49di5ub3coKSxDPWMudXJsLnJlcGxhY2UoYm4sXCIkMV89XCIrTik7Yy51cmw9QysoQz09PWMudXJsPyhnbi50ZXN0KGMudXJsKT9cIiZcIjpcIj9cIikrXCJfPVwiK046XCJcIil9fShjLmRhdGEmJmMuaGFzQ29udGVudCYmYy5jb250ZW50VHlwZSE9PSExfHxuLmNvbnRlbnRUeXBlKSYmeC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsYy5jb250ZW50VHlwZSksYy5pZk1vZGlmaWVkJiYocj1yfHxjLnVybCx2Lmxhc3RNb2RpZmllZFtyXSYmeC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIix2Lmxhc3RNb2RpZmllZFtyXSksdi5ldGFnW3JdJiZ4LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsdi5ldGFnW3JdKSkseC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsYy5kYXRhVHlwZXNbMF0mJmMuYWNjZXB0c1tjLmRhdGFUeXBlc1swXV0/Yy5hY2NlcHRzW2MuZGF0YVR5cGVzWzBdXSsoYy5kYXRhVHlwZXNbMF0hPT1cIipcIj9cIiwgXCIrVG4rXCI7IHE9MC4wMVwiOlwiXCIpOmMuYWNjZXB0c1tcIipcIl0pO2ZvcihsIGluIGMuaGVhZGVycyl4LnNldFJlcXVlc3RIZWFkZXIobCxjLmhlYWRlcnNbbF0pO2lmKCFjLmJlZm9yZVNlbmR8fGMuYmVmb3JlU2VuZC5jYWxsKGgseCxjKSE9PSExJiZFIT09Mil7Uz1cImFib3J0XCI7Zm9yKGwgaW57c3VjY2VzczoxLGVycm9yOjEsY29tcGxldGU6MX0peFtsXShjW2xdKTtvPWtuKHhuLGMsbix4KTtpZighbylUKC0xLFwiTm8gVHJhbnNwb3J0XCIpO2Vsc2V7eC5yZWFkeVN0YXRlPTEsZiYmcC50cmlnZ2VyKFwiYWpheFNlbmRcIixbeCxjXSksYy5hc3luYyYmYy50aW1lb3V0PjAmJih1PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt4LmFib3J0KFwidGltZW91dFwiKX0sYy50aW1lb3V0KSk7dHJ5e0U9MSxvLnNlbmQoYixUKX1jYXRjaChrKXtpZighKEU8MikpdGhyb3cgaztUKC0xLGspfX1yZXR1cm4geH1yZXR1cm4geC5hYm9ydCgpfSxhY3RpdmU6MCxsYXN0TW9kaWZpZWQ6e30sZXRhZzp7fX0pO3ZhciBNbj1bXSxfbj0vXFw/LyxEbj0vKD0pXFw/KD89JnwkKXxcXD9cXD8vLFBuPXYubm93KCk7di5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGU9TW4ucG9wKCl8fHYuZXhwYW5kbytcIl9cIitQbisrO3JldHVybiB0aGlzW2VdPSEwLGV9fSksdi5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKG4scixpKXt2YXIgcyxvLHUsYT1uLmRhdGEsZj1uLnVybCxsPW4uanNvbnAhPT0hMSxjPWwmJkRuLnRlc3QoZiksaD1sJiYhYyYmdHlwZW9mIGE9PVwic3RyaW5nXCImJiEobi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmRG4udGVzdChhKTtpZihuLmRhdGFUeXBlc1swXT09PVwianNvbnBcInx8Y3x8aClyZXR1cm4gcz1uLmpzb25wQ2FsbGJhY2s9di5pc0Z1bmN0aW9uKG4uanNvbnBDYWxsYmFjayk/bi5qc29ucENhbGxiYWNrKCk6bi5qc29ucENhbGxiYWNrLG89ZVtzXSxjP24udXJsPWYucmVwbGFjZShEbixcIiQxXCIrcyk6aD9uLmRhdGE9YS5yZXBsYWNlKERuLFwiJDFcIitzKTpsJiYobi51cmwrPShfbi50ZXN0KGYpP1wiJlwiOlwiP1wiKStuLmpzb25wK1wiPVwiK3MpLG4uY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIHV8fHYuZXJyb3IocytcIiB3YXMgbm90IGNhbGxlZFwiKSx1WzBdfSxuLmRhdGFUeXBlc1swXT1cImpzb25cIixlW3NdPWZ1bmN0aW9uKCl7dT1hcmd1bWVudHN9LGkuYWx3YXlzKGZ1bmN0aW9uKCl7ZVtzXT1vLG5bc10mJihuLmpzb25wQ2FsbGJhY2s9ci5qc29ucENhbGxiYWNrLE1uLnB1c2gocykpLHUmJnYuaXNGdW5jdGlvbihvKSYmbyh1WzBdKSx1PW89dH0pLFwic2NyaXB0XCJ9KSx2LmFqYXhTZXR1cCh7YWNjZXB0czp7c2NyaXB0OlwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sY29udGVudHM6e3NjcmlwdDovamF2YXNjcmlwdHxlY21hc2NyaXB0L30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGUpe3JldHVybiB2Lmdsb2JhbEV2YWwoZSksZX19fSksdi5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oZSl7ZS5jYWNoZT09PXQmJihlLmNhY2hlPSExKSxlLmNyb3NzRG9tYWluJiYoZS50eXBlPVwiR0VUXCIsZS5nbG9iYWw9ITEpfSksdi5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsZnVuY3Rpb24oZSl7aWYoZS5jcm9zc0RvbWFpbil7dmFyIG4scj1pLmhlYWR8fGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdfHxpLmRvY3VtZW50RWxlbWVudDtyZXR1cm57c2VuZDpmdW5jdGlvbihzLG8pe249aS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLG4uYXN5bmM9XCJhc3luY1wiLGUuc2NyaXB0Q2hhcnNldCYmKG4uY2hhcnNldD1lLnNjcmlwdENoYXJzZXQpLG4uc3JjPWUudXJsLG4ub25sb2FkPW4ub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGUsaSl7aWYoaXx8IW4ucmVhZHlTdGF0ZXx8L2xvYWRlZHxjb21wbGV0ZS8udGVzdChuLnJlYWR5U3RhdGUpKW4ub25sb2FkPW4ub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsciYmbi5wYXJlbnROb2RlJiZyLnJlbW92ZUNoaWxkKG4pLG49dCxpfHxvKDIwMCxcInN1Y2Nlc3NcIil9LHIuaW5zZXJ0QmVmb3JlKG4sci5maXJzdENoaWxkKX0sYWJvcnQ6ZnVuY3Rpb24oKXtuJiZuLm9ubG9hZCgwLDEpfX19fSk7dmFyIEhuLEJuPWUuQWN0aXZlWE9iamVjdD9mdW5jdGlvbigpe2Zvcih2YXIgZSBpbiBIbilIbltlXSgwLDEpfTohMSxqbj0wO3YuYWpheFNldHRpbmdzLnhocj1lLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0xvY2FsJiZGbigpfHxJbigpfTpGbixmdW5jdGlvbihlKXt2LmV4dGVuZCh2LnN1cHBvcnQse2FqYXg6ISFlLGNvcnM6ISFlJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gZX0pfSh2LmFqYXhTZXR0aW5ncy54aHIoKSksdi5zdXBwb3J0LmFqYXgmJnYuYWpheFRyYW5zcG9ydChmdW5jdGlvbihuKXtpZighbi5jcm9zc0RvbWFpbnx8di5zdXBwb3J0LmNvcnMpe3ZhciByO3JldHVybntzZW5kOmZ1bmN0aW9uKGkscyl7dmFyIG8sdSxhPW4ueGhyKCk7bi51c2VybmFtZT9hLm9wZW4obi50eXBlLG4udXJsLG4uYXN5bmMsbi51c2VybmFtZSxuLnBhc3N3b3JkKTphLm9wZW4obi50eXBlLG4udXJsLG4uYXN5bmMpO2lmKG4ueGhyRmllbGRzKWZvcih1IGluIG4ueGhyRmllbGRzKWFbdV09bi54aHJGaWVsZHNbdV07bi5taW1lVHlwZSYmYS5vdmVycmlkZU1pbWVUeXBlJiZhLm92ZXJyaWRlTWltZVR5cGUobi5taW1lVHlwZSksIW4uY3Jvc3NEb21haW4mJiFpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSYmKGlbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIik7dHJ5e2Zvcih1IGluIGkpYS5zZXRSZXF1ZXN0SGVhZGVyKHUsaVt1XSl9Y2F0Y2goZil7fWEuc2VuZChuLmhhc0NvbnRlbnQmJm4uZGF0YXx8bnVsbCkscj1mdW5jdGlvbihlLGkpe3ZhciB1LGYsbCxjLGg7dHJ5e2lmKHImJihpfHxhLnJlYWR5U3RhdGU9PT00KSl7cj10LG8mJihhLm9ucmVhZHlzdGF0ZWNoYW5nZT12Lm5vb3AsQm4mJmRlbGV0ZSBIbltvXSk7aWYoaSlhLnJlYWR5U3RhdGUhPT00JiZhLmFib3J0KCk7ZWxzZXt1PWEuc3RhdHVzLGw9YS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxjPXt9LGg9YS5yZXNwb25zZVhNTCxoJiZoLmRvY3VtZW50RWxlbWVudCYmKGMueG1sPWgpO3RyeXtjLnRleHQ9YS5yZXNwb25zZVRleHR9Y2F0Y2gocCl7fXRyeXtmPWEuc3RhdHVzVGV4dH1jYXRjaChwKXtmPVwiXCJ9IXUmJm4uaXNMb2NhbCYmIW4uY3Jvc3NEb21haW4/dT1jLnRleHQ/MjAwOjQwNDp1PT09MTIyMyYmKHU9MjA0KX19fWNhdGNoKGQpe2l8fHMoLTEsZCl9YyYmcyh1LGYsYyxsKX0sbi5hc3luYz9hLnJlYWR5U3RhdGU9PT00P3NldFRpbWVvdXQociwwKToobz0rK2puLEJuJiYoSG58fChIbj17fSx2KGUpLnVubG9hZChCbikpLEhuW29dPXIpLGEub25yZWFkeXN0YXRlY2hhbmdlPXIpOnIoKX0sYWJvcnQ6ZnVuY3Rpb24oKXtyJiZyKDAsMSl9fX19KTt2YXIgcW4sUm4sVW49L14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLHpuPW5ldyBSZWdFeHAoXCJeKD86KFstK10pPXwpKFwiK20rXCIpKFthLXolXSopJFwiLFwiaVwiKSxXbj0vcXVldWVIb29rcyQvLFhuPVtHbl0sVm49e1wiKlwiOltmdW5jdGlvbihlLHQpe3ZhciBuLHIsaT10aGlzLmNyZWF0ZVR3ZWVuKGUsdCkscz16bi5leGVjKHQpLG89aS5jdXIoKSx1PStvfHwwLGE9MSxmPTIwO2lmKHMpe249K3NbMl0scj1zWzNdfHwodi5jc3NOdW1iZXJbZV0/XCJcIjpcInB4XCIpO2lmKHIhPT1cInB4XCImJnUpe3U9di5jc3MoaS5lbGVtLGUsITApfHxufHwxO2RvIGE9YXx8XCIuNVwiLHUvPWEsdi5zdHlsZShpLmVsZW0sZSx1K3IpO3doaWxlKGEhPT0oYT1pLmN1cigpL28pJiZhIT09MSYmLS1mKX1pLnVuaXQ9cixpLnN0YXJ0PXUsaS5lbmQ9c1sxXT91KyhzWzFdKzEpKm46bn1yZXR1cm4gaX1dfTt2LkFuaW1hdGlvbj12LmV4dGVuZChLbix7dHdlZW5lcjpmdW5jdGlvbihlLHQpe3YuaXNGdW5jdGlvbihlKT8odD1lLGU9W1wiKlwiXSk6ZT1lLnNwbGl0KFwiIFwiKTt2YXIgbixyPTAsaT1lLmxlbmd0aDtmb3IoO3I8aTtyKyspbj1lW3JdLFZuW25dPVZuW25dfHxbXSxWbltuXS51bnNoaWZ0KHQpfSxwcmVmaWx0ZXI6ZnVuY3Rpb24oZSx0KXt0P1huLnVuc2hpZnQoZSk6WG4ucHVzaChlKX19KSx2LlR3ZWVuPVluLFluLnByb3RvdHlwZT17Y29uc3RydWN0b3I6WW4saW5pdDpmdW5jdGlvbihlLHQsbixyLGkscyl7dGhpcy5lbGVtPWUsdGhpcy5wcm9wPW4sdGhpcy5lYXNpbmc9aXx8XCJzd2luZ1wiLHRoaXMub3B0aW9ucz10LHRoaXMuc3RhcnQ9dGhpcy5ub3c9dGhpcy5jdXIoKSx0aGlzLmVuZD1yLHRoaXMudW5pdD1zfHwodi5jc3NOdW1iZXJbbl0/XCJcIjpcInB4XCIpfSxjdXI6ZnVuY3Rpb24oKXt2YXIgZT1Zbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gZSYmZS5nZXQ/ZS5nZXQodGhpcyk6WW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGUpe3ZhciB0LG49WW4ucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbj90aGlzLnBvcz10PXYuZWFzaW5nW3RoaXMuZWFzaW5nXShlLHRoaXMub3B0aW9ucy5kdXJhdGlvbiplLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOnRoaXMucG9zPXQ9ZSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqdCt0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxuJiZuLnNldD9uLnNldCh0aGlzKTpZbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSxZbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9WW4ucHJvdG90eXBlLFluLnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gZS5lbGVtW2UucHJvcF09PW51bGx8fCEhZS5lbGVtLnN0eWxlJiZlLmVsZW0uc3R5bGVbZS5wcm9wXSE9bnVsbD8odD12LmNzcyhlLmVsZW0sZS5wcm9wLCExLFwiXCIpLCF0fHx0PT09XCJhdXRvXCI/MDp0KTplLmVsZW1bZS5wcm9wXX0sc2V0OmZ1bmN0aW9uKGUpe3YuZnguc3RlcFtlLnByb3BdP3YuZnguc3RlcFtlLnByb3BdKGUpOmUuZWxlbS5zdHlsZSYmKGUuZWxlbS5zdHlsZVt2LmNzc1Byb3BzW2UucHJvcF1dIT1udWxsfHx2LmNzc0hvb2tzW2UucHJvcF0pP3Yuc3R5bGUoZS5lbGVtLGUucHJvcCxlLm5vdytlLnVuaXQpOmUuZWxlbVtlLnByb3BdPWUubm93fX19LFluLnByb3BIb29rcy5zY3JvbGxUb3A9WW4ucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihlKXtlLmVsZW0ubm9kZVR5cGUmJmUuZWxlbS5wYXJlbnROb2RlJiYoZS5lbGVtW2UucHJvcF09ZS5ub3cpfX0sdi5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHQpe3ZhciBuPXYuZm5bdF07di5mblt0XT1mdW5jdGlvbihyLGkscyl7cmV0dXJuIHI9PW51bGx8fHR5cGVvZiByPT1cImJvb2xlYW5cInx8IWUmJnYuaXNGdW5jdGlvbihyKSYmdi5pc0Z1bmN0aW9uKGkpP24uYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMuYW5pbWF0ZShabih0LCEwKSxyLGkscyl9fSksdi5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5maWx0ZXIoR3QpLmNzcyhcIm9wYWNpdHlcIiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTp0fSxlLG4scil9LGFuaW1hdGU6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9di5pc0VtcHR5T2JqZWN0KGUpLHM9di5zcGVlZCh0LG4sciksbz1mdW5jdGlvbigpe3ZhciB0PUtuKHRoaXMsdi5leHRlbmQoe30sZSkscyk7aSYmdC5zdG9wKCEwKX07cmV0dXJuIGl8fHMucXVldWU9PT0hMT90aGlzLmVhY2gobyk6dGhpcy5xdWV1ZShzLnF1ZXVlLG8pfSxzdG9wOmZ1bmN0aW9uKGUsbixyKXt2YXIgaT1mdW5jdGlvbihlKXt2YXIgdD1lLnN0b3A7ZGVsZXRlIGUuc3RvcCx0KHIpfTtyZXR1cm4gdHlwZW9mIGUhPVwic3RyaW5nXCImJihyPW4sbj1lLGU9dCksbiYmZSE9PSExJiZ0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ITAsbj1lIT1udWxsJiZlK1wicXVldWVIb29rc1wiLHM9di50aW1lcnMsbz12Ll9kYXRhKHRoaXMpO2lmKG4pb1tuXSYmb1tuXS5zdG9wJiZpKG9bbl0pO2Vsc2UgZm9yKG4gaW4gbylvW25dJiZvW25dLnN0b3AmJlduLnRlc3QobikmJmkob1tuXSk7Zm9yKG49cy5sZW5ndGg7bi0tOylzW25dLmVsZW09PT10aGlzJiYoZT09bnVsbHx8c1tuXS5xdWV1ZT09PWUpJiYoc1tuXS5hbmltLnN0b3AociksdD0hMSxzLnNwbGljZShuLDEpKTsodHx8IXIpJiZ2LmRlcXVldWUodGhpcyxlKX0pfX0pLHYuZWFjaCh7c2xpZGVEb3duOlpuKFwic2hvd1wiKSxzbGlkZVVwOlpuKFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpabihcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGUsdCl7di5mbltlXT1mdW5jdGlvbihlLG4scil7cmV0dXJuIHRoaXMuYW5pbWF0ZSh0LGUsbixyKX19KSx2LnNwZWVkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1lJiZ0eXBlb2YgZT09XCJvYmplY3RcIj92LmV4dGVuZCh7fSxlKTp7Y29tcGxldGU6bnx8IW4mJnR8fHYuaXNGdW5jdGlvbihlKSYmZSxkdXJhdGlvbjplLGVhc2luZzpuJiZ0fHx0JiYhdi5pc0Z1bmN0aW9uKHQpJiZ0fTtyLmR1cmF0aW9uPXYuZngub2ZmPzA6dHlwZW9mIHIuZHVyYXRpb249PVwibnVtYmVyXCI/ci5kdXJhdGlvbjpyLmR1cmF0aW9uIGluIHYuZnguc3BlZWRzP3YuZnguc3BlZWRzW3IuZHVyYXRpb25dOnYuZnguc3BlZWRzLl9kZWZhdWx0O2lmKHIucXVldWU9PW51bGx8fHIucXVldWU9PT0hMClyLnF1ZXVlPVwiZnhcIjtyZXR1cm4gci5vbGQ9ci5jb21wbGV0ZSxyLmNvbXBsZXRlPWZ1bmN0aW9uKCl7di5pc0Z1bmN0aW9uKHIub2xkKSYmci5vbGQuY2FsbCh0aGlzKSxyLnF1ZXVlJiZ2LmRlcXVldWUodGhpcyxyLnF1ZXVlKX0scn0sdi5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sc3dpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuLjUtTWF0aC5jb3MoZSpNYXRoLlBJKS8yfX0sdi50aW1lcnM9W10sdi5meD1Zbi5wcm90b3R5cGUuaW5pdCx2LmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSxuPXYudGltZXJzLHI9MDtxbj12Lm5vdygpO2Zvcig7cjxuLmxlbmd0aDtyKyspZT1uW3JdLCFlKCkmJm5bcl09PT1lJiZuLnNwbGljZShyLS0sMSk7bi5sZW5ndGh8fHYuZnguc3RvcCgpLHFuPXR9LHYuZngudGltZXI9ZnVuY3Rpb24oZSl7ZSgpJiZ2LnRpbWVycy5wdXNoKGUpJiYhUm4mJihSbj1zZXRJbnRlcnZhbCh2LmZ4LnRpY2ssdi5meC5pbnRlcnZhbCkpfSx2LmZ4LmludGVydmFsPTEzLHYuZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoUm4pLFJuPW51bGx9LHYuZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LHYuZnguc3RlcD17fSx2LmV4cHImJnYuZXhwci5maWx0ZXJzJiYodi5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHYuZ3JlcCh2LnRpbWVycyxmdW5jdGlvbih0KXtyZXR1cm4gZT09PXQuZWxlbX0pLmxlbmd0aH0pO3ZhciBlcj0vXig/OmJvZHl8aHRtbCkkL2k7di5mbi5vZmZzZXQ9ZnVuY3Rpb24oZSl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZT09PXQ/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24odCl7di5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsZSx0KX0pO3ZhciBuLHIsaSxzLG8sdSxhLGY9e3RvcDowLGxlZnQ6MH0sbD10aGlzWzBdLGM9bCYmbC5vd25lckRvY3VtZW50O2lmKCFjKXJldHVybjtyZXR1cm4ocj1jLmJvZHkpPT09bD92Lm9mZnNldC5ib2R5T2Zmc2V0KGwpOihuPWMuZG9jdW1lbnRFbGVtZW50LHYuY29udGFpbnMobixsKT8odHlwZW9mIGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IT1cInVuZGVmaW5lZFwiJiYoZj1sLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxpPXRyKGMpLHM9bi5jbGllbnRUb3B8fHIuY2xpZW50VG9wfHwwLG89bi5jbGllbnRMZWZ0fHxyLmNsaWVudExlZnR8fDAsdT1pLnBhZ2VZT2Zmc2V0fHxuLnNjcm9sbFRvcCxhPWkucGFnZVhPZmZzZXR8fG4uc2Nyb2xsTGVmdCx7dG9wOmYudG9wK3UtcyxsZWZ0OmYubGVmdCthLW99KTpmKX0sdi5vZmZzZXQ9e2JvZHlPZmZzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vZmZzZXRUb3Asbj1lLm9mZnNldExlZnQ7cmV0dXJuIHYuc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCYmKHQrPXBhcnNlRmxvYXQodi5jc3MoZSxcIm1hcmdpblRvcFwiKSl8fDAsbis9cGFyc2VGbG9hdCh2LmNzcyhlLFwibWFyZ2luTGVmdFwiKSl8fDApLHt0b3A6dCxsZWZ0Om59fSxzZXRPZmZzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXYuY3NzKGUsXCJwb3NpdGlvblwiKTtyPT09XCJzdGF0aWNcIiYmKGUuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKTt2YXIgaT12KGUpLHM9aS5vZmZzZXQoKSxvPXYuY3NzKGUsXCJ0b3BcIiksdT12LmNzcyhlLFwibGVmdFwiKSxhPShyPT09XCJhYnNvbHV0ZVwifHxyPT09XCJmaXhlZFwiKSYmdi5pbkFycmF5KFwiYXV0b1wiLFtvLHVdKT4tMSxmPXt9LGw9e30sYyxoO2E/KGw9aS5wb3NpdGlvbigpLGM9bC50b3AsaD1sLmxlZnQpOihjPXBhcnNlRmxvYXQobyl8fDAsaD1wYXJzZUZsb2F0KHUpfHwwKSx2LmlzRnVuY3Rpb24odCkmJih0PXQuY2FsbChlLG4scykpLHQudG9wIT1udWxsJiYoZi50b3A9dC50b3Atcy50b3ArYyksdC5sZWZ0IT1udWxsJiYoZi5sZWZ0PXQubGVmdC1zLmxlZnQraCksXCJ1c2luZ1wiaW4gdD90LnVzaW5nLmNhbGwoZSxmKTppLmNzcyhmKX19LHYuZm4uZXh0ZW5kKHtwb3NpdGlvbjpmdW5jdGlvbigpe2lmKCF0aGlzWzBdKXJldHVybjt2YXIgZT10aGlzWzBdLHQ9dGhpcy5vZmZzZXRQYXJlbnQoKSxuPXRoaXMub2Zmc2V0KCkscj1lci50ZXN0KHRbMF0ubm9kZU5hbWUpP3t0b3A6MCxsZWZ0OjB9OnQub2Zmc2V0KCk7cmV0dXJuIG4udG9wLT1wYXJzZUZsb2F0KHYuY3NzKGUsXCJtYXJnaW5Ub3BcIikpfHwwLG4ubGVmdC09cGFyc2VGbG9hdCh2LmNzcyhlLFwibWFyZ2luTGVmdFwiKSl8fDAsci50b3ArPXBhcnNlRmxvYXQodi5jc3ModFswXSxcImJvcmRlclRvcFdpZHRoXCIpKXx8MCxyLmxlZnQrPXBhcnNlRmxvYXQodi5jc3ModFswXSxcImJvcmRlckxlZnRXaWR0aFwiKSl8fDAse3RvcDpuLnRvcC1yLnRvcCxsZWZ0Om4ubGVmdC1yLmxlZnR9fSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9mZnNldFBhcmVudHx8aS5ib2R5O3doaWxlKGUmJiFlci50ZXN0KGUubm9kZU5hbWUpJiZ2LmNzcyhlLFwicG9zaXRpb25cIik9PT1cInN0YXRpY1wiKWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fGkuYm9keX0pfX0pLHYuZWFjaCh7c2Nyb2xsTGVmdDpcInBhZ2VYT2Zmc2V0XCIsc2Nyb2xsVG9wOlwicGFnZVlPZmZzZXRcIn0sZnVuY3Rpb24oZSxuKXt2YXIgcj0vWS8udGVzdChuKTt2LmZuW2VdPWZ1bmN0aW9uKGkpe3JldHVybiB2LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGUsaSxzKXt2YXIgbz10cihlKTtpZihzPT09dClyZXR1cm4gbz9uIGluIG8/b1tuXTpvLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtpXTplW2ldO28/by5zY3JvbGxUbyhyP3Yobykuc2Nyb2xsTGVmdCgpOnMscj9zOnYobykuc2Nyb2xsVG9wKCkpOmVbaV09c30sZSxpLGFyZ3VtZW50cy5sZW5ndGgsbnVsbCl9fSksdi5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGUsbil7di5lYWNoKHtwYWRkaW5nOlwiaW5uZXJcIitlLGNvbnRlbnQ6bixcIlwiOlwib3V0ZXJcIitlfSxmdW5jdGlvbihyLGkpe3YuZm5baV09ZnVuY3Rpb24oaSxzKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoJiYocnx8dHlwZW9mIGkhPVwiYm9vbGVhblwiKSx1PXJ8fChpPT09ITB8fHM9PT0hMD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiB2LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKG4scixpKXt2YXIgcztyZXR1cm4gdi5pc1dpbmRvdyhuKT9uLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2VdOm4ubm9kZVR5cGU9PT05PyhzPW4uZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KG4uYm9keVtcInNjcm9sbFwiK2VdLHNbXCJzY3JvbGxcIitlXSxuLmJvZHlbXCJvZmZzZXRcIitlXSxzW1wib2Zmc2V0XCIrZV0sc1tcImNsaWVudFwiK2VdKSk6aT09PXQ/di5jc3MobixyLGksdSk6di5zdHlsZShuLHIsaSx1KX0sbixvP2k6dCxvLG51bGwpfX0pfSksZS5qUXVlcnk9ZS4kPXYsdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUuYW1kLmpRdWVyeSYmZGVmaW5lKFwianF1ZXJ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gdn0pfSkod2luZG93KTtcbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mICQgIT0gXCJ1bmRlZmluZWRcIiA/ICQgOiB3aW5kb3cuJCk7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcbiIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS9Db21tb25KU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAod2l0aCBzdXBwb3J0IGZvciB3ZWIgd29ya2VycylcbiAgICAgICAgdmFyIGdsb2I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsb2IgPSB3aW5kb3c7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2IgPSBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYi5TcGFya01ENSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qXG4gICAgICogRmFzdGVzdCBtZDUgaW1wbGVtZW50YXRpb24gYXJvdW5kIChKS00gbWQ1KS5cbiAgICAgKiBDcmVkaXRzOiBKb3NlcGggTXllcnNcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUtdGV4dC5odG1sXG4gICAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9tZDUtc2hvb3RvdXQvN1xuICAgICAqL1xuXG4gICAgLyogdGhpcyBmdW5jdGlvbiBpcyBtdWNoIGZhc3RlcixcbiAgICAgIHNvIGlmIHBvc3NpYmxlIHdlIHVzZSBpdC4gU29tZSBJRXNcbiAgICAgIGFyZSB0aGUgb25seSBvbmVzIEkga25vdyBvZiB0aGF0XG4gICAgICBuZWVkIHRoZSBpZGlvdGljIHNlY29uZCBmdW5jdGlvbixcbiAgICAgIGdlbmVyYXRlZCBieSBhbiBpZiBjbGF1c2UuICAqL1xuICAgIHZhciBhZGQzMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSArIGIpICYgMHhGRkZGRkZGRjtcbiAgICB9LFxuICAgICAgICBoZXhfY2hyID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ107XG5cblxuICAgIGZ1bmN0aW9uIGNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgICAgIGEgPSBhZGQzMihhZGQzMihhLCBxKSwgYWRkMzIoeCwgdCkpO1xuICAgICAgICByZXR1cm4gYWRkMzIoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZDVjeWNsZSh4LCBrKSB7XG4gICAgICAgIHZhciBhID0geFswXSxcbiAgICAgICAgICAgIGIgPSB4WzFdLFxuICAgICAgICAgICAgYyA9IHhbMl0sXG4gICAgICAgICAgICBkID0geFszXTtcblxuICAgICAgICBhICs9IChiICYgYyB8IH5iICYgZCkgKyBrWzBdIC0gNjgwODc2OTM2IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgJiBiIHwgfmEgJiBjKSArIGtbMV0gLSAzODk1NjQ1ODYgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEyIHwgZCA+Pj4gMjApICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgJiBhIHwgfmQgJiBiKSArIGtbMl0gKyA2MDYxMDU4MTkgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE3IHwgYyA+Pj4gMTUpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgJiBkIHwgfmMgJiBhKSArIGtbM10gLSAxMDQ0NTI1MzMwIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgfCAwO1xuICAgICAgICBhICs9IChiICYgYyB8IH5iICYgZCkgKyBrWzRdIC0gMTc2NDE4ODk3IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgJiBiIHwgfmEgJiBjKSArIGtbNV0gKyAxMjAwMDgwNDI2IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMiB8IGQgPj4+IDIwKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYSB8IH5kICYgYikgKyBrWzZdIC0gMTQ3MzIzMTM0MSB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTcgfCBjID4+PiAxNSkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGQgfCB+YyAmIGEpICsga1s3XSAtIDQ1NzA1OTgzIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgfCAwO1xuICAgICAgICBhICs9IChiICYgYyB8IH5iICYgZCkgKyBrWzhdICsgMTc3MDAzNTQxNiB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNyB8IGEgPj4+IDI1KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYiB8IH5hICYgYykgKyBrWzldIC0gMTk1ODQxNDQxNyB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTIgfCBkID4+PiAyMCkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGEgfCB+ZCAmIGIpICsga1sxMF0gLSA0MjA2MyB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTcgfCBjID4+PiAxNSkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGQgfCB+YyAmIGEpICsga1sxMV0gLSAxOTkwNDA0MTYyIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgfCAwO1xuICAgICAgICBhICs9IChiICYgYyB8IH5iICYgZCkgKyBrWzEyXSArIDE4MDQ2MDM2ODIgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDcgfCBhID4+PiAyNSkgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYSAmIGIgfCB+YSAmIGMpICsga1sxM10gLSA0MDM0MTEwMSB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTIgfCBkID4+PiAyMCkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGEgfCB+ZCAmIGIpICsga1sxNF0gLSAxNTAyMDAyMjkwIHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNyB8IGMgPj4+IDE1KSArIGQgfCAwO1xuICAgICAgICBiICs9IChjICYgZCB8IH5jICYgYSkgKyBrWzE1XSArIDEyMzY1MzUzMjkgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIyIHwgYiA+Pj4gMTApICsgYyB8IDA7XG5cbiAgICAgICAgYSArPSAoYiAmIGQgfCBjICYgfmQpICsga1sxXSAtIDE2NTc5NjUxMCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYyB8IGIgJiB+YykgKyBrWzZdIC0gMTA2OTUwMTYzMiB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYiB8IGEgJiB+YikgKyBrWzExXSArIDY0MzcxNzcxMyB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTQgfCBjID4+PiAxOCkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGEgfCBkICYgfmEpICsga1swXSAtIDM3Mzg5NzMwMiB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjAgfCBiID4+PiAxMikgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGQgfCBjICYgfmQpICsga1s1XSAtIDcwMTU1ODY5MSB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYyB8IGIgJiB+YykgKyBrWzEwXSArIDM4MDE2MDgzIHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCA5IHwgZCA+Pj4gMjMpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgJiBiIHwgYSAmIH5iKSArIGtbMTVdIC0gNjYwNDc4MzM1IHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNCB8IGMgPj4+IDE4KSArIGQgfCAwO1xuICAgICAgICBiICs9IChjICYgYSB8IGQgJiB+YSkgKyBrWzRdIC0gNDA1NTM3ODQ4IHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMCB8IGIgPj4+IDEyKSArIGMgfCAwO1xuICAgICAgICBhICs9IChiICYgZCB8IGMgJiB+ZCkgKyBrWzldICsgNTY4NDQ2NDM4IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgJiBjIHwgYiAmIH5jKSArIGtbMTRdIC0gMTAxOTgwMzY5MCB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYiB8IGEgJiB+YikgKyBrWzNdIC0gMTg3MzYzOTYxIHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNCB8IGMgPj4+IDE4KSArIGQgfCAwO1xuICAgICAgICBiICs9IChjICYgYSB8IGQgJiB+YSkgKyBrWzhdICsgMTE2MzUzMTUwMSB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjAgfCBiID4+PiAxMikgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGQgfCBjICYgfmQpICsga1sxM10gLSAxNDQ0NjgxNDY3IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgJiBjIHwgYiAmIH5jKSArIGtbMl0gLSA1MTQwMzc4NCB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYiB8IGEgJiB+YikgKyBrWzddICsgMTczNTMyODQ3MyB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTQgfCBjID4+PiAxOCkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGEgfCBkICYgfmEpICsga1sxMl0gLSAxOTI2NjA3NzM0IHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMCB8IGIgPj4+IDEyKSArIGMgfCAwO1xuXG4gICAgICAgIGEgKz0gKGIgXiBjIF4gZCkgKyBrWzVdIC0gMzc4NTU4IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgXiBiIF4gYykgKyBrWzhdIC0gMjAyMjU3NDQ2MyB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTEgfCBkID4+PiAyMSkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCBeIGEgXiBiKSArIGtbMTFdICsgMTgzOTAzMDU2MiB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyBeIGQgXiBhKSArIGtbMTRdIC0gMzUzMDk1NTYgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIzIHwgYiA+Pj4gOSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiBeIGMgXiBkKSArIGtbMV0gLSAxNTMwOTkyMDYwIHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgXiBiIF4gYykgKyBrWzRdICsgMTI3Mjg5MzM1MyB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTEgfCBkID4+PiAyMSkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCBeIGEgXiBiKSArIGtbN10gLSAxNTU0OTc2MzIgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE2IHwgYyA+Pj4gMTYpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgXiBkIF4gYSkgKyBrWzEwXSAtIDEwOTQ3MzA2NDAgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIzIHwgYiA+Pj4gOSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiBeIGMgXiBkKSArIGtbMTNdICsgNjgxMjc5MTc0IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgXiBiIF4gYykgKyBrWzBdIC0gMzU4NTM3MjIyIHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMSB8IGQgPj4+IDIxKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkIF4gYSBeIGIpICsga1szXSAtIDcyMjUyMTk3OSB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyBeIGQgXiBhKSArIGtbNl0gKyA3NjAyOTE4OSB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjMgfCBiID4+PiA5KSArIGMgfCAwO1xuICAgICAgICBhICs9IChiIF4gYyBeIGQpICsga1s5XSAtIDY0MDM2NDQ4NyB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNCB8IGEgPj4+IDI4KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhIF4gYiBeIGMpICsga1sxMl0gLSA0MjE4MTU4MzUgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDExIHwgZCA+Pj4gMjEpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgXiBhIF4gYikgKyBrWzE1XSArIDUzMDc0MjUyMCB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyBeIGQgXiBhKSArIGtbMl0gLSA5OTUzMzg2NTEgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIzIHwgYiA+Pj4gOSkgKyBjIHwgMDtcblxuICAgICAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsga1swXSAtIDE5ODYzMDg0NCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNiB8IGEgPj4+IDI2KSArIGIgfCAwO1xuICAgICAgICBkICs9IChiIF4gKGEgfCB+YykpICsga1s3XSArIDExMjY4OTE0MTUgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEwIHwgZCA+Pj4gMjIpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGEgXiAoZCB8IH5iKSkgKyBrWzE0XSAtIDE0MTYzNTQ5MDUgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBrWzVdIC0gNTc0MzQwNTUgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIxIHxiID4+PiAxMSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYyBeIChiIHwgfmQpKSArIGtbMTJdICsgMTcwMDQ4NTU3MSB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNiB8IGEgPj4+IDI2KSArIGIgfCAwO1xuICAgICAgICBkICs9IChiIF4gKGEgfCB+YykpICsga1szXSAtIDE4OTQ5ODY2MDYgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEwIHwgZCA+Pj4gMjIpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGEgXiAoZCB8IH5iKSkgKyBrWzEwXSAtIDEwNTE1MjMgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBrWzFdIC0gMjA1NDkyMjc5OSB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjEgfGIgPj4+IDExKSArIGMgfCAwO1xuICAgICAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsga1s4XSArIDE4NzMzMTMzNTkgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDYgfCBhID4+PiAyNikgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYiBeIChhIHwgfmMpKSArIGtbMTVdIC0gMzA2MTE3NDQgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEwIHwgZCA+Pj4gMjIpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGEgXiAoZCB8IH5iKSkgKyBrWzZdIC0gMTU2MDE5ODM4MCB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTUgfCBjID4+PiAxNykgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoZCBeIChjIHwgfmEpKSArIGtbMTNdICsgMTMwOTE1MTY0OSB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjEgfGIgPj4+IDExKSArIGMgfCAwO1xuICAgICAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsga1s0XSAtIDE0NTUyMzA3MCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNiB8IGEgPj4+IDI2KSArIGIgfCAwO1xuICAgICAgICBkICs9IChiIF4gKGEgfCB+YykpICsga1sxMV0gLSAxMTIwMjEwMzc5IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgfCAwO1xuICAgICAgICBjICs9IChhIF4gKGQgfCB+YikpICsga1syXSArIDcxODc4NzI1OSB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTUgfCBjID4+PiAxNykgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoZCBeIChjIHwgfmEpKSArIGtbOV0gLSAzNDM0ODU1NTEgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIxIHwgYiA+Pj4gMTEpICsgYyB8IDA7XG5cbiAgICAgICAgeFswXSA9IGEgKyB4WzBdIHwgMDtcbiAgICAgICAgeFsxXSA9IGIgKyB4WzFdIHwgMDtcbiAgICAgICAgeFsyXSA9IGMgKyB4WzJdIHwgMDtcbiAgICAgICAgeFszXSA9IGQgKyB4WzNdIHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZDVibGsocykge1xuICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLFxuICAgICAgICAgICAgaTsgLyogQW5keSBLaW5nIHNhaWQgZG8gaXQgdGhpcyB3YXkuICovXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIG1kNWJsa3NbaSA+PiAyXSA9IHMuY2hhckNvZGVBdChpKSArIChzLmNoYXJDb2RlQXQoaSArIDEpIDw8IDgpICsgKHMuY2hhckNvZGVBdChpICsgMikgPDwgMTYpICsgKHMuY2hhckNvZGVBdChpICsgMykgPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDVibGtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1kNWJsa19hcnJheShhKSB7XG4gICAgICAgIHZhciBtZDVibGtzID0gW10sXG4gICAgICAgICAgICBpOyAvKiBBbmR5IEtpbmcgc2FpZCBkbyBpdCB0aGlzIHdheS4gKi9cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkgKz0gNCkge1xuICAgICAgICAgICAgbWQ1Ymxrc1tpID4+IDJdID0gYVtpXSArIChhW2kgKyAxXSA8PCA4KSArIChhW2kgKyAyXSA8PCAxNikgKyAoYVtpICsgM10gPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDVibGtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1kNTEocykge1xuICAgICAgICB2YXIgbiA9IHMubGVuZ3RoLFxuICAgICAgICAgICAgc3RhdGUgPSBbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgLTE3MzI1ODQxOTQsIDI3MTczMzg3OF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgdGFpbCxcbiAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgIGxvLFxuICAgICAgICAgICAgaGk7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbjsgaSArPSA2NCkge1xuICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIG1kNWJsayhzLnN1YnN0cmluZyhpIC0gNjQsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGkgLSA2NCk7XG4gICAgICAgIGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICB0YWlsID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRhaWxbaSA+PiAyXSB8PSBzLmNoYXJDb2RlQXQoaSkgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbFtpID4+IDJdIHw9IDB4ODAgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIGlmIChpID4gNTUpIHtcbiAgICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdGFpbFtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZXdhcmUgdGhhdCB0aGUgZmluYWwgbGVuZ3RoIG1pZ2h0IG5vdCBmaXQgaW4gMzIgYml0cyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICB0bXAgPSBuICogODtcbiAgICAgICAgdG1wID0gdG1wLnRvU3RyaW5nKDE2KS5tYXRjaCgvKC4qPykoLnswLDh9KSQvKTtcbiAgICAgICAgbG8gPSBwYXJzZUludCh0bXBbMl0sIDE2KTtcbiAgICAgICAgaGkgPSBwYXJzZUludCh0bXBbMV0sIDE2KSB8fCAwO1xuXG4gICAgICAgIHRhaWxbMTRdID0gbG87XG4gICAgICAgIHRhaWxbMTVdID0gaGk7XG5cbiAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWQ1MV9hcnJheShhKSB7XG4gICAgICAgIHZhciBuID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBzdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgbG8sXG4gICAgICAgICAgICBoaTtcblxuICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBuOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgbWQ1YmxrX2FycmF5KGEuc3ViYXJyYXkoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IHN1cmUgaWYgaXQgaXMgYSBidWcsIGhvd2V2ZXIgSUUxMCB3aWxsIGFsd2F5cyBwcm9kdWNlIGEgc3ViIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgcGFyZW50IGFycmF5IGlmIHRoZSBzdWIgYXJyYXkgc3BlY2lmaWVkIHN0YXJ0c1xuICAgICAgICAvLyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgcGFyZW50IGFycmF5IC0gd2VpcmQuXG4gICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzcxNDUyL3R5cGVkLWFycmF5LXN1YmFycmF5LWlzc3VlXG4gICAgICAgIGEgPSAoaSAtIDY0KSA8IG4gPyBhLnN1YmFycmF5KGkgLSA2NCkgOiBuZXcgVWludDhBcnJheSgwKTtcblxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYVtpXSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWxbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICBpZiAoaSA+IDU1KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRhaWxbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmV3YXJlIHRoYXQgdGhlIGZpbmFsIGxlbmd0aCBtaWdodCBub3QgZml0IGluIDMyIGJpdHMgc28gd2UgdGFrZSBjYXJlIG9mIHRoYXRcbiAgICAgICAgdG1wID0gbiAqIDg7XG4gICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgIGxvID0gcGFyc2VJbnQodG1wWzJdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQodG1wWzFdLCAxNikgfHwgMDtcblxuICAgICAgICB0YWlsWzE0XSA9IGxvO1xuICAgICAgICB0YWlsWzE1XSA9IGhpO1xuXG4gICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmhleChuKSB7XG4gICAgICAgIHZhciBzID0gJycsXG4gICAgICAgICAgICBqO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XG4gICAgICAgICAgICBzICs9IGhleF9jaHJbKG4gPj4gKGogKiA4ICsgNCkpICYgMHgwRl0gKyBoZXhfY2hyWyhuID4+IChqICogOCkpICYgMHgwRl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGV4KHgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB4W2ldID0gcmhleCh4W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvLyBJbiBzb21lIGNhc2VzIHRoZSBmYXN0IGFkZDMyIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkLi5cbiAgICBpZiAoaGV4KG1kNTEoJ2hlbGxvJykpICE9PSAnNWQ0MTQwMmFiYzRiMmE3NmI5NzE5ZDkxMTAxN2M1OTInKSB7XG4gICAgICAgIGFkZDMyID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRiksXG4gICAgICAgICAgICAgICAgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICAgICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEFycmF5QnVmZmVyIHNsaWNlIHBvbHlmaWxsLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHRhdWJlcnQvbm9kZS1hcnJheWJ1ZmZlci1zbGljZVxuICAgICAqL1xuXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIUFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xhbXAodmFsLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAodmFsIHwgMCkgfHwgMDtcblxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWwgKyBsZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2YWwsIGxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gY2xhbXAoZnJvbSwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBudW0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gY2xhbXAodG8sIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJlZ2luID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnVtID0gZW5kIC0gYmVnaW47XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3IEFycmF5QnVmZmVyKG51bSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLCBiZWdpbiwgbnVtKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXJzLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdG9VdGY4KHN0cikge1xuICAgICAgICBpZiAoL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRmOFN0cjJBcnJheUJ1ZmZlcihzdHIsIHJldHVyblVJbnQ4QXJyYXkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKSxcbiAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiksXG4gICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5VSW50OEFycmF5ID8gYXJyIDogYnVmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheUJ1ZmZlcjJVdGY4U3RyKGJ1ZmYpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoYnVmZikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKGZpcnN0LCBzZWNvbmQsIHJldHVyblVJbnQ4QXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGZpcnN0LmJ5dGVMZW5ndGggKyBzZWNvbmQuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmVzdWx0LnNldChuZXcgVWludDhBcnJheShmaXJzdCkpO1xuICAgICAgICByZXN1bHQuc2V0KG5ldyBVaW50OEFycmF5KHNlY29uZCksIGZpcnN0LmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5VSW50OEFycmF5ID8gcmVzdWx0IDogcmVzdWx0LmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoZXhUb0JpbmFyeVN0cmluZyhoZXgpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gW10sXG4gICAgICAgICAgICBsZW5ndGggPSBoZXgubGVuZ3RoLFxuICAgICAgICAgICAgeDtcblxuICAgICAgICBmb3IgKHggPSAwOyB4IDwgbGVuZ3RoIC0gMTsgeCArPSAyKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoeCwgMiksIDE2KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFNwYXJrTUQ1IE9PUCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGNsYXNzIHRvIHBlcmZvcm0gYW4gaW5jcmVtZW50YWwgbWQ1LCBvdGhlcndpc2UgdXNlIHRoZVxuICAgICAqIHN0YXRpYyBtZXRob2RzIGluc3RlYWQuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcGFya01ENSgpIHtcbiAgICAgICAgLy8gY2FsbCByZXNldCB0byBpbml0IHRoZSBpbnN0YW5jZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIHN0cmluZy5cbiAgICAgKiBBIGNvbnZlcnNpb24gd2lsbCBiZSBhcHBsaWVkIGlmIGFuIHV0Zjggc3RyaW5nIGlzIGRldGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGJlIGFwcGVuZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFya01ENX0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIENvbnZlcnRzIHRoZSBzdHJpbmcgdG8gdXRmOCBieXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgLy8gVGhlbiBhcHBlbmQgYXMgYmluYXJ5XG4gICAgICAgIHRoaXMuYXBwZW5kQmluYXJ5KHRvVXRmOChzdHIpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIGJpbmFyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudHMgVGhlIGJpbmFyeSBzdHJpbmcgdG8gYmUgYXBwZW5kZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1fSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUucHJvdG90eXBlLmFwcGVuZEJpbmFyeSA9IGZ1bmN0aW9uIChjb250ZW50cykge1xuICAgICAgICB0aGlzLl9idWZmICs9IGNvbnRlbnRzO1xuICAgICAgICB0aGlzLl9sZW5ndGggKz0gY29udGVudHMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9idWZmLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbGVuZ3RoOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9oYXNoLCBtZDVibGsodGhpcy5fYnVmZi5zdWJzdHJpbmcoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYnVmZiA9IHRoaXMuX2J1ZmYuc3Vic3RyaW5nKGkgLSA2NCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIHRoZSBpbmNyZW1lbnRhbCBjb21wdXRhdGlvbiwgcmVzZXRpbmcgdGhlIGludGVybmFsIHN0YXRlIGFuZFxuICAgICAqIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByYXcgVHJ1ZSB0byBnZXQgdGhlIHJhdyBzdHJpbmcsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSB0aGlzLl9idWZmLFxuICAgICAgICAgICAgbGVuZ3RoID0gYnVmZi5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIHJldDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRhaWxbaSA+PiAyXSB8PSBidWZmLmNoYXJDb2RlQXQoaSkgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maW5pc2godGFpbCwgbGVuZ3RoKTtcbiAgICAgICAgcmV0ID0gaGV4KHRoaXMuX2hhc2gpO1xuXG4gICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgIHJldCA9IGhleFRvQmluYXJ5U3RyaW5nKHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFya01ENX0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVmZiA9ICcnO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9oYXNoID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBzdGF0ZVxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1ZmY6IHRoaXMuX2J1ZmYsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2xlbmd0aCxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX2hhc2hcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fYnVmZiA9IHN0YXRlLmJ1ZmY7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faGFzaCA9IHN0YXRlLmhhc2g7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIG1lbW9yeSB1c2VkIGJ5IHRoZSBpbmNyZW1lbnRhbCBidWZmZXIgYW5kIG90aGVyIGFkZGl0aW9uYWxcbiAgICAgKiByZXNvdXJjZXMuIElmIHlvdSBwbGFuIHRvIHVzZSB0aGUgaW5zdGFuY2UgYWdhaW4sIHVzZSByZXNldCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5faGFzaDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J1ZmY7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYmFzZWQgb24gdGhlIHRhaWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgdGFpbCAgIFRoZSB0YWlsICh3aWxsIGJlIG1vZGlmaWVkKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmVtYWluaW5nIGJ1ZmZlclxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKHRhaWwsIGxlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IGxlbmd0aCxcbiAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgIGxvLFxuICAgICAgICAgICAgaGk7XG5cbiAgICAgICAgdGFpbFtpID4+IDJdIHw9IDB4ODAgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIGlmIChpID4gNTUpIHtcbiAgICAgICAgICAgIG1kNWN5Y2xlKHRoaXMuX2hhc2gsIHRhaWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIHRoZSBmaW5hbCBjb21wdXRhdGlvbiBiYXNlZCBvbiB0aGUgdGFpbCBhbmQgbGVuZ3RoXG4gICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWF5IG5vdCBmaXQgaW4gMzIgYml0cyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICB0bXAgPSB0aGlzLl9sZW5ndGggKiA4O1xuICAgICAgICB0bXAgPSB0bXAudG9TdHJpbmcoMTYpLm1hdGNoKC8oLio/KSguezAsOH0pJC8pO1xuICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KHRtcFsxXSwgMTYpIHx8IDA7XG5cbiAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgdGFpbFsxNV0gPSBoaTtcbiAgICAgICAgbWQ1Y3ljbGUodGhpcy5faGFzaCwgdGFpbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBtZDUgaGFzaCBvbiBhIHN0cmluZy5cbiAgICAgKiBBIGNvbnZlcnNpb24gd2lsbCBiZSBhcHBsaWVkIGlmIHV0Zjggc3RyaW5nIGlzIGRldGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBzdHIgVGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhd10gVHJ1ZSB0byBnZXQgdGhlIHJhdyBzdHJpbmcsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUuaGFzaCA9IGZ1bmN0aW9uIChzdHIsIHJhdykge1xuICAgICAgICAvLyBDb252ZXJ0cyB0aGUgc3RyaW5nIHRvIHV0ZjggYnl0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIFRoZW4gY29tcHV0ZSBpdCB1c2luZyB0aGUgYmluYXJ5IGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBTcGFya01ENS5oYXNoQmluYXJ5KHRvVXRmOChzdHIpLCByYXcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb250ZW50IFRoZSBiaW5hcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmF3XSAgICAgVHJ1ZSB0byBnZXQgdGhlIHJhdyBzdHJpbmcsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUuaGFzaEJpbmFyeSA9IGZ1bmN0aW9uIChjb250ZW50LCByYXcpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBtZDUxKGNvbnRlbnQpLFxuICAgICAgICAgICAgcmV0ID0gaGV4KGhhc2gpO1xuXG4gICAgICAgIHJldHVybiByYXcgPyBoZXhUb0JpbmFyeVN0cmluZyhyZXQpIDogcmV0O1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFNwYXJrTUQ1IE9PUCBpbXBsZW1lbnRhdGlvbiBmb3IgYXJyYXkgYnVmZmVycy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGNsYXNzIHRvIHBlcmZvcm0gYW4gaW5jcmVtZW50YWwgbWQ1IE9OTFkgZm9yIGFycmF5IGJ1ZmZlcnMuXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNhbGwgcmVzZXQgdG8gaW5pdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFyciBUaGUgYXJyYXkgdG8gYmUgYXBwZW5kZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyh0aGlzLl9idWZmLmJ1ZmZlciwgYXJyLCB0cnVlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB0aGlzLl9sZW5ndGggKz0gYXJyLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbGVuZ3RoOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9oYXNoLCBtZDVibGtfYXJyYXkoYnVmZi5zdWJhcnJheShpIC0gNjQsIGkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmID0gKGkgLSA2NCkgPCBsZW5ndGggPyBuZXcgVWludDhBcnJheShidWZmLmJ1ZmZlci5zbGljZShpIC0gNjQpKSA6IG5ldyBVaW50OEFycmF5KDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24sIHJlc2V0aW5nIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmRcbiAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgc3RyaW5nLCBmYWxzZSB0byBnZXQgdGhlIGhleCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIHZhciBidWZmID0gdGhpcy5fYnVmZixcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYnVmZltpXSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpbmlzaCh0YWlsLCBsZW5ndGgpO1xuICAgICAgICByZXQgPSBoZXgodGhpcy5faGFzaCk7XG5cbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgcmV0ID0gaGV4VG9CaW5hcnlTdHJpbmcocmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9idWZmID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2hhc2ggPSBbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgLTE3MzI1ODQxOTQsIDI3MTczMzg3OF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHN0YXRlXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBTcGFya01ENS5wcm90b3R5cGUuZ2V0U3RhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBhIHN0cmluZ1xuICAgICAgICBzdGF0ZS5idWZmID0gYXJyYXlCdWZmZXIyVXRmOFN0cihzdGF0ZS5idWZmKTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlclxuICAgICAgICBzdGF0ZS5idWZmID0gdXRmOFN0cjJBcnJheUJ1ZmZlcihzdGF0ZS5idWZmLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gU3BhcmtNRDUucHJvdG90eXBlLnNldFN0YXRlLmNhbGwodGhpcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBTcGFya01ENS5BcnJheUJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95O1xuXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLl9maW5pc2ggPSBTcGFya01ENS5wcm90b3R5cGUuX2ZpbmlzaDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBtZDUgaGFzaCBvbiBhbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnIgVGhlIGFycmF5IGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIFtyYXddIFRydWUgdG8gZ2V0IHRoZSByYXcgc3RyaW5nLCBmYWxzZSB0byBnZXQgdGhlIGhleCBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLmhhc2ggPSBmdW5jdGlvbiAoYXJyLCByYXcpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBtZDUxX2FycmF5KG5ldyBVaW50OEFycmF5KGFycikpLFxuICAgICAgICAgICAgcmV0ID0gaGV4KGhhc2gpO1xuXG4gICAgICAgIHJldHVybiByYXcgPyBoZXhUb0JpbmFyeVN0cmluZyhyZXQpIDogcmV0O1xuICAgIH07XG5cbiAgICByZXR1cm4gU3BhcmtNRDU7XG59KSk7XG4iLCIvKlxuICogVGhpcyBzY3JpcHQgYWRkcyBjcm9zcy1kb2N1bWVudCBtZXNzYWdpbmcgKHBvc3RNZXNzYWdlKSBzdXBwb3J0IFsxLDJdLCB0byBhbGxvd1xuICogZW1iZWRkaW5nIG9uZSBvciBtYW55IGluc3RhbmNlcyBvZiB0aGUgVHJlZSBJbGx1c3RyYXRvciBVSSBpbiBhblxuICogSVB5dGhvbiBub3RlYm9vay4gVGhpcyBsZXRzIHVzIHByb3ZpZGUgdHJlZSBkYXRhIGZyb20gdGhlIHN1cnJvdW5kaW5nXG4gKiBJUHl0aG9uIHNlc3Npb24sIGFuZCBzYXZlIFNWRyBvdXRwdXQgb3IgY29tcGxldGUgaWxsdXN0cmF0aW9uIEpTT04gZnJvbSBlYWNoXG4gKiBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VmdWwgaW4gcHJlLXB1YmxpY2F0aW9uIGFuZCBleHBsb3JhdG9yeSBzY2VuYXJpb3MgZm9yIGFcbiAqIHNpbmdsZSB1c2VyLCBvciBmYWlybHkgZWFzeSBjb2xsYWJvcmF0aW9uLCB1c2luZyBXYWthcmkgb3IgYW5vdGhlciBub3RlYm9va1xuICogc2VydmVyLlxuICpcbiAqIFsxXSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Bvc3RNZXNzYWdlXG4gKiBbMl0gaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9zdE1lc3NhZ2VcbiAqL1xuXG4vLyBub3RlYm9vayB3aW5kb3cgaXMgb3BlbmVyIChmb3Igc2VwYXJhdGUgdGFiL3dpbmRvdykgb3IgcGFyZW50IChmb3IgSUZSQU1FKVxudmFyIG5vdGVib29rV2luZG93ID0gd2luZG93Lm9wZW5lciB8fCB3aW5kb3cucGFyZW50O1xuXG4vLyBUT0RPOiBzZXQgZXhwZWN0ZWQgY2FsbGluZyBkb21haW4gd2hlbiBpbnN0YW5jZSBpcyBjcmVhdGVkP1xuXG5mdW5jdGlvbiByZWNlaXZlTWVzc2FnZShlKSB7XG4gICAgdmFyIG1zZyA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAvKiBSRU1JTkRFUjogQSBtZXNzYWdlIGhhcyB0aHJlZSBwcm9wZXJ0aWVzIG9mIGludGVyZXN0OlxuICAgICAqICAgbXNnLm9yaWdpbiBpcyB0aGUgZG9tYWluIHRoYXQgaG9sZHMgdGhlIHN1cnJvdW5kaW5nIElQeXRob24gbm90ZWJvb2tcbiAgICAgKiAgIG1zZy5kYXRhIGlzIGl0cyBwYXlsb2FkXG4gICAgICogICBtc2cuc291cmNlIGlzIHRoZSB3aW5kb3cgdGhhdCBzZW50IHRoZSBtZXNzYWdlICh0aGUgbm90ZWJvb2sgdmlld2VyKVxuICAgICAqL1xuICAgIGlmIChtc2cuc291cmNlICE9PSBub3RlYm9va1dpbmRvdykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFeHBlY3RlZCB0aGlzIG1lc3NhZ2UgZnJvbSBteSBub3RlYm9va1dpbmRvdyAob3BlbmVyIG9yIHBhcmVudCkhXFxuXCJcbiAgICAgICAgICAgICAgICAgICAgK1wiICBtc2cuc291cmNlPVwiKyBtc2cuc291cmNlICtcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICtcIiAgbm90ZWJvb2tXaW5kb3c9XCIrIG5vdGVib29rV2luZG93XG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAvL3JldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1zZy5kYXRhWydtZXRob2QnXSkge1xuICAgICAgICBhbGVydChcIkV4cGVjdGVkIGEgbmFtZWQgbWV0aG9kIGluIG1zZy5kYXRhLm1ldGhvZCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1zZy5kYXRhWydyZXNwb25zZSddKSB7XG4gICAgICAgIGFsZXJ0KFwiRXhwZWN0ZWQgYW4gb2JqZWN0IGluIG1zZy5kYXRhLnJlc3BvbnNlIVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChtc2cuZGF0YVsnbWV0aG9kJ10pIHtcbiAgICAgICAgY2FzZSAnYWRkVHJlZSc6XG4gICAgICAgICAgICB2YXIgdHJlZURhdGEgPSBtc2cuZGF0YVsndHJlZURhdGEnXTtcbiAgICAgICAgICAgIGlmICghdHJlZURhdGEpIHtcbiAgICAgICAgICAgICAgICBhbGVydChcIk5vIHRyZWUgZGF0YSBwcm92aWRlZCFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZHVtcEN1cnJlbnRJbGx1c3RyYXRpb24nOlxuICAgICAgICAgICAgdmFyIHRhcmdldENlbGwgPSBnZXRUYXJnZXRDZWxsKG1zZyk7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkdW1wQ3VycmVudElsbHVzdHJhdGlvblNWRyc6XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q2VsbCA9IGdldFRhcmdldENlbGwobXNnKTtcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIEhhbmRsZSBjYWxsYmFja3MgZm9yIG1lc3NhZ2VzIEZST00gdGhpcyB3aW5kb3cgKi9cblxuICAgICAgICBjYXNlICdnZXRJbGx1c3RyYXRpb25MaXN0X3Jlc3BvbnNlJzpcbiAgICAgICAgICAgIGdldElsbHVzdHJhdGlvbkxpc3RfY2FsbGJhY2sobXNnLmRhdGEucmVzcG9uc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xvYWRJbGx1c3RyYXRpb25fcmVzcG9uc2UnOlxuICAgICAgICAgICAgbG9hZElsbHVzdHJhdGlvbl9jYWxsYmFjayhtc2cuZGF0YS5yZXNwb25zZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2F2ZUlsbHVzdHJhdGlvbl9yZXNwb25zZSc6XG4gICAgICAgICAgICBzYXZlSWxsdXN0cmF0aW9uX2NhbGxiYWNrKG1zZy5kYXRhLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWxldGVJbGx1c3RyYXRpb25fcmVzcG9uc2UnOlxuICAgICAgICAgICAgZGVsZXRlSWxsdXN0cmF0aW9uX2NhbGxiYWNrKG1zZy5kYXRhLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xpc3RBbGxOb3RlYm9va1ZhcnNfcmVzcG9uc2UnOlxuICAgICAgICAgICAgLy8gTi5CLiB0aGUgZXhwZWN0ZWQgY2FsbGJhY2sgaXMgbmFtZWQgZm9yIGEgZ2VuZXJhbCBBUEksIG5vdCB0aGVcbiAgICAgICAgICAgIC8vIGRldGFpbHMgb2YgSnVweXRlciBub3RlYm9vay5cbiAgICAgICAgICAgIGdldFRyZWVTb3VyY2VMaXN0X2NhbGxiYWNrKG1zZy5kYXRhLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnZXRUcmVlU291cmNlRGF0YV9yZXNwb25zZSc6XG4gICAgICAgICAgICBnZXRUcmVlU291cmNlRGF0YV9jYWxsYmFjayhtc2cuZGF0YS5yZXNwb25zZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYWxlcnQoXCJVbmV4cGVjdGVkIG1ldGhvZCBbXCIrIG1zZy5kYXRhLm1ldGhvZCArXCJdIGluIHRoaXMgbWVzc2FnZSFcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRDZWxsKG1zZykge1xuICAgIC8vIFJldHVybiB0aGUgc3BlY2lmaWVkIGNlbGwsIG9yIHRoZSBuZXh0IGF2YWlsYWJsZVxuICAgIC8vIFRPRE86IHdoYXQga2luZCBvZiBjZWxsIHJlZmVyZW5jZSB3b3JrcyBmb3Igbm90ZWJvb2sgSlM/XG4gICAgLy8gIC0gbnRoIGNlbGw/XG4gICAgLy8gIC0gYnkgbmFtZSBvciBlbGVtZW50IElEP1xuICAgIC8vICB2IGEgZGlyZWN0IHJlZmVyZW5jZT8gTk8sIHRoZXNlIGFyZSBub3Qgc2hhcmVkIGFjcm9zcyB3aW5kb3dzXG59XG5cbmNvbnNvbGUud2FybihcIkFERElORyBldmVudCBsaXN0ZW5lciAoYnJpZGdlIEpTKSB0byB0aGlzIHdpbmRvdzogXCIrIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbi8vd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlY2VpdmVNZXNzYWdlLCBmYWxzZSk7XG4kKHdpbmRvdykub2ZmKCdtZXNzYWdlLlRyZWVJbGx1c3RyYXRvcicpXG4gICAgICAgICAub24oJ21lc3NhZ2UuVHJlZUlsbHVzdHJhdG9yJywgcmVjZWl2ZU1lc3NhZ2UpO1xuXG4vKiBUaGUgbWV0aG9kcyBiZWxvdyBjb25zdGl0dXRlIGEgZ2VuZXJhbCBBUEkgZm9yIHRoZSBUcmVlIElsbHVzdHJhdG9yLiBcbiAqIFRoZXNlIHNob3VsZCBzdXBwb3J0IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIHZpYSBjYWxsYmFja3MuIFdoZW4gZGVmaW5pbmdcbiAqIGZ1bmN0aW9uIG5hbWVzIGFuZCBhcmd1bWVudHMsIGtlZXAgaW4gbWluZCB0aGF0IHdlIGV4cGVjdCB0byBidWlsZCBwYXJhbGxlbFxuICogaW1wbGVtZW50YXRpb25zIGluIG90aGVyIGNvbnRleHRzIChlLmcuLCB3aXRoaW4gYSBkZWRpY2F0ZWQgd2Vic2l0ZSBvciB0aGVcbiAqIFRvb2xzIHRhYiBvZiB0aGUgT3BlblRyZWUgY3VyYXRpb24gYXBwKS5cbiAqL1xuXG4vLyBNYW5hZ2UgaWxsdXN0cmF0aW9ucyBmcm9tIHRoZSBjdXJyZW50IGRvY3N0b3JlIChpbiB0aGlzIGNhc2UsIHRoZSBub3RlYm9vayBtZXRhZGF0YSlcblxuZnVuY3Rpb24gdXNlckhhc1N0b3JhZ2VBY2Nlc3MoKSB7XG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgcnVubmluZywgZWRpdGFibGUgbm90ZWJvb2ssIGFueW9uZSBjYW4gc2F2ZSBkYXRhLlxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gc3Rhc2ggY2FsbGJhY2tzIGZvciB1c2UgYnkgY3Jvc3Mtd2luZG93IHJlc3BvbnNlc1xudmFyIGdldElsbHVzdHJhdGlvbkxpc3RfY2FsbGJhY2sgPSBudWxsLFxuICAgIGxvYWRJbGx1c3RyYXRpb25fY2FsbGJhY2sgPSBudWxsLFxuICAgIHNhdmVJbGx1c3RyYXRpb25fY2FsbGJhY2sgPSBudWxsLFxuICAgIGRlbGV0ZUlsbHVzdHJhdGlvbl9jYWxsYmFjayA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldElsbHVzdHJhdGlvbkxpc3QoY2FsbGJhY2spIHtcbiAgICBnZXRJbGx1c3RyYXRpb25MaXN0X2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBub3RlYm9va1dpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIG1ldGhvZDogJ2dldElsbHVzdHJhdGlvbkxpc3QnXG4gICAgfSwgXG4gICAgJyonKTsgIC8vIFRPRE86IHJlc3RyaWN0IHRvIHRoaXMgcGFydGljdWxhciBub3RlYm9vaydzIGRvbWFpbj9cbn1cblxuZnVuY3Rpb24gbG9hZElsbHVzdHJhdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgICBsb2FkSWxsdXN0cmF0aW9uX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBub3RlYm9va1dpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIG1ldGhvZDogJ2xvYWRJbGx1c3RyYXRpb24nLFxuICAgICAgICB1bmlxdWVJRDogaWRcbiAgICB9LCBcbiAgICAnKicpOyAgLy8gVE9ETzogcmVzdHJpY3QgdG8gdGhpcyBwYXJ0aWN1bGFyIG5vdGVib29rJ3MgZG9tYWluP1xufVxuXG5mdW5jdGlvbiBzYXZlSWxsdXN0cmF0aW9uKGZvcmNlUG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBzYXZlLCBzYXZlLWFzLCBjb3B5P1xuICAgIHNhdmVJbGx1c3RyYXRpb25fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGN1cnJlbnQgaWxsdXN0cmF0aW9uIHRvIHNpbXBsZSBKUyB1c2luZyBvdXIgXG4gICAgLy8gS25vY2tvdXQgbWFwcGluZyBvcHRpb25zXG4gICAgdmFyIGNsb25hYmxlSWxsdXN0cmF0aW9uID0ga28ubWFwcGluZy50b0pTKHN0eWxpc3QuaWxsKTtcblxuICAgIHZhciBtc2dJbmZvID0ge1xuICAgICAgICBtZXRob2Q6ICdzYXZlSWxsdXN0cmF0aW9uJyxcbiAgICAgICAgaWxsdXN0cmF0aW9uOiBjbG9uYWJsZUlsbHVzdHJhdGlvblxuICAgIH07XG4gICAgLy8gVG8gcmUtc2F2ZSBpbiB0aGUgc2FtZSBzbG90LCBvbWl0IHRoZSB1bmlxdWVJRFxuICAgIGlmICh0eXBlb2YoZm9yY2VQb3NpdGlvbikgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1zZ0luZm8udW5pcXVlSUQgPSBmb3JjZVBvc2l0aW9uO1xuICAgIH1cbiAgICBcbiAgICBub3RlYm9va1dpbmRvdy5wb3N0TWVzc2FnZShtc2dJbmZvLCAnKicpOyAgXG4gICAgLy8gVE9ETzogcmVzdHJpY3QgdG8gdGhpcyBwYXJ0aWN1bGFyIG5vdGVib29rJ3MgZG9tYWluP1xufVxuXG5mdW5jdGlvbiBkZWxldGVJbGx1c3RyYXRpb24oc2xvdFBvc2l0aW9uLCBjYWxsYmFjaykge1xuICAgIGRlbGV0ZUlsbHVzdHJhdGlvbl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZihzbG90UG9zaXRpb24pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZGVsZXRlSWxsdXN0cmF0aW9uKCkgUkVRVUlSRVMgYSB2YWxpZCBzbG90IHBvc2l0aW9uLCBub3QgXCIrIHNsb3RQb3NpdGlvbiArXCIgPFwiKyB0eXBlb2Yoc2xvdFBvc2l0aW9uKSArXCI+XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1zZ0luZm8gPSB7XG4gICAgICAgIG1ldGhvZDogJ2RlbGV0ZUlsbHVzdHJhdGlvbicsXG4gICAgICAgIGlsbHVzdHJhdGlvbjogY2xvbmFibGVJbGx1c3RyYXRpb24sXG4gICAgICAgIHVuaXF1ZUlEOiBzbG90UG9zaXRpb25cbiAgICB9O1xuXG4gICAgbm90ZWJvb2tXaW5kb3cucG9zdE1lc3NhZ2UobXNnSW5mbywgJyonKTtcbiAgICAvLyBUT0RPOiByZXN0cmljdCB0byB0aGlzIHBhcnRpY3VsYXIgbm90ZWJvb2sncyBkb21haW4/XG59XG5cbi8vIEdldCB1c2VyLWZyaWVuZGx5IGxpc3Qgb2YgYXZhaWxhYmxlIHNvdXJjZSBkYXRhIGZvciB0cmVlcywgZXRjLlxuLy8gVE9ETzogSW5jbHVkZSBKUyB2YXJpYWJsZXMsIGZyb20gd2luZG93IHNjb3BlIChvciBzY29wZSBwcm92aWRlZCk/XG4vLyBUT0RPOiBTdXBwb3J0IG11bHRpcGxlIGtlcm5lbHMgKFB5dGhvbiwgSnVsaWEsIGV0YykgaWYgYXZhaWxhYmxlP1xuLy8gVE9ETzogRmlsdGVyIGtlcm5lbCB2YXJzICh1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zPykgdG8gc2hvdyBvbmx5IHN1aXRhYmxlIHZhcmlhYmxlcyBmb3IgZWFjaCBxdWVyeT9cblxuLy8gc3Rhc2ggY2FsbGJhY2tzIGZvciB1c2UgYnkgY3Jvc3Mtd2luZG93IHJlc3BvbnNlc1xudmFyIGdldFRyZWVTb3VyY2VMaXN0X2NhbGxiYWNrID0gbnVsbCxcbiAgICBnZXRUcmVlU291cmNlRGF0YV9jYWxsYmFjayA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFRyZWVTb3VyY2VMaXN0KGNhbGxiYWNrKSB7XG4gICAgZ2V0VHJlZVNvdXJjZUxpc3RfY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIG5vdGVib29rV2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWV0aG9kOiAnbGlzdEFsbE5vdGVib29rVmFycydcbiAgICB9LCBcbiAgICAnKicpOyAgLy8gVE9ETzogcmVzdHJpY3QgdG8gdGhpcyBwYXJ0aWN1bGFyIG5vdGVib29rJ3MgZG9tYWluP1xufVxuXG5mdW5jdGlvbiBnZXRUcmVlU291cmNlRGF0YShpZCwgY2FsbGJhY2spIHtcbiAgICAvLyAnY2FsbGJhY2snIHNob3VsZCBleHBlY3QgYSBzaW5nbGUgb2JqIHdpdGggJ2RhdGEnIG9yICdlcnJvcicgcHJvcGVydGllcylcbiAgICBnZXRUcmVlU291cmNlRGF0YV9jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgbm90ZWJvb2tXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBtZXRob2Q6ICdnZXROb3RlYm9va1ZhcicsXG4gICAgICAgIHZhck5hbWU6IGlkXG4gICAgfSwgXG4gICAgJyonKTsgIC8vIFRPRE86IHJlc3RyaWN0IHRvIHRoaXMgcGFydGljdWxhciBub3RlYm9vaydzIGRvbWFpbj9cbn1cblxuZnVuY3Rpb24gZ2V0U3VwcGxlbWVudGFsRGF0YVNvdXJjZUxpc3QoaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xufVxuXG5mdW5jdGlvbiBnZXRPcm5hbWVudFNvdXJjZUxpc3QoaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xufVxuXG4vLyBFeHBvc2Ugc29tZSBtZW1iZXJzIHRvIG91dHNpZGUgY29kZSAoZWcsIEtub2Nrb3V0IGJpbmRpbmdzLCBvbkNsaWNrXG4vLyBhdHRyaWJ1dGVzLi4uKVxudmFyIGFwaSA9IFtcbiAgICAvLyBleHBlY3RlZCBBUEkgZm9yIHN0b3JhZ2UgYmFja2VuZFxuICAgICdnZXRJbGx1c3RyYXRpb25MaXN0JyxcbiAgICAnbG9hZElsbHVzdHJhdGlvbicsXG4gICAgJ3NhdmVJbGx1c3RyYXRpb24nLFxuICAgICdkZWxldGVJbGx1c3RyYXRpb24nLFxuICAgICd1c2VySGFzU3RvcmFnZUFjY2VzcycsXG4gICAgLy8gZnVuY3Rpb25zIHVuaXF1ZSB0byBhbiBJUHl0aG9uIG5vdGVib29rXG4gICAgJ2dldFRyZWVTb3VyY2VMaXN0JyxcbiAgICAnZ2V0VHJlZVNvdXJjZURhdGEnXG5dO1xuJC5lYWNoKGFwaSwgZnVuY3Rpb24oaSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIHBvcHVsYXRlIHRoZSBkZWZhdWx0ICdtb2R1bGUuZXhwb3J0cycgb2JqZWN0XG4gICAgZXhwb3J0c1sgbWV0aG9kTmFtZSBdID0gZXZhbCggbWV0aG9kTmFtZSApO1xufSk7XG4iLCIvKlxuICogVGhpcyBzY3JpcHQgYWRkcyBzdG9yYWdlIG9uIHRoZSBsb2NhbCBmaWxlc3lzdGVtIGZvciBtb2Rlcm4gYnJvd3NlcnMuXG4gKiBJbGx1c3RyYXRpb25zIGFyZSBzYXZlZCBhcyBaSVAgYXJjaGl2ZXMsIHR5cGljYWxseSB3aXRoIGludGVybmFsIGNvcGllcyBvZlxuICogaW5wdXQgZGF0YSwgdHJhbnNmb3JtYXRpb24gcmVzdWx0cywgYW5kIG91dHB1dCBmaWxlcy5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VmdWwgaW4gcHJlLXB1YmxpY2F0aW9uLCBleHBsb3JhdG9yeSBzY2VuYXJpb3MsIGFuZCBwcml2YXRlXG4gKiBjb2xsYWJvcmF0aW9uIHZpYSBlbWFpbC4gXG4gKi9cblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3RpLXV0aWxzJyksXG4gICAgSlNaaXAgPSByZXF1aXJlKCdqc3ppcCcpLFxuICAgIG1kNSA9IHJlcXVpcmUoJ3NwYXJrLW1kNScpLFxuICAgIEZpbGVTYXZlciA9IHJlcXVpcmUoJ2ZpbGUtc2F2ZXInKSwgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0ZpbGVTYXZlci5qc1xuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vLyBUT0RPOiBleHBvc2UgSlNaaXAgdG8gSlMgaW4gdGhlIG1haW4gVUk/XG4vLyBnbG9iYWwuSlNaaXAgPSBKU1ppcDtcblxuLy8gTi5CLiBTb21lIGdsb2JhbHMgYXJlIGFscmVhZHkgdmlzaWJsZSBmcm9tIGhlcmVcbi8vL3ZhciBzdHlsaXN0O1xuXG5mdW5jdGlvbiB1c2VySGFzU3RvcmFnZUFjY2VzcygpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBydW5uaW5nLCBlZGl0YWJsZSBub3RlYm9vaywgYW55b25lIGNhbiBzYXZlIGRhdGEuXG4gICAgcmV0dXJuIHV0aWxzLmJyb3dzZXJTdXBwb3J0c0ZpbGVBUEkoKTtcbiAgICAvL3JldHVybiBzdHlsaXN0LnV0aWxzLmJyb3dzZXJTdXBwb3J0c0ZpbGVBUEkoKTsgIC8vIGFsc28gd29ya3MhXG59XG5cbmZ1bmN0aW9uIGdldElsbHVzdHJhdGlvbkxpc3QoY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIGlzIG5vdCByZWFsbHkgcG9zc2libGUgaW4gdGhlIGxvY2FsIGZpbGVzeXN0ZW07IHJldHVybiBhbiBlbXB0eSBsaXN0IGZvciBub3cuXG4gICAgdmFyIHJlc3AgPSB7IGRhdGE6IFsgXSB9O1xuICAgIC8vICdjYWxsYmFjaycgZXhwZWN0cyBhIHNpbmdsZSBvYmogd2l0aCAnZGF0YScgb3IgJ2Vycm9yJyBwcm9wZXJ0aWVzXG4gICAgY2FsbGJhY2socmVzcCk7XG59XG5cbmZ1bmN0aW9uIGxvYWRJbGx1c3RyYXRpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gaW4gdGhlIGZpbGVzeXN0ZW0sICdpZCcgaXMgYSBmdWxsIHBhdGg/IG9yIGlnbm9yZSBpdCBoZXJlP1xufVxuXG5mdW5jdGlvbiBzYXZlSWxsdXN0cmF0aW9uKGlkLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8qIEluIHRoZSBmaWxlc3lzdGVtLCAnaWQnIGlzIGp1c3QgYSBzdWdnZXN0ZWQgZmlsZW5hbWUuIFxuICAgICAqIE5PVEUgdGhhdCB3ZSBoYXZlIG5vIGNvbnRyb2wgb3ZlciB3aGVyZSB0aGUgYnJvd3NlciB3aWxsIHNhdmUgYVxuICAgICAqIGRvd25sb2FkZWQgZmlsZSwgYW5kIHdlIGhhdmUgbm8gZGlyZWN0IGtub3dsZWRnZSBvZiB0aGUgZmlsZXN5c3RlbS5cbiAgICAgKiBGdXJ0aGVybW9yZSwgbW9zdCBicm93c2VycyB3b24ndCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgZmlsZSB3aXRoIHRoaXNcbiAgICAgKiBwYXRoK25hbWUsIGFuZCB3aWxsIGluc3RlYWQgaW5jcmVtZW50IHRoZSBuZXcgZmlsZSwgZS5nLlxuICAgICAqICdiZWUtdHJlZXMtY29tcGFyZWQuemlwJyBiZWNvbWVzICd+L0Rvd25sb2Fkcy9iZWUtdHJlZXMtY29tcGFyZWQgKDIpLnppcCcuXG4gICAgICpcbiAgICAgKiBDYW4gd2Ugc3VwcG9ydCB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IgZm9yLi4uID9cbiAgICAgKiAgU2F2ZSAgKG5vdCByZWFsbHksIHNpbmNlIHdlIGNhbid0IG92ZXJ3cml0ZSBhIGZpbGUpXG4gICAgICogIFNhdmUgQXMuLi4gIChieSBkZWZhdWx0LCB3aXRoIGEgcG9zc2libHkgbXVuZ2VkL2luY3JlbWVudGVkIGZpbGVuYW1lKVxuICAgICAqICBDb3B5ICAoc3VyZSwgdGhhdCdzIGVhc3kgaWYgd2UganVzdCBhbGxvdyByZW5hbWluZylcbiAgICAgKi9cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7RlVMTF9BUkNISVZFOiB0cnVlfTtcblxuICAgIC8vIFRPRE86IGFkZCB0aGlzIHVzZXIgdG8gdGhlIGF1dGhvcnMgbGlzdCwgaWYgbm90IGZvdW5kP1xuICAgIC8vIChlbWFpbCBhbmQvb3IgdXNlcmlkLCBzbyB3ZSBjYW4gbGluayB0byBhdXRob3JzKVxuICAgIC8qXG4gICAgdmFyIHVzZXJEaXNwbGF5TmFtZSA9ID8/P1xuICAgIHZhciBsaXN0UG9zID0gJC5pbkFycmF5KCB1c2VyRGlzcGxheU5hbWUsIHN0eWxpc3QuaWxsLm1ldGFkYXRhLmF1dGhvcnMoKSApO1xuICAgIGlmIChsaXN0UG9zID09PSAtMSkge1xuICAgICAgICBzdHlsaXN0LmlsbC5tZXRhZGF0YS5hdXRob3JzLnB1c2goIHVzZXJEaXNwbGF5TmFtZSApO1xuICAgIH1cbiAgICAqL1xuXG4gICAgLy8gVE9ETzogY2xlYXIgYW55IGV4aXN0aW5nIFVSTD8gb3Iga2VlcCBsYXN0LWtub3duIGdvb2Qgb25lP1xuICAgIC8vY2xvbmFibGVJbGx1c3RyYXRpb24ubWV0YWRhdGEudXJsID0gJyc7XG5cbiAgICAvLyBUT0RPOiBhZGQgYSBcInNjcnViYmVyXCIgYXMgd2UgZG8gZm9yIE9wZW5UcmVlIHN0dWRpZXM/IFxuICAgIC8vIHNjcnViSWxsdXN0cmF0aW9uRm9yVHJhbnNwb3J0KHN0eWxpc3QuaWxsKTtcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGN1cnJlbnQgaWxsdXN0cmF0aW9uIHRvIHNpbXBsZSBKUyB1c2luZyBvdXIgXG4gICAgLy8gS25vY2tvdXQgbWFwcGluZyBvcHRpb25zXG4gICAgdmFyIGNsb25hYmxlSWxsdXN0cmF0aW9uID0ga28ubWFwcGluZy50b0pTKHN0eWxpc3QuaWxsKTtcblxuICAgIC8vIGNyZWF0ZSBhIFppcCBhcmNoaXZlLCBhZGQgdGhlIGNvcmUgZG9jdW1lbnRcbiAgICB2YXIgYXJjaGl2ZSA9IG5ldyBKU1ppcCgpO1xuICAgIGFyY2hpdmUuZmlsZShcIm1haW4uanNvblwiLCBKU09OLnN0cmluZ2lmeShjbG9uYWJsZUlsbHVzdHJhdGlvbikpO1xuXG4gICAgLy8gVGVzdCBhbGwgaW5wdXQgZm9yIHJlcGVhdGFibGUgcHJvdmVuYW5jZSBpbmZvOyBpZiBhbnkgYXJlIGxhY2tpbmcgYVxuICAgIC8vIGNsZWFyIHNvdXJjZSwgd2Ugc2hvdWxkIGVtYmVkIHRoZSBzb3VyY2UgZGF0YSBoZXJlLlxuICAgIHZhciBzdGF0aWNJbnB1dHMgPSBUcmVlSWxsdXN0cmF0b3IuZ2F0aGVyU3RhdGljSW5wdXREYXRhKCk7XG4gICAgaWYgKG9wdGlvbnMuRlVMTF9BUkNISVZFIHx8IChzdGF0aWNJbnB1dHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgLy8gYWRkIHNvbWUgb3IgYWxsIGlucHV0IGRhdGEgZm9yIHRoaXMgaWxsdXN0cmF0aW9uXG4gICAgICAgIC8vdmFyIGlucHV0Rm9sZGVyID0gYXJjaGl2ZS5mb2xkZXIoJ2lucHV0Jyk7XG4gICAgICAgIHZhciBpbnB1dHNUb1N0b3JlID0gb3B0aW9ucy5GVUxMX0FSQ0hJVkUgPyBUcmVlSWxsdXN0cmF0b3IuZ2F0aGVyQWxsSW5wdXREYXRhKCkgOiBzdGF0aWNJbnB1dHM7XG4gICAgICAgICQuZWFjaChpbnB1dHNUb1N0b3JlLCBmdW5jdGlvbihpLCBpbnB1dERhdGEpIHtcbiAgICAgICAgICAgIHZhciBpdHNQYXRoID0gaW5wdXREYXRhLnBhdGg7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IHV0aWxzLnNlcmlhbGl6ZURhdGFGb3JTYXZlZEZpbGUoIGlucHV0RGF0YS52YWx1ZSApO1xuICAgICAgICAgICAgYXJjaGl2ZS5maWxlKGl0c1BhdGgsIHNlcmlhbGl6ZWQudmFsdWUsIHNlcmlhbGl6ZWQub3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBvdGhlciBjYWNoZSBlbnRyaWVzICh0cmFuc2Zvcm1lZCBkYXRhKVxuICAgIGlmIChvcHRpb25zLkZVTExfQVJDSElWRSkge1xuICAgICAgICAvL3ZhciB0cmFuc2Zvcm1Gb2xkZXIgPSBhcmNoaXZlLmZvbGRlcigndHJhbnNmb3JtJyk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1zVG9TdG9yZSA9IFRyZWVJbGx1c3RyYXRvci5nYXRoZXJBbGxUcmFuc2Zvcm1EYXRhKCk7XG4gICAgICAgICQuZWFjaCh0cmFuc2Zvcm1zVG9TdG9yZSwgZnVuY3Rpb24oaSwgdHJhbnNmb3JtRGF0YSkge1xuICAgICAgICAgICAgdmFyIGl0c1BhdGggPSB0cmFuc2Zvcm1EYXRhLnBhdGg7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IHV0aWxzLnNlcmlhbGl6ZURhdGFGb3JTYXZlZEZpbGUoIHRyYW5zZm9ybURhdGEudmFsdWUgKTtcbiAgICAgICAgICAgIGFyY2hpdmUuZmlsZShpdHNQYXRoLCBzZXJpYWxpemVkLnZhbHVlLCBzZXJpYWxpemVkLm9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYW55IG91dHB1dCBkb2NzIChTVkcsIFBERilcbiAgICB2YXIgb3V0cHV0Rm9sZGVyID0gYXJjaGl2ZS5mb2xkZXIoJ291dHB1dCcpO1xuICAgIG91dHB1dEZvbGRlci5maWxlKCdtYWluLnN2ZycsIFwiVE9ET1xcblwiLCB7VE9ETzogXCJXaGF0IGFyZSBhcHByb3ByaWF0ZSBvcHRpb25zIGZvciBTVkc/XCJ9KTtcblxuICAgIC8qIEFTU1VNRSB3ZSBoYXZlIG5vIGtub3dsZWRnZSBvZiB0aGUgY2hvc2VuIHNhdmUgcGF0aCwgb3IgdGhlIHByaW9yXG4gICAgICogZXhpc3RlbmNlIG9mIHRoZSBzcGVjaWZpZWQgZmlsZW5hbWUgaW4gdGhhdCBsb2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgc3VnZ2VzdGVkRmlsZU5hbWUgPSBzdHlsaXN0LmdldERlZmF1bHRBcmNoaXZlRmlsZU5hbWUoIGlkICk7XG4gICAgYXJjaGl2ZS5nZW5lcmF0ZUFzeW5jKCB7dHlwZTpcImJsb2JcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2sobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTaG93IHByb2dyZXNzIGFzIGRlbW9uc3RyYXRlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9leGFtcGxlcy9kb3dubG9hZGVyLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggbWV0YWRhdGEucGVyY2VudC50b0ZpeGVkKDIpICsgXCIgJSBjb21wbGV0ZVwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgLnRoZW4oIGZ1bmN0aW9uIChibG9iKSB7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgc3VnZ2VzdGVkRmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZmFpbHVyZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdFUlJPUiBzYXZpbmcgdGhpcyBaSVAgYXJjaGl2ZTpcXG4nKyBlcnIpO1xuICAgICAgICAgICAgICAgICAgfSApO1xufVxuXG5mdW5jdGlvbiBkZWxldGVJbGx1c3RyYXRpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gV2UgcmVhbGx5IGNhbid0IGRvIHRoaXMgdW5kZXIgY3VycmVudCAoMjAxNykgYnJvd2VyIHNlY3VyaXR5IHJ1bGVzIVxuICAgIGNvbnNvbGUuZXJyb3IoXCJkZWxldGVJbGx1c3RyYXRpb24oKSBpcyBub3QgcG9zc2libGUgaW4gbG9jYWwgZmlsZXN5c3RlbSFcIik7XG4gICAgY2FsbGJhY2soe2Vycm9yOiBcImRlbGV0ZUlsbHVzdHJhdGlvbigpIGlzIG5vdCBwb3NzaWJsZSBpbiBsb2NhbCBmaWxlc3lzdGVtIVwifSk7XG59XG5cblxuLy8gR2V0IHVzZXItZnJpZW5kbHkgbGlzdCBvZiBhdmFpbGFibGUgc291cmNlIGRhdGEgZm9yIHRyZWVzLCBldGMuXG4vLyBUT0RPOiBJbmNsdWRlIEpTIHZhcmlhYmxlcywgZnJvbSB3aW5kb3cgc2NvcGUgKG9yIHNjb3BlIHByb3ZpZGVkKT9cbi8vIFRPRE86IFN1cHBvcnQgbXVsdGlwbGUga2VybmVscyAoUHl0aG9uLCBKdWxpYSwgZXRjKSBpZiBhdmFpbGFibGU/XG4vLyBUT0RPOiBGaWx0ZXIga2VybmVsIHZhcnMgKHVzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnM/KSB0byBzaG93IG9ubHkgc3VpdGFibGUgdmFyaWFibGVzIGZvciBlYWNoIHF1ZXJ5P1xuXG4vLyBFeHBvc2Ugc29tZSBtZW1iZXJzIHRvIG91dHNpZGUgY29kZSAoZWcsIEtub2Nrb3V0IGJpbmRpbmdzLCBvbkNsaWNrXG4vLyBhdHRyaWJ1dGVzLi4uKVxudmFyIGFwaSA9IFtcbiAgICAvLyBleHBlY3RlZCBBUEkgZm9yIHN0b3JhZ2UgYmFja2VuZFxuICAgICdnZXRJbGx1c3RyYXRpb25MaXN0JywgIC8vIGFsd2F5cyByZXR1cm5zIGFuIGVtcHR5IGxpc3RcbiAgICAnbG9hZElsbHVzdHJhdGlvbicsXG4gICAgJ3NhdmVJbGx1c3RyYXRpb24nLFxuICAgICdkZWxldGVJbGx1c3RyYXRpb24nLCAgLy8gbm90IHJlYWxseSBhdmFpbGFibGUsIGJ1dCByZXF1aXJlZCBmb3Igc3RhbmRhcmQgYmFja2VuZCBBUElcbiAgICAndXNlckhhc1N0b3JhZ2VBY2Nlc3MnXG5dO1xuJC5lYWNoKGFwaSwgZnVuY3Rpb24oaSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIHBvcHVsYXRlIHRoZSBkZWZhdWx0ICdtb2R1bGUuZXhwb3J0cycgb2JqZWN0XG4gICAgZXhwb3J0c1sgbWV0aG9kTmFtZSBdID0gZXZhbCggbWV0aG9kTmFtZSApO1xufSk7XG4iLCIvKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCBob3N0IGFkYXB0ZXIgZm9yIGEgc3RhbmRhbG9uZSB3ZWItYXBwIChhbGwgbG9naWMgaXNcbiAqIGNsaWVudC1zaWRlIEpTKSB1c2luZyB3ZWIgc2VydmljZXMgZnJvbSB0aGUgT3BlblRyZWUgQVBJcy4gVGhpcyBpbmNsdWRlcyBhXG4gKiBzdG9yYWdlIGJhY2tlbmQgYmFzZWQgb24gcGV5b3RsWzFdIGFuZCBwaHlsZXN5c3RlbVsyXSBjb252ZW50aW9ucyBmb3IgYVxuICogXCJmb2xkZXJpc2hcIiBpbGx1c3RyYXRpb24gdHlwZTpcbiAqXG4gKiBFYWNoIG9iamVjdCBJRCBpcyB1bmlxdWUsIGJ1dCB0aGlzIG1pZ2h0IGJlIGEgc3VicGF0aCBhbmQgd2ViLXNsdWdbM10uIFNvXG4gKiB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBpbGx1c3RyYXRpb25zIGNhbGxlZCAnbXktZmF2b3JpdGUnLCBidXQgdGhleSdkIG5lZWRcbiAqIHRvIGJlIHVuZGVyIGRpZmZlcmVudCBzdWJwYXRocyAocGVyIHVzZXIsIG9yIGJhc2VkIG9uIHNvbWUgb3RoZXIgZ3JvdXBpbmcpLlxuICpcbiAqIFsxXSBwZXlvdGxcbiAqIFsyXSBwaHlsZXN5c3RlbVxuICogWzNdIHdlYiBzbHVnXG4gKi9cblxuLyogVGhlIG1ldGhvZHMgYmVsb3cgY29uc3RpdHV0ZSBhIGdlbmVyYWwgQVBJIGZvciB0aGUgVHJlZSBJbGx1c3RyYXRvci4gXG4gKiBUaGVzZSBzaG91bGQgc3VwcG9ydCBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyB2aWEgY2FsbGJhY2tzLiBXaGVuIGRlZmluaW5nXG4gKiBmdW5jdGlvbiBuYW1lcyBhbmQgYXJndW1lbnRzLCBrZWVwIGluIG1pbmQgdGhhdCB3ZSBleHBlY3QgdG8gYnVpbGQgcGFyYWxsZWxcbiAqIGltcGxlbWVudGF0aW9ucyBpbiBvdGhlciBjb250ZXh0cyAoZS5nLiwgd2l0aGluIGEgZGVkaWNhdGVkIHdlYnNpdGUgb3IgdGhlXG4gKiBUb29scyB0YWIgb2YgdGhlIE9wZW5UcmVlIGN1cmF0aW9uIGFwcCkuXG4gKlxuICogR2VuZXJhbGx5IHNwZWFraW5nLCBlYWNoIGNhbGxiYWNrIGV4cGV0cyBhIHNpbmdsZSBvYmplY3Qgd2l0aCAnZGF0YScgb3JcbiAqICdlcnJvcicgcHJvcGVydGllcywgYnV0IG5vdCBib3RoLiBEZXRhaWxzIGZvciAnZGF0YScgYXJlIHNwZWNpZmljIHRvIGVhY2hcbiAqIG1ldGhvZC5cbiAqL1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdGktdXRpbHMnKSxcbiAgICBKU1ppcCA9IHJlcXVpcmUoJ2pzemlwJyk7XG5cbi8vIFJldHVybiBhIHNlbnNpYmxlIGVycm9yIGZyb20gcGxhY2Vob2xkZXIgbWV0aG9kc1xudmFyIG5vdEltcGxlbWVudGVkUmVzcG9uc2UgPSB7XG4gICAgZXJyb3I6XCJOb3QgeWV0IGltcGxlbWVudGVkIGluIHRoaXMgc3RvcmFnZSBiYWNrZW5kIVwiXG59O1xuXG4vKiBNYW5hZ2UgaWxsdXN0cmF0aW9ucyBmcm9tIHRoZSBjdXJyZW50IGRvY3N0b3JlIChwaHlsZXN5c3RlbSB2aWEgaXRzIEFQSSkuXG4gKiBOLkIuIHRoYXQgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZCB0byBtYW5hZ2UgYSBmZXcgc3VidHlwZXMgKGlsbHVzdHJhdGlvbnMsXG4gKiB0ZW1wbGF0ZXMsIHN0eWxlIGd1aWRlcywgZXRjLikgaW4gYSB1bmlmb3JtIHdheS5cbiAqL1xudmFyIGlsbHVzdHJhdGlvbkFQSUJhc2VVUkwgPSBcImh0dHBzOi8vZGV2YXBpLm9wZW50cmVlb2ZsaWZlLm9yZ1wiO1xudmFyIGxpc3RBbGxJbGx1c3RyYXRpb25zX3VybCA9IGlsbHVzdHJhdGlvbkFQSUJhc2VVUkwgKyAnL3YzL2lsbHVzdHJhdGlvbnMvbGlzdF9hbGwnO1xudmFyIGNyZWF0ZUlsbHVzdHJhdGlvbl9QT1NUX3VybCA9IGlsbHVzdHJhdGlvbkFQSUJhc2VVUkwgKyAnL3YzL2lsbHVzdHJhdGlvbic7XG52YXIgbG9hZElsbHVzdHJhdGlvbl9HRVRfdXJsID0gaWxsdXN0cmF0aW9uQVBJQmFzZVVSTCArICcvdjMvaWxsdXN0cmF0aW9uL3tET0NfSUR9LnppcCc7XG52YXIgdXBkYXRlSWxsdXN0cmF0aW9uX1BVVF91cmwgPSBpbGx1c3RyYXRpb25BUElCYXNlVVJMICsgJy92My9pbGx1c3RyYXRpb24ve0RPQ19JRH0nO1xudmFyIGRlbGV0ZUlsbHVzdHJhdGlvbl9ERUxFVEVfdXJsID0gaWxsdXN0cmF0aW9uQVBJQmFzZVVSTCArICcvdjMvaWxsdXN0cmF0aW9uL3tET0NfSUR9Jztcbi8qIE1hbmFnZSBzdWItcmVzb3VyY2VzIChvcGFxdWUgZmlsZXMpIHdpdGhpbiBjb21wbGV4IHR5cGVzLCBlLmcuIHN1cHBvcnRpbmdcbiAqIGRhdGEgZm9yIGFuIGlsbHVzdHJhdGlvbi5cbiAqXG4gKiBOLkIuIFdlJ2xsIHVzZSBQVVQgKHZzLiBQT1NUKSBmb3IgY3JlYXRpb24gKmFuZCogdXBkYXRlcywgc2luY2Ugd2UnbGxcbiAqIHNwZWNpZnkgdGhlIGRlc2lyZWQgZmlsZS1wYXRoIGluIHRoZSBVUkwuIEFueSBzdWJzZXF1ZW50IFBVVHMgdG8gdGhpcyBVUkxcbiAqIHdpbGwgdXBkYXRlIHRoZSByZXNvdXJjZSBzdG9yZWQgdGhlcmUuXG4gKi9cbi8vdmFyIGNyZWF0ZUZpbGVfUE9TVF91cmwgPSBpbGx1c3RyYXRpb25BUElCYXNlVVJMICsgJy92My9pbGx1c3RyYXRpb24ve0RPQ19JRH0vZmlsZSc7XG52YXIgY3JlYXRlT3JVcGRhdGVGaWxlX1BVVF91cmwgPSBpbGx1c3RyYXRpb25BUElCYXNlVVJMICsgJy92My9pbGx1c3RyYXRpb24ve0RPQ19JRH0ve0ZJTEVfUEFUSH0nO1xudmFyIGxvYWRGaWxlX0dFVF91cmwgPSBpbGx1c3RyYXRpb25BUElCYXNlVVJMICsgJy92My9pbGx1c3RyYXRpb24ve0RPQ19JRH0ve0ZJTEVfUEFUSH0nO1xudmFyIHJlbW92ZUZpbGVfREVMRVRFX3VybCA9IGlsbHVzdHJhdGlvbkFQSUJhc2VVUkwgKyAnL3YzL2lsbHVzdHJhdGlvbi97RE9DX0lEfS97RklMRV9QQVRIfSc7XG5cbi8vIFVzZSBhIGtub3duLWdvb2QgVVJMIGZyYWdtZW50IHRvIGV4dHJhY3QgYW4gaWxsdXN0cmF0aW9uIElEIGZyb20gaXRzIEFQSSBVUkxcbnZhciBpbGx1c3RyYXRpb25VUkxTcGxpdHRlckFQSSA9ICcvaWxsdXN0cmF0aW9uLyc7XG4vLyBGYWxsIGJhY2sgdG8gcmF3LWRhdGEgVVJMIGluIHNvbWUgY2FzZXNcbnZhciBpbGx1c3RyYXRpb25VUkxTcGxpdHRlclJhdyA9ICcvZG9jcy1ieS1vd25lci8nOyAgLy8gb3IgJ2lsbHVzdHJhdGlvbnMnP1xuXG5mdW5jdGlvbiBnZXRJbGx1c3RyYXRpb25JREZyb21VUkwodXJsKSB7XG4gICAgLy8gYW55dGhpbmcgYWZ0ZXIgdGhlIGtub3duIEFQSSBlbmRwb2ludCBpcyBhIGlsbHVzdHJhdGlvbiBJRFxuICAgIHZhciBmcm9tQVBJID0gdXJsLnNwbGl0KCBpbGx1c3RyYXRpb25VUkxTcGxpdHRlckFQSSApWzFdO1xuICAgIHZhciBmcm9tUmF3RGF0YSA9IHVybC5zcGxpdCggaWxsdXN0cmF0aW9uVVJMU3BsaXR0ZXJSYXcgKVsxXTtcbiAgICBpZiAoZnJvbVJhd0RhdGEpIHtcbiAgICAgICAgLy8gc3RyaXAgZmlsZSBleHRlbnNpb25cbiAgICAgICAgZnJvbVJhd0RhdGEgPSBmcm9tUmF3RGF0YS5zcGxpdCgnLmpzb24nKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BUEkgfHwgZnJvbVJhd0RhdGE7XG59XG5cbi8qIE1vc3Qgb3BlcmF0aW9ucyAoYmV5b25kIGEgc2ltcGxlIGZldGNoKSB3aWxsIHJlcXVpcmUgdGhlIHVzZXIgdG8gYmUgbG9nZ2VkXG4gKiBpbiB2aWEgR2l0SHViLiBTdG9yZSB0aGVpciBpZCwgbmFtZSwgYW5kIGNyZWRlbnRpYWxzIGhlcmUuXG4gKi9cbnZhciBnaXRodWJBUElCYXNlVVJMID0gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xudmFyIGdldEdpdEh1YlRva2VuX3VybCA9IGdpdGh1YkFQSUJhc2VVUkwgKyAnL2F1dGhvcml6YXRpb25zJztcbnZhciBnZXRHaXRIdWJVc2VySW5mb191cmwgPSBnaXRodWJBUElCYXNlVVJMICsgJy91c2VyJztcbnZhciB1c2VyRGlzcGxheU5hbWUgPSBrby5vYnNlcnZhYmxlKCksXG4gICAgdXNlckxvZ2luID0ga28ub2JzZXJ2YWJsZSgpLFxuICAgIHVzZXJFbWFpbCA9IGtvLm9ic2VydmFibGUoKSxcbiAgICB1c2VyQXV0aFRva2VuO1xudmFyIGdpdGh1YlRva2VuUHJvcHMgPSB7XG4gICAgXCJzY29wZXNcIjogW1wicHVibGljX3JlcG9cIl0sIFxuICAgIFwibm90ZVwiOiBcIlRyZWUgSWxsdXN0cmF0b3IgKFwiKyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1wiKVwiLFxuICAgIFwiZmluZ2VycHJpbnRcIjogXCJ0cmVlLWlsbHVzdHJhdG9yLVwiKyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1wiLW9uZS10aW1lLXRva2VuXCJcbn1cbmZ1bmN0aW9uIHVzZXJIYXNTdG9yYWdlQWNjZXNzKCkge1xuICAgIHJldHVybiB1c2VyTG9naW4oKSAmJiAodXNlckxvZ2luKCkgIT09ICdMT0dJTl9OT1RfRk9VTkQnKTtcbn1cblxuZnVuY3Rpb24gbG9naW5Ub0dpdEh1YigpIHtcbiAgICAvLyBOLkIuIHdlIG5lZWQgdG8gZW5jb2RlIGNyZWRlbnRpYWxzIHRvIEJhc2U2NCBmb3IgdGhlIEF1dGggaGVhZGVyXG4gICAgdmFyICRwb3B1cCA9ICQoJyNzdG9yYWdlLW9wdGlvbnMtcG9wdXAnKTtcbiAgICB2YXIgdXNlcm5hbWUgPSAkLnRyaW0oICRwb3B1cC5maW5kKCcjZ2l0aHViLXVzZXJpZCcpLnZhbCgpICk7XG4gICAgdmFyIHBhc3N3b3JkID0gJC50cmltKCAkcG9wdXAuZmluZCgnI2dpdGh1Yi1wYXNzd29yZCcpLnZhbCgpICk7XG4gICAgdmFyIGI2NGNyZWRlbnRpYWxzID0gYnRvYSggdXNlcm5hbWUrJzonK3Bhc3N3b3JkICk7XG4gICAgLy8gTi5CLiBhdG9iKGI2NGhlYWRlcikgc2hvdWxkIGNsZWFubHkgcmVzdG9yZSB0aGUgaW5wdXQgdmFsdWVzXG4gICAgdmFyIGJhc2ljQXV0aEhlYWRlcnMgPSB7XG4gICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBcIkJhc2ljIFwiKyBiNjRjcmVkZW50aWFsc1xuICAgIH1cbiAgICB2YXIgZGVsZXRlUHJpb3JBdXRoVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogV2UgY2FsbCB0aGlzIGlmIHdlJ3JlIGJsb2NrZWQgKGJlbG93KSBmcm9tIGNyZWF0aW5nIGEgbmV3IE9BdXRoXG4gICAgICAgICAqIHRva2VuIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIHN0YWxlIG9uZSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICB1cmw6IGdldEdpdEh1YlRva2VuX3VybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJhc2ljQXV0aEhlYWRlcnMsXG4gICAgICAgICAgICAvL2RhdGE6IHt9LFxuICAgICAgICAgICAgLy9jcm9zc2RvbWFpbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oIGRhdGEgKSB7ICAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRmluZCB0aGUgaWQgb2YgdGhlIGV4aXN0aW5nIHRva2VuIHdpdGggbXkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHZhciBzdGFsZVRva2VuSUQgPSBudWxsO1xuICAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihpLCB0b2tlbkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoKHRva2VuSW5mby5hcHAubmFtZSA9PT0gZ2l0aHViVG9rZW5Qcm9wcy5ub3RlKSAmJiAuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuSW5mby5maW5nZXJwcmludCA9PT0gZ2l0aHViVG9rZW5Qcm9wcy5maW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGVUb2tlbklEID0gdG9rZW5JbmZvLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFsZVRva2VuSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBlcnJvciBjbGVhcmluZyBvbGQgR2l0SHViIE9BdXRoIHRva2VuLiBQcm9iYWJseSBqdXN0IGEgNDA0IGVycm9yLCBubyBuZWVkIGZvciBhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IChnZXRHaXRIdWJUb2tlbl91cmwgK1wiL1wiKyBzdGFsZVRva2VuSUQpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBiYXNpY0F1dGhIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlYWxseSBzaG91bGRuJ3QgZ28gd3JvbmcuLlxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluIHRvIGNyZWF0ZSBhIG5ldyB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlTmV3QXV0aFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCBqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24gKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yVGhyb3duID09ICdVbmF1dGhvcml6ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiR2l0SHViIGNyZWRlbnRpYWxzIG5vdCByZWNvZ25pemVkISBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIlVua25vd24gZXJyb3IgY29udGFjdGluZyBHaXRIdWIuIFBsZWFzZSB3YWl0IGEgbW9tZW50IGFuZCB0cnkgYWdhaW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlOiBmdW5jdGlvbigganFYSFIsIHRleHRTdGF0dXMgKSB7IH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjcmVhdGVOZXdBdXRoVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogQ2FsbCBHaXRIdWIgQVBJIHRvIGdlbmVyYXRlIGEgbmV3IE9BdXRoIHRva2VuIGZvciB0aGlzIHVzZXIuICBOb3RlXG4gICAgICAgICAqIHRoYXQgd2UncmUgZ2V0dGluZyBhIGdlbmVyYWwgXCJwZXJzb25hbCBhY2Nlc3NcIiB0b2tlbiBmb3IgdGhpcyB1c2VyLFxuICAgICAgICAgKiBub3Qgc29tZXRoaW5nIGFwcGxpY2F0aW9uLXNwZWNpZmljIHNpbmNlIHRoYXQgd291bGQgcmVxdWlyZSBleHBvc2luZ1xuICAgICAgICAgKiBpdHMgY2xpZW50IHNlY3JldCwgYXMgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAgICAqICAgaHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS92My9vYXV0aF9hdXRob3JpemF0aW9ucy8jZ2V0LW9yLWNyZWF0ZS1hbi1hdXRob3JpemF0aW9uLWZvci1hLXNwZWNpZmljLWFwcFxuICAgICAgICAgKi9cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogZ2V0R2l0SHViVG9rZW5fdXJsLFxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoIGdpdGh1YlRva2VuUHJvcHMgKSxcbiAgICAgICAgICAgIC8qIE5PVEUgdGhhdCB3ZSBjYW4ndCB1c2UgalF1ZXJ5J3MgbmV3ZXIgYHVzZXJuYW1lYCBhbmQgYHBhc3N3b3JkYCBcbiAgICAgICAgICAgICAqIHByb3BlcnRpZXMgaGVyZSwgc2luY2UgdGhlIEdpdEh1YiBBUEkgd29uJ3QgcHJlc2VudCBhbiBhdXRoXG4gICAgICAgICAgICAgKiBjaGFsbGVuZ2UuIEluc3RlYWQsIHdlJ2xsIG5lZWQgdG8gcHJlLWVtcHRpdmVseSBzZW5kIHRoZSB1c2VyJ3NcbiAgICAgICAgICAgICAqIGNyZWRlbnRpYWxzIGluIG91ciBmaXJzdCByZXF1ZXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoZWFkZXJzOiBiYXNpY0F1dGhIZWFkZXJzLFxuICAgICAgICAgICAgLy9jcm9zc2RvbWFpbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oIGRhdGEgKSB7ICAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gcmF3IHJlc3BvbnNlIHNob3VsZCBiZSBKU09OXG4gICAgICAgICAgICAgICAgdXNlckF1dGhUb2tlbiA9IGRhdGEudG9rZW47XG4gICAgICAgICAgICAgICAgLy8vY29uc29sZS53YXJuKFwiPj4+IEdpdEh1YiBPQXV0aCB0b2tlbjogXCIrIHVzZXJBdXRoVG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBuZXcgdG9rZW4gdG8gZmV0Y2ggdXNlciBpZCwgZGlzcGxheSBuYW1lLCBlbWFpbCg/KVxuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldEdpdEh1YlVzZXJJbmZvX3VybCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IFwiVG9rZW4gXCIrIHVzZXJBdXRoVG9rZW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5vdyBoYXZlIHByb3BlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEaXNwbGF5TmFtZShkYXRhLm5hbWUgfHwgXCJOQU1FX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJMb2dpbihkYXRhLmxvZ2luIHx8IFwiTE9HSU5fTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckVtYWlsKGRhdGEuZW1haWwgfHwgXCJFTUFJTF9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgcGFzc3dvcmQtaW5wdXQgZmllbGQsIGhpZGUgbG9naW4sIHNob3cgc29tZSBjb250ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgJHBvcHVwLmZpbmQoJyNnaXRodWItcGFzc3dvcmQnKS52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2dpdGh1Yi1sb2dpbi1wYW5lbCcpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNnaXRodWItbG9nZ2VkLWluJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnl0aGluZyBlbHNlIHRvIGRvIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1VuYXV0aG9yaXplZCc6ICAvLyA0MDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiR2l0SHViIGNyZWRlbnRpYWxzIG5vdCByZWNvZ25pemVkISBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdVbnByb2Nlc3NhYmxlIEVudGl0eSc6ICAvLyA0MjJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgdG9rZW4gYWxyZWFkeSBleGlzdHMhIENsb2JiZXJpbmcgb2xkIHRva2VuIHRvIHJldHJ5Li4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSB0aGF0IHRoaXMgd2lsbCBzZWFyY2gtYW5kLWRlc3Ryb3kgdGhlIG9sZCB0b2tlbiwgdGhlbiByZXRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByaW9yQXV0aFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiVW5rbm93biBlcnJvciAnXCIrIGVycm9yVGhyb3duICtcIicgKFwiKyBqcVhIUi5zdGF0dXMgK1wiKSBjb250YWN0aW5nIEdpdEh1Yi4gUGxlYXNlIHdhaXQgYSBtb21lbnQgYW5kIHRyeSBhZ2FpblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFN0YXJ0IHRoZSBwcm9jZXNzLCB1c2luZyBsb2NhbCBmdW5jcyBhbmQgY3JlZGVudGlhbHNcbiAgICBjcmVhdGVOZXdBdXRoVG9rZW4oKTtcbn1cblxuZnVuY3Rpb24gdXNlcklzTG9nZ2VkSW50b0dpdEh1YigpIHtcbiAgICByZXR1cm4gISF1c2VyQXV0aFRva2VuOyAgLy8gZmFpbHMgb24gXCJcIiwgbnVsbCwgdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRHaXRIdWJJbGx1c3RyYXRpb25JRCggKSB7XG4gICAgLy8gc3VnZ2VzdCBhbiBJRCwgYmFzZWQgb24gcHJpb3Igc3RvcmFnZSAqb3IqIGlsbHVzdHJhdGlvbiBuYW1lXG4gICAgLyogQ1VSUkVOVExZIFVOVVNFRCEgYnV0IHNlZW1zIGhhbmR5Li4uICovXG4gICAgdmFyIHByaW9yU3RvcmFnZVVSTCA9IHN0eWxpc3QuaWxsLm1ldGFkYXRhLnVybCgpO1xuICAgIGlmIChwcmlvclN0b3JhZ2VVUkwpIHtcbiAgICAgICAgcmV0dXJuIGdldElsbHVzdHJhdGlvbklERnJvbVVSTChwcmlvclN0b3JhZ2VVUkwpO1xuICAgIH1cbiAgICB2YXIgbmFtZVNsdWcgPSBzbHVnaWZ5KHN0eWxpc3QuaWxsLm1ldGFkYXRhLm5hbWUoKSk7XG4gICAgcmV0dXJuICh1c2VyTG9naW4oKSArJy8nKyBuYW1lU2x1Zyk7XG59XG5cbmZ1bmN0aW9uIHNsdWdpZnkoc3RyKSB7XG4gICAgLy8gQ29udmVydCBhbnkgc3RyaW5nIGludG8gYSBzaW1wbGlmaWVkIFwic2x1Z1wiIHN1aXRhYmxlIGZvciB1c2UgaW4gVVJMIG9yIHF1ZXJ5LXN0cmluZ1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW15hLXowLTkgLV0vZywgJycpICAvLyByZW1vdmUgaW52YWxpZCBjaGFyc1xuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpICAgICAgICAgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBieSAtXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8tKy9nLCAnLScpOyAgICAgICAgIC8vIGNvbGxhcHNlIGRhc2hlc1xufVxuXG5mdW5jdGlvbiBnZXRJbGx1c3RyYXRpb25MaXN0KGNhbGxiYWNrKSB7XG4gICAgLyogVGhlICdkYXRhJyAoaWYgc3VjY2Vzc2Z1bCkgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggd2l0aFxuICAgICAqICduYW1lJywgJ2Rlc2NyaXB0aW9uJywgYW5kICdzb3VyY2UnIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgLy8gVW50aWwgd2UgaGF2ZSBhIGZhc3QgaW5kZXgsIGZldGNoIHRoZSBjb21wbGV0ZSBpbGx1c3RyYXRpb24gbGlzdCBmcm9tIHRoZSBpbGx1c3RyYXRpb25zIEFQSVxuICAgIC8vIGh0dHBzOi8vZGV2YXBpLm9wZW50cmVlb2ZsaWZlLm9yZy92My9pbGx1c3RyYXRpb25zL2xpc3RfYWxsXG4gICAgLy8gJ2NhbGxiYWNrJyBleHBlY3RzIGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXNcbiAgICB2YXIgcmVzcCA9IHt9O1xuICAgICQuYWpheCh7XG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICB1cmw6IGxpc3RBbGxJbGx1c3RyYXRpb25zX3VybCxcbiAgICAgICAgLy9jcm9zc2RvbWFpbjogdHJ1ZSxcbiAgICAgICAgLy9jb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhICkgeyAgLy8gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgLy8gY29udmVydCByYXcgcmVzcG9uc2UgdG8gSlNPTlxuICAgICAgICAgICAgdmFyIGZvdW5kSWxsdXN0cmF0aW9ucyA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICAgICAgcmVzcC5kYXRhID0gWyBdO1xuICAgICAgICAgICAgaWYgKGZvdW5kSWxsdXN0cmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDb252ZXJ0IHRoZXNlIHByb3BlcnRpZXMgdG8gdGhlIG1vcmUgZ2VuZXJpYyBvbmVzIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gYnkgdGhlIFRyZWUgSWxsdXN0cmF0b3IgKG5hbWUsIGRlc2NyaXB0aW9uLCBzb3VyY2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCc9PT0gZm91bmQgJysgZm91bmRJbGx1c3RyYXRpb25zLmxlbmd0aCArJyBpbGx1c3RyYXRpb25zID09PScpO1xuICAgICAgICAgICAgICAgICQuZWFjaCggZm91bmRJbGx1c3RyYXRpb25zLCBmdW5jdGlvbihpLCBpbGx1c3RyYXRpb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgcmljaCBIVE1MIGRlc2NyaXB0aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIC8qIFNraXBwaW5nIHRoaXMgZm9yIG5vdyAoYSBnZW5lcmFsIEdpdEh1YiBVUkwgdG8gaXRzIGZvbGRlciB3b3VsZCBiZSBiZXR0ZXIhKVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjVVJMID0gJ2h0dHBzOi8vZGV2YXBpLm9wZW50cmVlb2ZsaWZlLm9yZy92My9pbGx1c3RyYXRpb24ve0lEfSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3tJRH0nLCBpbGx1c3RyYXRpb25JbmZvWydpZCddKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRhcHQgdGhlIFVSTCBhYm92ZSB0byB1c2UgbWF0Y2hpbmcgQVBJIGRvbWFpbiFcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NIVE1MID0gJzxhIGhyZWY9XCJ7VVJMfVwiIHRhcmdldD1cIl9ibGFua1wiIHRpdGxlPVwiQ2xpY2sgdG8gc2VlIHNvdXJjZSBpbiBhIG5ldyB3aW5kb3dcIj57SUR9PC9hPjwvZGl2PidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgne1VSTH0nLCBzcmNVUkwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3tJRH0nLCBpbGx1c3RyYXRpb25JbmZvWydpZCddKTtcbiAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY0hUTUwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlsbHVzdHJhdGlvbkluZm8ubWV0YWRhdGFbJ2Rlc2NyaXB0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NIVE1MICs9ICc8ZGl2IGNsYXNzPVwiZ2l0aHViLWRlc2NyaXB0aW9uXCI+e0RFU0N9PC9kaXY+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgne0RFU0N9JywgaWxsdXN0cmF0aW9uSW5mby5tZXRhZGF0YVsnZGVzY3JpcHRpb24nXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcC5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIGZvciBzaW1wbGUtY2hvb3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaWxsdXN0cmF0aW9uSW5mby5tZXRhZGF0YVsnbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NIVE1MLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpbGx1c3RyYXRpb25JbmZvWydpZCddXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzQXJyYXkoZm91bmRJbGx1c3RyYXRpb25zKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignPT09IG5vIGlsbHVzdHJhdGlvbnMgZm91bmQgPT09Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJz09PSBpbnZhbGlkIHJlc3BvbnNlISA9PT0nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvdW5kSWxsdXN0cmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmVzcC5lcnJvciA9IFwiSW52YWxpZCByZXNwb25zZSAoaWxsdXN0cmF0aW9uIGxpc3QpOiBcIisgZm91bmRJbGx1c3RyYXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biApIHtcbiAgICAgICAgICAgIHJlc3AuZXJyb3IgPSBcIlVuYWJsZSB0byBsb2FkIGlsbHVzdHJhdGlvbiBsaXN0IVwiO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbG9hZElsbHVzdHJhdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgICAvLyAnY2FsbGJhY2snIGV4cGVjdHMgYSBzaW5nbGUgb2JqIHdpdGggJ2RhdGEnIG9yICdlcnJvcicgcHJvcGVydGllc1xuICAgIHZhciByZXNwID0ge307XG4gICAgJC5hamF4KHtcbiAgICAgICAgZ2xvYmFsOiBmYWxzZSwgIC8vIHN1cHByZXNzIHdlYjJweSdzIGFnZ3Jlc3NpdmUgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgZGF0YVR5cGU6ICdiaW5hcnknLCAgICAgLy8gbm93IGhhcyBhIHByb3BlciBiaW5hcnkgdHJhbnNwb3J0XG4gICAgICAgIHVybDogbG9hZElsbHVzdHJhdGlvbl9HRVRfdXJsLnJlcGxhY2UoJ3tET0NfSUR9JywgaWQpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAvLyBtaXNjIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAnYXV0aG9yX25hbWUnOiAodXNlckRpc3BsYXlOYW1lKCkgfHwgXCJcIiksXG4gICAgICAgICAgICAnYXV0aG9yX2VtYWlsJzogKHVzZXJFbWFpbCgpIHx8IFwiXCIpLFxuICAgICAgICAgICAgJ2F1dGhfdG9rZW4nOiAodXNlckF1dGhUb2tlbiB8fCBcIlwiKVxuICAgICAgICB9LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiggZGF0YSwgdGV4dFN0YXR1cywganFYSFIgKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBtZXRob2Qgc2hvdWxkIHJldHVybiBlaXRoZXIgdGhlIG5ldyBpbGx1c3RyYXRpb24gYXMgYSBaSVAgYXJjaGl2ZSwgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vaGlkZU1vZGFsU2NyZWVuKCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCB2ZXJzaW9uIGhpc3Rvcnkgb3Igb3RoZXIgbWV0YWRhdGE/XG4gICAgICAgICAgICAvKiBUaGUgY2FsbGJhY2sgcHJvdmlkZWQgd2lsbCByZXBsYWNlIHN0eWxpc3QuaWxsIGFuZCByZWJpbmQgVUlcbiAgICAgICAgICAgICAqIGFuZCB0aGUgcmVuZGVyaW5nIHBpcGVsaW5lLiBJdCBleHBlY3RzIGEgcmVzcG9uc2Ugb2JqZWN0IHdpdGhcbiAgICAgICAgICAgICAqICdkYXRhJyBvciAnZXJyb3InLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIganNvbkRhdGEsIGlsbCwgYXJjaGl2ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAganNvbkRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9hZElsbHVzdHJhdGlvbigpOiBSZXNwb25zZSBwYXJzZWQgYXMgSlNPTlwiKTtcbiAgICAgICAgICAgICAgICBpbGwgPSBqc29uRGF0YVsnZGF0YSddOyAgLy8gaWxsdXN0cmF0aW9uIGFzIEpTIG9iamVjdCBcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImxvYWRJbGx1c3RyYXRpb24oKTogUmVzcG9uc2UgaXMgbm90IEpTT04sIHRyeWluZyBhcyBhIFpJUCBhcmNoaXZlXCIpO1xuICAgICAgICAgICAgICAgIHZhciBhcmNoaXZlID0gbmV3IEpTWmlwKCk7XG4gICAgICAgICAgICAgICAgdmFyIHppcE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYmFzZTY0OiB0cnVlLCAgICAgICAgICAgICAgICAgLy8gbm9wZSwgZmFpbHMgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrQ1JDMzI6IHRydWUgICAgICAgICAgICAgIC8vIHN0aWxsIHJlcG9ydHMgbWlzc2luZyBieXRlc1xuICAgICAgICAgICAgICAgICAgICAvL29wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSAgIC8vIHN0aWxsIHJlcG9ydHMgbWlzc2luZyBieXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmNoaXZlLmxvYWRBc3luYyhkYXRhLCB6aXBPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih6aXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGFuZCBwYXJzZSB0aGUgSlNPTiBjb3JlIGZpbGUgaW4gdGhpcyBhcmNoaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vY29uc29sZS5sb2coemlwLmZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXAuZmlsZSgnbWFpbi5qc29uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFzeW5jKFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbWV0YWRhdGEgd3JhcHBlciBoZXJlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWxsID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJsb2FkSWxsdXN0cmF0aW9uKCk6IFJlc3BvbnNlIHBhcnNlZCBhcyBKU09OXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AuZGF0YSA9IGlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AuZXJyb3IgPSBcIlVuYWJsZSB0byBwYXJzZSAnbWFpbi5qc29uJyFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBiYWlsIG91dCBvZiBvdXRlciBmdW5jdGlvbiAod2UgaGFuZGxlIGNhbGxiYWNrcyBhYm92ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbGwpIHsgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICByZXNwLmVycm9yID0gXCJObyBpbGx1c3RyYXRpb24gZGF0YSBmb3VuZCFcIjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3AuZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGlsbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3AuZXJyb3IgPSBcIk5vIGlsbHVzdHJhdGlvbiAnXCIrIGlkICtcIicgZm91bmQhXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5kYXRhID0gaWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3ApO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oIGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSICkge1xuICAgICAgICAgICAgLy9oaWRlTW9kYWxTY3JlZW4oKTtcbiAgICAgICAgICAgIGlmICgodHlwZW9mKGpxWEhSLnJlc3BvbnNlVGV4dCkgIT09ICdzdHJpbmcnKSB8fCBqcVhIUi5yZXNwb25zZVRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzcC5lcnJvciA9ICdTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhpcyBpbGx1c3RyYXRpb24uIChObyBtb3JlIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZS4pJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcC5lcnJvciA9ICdTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhpcyBpbGx1c3RyYXRpb246XFxuXFxuICcrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3ApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVJbGx1c3RyYXRpb24oaWxsdXN0cmF0aW9uSUQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge0ZVTExfQVJDSElWRTogdHJ1ZX07XG4gICAgLy8gJ2NhbGxiYWNrJyBleHBlY3RzIGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXNcbiAgICB2YXIgcmVzcCA9IHt9O1xuICAgIC8vIFRPRE86IHN1cHBvcnQgc2F2ZSwgc2F2ZS1hcywgY29weT9cbiAgICBpZiAoIXVzZXJBdXRoVG9rZW4pIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc2F2ZSB3aXRob3V0IGEgdG9rZW47IHN0b3AgYW5kIHByb21wdCBmb3IgbG9naW5cbiAgICAgICAgbG9naW5Ub0dpdEh1YigpO1xuICAgICAgICByZXNwLmVycm9yID0gXCJVc2VyIG5vdCBsb2dnZWQgaW50byBHaXRIdWIhIFByb21wdGluZyBmb3IgbG9naW4gbm93LlwiXG4gICAgICAgIGNhbGxiYWNrKHJlc3ApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFkZCB0aGlzIHVzZXIgdG8gdGhlIGF1dGhvcnMgbGlzdCwgaWYgbm90IGZvdW5kXG4gICAgLy8gVE9ETzogYWRkIGVtYWlsIG9yIHVzZXJpZCBoZXJlLCBzbyB3ZSBjYW4gbGluayB0byBhdXRob3JzP1xuICAgIHZhciBsaXN0UG9zID0gJC5pbkFycmF5KCB1c2VyRGlzcGxheU5hbWUoKSwgc3R5bGlzdC5pbGwubWV0YWRhdGEuYXV0aG9ycygpICk7XG4gICAgaWYgKGxpc3RQb3MgPT09IC0xKSB7XG4gICAgICAgIHN0eWxpc3QuaWxsLm1ldGFkYXRhLmF1dGhvcnMucHVzaCggdXNlckRpc3BsYXlOYW1lKCkgKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgYSBcInNjcnViYmVyXCIgYXMgd2UgZG8gZm9yIE9wZW5UcmVlIHN0dWRpZXM/IFxuICAgIC8vIHNjcnViSWxsdXN0cmF0aW9uRm9yVHJhbnNwb3J0KHN0eWxpc3QuaWxsKTtcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGN1cnJlbnQgaWxsdXN0cmF0aW9uIHRvIHNpbXBsZSBKUyB1c2luZyBvdXIgXG4gICAgLy8gS25vY2tvdXQgbWFwcGluZyBvcHRpb25zXG4gICAgdmFyIGNsb25hYmxlSWxsdXN0cmF0aW9uID0ga28ubWFwcGluZy50b0pTKHN0eWxpc3QuaWxsKTtcblxuICAgIC8vIEFyZSB3ZSBjcmVhdGluZyBhIG5ldyBvbmUsIG9yIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG9uZT9cbiAgICB2YXIgY3JlYXRlT3JVcGRhdGU7XG4gICAgaWYgKCgnc2hhJyBpbiBzdHlsaXN0LmlsbC5tZXRhZGF0YSkgJiYgc3R5bGlzdC5pbGwubWV0YWRhdGEuc2hhKCkpIHtcbiAgICAgICAgLy8gd2UncmUgVVBEQVRJTkcgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxuICAgICAgICBjcmVhdGVPclVwZGF0ZSA9ICdVUERBVEUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlJ3JlIENSRUFUSU5HIGEgbmV3IGNvbGxlY3Rpb25cbiAgICAgICAgY3JlYXRlT3JVcGRhdGUgPSAnQ1JFQVRFJztcbiAgICB9XG4gICAgaWYgKGlsbHVzdHJhdGlvbklEICYmIHR5cGVvZihpbGx1c3RyYXRpb25JRCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHVwZGF0ZSAob3IgYWRkKSBhbiBpbnRlcm5hbCBVUkwgd2l0aCB0aGUgc3BlY2lmaWVkIElELCBlLmcuIGZyb20gU2F2ZSBBcy4uLlxuICAgICAgICBjbG9uYWJsZUlsbHVzdHJhdGlvbi5tZXRhZGF0YS51cmwgPSBpbGx1c3RyYXRpb25VUkxTcGxpdHRlckFQSSArIGlsbHVzdHJhdGlvbklEO1xuICAgIH0gZWxzZSBpZiAoY2xvbmFibGVJbGx1c3RyYXRpb24ubWV0YWRhdGEudXJsKSB7XG4gICAgICAgIC8vIHdlJ2xsIHVzZSB0aGUgSUQgYWxyZWFkeSBzdG9yZWQgaW4gaXRzIFVSTFxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlJ2xsIGJ1aWxkIGEgcHJvcHNlZCB1cmwsIGJhc2VkIG9uIHRoZSBpbGx1c3RyYXRpb24ncyBuYW1lXG4gICAgICAgIHZhciBuYW1lU2x1ZyA9IHNsdWdpZnkoY2xvbmFibGVJbGx1c3RyYXRpb24ubWV0YWRhdGEubmFtZSk7XG4gICAgICAgIC8vIGJ1aWxkIGEgZnJlc2ggSUQgd2l0aCBjdXJyZW50IHVzZXIgYXMgY3JlYXRvclxuICAgICAgICBjbG9uYWJsZUlsbHVzdHJhdGlvbi5tZXRhZGF0YS51cmwgPSBpbGx1c3RyYXRpb25VUkxTcGxpdHRlckFQSSArIHVzZXJMb2dpbigpICsnLycrIG5hbWVTbHVnO1xuICAgIH1cbiAgICBpbGx1c3RyYXRpb25JRCA9IGdldElsbHVzdHJhdGlvbklERnJvbVVSTChjbG9uYWJsZUlsbHVzdHJhdGlvbi5tZXRhZGF0YS51cmwpO1xuXG4gICAgLy8gY3JlYXRlIGEgWmlwIGFyY2hpdmUsIGFkZCB0aGUgY29yZSBkb2N1bWVudCBhbmQgc3RhdGljIGlucHV0IGRhdGFcbiAgICB2YXIgYXJjaGl2ZSA9IG5ldyBKU1ppcCgpO1xuICAgIGFyY2hpdmUuZmlsZShcIm1haW4uanNvblwiLCBKU09OLnN0cmluZ2lmeShjbG9uYWJsZUlsbHVzdHJhdGlvbikpO1xuICAgIC8vIFRlc3QgYWxsIGlucHV0IGZvciByZXBlYXRhYmxlIHByb3ZlbmFuY2UgaW5mbzsgaWYgYW55IGFyZSBsYWNraW5nIGFcbiAgICAvLyBjbGVhciBzb3VyY2UsIHdlIHNob3VsZCBlbWJlZCB0aGUgc291cmNlIGRhdGEgaGVyZS5cbiAgICB2YXIgc3RhdGljSW5wdXRzID0gVHJlZUlsbHVzdHJhdG9yLmdhdGhlclN0YXRpY0lucHV0RGF0YSgpO1xuICAgIGlmIChvcHRpb25zLkZVTExfQVJDSElWRSB8fCAoc3RhdGljSW5wdXRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIC8vIGFkZCBzb21lIG9yIGFsbCBpbnB1dCBkYXRhIGZvciB0aGlzIGlsbHVzdHJhdGlvblxuICAgICAgICB2YXIgaW5wdXRzVG9TdG9yZSA9IG9wdGlvbnMuRlVMTF9BUkNISVZFID8gVHJlZUlsbHVzdHJhdG9yLmdhdGhlckFsbElucHV0RGF0YSgpIDogc3RhdGljSW5wdXRzO1xuICAgICAgICAkLmVhY2goaW5wdXRzVG9TdG9yZSwgZnVuY3Rpb24oaSwgaW5wdXREYXRhKSB7XG4gICAgICAgICAgICB2YXIgaXRzUGF0aCA9IGlucHV0RGF0YS5wYXRoO1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSB1dGlscy5zZXJpYWxpemVEYXRhRm9yU2F2ZWRGaWxlKCBpbnB1dERhdGEudmFsdWUgKTtcbiAgICAgICAgICAgIGFyY2hpdmUuZmlsZShpdHNQYXRoLCBzZXJpYWxpemVkLnZhbHVlLCBzZXJpYWxpemVkLm9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuRlVMTF9BUkNISVZFKSB7XG4gICAgICAgIC8vIGFkZCBvdGhlciBjYWNoZSBlbnRyaWVzICh0cmFuc2Zvcm1lZCBkYXRhKVxuICAgICAgICAvLy92YXIgdHJhbnNmb3JtRm9sZGVyID0gYXJjaGl2ZS5mb2xkZXIoJ3RyYW5zZm9ybScpO1xuICAgICAgICB2YXIgdHJhbnNmb3Jtc1RvU3RvcmUgPSBUcmVlSWxsdXN0cmF0b3IuZ2F0aGVyQWxsVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICAkLmVhY2godHJhbnNmb3Jtc1RvU3RvcmUsIGZ1bmN0aW9uKGksIHRyYW5zZm9ybURhdGEpIHtcbiAgICAgICAgICAgIHZhciBpdHNQYXRoID0gdHJhbnNmb3JtRGF0YS5wYXRoO1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSB1dGlscy5zZXJpYWxpemVEYXRhRm9yU2F2ZWRGaWxlKCB0cmFuc2Zvcm1EYXRhLnZhbHVlICk7XG4gICAgICAgICAgICBhcmNoaXZlLmZpbGUoaXRzUGF0aCwgc2VyaWFsaXplZC52YWx1ZSwgc2VyaWFsaXplZC5vcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHVwbG9hZElsbHVzdHJhdGlvbkJsb2IgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAvLyB1c2UgRm9ybURhdGEgdG8gc2VuZCBcInB1cmVcIiBiaW5hcnkgZGF0YVxuICAgICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdhcmNoaXZlJywgYmxvYiwgJ3VwZGF0ZS56aXAnKTtcblxuICAgICAgICB2YXIgc2F2ZVVSTDtcbiAgICAgICAgaWYgKGNyZWF0ZU9yVXBkYXRlID09PSAnVVBEQVRFJykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbGx1c3RyYXRpb25cbiAgICAgICAgICAgIHNhdmVVUkwgPSB1cGRhdGVJbGx1c3RyYXRpb25fUFVUX3VybC5yZXBsYWNlKCd7RE9DX0lEfScsIGlsbHVzdHJhdGlvbklEKTtcbiAgICAgICAgICAgIC8qIFRPRE8/IGdhdGhlciBjb21taXQgbWVzc2FnZSAoaWYgYW55KSBmcm9tIHByZS1zYXZlIHBvcHVwXG4gICAgICAgICAgICB2YXIgY29tbWl0TWVzc2FnZTtcbiAgICAgICAgICAgIHZhciBmaXJzdExpbmUgPSAkKCcjc2F2ZS1jb21tZW50LWZpcnN0LWxpbmUnKS52YWwoKTtcbiAgICAgICAgICAgIHZhciBtb3JlTGluZXMgPSAkKCcjc2F2ZS1jb21tZW50LW1vcmUtbGluZXMnKS52YWwoKTtcbiAgICAgICAgICAgIGlmICgkLnRyaW0oZmlyc3RMaW5lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb21taXRNZXNzYWdlID0gJC50cmltKG1vcmVMaW5lcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQudHJpbShtb3JlTGluZXMpID09PSAnJyl7XG4gICAgICAgICAgICAgICAgY29tbWl0TWVzc2FnZSA9ICQudHJpbShmaXJzdExpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21taXRNZXNzYWdlID0gJC50cmltKGZpcnN0TGluZSkgK1wiXFxuXFxuXCIrICQudHJpbShtb3JlTGluZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gYWRkIG5vbi1OZXhzb24gdmFsdWVzIHRvIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBxc1ZhcnMgPSAkLnBhcmFtKHtcbiAgICAgICAgICAgICAgICBhdXRob3JfbmFtZTogdXNlckRpc3BsYXlOYW1lKCksXG4gICAgICAgICAgICAgICAgYXV0aG9yX2VtYWlsOiB1c2VyRW1haWwoKSxcbiAgICAgICAgICAgICAgICBhdXRoX3Rva2VuOiB1c2VyQXV0aFRva2VuLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nX2NvbW1pdF9TSEE6IHN0eWxpc3QuaWxsLm1ldGFkYXRhLnNoYSgpLFxuICAgICAgICAgICAgICAgIGNvbW1pdF9tc2c6ICdTYXZlZCBmcm9tIFRyZWUgSWxsdXN0cmF0b3InICAgICAgIC8vIGFkZCB2ZXJzaW9uP1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYXZlVVJMICs9ICgnPycrIHFzVmFycyk7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSwgIC8vIHN1cHByZXNzIHdlYjJweSdzIGFnZ3Jlc3NpdmUgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIC8vIGNyb3NzZG9tYWluOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogZmFsc2UsICAgLy8gRm9ybURhdGEgd2lsbCBzZW5kIGFzICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICAgICAgICAgIHVybDogc2F2ZVVSTCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBvcnQgZXJyb3JzIG9yIG1hbGZvcm1lZCBkYXRhLCBpZiBhbnlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMgIT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWpvciBzZXJ2ZXItc2lkZSBlcnJvciwganVzdCBzaG93IHJhdyByZXNwb25zZSBmb3IgdGVjaCBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5lcnJvciA9IFwiU29ycnksIHRoZXJlIHdhcyBhbiBlcnJvciBzYXZpbmcgdGhpcyBpbGx1c3RyYXRpb246XFxuXFxuXCIrIGpxWEhSLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChyZXNwLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgYmxvY2tlZCB0aGUgc2F2ZSwgcHJvYmFibHkgZHVlIHRvIHZhbGlkYXRpb24gZXJyb3JzIVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLnBhcnNlSlNPTihqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgcHJvcGVybHkgcGFyc2VkIEpTT04sIHNob3cgaXQgbW9yZSBzZW5zaWJseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGJ1dCBmb3Igbm93LCByZXBlYXQgdGhlIGNydWRlIGZlZWRiYWNrIHVzZWQgYWJvdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwLmVycm9yID0gXCJTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yIGluIHRoZSBpbGx1c3RyYXRpb24gZGF0YTpcXG5cXG5cIisganFYSFIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQocmVzcC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcHV0UmVzcG9uc2UgPSAkLnBhcnNlSlNPTihqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29tbWl0U0hBID0gcHV0UmVzcG9uc2VbJ3NoYSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q29tbWl0U0hBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LmlsbC5tZXRhZGF0YS5zaGEobmV3Q29tbWl0U0hBKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBUT0RPOiBhZGQgJ3ZlcnNpb25zJyBvciAnbWV0YWRhdGEudmVyc2lvbnMnIHRvIHJlY29yZCB0aGVzZSBjb21taXRzP1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ3ZlcnNpb25IaXN0b3J5JyBpbiBwdXRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5pbGwubWV0YWRhdGEudmVyc2lvbnMocHV0UmVzcG9uc2VbJ3ZlcnNpb25IaXN0b3J5J10gfHwgWyBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAocHV0UmVzcG9uc2VbJ21lcmdlX25lZWRlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1lvdXIgY2hhbmdlcyB3ZXJlIHNhdmVkLCBidXQgYW4gZWRpdCBieSBhbm90aGVyIHVzZXIgcHJldmVudGVkIHlvdXIgZWRpdCBmcm9tIG1lcmdpbmcgdG8gdGhlIHB1YmxpY2x5IHZpc2libGUgbG9jYXRpb24uIEluIHRoZSBuZWFyIGZ1dHVyZSwgd2UgaG9wZSB0byB0YWtlIGNhcmUgb2YgdGhpcyBhdXRvbWF0aWNhbGx5LiBJbiB0aGUgbWVhbnRpbWUsIHBsZWFzZSA8YSBocmVmPVwibWFpbHRvOmluZm9Ab3BlbnRyZWVvZmxpZmUub3JnP3N1YmplY3Q9SWxsdXN0cmF0aW9uJTIwbWVyZ2UlMjBuZWVkZWQlMjAtJTIwJysgbmV3Q29tbWl0U0hBICsnXCI+cmVwb3J0IHRoaXMgZXJyb3I8L2E+IHRvIHRoZSBPcGVuIFRyZWUgb2YgTGlmZSBzb2Z0d2FyZSB0ZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRPRE86IG1ha2UgdGhpcyBhIGNsZWFuZXIsIG1vcmUgZnJpZW5kbHkgZGlzcGxheSAod2l0aCBhY3RpdmUgbWFpbHRvOiBoeXBlcmxpbmspICovXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTkIsIHdlIHRyZWF0IHRoaXMgYXMgYSB3YXJuaW5nLCBidXQgbm90IGEgc2F2ZSBlcnJvcjsgcmV0dXJuIHRoZSBkYXRhIGFzIGV4cGVjdGVkIVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXN1bWUgc3VjY2VzcyBmcm9tIGhlcmUgb25cbiAgICAgICAgICAgICAgICAgICAgLy9oaWRlTW9kYWxTY3JlZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgLy9zaG93U3VjY2Vzc01lc3NhZ2UoJ1N0dWR5IHNhdmVkIHRvIHJlbW90ZSBzdG9yYWdlLicpO1xuICAgICAgICAgICAgICAgICAgICAvKiBUT0RPOiBCbG9jayBwYWdlLWV4aXQgb24gdW5zYXZlZCBjaGFuZ2VzP1xuICAgICAgICAgICAgICAgICAgICBwb3BQYWdlRXhpdFdhcm5pbmcoJ1VOU0FWRURfU1RVRFlfQ0hBTkdFUycpO1xuICAgICAgICAgICAgICAgICAgICBzdHVkeUhhc1Vuc2F2ZWRDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVTYXZlQnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHVwZGF0ZSB2aXo/XG4gICAgICAgICAgICAgICAgICAgIHJlc3AuZGF0YSA9IHB1dFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHsgIC8vIGkuZS4gY3JlYXRlT3JVcGRhdGUgPT09ICdDUkVBVEUnXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IGlsbHVzdHJhdGlvblxuICAgICAgICAgICAgc2F2ZVVSTCA9IGNyZWF0ZUlsbHVzdHJhdGlvbl9QT1NUX3VybDtcbiAgICAgICAgICAgIC8vIGFkZCBub24tTmV4c29uIHZhbHVlcyB0byB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgICAgICB2YXIgcXNWYXJzID0gJC5wYXJhbSh7XG4gICAgICAgICAgICAgICAgYXV0aG9yX25hbWU6IHVzZXJEaXNwbGF5TmFtZSgpLFxuICAgICAgICAgICAgICAgIGF1dGhvcl9lbWFpbDogdXNlckVtYWlsKCksXG4gICAgICAgICAgICAgICAgYXV0aF90b2tlbjogdXNlckF1dGhUb2tlbixcbiAgICAgICAgICAgICAgICBjb21taXRfbXNnOiAnU2F2ZWQgZnJvbSBUcmVlIElsbHVzdHJhdG9yJyAgICAgICAvLyBhZGQgdmVyc2lvbj9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2F2ZVVSTCArPSAoJz8nKyBxc1ZhcnMpO1xuXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZmFsc2UsICAvLyBzdXBwcmVzcyB3ZWIycHkncyBhZ2dyZXNzaXZlIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3Nkb21haW46IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSwgICAvLyBGb3JtRGF0YSB3aWxsIHNlbmQgYXMgJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgICAgICAgICAgdXJsOiBzYXZlVVJMLFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaXNjIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICdhdXRob3JfbmFtZSc6ICh1c2VyRGlzcGxheU5hbWUoKSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcl9lbWFpbCc6ICh1c2VyRW1haWwoKSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhfdG9rZW4nOiAodXNlckF1dGhUb2tlbiB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgJ2pzb24nOiBKU09OLnN0cmluZ2lmeShjbG9uYWJsZUlsbHVzdHJhdGlvbilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRpb24gbWV0aG9kIHNob3VsZCByZXR1cm4gZWl0aGVyIGEgcmVkaXJlY3QgVVJMIHRvIHRoZSBuZXcgaWxsdXN0cmF0aW9uLCBvciBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAvL2hpZGVNb2RhbFNjcmVlbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2F2ZUlsbHVzdHJhdGlvbigpOiBkb25lISB0ZXh0U3RhdHVzID0gJysgdGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBlcnJvcnMgb3IgbWFsZm9ybWVkIGRhdGEsIGlmIGFueVxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwLmVycm9yID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgY3JlYXRpbmcgdGhpcyBpbGx1c3RyYXRpb24uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KHJlc3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGludGVybmFsICd1cmwnIG9mIHRoZSBsaXZlIGlsbHVzdHJhdGlvbiB0byBtYXRjaCB3aGF0IHdhcyBhc3NpZ25lZFxuICAgICAgICAgICAgICAgICAgICAvLyAoQVBJIGVuc3VyZXMgdW5pcXVlbmVzcywgdHlwaWNhbGx5IGJ5IGluY3JlbWVudGluZyBkdXBsaWNhdGUgaWRzKVxuICAgICAgICAgICAgICAgICAgICAvLyBFWEFNUExFOiAgaHR0cHM6Ly9hcGkub3BlbnRyZWVvZmxpZmUub3JnL3YzL2lsbHVzdHJhdGlvbi9qaW1hbGxtYW4vbXktaWxsdXN0cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3NpZ25lZFVSTCA9IGRhdGEucmVzb3VyY2VfdXJsO1xuICAgICAgICAgICAgICAgICAgICBzdHlsaXN0LmlsbC5tZXRhZGF0YS51cmwoIGFzc2lnbmVkVVJMICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb21taXRTSEEgPSBkYXRhWydzaGEnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbW1pdFNIQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGlzdC5pbGwubWV0YWRhdGEuc2hhKG5ld0NvbW1pdFNIQSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkICd2ZXJzaW9ucycgb3IgJ21ldGFkYXRhLnZlcnNpb25zJyB0byByZWNvcmQgdGhlc2UgY29tbWl0cz9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiggZGF0YSwgdGV4dFN0YXR1cywganFYSFIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaGlkZU1vZGFsU2NyZWVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mKGpxWEhSLnJlc3BvbnNlVGV4dCkgIT09ICdzdHJpbmcnKSB8fCBqcVhIUi5yZXNwb25zZVRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwLmVycm9yID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgY3JlYXRpbmcgdGhpcyBpbGx1c3RyYXRpb24uIChObyBtb3JlIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZS4pJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AuZXJyb3IgPSAnU29ycnksIHRoZXJlIHdhcyBhbiBlcnJvciBjcmVhdGluZyB0aGlzIGlsbHVzdHJhdGlvbjpcXG5cXG4gJysganFYSFIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KHJlc3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCBkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUiApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gZW5kIG9mIGlmL2Vsc2UgKENSRUFURSB2cy4gVVBEQVRFKVxuICAgIH07XG5cbiAgICBhcmNoaXZlLmdlbmVyYXRlQXN5bmMoIHt0eXBlOlwiYmxvYlwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdyBwcm9ncmVzcyBhcyBkZW1vbnN0cmF0ZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vZXhhbXBsZXMvZG93bmxvYWRlci5odG1sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIG1ldGFkYXRhLnBlcmNlbnQudG9GaXhlZCgyKSArIFwiICUgY29tcGxldGVcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgIC50aGVuKCB1cGxvYWRJbGx1c3RyYXRpb25CbG9iLCAgIC8vIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsdXJlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0VSUk9SIGdlbmVyYXRpbmcgdGhpcyBaSVAgYXJjaGl2ZTpcXG4nKyBlcnIpO1xuICAgICAgICAgICAgICAgICAgfSApO1xufVxuXG5cbmZ1bmN0aW9uIGRlbGV0ZUlsbHVzdHJhdGlvbihpbGx1c3RyYXRpb25JRCwgY2FsbGJhY2spIHtcbiAgICAvLyAnY2FsbGJhY2snIHNob3VsZCBleHBlY3QgYSBzaW5nbGUgb2JqIHdpdGggJ2RhdGEnIG9yICdlcnJvcicgcHJvcGVydGllcylcbiAgICB2YXIgcmVzcCA9IHt9O1xuXG4gICAgaWYgKCF1c2VyQXV0aFRva2VuKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHNhdmUgd2l0aG91dCBhIHRva2VuOyBzdG9wIGFuZCBwcm9tcHQgZm9yIGxvZ2luXG4gICAgICAgIGxvZ2luVG9HaXRIdWIoKTtcbiAgICAgICAgcmVzcC5lcnJvciA9IFwiVXNlciBub3QgbG9nZ2VkIGludG8gR2l0SHViISBQcm9tcHRpbmcgZm9yIGxvZ2luIG5vdy5cIlxuICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaWxsdXN0cmF0aW9uSUQgfHwgdHlwZW9mKGlsbHVzdHJhdGlvbklEKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIGNsb2JiZXIgYW55dGhpbmcgb24gR2l0SHViXG4gICAgICAgIHJlc3AuZXJyb3IgPSBcImRlbGV0ZUlsbHVzdHJhdGlvbigpIG5lZWRzIGEgcHJvcGVyIGxvY2F0aW9uIHN0cmluZywgbm90IFwiKyBpbGx1c3RyYXRpb25JRCArXCIgPFwiKyB0eXBlb2YoaWxsdXN0cmF0aW9uSUQpICtcIj4hXCI7XG4gICAgICAgIGNhbGxiYWNrKHJlc3ApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBjaG9zZW4gaWxsdXN0cmF0aW9uXG4gICAgdmFyIGRlbGV0ZVVSTCA9IGRlbGV0ZUlsbHVzdHJhdGlvbl9ERUxFVEVfdXJsLnJlcGxhY2UoJ3tET0NfSUR9JywgaWxsdXN0cmF0aW9uSUQpO1xuICAgICQuYWpheCh7XG4gICAgICAgIGdsb2JhbDogZmFsc2UsICAvLyBzdXBwcmVzcyB3ZWIycHkncyBhZ2dyZXNzaXZlIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAvLyBjcm9zc2RvbWFpbjogdHJ1ZSxcbiAgICAgICAgLy8gY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICB1cmw6IGRlbGV0ZVVSTCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLy8gbWlzYyBpZGVudGlmeWluZyBpbmZvcm1hdGlvbiAoZm9yIGF1dGgpXG4gICAgICAgICAgICAnYXV0aG9yX25hbWUnOiAodXNlckRpc3BsYXlOYW1lKCkgfHwgXCJcIiksXG4gICAgICAgICAgICAnYXV0aG9yX2VtYWlsJzogKHVzZXJFbWFpbCgpIHx8IFwiXCIpLFxuICAgICAgICAgICAgJ2F1dGhfdG9rZW4nOiAodXNlckF1dGhUb2tlbiB8fCBcIlwiKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oIGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSICkge1xuICAgICAgICAgICAgLy8gVE9ETzogY3JlYXRpb24gbWV0aG9kIHNob3VsZCByZXR1cm4gPz8/IG9uIHN1Y2Nlc3MsIG9yIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vaGlkZU1vZGFsU2NyZWVuKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGVsZXRlSWxsdXN0cmF0aW9uKCk6IGRvbmUhIHRleHRTdGF0dXMgPSAnKyB0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgIC8vIHJlcG9ydCBlcnJvcnMgb3IgbWFsZm9ybWVkIGRhdGEsIGlmIGFueVxuICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIC8qIE5CIHRoZSBjYWxsYmFjayAoYmVsb3cpIHNob3VsZCBoYW5kbGUgYW55IGNsZWFudXAsIGlmIGUuZy4gd2UganVzdFxuICAgICAgICAgICAgICAgICAqIGRlbGV0ZWQgdGhlIGN1cnJlbnRseSBsb2FkZWQgaWxsdXN0cmF0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwLmVycm9yID0gXCJTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yIGRlbGV0aW5nIHRoaXMgaWxsdXN0cmF0aW9uLlwiO1xuICAgICAgICAgICAgICAgIGFsZXJ0KHJlc3AuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oIGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSICkge1xuICAgICAgICAgICAgLy9oaWRlTW9kYWxTY3JlZW4oKTtcbiAgICAgICAgICAgIGlmICgodHlwZW9mKGpxWEhSLnJlc3BvbnNlVGV4dCkgIT09ICdzdHJpbmcnKSB8fCBqcVhIUi5yZXNwb25zZVRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzcC5lcnJvciA9ICdTb3JyeSwgdGhlcmUgd2FzIGFuIGVycm9yIGRlbGV0aW5nIHRoaXMgaWxsdXN0cmF0aW9uLiAoTm8gbW9yZSBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUuKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3AuZXJyb3IgPSAnU29ycnksIHRoZXJlIHdhcyBhbiBlcnJvciBkZWxldGluZyB0aGlzIGlsbHVzdHJhdGlvbjpcXG5cXG4gJysganFYSFIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxlcnQocmVzcC5lcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigganFYSFIsIHRleHRTdGF0dXMgKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBHZXQgdXNlci1mcmllbmRseSBsaXN0IG9mIGF2YWlsYWJsZSBzb3VyY2UgZGF0YSBmb3IgdHJlZXMsIGV0Yy4/XG5cbmZ1bmN0aW9uIGdldFRyZWVTb3VyY2VMaXN0KGNhbGxiYWNrKSB7XG4gICAgLy8gJ2NhbGxiYWNrJyBzaG91bGQgZXhwZWN0IGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXMpXG4gICAgY2FsbGJhY2sobm90SW1wbGVtZW50ZWRSZXNwb25zZSk7XG59XG5mdW5jdGlvbiBnZXRUcmVlU291cmNlRGF0YShpZCwgY2FsbGJhY2spIHtcbiAgICAvLyAnY2FsbGJhY2snIHNob3VsZCBleHBlY3QgYSBzaW5nbGUgb2JqIHdpdGggJ2RhdGEnIG9yICdlcnJvcicgcHJvcGVydGllcylcbiAgICBjYWxsYmFjayhub3RJbXBsZW1lbnRlZFJlc3BvbnNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VwcGxlbWVudGFsRGF0YVNvdXJjZUxpc3QoaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gJ2NhbGxiYWNrJyBzaG91bGQgZXhwZWN0IGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXMpXG4gICAgY2FsbGJhY2sobm90SW1wbGVtZW50ZWRSZXNwb25zZSk7XG59XG5mdW5jdGlvbiBnZXRTdXBwbGVtZW50YWxEYXRhU291cmNlVmFsdWUoaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gJ2NhbGxiYWNrJyBzaG91bGQgZXhwZWN0IGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXMpXG4gICAgY2FsbGJhY2sobm90SW1wbGVtZW50ZWRSZXNwb25zZSk7XG59XG5cbmZ1bmN0aW9uIGdldE9ybmFtZW50U291cmNlTGlzdChpZCwgY2FsbGJhY2spIHtcbiAgICAvLyAnY2FsbGJhY2snIHNob3VsZCBleHBlY3QgYSBzaW5nbGUgb2JqIHdpdGggJ2RhdGEnIG9yICdlcnJvcicgcHJvcGVydGllcylcbiAgICBjYWxsYmFjayhub3RJbXBsZW1lbnRlZFJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIGdldE9ybmFtZW50U291cmNlVmFsdWUoaWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gJ2NhbGxiYWNrJyBzaG91bGQgZXhwZWN0IGEgc2luZ2xlIG9iaiB3aXRoICdkYXRhJyBvciAnZXJyb3InIHByb3BlcnRpZXMpXG4gICAgY2FsbGJhY2sobm90SW1wbGVtZW50ZWRSZXNwb25zZSk7XG59XG5cbi8vIEV4cG9zZSBzb21lIG1lbWJlcnMgdG8gb3V0c2lkZSBjb2RlIChlZywgS25vY2tvdXQgYmluZGluZ3MsIG9uQ2xpY2tcbi8vIGF0dHJpYnV0ZXMuLi4pXG52YXIgYXBpID0gW1xuICAgIC8vIGV4cGVjdGVkIEFQSSBmb3Igc3RvcmFnZSBiYWNrZW5kXG4gICAgJ2dldElsbHVzdHJhdGlvbkxpc3QnLFxuICAgICdsb2FkSWxsdXN0cmF0aW9uJyxcbiAgICAnc2F2ZUlsbHVzdHJhdGlvbicsXG4gICAgJ2RlbGV0ZUlsbHVzdHJhdGlvbicsXG4gICAgJ2dldERlZmF1bHRHaXRIdWJJbGx1c3RyYXRpb25JRCcsXG4gICAgJ2dldElsbHVzdHJhdGlvbklERnJvbVVSTCcsXG4gICAgJ3VzZXJIYXNTdG9yYWdlQWNjZXNzJyxcbiAgICAvLyBhdXRoIGluZm9ybWF0aW9uIChzcGVjaWZpYyB0byB0aGlzIGJhY2tlbmQ/KVxuICAgICd1c2VyRGlzcGxheU5hbWUnLFxuICAgICd1c2VyTG9naW4nLFxuICAgICd1c2VyRW1haWwnLFxuICAgIC8vJ3VzZXJBdXRoVG9rZW4nXG4gICAgJ2xvZ2luVG9HaXRIdWInLFxuICAgICd1c2VySXNMb2dnZWRJbnRvR2l0SHViJ1xuICAgIC8qIFRPRE86IEFkZCBwcm92aWRlcnMgZm9yIG1pbm9yIHR5cGVzP1xuICAgICdnZXRUcmVlU291cmNlTGlzdCcsXG4gICAgJ2dldFRyZWVTb3VyY2VEYXRhJyxcbiAgICAnZ2V0U3VwcGxlbWVudGFsRGF0YVNvdXJjZUxpc3QnLFxuICAgICdnZXRTdXBwbGVtZW50YWxEYXRhU291cmNlRGF0YScsXG4gICAgJ2dldE9ybmFtZW50U291cmNlTGlzdCcsXG4gICAgJ2dldE9ybmFtZW50U291cmNlRGF0YScsXG4gICAgICovXG5dO1xuJC5lYWNoKGFwaSwgZnVuY3Rpb24oaSwgbWV0aG9kTmFtZSkge1xuICAgIC8vIHBvcHVsYXRlIHRoZSBkZWZhdWx0ICdtb2R1bGUuZXhwb3J0cycgb2JqZWN0XG4gICAgZXhwb3J0c1sgbWV0aG9kTmFtZSBdID0gZXZhbCggbWV0aG9kTmFtZSApO1xufSk7XG4iLCIvKlxuICogSW4gdGhpcyBlZGl0b3IsIHdlIGdlbmVyYXRlIGEgZGVjbGFyYXRpdmUgVmVnYSBzcGVjIChhbmQgaXRzIGRvd25zdHJlYW0gZDNcbiAqIHZpc3VhbGl6YXRpb24pIGZyb20gYSBtb3JlIGRlc2NyaXB0aXZlIHNjZW5lLWdyYXBoIG1vZGVsLiBUaGlzIGNvcnJlc3BvbmRzXG4gKiBjbG9zZWx5IHdpdGggYSB3ZWIgVUkgdGhhdCdzIGJvdW5kIGFuZCBlbmFibGVkIHVzaW5nIEtub2Nrb3V0SlMuXG4gKi9cblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4vdGktdXRpbHMnKSxcbiAgICBqc3ppcCA9IHJlcXVpcmUoJ2pzemlwJyksXG4gICAgRmlsZVNhdmVyID0gcmVxdWlyZSgnZmlsZS1zYXZlcicpLFxuICAgIEJsb2IgPSByZXF1aXJlKCdibG9iLXBvbHlmaWxsJyksXG4gICAgbWQ1ID0gcmVxdWlyZSgnc3BhcmstbWQ1JyksXG4gICAgdmcgPSByZXF1aXJlKCd2ZWdhJyksXG4gICAgVHJlZUlsbHVzdHJhdG9yID0gcmVxdWlyZSgnLi9UcmVlSWxsdXN0cmF0b3IuanMnKSxcbiAgICBzdGFzaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdmcuZGF0YS5zdGFzaC5qcycpO1xuICAgIHBsdWNrVHJhbnNmb3JtID0gcmVxdWlyZSgnLi92Zy5kYXRhLnBsdWNrLmpzJyk7XG4gICAgbmV4c29uVHJhbnNmb3JtID0gcmVxdWlyZSgnLi92Zy5kYXRhLm5leHNvbi5qcycpO1xuICAgIHBoeWxvZ3JhbVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdmcuZGF0YS5waHlsb2dyYW0uanMnKTtcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLy8gZXhwb3NlIFRyZWVJbGx1c3RyYXRvciB0byBKUyBpbiB0aGUgbWFpbiBVSSBcbmdsb2JhbC5UcmVlSWxsdXN0cmF0b3IgPSBUcmVlSWxsdXN0cmF0b3I7XG5nbG9iYWwuJCA9ICQ7XG5cbi8vIHJlZ2lzdGVyIGN1c3RvbSB0cmFuc2Zvcm1zIHdpdGggdGhlIGluc3RhbGxlZCB2ZWdhXG52Zy50cmFuc2Zvcm1zWydzdGFzaCddID0gc3Rhc2hUcmFuc2Zvcm07XG52Zy50cmFuc2Zvcm1zWydwbHVjayddID0gcGx1Y2tUcmFuc2Zvcm07XG52Zy50cmFuc2Zvcm1zWyduZXhzb24nXSA9IG5leHNvblRyYW5zZm9ybTtcbnZnLnRyYW5zZm9ybXNbJ3BoeWxvZ3JhbSddID0gcGh5bG9ncmFtVHJhbnNmb3JtO1xuXG4vLyBwYXRjaCBtaXNzaW5nIEpTIGNvbnNvbGUgb24gc29tZSAodmVyeSkgb2xkIGJyb3dzZXJzXG5pZiAodHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUgPSB7XG4gICAgbG9nOiBmdW5jdGlvbihtc2cpIHt9LFxuICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge30sXG4gICAgZXJyb3I6IHdpbmRvdy5hbGVydFxufVxuXG4vLyBUZXN0IHF1ZXJ5LXN0cmluZyB2YXJpYWJsZXMsIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTE1ODMwMVxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBSZWdFeHAoJ1s/Jl0nICsgbmFtZSArICc9KFteJl0qKScpLmV4ZWMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgcmV0dXJuIG1hdGNoICYmIGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qIERldGVybWluZSB0aGUgY3VycmVudCBob3N0IGFwcGxpY2F0aW9uLCBzbyB3ZSBjYW4gYWRhcHQgdG8gdGhlIGFkdmFudGFnZXNcbiAqIGFuZCBsaW1pdGF0aW9ucyBvZiBlYWNoOlxuICogIC0gc3RvcmFnZSBvcHRpb25zIGFuZCByZXF1aXJlbWVudHNcbiAqICAgICAgLSBzbG90LSB2cy4gVVJMLWJhc2VkIHN0b3JhZ2VcbiAqICAgICAgLSBuYW1pbmcgcmVzdHJpY3Rpb25zICh1bmlxdWVuZXNzLCBldGMpXG4gKiAgLSBkYXRhIHNvdXJjZXMgYW5kIGZvcm1hdHMsIGUuZy5cbiAqICAgICAgLSB2YWx1ZXMgZnJvbSBhIHNlcnZlci1zaWRlIGtlcm5lbCBpbiBKdXB5dGVyXG4gKiAgICAgIC0gdXNlcidzIHJlc291cmNlcyBpbiBPcGVuVHJlZSByZXBvc2l0b3J5XG4gKiAgICAgIC0gc3BlY2lhbCBhZGFwdGVycy92YWxpZGF0b3JzIGZvciB0cmVlIGRhdGFcbiAqICAtIG9wdGlvbmFsIGZlYXR1cmVzIGFuZCBVSVxuICogIC0gYWRqdXN0bWVudHMgdG8gbGF5b3V0IGFuZCBzdHlsZVxuICpcbiAqIFRoZSBob3N0IGFwcGxpY2F0aW9uIHNob3VsZCBiZSBzcGVjaWZpZWQgb24gdGhlIHF1ZXJ5LXN0cmluZyBvZlxuICogJ3N0eWxpc3QuaHRtbCcsIGZvciBleGFtcGxlIFxuICogICAgICAuLi4vc3R5bGlzdC5odG1sP2hvc3RBcHBsaWNhdGlvbj1KVVBZVEVSX05PVEVCT09LXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHN0YW5kYWxvbmUgcGFnZSwgd2hpY2ggZGVwZW5kcyBlbnRpcmVseSBvbiBvdXRzaWRlXG4gKiB3ZWIgc2VydmljZXMgZm9yIGRhdGEgYW5kIHN0b3JhZ2UuXG4gKi9cbnZhciBob3N0QXBwbGljYXRpb24gPSBUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5TVEFOREFMT05FO1xuLy8gVmFsaWRhdGUgcmVjZWl2ZWQgaG9zdC1hcHAgc3RyaW5nIGFnYWluc3QgZW51bWVyYXRlZCB2YWx1ZXNcbiQuZWFjaChUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucywgZnVuY3Rpb24oaSwgdGVzdFZhbHVlKSB7XG4gICAgaWYgKGdldFBhcmFtZXRlckJ5TmFtZSgnaG9zdEFwcGxpY2F0aW9uJykgPT0gdGVzdFZhbHVlKSB7XG4gICAgICAgIGhvc3RBcHBsaWNhdGlvbiA9IHRlc3RWYWx1ZTtcbiAgICB9XG59KTtcbmNvbnNvbGUubG9nKFwiVHJlZSBJbGx1c3RyYXRvciBob3N0IGFwcGxpY2F0aW9uOiBcIisgaG9zdEFwcGxpY2F0aW9uKTtcblxuLy8gV2UnbGwgYXR0ZW1wdCB0byBkeW5hbWljYWxseSBsb2FkIGFwcHJvcHJpYXRlIHN0b3JhZ2UgYmFja2VuZHMgYW5kIG90aGVyIGNvbXBvbmVudHNcbnZhciBMT0NBTF9GSUxFU1lTVEVNID0gVHJlZUlsbHVzdHJhdG9yLnN0b3JhZ2VCYWNrZW5kcy5MT0NBTF9GSUxFU1lTVEVNLFxuICAgIEpVUFlURVJfTk9URUJPT0sgPSBUcmVlSWxsdXN0cmF0b3Iuc3RvcmFnZUJhY2tlbmRzLkpVUFlURVJfTk9URUJPT0ssXG4gICAgR0lUSFVCX1JFUE8gPSBUcmVlSWxsdXN0cmF0b3Iuc3RvcmFnZUJhY2tlbmRzLkdJVEhVQl9SRVBPO1xudmFyIHN0b3JhZ2UgPSB7fTtcbnN0b3JhZ2VbIExPQ0FMX0ZJTEVTWVNURU0gXSA9IHJlcXVpcmUoJy4vc3RvcmFnZS9sb2NhbC1maWxlc3lzdGVtLmpzJyk7XG5zdG9yYWdlWyBKVVBZVEVSX05PVEVCT09LIF0gPSByZXF1aXJlKCcuL3N0b3JhZ2UvaXB5dGhvbi1ub3RlYm9vay1icmlkZ2UuanMnKTtcbnN0b3JhZ2VbIEdJVEhVQl9SRVBPIF0gICAgICA9IHJlcXVpcmUoJy4vc3RvcmFnZS9uYW1lc3BhY2VkLXVybHMuanMnKTtcblxuc3RvcmFnZS5sYXN0U2F2ZSA9IHtcbiAgICBiYWNrZW5kOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgIGxvY2F0aW9uOiBrby5vYnNlcnZhYmxlKG51bGwpXG59O1xuLyogRWFjaCB0aW1lIHRoZSB1c2VyIHN1Y2Vzc2Z1bGx5IHNhdmVzIHRoZSBjdXJyZW50IGlsbHVzdHJhdGlvbiwgc3Rhc2ggdGhlXG4gKiBzdG9yYWdlIGJhY2tlbmQgYW5kIGFueSBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gTk9URSB0aGF0IGxvY2F0aW9uIHZhbHVlc1xuICogYXJlIGRpZmZlcmVudCBmb3IgZWFjaCBzdG9yYWdlIGJhY2tlbmQuXG4gKlxuICogTE9DQUxfRklMRVNZU1RFTSBvbmx5IGtub3dzIHRoZSBwcm9wb3NlZCBmaWxlbmFtZSwgKm5vdCogdGhlIG9uZVxuICogYWN0dWFsbHkgYXBwbGllZCBvciBpdHMgbG9jYXRpb24gaW4gdGhlIGZpbGVzeXN0ZW06XG4gKiAgICAgIGJhY2tlbmQ6IFRyZWVJbGx1c3RyYXRvci5zdG9yYWdlQmFja2VuZHMuTE9DQUxfRklMRVNZU1RFTSxcbiAqICAgICAgbG9jYXRpb246ICd0cmVlcy1hYm91dC1iZWVzLUxBVEVTVC56aXAnXG4gKiAgICAgT1IgaWYgdGhhdCBwcm9wb3NlZCBuYW1lIGlzIG1vb3QsIGVtcHR5IG9yIHVucmVsaWFibGU6XG4gKiAgICAgIGxvY2F0aW9uOiAnVU5LTk9XTidcbiAqXG4gKiBKVVBZVEVSX05PVEVCT09LIGlzIHNpbXBseSBhbiBpbnRlZ2VyIHBvaW50aW5nIHRvIHRoZSBuLXRoIHN0b3JhZ2Ugc2xvdDpcbiAqICAgICAgYmFja2VuZDogVHJlZUlsbHVzdHJhdG9yLnN0b3JhZ2VCYWNrZW5kcy5KVVBZVEVSX05PVEVCT09LLFxuICogICAgICBsb2NhdGlvbjogNFxuICpcbiAqIEdJVEhVQl9SRVBPIGtub3dzIHRoZSBmaW5hbCBhc3NpZ25lZCBJbGx1c3RyYXRpb24gSUQgYXNzaWduZWQgYnkgdGhlXG4gKiBwaHlsZXN5c3RlbSBBUEk6XG4gKiAgICAgIGJhY2tlbmQ6IFRyZWVJbGx1c3RyYXRvci5zdG9yYWdlQmFja2VuZHMuR0lUSFVCX1JFUE8sXG4gKiAgICAgIGxvY2F0aW9uOiAnL2ppbWFsbG1hbi90cmVlcy1hYm91dC1iZWVzJ1xuICpcbiAqIEJvdGggc2hvdWxkIHJlc2V0IHRvIG51bGwgaWYgd2UgYWJhbmRvbiBhbiBpbGx1c3RyYXRpb24gb3Igb3BlbiBhIG5ldyBvbmVcbiAqIChvciBpZiBhbiBhdHRlbXB0ZWQgc2F2ZSBmYWlscz8pOlxuICogICAgICBiYWNrZW5kID0gbnVsbDtcbiAqICAgICAgbG9jYXRpb24gPSBudWxsO1xuICovXG5mdW5jdGlvbiB1cGRhdGVMYXN0U2F2ZWRJbmZvKCBiYWNrZW5kLCBsb2NhdGlvbiApIHtcbiAgICBzdG9yYWdlLmxhc3RTYXZlLmJhY2tlbmQoYmFja2VuZCk7XG4gICAgc3RvcmFnZS5sYXN0U2F2ZS5sb2NhdGlvbihsb2NhdGlvbik7XG4gICAgY29uc29sZS53YXJuKCdVUERBVEVEIGxhc3RTYXZlLCBiYWNrZW5kOiAnKyBzdG9yYWdlLmxhc3RTYXZlLmJhY2tlbmQoKSArJywgbG9jYXRpb246ICcrIHN0b3JhZ2UubGFzdFNhdmUubG9jYXRpb24oKSk7XG59XG5mdW5jdGlvbiBjbGVhckxhc3RTYXZlZEluZm8oKSB7XG4gICAgc3RvcmFnZS5sYXN0U2F2ZS5iYWNrZW5kKG51bGwpO1xuICAgIHN0b3JhZ2UubGFzdFNhdmUubG9jYXRpb24obnVsbCk7XG4gICAgY29uc29sZS53YXJuKCdDTEVBUkVEIGxhc3RTYXZlLCBiYWNrZW5kOiAnKyBzdG9yYWdlLmxhc3RTYXZlLmJhY2tlbmQoKSArJywgbG9jYXRpb246ICcrIHN0b3JhZ2UubGFzdFNhdmUubG9jYXRpb24oKSk7XG59XG5cbi8qIE9mZmVyIGFsbCBzdHVkaWVzIGFuZCB0cmVlcyBmcm9tIHRoZSBPcGVuIFRyZWUgb2YgTGlmZSByZXBvc2l0b3J5LFxuICogcGx1cyBvdGhlciBzb3VyY2VzIGFuZCB0cmVlIGZvcm1hdHMuIFdlJ2xsIG1ha2UgYSB0cmVlIG9mIEtub2Nrb3V0XG4gKiBvYnNlcnZhYmxlcywgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIChhbmQgdGhlIFVJKSBvbi10aGUtZmx5LlxuICpcbiAqIFRoaXMgc2hvdWxkIGFkYXB0IHRvIHRoZSBjdXJyZW50IGhvc3QgYXBwbGljYXRpb24sIGZvciBleGFtcGxlOlxuICogIC0gXCJsb2NhbFwiIHZhcmlhYmxlcyBmcm9tIGFuIGlQeXRob24gbm90ZWJvb2sgKGluY2wuIHNlcnZlci1zaWRlIGtlcm5lbClcbiAqICAtIHNpbWlsYXIgXCJsb2NhbFwiIGRhdGEgaW4gYW4gQXJib3Igd29ya2Zsb3dcbiAqICAtIHRoZSBjdXJyZW50IHVzZXIncyBzdHVkaWVzL3RyZWVzL2Zhdm9yaXRlcyBpbiBPcGVuVHJlZVxuICpcbiAqIE4uQi4gVGhlIGN1cnJlbnQgZGlzcGxheSBsb2dpYyB3aWxsIGhpZGUgYW55IGdyb3VwIHRoYXQgaGFzIG5vIGNoaWxkcmVuLlxuICovXG52YXIgYXZhaWxhYmxlVHJlZXMgPSBrby5tYXBwaW5nLmZyb21KUyhbXG4gICAge1xuICAgICAgICBuYW1lOiBcIlBsYWNlaG9sZGVyIHRyZWVcIiwgXG4gICAgICAgIHVybDogJy4vcGxhY2Vob2xkZXItdHJlZS5qc29uJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkRhdGEgdXNlZCBpbiB0aGlzIGlsbHVzdHJhdGlvblwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQSBsaXN0IG9mIFwiZnJpZW5kbHlcIiBsYWJlbHMgaWRlbnRpZnlpbmcgZXhpc3Rpbmcgc291cmNlIGRhdGFcbiAgICAgICAgICAgICAqIGFscmVhZHkgZm91bmQgaW4gdGhpcyBpbGx1c3RyYXRpb24uIEZpbHRlciBieSB0eXBlL2Zvcm1hdCwgYmFzZWRcbiAgICAgICAgICAgICAqIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgKGUuZy4gdHJlZXMgdnMuIHRyYWl0cyk/XG4gICAgICAgICAgICAgKiBFeGFtcGxlcyB3b3VsZCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJUcmFpdCBkYXRhIDEuMmVcIixcbiAgICAgICAgICAgICAgICB1cmw6ICcuL2lucHV0cy9UcmFpdCBkYXRhIDEuMmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiU2Vjb25kIChzcGFyc2UpIHBhcnNpbW9ueSB0cmVlc1wiLFxuICAgICAgICAgICAgICAgIHVybDogJy4vaW5wdXRzL1NlY29uZCAoc3BhcnNlKSBwYXJzaW1vbnkgdHJlZXMnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlRyYWl0IGRhdGEgMS4yZVwiLFxuICAgICAgICAgICAgICAgIHVybDogJy4vaW5wdXRzL1RyYWl0IGRhdGEgMS4yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJTZWNvbmQgKHNwYXJzZSkgcGFyc2ltb255IHRyZWVzXCIsXG4gICAgICAgICAgICAgICAgdXJsOiAnLi9pbnB1dHMvU2Vjb25kIChzcGFyc2UpIHBhcnNpbW9ueSB0cmVlcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkZyb20gbm90ZWJvb2sga2VybmVsXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBBIGxpc3Qgb2YgdmFyaWFibGVzLCBlYWNoIG1hcmtlZCB3aXRoIGl0cyBsYW5ndWFnZS9rZXJuZWwgKi9cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkV4YW1wbGVzXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJUdW92aWxhLCAyMDEzXCIsIFxuICAgICAgICAgICAgICAgIHVybDogYnVpbGRTdHVkeUZldGNoVVJMKCAnMjM4MCcgKVxuICAgICAgICAgICAgICAgIC8qIE5PVEUgdGhhdCB0aGlzIG9uZSBoYXMgdHdvIHRyZWVzIVxuICAgICAgICAgICAgICAgIHRyZWVJRDogJ3RyZWU0OTk5JyxcbiAgICAgICAgICAgICAgICBvdHVzSUQ6ICd0cmVlNTAwMCdcbiAgICAgICAgICAgICAgICAqLyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJKYW5zZW4sIDIwMDdcIiwgXG4gICAgICAgICAgICAgICAgdXJsOiBidWlsZFN0dWR5RmV0Y2hVUkwoICdwZ18xMCcgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkRyZXcgQlQsIDIwMTRcIiwgXG4gICAgICAgICAgICAgICAgdXJsOiBidWlsZFN0dWR5RmV0Y2hVUkwoICdwZ18yODIxJyApXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJFbnRlciBvciB1cGxvYWQgdHJlZSBkYXRhXCIsXG4gICAgICAgIC8qXG4gICAgICAgIG5hbWU6IFwiRW50ZXIgb3IgdXBsb2FkIHRyZWUgZGF0YSBhcy4uLlwiLFxuICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiTmV3aWNrIHN0cmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiTmV3aWNrIHN0cmluZyB3aXRoIGV4dHJhIGRhdGFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIk5FWFVTXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIk9uIHRoZSB3ZWJcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkVudGVyIE9wZW5UcmVlIHN0dWR5IGFuZCB0cmVlIGlkc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRW50ZXIgVVJMIHRvIE5leFNPTiAxLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkVudGVyIFVSTCB0byBhIEdpdEh1YiBnaXN0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbl0pO1xuXG52YXIgYXZhaWxhYmxlRGF0YVNvdXJjZXMgPSBrby5tYXBwaW5nLmZyb21KUyhbXG4gICAge1xuICAgICAgICBuYW1lOiBcIlBsYWNlaG9sZGVyIGRhdGFzZXRcIiwgXG4gICAgICAgIHVybDogJy4vcGxhY2Vob2xkZXItZGF0YXNldC5qc29uJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkRhdGEgdXNlZCBpbiB0aGlzIGlsbHVzdHJhdGlvblwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQSBsaXN0IG9mIFwiZnJpZW5kbHlcIiBsYWJlbHMgaWRlbnRpZnlpbmcgZXhpc3Rpbmcgc291cmNlIGRhdGFcbiAgICAgICAgICAgICAqIGFscmVhZHkgZm91bmQgaW4gdGhpcyBpbGx1c3RyYXRpb24uIEZpbHRlciBieSB0eXBlL2Zvcm1hdCwgYmFzZWRcbiAgICAgICAgICAgICAqIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgKGUuZy4gdHJlZXMgdnMuIHRyYWl0cyk/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkZPT1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQkFSXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkZyb20gbm90ZWJvb2sga2VybmVsXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBBIGxpc3Qgb2YgdmFyaWFibGVzLCBlYWNoIG1hcmtlZCB3aXRoIGl0cyBsYW5ndWFnZS9rZXJuZWwgKi9cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkVudGVyIG9yIHVwbG9hZCBkYXRhXCJcbiAgICAgICAgLypcbiAgICAgICAgbmFtZTogXCJFbnRlciBvciB1cGxvYWQgZGF0YSBhcy4uLlwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29tbWEtc2VwYXJhdGVkIHZhbHVlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiVGFiLXNlcGFyYXRlZCB2YWx1ZXNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXRjLlxuICAgICAgICBdXG4gICAgICAgICovXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiT24gdGhlIHdlYlwiLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRW50ZXIgVVJMIHRvIGRhdGEgZmlsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRW50ZXIgVVJMIHRvIGEgR2l0SHViIGdpc3RcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZUF2YWlsYWJsZVRyZWVzKCkge1xuICAgIC8qIEJ1aWxkIGFuIGFwcHJvcHJpYXRlIChuZXN0ZWQpIGxpc3Qgb2YgY2hvaWNlcywgYmFzZWQgb24gdGhlIGN1cnJlbnQgaG9zdFxuICAgICAqIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogTi5CLiB0aGlzIHNob3VsZCBiZSByZXBlYXRhYmxlIHRvIHVwZGF0ZSB0cmVlIHNvdXJjZXMgYXMgdGhleSBjb21lIGFuZCBnby5cbiAgICAgKi9cbiAgICBzd2l0Y2goaG9zdEFwcGxpY2F0aW9uKSB7XG4gICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLmhvc3RBcHBsaWNhdGlvbnMuSlVQWVRFUl9OT1RFQk9PSzpcbiAgICAgICAgICAgIC8qIEZldGNoIG5vdGVib29rIHZhcmlhYmxlcyBmcm9tIHRoZSBzZXJ2ZXItc2lkZSBrZXJuZWwsIHZpYVxuICAgICAgICAgICAgICogSnVweXRlcidzIEpTIEFQSS5cbiAgICAgICAgICAgICAqIFRPRE86IENhbiB3ZSBkZWFsIHdpdGggbXVsdGlwbGUga2VybmVscyBpbiB0aGUgbmV3ZXN0IG5vdGVib29rcz9cbiAgICAgICAgICAgICAqIFRPRE86IENhbiB3ZSBkaXN0aW5ndWlzaCBSLXZpYS1QeXRob24gZnJvbSB0aGUgUHl0aG9uIGtlcm5lbD9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcmFnZVsgSlVQWVRFUl9OT1RFQk9PSyBdLmdldFRyZWVTb3VyY2VMaXN0KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdGVib29rU291cmNlTGlzdCA9IGtvLnV0aWxzLmFycmF5Rmlyc3QoYXZhaWxhYmxlVHJlZXMoKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lKCkgPT09ICdGcm9tIG5vdGVib29rIGtlcm5lbCc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm90ZWJvb2tTb3VyY2VMaXN0LmNoaWxkcmVuLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICgnZGF0YScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGxhaW4gdGhlIGVtcHR5IGxpc3QsIHN1Z2dlc3QgYSByZW1lZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVib29rU291cmNlTGlzdC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKFwiTm8gdmFyaWFibGVzIGZvdW5kISBSdW4gY29kZSBjZWxscyBhbmQgdHJ5IGFnYWluLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKSAgLy8gaW5mby1vbmx5IChub3QgY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGFueSB2YXJpYWJsZXMgcmV0dXJuZWQgYW5kIHRoZWlyIHNvdXJjZSBrZXJuZWwvbGFuZ1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uKGksIG5iVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmJWYXIgaXMgYSB0d28taXRlbSBsaXN0IGxpa2UgWydIaSBtb20nLCAnc3RyJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmJWYXJOYW1lID0gbmJWYXJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5iVmFyVHlwZSA9IG5iVmFyWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYlZhckxhbmd1YWdlID0gbmJWYXJbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZWJvb2tTb3VyY2VMaXN0LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKG5iVmFyTmFtZSArXCIgKFwiKyBuYlZhckxhbmd1YWdlICtcIiBcIisgbmJWYXJUeXBlICtcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbDoga28ub2JzZXJ2YWJsZShuYlZhckxhbmd1YWdlKSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmZXJzIHRvIGtlcm5lbC1pZCB2cy4gbGFuZ3VhZ2U/IGVnICdweXRob24yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyB0aGUgZXJyb3IgaW4gdGhlIHNvdXJjZS1saXN0LCBhbmQgc3VnZ2VzdCBhIHJlbWVkeVxuICAgICAgICAgICAgICAgICAgICBub3RlYm9va1NvdXJjZUxpc3QuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKFwiRVJST1IgbG9hZGluZyBub3RlYm9vayB2YWx1ZXMuIFJ1biBjb2RlIGNlbGxzIGFuZCB0cnkgYWdhaW4uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSkgIC8vIGluZm8tb25seSAobm90IGNsaWNrYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5TVEFOREFMT05FOlxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkbyBoZXJlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8qIENvbnZlcnNpb24gdXRpbGl0aWVzIGZvciBwaHlzaWNhbCB1bml0c1xuICovXG52YXIgY21fcGVyX2luY2ggPSAyLjU0O1xuZnVuY3Rpb24gaW5jaGVzVG9DZW50aW1ldGVycyggaW5jaGVzICkge1xuICAgIHJldHVybiBpbmNoZXMgKiBjbV9wZXJfaW5jaDtcbn1cbmZ1bmN0aW9uIGNlbnRpbWV0ZXJzVG9JbmNoZXMoIGNtICkge1xuICAgIHJldHVybiBjbSAvIGNtX3Blcl9pbmNoO1xufVxuXG52YXIgcHRfcGVyX2luY2ggPSA3Mi4wO1xuZnVuY3Rpb24gaW5jaGVzVG9Qb2ludHMoIGluY2hlcywgcHBpICkge1xuICAgIHJldHVybiBpbmNoZXMgKiBwdF9wZXJfaW5jaDtcbn1cbmZ1bmN0aW9uIHBvaW50c1RvSW5jaGVzKCBwdCwgcHBpICkge1xuICAgIHJldHVybiBwdCAvIHB0X3Blcl9pbmNoO1xufVxuXG52YXIgcHRfcGVyX2NtID0gcHRfcGVyX2luY2ggLyBjbV9wZXJfaW5jaDtcbmZ1bmN0aW9uIGNlbnRpbWV0ZXJzVG9Qb2ludHMoIGNtLCBwcGkgKSB7XG4gICAgcmV0dXJuIGNtICogcHRfcGVyX2NtO1xufVxuZnVuY3Rpb24gcG9pbnRzVG9DZW50aW1ldGVycyggcHQsIHBwaSApIHtcbiAgICByZXR1cm4gcHQgLyBwdF9wZXJfY207XG59XG5cbmZ1bmN0aW9uIHBpeGVsc1RvSW5jaGVzKCBweCwgcHBpICkge1xuICAgIHJldHVybiBweCAvIHBwaTtcbn1cbmZ1bmN0aW9uIGluY2hlc1RvUGl4ZWxzKCBpbmNoZXMsIHBwaSApIHtcbiAgICByZXR1cm4gaW5jaGVzICogcHBpO1xufVxuZnVuY3Rpb24gcGl4ZWxzVG9DZW50aW1ldGVycyggcHgsIHBwaSApIHtcbiAgICByZXR1cm4gaW5jaGVzVG9DZW50aW1ldGVycyhweCAvIHBwaSk7XG59XG5mdW5jdGlvbiBjZW50aW1ldGVyc1RvUGl4ZWxzKCBjbSwgcHBpICkge1xuICAgIHJldHVybiBjZW50aW1ldGVyc1RvSW5jaGVzKCBjbSApICogcHBpO1xufVxuXG5mdW5jdGlvbiBwaXhlbHNUb1BoeXNpY2FsVW5pdHMoIHB4LCBwcGkgKSB7XG4gICAgaWYgKGlsbC5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gVHJlZUlsbHVzdHJhdG9yLnVuaXRzLklOQ0hFUykge1xuICAgICAgICByZXR1cm4gcGl4ZWxzVG9JbmNoZXMoIHB4LCBwcGkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGl4ZWxzVG9DZW50aW1ldGVycyggcHgsIHBwaSApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBoeXNpY2FsVW5pdHNUb1BpeGVscyggdW5pdHMsIHBwaSApIHtcbiAgICBpZiAoaWxsLnN0eWxlLnByaW50U2l6ZS51bml0cygpID09PSBUcmVlSWxsdXN0cmF0b3IudW5pdHMuSU5DSEVTKSB7XG4gICAgICAgIHJldHVybiBpbmNoZXNUb1BpeGVscyggdW5pdHMsIHBwaSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjZW50aW1ldGVyc1RvUGl4ZWxzKCB1bml0cywgcHBpICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQaHlzaWNhbFVuaXRTdWZmaXgoKSB7XG4gICAgaWYgKHBoeXNpY2FsVW5pdHMgPT09ICdJTkNIRVMnKSB7XG4gICAgICAgIHJldHVybiAnaW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnY20nO1xuICAgIH1cbn1cblxuLy8gcnVsZXIgbWV0cmljcyAoYWRqdXN0IGZvciBsZWdpYmlsaXR5KVxudmFyIHJ1bGVyV2lkdGggPSAyNTsgIC8vIHB4XG5cbi8qIE1haW50YWluIGEgZmV3IGluZGVwZW5kZW50IHNjYWxlcyAoaW4gcGl4ZWxzL2luY2gpIHRvIHN1cHBvcnQgdGhlXG4gKiBpbGx1c3RyYXRpb24gZWRpdG9yLiBUaGVzZSB3aWxsIHNvbWV0aW1lcyBhbGlnbiwgYnV0IGl0J3Mgdml0YWwgdGhhdCB3ZSBjYW5cbiAqIGRpc2NyaW1pbmF0ZSBiZXR3ZWVuIHRoZW0gYXMgZWFjaCBpcyBzdWl0ZWQgZm9yIGEgZGlmZmVyZW50IHB1cnBvc2VzLlxuICovXG52YXIgYnJvd3Nlcl9wcGk7ICAvLyBTVkcgcmVzb2x1dGlvbiBpbiBjdXJyZW50IGJyb3dzZXIgKG5vdCByZWxpYWJsZSEpXG52YXIgaW50ZXJuYWxfcHBpID0gOTA7ICAvLyBTVkcgZGVmYXVsdCBwaXhlbHMgcGVyIGluY2ggKGNhbiBiZSBtb2RpZmllZCB0byBzdWl0IHByaW50aW5nIGRldmljZSlcbnZhciBkaXNwbGF5X3BwaSA9IGludGVybmFsX3BwaTsgIC8vIHBpeGVscyBwZXIgaW5jaCBhdCBjdXJyZW50IG1hZ25pZmljYXRpb24gKHpvb20gbGV2ZWwpXG5cbi8qIFRyYWNrIHRoZSB2YWx1ZXMgdXNlZCBmb3Igb3VyIHZpZXdwb3J0IChvdmVyYWxsIHNpemUsIG1hcmdpbnMgdnMuIGlsbHVzdHJhdGlvbilcbiAqIGZvciBlYXN5IHJlLXVzZSBpbiBydWxlcnMsIGV0Yy4gRm9yIGJhY2tncm91bmQsIHNlZSBTVkcncyB2aWV3Qm94IGRvY3M6IFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAqL1xudmFyIHZpZXdib3ggPSB7XG4gICAgJ3gnOiAwLFxuICAgICd5JzogMCxcbiAgICAnd2lkdGgnOiAwLFxuICAgICdoZWlnaHQnOiAwLFxufVxuZnVuY3Rpb24gdXBkYXRlVmlld3BvcnRWaWV3Ym94KCR2aWV3cG9ydCkge1xuICAgIC8qIEFkanVzdCB0aGUgbWFpbiBWRyB2aWV3Qm94IGFzIG5lZWRlZCB0byBtYXRjaCB0aGUgY3VycmVudCBpbGx1c3RyYXRpb25cbiAgICAgKiBzaXplIGFuZCBjaG9zZW4gbWFnbmlmaWNhdGlvbi4gVGhlIHJlc3VsdCBzaG91bGQgYmUgdGhhdCBzY3JvbGxiYXJzIG9mZmVyIFxuICAgICAqIGFjY2VzcyB0byBhbGwgU1ZHIGVsZW1lbnRzIChpbiBvciBvdXQgb2YgdGhlIHByaW50ZWQgYXJlYSksIHdoaWxlIHRoZSB1c2VyXG4gICAgICogaXMgZnJlZSB0byBjaG9vc2UgYXJiaXRyYXJ5IGxldmVscyBvZiBtYWduaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIC8vIFRPRE86IG1haW50YWluIHRoZSBjdXJyZW50IGNlbnRlciBwb2ludCwgYnV0IHN1cnJlbmRlciBlbXB0eSB0ZXJyaXRvcnlcbiAgICBpZiAoISR2aWV3cG9ydCkge1xuICAgICAgICAkdmlld3BvcnQgPSAkKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYVwiKTtcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBsYXRlc3QgRElWIHNpemUrcHJvcG9ydGlvbnMuIChUaGVzZSBjYW4gY2hhbmdlIGlmIHRoZVxuICAgICAqIHVzZXIgdG9nZ2xlcyBzY3JvbGxiYXJzIG9yIHJlc2l6ZXMgdGhlIHN1cnJvdW5kaW5nIHBhZ2UuKSBUaGlzIGlzIHRoZVxuICAgICAqIG5ldyAqbWluaW11bSogc2l6ZSBmb3Igb3VyIFNWRyBlbGVtZW50LCB0byBhdm9pZCBnYXBzIGluIHRoZSB2aWV3cG9ydCFcbiAgICAgKi9cbiAgICB2YXIgdnBEaXYgPSAkdmlld3BvcnRbMF07XG4gICAgdmFyIGRpdldpZHRoID0gdnBEaXYuY2xpZW50V2lkdGg7XG4gICAgdmFyIGRpdkhlaWdodCA9IHZwRGl2LmNsaWVudEhlaWdodDtcbiAgICB2YXIgZGl2UHJvcG9ydGlvbnMgPSBkaXZXaWR0aCAvIGRpdkhlaWdodDtcblxuICAgIC8qIFdoYXQgbXVzdCBiZSBpbiB0aGUgdmlld2JveD8gQWxsIGlsbHVzdHJhdGlvbiBlbGVtZW50cyAoc28gd2UgY2FuIHNjcm9sbFxuICAgICAqIHRvIHRoZW0pLCBwbHVzIGFueSBwYWRkaW5nIG5lZWRlZCAoYXQgY3VycmVudCBtYWduaWZpY2F0aW9uKSB0byBmaWxsIHRoZVxuICAgICAqIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIHZhciBlYm94ID0gZ2V0SW5jbHVzaXZlSWxsdXN0cmF0aW9uQm91bmRpbmdCb3goKTtcbiAgICAvLyB0aGlzIGlzIHRoZSBhcmVhIHdpdGggYWxsIGlsbHVzdHJhdGlvbiBlbGVtZW50c1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IGVib3gueCArIChlYm94LndpZHRoIC8gMiksXG4gICAgICAgIHk6IGVib3gueSArIChlYm94LmhlaWdodCAvIDIpXG4gICAgfTtcblxuICAgIC8vIGNvcHkgdG8gb3VyIHBlcnNpc3RlbnQgdmlld2JveFxuICAgIGZvciAodmFyIHByb3AgaW4gZWJveCkge1xuICAgICAgICB2aWV3Ym94W3Byb3BdID0gZWJveFtwcm9wXTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcG9ydGlvbmFsV2lkdGggPSBNYXRoLnJvdW5kKHZpZXdib3gud2lkdGggKiB2aWV3cG9ydE1hZ25pZmljYXRpb24pO1xuICAgIHZhciBwcm9wb3J0aW9uYWxIZWlnaHQgPSBNYXRoLnJvdW5kKHZpZXdib3guaGVpZ2h0ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcblxuICAgIC8vIGNvbXBhcmUgaXRzIHByb3BvcnRpb25zIHRvIG91ciAqbmV3KiB2aWV3cG9ydDsgcGFkIGFzIG5lZWRlZCB0byBmaWxsIHNwYWNlXG4gICAgdmFyIGJib3ggPSB2aWV3Ym94O1xuICAgIGlmIChwcm9wb3J0aW9uYWxXaWR0aCA8IGRpdldpZHRoKSB7XG4gICAgICAgIC8vIGRpdiBpcyB3aWRlciwgcGFkIHZpZXdib3ggd2lkdGggdG8gbWF0Y2hcbiAgICAgICAgdmFyIGFkanVzdGVkV2lkdGggPSBkaXZXaWR0aCAvIHZpZXdwb3J0TWFnbmlmaWNhdGlvbjtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBhZGp1c3RlZFdpZHRoIC0gdmlld2JveC53aWR0aDtcbiAgICAgICAgdmlld2JveC53aWR0aCA9IGFkanVzdGVkV2lkdGg7XG4gICAgICAgIHZpZXdib3gueCAtPSAoZXh0cmFXaWR0aCAvIDIpO1xuICAgIH0gXG4gICAgaWYgKHByb3BvcnRpb25hbEhlaWdodCA8IGRpdkhlaWdodCkge1xuICAgICAgICAvLyBkaXYgaXMgdGFsbGVyLCBwYWQgdmlld2JveCBoZWlnaHQgdG8gbWF0Y2hcbiAgICAgICAgdmFyIGFkanVzdGVkSGVpZ2h0ID0gZGl2SGVpZ2h0IC8gdmlld3BvcnRNYWduaWZpY2F0aW9uO1xuICAgICAgICB2YXIgZXh0cmFIZWlnaHQgPSBhZGp1c3RlZEhlaWdodCAtIHZpZXdib3guaGVpZ2h0O1xuICAgICAgICB2aWV3Ym94LmhlaWdodCA9IGFkanVzdGVkSGVpZ2h0O1xuICAgICAgICB2aWV3Ym94LnkgLT0gKGV4dHJhSGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgLy8gbW92ZSBvdXIgYmFja2dyb3VuZCB0byB0aGUgbmV3IHZpZXdwb3J0IHRvcC1sZWZ0IGNvcm5lclxuICAgIGQzLnNlbGVjdEFsbCgnI3ZpZXdwb3J0LWJhY2tncm91bmQsICN2aWV3cG9ydC1ib3VuZHMnKVxuICAgICAgICAuYXR0cigneCcsIHZpZXdib3gueClcbiAgICAgICAgLmF0dHIoJ3knLCB2aWV3Ym94LnkpO1xuXG4gICAgLy8gVXBkYXRlIHBoeXNpY2FsIHNpemUgb2YgU1ZHIGVsZW1lbnQgYmFzZWQgb24gbmV3IHZpZXdib3ggYW5kIG1hZ25pZmljYXRpb25cbiAgICBwcm9wb3J0aW9uYWxXaWR0aCA9IE1hdGgucm91bmQodmlld2JveC53aWR0aCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgcHJvcG9ydGlvbmFsSGVpZ2h0ID0gTWF0aC5yb3VuZCh2aWV3Ym94LmhlaWdodCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgdmFyIHN2Z1dpZHRoID0gcHJvcG9ydGlvbmFsV2lkdGg7XG4gICAgdmFyIHN2Z0hlaWdodCA9IHByb3BvcnRpb25hbEhlaWdodDtcblxuICAgIC8vIE5PVEUgdGhhdCB3ZSBuZWVkIHRvIHVzZSBlbC5zZXRBdHRyaWJ1dGUgdG8ga2VlcCBtaXhlZC1jYXNlIGF0dHJpYnV0ZSBuYW1lc1xuICAgIHZhciBzdmcgPSAkdmlld3BvcnQuZmluZCgnc3ZnJylbMF07XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UncmUgYXQgbGVhc3QgZmlsbGluZyB0aGUgYXZhaWxhYmxlIHZpZXdwb3J0IERJVlxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc3ZnV2lkdGgpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN2Z0hlaWdodCk7XG5cbiAgICAvLyBUT0RPOiBudWRnZSBzY3JvbGxiYXJzIHRvIGhvbGQgYSBzdGVhZHkgdmlldz9cblxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAodmlld2JveC54ICsnICcrIHZpZXdib3gueSArJyAnKyB2aWV3Ym94LndpZHRoICsnICcrdmlld2JveC5oZWlnaHQpKTtcbiAgICAkKCcjdmlld2JveC1pbmRpY2F0b3InKS5odG1sKHN2Zy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSk7XG4gICAgJCgnI21hZy1pbmRpY2F0b3InKS5odG1sKHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgJCgnI3N2Zy13aWR0aC1pbmRpY2F0b3InKS5odG1sKHN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgICQoJyNzdmctaGVpZ2h0LWluZGljYXRvcicpLmh0bWwoc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXG4gICAgLypcbiAgICBjb25zb2xlLmxvZygnT0xEIGRpdiB3OiAnKyBzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICBjb25zb2xlLmxvZygnICB2aWV3Ym94LndpZHRoOiAnKyB2aWV3Ym94LndpZHRoKTtcbiAgICBjb25zb2xlLmxvZygnICAqIG1hZ25pZmljYXRpb246ICcrIHZpZXdwb3J0TWFnbmlmaWNhdGlvbik7XG4gICAgY29uc29sZS5sb2coJyAgTkVXIGRpdiB3OiAnKyB2aWV3Ym94LndpZHRoICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBJTlQgZGl2IHc6ICcrIE1hdGgucm91bmQodmlld2JveC53aWR0aCAqIHZpZXdwb3J0TWFnbmlmaWNhdGlvbikpO1xuICAgIGNvbnNvbGUubG9nKCdPTEQgZGl2IGg6ICcrIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcbiAgICBjb25zb2xlLmxvZygnICB2aWV3Ym94LmhlaWdodDogJysgdmlld2JveC5oZWlnaHQpO1xuICAgIGNvbnNvbGUubG9nKCcgICogbWFnbmlmaWNhdGlvbjogJysgdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBORVcgZGl2IGg6ICcrIHZpZXdib3guaGVpZ2h0ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICBjb25zb2xlLmxvZygnICBJTlQgZGl2IGg6ICcrIE1hdGgucm91bmQodmlld2JveC5oZWlnaHQgKiB2aWV3cG9ydE1hZ25pZmljYXRpb24pKTtcbiAgICAqL1xufVxuXG4vKiBUT0RPOiBMb2FkIGF2YWlsYWJsZSBzdHlsZXMgZnJvbSBhbiBleHRlcm5hbCBzb3VyY2Ugb3Igc3RvcmUuIFRoZXNlIG1pZ2h0IGJlXG4gKiBzaGFyZWQgb3IgcHJpdmF0ZS4gU3R5bGVzIHNob3VsZCBpbmNsdWRlIG5hbWUgYW5kIGRlc2NyaXB0aW9uLCBkZWZhdWx0cyBmb3JcbiAqIG1vc3QgdmlzdWFsIHByb3BlcnRpZXMsIGFuZCBjb25zdHJhaW50cyAoc29mdCBvciBoYXJkKSB0aGF0IHdlIGNhbiB0ZXN0XG4gKiBhZ2FpbnN0LlxuICovXG52YXIgYXZhaWxhYmxlU3R5bGVHdWlkZXMgPSBudWxsO1xuZnVuY3Rpb24gc2hvd1N0eWxlR3VpZGVQaWNrZXIoKSB7XG4gICAgLy8gZm9yIG5vdywgbG9hZCBmcm9tIGEgc3RhdGljIEpTT04gZmlsZSBcbiAgICB2YXIgbG9va3VwVVJMID0gJy4vc3R5bGUtZ3VpZGVzLmpzb24nO1xuXG4gICAgLy9zaG93TW9kYWxTY3JlZW4oXCJHYXRoZXJpbmcgc3R5bGUgZ3VpZGVzLi4uXCIsIHtTSE9XX0JVU1lfQkFSOnRydWV9KTtcbiAgICAkLmFqYXgoe1xuICAgICAgICBnbG9iYWw6IGZhbHNlLCAgLy8gc3VwcHJlc3Mgd2ViMnB5J3MgYWdncmVzc2l2ZSBlcnJvciBoYW5kbGluZz9cbiAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIC8vIGNyb3NzZG9tYWluOiB0cnVlLFxuICAgICAgICAvLyBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIHVybDogbG9va3VwVVJMLFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCB0ZXh0U3RhdHVzICkge1xuICAgICAgICAgICAgLy9oaWRlTW9kYWxTY3JlZW4oKTtcbiAgICAgICAgICAgIGlmICgodGV4dFN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSAmJiAodGV4dFN0YXR1cyAhPT0gJ3BhcnNlcmVycm9yJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1NvcnJ5LCB0aGVyZSB3YXMgYW4gZXJyb3IgbG9va2luZyB1cCB0aGUgYXZhaWxhYmxlIHN0eWxlIGd1aWRlcy4gKFNlZSBKUyBjb25zb2xlIGZvciBkZXRhaWxzLiknO1xuICAgICAgICAgICAgICAgIGFsZXJ0KGVyck1zZyk7IFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJNc2cgKydcXG5cXG50ZXh0U3RhdHVzPScrIHRleHRTdGF0dXMgKydcXG5cXG4nKyBqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIC8vc2hvd0Vycm9yTWVzc2FnZShlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgcmF3IHJlc3BvbnNlIHRvIEpTT05cbiAgICAgICAgICAgIHZhciByZXN1bHRzSlNPTiA9ICQucGFyc2VKU09OKGpxWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0c0pTT04ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ05vIHN0eWxlIGd1aWRlcyBmb3VuZCEnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU3R5bGVHdWlkZXMgPSByZXN1bHRzSlNPTjtcbiAgICAgICAgICAgICAgICB2YXIgJGNob29zZXIgPSAkKCcjc3R5bGVndWlkZS1jaG9vc2VyJyk7XG4gICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHZhciAkY3VycmVudE5hbWVEaXNwbGF5ID0gJGNob29zZXIuZmluZCgnI2N1cnJlbnQtc3R5bGVndWlkZS1uYW1lJyk7XG4gICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5odG1sKCBpbGwuc3R5bGVHdWlkZS5uYW1lKCkgKTtcbiAgICAgICAgICAgICAgICBpZiAoaWxsLnN0eWxlR3VpZGUudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwaXZvdCBiYXNlZCBvbiB2ZXJzaW9uIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGlsbC5zdHlsZUd1aWRlLnZlcnNpb24udHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci52ZXJzaW9uVHlwZXMuQ0hFQ0tTVU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5hcHBlbmQoJzxlbSBjbGFzcz1cInZlcnNpb25cIj4mbmJzcDsgJmx0OycrIGlsbC5zdHlsZUd1aWRlLnZlcnNpb24udmFsdWUoKSArJyZndDs8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IudmVyc2lvblR5cGVzLlRJTUVTVEFNUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3VycmVudE5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyAgYXMgb2YgJysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnZlcnNpb25UeXBlcy5TRU1BTlRJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3VycmVudE5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyB2JysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnROYW1lRGlzcGxheS5hcHBlbmQoJzxlbSBjbGFzcz1cInZlcnNpb25cIj5Vbmtub3duIHZlcnNpb24gdHlwZTogJysgaWxsLnN0eWxlR3VpZGUudmVyc2lvbi52YWx1ZSgpICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcjY3VycmVudC1zdHlsZWd1aWRlLXNvdXJjZScpLmh0bWwoIGlsbC5zdHlsZUd1aWRlU291cmNlSFRNTCgpICk7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGF2YWlsYWJsZVN0eWxlR3VpZGVzLCBmdW5jdGlvbihpLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHRoZSBpbGxsdXN0cmF0aW9uJ3MgY3VycmVudCBzdHlsZSBndWlkZT8gY29tcGFyZSBuYW1lLCBzb3VyY2UsIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXNzaWduZWRTdHlsZUd1aWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzVmVyc2lvbk9mQXNzaWduZWRTdHlsZUd1aWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2gubmFtZSA9PT0gaWxsLnN0eWxlR3VpZGUubmFtZSgpKSAmJiAobWF0Y2guc291cmNlLnZhbHVlID09PSBpbGwuc3R5bGVHdWlkZS5zb3VyY2UudmFsdWUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXNzaWduZWRTdHlsZUd1aWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC52ZXJzaW9uLnZhbHVlICE9PSBpbGwuc3R5bGVHdWlkZS52ZXJzaW9uLnZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzVmVyc2lvbk9mQXNzaWduZWRTdHlsZUd1aWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgJG1hdGNoSW5mbyA9ICQoJzxkaXYgY2xhc3M9XCJtYXRjaFwiPjxpbWcgY2xhc3M9XCJ0aHVtYm5haWxcIj48L2ltZz48ZGl2IGNsYXNzPVwibmFtZVwiPjwvZGl2PjxkaXY+U291cmNlOiA8c3BhbiBjbGFzcz1cInNvdXJjZVwiPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVwiZGVzY3JpcHRpb25cIj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aHVtYiA9ICRtYXRjaEluZm8uZmluZCgnLnRodW1ibmFpbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3NpZ25lZFN0eWxlR3VpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uYWRkQ2xhc3MoJ2Fzc2lnbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2aW91c1ZlcnNpb25PZkFzc2lnbmVkU3R5bGVHdWlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uYWRkQ2xhc3MoJ3ByZXZpb3VzLXZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWIuYWZ0ZXIoJzxhIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIGhyZWY9XCIjXCIgb25jbGljaz1cInN0eWxpc3QuYXBwbHlDaG9zZW5TdHlsZUd1aWRlKHRoaXMpOyByZXR1cm4gZmFsc2U7XCI+VXBkYXRlPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWIuYWZ0ZXIoJzxhIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbCBkaXNhYmxlZFwiIGhyZWY9XCIjXCIgb25jbGljaz1cImFsZXJ0KFxcJ1RoaXMgc3R5bGUgZ3VpZGUgaXMgYWxyZWFkeSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IGlsbHVzdHJhdGlvbi5cXCcpOyByZXR1cm4gZmFsc2U7XCI+QXNzaWduZWQ8L2E+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2guY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aHVtYi5hZnRlcignPGEgY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgaHJlZj1cIiNcIiBvbmNsaWNrPVwic3R5bGlzdC5hcHBseUNob3NlblN0eWxlR3VpZGUodGhpcyk7IHJldHVybiBmYWxzZTtcIj5BcHBseTwvYT4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aHVtYi5hZnRlcignPGEgY2xhc3M9XCJidG4gYnRuLXNtYWxsIGRpc2FibGVkXCIgaHJlZj1cIiNcIiBvbmNsaWNrPVwiYWxlcnQoXFwnU29ycnksIHRoaXMgaXMganVzdCBhbiBlbXB0eSBleGFtcGxlLlxcJyk7IHJldHVybiBmYWxzZTtcIj5FeGFtcGxlPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8uZmluZCgnLnRodW1ibmFpbCcpLmF0dHIoJ3NyYycsIG1hdGNoLnRodW1ibmFpbFNyYyB8fCAnLi9icm9rZW4ucG5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkbmFtZURpc3BsYXkgPSAkbWF0Y2hJbmZvLmZpbmQoJy5uYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICRuYW1lRGlzcGxheS5odG1sKG1hdGNoLm5hbWUgfHwgJzxlbT5ObyBuYW1lIGZvdW5kPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpdm90IGJhc2VkIG9uIHZlcnNpb24gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG1hdGNoLnZlcnNpb24udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnZlcnNpb25UeXBlcy5DSEVDS1NVTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPiZuYnNwOyAmbHQ7JysgbWF0Y2gudmVyc2lvbi52YWx1ZSArJyZndDs8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci52ZXJzaW9uVHlwZXMuVElNRVNUQU1QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbmFtZURpc3BsYXkuYXBwZW5kKCc8ZW0gY2xhc3M9XCJ2ZXJzaW9uXCI+Jm5ic3A7ICBhcyBvZiAnKyBtYXRjaC52ZXJzaW9uLnZhbHVlICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IudmVyc2lvblR5cGVzLlNFTUFOVElDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbmFtZURpc3BsYXkuYXBwZW5kKCc8ZW0gY2xhc3M9XCJ2ZXJzaW9uXCI+Jm5ic3A7IHYnKyBtYXRjaC52ZXJzaW9uLnZhbHVlICsnPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWVEaXNwbGF5LmFwcGVuZCgnPGVtIGNsYXNzPVwidmVyc2lvblwiPlVua25vd24gdmVyc2lvbiB0eXBlOiAnKyBtYXRjaC5zb3VyY2UudHlwZSArJzwvZW0+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyICRzb3VyY2VEaXNwbGF5ID0gJG1hdGNoSW5mby5maW5kKCcuc291cmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpdm90IGJhc2VkIG9uIHNvdXJjZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2gobWF0Y2guc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci5kYXRhU291cmNlVHlwZXMuQlVJTFRfSU46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzb3VyY2VEaXNwbGF5Lmh0bWwoJzxzdHJvbmc+QnVpbHQtaW48L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyZWVJbGx1c3RyYXRvci5kYXRhU291cmNlVHlwZXMuVVJMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc291cmNlRGlzcGxheS5odG1sKCc8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiJysgbWF0Y2guc291cmNlLnZhbHVlICsnXCI+JysgbWF0Y2guc291cmNlLnZhbHVlICsnPC9hPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc291cmNlRGlzcGxheS5odG1sKCc8ZW0+VW5rbm93biBzb3VyY2UgdHlwZTogJysgbWF0Y2guc291cmNlLnR5cGUgKyc8L2VtPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNvdXJjZURpc3BsYXkuaHRtbCgnPGVtPk5vIHNvdXJjZSBmb3VuZDwvZW0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJG1hdGNoSW5mby5maW5kKCcuZGVzY3JpcHRpb24nKS5odG1sKCBtYXRjaC5kZXNjcmlwdGlvbiB8fCAnPGVtPk5vIGRlc2NyaXB0aW9uIGZvdW5kPC9lbT4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgdW5pcXVlIGtleSB0byBkZXRlcm1pbmUgdGhlIGNob3NlbiBzdHlsZSBndWlkZSBsYXRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2dLZXkgPSBtYXRjaC5uYW1lICsnfCcrIChtYXRjaC52ZXJzaW9uID8gbWF0Y2gudmVyc2lvbi52YWx1ZSA6IFwiXCIpICsnfCcrIChtYXRjaC5zb3VyY2UgPyBtYXRjaC5zb3VyY2UudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgJG1hdGNoSW5mby5hcHBlbmQoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgY2xhc3M9XCJtYXRjaC1rZXlcIiB2YWx1ZT1cIicrIHNnS2V5ICsnXCIgLz4nKTtcbiAgICAgICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5hcHBlbmQoJG1hdGNoSW5mbyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGNob29zZXIub2ZmKCdzaG93bicpLm9uKCdzaG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaXplIHNjcm9sbGluZyBsaXN0IHRvIGZpdCBpbiB0aGUgY3VycmVudCBET0ktbG9va3VwIHBvcHVwIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGNob29zZXIgPSAkKCcjc3R5bGVndWlkZS1jaG9vc2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzTGlzdEhlaWdodCA9ICRjaG9vc2VyLmZpbmQoJy5tb2RhbC1ib2R5JykuaGVpZ2h0KCkgLSAkY2hvb3Nlci5maW5kKCcuYmVmb3JlLW1hdGNoZXMnKS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm91dGVySGVpZ2h0KHJlc3VsdHNMaXN0SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcuZm91bmQtbWF0Y2hlcycpLmNzcygndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICRjaG9vc2VyLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyogR2VuZXJhbCBzdXBwb3J0IGZvciBkaXJlY3QtbWFuaXB1bGF0aW9uIG9wcyAoZXNwLiB0byB0cmFjayBkcmFnZ2luZyB3aXRoIHRoZSBtb3VzZSkgKi9cbnZhciBkcmFnSGFuZGxlID0gbnVsbCwgIC8vIHRoZSBoYW5kbGUgKEhUTUwvU1ZHIGVsZW1lbnQpIGJlaW5nIGRyYWdnZWQsIGlmIGFueVxuICAgIGRyYWdIYW5kbGVOYW1lID0gbnVsbDtcbiAgICBkcmFnU3RhcnRIYW5kbGVMb2MgPSBudWxsLCAgLy8gcmVwbGFjZSB3aXRoIHt4OjxOdW1iZXI+LCB5OjxOdW1iZXI+fSwgaW4gc2NyZWVuIHB4OyByZXNldCB0byBudWxsIHdoZW4gZG9uZVxuICAgIGRyYWdFbGVtZW50ID0gbnVsbCwgLy8gdGhlIElsbHVzdHJhdGlvbiBlbGVtZW50IChlZywgSWxsdXN0cmF0ZWRUcmVlKSBhZmZlY3RlZCwgaWYgYW55XG4gICAgZHJhZ1N0YXJ0RWxlbWVudFByb3BzID0gbnVsbCwgLy8gcmVsYXRlZCBwcm9wZXJ0aWVzIG9mIHRoZSB0YXJnZXQgZWxlbWVudCAoWFkgY29vcmRzLCBhbmdsZXMsIGV0Yy4pXG4gICAgZHJhZ0N1cnJlbnRIYW5kbGVEZWx0YSA9IG51bGw7ICAvLyBjdW11bGF0aXZlIGNoYW5nZSBpbiBYL1ksIGluIHNjcmVlbiBweDsgc2FtZSBmb3JtYXQgYXMgZHJhZ1N0YXJ0SGFuZGxlTG9jIGFib3ZlXG5cbmZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoIGV2ZW50ICkge1xuICAgIC8qIEluaXRpYXRlIHNlbnNpYmxlIGRyYWdnaW5nIGJlaGF2aW9yIGZvciB0aGUgY3VycmVudCBoYW5kbGUgYW5kIHRhcmdldFxuICAgICAqIGVsZW1lbnQuICBTZWUgKndoaWNoKiBob3RzcG90IHRoaXMgaXMgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgYmVoYXZpb3Igd2l0aFxuICAgICAqIHRoZSBjdXJyZW50IHRyZWUuIEtleSBkZWNpc2lvbnMgd2lsbCBwZXJzaXN0IGluIHRoZSB2YXJzIGRlZmluZWQgYWJvdmUuXG4gICAgICovXG4gICAgdmFyICRob3RzcG90ID0gJCh0aGlzKS5pcygncGF0aCcpID8gJCh0aGlzKSA6ICQodGhpcykuZmluZCgncGF0aCcpO1xuICAgIGRyYWdIYW5kbGUgPSAkaG90c3BvdFswXTtcbiAgICBkcmFnSGFuZGxlTmFtZSA9ICQodGhpcykuaXMoJy50cmVlLWhvdHNwb3QnKSA/ICdob3RzcG90JyA6IGQzLnNlbGVjdCh0aGlzKS5kYXR1bSgpLm5hbWU7XG4gICAgLy8gRmV0Y2ggYW5kIGV4YW1pbmUgdGhlIHJlbGF0ZWQgaWxsdXN0cmF0aW9uIGVsZW1lbnRcbiAgICB2YXIgJGVsZW1lbnRHcm91cCA9ICRob3RzcG90LmNsb3Nlc3QoJ2cubWFyay1ncm91cFtjbGFzcyo9dHJlZS1dLCBnLm1hcmstZ3JvdXBbY2xhc3MqPWRhdGFzZXQtXSwgZy5tYXJrLWdyb3VwW2NsYXNzKj1vcm5hbWVudC1dJyk7XG4gICAgdmFyIGVsZW1lbnRJRCA9ICRlbGVtZW50R3JvdXAuYXR0cignY2xhc3MnKS5zcGxpdCgvXFxzKy8pWzFdO1xuICAgIHNob3dBY2NvcmRpb25QYW5lbEZvckVsZW1lbnQoIGVsZW1lbnRJRCApO1xuICAgIGRyYWdFbGVtZW50ID0gc3R5bGlzdC5pbGwuZ2V0RWxlbWVudEJ5SUQoIGVsZW1lbnRJRCApO1xuICAgIC8vIE9uIHRoZSBmaXJzdCBtb3VzZW1vdmUsIHdlJ2xsIHN0YXNoIHRoZSBlbGVtZW50J3Mgc3RhcnRpbmcgcHJvcGVydGllcyAoaW4gaWxsdXN0cmF0aW9uIHVuaXRzKVxuICAgIC8vL2NvbnNvbGUubG9nKFwiPj4gU1RBUlQgRFJBR0dJTkcgaGFuZGxlIFtcIisgZHJhZ0hhbmRsZU5hbWUgK1wiXS4uLlwiKTtcbiAgICAvLyBUcmFjayBsb2NhdGlvbnMgKnJlbGF0aXZlKiB0byB0aGUgdmlld3BvcnQsIHNvIHdlIGNhbiBkcmFnICphbmQqIHNjcm9sbCBhcyBuZWVkZWQuXG4gICAgdmFyICRzY3JvbGxpbmdWaWV3cG9ydCA9ICQoXCIjdml6LW91dGVyLWZyYW1lXCIpLmZpbmQoJ2Rpdi52ZWdhJyk7XG4gICAgZHJhZ1N0YXJ0SGFuZGxlTG9jID0gZ2V0SWxsdXN0cmF0aW9uTW91c2VMb2MoZXZlbnQsICRzY3JvbGxpbmdWaWV3cG9ydCk7XG5cbiAgICAvKiBURVNUIHVwZGF0aW5nIGhhbmRsZXMgZnJvbSBzdG9yZWQgZ2VuZXJhdG9yc1xuICAgIGlmIChkcmFnSGFuZGxlKSB7XG4gICAgICAgIGlmIChkcmFnSGFuZGxlTmFtZSA9PT0gJ2hvdHNwb3QnKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGVudGlyZSBob3RzcG90IHNoYXBlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImhvdHNwb3QgZCBCRUZPUkU6XCIrIGQzLnNlbGVjdChkcmFnSGFuZGxlKS5hdHRyKCdkJykpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KGRyYWdIYW5kbGUpLmF0dHIoJ2QnLCBwaHlsb2dyYW1UcmFuc2Zvcm0uaG90c3BvdEdlbmVyYXRvcigpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaG90c3BvdCBkIEFGVEVSOlwiKyBkMy5zZWxlY3QoZHJhZ0hhbmRsZSkuYXR0cignZCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBqdXN0IHRoZSBwb3NpdGlvbnMgb2YgYWxsIFxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGRyYWdIYW5kbGUgZm91bmQhIEhvdyBjYW4gdGhpcyBiZT9cIik7XG4gICAgICAgIGRlYnVnZ2VyO1xuICAgIH1cbiAgICAgKi9cbn1cblxuZnVuY3Rpb24gc3RvcERyYWdnaW5nKCBjYWxsYmFjayApIHtcbiAgICBpZiAodHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvL2NhbGxiYWNrKGRyYWdIYW5kbGUsIGRyYWdFbGVtZW50LCAuLi4gKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZHJhZ0hhbmRsZSA9IG51bGw7XG4gICAgZHJhZ0hhbmRsZU5hbWUgPSBudWxsO1xuICAgIGRyYWdFbGVtZW50ID0gbnVsbDtcbiAgICBkcmFnU3RhcnRIYW5kbGVMb2MgPSBudWxsO1xuICAgIGRyYWdTdGFydEVsZW1lbnRQcm9wcyA9IG51bGw7XG4gICAgZHJhZ0N1cnJlbnRIYW5kbGVEZWx0YSA9IG51bGw7XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICQoJ2JvZHknKS5vbihcIm1vdXNldXAgY2xpY2sgbW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBpZiAoZHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgc3RvcERyYWdnaW5nKHJlZnJlc2hWaXopO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgJCgnYm9keScpLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIGlmIChkcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICAvKiBDaGVjayB0YXJnZXQgZWxlbWVudCdzIHR5cGUgYW5kIHN1Yi10eXBlIChlZywgYSBjaXJjdWxhciB0cmVlKSBhbmRcbiAgICAgICAgICAgICAqIHRoZSBhY3RpdmUgaGFuZGxlIG5hbWUuIFRoZXNlIHdpbGwgZGljdGF0ZSB0aGUgZHJhZ2dpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgICAqIGFuZCBpbml0aWFsaXplIGRyYWdTdGFydEVsZW1lbnRQcm9wcyBpZiBpdCdzIG51bGwgb3IgZW1wdHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciAkaGFuZGxlID0gJChkcmFnSGFuZGxlKTtcbiAgICAgICAgICAgIHZhciAkaGFuZGxlc0dyb3VwID0gJGhhbmRsZS5jbG9zZXN0KCdnLm1hcmstZ3JvdXAuaGFuZGxlcycpO1xuICAgICAgICAgICAgLy8gVHJhY2sgbG9jYXRpb25zICpyZWxhdGl2ZSogdG8gdGhlIHZpZXdwb3J0LCBzbyB3ZSBjYW4gZHJhZyAqYW5kKiBzY3JvbGwgYXMgbmVlZGVkLlxuICAgICAgICAgICAgdmFyICRzY3JvbGxpbmdWaWV3cG9ydCA9ICQoXCIjdml6LW91dGVyLWZyYW1lXCIpLmZpbmQoJ2Rpdi52ZWdhJyk7XG4gICAgICAgICAgICB2YXIgbW91c2VMb2MgPSBnZXRJbGx1c3RyYXRpb25Nb3VzZUxvYyhldmVudCwgJHNjcm9sbGluZ1ZpZXdwb3J0KTtcbiAgICAgICAgICAgIGRyYWdDdXJyZW50SGFuZGxlRGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogKG1vdXNlTG9jLnggLSBkcmFnU3RhcnRIYW5kbGVMb2MueCksXG4gICAgICAgICAgICAgICAgeTogKG1vdXNlTG9jLnkgLSBkcmFnU3RhcnRIYW5kbGVMb2MueSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYWdFbGVtZW50IGluc3RhbmNlb2YgVHJlZUlsbHVzdHJhdG9yLklsbHVzdHJhdGVkVHJlZSkge1xuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBiZWhhdmlvciBieSBzcGVjaWZpYyBoYW5kbGVzIGFuZCAocGVyaGFwcykgdHJlZSBsYXlvdXRzXG4gICAgICAgICAgICAgICAgc3dpdGNoKGRyYWdIYW5kbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hvdHNwb3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhZyB0byBtb3ZlICh0cmFuc2xhdGUpIHRoZSBlbnRpcmUgdHJlZSBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRFbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnU3RhcnRFbGVtZW50UHJvcHMgPSB7IHg6IGRyYWdFbGVtZW50LnJvb3RYKCksIHk6IGRyYWdFbGVtZW50LnJvb3RZKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFVwZGF0ZSB0aGUgZWxlbWVudCdzIHJvb3RYIGFuZCByb290WSBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogTi5CLiB0aGlzIHdpbGwgdXBkYXRlIHRoZSB2aXNpYmxlIFVJLCBidXQgbm90IHRoZSB2aWV3cG9ydCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGb3Igbm93LCB0aGlzIGlzIGEgZGlyZWN0IHRyYW5zbGF0aW9uIG9mIGhhbmRsZSBtb3Rpb24gdG8gZWxlbWVudCBtb3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUT0RPOiBVc2UgY29uc3RyYWludHMgdG8gZW5mb3JjZSBtaW4uIHNpemVzLCBldGMuIChieSB0d2Vha2luZyBpdHMgcGh5c2ljYWxSb290WC9ZIGluc3RlYWQ/KVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0VsZW1lbnRUb1ggPSBkcmFnU3RhcnRFbGVtZW50UHJvcHMueCArIGRyYWdDdXJyZW50SGFuZGxlRGVsdGEueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRWxlbWVudFRvWSA9IGRyYWdTdGFydEVsZW1lbnRQcm9wcy55ICsgZHJhZ0N1cnJlbnRIYW5kbGVEZWx0YS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcGh5c2ljYWxYID0gc3R5bGlzdC5waXhlbHNUb1BoeXNpY2FsVW5pdHMoZHJhZ1RvWCwgc3R5bGlzdC5kaXNwbGF5X3BwaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudC5yb290WCggZHJhZ0VsZW1lbnRUb1ggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LnJvb3RZKCBkcmFnRWxlbWVudFRvWSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSAqYWxsKiBoYW5kbGVzLCBub3QganVzdCB0aGUgbWFpbiBob3RzcG90IChubyBuZWVkIHRvIHJlZHJhdyBvciBmdXJ0aGVyIGFkanVzdCB0aGVzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRoYW5kbGVzR3JvdXAuYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIrIGRyYWdDdXJyZW50SGFuZGxlRGVsdGEueCArXCIsXCIrIGRyYWdDdXJyZW50SGFuZGxlRGVsdGEueSArXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIGhhbmRsZXMgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3IgYmFzZWQgb24gdHJlZSBsYXlvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChkcmFnRWxlbWVudC5sYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnRyZWVMYXlvdXRzLlRSSUFOR0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJlZUlsbHVzdHJhdG9yLnRyZWVMYXlvdXRzLlJFQ1RBTkdMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWxsIHZlcnRleCBoYW5kbGVzIHNjYWxlIHRoZSB0cmVlIChyZWxhdGl2ZSB0byB0aGUgcm9vdCBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBOLkIuIHRoYXQgd2UgcGF5IGNsb3NlIGF0dGVudGlvbiB0byB0aGUgKmN1cnJlbnQqIGV4dGVudHMgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHZpZXdwb3J0LCBzaW5jZSB0aGUgcmVjdGFuZ3VsYXIgbGF5b3V0IGhhcyBhIGJvdW5kaW5nIGJveCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRlcGVuZHMgb24gdGhlIHN0cnVjdHVyZSBhbmQgYnJhbmNoaW5nIHBhdHRlcm5zIG9mIGVhY2ggdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRFbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydEVsZW1lbnRQcm9wcyA9IHsgcm9vdFg6IGRyYWdFbGVtZW50LnJvb3RYKCksIHJvb3RZOiBkcmFnRWxlbWVudC5yb290WSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZHJhZ0VsZW1lbnQud2lkdGgoKSwgaGVpZ2h0OiBkcmFnRWxlbWVudC5oZWlnaHQoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY2tvbiBuZXcgd2lkdGggYW5kIGhlaWdodCBhcyBhIHJhdGlvIHZzLiB0aGUgb3JpZ2luYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQYXJ0aWFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRQYXJ0aWFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0aWFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFydGlhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RvdGFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUb3RhbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydGlhbFdpZHRoID0gTWF0aC5hYnMobW91c2VMb2MueCAtIGRyYWdTdGFydEVsZW1lbnRQcm9wcy5yb290WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBhcnRpYWxXaWR0aCA9IE1hdGguYWJzKGRyYWdTdGFydEhhbmRsZUxvYy54IC0gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLnJvb3RYKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlID0gbmV3UGFydGlhbFdpZHRoIC8gb2xkUGFydGlhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUb3RhbFdpZHRoID0gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLndpZHRoICogeFNjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY2tvbiBwcm9wb3J0aW9uYWwgc2hhcmUgb2Ygd2lkdGggZm9yIHRoaXMgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxIZWlnaHQgPSBNYXRoLmFicyhtb3VzZUxvYy55IC0gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLnJvb3RZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFydGlhbEhlaWdodCA9IE1hdGguYWJzKGRyYWdTdGFydEhhbmRsZUxvYy55IC0gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLnJvb3RZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVNjYWxlID0gbmV3UGFydGlhbEhlaWdodCAvIG9sZFBhcnRpYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RvdGFsSGVpZ2h0ID0gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLmhlaWdodCAqIHlTY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUT0RPOiBSZXN0cmljdCB0byBtaW4uIGRpbWVuc2lvbnMsIE9SIGhhbmRsZSBjcm9zc2luZyB0aGUgb3JpZ2luIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgLSBpZiB0aGV5IHN3YXAgdGhlIHR3byB2ZXJ0ZXggaGFuZGxlcywgdGhleSBzaG91bGQgc3dpdGNoIHByb3BvcnRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgLSBpZiB0aGV5IHBhc3MgdGhlIHJvb3Qgbm9kZSwgXCJmbGlwXCIgdGhlIHRyZWUncyB0aXBzQWxpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIj4+PiB0aXBzIG9uIHRoZSBcIisgZHJhZ0VsZW1lbnQudGlwc0FsaWdubWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGRyYWdFbGVtZW50LnRpcHNBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdSSUdIVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCT1RUT00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRyZWUsIHN1YmplY3QgdG8gYW55IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LmNvbnN0cmFpbmVkV2lkdGgoIG5ld1RvdGFsV2lkdGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQuY29uc3RyYWluZWRIZWlnaHQoIG5ld1RvdGFsSGVpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlcmUgdGhlIG5ldyB2YWx1ZXMgYWNjZXB0ZWQ/IChBbGxvdyBmb3IgbWlub3Igc2xpcHBhZ2UgaGVyZS4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbkJvdW5kcyA9IChNYXRoLmFicyhkcmFnRWxlbWVudC53aWR0aCgpIC0gbmV3VG90YWxXaWR0aCkgPCAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5hYnMoZHJhZ0VsZW1lbnQuaGVpZ2h0KCkgLSBuZXdUb3RhbEhlaWdodCkgPCAyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZXMgdXNlZCBmb3IgdGhlIGhvdHNwb3Qgc2hvdWxkIHJlZmxlY3QgYW55IGFjdGl2ZSBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWluZWRYU2NhbGUgPSBkcmFnRWxlbWVudC53aWR0aCgpIC8gZHJhZ1N0YXJ0RWxlbWVudFByb3BzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWluZWRZU2NhbGUgPSBkcmFnRWxlbWVudC5oZWlnaHQoKSAvIGRyYWdTdGFydEVsZW1lbnRQcm9wcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVXBkYXRlIGhvdHNwb3QgYW5kIGhhbmRsZSBwb3NpdGlvbnMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgdGhlIG1haW4gaG90c3BvdCB0byBtYXRjaCB0aGUgcmF0aW9zIG9mIG9sZCB2cy4gbmV3Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaG90c3BvdCA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnRyZWUtaG90c3BvdCBwYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRob3RzcG90LmF0dHIoJ3RyYW5zZm9ybScsIFwic2NhbGUoXCIrIGNvbnN0cmFpbmVkWFNjYWxlICtcIixcIisgY29uc3RyYWluZWRZU2NhbGUgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGhpZGUgaXRzIGJvcmRlciAoYmVhdXNlIHNjYWxpbmcgc3Ryb2tlLXdpZHRoIGlzIHVnbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRob3RzcG90LmNzcygnc3Ryb2tlLW9wYWNpdHknLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5Cb3VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRob3RzcG90LnJlbW92ZUF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaG90c3BvdC5hdHRyKCdjbGFzcycsICdvdXQtb2YtYm91bmRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIG1vdmUgdGhlIHZlcnRleCBoYW5kbGVzIHRvIG1hdGNoIChcInB1c2hcIiBmcm9tIG9yaWdpbikgYnkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmeWluZyB0aGUgZGF0dW0gZm9yIGVhY2gsIHRoZW4gKmNhcmVmdWxseSogdXBkYXRpbmcgaXRzIHRyYW5zZm9ybXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdmVydGV4SGFuZGxlcyA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnZlcnRleC1oYW5kbGUgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5Cb3VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR2ZXJ0ZXhIYW5kbGVzLnJlbW92ZUF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmVydGV4SGFuZGxlcy5hdHRyKCdjbGFzcycsICdvdXQtb2YtYm91bmRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZlcnRleEhhbmRsZXMuZWFjaChmdW5jdGlvbihpLCBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZDNlbCA9IGQzLnNlbGVjdChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdHNEYXR1bSA9IGQzZWwuZGF0dW0oKS5kYXR1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCdvbGRfeCcgaW4gaXRzRGF0dW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Rhc2ggb3JpZ2luYWwgdmFsdWUgKG9uY2Ugb25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS5vbGRfeCA9IGl0c0RhdHVtLnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS5vbGRfeSA9IGl0c0RhdHVtLnkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c0RhdHVtLnggPSBpdHNEYXR1bS5vbGRfeCAqIGNvbnN0cmFpbmVkWFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRzRGF0dW0ueSA9IGl0c0RhdHVtLm9sZF95ICogY29uc3RyYWluZWRZU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldEFjdHVhbFNpemVFbGVtZW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmVlSWxsdXN0cmF0b3IudHJlZUxheW91dHMuQ0lSQ0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayB0aGUgc2FtZSBwcm9wZXJ0aWVzIGZvciBhbGwgcmVtYWluaW5nIGhhbmRsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRFbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydEVsZW1lbnRQcm9wcyA9IHsgcm9vdFg6IGRyYWdFbGVtZW50LnJvb3RYKCksIHJvb3RZOiBkcmFnRWxlbWVudC5yb290WSgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBkcmFnRWxlbWVudC5yYWRpdXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogZHJhZ0VsZW1lbnQuc3RhcnRBbmdsZSgpLCBlbmRBbmdsZTogZHJhZ0VsZW1lbnQuZW5kQW5nbGUoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIG9yaWdpbmFsIGFuZCBuZXcgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIElnbm9yZSBkcmFnQ3VycmVudEhhbmRsZURlbHRhOyBqdXN0IHJlY2tvbiBjdXJyZW50IG1vdXNlTG9jIGluIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIChpbGx1c3RyYXRpb24pIGNvb3JkaW5hdGVzIGFuZCBtZWFzdXJlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByb290IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeERpc3RhbmNlID0gbW91c2VMb2MueCAtIGRyYWdTdGFydEVsZW1lbnRQcm9wcy5yb290WDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlEaXN0YW5jZSA9IG1vdXNlTG9jLnkgLSBkcmFnU3RhcnRFbGVtZW50UHJvcHMucm9vdFk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KCBNYXRoLnBvdyh4RGlzdGFuY2UsIDIpICsgTWF0aC5wb3coeURpc3RhbmNlLCAyKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudC5jb25zdHJhaW5lZFJhZGl1cyggaHlwb3RlbnVzZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChkcmFnSGFuZGxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaXVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBVcGRhdGUgaG90c3BvdCBhbmQgaGFuZGxlIHBvc2l0aW9ucyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNjYWxlIHRoZSBtYWluIGhvdHNwb3QgdG8gbWF0Y2ggdGhlIHJhdGlvIG9mIG9sZCB2cy4gbmV3Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFJhZGl1cyA9IGRyYWdTdGFydEVsZW1lbnRQcm9wcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSYWRpdXMgPSBkcmFnRWxlbWVudC5yYWRpdXMoKSwgIC8vIHJlZmxlY3QgYWN0aXZlIGNvbnN0cmFpbnRzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQ2hhbmdlUmF0aW8gPSBwZW5kaW5nUmFkaXVzIC8gb2xkUmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaG90c3BvdCA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnRyZWUtaG90c3BvdCBwYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluQm91bmRzID0gKHBlbmRpbmdSYWRpdXMgPT09IGh5cG90ZW51c2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaG90c3BvdC5yZW1vdmVBdHRyKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRob3RzcG90LmF0dHIoJ2NsYXNzJywgJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGhvdHNwb3QuYXR0cigndHJhbnNmb3JtJywgXCJzY2FsZShcIisgc2l6ZUNoYW5nZVJhdGlvICtcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGhpZGUgaXRzIGJvcmRlciAoYmVhdXNlIHNjYWxpbmcgc3Ryb2tlLXdpZHRoIGlzIHVnbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGhvdHNwb3QuY3NzKCdzdHJva2Utb3BhY2l0eScsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBtb3ZlIHRoZSB2ZXJ0ZXggaGFuZGxlcyB0byBtYXRjaCAoXCJwdXNoXCIgZnJvbSBvcmlnaW4pIGJ5IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmeWluZyB0aGUgZGF0dW0gZm9yIGVhY2gsIHRoZW4gKmNhcmVmdWxseSogdXBkYXRpbmcgaXRzIHRyYW5zZm9ybXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR2ZXJ0ZXhIYW5kbGVzID0gJGhhbmRsZXNHcm91cC5maW5kKCcudmVydGV4LWhhbmRsZSBwYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR2ZXJ0ZXhIYW5kbGVzLnJlbW92ZUF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZlcnRleEhhbmRsZXMuYXR0cignY2xhc3MnLCAnb3V0LW9mLWJvdW5kcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmVydGV4SGFuZGxlcy5lYWNoKGZ1bmN0aW9uKGksIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQzZWwgPSBkMy5zZWxlY3QocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdHNEYXR1bSA9IGQzZWwuZGF0dW0oKS5kYXR1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ29sZF94JyBpbiBpdHNEYXR1bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXNoIG9yaWdpbmFsIHZhbHVlIChvbmNlIG9ubHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS5vbGRfeCA9IGl0c0RhdHVtLnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c0RhdHVtLm9sZF95ID0gaXRzRGF0dW0ueSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c0RhdHVtLnggPSBpdHNEYXR1bS5vbGRfeCAqIHNpemVDaGFuZ2VSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRzRGF0dW0ueSA9IGl0c0RhdHVtLm9sZF95ICogc2l6ZUNoYW5nZVJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0QWN0dWFsU2l6ZUVsZW1lbnRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQtYW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kLWFuZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBzaG91bGQgY2hhbmdlIHJhZGl1cyAqYW5kKiBhcmMgYW5nbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUluZm8gPSBkMy5zZWxlY3QoZHJhZ0hhbmRsZSkuZGF0dW0oKS5kYXR1bTsgLy8gaW5jbHVkZXMgLmFuZ2xlLCAudGhldGEsIGV0Y1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vL2NvbnNvbGUubG9nKGhhbmRsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbmdsZUluUmFkaWFucyA9IE1hdGguYXRhbjIoIHlEaXN0YW5jZSwgeERpc3RhbmNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcyBhbmQgZm9yY2UgdG8gcmFuZ2UgZnJvbSAwLTM2MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbmdsZUluRGVncmVlcyA9IHV0aWxzLm5vcm1hbGl6ZURlZ3JlZXMoIHV0aWxzLnJhZGlhbnNUb0RlZ3JlZXMoIG5ld0FuZ2xlSW5SYWRpYW5zICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFsgZHJhZ0hhbmRsZU5hbWUgPT09ICdzdGFydC1hbmdsZScgPyAnc3RhcnRBbmdsZScgOiAnZW5kQW5nbGUnIF0oIG5ld0FuZ2xlSW5EZWdyZWVzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBVcGRhdGUgaG90c3BvdCBhbmQgaGFuZGxlIHBvc2l0aW9ucyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0Nsb2Nrd2lzZSA9IChkcmFnRWxlbWVudC5yYWRpYWxTd2VlcCgpID09PSBUcmVlSWxsdXN0cmF0b3Iuc3dlZXBEaXJlY3Rpb25zLkNMT0NLV0lTRSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSYWRpdXMgPSBkcmFnRWxlbWVudC5yYWRpdXMoKSwgIC8vIHJlZmxlY3QgYWN0aXZlIGNvbnN0cmFpbnRzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhcnRBbmdsZSA9IGRyYWdFbGVtZW50LnN0YXJ0QW5nbGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0VuZEFuZ2xlID0gZHJhZ0VsZW1lbnQuZW5kQW5nbGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxBcmNEZWdyZWVzID0gaXNDbG9ja3dpc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMubm9ybWFsaXplRGVncmVlcyhwZW5kaW5nRW5kQW5nbGUgLSBwZW5kaW5nU3RhcnRBbmdsZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMubm9ybWFsaXplRGVncmVlcyhwZW5kaW5nU3RhcnRBbmdsZSAtIHBlbmRpbmdFbmRBbmdsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzaW5nTGFyZ2VBcmMgPSAodG90YWxBcmNEZWdyZWVzID49IDE4MCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGFydEFuZ2xlVmVydGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVja29uIHRoaXMgZnJvbSB0aGUgYW5nbGUgYW5kIHJhZGl1cyAoaHlwb3RlbnVzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBlbmRpbmdSYWRpdXMgKiBNYXRoLmNvcyggdXRpbHMuZGVncmVlc1RvUmFkaWFucyhwZW5kaW5nU3RhcnRBbmdsZSkgKSwgLy8gRnggPSBGIGNvcyhhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcGVuZGluZ1JhZGl1cyAqIE1hdGguc2luKCB1dGlscy5kZWdyZWVzVG9SYWRpYW5zKHBlbmRpbmdTdGFydEFuZ2xlKSApICAvLyBGeSA9IEYgc2luKGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdFbmRBbmdsZVZlcnRleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBlbmRpbmdSYWRpdXMgKiBNYXRoLmNvcyggdXRpbHMuZGVncmVlc1RvUmFkaWFucyhwZW5kaW5nRW5kQW5nbGUpICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwZW5kaW5nUmFkaXVzICogTWF0aC5zaW4oIHV0aWxzLmRlZ3JlZXNUb1JhZGlhbnMocGVuZGluZ0VuZEFuZ2xlKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZEFyY0FuZ2xlID0gaXNDbG9ja3dpc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMubm9ybWFsaXplRGVncmVlcyhwZW5kaW5nU3RhcnRBbmdsZSArICh0b3RhbEFyY0RlZ3JlZXMvMikpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLm5vcm1hbGl6ZURlZ3JlZXMocGVuZGluZ1N0YXJ0QW5nbGUgLSAodG90YWxBcmNEZWdyZWVzLzIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JhZGl1c0NvbnRyb2xWZXJ0ZXggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBwZW5kaW5nUmFkaXVzICogTWF0aC5jb3MoIHV0aWxzLmRlZ3JlZXNUb1JhZGlhbnMobWlkQXJjQW5nbGUpICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwZW5kaW5nUmFkaXVzICogTWF0aC5zaW4oIHV0aWxzLmRlZ3JlZXNUb1JhZGlhbnMobWlkQXJjQW5nbGUpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGhvdHNwb3QgPSAkaGFuZGxlc0dyb3VwLmZpbmQoJy50cmVlLWhvdHNwb3QgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbmdsZSA9IGRyYWdFbGVtZW50WyBkcmFnSGFuZGxlTmFtZSA9PT0gJ3N0YXJ0LWFuZ2xlJyA/ICdzdGFydEFuZ2xlJyA6ICdlbmRBbmdsZScgXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbkJvdW5kcyA9IChwZW5kaW5nUmFkaXVzID09PSBoeXBvdGVudXNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZXdBbmdsZSA9PT0gbmV3QW5nbGVJbkRlZ3JlZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaG90c3BvdC5yZW1vdmVBdHRyKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRob3RzcG90LmF0dHIoJ2NsYXNzJywgJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaG90c3BvdC5hdHRyKCdkJywgZ2VuZXJhdGVSYWRpYWxIb3RzcG90UGF0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdMYXJnZUFyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGFydEFuZ2xlVmVydGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nRW5kQW5nbGVWZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gaGlkZSBpdHMgYm9yZGVyIChiZWF1c2Ugc2NhbGluZyBzdHJva2Utd2lkdGggaXMgdWdseSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaG90c3BvdC5jc3MoJ3N0cm9rZS1vcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIG1vdmUgdGhlIHZlcnRleCBoYW5kbGVzIHRvIG1hdGNoIChcInB1c2hcIiBmcm9tIG9yaWdpbikgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb2RpZnlpbmcgdGhlIGRhdHVtIGZvciBlYWNoLCB0aGVuICpjYXJlZnVsbHkqIHVwZGF0aW5nIGl0cyB0cmFuc2Zvcm1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdmVydGV4SGFuZGxlcyA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnZlcnRleC1oYW5kbGUgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmVydGV4SGFuZGxlcy5yZW1vdmVBdHRyKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR2ZXJ0ZXhIYW5kbGVzLmF0dHIoJ2NsYXNzJywgJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZlcnRleEhhbmRsZXMuZWFjaChmdW5jdGlvbihpLCBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkM2VsID0gZDMuc2VsZWN0KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRzRGF0dW0gPSBkM2VsLmRhdHVtKCkuZGF0dW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCggaXRzRGF0dW0ubmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBuZXZlciBtb3Zlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQtYW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c0RhdHVtLnggPSBwZW5kaW5nU3RhcnRBbmdsZVZlcnRleC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0c0RhdHVtLnkgPSBwZW5kaW5nU3RhcnRBbmdsZVZlcnRleC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kLWFuZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS54ID0gcGVuZGluZ0VuZEFuZ2xlVmVydGV4Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRzRGF0dW0ueSA9IHBlbmRpbmdFbmRBbmdsZVZlcnRleC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaXVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS54ID0gcGVuZGluZ1JhZGl1c0NvbnRyb2xWZXJ0ZXgueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHNEYXR1bS55ID0gcGVuZGluZ1JhZGl1c0NvbnRyb2xWZXJ0ZXgueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0QWN0dWFsU2l6ZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBkcmFnIGhhbmRsZSBbJysgZHJhZ0hhbmRsZU5hbWUgKyddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAuLi4gZWxzZSBpZiAoZHJhZ0VsZW1lbnQgaW5zdGFuY2VvZiBUcmVlSWxsdXN0cmF0b3IuU3VwcG9ydGluZ0RhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRyYWdFbGVtZW50IGluc3RhbmNlb2YgVHJlZUlsbHVzdHJhdG9yLk9ybmFtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImRyYWcgbG9naWM6IHVuZXhwZWN0ZWQgZWxlbWVudCB0eXBlOiAnXCIrIGRyYWdFbGVtZW50Lm1ldGFkYXRhLnR5cGUoKSArXCInIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUmFkaWFsSG90c3BvdFBhdGgoIGxhcmdlQXJjLCBzd2VlcFZhbHVlLCByYWRpdXMsIHN0YXJ0UG9pbnQsIGVuZFBvaW50ICkge1xuICAgIC8qIFJldHVybiBhIHBhdGggdGhhdCBzd2VlcHMgYW4gYXJjIGFyb3VuZCBvcmlnaW4gMCwwXG4gICAgICogIEVYQU1QTEU6IFwiTTAsMCBMMzYuNzksMjMxLjI0IEEyMzQuMTQsMjM0LjE0IDAgMCwxIC0yMDkuNDIsMTA0LjczIFpcIlxuICAgICAqIEFTU1VNRVMgdGhhdCBhbmdsZXMgYXJlIGluIHJhZGlhbnMhXG4gICAgICogQWRhcHRlZCBmcm9tIGB2Zy5kYXRhLnBoeWxvZ3JhbS5qc2AsIHNlZSBhbHNvOlxuICAgICAqICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvVHV0b3JpYWwvUGF0aHMjQXJjc1xuICAgICAqICBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YUVsbGlwdGljYWxBcmNDb21tYW5kc1xuICAgICAqL1xuICAgIHZhciByb3RhdGlvbiA9IDAsICAvLyB0aGlzIGlzIG1vb3QgZm9yIGEgY2lyY2xlXG4gICAgICAgIC8vY2xvY2t3aXNlID0gTWF0aC5hYnMobWlkQW5nbGUgLSBzcmNBbmdsZSkgPiBNYXRoLlBJID8gbWlkQW5nbGUgPD0gc3JjQW5nbGUgOiBtaWRBbmdsZSA+IHNyY0FuZ2xlLFxuICAgICAgICBsYXJnZUFyYyA9IE51bWJlcihsYXJnZUFyYyksXG4gICAgICAgIHN3ZWVwVmFsdWUgPSBOdW1iZXIoc3dlZXBWYWx1ZSk7XG4gICAgdmFyIHBhdGggPSBcIk0wLDBcIiArXG4gICAgICBcIiBMXCIrIFtzdGFydFBvaW50Lngsc3RhcnRQb2ludC55XSArXG4gICAgICBcIiBBXCIgKyBbcmFkaXVzLHJhZGl1c10gKycgJysgcm90YXRpb24gKycgJysgbGFyZ2VBcmMgKycsJysgc3dlZXBWYWx1ZSArJyAnKyBbZW5kUG9pbnQueCxlbmRQb2ludC55XSArXG4gICAgICBcIiBaXCI7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0TW91c2VMb2MoZXZlbnQsICRzY3JvbGxpbmdWaWV3cG9ydCkge1xuICAgIC8vIFJlY2tvbiBtb3VzZSBwb3NpdGlvbiBhcyBkaXNwbGF5IHB4LCByZWxhdGl2ZSB0byB0aGUgU1ZHIHZpZXdwb3J0XG4gICAgdmFyIHZwT2Zmc2V0ID0gJHNjcm9sbGluZ1ZpZXdwb3J0Lm9mZnNldCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IChldmVudC5wYWdlWCAtIHZwT2Zmc2V0LmxlZnQgKyAkc2Nyb2xsaW5nVmlld3BvcnQuc2Nyb2xsTGVmdCgpKSxcbiAgICAgICAgeTogKGV2ZW50LnBhZ2VZIC0gdnBPZmZzZXQudG9wICsgJHNjcm9sbGluZ1ZpZXdwb3J0LnNjcm9sbFRvcCgpKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRJbGx1c3RyYXRpb25Nb3VzZUxvYyhldmVudCwgJHNjcm9sbGluZ1ZpZXdwb3J0KSB7XG4gICAgLyogUmVja29uIG1vdXNlIHBvc2l0aW9uIGluIHRoZSBpbGx1c3RyYXRpb24ncyBTVkcgY29vcmRpbmF0ZXMuXG4gICAgICogTi5CLiB0aGF0IGQzIHByb3ZpZGVzIGFuIGVhc3kgbWV0aG9kIGZvciB0aGlzLCBidXQgaXQgY2FuJ3QgYmUgY2FsbGVkXG4gICAgICogZXhjZXB0IHdpdGhpbiBhIChkMykgZXZlbnQgaGFuZGxlciBvbiB0aGUgU1ZHIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqICAgaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL2Jsb2IvbWFzdGVyL3NyYy9ldmVudC9tb3VzZS5qc1xuICAgICAqICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjc0MzQyODVcbiAgICAgKiBGQUlMUyBIRVJFOiBjb25zb2xlLmVycm9yKCBkMy5tb3VzZShkMy5zZWxlY3QoJ2Rpdi52ZWdhID4gc3ZnJykpICk7XG4gICAgICovXG4gICAgLyogVGhpcyBjb2RlIGludm9rZXMgdGhlIGQzIGxvY2F0aW9uIHRlc3QsIGJ1dCBjYW4ndCByZXR1cm4gYSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICBUbyBzZWUgaXQgaW4gYWN0aW9uLCB1bmNvbW1lbnQgYm90aCBibG9ja3MgbWFya2VkIEQzX01PVVNFX1NFTlNJTkdcbiAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQgKFwiTW91c2VFdmVudFwiKTtcbiAgICBldnQuaW5pdE1vdXNlRXZlbnQoXCJtb3VzZXRlc3RcIiwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jdHJsS2V5LCBldmVudC5hbHRLZXksIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAwLCBudWxsKTtcbiAgICAkKCdkaXYudmVnYSA+IHN2ZycpWzBdLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAqL1xuXG4gICAgdmFyIHZpZXdwb3J0TG9jID0gZ2V0Vmlld3BvcnRNb3VzZUxvYyhldmVudCwgJHNjcm9sbGluZ1ZpZXdwb3J0KTtcbiAgICAvLyBSZXZlcnNlIHRoZSBjdXJyZW50IG1hZ25pZmljYXRpb24gYW5kIGFsbG93IGZvciBwYWRkZWQgdmlld3BvcnRcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAodmlld3BvcnRMb2MueCAvIHZpZXdwb3J0TWFnbmlmaWNhdGlvbikgKyB2aWV3Ym94LngsXG4gICAgICAgIHk6ICh2aWV3cG9ydExvYy55IC8gdmlld3BvcnRNYWduaWZpY2F0aW9uKSArIHZpZXdib3gueVxuICAgIH07XG59XG5cbi8qIFRoZSBjdXJyZW50IFZlZ2Egc3BlYyBpcyBnZW5lcmF0ZWQgdXNpbmcgdGhlIGNob3NlbiBzdHlsZSAoYWJvdmUpIGFuZCBcbiAqIHRoZSBpbGx1c3RyYXRpb24gc291cmNlIGFuZCBkZWNpc2lvbnMgbWFkZSBpbiB0aGUgd2ViIFVJLiBXaGVuIHRoZVxuICogaWxsdXN0cmF0aW9uIGlzIHNhdmVkLCB0aGUgbGF0ZXN0IGNhbiBhbHNvIGJlIGVtYmVkZGVkLiBPciBwZXJoYXBzIHdlIHNob3VsZFxuICogYWx3YXlzIGdlbmVyYXRlIGl0IGZyZXNoIGZyb20gdGhlIHNvdXJjZSBkYXRhIGFuZCBzY2VuZSBncmFwaCB3aGVublxuICogKHJlKWxvYWRpbmcgdGhlIGlsbHVzdHJhdGlvbj9cbiAqL1xudmFyIHZlZ2FTcGVjO1xudmFyIHZpZXc7IC8vIGEgVmVnYSBWaWV3Q29tcG9uZW50ICh1c2UgdG8gc2V0IHNpZ25hbHMsIHVwZGF0ZXMsIGV0Yy4pXG5mdW5jdGlvbiByZWZyZXNoVml6KG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBjb25zb2xlLndhcm4oJ3JlZnJlc2hWaXooKSBTVEFSVElORycpO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9OyBcblxuICAgIGlsbC51cGRhdGVWZWdhU3BlYygpOyAgLy8gVE9ETzogdHJpZ2dlciB1cGRhdGVzIG9uIGEgbW9yZSBzZW5zaWJsZSBiYXNpc1xuXG4gICAgdmcucGFyc2Uuc3BlYyhpbGwudmVnYVNwZWMsIGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgICAgIHZpZXcgPSBjaGFydCh7ZWw6XCIjdml6LW91dGVyLWZyYW1lXCIsIHJlbmRlcmVyOlwic3ZnXCJ9KTtcbiAgICAgICAgLy8gZXhwb3J0IHRoZSBuZXcgdmlld1xuICAgICAgICBleHBvcnRzLnZpZXcgPSB2aWV3O1xuICAgICAgICB2aWV3LnVwZGF0ZSgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLlNIT1dfQUxMKSB7XG4gICAgICAgICAgICByZXNpemVWaWV3cG9ydFRvU2hvd0FsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdFRyZWVJbGx1c3RyYXRvcldpbmRvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogKFJlKWJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIGVsZW1lbnQgaG90c3BvdHMgKi9cbiAgICAgICAgLy8gTi5CLiBqUXVlcnkgZXZlbnQgZGVsZWdhdGlvbiBkb2Vzbid0IHNlZW0gdG8gd29yayB3aXRoIFNWRyBlbGVtZW50cyFcbiAgICAgICAgdmFyICRzY3JvbGxpbmdWaWV3cG9ydCA9ICQoXCIjdml6LW91dGVyLWZyYW1lXCIpLmZpbmQoJ2Rpdi52ZWdhJyk7XG4gICAgICAgIC8vJHNjcm9sbGluZ1ZpZXdwb3J0LmRlbGVnYXRlKFwiLnRyZWUtaG90c3BvdFwiLCBcImNsaWNrIGhvdmVyIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gLi4uXG4gICAgICAgICRzY3JvbGxpbmdWaWV3cG9ydC5maW5kKCdnLmhhbmRsZXMnKVxuICAgICAgICAgICAgLm9mZignLmhvdHNwb3QnKSAgLy8gcmVtb3ZlIGFueSBwcmlvciBiaW5kaW5nc1xuICAgICAgICAgICAgLm9uKFwibW91c2VlbnRlci5ob3RzcG90XCIsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBnZXRJbGx1c3RyYXRpb25FbGVtZW50RnJvbUhhbmRsZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0VsZW1lbnRIYW5kbGVzKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VsZWF2ZS5ob3RzcG90XCIsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZ2V0SWxsdXN0cmF0aW9uRWxlbWVudEZyb21IYW5kbGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdFbGVtZW50ICE9PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICBoaWRlRWxlbWVudEhhbmRsZXMoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIGNhbid0IGFkZCBwcm9wZXIgSURzIGZvciB2ZXJ0ZXggaGFuZGxlcywgYnV0IHN0YXJ0RHJhZ2dpbmcgd2lsbCBhZGFwdFxuICAgICAgICB2YXIgYWxsSGFuZGxlcyA9ICRzY3JvbGxpbmdWaWV3cG9ydC5maW5kKCcudHJlZS1ob3RzcG90LCAuaGFuZGxlcyAudmVydGV4LWhhbmRsZSBwYXRoJylcbiAgICAgICAgICAgIC5jc3MoJ2N1cnNvcicsJ21vdmUnKVxuICAgICAgICAgICAgLm9mZignLmhvdHNwb3QnKSAgLy8gcmVtb3ZlIGFueSBwcmlvciBiaW5kaW5nc1xuICAgICAgICAgICAgLy8ub24oXCJtb3VzZWVudGVyLmhvdHNwb3QgbW91c2VsZWF2ZS5ob3RzcG90IG1vdXNlZG93bi5ob3RzcG90IG1vdXNldXAuaG90c3BvdCBjbGljay5ob3RzcG90IG1vdXNlbW92ZS5ob3RzcG90XCIsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAub24oXCJtb3VzZWRvd24uaG90c3BvdFwiLCBzdGFydERyYWdnaW5nKTtcblxuICAgICAgICAvLyBBZGQgU1ZHICd0aXRsZScgZWxlbWVudHMgdG8gcHJvdmlkZSB0b29sLXRpcHMgZm9yIGFsbCBob3RzcG90c1xuICAgICAgICAkLmVhY2goYWxsSGFuZGxlcywgZnVuY3Rpb24oaSwgaCkge1xuICAgICAgICAgICAgLy8gZXh0cmFjdCBhbmQgZGlzcGxheSBpdHMgZGVzY3JpcHRpb24gYXMgYSB0b29sdGlwXG4gICAgICAgICAgICB2YXIgJGhhbmRsZSA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgZDNoYW5kbGUgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcCA9IFwiVE9ETzogQWRkIGEgdG9vbHRpcCBmb3IgdGhpcyBoYW5kbGUhXCI7XG4gICAgICAgICAgICBpZiAoZDNoYW5kbGUuZGF0dW0oKSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSBkM2hhbmRsZS5kYXR1bSgpLnRvb2x0aXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgaGFuZGxlcyAoZXNwLiBob3RzcG90cykgZG9uJ3QgaGF2ZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKCRoYW5kbGUuaXMoJy50cmVlLWhvdHNwb3QnKSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwID0gXCJEcmFnIHRvIG1vdmUgdGhpcyB0cmVlIG9uIHRoZSBwYWdlLlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQzaGFuZGxlLmFwcGVuZChcInN2Zzp0aXRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh0b29sdGlwKTtcbiAgICAgICAgfSk7XG5cbiAgICAvKiBUaGlzIGNvZGUgYWN0aXZhdGVzIGEgZDMgbG9jYXRpb24gdGVzdCBpbiByZXNwb25zZSB0byBhIGN1c3RvbSBldmVudCxcbiAgICAgKiBidXQgaXQgY2FuJ3QgcmV0dXJuIGEgdmFsdWUgZGlyZWN0bHkuIFRvIHNlZSB0aGlzIGluIGFjdGlvbiwgdW5jb21tZW50XG4gICAgICogYm90aCBibG9ja3MgbWFya2VkIEQzX01PVVNFX1NFTlNJTkdcbiAgICAgICAgZDMuc2VsZWN0KCdkaXYudmVnYSA+IHN2ZycpLm9uKCdtb3VzZXRlc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oIGQzLm1vdXNlKHRoaXMpICk7XG4gICAgICAgIH0pO1xuICAgICAqL1xuXG4gICAgfSk7XG4gICAgY29uc29sZS53YXJuKFwicmVmcmVzaFZpeigpIHRvb2sgXCIrIChuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lKSArXCIgbXMgdG8gY29tcGxldGVcIik7XG59XG5mdW5jdGlvbiBnZXRJbGx1c3RyYXRpb25FbGVtZW50RnJvbUhhbmRsZSggaGFuZGxlICkge1xuICAgIC8vIFNob3VsZCB0aGlzIHVzZSBhc3NpZ25lZCBkYXR1bSBpbnN0ZWFkP1xuICAgIHZhciAkZWxlbWVudEdyb3VwID0gJChoYW5kbGUpLmNsb3Nlc3QoJ2cubWFyay1ncm91cFtjbGFzcyo9dHJlZS1dLCBnLm1hcmstZ3JvdXBbY2xhc3MqPWRhdGFzZXQtXSwgZy5tYXJrLWdyb3VwW2NsYXNzKj1vcm5hbWVudC1dJyk7XG4gICAgdmFyIGVsZW1lbnRJRCA9ICRlbGVtZW50R3JvdXAuYXR0cignY2xhc3MnKS5zcGxpdCgvXFxzKy8pWzFdO1xuICAgIC8vIEFTU1VNRVMgYSBwcmVkaWN0YWJsZSBjbGFzcyBhdHRyaWJ1dGUsIGUuZy4gJ2dyb3VwLW1hcmtzIHRyZWUtMydcbiAgICByZXR1cm4gc3R5bGlzdC5pbGwuZ2V0RWxlbWVudEJ5SUQoIGVsZW1lbnRJRCApO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEhhbmRsZXNHcm91cCggaWxsRWxlbWVudCApIHtcbiAgICAvLyBGaW5kIHRoZSBTVkcgZ3JvdXAgaG9sZGluZyBhbGwgaGFuZGxlcyBmb3IgYSBnaXZlbiBJbGx1c3RyYXRlZFRyZWUvZXRjLlxuICAgIHZhciAkZWxlbWVudEdyb3VwID0gJCgnZGl2LnZlZ2Egc3ZnIGcuaWxsdXN0cmF0aW9uLWVsZW1lbnRzIGcubWFyay1ncm91cFtjbGFzcyo9JysgaWxsRWxlbWVudC5pZCgpICsnXScpO1xuICAgIHZhciAkaGFuZGxlc0dyb3VwID0gJGVsZW1lbnRHcm91cC5maW5kKCdnLm1hcmstZ3JvdXAuaGFuZGxlcycpO1xuICAgIHJldHVybiAkaGFuZGxlc0dyb3VwO1xufVxuZnVuY3Rpb24gc2hvd0VsZW1lbnRIYW5kbGVzKCBpbGxFbGVtZW50ICkge1xuICAgIC8vIFNob3cgYWxsIGhhbmRsZXMgZm9yIGEgZ2l2ZW4gSWxsdXN0cmF0ZWRUcmVlL2V0Yy5cbiAgICB2YXIgJGhhbmRsZXNHcm91cCA9IGdldEVsZW1lbnRIYW5kbGVzR3JvdXAoIGlsbEVsZW1lbnQgKTtcbiAgICB2YXIgJGhvdHNwb3QgPSAkaGFuZGxlc0dyb3VwLmZpbmQoJy50cmVlLWhvdHNwb3QgcGF0aCcpO1xuICAgICRob3RzcG90LmNzcyh7XG4gICAgICAgICdmaWxsT3BhY2l0eSc6IFwiMC4yXCIsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JzogXCIwLjZcIlxuICAgIH0pO1xuICAgIHZhciAkaGFuZGxlcyA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnZlcnRleC1oYW5kbGUgcGF0aCcpO1xuICAgICRoYW5kbGVzLmNzcyh7XG4gICAgICAgICdmaWxsT3BhY2l0eSc6IFwiMS4wXCIsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoaWRlRWxlbWVudEhhbmRsZXMoIGlsbEVsZW1lbnQgKSB7XG4gICAgLy8gSGlkZSBhbGwgaGFuZGxlcyBmb3IgYSBnaXZlbiBJbGx1c3RyYXRlZFRyZWUvZXRjLlxuICAgIHZhciAkaGFuZGxlc0dyb3VwID0gZ2V0RWxlbWVudEhhbmRsZXNHcm91cCggaWxsRWxlbWVudCApO1xuICAgIHZhciAkaG90c3BvdCA9ICRoYW5kbGVzR3JvdXAuZmluZCgnLnRyZWUtaG90c3BvdCBwYXRoJyk7XG4gICAgJGhvdHNwb3QuY3NzKHtcbiAgICAgICAgJ2ZpbGxPcGFjaXR5JzogXCIwXCIsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JzogXCIwXCJcbiAgICB9KTtcbiAgICB2YXIgJGhhbmRsZXMgPSAkaGFuZGxlc0dyb3VwLmZpbmQoJy52ZXJ0ZXgtaGFuZGxlIHBhdGgnKTtcbiAgICAkaGFuZGxlcy5jc3Moe1xuICAgICAgICAnZmlsbE9wYWNpdHknOiBcIjBcIixcbiAgICB9KTtcbn1cblxuXG52YXIgaWxsOyAgXG5cbi8vIEtlZXAgc2FmZSBjb3B5IG9mIGxpc3QtY29udGFpbmluZyBtYXJrdXAgZm9yIHJlLXVzZSBhcyBhIEtub2Nrb3V0IHRlbXBsYXRlIChzZWUgYmVsb3cpXG52YXIgJHN0YXNoZWRFZGl0QXJlYSA9IG51bGw7XG5cbi8vIExvYWQgYW4gaWxsdXN0cmF0aW9uIGZyb20gSlMvSlNPTiBkYXRhICh1c3UuIGNhbGxlZCBieSBjb252ZW5pZW5jZSBmdW5jdGlvbnMgYmVsb3cpXG5mdW5jdGlvbiBsb2FkSWxsdXN0cmF0aW9uRGF0YSggZGF0YSwgaW5pdGlhbENhY2hlLCBuZXdPckV4aXN0aW5nICkge1xuICAgIC8vIFVzZSBhbiBJbGx1c3RyYXRpb24gb2JqZWN0IGFzIG91ciBwcmltYXJ5IHZpZXcgbW9kZWwgZm9yIEtub2Nrb3V0SlNcbiAgICAvLyAoYnkgY29udmVudGlvbiwgaXQncyB1c3VhbGx5IG5hbWVkICd2aWV3TW9kZWwnKVxuICAgIGlsbCA9IG5ldyBUcmVlSWxsdXN0cmF0b3IuSWxsdXN0cmF0aW9uKCBkYXRhICk7XG4gICAgLy8gZXhwb3J0IHRoZSBuZXcgaWxsdXN0cmF0aW9uXG4gICAgZXhwb3J0cy5pbGwgPSBpbGw7XG5cbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgY2FjaGVkIGRhdGEgZnJvbSB0aGUgaWxsdXN0cmF0aW9uIHJlbmRlcmluZyBwaXBlbGluZTtcbiAgICAvLyB1c2UgaW5pdGlhbCBkYXRhIGlmIHByb3ZpZGVkIGJ5IHRoZSBjYWxsZXIuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsQ2FjaGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIFRyZWVJbGx1c3RyYXRvci5mbHVzaENhY2hlKCBpbml0aWFsQ2FjaGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUcmVlSWxsdXN0cmF0b3IuZmx1c2hDYWNoZSggKTtcbiAgICB9XG5cbiAgICAvKiBUT0RPOiBoYW5kbGUgdGhlIG5ld09yRXhpc3Rpbmcgc3RvcmFnZSBpbmZvPyBvciBtYXliZSB0aGlzIGlzXG4gICAgICogaGFuZGxlZCBieSB0aGUgc3RvcmFnZSBiYWNrZW5kLi4uXG4gICAgICovXG5cbiAgICAvLyBhZGQgYSBzaW5nbGUgcGxhY2Vob2xkZXIgdHJlZVxuICAgIGlmICghZGF0YSkge1xuICAgICAgICBpbGwuYWRkSWxsdXN0cmF0ZWRUcmVlKCk7XG4gICAgfVxuXG4gICAgaWYgKCRzdGFzaGVkRWRpdEFyZWEgPT09IG51bGwpIHtcbiAgICAgICAgLy8gU3Rhc2ggdGhlIHByaXN0aW5lIG1hcmt1cCBiZWZvcmUgYmluZGluZyB0aGlzIHBvcHVwIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAkc3Rhc2hlZEVkaXRBcmVhID0gJCgnI3RpLW1haW4tYWNjb3JkaW9uJykuY2xvbmUoKTtcbiAgICAgICAgLypcbiAgICAgICAgJHN0YXNoZWRDb2xsZWN0aW9uRGVjaXNpb25FbGVtZW50ID0gJCgnI3RyZWUtY29sbGVjdGlvbi12aWV3ZXInKVxuICAgICAgICAgICAgLmZpbmQoJyN0cmVlLWNvbGxlY3Rpb24tZGVjaXNpb25zID4gdHIuc2luZ2xlLXRyZWUtcm93JykuZXEoMCkuY2xvbmUoKTtcbiAgICAgICAgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXBsYWNlIHdpdGggcHJpc3RpbmUgbWFya3VwIHRvIGF2b2lkIHdlaXJkIHJlc3VsdHMgd2hlbiBsb2FkaW5nIGEgbmV3IGlsbHVzdHJhdGlvblxuICAgICAgICAkKCcjdGktbWFpbi1hY2NvcmRpb24nKS5jb250ZW50cygpLnJlcGxhY2VXaXRoKFxuICAgICAgICAgICAgJHN0YXNoZWRFZGl0QXJlYS5jbG9uZSgpLmNvbnRlbnRzKClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyAocmUpYmluZCB0byBlZGl0b3IgVUkgd2l0aCBLbm9ja291dFxuICAgIHZhciAkYm91bmRFbGVtZW50cyA9ICQoJyNlZGl0b3InKTsgLy8gYWRkIG90aGVyIGVsZW1lbnRzP1xuICAgICQuZWFjaCgkYm91bmRFbGVtZW50cywgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAga28uY2xlYW5Ob2RlKGVsKTtcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyhpbGwsZWwpO1xuICAgIH0pO1xuXG4gICAgcmVmcmVzaFZpeigge1NIT1dfQUxMOiB0cnVlfSApO1xufVxuZnVuY3Rpb24gbG9hZEVtcHR5SWxsdXN0cmF0aW9uKCkge1xuICAgIC8qIExvYWQgYW4gZW1wdHkgaWxsdXN0cmF0aW9uIHdpdGggYSBwbGFjZWhvbGRlciB0cmVlLCB3aXRoXG4gICAgICogbm8gSUQgb3Igc2xvdCBhc3NpZ25lZCAoaS5lLiwgdHJlYXQgdGhpcyBhcyBhIG5ldyBpbGx1c3RyYXRpb24pLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBzaW1wbGUgdGVtcGxhdGU/XG4gICAgICovXG4gICAgbG9hZElsbHVzdHJhdGlvbkRhdGEoIG51bGwsIHt9LCAnTkVXJyApO1xuICAgIGNsZWFyTGFzdFNhdmVkSW5mbygpO1xufVxuLy8gTi5CLiBUaGVyZSBzaG91bGQgYmUgYWRkaXRpb25hbCBjb252ZW5pZW5jZSBmdW5jdGlvbnMgaW4gdGhlIHN0b3JhZ2UgYmFja2VuZFxuLy8gIC0gZmV0Y2hBbmRMb2FkRXhpc3RpbmdJbGx1c3RyYXRpb24oIGRvY0lEIClcbi8vICAtIGZldGNoQW5kTG9hZElsbHVzdHJhdGlvblRlbXBsYXRlKCB0ZW1wbGF0ZUlEIClcblxuZnVuY3Rpb24gZmV0Y2hBbmRMb2FkRXhpc3RpbmdJbGx1c3RyYXRpb24oIGJhY2tlbmQsIGRvY0lEICkge1xuICAgIC8qIExvYWQgdGhlIEpTIChvciBKU09OPykgZGF0YSBwcm92aWRlZCwgYW5kIGtlZXAgdHJhY2sgb2YgaXRzIG9yaWdpbmFsIElEL3Nsb3QuXG4gICAgICovXG4gICAgc3RvcmFnZVsgYmFja2VuZCBdLmxvYWRJbGx1c3RyYXRpb24oZG9jSUQsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICgnZGF0YScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGxvYWRJbGx1c3RyYXRpb25EYXRhKCBkYXRhLCB7fSwgJ0VYSVNUSU5HJyApO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3Qtc2F2ZWQgaW5mb1xuICAgICAgICAgICAgdXBkYXRlTGFzdFNhdmVkSW5mbyhiYWNrZW5kLCBkb2NJRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hBbmRMb2FkSWxsdXN0cmF0aW9uVGVtcGxhdGUoIGJhY2tlbmQsIHRlbXBsYXRlSUQgKSB7XG4gICAgLyogTG9hZCB0aGUgSlMgKG9yIEpTT04pIGRhdGEgcHJvdmlkZWQsIGJ1dCB0cmVhdCB0aGlzIGFzIGEgbmV3IGlsbHVzdHJhdGlvbi5cbiAgICAgKlxuICAgICAqIE4uQi4gQSB0ZW1wbGF0ZSBpcyBiYXNpY2FsbHkgYW4gZXhpc3RpbmcgaWxsdXN0cmF0aW9uIGRvY3VtZW50LCB3aXRoXG4gICAgICogaW50ZXJuYWwgcHJvbXB0cyBhbmQgcGxhY2Vob2xkZXIgdHJlZXMvZGF0YSwgYnV0IHdlJ2xsIHRyZWF0IGl0IGFzIG5ldy5cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBmZXRjaCB1c2luZyBzdG9yYWdlIGJhY2tlbmRcbiAgICBzdG9yYWdlWyBiYWNrZW5kIF0ubG9hZElsbHVzdHJhdGlvbihkb2NJRCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGxvYWRJbGx1c3RyYXRpb25EYXRhKCB0ZW1wbGF0ZSwge30sICdORVcnICk7XG4gICAgICAgICAgICBjbGVhckxhc3RTYXZlZEluZm8oKTsgIC8vIHNvIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgdGVtcGxhdGUhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlLmVycm9yIHx8IFwiTm8gZGF0YSByZXR1cm5lZCAodW5zcGVjaWZpZWQgZXJyb3IpIVwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAvLyB0ZXN0IGZvciB0aGUgcHJlc2V0IHBwaSAocGl4ZWxzIC8gaW5jaCkgaW4gdGhpcyBicm93c2VyXG4gICAgYnJvd3Nlcl9wcGkgPSAkKCcjc3ZnLXRvb2xib3gnKS53aWR0aCgpIC8gMTAuMDtcbiAgICAkKCcjc3ZnLXRvb2xib3gnKS5oaWRlKCk7ICAvLyB0byBhdm9pZCBjcmF6eSBwYWdlIHdpZHRoIGluIEZpcmVmb3hcbiAgICAvLyBOT1RFIHRoYXQgdGhpcyBpcyBzdGlsbCB1bmxpa2VseSB0byBtYXRjaCB0aGUgcGh5c2ljYWwgc2l6ZSBvZiBhbnkgcGFydGljdWxhciBtb25pdG9yIVxuICAgIC8vIElmIHRoYXQncyBpbXBvcnRhbnQsIHdlIG1pZ2h0IHdhbnQgdG8gbGV0IHRoZSB1c2VyIHR3ZWFrIHRoaXMgdmFsdWUuXG4gICAgJCgnI2Jyb3dzZXItcHBpLWluZGljYXRvcicpLnRleHQoYnJvd3Nlcl9wcGkpO1xuICAgICQoJyNkaXNwbGF5LXBwaS1pbmRpY2F0b3InKS50ZXh0KGRpc3BsYXlfcHBpKTtcblxuICAgIC8vIHNob3cgb3IgZGlzYWJsZSB0aGUgZnVsbC1zY3JlZW4gd2lkZ2V0c1xuICAgIHZhciAkZnVsbFNjcmVlblRvZ2dsZSA9ICQoJ2J1dHRvbiNlbnRlci1mdWxsLXNjcmVlbicpO1xuICAgIGlmICgkLmZ1bGxzY3JlZW4uaXNOYXRpdmVseVN1cHBvcnRlZCgpKSB7XG4gICAgICAgIC8vIGllLCB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIGZ1bGwtc2NyZWVuIEFQSXNcbiAgICAgICAgJGZ1bGxTY3JlZW5Ub2dnbGUuc2hvdygpO1xuICAgICAgICAkKGRvY3VtZW50KS5iaW5kKCdmc2NyZWVuY2hhbmdlJywgZnVuY3Rpb24oZSwgc3RhdGUsIGVsZW0pIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGN1cnJlbnRseSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgICAgIGlmICgkLmZ1bGxzY3JlZW4uaXNGdWxsU2NyZWVuKCkpIHtcbiAgICAgICAgICAgICAgICAkKCcjZW50ZXItZnVsbC1zY3JlZW4nKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJCgnI2V4aXQtZnVsbC1zY3JlZW4nKS5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNlbnRlci1mdWxsLXNjcmVlbicpLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKCcjZXhpdC1mdWxsLXNjcmVlbicpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGltIGFuZCBkaXNhYmxlIHRoZSBmdWxsLXNjcmVlbiB0b2dnbGVcbiAgICAgICAgJGZ1bGxTY3JlZW5Ub2dnbGUuY3NzKFwib3BhY2l0eVwiLCBcIjAuNVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGZ1bGwtc2NyZWVuIGRpc3BsYXkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG93KCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQWRkIFwic2FmZXR5IG5ldFwiIGlmIHRoZXJlIGFyZSB1bnNhdmVkIGNoYW5nZXNcbiAgICAvLyBUT0RPOiBBZGQgSlNPTiBzdXBwb3J0IGZvciBvbGRlciBJRT9cblxuICAgIC8vIFVwZGF0ZSB0aGUgbGlzdCB3aXRoIGluaXRpYWwgdmFsdWVzXG4gICAgdXBkYXRlQXZhaWxhYmxlVHJlZXMoKTtcblxuICAgIC8vIEhhcyBteSBvcGVuZXIgcHJvdmlkZWQgYW4gaW5pdGlhbCBpbGx1c3RyYXRpb24gb3IgdGVtcGxhdGU/IElmIHNvLCBsb2FkIGl0IG5vd1xuICAgIHZhciBzdGFydGluZ0lEID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCdzdGFydGluZ0lEJyk7XG4gICAgY29uc29sZS5sb2coXCI+PiBzdGFydGluZ0lEOiBcIisgc3RhcnRpbmdJRCArXCIgPFwiKyB0eXBlb2Yoc3RhcnRpbmdJRCkgK1wiPlwiKTtcbiAgICB2YXIgc3RhcnRpbmdUeXBlID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCdzdGFydGluZ1R5cGUnKTtcbiAgICBjb25zb2xlLmxvZyhcIj4+IHN0YXJ0aW5nVHlwZTogXCIrIHN0YXJ0aW5nVHlwZSArXCIgPFwiKyB0eXBlb2Yoc3RhcnRpbmdUeXBlKSArXCI+XCIpO1xuICAgIC8vIE4uQi4gVGhpcyBzaG91bGQgYmUgYSBzdHJpbmcsIHNvICcwJyBpcyBhIHZhbGlkIHNsb3QgaWRlbnRpZmllciFcbiAgICBpZiAoc3RhcnRpbmdJRCkge1xuICAgICAgICAvLyBXaGljaCBzdG9yYWdlIGJhY2tlbmQgc2hvdWxkIHdlIHVzZT8gRGVwZW5kcyBvbiB0aGUgaG9zdCBhcHBcbiAgICAgICAgdmFyIGJhY2tlbmQ7XG4gICAgICAgIHN3aXRjaCAoaG9zdEFwcGxpY2F0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIChUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5KVVBZVEVSX05PVEVCT09LKTpcbiAgICAgICAgICAgICAgICAvLyBBU1NVTUUgd2UncmUgYmVpbmcgcGFzc2VkIGEgc3RvcmFnZSBzbG90IG51bWJlclxuICAgICAgICAgICAgICAgIGJhY2tlbmQgPSBUcmVlSWxsdXN0cmF0b3Iuc3RvcmFnZUJhY2tlbmRzLkpVUFlURVJfTk9URUJPT0s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChUcmVlSWxsdXN0cmF0b3IuaG9zdEFwcGxpY2F0aW9ucy5TVEFOREFMT05FKTpcbiAgICAgICAgICAgICAgICAvLyBBU1NVTUUgd2UncmUgYmVpbmcgcGFzc2VkIGEgcGh5bGVzeXN0ZW0gaWQgKHN0b3JlZCBvbiBHaXRIdWIpXG4gICAgICAgICAgICAgICAgYmFja2VuZCA9IFRyZWVJbGx1c3RyYXRvci5zdG9yYWdlQmFja2VuZHMuR0lUSFVCX1JFUE87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGhvc3RBcHBsaWNhdGlvbiBmb3VuZCAoJ1wiKyBob3N0QXBwbGljYXRpb24gK1wiJykhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc3RhcnRpbmdUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdJTExVU1RSQVRJT04nOlxuICAgICAgICAgICAgICAgIGZldGNoQW5kTG9hZEV4aXN0aW5nSWxsdXN0cmF0aW9uKCBiYWNrZW5kLCBzdGFydGluZ0lEICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdURU1QTEFURSc6XG4gICAgICAgICAgICAgICAgZmV0Y2hBbmRMb2FkSWxsdXN0cmF0aW9uVGVtcGxhdGUoIGJhY2tlbmQsIHN0YXJ0aW5nSUQgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHN0YXJ0aW5nVHlwZSBwcm92aWRlZCAoZXhwZWN0ZWQgJ0lMTFVTVFJBVElPTicgb3IgJ1RFTVBMQVRFJykhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRFbXB0eUlsbHVzdHJhdGlvbigpO1xuICAgIH1cblxuICAgIG1hdGNoVmlld3BvcnRUb1dpbmRvd1NpemUoKTtcblxuICAgIC8vIGVuYWJsZSBoaWRpbmcvc2hvd2luZyB0aGUgXCJzaWRlY2FyXCIgVUlcbiAgICAkKCcuc2lkZWNhci10b2dnbGUnKSAgLy8gaWUsIHRoZSBzcGxpdHRlciBhbmQgYWxsIHB1bGwgdGFic1xuICAgICAgICAvLyBjaGFuZ2UgY29sb3IgKG9mICphbGwqIHRvZ2dsaW5nIGVsZW1lbnRzKSBvbiBtb3VzZW92ZXJcbiAgICAgICAgLnVuYmluZCgnaG92ZXInKS5ob3ZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoJy5zaWRlY2FyLXRvZ2dsZScpLmFkZENsYXNzKCdob3ZlcmluZycpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoJy5zaWRlY2FyLXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdob3ZlcmluZycpO1xuICAgICAgICB9KVxuICAgICAgICAvLyBoaWRlL3Nob3cgKGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24pXG4gICAgICAgIC51bmJpbmQoJ2NsaWNrJykuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgIC8vIGRvbid0IHRyaWdnZXIgbXkgcGFyZW50IGVsZW1lbnRzIVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRseVZpc2libGUgPSAkKCcjc2lkZWNhcicpLmNzcygncmlnaHQnKSA9PT0gJzBweCc7XG4gICAgICAgICAgICB2YXIgaGlkZGVuWCA9IC0oICQoJyNzaWRlY2FyJykud2lkdGgoKSApO1xuICAgICAgICAgICAgdmFyIHZpc2libGVYID0gMDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50bHlWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgJCgnI3NpZGVjYXInKS5jc3MoJ3JpZ2h0JywgaGlkZGVuWCk7XG4gICAgICAgICAgICAgICAgJCgnI3NpZGVjYXItcHVsbHRhYiBhJykucmVtb3ZlQ2xhc3MoJ2ljb24tY2hldnJvbi1yaWdodCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ljb24tY2hldnJvbi1sZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNzaWRlY2FyJykuY3NzKCdyaWdodCcsIHZpc2libGVYKTtcbiAgICAgICAgICAgICAgICAkKCcjc2lkZWNhci1wdWxsdGFiIGEnKS5yZW1vdmVDbGFzcygnaWNvbi1jaGV2cm9uLWxlZnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdpY29uLWNoZXZyb24tcmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoVmlld3BvcnRUb1dpbmRvd1NpemUoKTtcbiAgICAgICAgICAgIHpvb21WaWV3cG9ydCgnUkVGUkVTSCcpO1xuICAgICAgICB9KTtcblxuICAgIC8vIHJlc2l6aW5nIHRoZSB3aW5kb3cgc2hvdWxkIHJlZnJlc2gvcmVzaXplIHRoZSB2aWV3cG9ydFxuICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaFZpZXdwb3J0VG9XaW5kb3dTaXplKCk7XG4gICAgICAgICAgICB6b29tVmlld3BvcnQoJ1JFRlJFU0gnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY29tcGxldGUgcmVzaXplOlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGJ1aWxkU3R1ZHlGZXRjaFVSTCggc3R1ZHlJRCApIHtcbiAgICAvLyBBU1NVTUVTIHdlJ3JlIHVzaW5nIHRoZSBwaHlsZXN5c3RlbSBBUEkgdG8gbG9hZCBzdHVkaWVzIGZyb20gdGhlIE9wZW5UcmVlIGRldiBzaXRlXG4gICAgdmFyIHRlbXBsYXRlID0gXCJodHRwczovL2FwaS5vcGVudHJlZW9mbGlmZS5vcmcvcGh5bGVzeXN0ZW0vdjEvc3R1ZHkve1NUVURZX0lEfT9vdXRwdXRfbmV4bWwyanNvbj0xLjAuMCZhdXRoX3Rva2VuPUFOT05ZTU9VU1wiXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoJ3tTVFVEWV9JRH0nLCBzdHVkeUlEKTtcbn1cblxuLypcbmZ1bmN0aW9uIHVzZUNob3NlblN0eWxlKCkge1xuICAgIHZpZXdNb2RlbC5zdHlsZSA9IGdldENob3NlblN0eWxlKCk7XG4gICAgcmVmcmVzaFZpeigpO1xufVxuZnVuY3Rpb24gZ2V0Q2hvc2VuU3R5bGUoKSB7XG4gICAgdmFyIHN0eWxlTmFtZSA9ICQoJyNzdHlsZS1jaG9vc2VyJykudmFsKCk7XG4gICAgcmV0dXJuIGdldFN0eWxlQnlOYW1lKCBzdHlsZU5hbWUgKTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlQnlOYW1lKCBzdHlsZU5hbWUgKSB7XG4gICAgdmFyIHNlbGVjdGVkU3R5bGVzID0gJC5ncmVwKGF2YWlsYWJsZVN0eWxlcywgZnVuY3Rpb24obykge3JldHVybiBvLm5hbWUgPT09IHN0eWxlTmFtZTt9KTtcbiAgICB2YXIgc3R5bGVJbmZvID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0ZWRTdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHlsZUluZm8gPSBzZWxlY3RlZFN0eWxlc1swXTtcbiAgICB9XG4gICAgaWYgKCFzdHlsZU5hbWUgfHwgIXN0eWxlSW5mbykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyBzdHlsZSBmb3VuZCB1bmRlciAnXCIrIHN0eWxlTmFtZSArXCInIVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZUluZm8uc3R5bGU7XG59XG4qL1xuXG5mdW5jdGlvbiB0b2dnbGVGaXhlZFJ1bGVycyh0b2dnbGUpIHtcbiAgICB2YXIgcnVsZXJzQXJlSGlkZGVuID0gJCgnI3Zpei1vdXRlci1mcmFtZScpLmhhc0NsYXNzKCdoaWRlLXJ1bGVycycpO1xuICAgIHZhciAkdG9nZ2xlQnRuID0gJCh0b2dnbGUpO1xuICAgIGlmIChydWxlcnNBcmVIaWRkZW4pIHtcbiAgICAgICAgLy8gc2hvdyB0aGVtIG5vd1xuICAgICAgICAkKCcjdml6LW91dGVyLWZyYW1lJykucmVtb3ZlQ2xhc3MoJ2hpZGUtcnVsZXJzJyk7XG4gICAgICAgICR0b2dnbGVCdG4udGV4dCgnSGlkZSBydWxlcnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoaWRlIHRoZW0gbm93XG4gICAgICAgICQoJyN2aXotb3V0ZXItZnJhbWUnKS5hZGRDbGFzcygnaGlkZS1ydWxlcnMnKTtcbiAgICAgICAgJHRvZ2dsZUJ0bi50ZXh0KCdTaG93IHJ1bGVycycpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydFZpZXdib3goKTtcbiAgICB6b29tVmlld3BvcnQoJ1JFRlJFU0gnKTtcbn1cblxuZnVuY3Rpb24gaW5pdFRyZWVJbGx1c3RyYXRvcldpbmRvdygpIHtcbiAgICB2YXIgJG91dGVyRnJhbWUgPSAkKFwiI3Zpei1vdXRlci1mcmFtZVwiKTtcbiAgICB2YXIgJHNjcm9sbGluZ1ZpZXdwb3J0ID0gJG91dGVyRnJhbWUuZmluZCgnZGl2LnZlZ2EnKTtcbiAgICB2YXIgJHJ1bGVyVW5pdHNEaXNwbGF5ID0gJG91dGVyRnJhbWUuZmluZCgnI2ZpeGVkLXJ1bGVyLXVuaXRzJyk7XG4gICAgdmFyICR0b3BSdWxlciA9ICRvdXRlckZyYW1lLmZpbmQoJyNmaXhlZC1ydWxlci10b3AnKTtcbiAgICB2YXIgJGxlZnRSdWxlciA9ICRvdXRlckZyYW1lLmZpbmQoJyNmaXhlZC1ydWxlci1sZWZ0Jyk7XG4gICAgdmFyIHZpZXdwb3J0RWxlbWVudCA9ICRzY3JvbGxpbmdWaWV3cG9ydFswXTtcbiAgICAvL3ZhciBzY3JvbGxiYXJXaWR0aCA9IC5vZmZzZXRXaWR0aCAtIHZpZXdwb3J0RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB2YXIgdG9wUnVsZXJBZGp1c3RlZFdpZHRoID0gdmlld3BvcnRFbGVtZW50ID8gdmlld3BvcnRFbGVtZW50LmNsaWVudFdpZHRoIDogJHRvcFJ1bGVyLndpZHRoKCk7XG4gICAgdmFyIGxlZnRSdWxlckFkanVzdGVkSGVpZ2h0ID0gdmlld3BvcnRFbGVtZW50ID8gdmlld3BvcnRFbGVtZW50LmNsaWVudEhlaWdodCA6ICR0b3BSdWxlci5oZWlnaHQoKTtcblxuICAgICRydWxlclVuaXRzRGlzcGxheS5jc3Moe1xuICAgICAgICAnd2lkdGgnOiBydWxlcldpZHRoICtcInB4XCIsXG4gICAgICAgICdoZWlnaHQnOiBydWxlcldpZHRoICtcInB4XCIsXG4gICAgICAgICdsaW5lLWhlaWdodCc6IHJ1bGVyV2lkdGggK1wicHhcIixcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IE1hdGguZmxvb3IocnVsZXJXaWR0aCAvIDIuNSkgK1wicHhcIlxuICAgIH0pO1xuICAgICR0b3BSdWxlci5jc3Moe1xuICAgICAgICAnaGVpZ2h0JzogcnVsZXJXaWR0aCtcInB4XCIsXG4gICAgICAgIC8vIGFkanVzdCB3aWR0aCBzaW5jZSB0aGVyZSdzIG5vIHNjcm9sbGJhciBoZXJlXG4gICAgICAgICd3aWR0aCc6IHRvcFJ1bGVyQWRqdXN0ZWRXaWR0aCArJ3B4JyxcbiAgICAgICAgJ21hcmdpbi1yaWdodCc6IC1ydWxlcldpZHRoK1wicHhcIlxuICAgIH0pO1xuICAgICRsZWZ0UnVsZXIuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogcnVsZXJXaWR0aCtcInB4XCIsXG4gICAgICAgIC8vIGFkanVzdCBoZWlnaHQgc2luY2UgdGhlcmUncyBubyBzY3JvbGxiYXIgaGVyZVxuICAgICAgICAnaGVpZ2h0JzogbGVmdFJ1bGVyQWRqdXN0ZWRIZWlnaHQgKydweCcsXG4gICAgICAgICdtYXJnaW4tYm90dG9tJzogLXJ1bGVyV2lkdGgrXCJweFwiXG4gICAgfSk7XG4gICAgJHNjcm9sbGluZ1ZpZXdwb3J0LmNzcygnbWFyZ2luLXJpZ2h0JywgLShydWxlcldpZHRoKzEpK1wicHhcIik7XG5cbiAgICAvLyByZXNldCB1bml0cyBkaXNwbGF5OyBjbGVhciBvbGQgcnVsZXJzXG4gICAgJHJ1bGVyVW5pdHNEaXNwbGF5LnRleHQoIGlsbC5zdHlsZS5wcmludFNpemUudW5pdHMoKSA9PT0gVHJlZUlsbHVzdHJhdG9yLnVuaXRzLklOQ0hFUyA/IFwiaW5cIiA6IFwiY21cIiApO1xuXG4gICAgLy8gYWRqdXN0IHZpZXdwb3J0L3ZpZXdib3ggdG8gcmVmbGVjdCBjdXJyZW50IG1hZ25pZmljYXRpb24gKGRpc3BsYXlfcHBpKVxuICAgIHVwZGF0ZVZpZXdwb3J0Vmlld2JveCggJHNjcm9sbGluZ1ZpZXdwb3J0ICk7XG5cbiAgICByZXNldEFjdHVhbFNpemVFbGVtZW50cygpO1xuXG4gICAgLy8gc3luYyBzY3JvbGxpbmcgb2YgcnVsZXJzIHRvIHZpZXdwb3J0XG4gICAgLy9UT0RPOiBkZWxlZ2F0ZSB0aGVzZSBmb3Igb25lLXRpbWUgY2FsbCFcbiAgICAkc2Nyb2xsaW5nVmlld3BvcnQub2ZmKCdzY3JvbGwnKS5vbignc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICR0b3BSdWxlci5zY3JvbGxMZWZ0KCRzY3JvbGxpbmdWaWV3cG9ydC5zY3JvbGxMZWZ0KCkpO1xuICAgICAgICAkbGVmdFJ1bGVyLnNjcm9sbFRvcCgkc2Nyb2xsaW5nVmlld3BvcnQuc2Nyb2xsVG9wKCkpO1xuICAgIH0pO1xuXG4gICAgLy8gc3luYyByZXNpemluZyBvZiBydWxlcnMgdG8gdmlld3BvcnRcbiAgICAvLyAobm8gZXZlbnQgZm9yIHRoaXMgZXhjZXB0IG9uIHRoZSB3aW5kb3csIGl0J3MgYW4gb24tZGVtYW5kIHRoaW5nKVxuICAgIHZhciB2aWV3cG9ydFdpZHRoID0gJHNjcm9sbGluZ1ZpZXdwb3J0WzBdLnNjcm9sbFdpZHRoO1xuICAgIHZhciB2aWV3cG9ydEhlaWdodCA9ICRzY3JvbGxpbmdWaWV3cG9ydFswXS5zY3JvbGxIZWlnaHQ7XG4gICAgdmFyIHRvcFJ1bGVyU2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtcbiAgICAgICAgICAgIHBpeGVsc1RvUGh5c2ljYWxVbml0cyh2aWV3Ym94LngsIGludGVybmFsX3BwaSksXG4gICAgICAgICAgICBwaXhlbHNUb1BoeXNpY2FsVW5pdHModmlld2JveC54ICsgdmlld2JveC53aWR0aCwgaW50ZXJuYWxfcHBpKVxuICAgICAgICBdKVxuICAgICAgICAucmFuZ2UoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHZpZXdwb3J0V2lkdGhcbiAgICAgICAgXSk7XG4gICAgdmFyIHRvcFJ1bGVyID0gZDMuc2VsZWN0KFwiI2ZpeGVkLXJ1bGVyLXRvcCBzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB2aWV3cG9ydFdpZHRoK1wicHhcIilcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcnVsZXJXaWR0aCtcInB4XCIpO1xuICAgIGRyYXdSdWxlcih0b3BSdWxlciwgJ0hPUklaT05UQUwnLCBpbGwuc3R5bGUucHJpbnRTaXplLnVuaXRzKCksIHRvcFJ1bGVyU2NhbGUpO1xuXG4gICAgdmFyIGxlZnRSdWxlclNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbXG4gICAgICAgICAgICBwaXhlbHNUb1BoeXNpY2FsVW5pdHModmlld2JveC55LCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgcGl4ZWxzVG9QaHlzaWNhbFVuaXRzKHZpZXdib3gueSArIHZpZXdib3guaGVpZ2h0LCBpbnRlcm5hbF9wcGkpXG4gICAgICAgIF0pXG4gICAgICAgIC5yYW5nZShbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICAgICAgXSk7XG4gICAgdmFyIGxlZnRSdWxlciA9IGQzLnNlbGVjdChcIiNmaXhlZC1ydWxlci1sZWZ0IHN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJ1bGVyV2lkdGgrXCJweFwiKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB2aWV3cG9ydEhlaWdodCtcInB4XCIpO1xuICAgIGRyYXdSdWxlcihsZWZ0UnVsZXIsICdWRVJUSUNBTCcsIGlsbC5zdHlsZS5wcmludFNpemUudW5pdHMoKSwgbGVmdFJ1bGVyU2NhbGUpO1xuXG4gICAgZW5hYmxlVmlld3BvcnRNYXNrKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QWN0dWFsU2l6ZUVsZW1lbnRzKCkge1xuICAgIC8qIFJlc2l6ZSBhbnkgYWN0dWFsLXNpemVzIGVsZW1lbnRzIChlLmcuIG1hbmlwdWxhdGlvbiBoYW5kbGVzKSBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogTi5CLiBXZSBkbyB0aGlzIGJ5IGludmVydGluZyB0aGUgY3VycmVudCB2aWV3cG9ydCBtYWduaWZpY2F0aW9uLiBTbmVha3khXG4gICAgICovXG4gICAgdmFyIGFjdHVhbFNpemVFbGVtZW50cyA9IGQzLnNlbGVjdEFsbCgnI3Zpei1vdXRlci1mcmFtZSAuYWN0dWFsLXNpemUgcGF0aCcpO1xuICAgIGFjdHVhbFNpemVFbGVtZW50cy5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBkYXR1bSBmcm9tIHBoeWxvZ3JhbSBtb2RlbCwgZS5nLiB2ZXJ0ZXhIYW5kbGVzWzBdXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIisgKGQuZGF0dW0ueCB8fCAwKSArXCIsXCIrIChkLmRhdHVtLnkgfHwgMCkgK1wiKSBzY2FsZShcIisgKDEgLyB2aWV3cG9ydE1hZ25pZmljYXRpb24pICtcIilcIjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcm91bmRUb05lYXJlc3QoIGludGVydmFsLCBpbnB1dCApIHtcbiAgICAvLyByb3VuZCB0byBzb21ldGhpbmcgbW9yZSBpbnRlcmVzdGluZyB0aGFuIFwiYW55IGludGVnZXJcIlxuICAgIC8vIEVYQU1QTEU6IHJvdW5kVG9OZWFyZXN0KCAwLjEyNSwgLTAuNTIgKSA9PT4gIC0wLjVcbiAgICAvLyBFWEFNUExFOiByb3VuZFRvTmVhcmVzdCggNywgNDYgKSA9PT4gIDQ5XG4gICAgcmV0dXJuIE1hdGgucm91bmQoaW5wdXQgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbDtcbn1cblxuZnVuY3Rpb24gZHJhd1J1bGVyKCBzdmdQYXJlbnQsIG9yaWVudGF0aW9uLCB1bml0cywgc2NhbGUgKSB7XG4gICAgLyogRHJhdyBhIHJ1bGVyIGluIHRoZSBjaG9zZW4gY29udGV4dCAoYXNzdW1lcyBTVkcgb3IgY2hpbGQgb2YgYW4gU1ZHKSwgd2l0aFxuICAgICAgICAtIGFwcHJvcHJpYXRlIHVuaXRzXG4gICAgICAgIC0gc2Vuc2libGUvbGVnaWJsZSBzdWJ0aWNrcyAoZWcsIG1pbGxpbWV0ZXJzIG9yIHNpeHRlZW50aHMgb2YgYW4gaW5jaCkgXG4gICAgICAgIC0gc2l6ZSBhbmQgYWRqdXN0IGJhc2VkIG9uIG9yaWVudGF0aW9uIChIT1JJWk9OVEFMIHwgVkVSVElDQUwpXG4gICAgICovXG4gICAgLy8gY2xlYXIgYW55IHByaW9yIHJ1bGVyIGdyb3VwXG4gICAgc3ZnUGFyZW50LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgIHZhciBudWRnZVRvcCA9IG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gMCA6IHJ1bGVyV2lkdGggLSAxO1xuICAgIHZhciBudWRnZUxlZnQgPSBvcmllbnRhdGlvbiA9PT0gJ1ZFUlRJQ0FMJyA/IHJ1bGVyV2lkdGggLSAxIDogMDtcblxuICAgIHZhciBydWxlckF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgLnRpY2tWYWx1ZXMoZDMucmFuZ2UoXG4gICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgxLjAsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgxLjAsIHNjYWxlLmRvbWFpbigpWzFdICsgMSksIFxuICAgICAgICAgICAgMSkpXG4gICAgICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnZCcpKSAgLy8gd2hvbGUgbnVtYmVyc1xuICAgICAgICAub3JpZW50KCBvcmllbnRhdGlvbiA9PT0gJ1ZFUlRJQ0FMJyA/ICdsZWZ0JyA6ICd0b3AnICk7XG5cbiAgICBzdmdQYXJlbnRcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzJylcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgIC5jYWxsKHJ1bGVyQXhpcyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdJTkNIRVMnKSB7XG4gICAgICAgIC8vIHRyeWluZyBzdWJ0aWNrcywgdXNpbmcgYWRkaXRpb25hbCBheGVzIG9uIHRoZSBzYW1lIHNjYWxlXG4gICAgICAgIHZhciBpbmNoV2lkdGggPSBpbmNoZXNUb1BpeGVscygxLCBkaXNwbGF5X3BwaSk7XG4gICAgICAgIHN1YnRpY2tzQXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgIC50aWNrVmFsdWVzKGQzLnJhbmdlKFxuICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuNSwgc2NhbGUuZG9tYWluKClbMF0pLCBcbiAgICAgICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgwLjUsIHNjYWxlLmRvbWFpbigpWzFdKSwgXG4gICAgICAgICAgICAgICAgMC41KSlcbiAgICAgICAgICAgIC50aWNrRm9ybWF0KCcnKSAvLyB1bmxhYmVsZWRcbiAgICAgICAgICAgIC50aWNrU2l6ZSg2KVxuICAgICAgICAgICAgLm9yaWVudCggb3JpZW50YXRpb24gPT09ICdWRVJUSUNBTCcgPyAnbGVmdCcgOiAndG9wJyApO1xuICAgICAgICBzdmdQYXJlbnRcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsJ291dGVyLWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuXG4gICAgICAgIHN1YnRpY2tzQXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgIC50aWNrVmFsdWVzKGQzLnJhbmdlKFxuICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuMjUsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4yNSwgc2NhbGUuZG9tYWluKClbMV0pLCBcbiAgICAgICAgICAgICAgICAwLjI1KSlcbiAgICAgICAgICAgIC50aWNrRm9ybWF0KCcnKSAvLyB1bmxhYmVsZWRcbiAgICAgICAgICAgIC50aWNrU2l6ZSg0KVxuICAgICAgICAgICAgLm9yaWVudCggb3JpZW50YXRpb24gPT09ICdWRVJUSUNBTCcgPyAnbGVmdCcgOiAndG9wJyApO1xuICAgICAgICBzdmdQYXJlbnRcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsJ291dGVyLWF4aXMgc3VidGlja3MnKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIG51ZGdlTGVmdCArXCIsIFwiKyBudWRnZVRvcCArXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuXG4gICAgICAgIGlmIChpbmNoV2lkdGggPiAyMCkge1xuICAgICAgICAgICAgc3VidGlja3NBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyhkMy5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4xMjUsIHNjYWxlLmRvbWFpbigpWzBdKSwgXG4gICAgICAgICAgICAgICAgICAgIHJvdW5kVG9OZWFyZXN0KDAuMTI1LCBzY2FsZS5kb21haW4oKVsxXSksIFxuICAgICAgICAgICAgICAgICAgICAwLjEyNSkpXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoJycpIC8vIHVubGFiZWxlZFxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgyKVxuICAgICAgICAgICAgICAgIC5vcmllbnQoIG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gJ2xlZnQnIDogJ3RvcCcgKTtcbiAgICAgICAgICAgIHN2Z1BhcmVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzIHN1YnRpY2tzJylcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgbnVkZ2VMZWZ0ICtcIiwgXCIrIG51ZGdlVG9wICtcIilcIilcbiAgICAgICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJhdyB0aWNrcyBmb3IgbWlsbGltZXRlcnNcbiAgICAgICAgdmFyIGNtV2lkdGggPSBjZW50aW1ldGVyc1RvUGl4ZWxzKDEsIGRpc3BsYXlfcHBpKTtcbiAgICAgICAgaWYgKGNtV2lkdGggPiAzMCkge1xuICAgICAgICAgICAgc3VidGlja3NBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyhkMy5yYW5nZShcbiAgICAgICAgICAgICAgICAgICAgcm91bmRUb05lYXJlc3QoMC4xLCBzY2FsZS5kb21haW4oKVswXSksIFxuICAgICAgICAgICAgICAgICAgICByb3VuZFRvTmVhcmVzdCgwLjEsIHNjYWxlLmRvbWFpbigpWzFdKSwgXG4gICAgICAgICAgICAgICAgICAgIDAuMSkpXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoJycpIC8vIHVubGFiZWxlZFxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgzKVxuICAgICAgICAgICAgICAgIC5vcmllbnQoIG9yaWVudGF0aW9uID09PSAnVkVSVElDQUwnID8gJ2xlZnQnIDogJ3RvcCcgKTtcbiAgICAgICAgICAgIHN2Z1BhcmVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCdvdXRlci1heGlzIHN1YnRpY2tzJylcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgbnVkZ2VMZWZ0ICtcIiwgXCIrIG51ZGdlVG9wICtcIilcIilcbiAgICAgICAgICAgICAgICAuY2FsbChzdWJ0aWNrc0F4aXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgdG9wQmFySGVpZ2h0O1xuZnVuY3Rpb24gbWF0Y2hWaWV3cG9ydFRvV2luZG93U2l6ZSgpIHtcbiAgICBpZiAoIXRvcEJhckhlaWdodCkge1xuICAgICAgICB0b3BCYXJIZWlnaHQgPSAkKCcjdG9wLWJhcicpLmhlaWdodCgpO1xuICAgICAgICAvLyBmcmVlemUgdGhlIGNvbnRyb2wgYmFyIGF0IGl0cyBjdXJyZW50IGhlaWdodCAgICAgICAgXG4gICAgICAgICQoJyN0b3AtYmFyJykuaGVpZ2h0KHRvcEJhckhlaWdodCk7XG4gICAgfVxuICAgIHZhciBjb2x1bW5IZWlnaHQgPSAkKCcjc3RpY2t5LXZpZXdlci1mcmFtZScpLmhlaWdodCgpO1xuICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSBjb2x1bW5IZWlnaHQgLSB0b3BCYXJIZWlnaHQ7XG4gICAgdmFyICRvdXRlckZyYW1lID0gJChcIiN2aXotb3V0ZXItZnJhbWVcIik7XG4gICAgdmFyIG51ZGdlID0gLTM2OyAgLy8gYWxsb3cgZm9yIHNjcm9sbGJhcnMsIGV0Yy5cbiAgICAkb3V0ZXJGcmFtZS5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0ICsgbnVkZ2UpO1xuXG4gICAgLy8gYWRqdXN0IHdpZHRoIGJhc2VkIG9uIHBvc2l0aW9uIG9mIHNpZGVjYXJcbiAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAkKCcjc2lkZWNhcicpLm9mZnNldCgpLmxlZnQ7XG4gICAgbnVkZ2UgPSAtMjg7ICAvLyBhbGxvdyBmb3Igc2Nyb2xsYmFycywgZXRjLlxuICAgICRvdXRlckZyYW1lLndpZHRoKGF2YWlsYWJsZVdpZHRoICsgbnVkZ2UpO1xufVxuXG52YXIgdmlld3BvcnRNYWduaWZpY2F0aW9uID0gMS4wO1xuZnVuY3Rpb24gem9vbVZpZXdwb3J0KCBkaXJlY3Rpb25Pclpvb21MZXZlbCApIHtcbiAgICAvLyBsZXQncyB1c2Ugc2ltcGxlLCBwcm9wb3J0aW9uYWwgc3RlcHMgdXAgYW5kIGRvd25cbiAgICB2YXIgc3RlcFVwID0gMS4yNTtcbiAgICB2YXIgc3RlcERvd24gPSAwLjg7ICAvLyBzaG91bGQgYmUgaW52ZXJzZSBvZiBzdGVwVXBcbiAgICB2YXIgcHJldmlvdXNNYWduaWZpY2F0aW9uID0gdmlld3BvcnRNYWduaWZpY2F0aW9uO1xuXG4gICAgc3dpdGNoKGRpcmVjdGlvbk9yWm9vbUxldmVsKSB7XG4gICAgICAgIGNhc2UgJ1JFRlJFU0gnOlxuICAgICAgICAgICAgLy8ganVzdCB1cGRhdGUgYXQgdGhlIGN1cnJlbnQgbWFnbmlmaWNhdGlvbiAoZS5nLiB3aGVuIHdpbmRvdyBpcyByZXNpemVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lOJzpcbiAgICAgICAgICAgIHZpZXdwb3J0TWFnbmlmaWNhdGlvbiAqPSBzdGVwVXA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT1VUJzpcbiAgICAgICAgICAgIHZpZXdwb3J0TWFnbmlmaWNhdGlvbiAqPSBzdGVwRG93bjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiBcbiAgICAgICAgICAgIC8vIGFzc3VtZSBpdCdzIGFuIGV4cGxpY2l0IHpvb20gbGV2ZWwsIHdoZXJlIDEuMCBtZWFucyBcImFjdHVhbCBzaXplXCJcbiAgICAgICAgICAgIHZpZXdwb3J0TWFnbmlmaWNhdGlvbiA9IGRpcmVjdGlvbk9yWm9vbUxldmVsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRpc3BsYXlfcHBpID0gaW50ZXJuYWxfcHBpICogdmlld3BvcnRNYWduaWZpY2F0aW9uO1xuICAgICQoJyNkaXNwbGF5LXBwaS1pbmRpY2F0b3InKS50ZXh0KGRpc3BsYXlfcHBpKTtcblxuICAgIC8vIFRPRE86IHJlc2V0IGNlbnRlciBwb2ludCBvZiB2aWV3Ym94PyBiYXNlZCBvbiBjbGljayBYWSwgb3IgY3VycmVudCBjZW50ZXI/XG4gICAgLy8gVE9ETzogdXBkYXRlIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB0byBzdGF5IGluIHBsYWNlP1xuXG4gICAgaW5pdFRyZWVJbGx1c3RyYXRvcldpbmRvdygpO1xufVxuXG4vKiBNYW5hZ2UgaGFuZGxlcyAoZW1iZWQvcmVtb3ZlIFNWRykgZm9yIGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgdHJlZXMsIGV0Yy5cbiAqIENVUlJFTlRMWSBVTlVTRUQhIGluIGZhdm9yIG9mIFwiaW5saW5lXCIgaGFuZGxlcyBmb3IgZWFjaCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBhZGRFbGVtZW50SGFuZGxlcygpIHtcbiAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgaWYgKHZpZXdwb3J0U1ZHLmVtcHR5KCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiYWRkRWxlbWVudEhhbmRsZXMoKTogdmlld3BvcnQgU1ZHIG5vdCBmb3VuZCFcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI2hhbmRsZXNcIikuZW1wdHkoKSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBsaW5rZWQgaW5zdGFuY2Ugb2YgaGFuZGxlc1xuICAgICAgICB2aWV3cG9ydFNWRy5pbnNlcnQoJ3VzZScsICdzdmcgPiBnJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnaGFuZGxlcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3hsaW5rOmhyZWYnLCAnI21hbmlwdWxhdGlvbi1oYW5kbGVzJyk7XG4gICAgfVxuICAgIC8vIFRPRE86IGNsZWFyIGFuZCAocmUpYnVpbGQgaGFuZGxlcyBmb3IgYWxsIGFjdGl2ZSBlbGVtZW50cz9cbn1cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRIYW5kbGVzKCkge1xuICAgIC8vIENVUlJFTlRMWSBVTlVTRURcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjaGFuZGxlc1wiKS5yZW1vdmUoKTtcbn1cblxuLyogQ29udmVydCBiZXR3ZWVuIGludGVybmFsIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCBoYW5kbGUgb3ZlcmxheSAoYSBzZWNvbmRcbiAqIFNWRyB3aXRoIFVJIGZvciBkaXJlY3QgbWFuaXB1bGF0aW9uIG9mIHRyZWVzLCBldGMuKVxuICovXG5mdW5jdGlvbiBpbnRlcm5hbFVuaXRzVG9PdmVybGF5UGl4ZWxzKCBjb29yZHMgKSB7XG4gICAgY29uc29sZS5sb2coXCJkaXNwbGF5X3BwaTogXCIrIGRpc3BsYXlfcHBpKTtcbiAgICBhc3NlcnQoKCgneCcgaW4gY29vcmRzKSAmJiAoJ3knIGluIGNvb3JkcykpLFxuICAgICAgICAgICBcIkluY29taW5nIG9iamVjdCBzaG91bGQgaW5jbHVkZSAneCcgYW5kICd5JyBwcm9wZXJ0aWVzLlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBjb29yZHMueCAqIGRpc3BsYXlfcHBpLFxuICAgICAgICB5OiBjb29yZHMueSAqIGRpc3BsYXlfcHBpIFxuICAgIH07XG59XG5mdW5jdGlvbiBvdmVybGF5UGl4ZWxzVG9JbnRlcm5hbFVuaXRzKGNvb3Jkcykge1xuICAgIGNvbnNvbGUubG9nKFwiZGlzcGxheV9wcGk6IFwiKyBkaXNwbGF5X3BwaSk7XG4gICAgYXNzZXJ0KCgoJ3gnIGluIGNvb3JkcykgJiYgKCd5JyBpbiBjb29yZHMpKSxcbiAgICAgICAgICAgXCJJbmNvbWluZyBvYmplY3Qgc2hvdWxkIGluY2x1ZGUgJ3gnIGFuZCAneScgcHJvcGVydGllcy5cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY29vcmRzLnggLyBkaXNwbGF5X3BwaSxcbiAgICAgICAgeTogY29vcmRzLnkgLyBkaXNwbGF5X3BwaSBcbiAgICB9O1xufVxuXG5mdW5jdGlvbiByZXNpemVWaWV3cG9ydFRvU2hvd0FsbCgpIHtcbiAgICAvLyBzaG93IGZ1bGwgaWxsdXN0cmF0aW9uIGJvdW5kcyAoYW5kIGFsbCBTVkcgZWxlbWVudHMhKSBpbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgYmJveCA9IGdldEluY2x1c2l2ZUlsbHVzdHJhdGlvbkJvdW5kaW5nQm94KCk7XG5cbiAgICAvLyBtYXRjaCB0aGUgdmlld3BvcnQncyBwcm9wb3J0aW9ucyAod2lkdGgvaGVpZ2h0KVxuICAgIHZhciAkdmlld3BvcnQgPSAkKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYVwiKTtcbiAgICAvLyBOT1RFIHRoYXQgd2Ugd2FudCB0byBtYXRjaCBpdHMgKmlubmVyKiBzaXplLCBub3QgaW5jbC4gc2Nyb2xsYmFycyFcbiAgICB2YXIgZGl2V2lkdGggPSAkdmlld3BvcnRbMF0uY2xpZW50V2lkdGg7XG4gICAgdmFyIGRpdkhlaWdodCA9ICR2aWV3cG9ydFswXS5jbGllbnRIZWlnaHQ7XG4gICAgLy8gY29tcGFyZSBpdHMgcHJvcG9ydGlvbnMgdG8gb3VyIGJvdW5kaW5nIGJveDsgcGFkIGFzIG5lZWRlZCB0byBtYXRjaFxuICAgIC8vIFRPRE86IHRoaXMgaXMgZHVwbGljYXRlIGNvZGUhIHJlZmFjdG9yIHRvIERSWVxuICAgIHZhciBkaXZQcm9wb3J0aW9ucyA9IGRpdldpZHRoIC8gZGl2SGVpZ2h0O1xuICAgIHZhciBiYm94UHJvcG9ydGlvbnMgPSBiYm94LndpZHRoIC8gYmJveC5oZWlnaHQ7XG4gICAgaWYgKGRpdlByb3BvcnRpb25zID4gYmJveFByb3BvcnRpb25zKSB7XG4gICAgICAgIC8vIGRpdiBpcyB3aWRlciwgcGFkIGJib3ggd2lkdGggdG8gbWF0Y2hcbiAgICAgICAgdmFyIGFkanVzdGVkV2lkdGggPSBkaXZQcm9wb3J0aW9ucyAqIGJib3guaGVpZ2h0O1xuICAgICAgICB2YXIgZXh0cmFXaWR0aCA9IGFkanVzdGVkV2lkdGggLSBiYm94LndpZHRoO1xuICAgICAgICBiYm94LndpZHRoID0gYWRqdXN0ZWRXaWR0aDtcbiAgICAgICAgYmJveC54IC09IChleHRyYVdpZHRoIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGl2IGlzIHRhbGxlciAob3IgZXF1YWwpLCBwYWQgYmJveCBoZWlnaHQgdG8gbWF0Y2hcbiAgICAgICAgdmFyIGZsaXBwZWREaXZQcm9wb3J0aW9ucyA9IGRpdkhlaWdodCAvIGRpdldpZHRoO1xuICAgICAgICB2YXIgYWRqdXN0ZWRIZWlnaHQgPSBmbGlwcGVkRGl2UHJvcG9ydGlvbnMgKiBiYm94LndpZHRoO1xuICAgICAgICB2YXIgZXh0cmFIZWlnaHQgPSBhZGp1c3RlZEhlaWdodCAtIGJib3guaGVpZ2h0O1xuICAgICAgICBiYm94LmhlaWdodCA9IGFkanVzdGVkSGVpZ2h0O1xuICAgICAgICBiYm94LnggLT0gKGV4dHJhSGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgLy8gY29weSB0byBvdXIgcGVyc2lzdGVudCB2aWV3Ym94XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiYm94KSB7XG4gICAgICAgIHZpZXdib3hbcHJvcF0gPSBiYm94W3Byb3BdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG1hdGNoIHRoZSB2aWV3cG9ydCdzIGZpbmFsIHNpemUgKGRpc2FibGVkIHNjcm9sbGJhcnMpP1xuICAgIFxuICAgIC8qIFNjYWxlIHRoZSBwcm9wb3J0aW9uYWwgU1ZHIHRvIGZpdCB0aGUgdmlld3BvcnQgRElWLiBUbyBkbyB0aGlzLCB3ZVxuICAgICAqIGRldGVybWluZSBob3cgYmlnIHRoZSBuZXcgdmlld2JveCB3b3VsZCBiZSBpbiBwaXhlbHMgKHVzaW5nIGRlZmF1bHRfcHBpKVxuICAgICAqIGFuZCBtYWduaWZ5IHRoaXMgdG8gZml0IHRoZSB2aWV3cG9ydERJVi5cbiAgICAgKi9cbiAgICB2YXIgbmV3TWFnbmlmaWNhdGlvbiA9IGRpdldpZHRoIC8gdmlld2JveC53aWR0aDtcbiAgICAvLyB1cGRhdGUgdGhlIGRpc3BsYXlcbiAgICB6b29tVmlld3BvcnQoIG5ld01hZ25pZmljYXRpb24gKTsgIC8vIGNhbGxzIGluaXRUcmVlSWxsdXN0cmF0b3JXaW5kb3coKTtcbn1cbmZ1bmN0aW9uIGdldE1pbmltYWxJbGx1c3RyYXRpb25Cb3VuZGluZ0JveCgpIHtcbiAgICAvLyBSZXR1cm4ganVzdCB0aGUgcmVnaW9uIGRlZmluZWQgZm9yIHByaW50aW5nIChjb3B5aW5nIGl0cyBwcm9wZXJ0aWVzXG4gICAgLy8gdG8gYSBzaW1wbGUgT2JqZWN0LCB0byBwcmV2ZW50IE5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yIGluIElFKVxuICAgIHZhciBiYm94ID0gJCgnI2lsbHVzdHJhdGlvbi1iYWNrZ3JvdW5kJylbMF0uZ2V0QkJveCgpO1xuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYmJveCk7XG59XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVJbGx1c3RyYXRpb25Cb3VuZGluZ0JveCgpIHtcbiAgICAvLyBGZXRjaCB0aGUgcmVnaW9uIGRlZmluZWQgZm9yIHByaW50aW5nLCBQTFVTIGFueSBcIm91dCBvZiBib3VuZHNcIiBTVkdcbiAgICAvLyBlbGVtZW50cy4gQWdhaW4sIHdlJ2xsIGNvcHlpbmcgaXRzIHByb3BlcnRpZXMgdG8gYSBzaW1wbGUgT2JqZWN0LCB0b1xuICAgIC8vIHByZXZlbnQgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgaW4gSUUuXG4gICAgdmFyIGJib3ggPSBkMy5zZWxlY3QoJ2cuaWxsdXN0cmF0aW9uLWVsZW1lbnRzJykubm9kZSgpLmdldEJCb3goKTtcbiAgICAvKiBSRU1JTkRFUjogVGhpcyBkZXNpZ25hdGVkIGdyb3VwIHNob3VsZCBjb250YWluIGFsbCBpbGx1c3RyYXRpb24gZWxlbWVudHNcbiAgICAgICBhbmQgYW4gaW52aXNpYmxlIGJveCBtYXRjaGluZyB0aGUgcHJpbnRlZCBhcmVhLiAqL1xuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYmJveCk7XG59XG5mdW5jdGlvbiBnZXREaWFnbm9zdGljQm91bmRpbmdCb3goKSB7XG4gICAgLy8gZ2F0aGVyIG91dGVybW9zdCBib3VuZHMgYmFzZWQgb24gZGlhZ25vc3RpYyBlbGVtZW50cyBmb3VuZFxuICAgIHZhciBiYm94ID0gZ2V0TWluaW1hbElsbHVzdHJhdGlvbkJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0KFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgdmFyIHJ1bGVycyA9IHZpZXdwb3J0U1ZHLnNlbGVjdChcIiNydWxlcnNcIikubm9kZSgpO1xuICAgIGlmIChydWxlcnMpIHtcbiAgICAgICAgYmJveCA9IGdldENvbWJpbmVkQm91bmRpbmdCb3goIGJib3gsIHJ1bGVycy5nZXRCQm94KCkgKTtcbiAgICB9XG4gICAgdmFyIGNyb3BtYXJrcyA9IHZpZXdwb3J0U1ZHLnNlbGVjdChcIiNjcm9wLW1hcmtzXCIpLm5vZGUoKTtcbiAgICBpZiAoY3JvcG1hcmtzKSB7XG4gICAgICAgIGJib3ggPSBnZXRDb21iaW5lZEJvdW5kaW5nQm94KCBiYm94LCBjcm9wbWFya3MuZ2V0QkJveCgpICk7XG4gICAgfVxuICAgIHZhciBkZXNjcmlwdGlvbiA9IHZpZXdwb3J0U1ZHLnNlbGVjdChcIiNkZXNjcmlwdGlvblwiKS5ub2RlKCk7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGJib3ggPSBnZXRDb21iaW5lZEJvdW5kaW5nQm94KCBiYm94LCBkZXNjcmlwdGlvbi5nZXRCQm94KCkgKTtcbiAgICB9XG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBiYm94KTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkQm91bmRpbmdCb3goIGJveDEsIGJveDIgKSB7XG4gICAgLy8gcmVja29uIHRoZSBcInVuaW9uXCIgb2YgdHdvIGJvdW5kaW5nIGJveGVzXG4gICAgdmFyIGJib3ggPSAkLmV4dGVuZCh7fSwgYm94MSk7XG4gICAgLy8gY29tcGFyZSAob2J2aW91cykgbGVmdCBhbmQgdG9wIGV4dGVudHNcbiAgICB2YXIgYmJveExlZnQgPSBiYm94Lng7XG4gICAgdmFyIGJveDJMZWZ0ID0gYm94Mi54O1xuICAgIGlmIChib3gyTGVmdCA8IGJib3hMZWZ0KSB7XG4gICAgICAgIC8vIGluY3JlYXNlIHdpZHRoLCB0aGVuIHJlc2V0IGxlZnQgZWRnZVxuICAgICAgICBiYm94LndpZHRoID0gYmJveC53aWR0aCArIChiYm94TGVmdCAtIGJveDJMZWZ0KTtcbiAgICAgICAgYmJveC54ID0gYm94MkxlZnQ7XG4gICAgfVxuICAgIHZhciBiYm94VG9wID0gYmJveC55O1xuICAgIHZhciBib3gyVG9wID0gYm94Mi55O1xuICAgIGlmIChib3gyVG9wIDwgYmJveFRvcCkge1xuICAgICAgICAvLyBpbmNyZWFzZSBoZWlnaHQsIHRoZW4gcmVzZXQgdG9wIGVkZ2VcbiAgICAgICAgYmJveC5oZWlnaHQgPSBiYm94LmhlaWdodCArIChiYm94VG9wIC0gYm94MlRvcCk7XG4gICAgICAgIGJib3gueSA9IGJveDJUb3A7XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgKGltcGxpY2l0KSByaWdodCBhbmQgYm90dG9tIGV4dGVudHNcbiAgICB2YXIgYmJveFJpZ2h0ID0gYmJveC54ICsgYmJveC53aWR0aDtcbiAgICB2YXIgYm94MlJpZ2h0ID0gYm94Mi54ICsgYm94Mi53aWR0aDtcbiAgICBpZiAoYm94MlJpZ2h0ID4gYmJveFJpZ2h0KSB7XG4gICAgICAgIGJib3gud2lkdGggPSBib3gyUmlnaHQgLSBiYm94Lng7XG4gICAgfVxuICAgIHZhciBiYm94Qm90dG9tID0gYmJveC55ICsgYmJveC5oZWlnaHQ7XG4gICAgdmFyIGJveDJCb3R0b20gPSBib3gyLnkgKyBib3gyLmhlaWdodDtcbiAgICBpZiAoYm94MkJvdHRvbSA+IGJib3hCb3R0b20pIHtcbiAgICAgICAgYmJveC5oZWlnaHQgPSBib3gyQm90dG9tIC0gYmJveC55O1xuICAgIH1cbiAgICByZXR1cm4gYmJveDtcbn1cblxuLyogQW5ub3lpbmcgYnJvd3NlciBxdWlyayEgRmlyZWZveC9NYWMgKGFuZCBwb3NzaWJseSBvdGhlcnM/KSBoYXZlIGRpZmZlcmVudCBTVkdcbiAqIG1hc2tpbmcgYmVoYXZpb3IsIHdoZXJlIHRoZSBtYXNrIGl0c2VsZiBtdXN0IHRyYW5zZm9ybSBhbG9uZyB3aXRoIHRoZSBTVkcgaXQgaXNcbiAqIG1hc2tpbmcuIEluIHRoZXNlIGNhc2VzLCB3ZSBuZWVkIHRvIG1hdGNoIHNjYWxlIGFuZCBcImludmVydFwiIFggYW5kIFlcbiAqIHBvc2l0aW9uIG9mIHRoZSBtYXNrLlxuICovXG52YXIgc3ZnTWFza1JlcXVpcmVzVHJhbnNmb3JtID0gJC5icm93c2VyLm1vemlsbGE7ICAvLyAgJiYgJC5icm93c2VyLnZlcnNpb24gPCBcIjM1XCI7XG4vKiBOT1RFIHRoYXQgdGVzdCB0aGlzIHdpbGwgZmFpbCB3aGVuIHdlIHVwZ3JhZGUgdG8galF1ZXJ5IDEuOSshIEluIHRoYXQgY2FzZSwgY29uc2lkZXI6XG4gICAgKiB0aGUgalF1ZXJ5IE1pZ3JhdGUgcGx1Z2luIG9yIHRoaXMgc25pcHBldDpcbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LW1pZ3JhdGUvYmxvYi9lNmJkYTZhODRjMjk0ZWIxMzE5ZmNlYjQ4YzA5ZjUxMDQyYzgwODkyL3NyYy9jb3JlLmpzI0w1MFxuICAgICogTW9kZXJuaXpyICh0aG91Z2ggaXQgZG9lc24ndCBzZWVtIHRvIGRldGVjdCB0aGlzIHBhcnRpY3VsYXIgcXVpcmspXG4gICAgKiBzbmlmZmluZyB0aGUgSlMgJ25hdmlnYXRvcicgb2JqZWN0IGZvciBtb3JlIGluZm9ybWF0aW9uICBcbiAqL1xuXG4vKiBNYW5hZ2UgcmUtdXNhYmxlIFNWRyBlbGVtZW50cyBpbiB0aGUgdmlld3BvcnQuIFRoZXNlIGFyZSB0eXBpY2FsbHkgZGVmaW5lZFxuICAgaW4gYSBwZXJzaXN0ZW50IFNWRyBkZWZzIGVsZW1lbnQsIHdoZXJlIHRoZXkgY2FuIGJlIG1vZGlmaWVkIGFuZCByZS11c2VkXG4gICAoaW5jbHVkaW5nIG11bHRpcGxlIGluc3RhbmNlcykgZm9yIG1hc2tpbmcsIGNsaXBwaW5nLCBhbmQgb3B0aW9uYWwgcHJpbnRlZFxuICAgb3V0cHV0IGxpa2UgY3JvcCBtYXJrcyBhbmQgZGlhZ25vc3RpYyBydWxlcnMuXG5cbiAgIE5PVEUgdGhhdCB3ZSBuZWVkIHRvIHVzZSBkMyB0byBjcmVhdGUgU1ZHIGVsZW1lbnRzLiBqUXVlcnkgZmx1YnMgdGhlXG4gICBuYW1lc3BhY2VzIVxuKi9cbmZ1bmN0aW9uIGVuYWJsZVZpZXdwb3J0TWFzaygpIHtcbiAgICAvL3ZhciB0b29sYm94U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3N2Zy10b29sYm94XCIpO1xuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdEFsbChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIGlmICh2aWV3cG9ydFNWRy5lbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImVuYWJsZVZpZXdwb3J0TWFzaygpOiB2aWV3cG9ydCBTVkcgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXNrID0gZDMuc2VsZWN0KCcjdmlld3BvcnQtbWFzaycpO1xuXG4gICAgaWYgKHN2Z01hc2tSZXF1aXJlc1RyYW5zZm9ybSkge1xuICAgICAgICAvLyBzZXQgZXhwbGljaXQgc2l6ZSBhbmQgc2NhbGUgZm9yIHRoZSB2aWV3cG9ydCBtYXNrIGl0c2VsZlxuICAgICAgICBkMy5zZWxlY3QoXCIjdmlld3BvcnQtbWFza1wiKVxuICAgICAgICAgICAgLmF0dHIoJ21hc2tVbml0cycsICd1c2VyU3BhY2VPblVzZScpXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB2aWV3Ym94LndpZHRoICogdmlld3BvcnRNYWduaWZpY2F0aW9uKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHZpZXdib3guaGVpZ2h0ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICAgICAgLy8gc2NhbGUgdGhlIG1hc2sgIT8gc2VlbXMgdG8gYmUgcmVxdWlyZWQgZm9yIEZGL01hYywgYXQgbGVhc3RcbiAgICAgICAgdmFyIG1hc2tHcm91cFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJysgLSh2aWV3Ym94LnggKiB2aWV3cG9ydE1hZ25pZmljYXRpb24pICsnLCcrIC0odmlld2JveC55ICogdmlld3BvcnRNYWduaWZpY2F0aW9uKSArJykgc2NhbGUoJysgdmlld3BvcnRNYWduaWZpY2F0aW9uICsnKSc7XG4gICAgICAgIC8vY29uc29sZS5sb2cobWFza0dyb3VwVHJhbnNmb3JtKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI21hc2stc2hhcGVzXCIpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgbWFza0dyb3VwVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBtYXRjaCB0aGUgbWFzaydzIHZpZXdwb3J0LWJvdW5kcyB0byB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplXG4gICAgZDMuc2VsZWN0KFwiI3ZpZXdwb3J0LWJvdW5kc1wiKVxuICAgICAgICAuYXR0cigneCcsIHZpZXdib3gueClcbiAgICAgICAgLmF0dHIoJ3knLCB2aWV3Ym94LnkpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHZpZXdib3gud2lkdGgpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCB2aWV3Ym94LmhlaWdodCk7XG4gICAgLy8gbWF0Y2ggdGhlIG1hc2sncyBpbGx1c3RyYXRpb24tYm91bmRzIHRvIHRoZSBjdXJyZW50IGlsbHVzdHJhdGlvbiBzaXplXG4gICAgZDMuc2VsZWN0KFwiI2lsbHVzdHJhdGlvbi1ib3VuZHNcIilcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHBoeXNpY2FsVW5pdHNUb1BpeGVscyhpbGwuc3R5bGUucHJpbnRTaXplLndpZHRoKCksIGludGVybmFsX3BwaSkpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoKSwgaW50ZXJuYWxfcHBpKSk7XG5cbiAgICAvLyBhc3NpZ24gdGhlIG1hc2sgdG8gdGhlIG1haW4gdmlld3BvcnQgKGZhZGVzIHN0dWZmIG91dHNpZGUgdGhlIHByaW50IGFyZWEpXG4gICAgdmlld3BvcnRTVkcuYXR0cignbWFzaycsICd1cmwoI3ZpZXdwb3J0LW1hc2spJyk7XG5cbiAgICBpZiAodmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI3ZpZXdwb3J0LWJhY2tncm91bmRcIikuZW1wdHkoKSkge1xuICAgICAgICAvLyBhZGQgbWlsZGVyIGJhY2tkcm9wIGZvciB3b3JrIGFyZWEgKG91dHNpZGUgdGhlIHByaW50IGFyZWEpXG4gICAgICAgIHZpZXdwb3J0U1ZHLmluc2VydCgncmVjdCcsICdzdmcgPiBnJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAndmlld3BvcnQtYmFja2dyb3VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJyNjY2MnKTtcbiAgICAgICAgLy8gYWRkIGEgd2hpdGUgYmFja2dyb3VuZCBmb3IgdGhlIHByaW50IGFyZWFcbiAgICAgICAgdmlld3BvcnRTVkcuaW5zZXJ0KCd1c2UnLCAnc3ZnID4gZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2lsbHVzdHJhdGlvbi1iYWNrZ3JvdW5kJylcbiAgICAgICAgICAgICAgICAuYXR0cigneGxpbms6aHJlZicsICcjaWxsdXN0cmF0aW9uLWJvdW5kcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCcjYmJiJyk7XG4gICAgfVxuICAgIGQzLnNlbGVjdCgnI3ZpZXdwb3J0LWJhY2tncm91bmQnKVxuICAgICAgICAuYXR0cigneCcsIHZpZXdib3gueClcbiAgICAgICAgLmF0dHIoJ3knLCB2aWV3Ym94LnkpO1xuICAgIHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiN2aWV3cG9ydC1iYWNrZ3JvdW5kLCAjaWxsdXN0cmF0aW9uLWJhY2tncm91bmRcIilcbiAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG59XG5mdW5jdGlvbiBkaXNhYmxlVmlld3BvcnRNYXNrKCkge1xuICAgIC8vIHJlbW92ZSBhbmQgY2xlYW4gdXAgbWFza2luZyBzdHVmZiAocHJpb3IgdG8gcHJpbnRpbmc/KVxuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdEFsbChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIHZpZXdwb3J0U1ZHLmF0dHIoJ21hc2snLCBudWxsKTtcbi8qXG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI3ZpZXdwb3J0LWJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgdmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI2lsbHVzdHJhdGlvbi1iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuKi9cbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjdmlld3BvcnQtYmFja2dyb3VuZCwgI2lsbHVzdHJhdGlvbi1iYWNrZ3JvdW5kXCIpXG4gICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVByaW50aW5nQ3JvcEFyZWEoKSB7XG4gICAgZDMuc2VsZWN0KCdkaXYudmVnYSBzdmcgZy5pbGx1c3RyYXRpb24tZWxlbWVudHMnKVxuICAgICAgICAuc3R5bGUoJ2NsaXAtcGF0aCcsJ3VybCgjcHJpbnRpbmctY2xpcC1wYXRoKScpO1xufVxuZnVuY3Rpb24gZGlzYWJsZVByaW50aW5nQ3JvcEFyZWEoKSB7XG4gICAgZDMuc2VsZWN0KCdkaXYudmVnYSBzdmcgZy5pbGx1c3RyYXRpb24tZWxlbWVudHMnKVxuICAgICAgICAuc3R5bGUoJ2NsaXAtcGF0aCcsJ25vbmUnKTtcbn1cblxuLyogTWFuYWdlIGRpYWdub3N0aWMgbWFya2luZ3MgKGNyb3AgbWFya3MsIGRlc2NyaXB0aW9uLCBydWxlcnMpIGZvciBwcmludGVkIG91dHB1dCAqL1xuZnVuY3Rpb24gc2hvd1ByaW50aW5nRGlhZ25vc3RpY3MoKSB7XG4gICAgc2hvd1ByaW50aW5nQ3JvcE1hcmtzKCk7XG4gICAgc2hvd1ByaW50aW5nRGVzY3JpcHRpb24oKTtcbiAgICBzaG93UHJpbnRpbmdSdWxlcnMoKTtcbn1cbmZ1bmN0aW9uIGhpZGVQcmludGluZ0RpYWdub3N0aWNzKCkge1xuICAgIGhpZGVQcmludGluZ0Nyb3BNYXJrcygpO1xuICAgIGhpZGVQcmludGluZ0Rlc2NyaXB0aW9uKCk7XG4gICAgaGlkZVByaW50aW5nUnVsZXJzKCk7XG59XG5mdW5jdGlvbiBzaG93UHJpbnRpbmdDcm9wTWFya3MoKSB7XG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgaWYgKHZpZXdwb3J0U1ZHLmVtcHR5KCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwic2hvd1ByaW50aW5nQ3JvcE1hcmtzKCk6IHZpZXdwb3J0IFNWRyBub3QgZm91bmQhXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiNjcm9wLW1hcmtzXCIpLmVtcHR5KCkpIHtcbiAgICAgICAgLy8gY3JlYXRlIGluc3RhbmNlIG9mIGNyb3AgbWFya3MgYW5kIFxuICAgICAgICB2aWV3cG9ydFNWRy5pbnNlcnQoJ3VzZScsICdzdmcgPiBnJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnY3JvcC1tYXJrcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3hsaW5rOmhyZWYnLCAnI3ByaW50aW5nLWNyb3AtbWFya3MnKTtcbiAgICB9XG4gICAgLy8gYWRqdXN0IHBsYWNlbWVudCBvZiBtYXJrcyB0byBtYXRjaCBmb3IgaWxsdXN0cmF0aW9uIHNpemVcbiAgICB2YXIgcHJpbnRUb3BFZGdlID0gMDsgIC8vIG5vIG5lZWQgdG8gc2V0IHRoZXNlXG4gICAgdmFyIHByaW50TGVmdEVkZ2UgPSAwO1xuICAgIHZhciBwcmludEJvdHRvbUVkZ2UgPSBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS5oZWlnaHQoKSwgaW50ZXJuYWxfcHBpKTtcbiAgICB2YXIgcHJpbnRSaWdodEVkZ2UgPSBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpLCBpbnRlcm5hbF9wcGkpO1xuICAgIGQzLnNlbGVjdCgnI2Nyb3AtbWFyay10b3AtcmlnaHQnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIrIHByaW50UmlnaHRFZGdlICtcIiwgMClcIik7XG4gICAgZDMuc2VsZWN0KCcjY3JvcC1tYXJrLWJvdHRvbS1sZWZ0JylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKDAsIFwiKyBwcmludEJvdHRvbUVkZ2UgK1wiKVwiKTtcbiAgICBkMy5zZWxlY3QoJyNjcm9wLW1hcmstYm90dG9tLXJpZ2h0JylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKFwiKyBwcmludFJpZ2h0RWRnZSArXCIsIFwiKyBwcmludEJvdHRvbUVkZ2UgK1wiKVwiKTtcbn1cbmZ1bmN0aW9uIGhpZGVQcmludGluZ0Nyb3BNYXJrcygpIHtcbiAgICAvLyByZW1vdmUgYWxsIGNyb3AtbWFyayBpbnN0YW5jZXNcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjY3JvcC1tYXJrc1wiKS5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIHNob3dQcmludGluZ0Rlc2NyaXB0aW9uKCkge1xuICAgIHZhciB2aWV3cG9ydFNWRyA9IGQzLnNlbGVjdEFsbChcIiN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnXCIpO1xuICAgIGlmICh2aWV3cG9ydFNWRy5lbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNob3dQcmludGluZ0Rlc2NyaXB0aW9uKCk6IHZpZXdwb3J0IFNWRyBub3QgZm91bmQhXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZpZXdwb3J0U1ZHLnNlbGVjdEFsbChcIiNkZXNjcmlwdGlvblwiKS5lbXB0eSgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnN0YW5jZSBvZiBjcm9wIG1hcmtzIGFuZCBcbiAgICAgICAgdmlld3BvcnRTVkcuaW5zZXJ0KCd1c2UnLCAnc3ZnID4gZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2Rlc2NyaXB0aW9uJylcbiAgICAgICAgICAgICAgICAuYXR0cigneGxpbms6aHJlZicsICcjcHJpbnRpbmctZGVzY3JpcHRpb24nKTtcbiAgICB9XG4gICAgLy8gTk9URSB0aGF0IHdlIG5lZWQgdG8gbW92ZSB0aGUgKm9yaWdpbmFsKiB0ZXh0IGVsZW1lbnQgdG8gZ2V0IGl0cyBwcm9wZXIgYm91bmRpbmcgYm94IVxuICAgIGQzLnNlbGVjdCgnI3ByaW50aW5nLWRlc2NyaXB0aW9uLW5hbWUnKVxuICAgICAgICAuYXR0cigneCcsIC01MClcbiAgICAgICAgLmF0dHIoJ3knLCAtMTEwKVxuICAgICAgICAudGV4dChcIlRPRE86IEFkZCB0aGUgYWN0dWFsIGlsbHVzdHJhdGlvbiBuYW1lLCBvciAnVW50aXRsZWQnXCIpO1xuICAgIHZhciByaWdodE5vdyA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIGRpc3BsYXlEYXRlVGltZSA9IFwiR2VuZXJhdGVkIFwiKyByaWdodE5vdy50b0xvY2FsZURhdGVTdHJpbmcoKSArXCIgLSBcIisgcmlnaHROb3cudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgZDMuc2VsZWN0KCcjcHJpbnRpbmctZGVzY3JpcHRpb24tZGF0ZXRpbWUnKVxuICAgICAgICAuYXR0cigneCcsIC01MClcbiAgICAgICAgLmF0dHIoJ3knLCAtOTQpXG4gICAgICAgIC50ZXh0KGRpc3BsYXlEYXRlVGltZSk7XG59XG5mdW5jdGlvbiBoaWRlUHJpbnRpbmdEZXNjcmlwdGlvbigpIHtcbiAgICAvLyByZW1vdmUgZGVzY3JpcHRpb24gaW5zdGFuY2VcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjZGVzY3JpcHRpb25cIikucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBzaG93UHJpbnRpbmdSdWxlcnMoKSB7XG4gICAgdmFyIHZpZXdwb3J0U1ZHID0gZDMuc2VsZWN0QWxsKFwiI3Zpei1vdXRlci1mcmFtZSBkaXYudmVnYSBzdmdcIik7XG4gICAgaWYgKHZpZXdwb3J0U1ZHLmVtcHR5KCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwic2hvd1ByaW50aW5nRGVzY3JpcHRpb24oKTogdmlld3BvcnQgU1ZHIG5vdCBmb3VuZCFcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodmlld3BvcnRTVkcuc2VsZWN0QWxsKFwiI3J1bGVyc1wiKS5lbXB0eSgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnN0YW5jZSBvZiBjcm9wIG1hcmtzIGFuZCBcbiAgICAgICAgdmlld3BvcnRTVkcuaW5zZXJ0KCd1c2UnLCAnc3ZnID4gZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3J1bGVycycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3hsaW5rOmhyZWYnLCAnI3ByaW50aW5nLXJ1bGVycycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgLTYwKTtcbiAgICB9XG4gICAgLy8gc2V0IHNjYWxlIGZvciBpbmNoIHJ1bGVyXG4gICAgdmFyIHVuaXRXaWR0aCA9IGluY2hlc1RvUGl4ZWxzKDEuMCwgaW50ZXJuYWxfcHBpKTtcbiAgICBkMy5zZWxlY3QoJyNydWxlci1pbmNoZXMgbGluZScpXG4gICAgICAgIC5hdHRyKCd4MicsIDYgKiB1bml0V2lkdGgpO1xuICAgIGQzLnNlbGVjdEFsbCgnI3J1bGVyLWluY2hlcyByZWN0JylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB1bml0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoaSAqIDIgKiB1bml0V2lkdGgpICsgdW5pdFdpZHRoKVxuICAgICAgICB9KTtcbiAgICAvLyBzZXQgc2NhbGUgZm9yIGNtIHJ1bGVyXG4gICAgdW5pdFdpZHRoID0gY2VudGltZXRlcnNUb1BpeGVscygxLjAsIGludGVybmFsX3BwaSk7XG4gICAgZDMuc2VsZWN0KCcjcnVsZXItY20gbGluZScpXG4gICAgICAgIC5hdHRyKCd4MicsIDE2ICogdW5pdFdpZHRoKTtcbiAgICBkMy5zZWxlY3RBbGwoJyNydWxlci1jbSByZWN0JylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB1bml0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoaSAqIDIgKiB1bml0V2lkdGgpICsgdW5pdFdpZHRoKVxuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGhpZGVQcmludGluZ1J1bGVycygpIHtcbiAgICAvLyByZW1vdmUgZGVzY3JpcHRpb24gaW5zdGFuY2VcbiAgICB2YXIgdmlld3BvcnRTVkcgPSBkMy5zZWxlY3RBbGwoXCIjdml6LW91dGVyLWZyYW1lIGRpdi52ZWdhIHN2Z1wiKTtcbiAgICB2aWV3cG9ydFNWRy5zZWxlY3RBbGwoXCIjcnVsZXJzXCIpLnJlbW92ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRQcmludGFibGVTVkcoIG9wdGlvbnMgKSB7XG4gICAgLy8gVE9ETzogQWRkIGFuIG9wdGlvbiB0byBnZW5lcmF0ZSBzdGFuZGFsb25lIFNWRywgdnMuIGlubGluZSBmb3IgSFRNTDVcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIC8vIHNoaWZ0IFNWRyBmcm9tIGVkaXRpbmcgdG8gcHJpbnRpbmdcbiAgICBkaXNhYmxlVmlld3BvcnRNYXNrKCk7XG4gICAgZW5hYmxlUHJpbnRpbmdDcm9wQXJlYSgpO1xuICAgIGlmIChvcHRpb25zLklOQ0xVREVfRElBR05PU1RJQ1MpIHtcbiAgICAgICAgc2hvd1ByaW50aW5nRGlhZ25vc3RpY3MoKTtcbiAgICB9XG5cbiAgICAvLyBjYXB0dXJlIHRoZSB2aWV3Ym94IGFuZCBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHdvcmtpbmcgdmlld1xuICAgIHZhciBpbGx1c3RyYXRpb24gPSBkMy5zZWxlY3QoJyN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2Egc3ZnJyk7XG4gICAgdmFyIHdvcmtpbmdWaWV3ID0ge1xuICAgICAgICAnd2lkdGgnOiBpbGx1c3RyYXRpb24uYXR0cihcIndpZHRoXCIpLFxuICAgICAgICAnaGVpZ2h0JzogaWxsdXN0cmF0aW9uLmF0dHIoXCJoZWlnaHRcIiksXG4gICAgICAgICd2aWV3Qm94JzogaWxsdXN0cmF0aW9uLmF0dHIoXCJ2aWV3Qm94XCIpXG4gICAgfVxuXG4gICAgLy8gbW9kaWZ5IHRoZSB2aWV3Ym94IHRvIGNhcHR1cmUganVzdCB0aGUgaWxsdXN0cmF0aW9uIGVsZW1lbnRzIChhbmQgcG9zc2libHkgZGlhZ25vc3RpYyBzdHVmZilcbiAgICB2YXIgcHJpbnRWaWV3Qm94ID0gKG9wdGlvbnMuSU5DTFVERV9ESUFHTk9TVElDUykgP1xuICAgICAgICBnZXREaWFnbm9zdGljQm91bmRpbmdCb3goKSA6IFxuICAgICAgICBnZXRNaW5pbWFsSWxsdXN0cmF0aW9uQm91bmRpbmdCb3goKTtcblxuICAgIC8qXG4gICAgY29uc29sZS5sb2coXCJwcmludFZpZXdCb3g6IFwiKTtcbiAgICBjb25zb2xlLmxvZyhwcmludFZpZXdCb3gpO1xuICAgICovXG5cbiAgICAvLyBzaGlmdCB0aGUgbWFpbiBTVkcgZGltZW5zaW9ucyB0byBwaHlzaWNhbCB1bml0cyAoZm9yIG1vcmUgYWNjdXJhdGUgcHJpbnQgc2l6ZSlcbiAgICB2YXIgdW5pdFN1ZmZpeCA9IGlsbC51bml0c0Nzc1N1ZmZpeCgpO1xuICAgIC8vIHJlY2tvbiBwaHlzaWNhbCBzaXplIGluIGRlZmF1bHQgKHByaW50LXJlYWR5KSBwcGkgdG8gXCJmcmVlemVcIiB0aGUgcGl4ZWwgc2l6ZSBvZiB0aGUgdG9wLWxldmVsIFNWR1xuICAgIGlsbHVzdHJhdGlvblxuICAgICAgICAvKiBOLkIuIFJlbHlpbmcgb24gXCJuYXR1cmFsXCIgU1ZHIHJlcyAoOTAgcHBpKSBwcmludHMgbm90LXF1aXRlIHRvIHNjYWxlIVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHByaW50Vmlld0JveC53aWR0aCkgICAvLyByZWx5IG9uIGJ1aWx0LWluID9cbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcHJpbnRWaWV3Qm94LmhlaWdodClcbiAgICAgICAgKi9cbiAgICAgICAgLy8gRXhwbGljaXRseSBzdGF0ZSBXUk9ORyBwaHlzaWNhbCBzaXplLCB1c2luZyBicm93c2VyIFBQSTsgcHJpbnRzIGNvcnJlY3RseSwgYnV0IGdpdmVzIG1lIGEgbWlncmFpbmVcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwaXhlbHNUb1BoeXNpY2FsVW5pdHMocHJpbnRWaWV3Qm94LndpZHRoLCBicm93c2VyX3BwaSkgKyB1bml0U3VmZml4KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBwaXhlbHNUb1BoeXNpY2FsVW5pdHMocHJpbnRWaWV3Qm94LmhlaWdodCwgYnJvd3Nlcl9wcGkpICsgdW5pdFN1ZmZpeClcbiAgICAgICAgLmF0dHIoXCJ2aWV3Qm94XCIsIChwcmludFZpZXdCb3gueCArJyAnKyBwcmludFZpZXdCb3gueSArJyAnKyBwcmludFZpZXdCb3gud2lkdGggKycgJytwcmludFZpZXdCb3guaGVpZ2h0KSk7XG5cbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKCBcInc6IFwiKyBpbGx1c3RyYXRpb24uYXR0cignd2lkdGgnKSApO1xuICAgIGNvbnNvbGUubG9nKCBcImg6IFwiKyBpbGx1c3RyYXRpb24uYXR0cignaGVpZ2h0JykgKTtcbiAgICBjb25zb2xlLmxvZyggXCJ2OiBcIisgaWxsdXN0cmF0aW9uLmF0dHIoJ3ZpZXdCb3gnKSApO1xuICAgIGNvbnNvbGUubG9nKFwiZGlzcGxheV9wcGk6IFwiKyBkaXNwbGF5X3BwaSk7XG4gICAgY29uc29sZS5sb2coXCJpbnRlcm5hbF9wcGk6IFwiKyBpbnRlcm5hbF9wcGkpO1xuICAgIGNvbnNvbGUubG9nKFwiYnJvd3Nlcl9wcGk6IFwiKyBpbnRlcm5hbF9wcGkpO1xuICAgIGNvbnNvbGUubG9nKFwidmlld3BvcnRNYWduaWZpY2F0aW9uOiBcIisgdmlld3BvcnRNYWduaWZpY2F0aW9uKTtcbiAgICAqL1xuXG4gICAgLy8gbW9tZW50YXJpbHkgXCJzcGxpY2VcIiBwZXJzaXN0ZW50IGRlZnMgaW50byB0aGUgaWxsdXN0cmF0aW9uLCBjYXB0dXJlIHRoZSByZXN1bHRcbiAgICB2YXIgdG9vbGJveCA9IGQzLnNlbGVjdCgnI3N2Zy10b29sYm94Jyk7XG4gICAgdmFyIGRlZnMgPSB0b29sYm94LnNlbGVjdCgnZGVmcycpO1xuICAgICQoaWxsdXN0cmF0aW9uLm5vZGUoKSkucHJlcGVuZChkZWZzKTtcblxuICAgIC8qXG4gICAgICogQ2FwdHVyZSB0aGUgcmVzdWx0aW5nIFNWRyAoaWUsIFRoZSBNb21lbnQgb2YgVHJ1dGgpLi4uIFxuICAgICAqL1xuICAgIHZhciBjb21iaW5lZFNWRyA9ICQoJyN2aXotb3V0ZXItZnJhbWUgZGl2LnZlZ2EnKS5odG1sKCk7XG5cbiAgICAvLyBSZXBsYWNlIFNhZmFyaSdzIHdlaXJkIG5hbWVzcGFjZSBwcmVmaXhlcyAoTlMxOiwgTlMyOiwgZXRjKSB3aXRoIHRoZSByZWFsIGRlYWxcbiAgICBjb21iaW5lZFNWRyA9IGNvbWJpbmVkU1ZHLnJlcGxhY2UoL05TXFxkKzovZ2ksICd4bGluazonKTtcblxuICAgIC8qXG4gICAgICogLi4uIHRoZW4gdW53aW5kIGFsbCB0aGVzZSBjaGFuZ2VzIHRvIHJlc3RvcmUgb3VyIG5vcm1hbCB3b3JraW5nIHZpZXcuIFxuICAgICAqL1xuXG4gICAgLy8gcmVwbGFjZSB0aGUgcGVyc2lzdGVudCBkZWZzXG4gICAgJCh0b29sYm94Lm5vZGUoKSkucHJlcGVuZChkZWZzKTtcblxuICAgIC8vIHJlc3RvcmUgcGl4ZWwgZGltZW5zaW9ucyAoaW4gZGVmZXJlbmNlIHRvIFZlZ2EpXG4gICAgaWxsdXN0cmF0aW9uXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd29ya2luZ1ZpZXcud2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHdvcmtpbmdWaWV3LmhlaWdodClcbiAgICAgICAgLmF0dHIoXCJ2aWV3Qm94XCIsIHdvcmtpbmdWaWV3LnZpZXdCb3gpO1xuXG4gICAgLy8gcmV2ZXJzZSBhbGwgdGhlIHByZXZpb3VzIHN0ZXBzXG4gICAgaWYgKG9wdGlvbnMuSU5DTFVERV9ESUFHTk9TVElDUykge1xuICAgICAgICBoaWRlUHJpbnRpbmdEaWFnbm9zdGljcygpO1xuICAgIH1cbiAgICBkaXNhYmxlUHJpbnRpbmdDcm9wQXJlYSgpO1xuICAgIGVuYWJsZVZpZXdwb3J0TWFzaygpO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkU1ZHO1xufVxuXG5mdW5jdGlvbiBwcmludElsbHVzdHJhdGlvbihvcHRpb25zKSB7XG4gICAgLyogUHJpbnQgc3RhbmRhbG9uZSBTVkcgYXMgYSBzaW1wbGUgZG9jdW1lbnQsIG9yIGRpc3BsYXkgaXRzIGN1cnJlbnQgb3V0cHV0IFNWRy5cbiAgICAgKiAgIEVYQU1QTEU6IHByaW50SWxsdXN0cmF0aW9uKCk7XG4gICAgICogICBFWEFNUExFOiBwcmludElsbHVzdHJhdGlvbih7SU5DTFVERV9ESUFHTk9TVElDUzogdHJ1ZX0pO1xuICAgICAqICAgRVhBTVBMRTogcHJpbnRJbGx1c3RyYXRpb24oe0lOQ0xVREVfRElBR05PU1RJQ1M6IHRydWUsIFNIT1dfU1ZHOiB0cnVlfSk7XG4gICAgICovXG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIHNob3dEaWFnbm9zdGljcyA9IG9wdGlvbnMuSU5DTFVERV9ESUFHTk9TVElDUyB8fCBmYWxzZTtcbiAgICB2YXIgbGVhdmVXaW5kb3dPcGVuID0gb3B0aW9ucy5TSE9XX1NWRyB8fCBmYWxzZTtcblxuICAgIHZhciB3PXdpbmRvdy5vcGVuKCk7XG4gICAgaWYgKCF3KSB7XG4gICAgICAgIGFsZXJ0KFwiUGxlYXNlIGFsbG93IHBvcHVwcyBmb3IgdGhpcyBkb21haW4uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgYSBzaW1wbGUgSFRNTDUgcGFnZSB3aXRoIGlubGluZSBTVkdcbiAgICAvLyBUT0RPOiBnZW5lcmF0ZSBzdGFuZGFsb25lIFNWRyBkb2N1bWVudCAodG8gc2F2ZSBvciBzaGFyZSkgaW5zdGVhZD9cbiAgICB2YXIgZG9jID0gdy5kb2N1bWVudDtcbiAgICBkb2Mub3BlbihcInRleHQvaHRtbFwiLCBcInJlcGxhY2VcIik7XG4gICAgZG9jLndyaXRlKCc8IURPQ1RZUEUgaHRtbD48SFRNTD48SEVBRD48VElUTEU+VHJlZSBJbGx1c3RyYXRvciAtIFNWRyBmb3IgcHJpbnRpbmc8L1RJVExFPjwvSEVBRD48Qk9EWT48L0JPRFk+PC9IVE1MPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIHZhciBvdXRwdXRTVkcgPSBnZXRQcmludGFibGVTVkcoIHtJTkNMVURFX0RJQUdOT1NUSUNTOiBzaG93RGlhZ25vc3RpY3N9ICk7XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIHJlbmRlciB0aGUgbmV3IHdpbmRvdyBzbyB3ZSBjYW4gdXNlIGl0cyBoZWlnaHRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGVhdmVXaW5kb3dPcGVuKSB7XG4gICAgICAgICAgICAvLyB3cml0ZSBqdXN0IHRoZSBTVkcgdG8gdGhlIG5ldyB3aW5kb3csIHRvIGJlIGNvcGllZCB0byBjbGlwYm9hcmRcbiAgICAgICAgICAgIHZhciBpdHNDbGllbnRIZWlnaHQgPSAkKCdodG1sJywgZG9jKVswXS5jbGllbnRIZWlnaHQgLSA1MDtcbiAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9ICc8dGV4dGFyZWEgc3R5bGU9XCJ3aWR0aDogOTUlOyBoZWlnaHQ6ICcrIGl0c0NsaWVudEhlaWdodCArJ3B4O1wiPicrIG91dHB1dFNWRyArJzwvdGV4dGFyZWE+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbCBwcmludCtjbG9zZSBiZWhhdmlvclxuICAgICAgICAgICAgZG9jLmJvZHkuaW5uZXJIVE1MID0gb3V0cHV0U1ZHO1xuICAgICAgICAgICAgdy5wcmludCgpO1xuICAgICAgICAgICAgdy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSwgNTAwKTtcbn1cblxuLyogQWNjb3JkaW9uIFVJIGhlbHBlcnMgKi9cbmZ1bmN0aW9uIGFjY29yZGlvblBhbmVsU2hvd24oZSkge1xuICAgIHZhciAkaGVhZGluZyA9ICQoZS50YXJnZXQpLnByZXYoJy5wYW5lbC1oZWFkaW5nJyk7XG4gICAgJGhlYWRpbmcuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAudGV4dCgnQ2xpY2sgdG8gY2xvc2UgdGhpcyBwYW5lbCcpO1xufVxuZnVuY3Rpb24gYWNjb3JkaW9uUGFuZWxIaWRkZW4oZSkge1xuICAgIHZhciAkaGVhZGluZyA9ICQoZS50YXJnZXQpLnByZXYoJy5wYW5lbC1oZWFkaW5nJyk7XG4gICAgJGhlYWRpbmcuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAudGV4dCgnQ2xpY2sgdG8gb3BlbiB0aGlzIHBhbmVsJyk7XG59XG5mdW5jdGlvbiBzaG93QWNjb3JkaW9uSGludChlKSB7XG4gICAgJChlLnRhcmdldClcbiAgICAgICAgLmZpbmQoXCJpLmhlbHAtcm9sbG92ZXJcIilcbiAgICAgICAgLnNob3coKTtcbn1cbmZ1bmN0aW9uIGhpZGVBY2NvcmRpb25IaW50KGUpIHtcbiAgICAkKGUudGFyZ2V0KVxuICAgICAgICAuZmluZChcImkuaGVscC1yb2xsb3ZlclwiKVxuICAgICAgICAuaGlkZSgpO1xufVxuZnVuY3Rpb24gc2hvd0FjY29yZGlvblBhbmVsKCBwYW5lbElEICkge1xuICAgIC8qIERyaXZlIHRoZSBzaWRlYmFyIFVJIHRvIHNob3cgYSBwYXJ0aWN1bGFyIHNlY3Rpb24gb24gZGVtYW5kLCBcbiAgICAgKiBlLmcuIHNob3cgYSB0cmVlJ3MgcHJvcGVydGllcyB3aGVuIHVzZXIgY2xpY2tzIG9uIGl0IGluIHZpei5cbiAgICAgKi9cbiAgICB2YXIgJGNob3NlblBhbmVsID0gJChwYW5lbElEKTtcbiAgICBpZiAoJGNob3NlblBhbmVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdzaG93QWNjb3JkaW9uUGFuZWwoKTogTm8gc3VjaCBwYW5lbCBhcyAnKyBwYW5lbElEKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJGNob3NlblBhbmVsLmhhc0NsYXNzKCdpbicpKSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBvcGVuOyBkb24ndCB0b2dnbGUgaXQgc2h1dCFcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUb2dnbGUgdG8gc2hvdyB0aGlzIHBhbmVsOyB1c2UgQVBJIHZzLiBhIHNpbXVsYXRlZCBjbGljaywgd2hpY2ggY2FuIHN0b3AgZHJhZ2dpbmchXG4gICAgICAgIC8vIENsb3NlIG90aGVyIHBhbmVscyAodGhlc2UgYXJlIFwic3RpY2t5XCIgZm9yIHNvbWUgcmVhc29uKVxuICAgICAgICAkY2hvc2VuUGFuZWwuY2xvc2VzdCgnLmFjY29yZGlvbicpLmZpbmQoJy5jb2xsYXBzZS5pbicpXG4gICAgICAgICAgICAuY29sbGFwc2UoJ2hpZGUnKTtcbiAgICAgICAgJGNob3NlblBhbmVsLmNvbGxhcHNlKCdzaG93Jyk7XG4gICAgfVxuICAgIC8vIFRPRE86IHNob3cgc2lkZWNhciBpbiBhbGwgY2FzZXM/XG59XG5mdW5jdGlvbiBzaG93QWNjb3JkaW9uUGFuZWxGb3JFbGVtZW50KCBlbGVtZW50SUQgKSB7XG4gICAgdmFyIHBhbmVsSUQgPSAnI3RpLXBhbmVsLScrIGVsZW1lbnRJRDtcbiAgICBzaG93QWNjb3JkaW9uUGFuZWwoIHBhbmVsSUQgKTtcbn1cbmZ1bmN0aW9uIGdldEFjY29yZGlvblBhbmVsRm9yRWxlbWVudCggaWxsRWxlbWVudCApIHtcbiAgICB2YXIgcGFuZWxJRCA9ICcjdGktcGFuZWwtJysgaWxsRWxlbWVudC5pZCgpO1xuICAgIHJldHVybiAkKHBhbmVsSUQpO1xufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAkKCcjdGktbWFpbi1hY2NvcmRpb24gLnBhbmVsLWJvZHknKS5vbignc2hvd24nLCBhY2NvcmRpb25QYW5lbFNob3duKTtcbiAgICAkKCcjdGktbWFpbi1hY2NvcmRpb24gLnBhbmVsLWJvZHknKS5vbignaGlkZGVuJywgYWNjb3JkaW9uUGFuZWxIaWRkZW4pO1xuXG4gICAgJCgnI3RpLW1haW4tYWNjb3JkaW9uIC5wYW5lbC1oZWFkaW5nJykub24oJ21vdXNlZW50ZXInLCBzaG93QWNjb3JkaW9uSGludCk7XG4gICAgJCgnI3RpLW1haW4tYWNjb3JkaW9uIC5wYW5lbC1oZWFkaW5nJykub24oJ21vdXNlbGVhdmUnLCBoaWRlQWNjb3JkaW9uSGludCk7XG59KTtcblxuZnVuY3Rpb24gZG9Ob3RoaW5nKCkge1xuICAgIC8vIG9jY2FzaW9uYWxseSB1c2VmdWwgaW4gS25vY2tvdXQuanMgY2xpY2sgYmluZGluZ3NcbiAgICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGdldFByaW50QXJlYUxhbmRtYXJrcygpIHtcbiAgICAvLyBnYXRoZXIgaW50ZXJlc3RpbmcgY29vcmRpbmF0ZXMgaW4gaW50ZXJuYWwgcGl4ZWxzXG4gICAgaWYgKGlsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHBoeXNpY2FsVW5pdHNUb1BpeGVscyhpbGwuc3R5bGUucHJpbnRTaXplLndpZHRoKCksIGludGVybmFsX3BwaSksXG4gICAgICAgICAgICBoZWlnaHQ6IHBoeXNpY2FsVW5pdHNUb1BpeGVscyhpbGwuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpLCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgbGVmdFg6IDAsXG4gICAgICAgICAgICBjZW50ZXJYOiBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpIC8gMi4wLCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgcmlnaHRYOiBwaHlzaWNhbFVuaXRzVG9QaXhlbHMoaWxsLnN0eWxlLnByaW50U2l6ZS53aWR0aCgpLCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgdG9wWTogMCxcbiAgICAgICAgICAgIGNlbnRlclk6IHBoeXNpY2FsVW5pdHNUb1BpeGVscyhpbGwuc3R5bGUucHJpbnRTaXplLmhlaWdodCgpIC8gMi4wLCBpbnRlcm5hbF9wcGkpLFxuICAgICAgICAgICAgYm90dG9tWTogcGh5c2ljYWxVbml0c1RvUGl4ZWxzKGlsbC5zdHlsZS5wcmludFNpemUuaGVpZ2h0KCksIGludGVybmFsX3BwaSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIHZhbHVlc1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAgIDEuMCxcbiAgICAgICAgaGVpZ2h0OiAgMS4wLFxuICAgICAgICBsZWZ0WDogICAwLjAsXG4gICAgICAgIGNlbnRlclg6IDAuNSxcbiAgICAgICAgcmlnaHRYOiAgMS4wLFxuICAgICAgICB0b3BZOiAgICAwLjAsXG4gICAgICAgIGNlbnRlclk6IDAuNSxcbiAgICAgICAgYm90dG9tWTogMS4wXG4gICAgfTtcbn1cbiBcbmZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdGVzdCA9ICQoJyNmdWxsLXNjcmVlbi1hcmVhJykuZnVsbHNjcmVlbigpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4aXRGdWxsU2NyZWVuKCkge1xuICAgICQuZnVsbHNjcmVlbi5leGl0KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiBUZXN0IHJlZ2V4cHMgZm9yIE1JTUUtdHlwZSAoY29udGVudC10eXBlKSBvZiBhIEZpbGUgb3IgQmxvYiAqL1xudmFyIGFsbFR5cGVzID0gLy4qLztcbnZhciB0ZXh0VHlwZXMgPSAvdGV4dC4qLzsgLy8gVE9ETzogYWRkICdhcHBsaWNhdGlvbi9qc29uJywgZXRjP1xudmFyIGltYWdlVHlwZXMgPSAvaW1hZ2UuKi87XG5cbi8vIFdoYXQgZG8gd2UgZXhwZWN0IChvciBmb3JiaWQpIGZvciBkaWZmZXJlbnQgaWxsdXN0cmF0aW9uIGVsZW1lbnRzP1xudmFyIGV4cGVjdGVkTUlNRVR5cGVzID0ge1xuICAgICdJbGx1c3RyYXRlZFRyZWUnOiB0ZXh0VHlwZXMsXG4gICAgJ1N1cHBvcnRpbmdEYXRhc2V0JzogdGV4dFR5cGVzLFxuICAgICdPcm5hbWVudCc6IGltYWdlVHlwZXNcbn07XG52YXIgZGlzYWxsb3dlZE1JTUVUeXBlcyA9IHtcbiAgICAnSWxsdXN0cmF0ZWRUcmVlJzogaW1hZ2VUeXBlcyxcbiAgICAnU3VwcG9ydGluZ0RhdGFzZXQnOiBpbWFnZVR5cGVzLFxuICAgICdPcm5hbWVudCc6IGFsbFR5cGVzXG59O1xuXG5mdW5jdGlvbiBoYW5kbGVDaG9zZW5Mb2NhbEZpbGUoIGlsbEVsZW1lbnQsIGV2ZW50ICkge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVDaG9zZW5Mb2NhbEZpbGUgU1RBUlRJTkcuLi4nKTtcbiAgICB2YXIgZmlsZUxpc3QgPSBldmVudC50YXJnZXQuZmlsZXM7ICAgICAgLy8gYSBGaWxlTGlzdFxuICAgIC8vIEZvciBub3csIHdlIGV4cGVjdCBqdXN0IG9uZSBmaWxlIVxuICAgIHZhciBjaG9zZW5GaWxlID0gZmlsZUxpc3RbMF07ICAgICAgICAgICAvLyBhIEZpbGVcblxuICAgIC8vIFdhcm4vcmVqZWN0IGlmIG5vdCBhbiBhcHByb3ByaWF0ZSBNSU1FLXR5cGUgZm9yIHRoaXMgZWxlbWVudD9cbiAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IGV4cGVjdGVkTUlNRVR5cGVzWyBpbGxFbGVtZW50Lm1ldGFkYXRhLnR5cGUoKSBdO1xuICAgIHZhciBkaXNhbGxvd2VkVHlwZXMgPSBkaXNhbGxvd2VkTUlNRVR5cGVzWyBpbGxFbGVtZW50Lm1ldGFkYXRhLnR5cGUoKSBdO1xuICAgIGlmIChjaG9zZW5GaWxlLnR5cGUubWF0Y2goZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBleHBlY3RlZCBjb250ZW50IHR5cGUsIGNhcnJ5IG9uLi4uXG4gICAgfSBlbHNlIGlmIChjaG9zZW5GaWxlLnR5cGUubWF0Y2goZGlzYWxsb3dlZFR5cGVzKSkge1xuICAgICAgICBhbGVydChcIkZpbGVzIG9mIE1JTUUtdHlwZSAnXCIrIGNob3NlbkZpbGUudHlwZSArXCInIGFyZSBub3QgYWxsb3dlZCBmb3IgXCIrIGlsbEVsZW1lbnQubWV0YWRhdGEudHlwZSgpICtcIiBlbGVtZW50cy5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGNvbnRlbnQgdHlwZSBpcyBub3QgaW4gZWl0aGVyIGxpc3QuIEFjY2VwdCBmb3Igbm93P1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUZW50YXRpdmVseSBhbGxvd2luZyBNSU1FLXR5cGUgJ1wiKyBjaG9zZW5GaWxlLnR5cGUgK1wiJyBmb3IgdGhpcyBcIisgaWxsRWxlbWVudC5tZXRhZGF0YS50eXBlKCkpO1xuICAgIH1cblxuICAgIC8vIFNob3cgZmlsZSBpbmZvcm1hdGlvbiBpbiBpdHMgYWNjb3JkaW9uIGVsZW1lbnRcbiAgICB2YXIgJHBhbmVsID0gZ2V0QWNjb3JkaW9uUGFuZWxGb3JFbGVtZW50KCBpbGxFbGVtZW50ICk7XG4gICAgJHBhbmVsLmZpbmQoJy5jaG9zZW4tZmlsZS1uYW1lJykudGV4dChjaG9zZW5GaWxlLm5hbWUpO1xuICAgICRwYW5lbC5maW5kKCcuY2hvc2VuLWZpbGUtdHlwZScpLmh0bWwoY2hvc2VuRmlsZS50eXBlIHx8ICc8ZW0+VW5rbm93bjwvZW0+Jyk7XG4gICAgJHBhbmVsLmZpbmQoJy5jaG9zZW4tZmlsZS1zaXplJykudGV4dChjaG9zZW5GaWxlLnNpemUpO1xuICAgICRwYW5lbC5maW5kKCcuY2hvc2VuLWZpbGUtbGFzdC1tb2QtZGF0ZScpLnRleHQoY2hvc2VuRmlsZS5sYXN0TW9kaWZpZWREYXRlLnRvTG9jYWxlU3RyaW5nKCkpO1xuXG4gICAgLy8gY3JlYXRlIGEgVVJMIHRvIHRoaXMgRmlsZVxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIC8vIGNsb3N1cmUgdG8gY2FwdHVyZSB0aGUgZmlsZSBpbmZvcm1hdGlvbi5cbiAgICByZWFkZXIub25sb2FkID0gKGZ1bmN0aW9uKHRoZUZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciByID0gZS50YXJnZXQ7ICAvLyBpLmUuLCB0aGlzIEZpbGVSZWFkZXJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmlsZVJlYWRyIHJlc3VsdCBmb3IgJ1wiKyBlc2NhcGUodGhlRmlsZS5uYW1lKSArXCInOlxcblwiKyByLnJlc3VsdCk7XG4gICAgICAgICAgICAvL2RlYnVnZ2VyO1xuICAgICAgICB9O1xuICAgIH0pKGNob3NlbkZpbGUpO1xuICAgIC8vcmVhZGVyLnJlYWRBc0RhdGFVUkwoY2hvc2VuRmlsZSk7ICAgICAgIC8vIHJlc3VsdCBpcyAnZGF0YTo7YmFzZTY0LEtFRXNLRUlzS0VNc1JDa3BLVHM9J1xuICAgIC8vcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhjaG9zZW5GaWxlKTsgIC8vIHJlc3VsdCBpcyAnKEEsKEIsKEMsRCkpKTsnXG4gICAgLy9yZWFkZXIucmVhZEFzVGV4dChjaG9zZW5GaWxlKTsgICAgICAgICAgLy8gcmVzdWx0IGlzICcoQSwoQiwoQyxEKSkpOydcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2hvc2VuRmlsZSk7ICAgICAvLyByZXN1bHQgaXMgJ1tvYmplY3QgQXJyYXlCdWZmZXJdJywgbW9yZSB0byBkbyBoZXJlIG9idmlvdXNseVxufVxuXG5mdW5jdGlvbiBhcHBseUNob3NlblN0eWxlR3VpZGUoY2xpY2tlZCkge1xuICAgIHZhciAkY2xpY2tlZCA9ICQoY2xpY2tlZCk7XG4gICAgdmFyICRzZ0Jsb2NrID0gJGNsaWNrZWQuY2xvc2VzdCgnLm1hdGNoJyk7XG4gICAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIGR1bWIgbWF0Y2hpbmcgd2l0aCBLTyBiaW5kaW5nIHRvIGFjdHVhbCBkYXRhXG4gICAgdmFyIG1hdGNoS2V5ID0gJHNnQmxvY2suZmluZCgnLm1hdGNoLWtleScpLnZhbCgpO1xuICAgIGNvbnNvbGUubG9nKFwiPiBMb29raW5nIGZvciBtYXRjaEtleTogXCIrIG1hdGNoS2V5KTtcbiAgICB2YXIgY2hvc2VuU3R5bGVHdWlkZSA9IG51bGw7XG4gICAgJC5lYWNoKGF2YWlsYWJsZVN0eWxlR3VpZGVzLCBmdW5jdGlvbihpLCBzZykge1xuICAgICAgICAvLyBpcyB0aGlzIHRoZSBpbGxsdXN0cmF0aW9uJ3MgY3VycmVudCBzdHlsZSBndWlkZT8gY29tcGFyZSBuYW1lLCBzb3VyY2UsIHZlcnNpb25cbiAgICAgICAgdmFyIHRlc3RLZXkgID0gc2cubmFtZSArJ3wnKyBzZy52ZXJzaW9uLnZhbHVlICsnfCcrIHNnLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCI+PiBjb21wYXJpbmcgdGVzdEtleTogXCIrIHRlc3RLZXkpO1xuICAgICAgICBpZiAodGVzdEtleSA9PT0gbWF0Y2hLZXkpIHtcbiAgICAgICAgICAgIGNob3NlblN0eWxlR3VpZGUgPSBzZztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hvc2VuU3R5bGVHdWlkZSkge1xuICAgICAgICBhbGVydCgnVW5hYmxlIHRvIG1hdGNoIHRoZSBjaG9zZW4gc3R5bGUgZ3VpZGUhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVE9ETzogYXBwbHkgLyBtZXJnZSB0aGlzIHN0eWxlIGd1aWRlIGludG8gdGhlIGN1cnJlbnQgaWxsdXN0cmF0aW9uXG4gICAgaWxsLmFwcGx5U3R5bGVHdWlkZShjaG9zZW5TdHlsZUd1aWRlKTtcbiAgICAvLyBjbG9zZSB0aGUgbW9kYWwgY2hvb3NlclxuICAgICRzZ0Jsb2NrLmNsb3Nlc3QoJy5tb2RhbC1zdHlsZWd1aWRlLWNob29zZXInKS5maW5kKCcubW9kYWwtaGVhZGVyIC5jbG9zZScpLmNsaWNrKCk7XG59XG5cbi8vIHJlZmxlY3QgdGhlIGN1cnJlbnQgdXNlcidzIGlkZW50aXR5LCBvciBudWxsIGZvciBhbiBhbm9ueW1vdXMgdXNlclxuZnVuY3Rpb24gdXNlckxvZ2luKCkge1xuICAgIHJldHVybiBzdG9yYWdlLnVzZXJMb2dpbigpO1xufVxuZnVuY3Rpb24gdXNlckRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiBzdG9yYWdlLnVzZXJEaXNwbGF5TmFtZSgpO1xufVxuZnVuY3Rpb24gdXNlckVtYWlsKCkge1xuICAgIHJldHVybiBzdG9yYWdlLmdldFVzZXJFbWFpbCgpO1xufVxuZnVuY3Rpb24gdXNlckhhc1N0b3JhZ2VBY2Nlc3MoKSB7XG4gICAgLy9yZXR1cm4gdXNlckxvZ2luKCkgJiYgKHVzZXJMb2dpbigpICE9PSAnTE9HSU5fTk9UX0ZPVU5EJyk7XG4gICAgcmV0dXJuIHN0b3JhZ2UudXNlckhhc1N0b3JhZ2VBY2Nlc3MoKTtcbn1cbmZ1bmN0aW9uIHVzZXJJc0xvZ2dlZEluKGNhbGxiYWNrKSB7XG4gICAgaWYgKHN0b3JhZ2UudXNlckF1dGhUb2tlbikge1xuICAgICAgICAvLyBhc3luY2hyb25vdXMsIHNpbmNlIGl0IG1heSByZXF1aXJlIGFuIEFKQVggcm91bmR0cmlwLi4uXG4gICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhbGVydCgnc3R5bGlzdC51c2VySXNMb2dnZWRJbigpIC0gcmVxdWlyZXMgYSBjYWxsYmFjayBmdW5jdGlvbiEnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0cnVlIGlmIE9BdXRoIHN0aWxsIHJlY29nbml6ZXMgdGhpcyB0b2tlblxuICAgICAgICBjYWxsYmFjayhzdG9yYWdlLnVzZXJJc0xvZ2dlZEluKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG5vIGNhbGxiYWNrIHJlcXVpcmVkIVxuICAgIHJldHVybiB0cnVlOyAgLy8gdHJlYXQgYXMgXCJ0cnVlXCIgYnkgZGVmYXVsdCwgZS5nLiBKdXB5dGVyIG5vdGVib29rXG59XG5cbi8vIG1hbmFnZSBpbGx1c3RyYXRpb25zICh1c2luZyBhbiBhZGFwdGVyIHdpdGggQVBJIG1ldGhvZHMsIGFscmVhZHkgbG9hZGVkKVxudmFyIGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gbnVsbDtcbiAgICAvLyBrZWVwIHRoZSBsYXRlc3Qgb3JkZXJlZCBhcnJheSAod2l0aCBwb3NpdGlvbnMsIG5hbWVzLCBkZXNjcmlwdGlvbnMpXG5mdW5jdGlvbiBsb2FkSWxsdXN0cmF0aW9uTGlzdChiYWNrZW5kLCBjYWxsYmFjaykge1xuICAgIGNvbnNvbGUubG9nKFwibG9hZElsbHVzdHJhdGlvbkxpc3QoKSBTVEFSVElORy4uLlwiKTtcbiAgICBzdG9yYWdlWyBiYWNrZW5kIF0uZ2V0SWxsdXN0cmF0aW9uTGlzdChmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAvLyBzaG93IHRoZSByZXR1cm5lZCBsaXN0IChvciByZXBvcnQgYW55IGVycm9yKSBmcm9tIHRoZSB1cHN0cmVhbSByZXNwb25zZVxuICAgICAgICBpZiAoJ2RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBleHBlY3QgYW4gb3JkZXJlZCBhcnJheSB3aXRoIG5hbWVzIGFuZCBkZXNjcmlwdGlvbnNcbiAgICAgICAgICAgIGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGJhY2tlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZS5lcnJvciB8fCBcIk5vIGRhdGEgcmV0dXJuZWQgKHVuc3BlY2lmaWVkIGVycm9yKSFcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNob3dJbGx1c3RyYXRpb25MaXN0KCBiYWNrZW5kLCBjdXJyZW50T3BlcmF0aW9uLCBvcHRpb25zICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtGTFVTSF9DQUNIRTogZmFsc2V9O1xuICAgIGlmIChvcHRpb25zLkZMVVNIX0NBQ0hFKSB7XG4gICAgICAgIGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0KSB7XG4gICAgICAgIC8vIFNob3cgbmFtZXMgYW5kIGRlc2NyaXB0aW9ucyBpbiBhIHNpbXBsZSwgZ2VuZXJhbCBjaG9vc2VyXG4gICAgICAgIHZhciAkY2hvb3NlciA9ICQoJyNzaW1wbGUtY2hvb3NlcicpO1xuICAgICAgICAvLyBTaG93IGFwcHJvcHJpYXRlIFVJIGFuZCBiZWhhdmlvciBmb3IgdGhlIGRlc2lyZWQgb3BlcmF0aW9uIChlZywgU0FWSU5HX0lMTFVTVFJBVElPTilcbiAgICAgICAgJGNob29zZXIuZmluZCgnW2NsYXNzXj1pZi1dJykuaGlkZSgpO1xuICAgICAgICAkY2hvb3Nlci5maW5kKCcuaWYtJysgY3VycmVudE9wZXJhdGlvbikuc2hvdygpOyAgLy8gZWcsICcuaWYtU0FWSU5HX0lMTFVTVFJBVElPTidcbiAgICAgICAgJGNob29zZXIuZmluZCgnLmlmLScrIGJhY2tlbmQpLnNob3coKTsgIC8vIGVnLCAnLmlmLUdJVEhVQl9SRVBPJ1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgKCdMT0FESU5HX0lMTFVTVFJBVElPTicpOlxuICAgICAgICAgICAgLy9jYXNlICgnTE9BRElOR19URU1QTEFURScpOlxuICAgICAgICAgICAgICAgICRjaG9vc2VyLmZpbmQoJy5kaWFsb2ctaGVhZGluZycpLmh0bWwoJ0xvYWQgYW4gZXhpc3RpbmcgaWxsdXN0cmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgnU0FWSU5HX0lMTFVTVFJBVElPTicpOlxuICAgICAgICAgICAgICAgIC8vIGFkanVzdCBkaXNwbGF5IGFuZCBiZWhhdmlvciBpbiB0aGUgc2hhcmVkIHBvcHVwXG4gICAgICAgICAgICAgICAgLyogQ2hlY2sgZm9yIGEgcHJpb3Igc3RvcmFnZSBsb2NhdGlvbiAobGFzdFNhdmUpOyBpZiBmb3VuZCxcbiAgICAgICAgICAgICAgICAgKiBleHBsYWluIHdoYXQgaGFwcGVucyBuZXh0IGFuZCBvZmZlciBhbHRlcm5hdGl2ZSBzYXZlLWFzXG4gICAgICAgICAgICAgICAgICogYmVoYXZpb3IsIGkuZS4gbWFrZSBhIGNvcHkgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcuZGlhbG9nLWhlYWRpbmcnKS5odG1sKCdTYXZlIChvciB1cGRhdGUpIHlvdXIgaWxsdXN0cmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKChzdG9yYWdlLmxhc3RTYXZlLmJhY2tlbmQoKSA9PT0gJ0dJVEhVQl9SRVBPJykgJiYgc3RvcmFnZS5sYXN0U2F2ZS5sb2NhdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2ltcGxlIHVwZGF0ZSBpcyB0aGUgcGF0aCBvZiBsZWFzdCByZXNpc3RhbmNlLCBidXQgb2ZmZXIgb3RoZXIgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAkKCcjbm90LXJlcGxhY2luZy1vbi1naXRodWInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNpZi1yZXBsYWNpbmctb24tZ2l0aHViJykuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY29nbml6ZSBhbiBpbXBsaWNpdCBtYXRjaCwgYmFzZWQgb24gbmFtZT0+c2x1ZyBjb252ZXJzaW9uP1xuICAgICAgICAgICAgICAgICAgICAkKCcjbm90LXJlcGxhY2luZy1vbi1naXRodWInKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNpZi1yZXBsYWNpbmctb24tZ2l0aHViJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICQoJyNzdWdnZXN0ZWQtc3RvcmFnZS1uYW1lJykudmFsKCBpbGwubWV0YWRhdGEubmFtZSgpICk7XG4gICAgICAgICAgICAgICAgJCgnI3N1Z2dlc3RlZC1zdG9yYWdlLW5hbWUnKS51bmJpbmQoJ2NoYW5nZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKCdwcm9wZXJ0eWNoYW5nZSBjaGFuZ2UgY2xpY2sga2V5dXAgaW5wdXQgcGFzdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE4uQi4gbG90cyBvZiBib3VuZCBldmVudHMsIHRvIGNhdGNoIGFueSBjaGFuZ2UgaW4gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIi4uLmNoZWNraW5nIGZvciBwb3RlbnRpYWwgc2F2ZSBjb25mbGljdHMuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYmFja2VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0dJVEhVQl9SRVBPJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBuZXcgc2x1Zy9pZCAob3Igc3RvcmVkIHByaW9yIGlkKSBhZ2FpbnN0IG91ciBpbGx1c3RyYXRpb24gbGlzdCwgd2FybiBpZiBpdCdzIGEgZHVwbGljYXRlIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9zZWRJRCA9IHN0b3JhZ2UuR0lUSFVCX1JFUE8uZ2V0RGVmYXVsdEdpdEh1YklsbHVzdHJhdGlvbklEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbXBhcmUgYWxsIGlkcy91cmxzIHdpdGggdGhpcyFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGN1cnJlbnRJbGx1c3RyYXRpb25MaXN0LCBmdW5jdGlvbihpLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocHJvcG9zZWRJRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obWF0Y2guc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5zb3VyY2UgPT09IHByb3Bvc2VkSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSElTIFdJTEwgT1ZFUldSSVRFIEFOIEVYSVNUSU5HIElMTFVTVFJBVElPTiFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2dpdGh1Yi1zdG9yYWdlLWR1cGUtd2FybmluZycpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50SWxsdXN0cmF0aW9uTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0pVUFlURVJfTk9URUJPT0snOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIjc3VnZ2VzdGVkLXN0b3JhZ2UtbmFtZSBzaG91bGQgbm90IGJlIGNoYW5naW5nIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1JU1NJTkcvVU5LTk9XTiBzdG9yYWdlIG9wZXJhdGlvbjogJ1wiKyBcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZXJhdGlvbiArXCInIDxcIisgdHlwZW9mKGN1cnJlbnRPcGVyYXRpb24pICtcIj5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5lbXB0eSgpO1xuICAgICAgICBpZiAoY3VycmVudElsbHVzdHJhdGlvbkxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAkY2hvb3Nlci5maW5kKCcuZm91bmQtbWF0Y2hlcycpLmFwcGVuZCgnPGRpdj4nK1xuICAgICAgICAgICAgICAnPGVtPk5vIGlsbHVzdHJhdGlvbnMgZm91bmQgaW4gc3RvcmFnZS48L2VtPicrXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVhY2goY3VycmVudElsbHVzdHJhdGlvbkxpc3QsIGZ1bmN0aW9uKGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLyogTGlzdCBpdGVtIHNob3VsZCBpbmNsdWRlIHRoZXNlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgKiAgLSBuYW1lXG4gICAgICAgICAgICAgICAgICogIC0gZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgKiAgLSBzb3VyY2VcbiAgICAgICAgICAgICAgICAgKiBOLkIuIEluIHNsb3QtYmFzZWQgc3RvcmFnZSwgYGlgIGlzIHRoZSBvbmx5IHNvdXJjZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlTG9jYXRpb24gPSBtYXRjaC5zb3VyY2UgfHwgaTtcbiAgICAgICAgICAgICAgICB2YXIgJG1hdGNoSW5mbyA9ICQoJzxkaXYgY2xhc3M9XCJtYXRjaFwiPjxkaXY+PHNwYW4gY2xhc3M9XCJuYW1lXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic3RvcmFnZS1sb2NhdGlvblwiPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVwiZGVzY3JpcHRpb25cIj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAkbWF0Y2hJbmZvLmZpbmQoJy5uYW1lJykuaHRtbChtYXRjaC5uYW1lIHx8ICc8ZW0+Tm8gbmFtZSBmb3VuZDwvZW0+JylcbiAgICAgICAgICAgICAgICAkbWF0Y2hJbmZvLmZpbmQoJy5zdG9yYWdlLWxvY2F0aW9uJykuaHRtbCgnICgnKyBzdG9yYWdlTG9jYXRpb24gKycpJyk7XG4gICAgICAgICAgICAgICAgJG1hdGNoSW5mby5maW5kKCcuZGVzY3JpcHRpb24nKS5odG1sKG1hdGNoLmRlc2NyaXB0aW9uIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgJGxvYWRCdXR0b24sICRkZWxldGVCdXR0b24sICRyZXBsYWNlQnV0dG9uO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudE9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMT0FESU5HX0lMTFVTVFJBVElPTic6XG4gICAgICAgICAgICAgICAgICAgIC8vY2FzZSAnTE9BRElOR19URU1QTEFURSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9hZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLW1pbmkgcHVsbC1yaWdodFwiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKycgc3R5bGU9XCJtYXJnaW4tdG9wOiA2cHg7IG1hcmdpbi1sZWZ0OiA4cHg7XCInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArJz5Mb2FkPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbG9hZEJ1dHRvbi5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbiggYmFja2VuZCwgc3RvcmFnZUxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgbW9kYWwgY2hvb3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLm1vZGFsLXNpbXBsZS1jaG9vc2VyJykuZmluZCgnLm1vZGFsLWhlYWRlciAuY2xvc2UnKS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbWF0Y2hJbmZvLnByZXBlbmQoJGxvYWRCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlbGV0ZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRhbmdlciBidG4tbWluaSBwdWxsLXJpZ2h0XCInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsnIHN0eWxlPVwibWFyZ2luLXRvcDogNnB4OyBtYXJnaW4tbGVmdDogOHB4O1wiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArJz48aSBjbGFzcz1cImljb24td2hpdGUgaWNvbi1yZW1vdmVcIj48L2k8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWxldGVCdXR0b24uY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm0oXCJUaGlzIHdpbGwgZGVsZXRlIEFMTCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGlsbHVzdHJhdGlvbi4gQXJlIHlvdSBzdXJlP1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJbGx1c3RyYXRpb24oIGJhY2tlbmQsIHN0b3JhZ2VMb2NhdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SWxsdXN0cmF0aW9uTGlzdCggYmFja2VuZCwgY3VycmVudE9wZXJhdGlvbiwge0ZMVVNIX0NBQ0hFOiB0cnVlfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtYXRjaEluZm8ucHJlcGVuZCgkZGVsZXRlQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTQVZJTkdfSUxMVVNUUkFUSU9OJzpcbiAgICAgICAgICAgICAgICAgICAgLy9jYXNlICdTQVZJTkdfVEVNUExBVEUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHJlcGxhY2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1taW5pIHB1bGwtcmlnaHRcIidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsnIHN0eWxlPVwibWFyZ2luLXRvcDogNnB4OyBtYXJnaW4tbGVmdDogOHB4O1wiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyc+UmVwbGFjZTwvYnV0dG9uPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJlcGxhY2VCdXR0b24uY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUN1cnJlbnRJbGx1c3RyYXRpb24oIGJhY2tlbmQsIHN0b3JhZ2VMb2NhdGlvbiwge1JFRlJFU0hfTElTVDogdHJ1ZX0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1hdGNoSW5mby5wcmVwZW5kKCRyZXBsYWNlQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWxldGVCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kYW5nZXIgYnRuLW1pbmkgcHVsbC1yaWdodFwiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArJyBzdHlsZT1cIm1hcmdpbi10b3A6IDZweDsgbWFyZ2luLWxlZnQ6IDhweDtcIidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyc+PGkgY2xhc3M9XCJpY29uLXdoaXRlIGljb24tcmVtb3ZlXCI+PC9pPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVsZXRlQnV0dG9uLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtKFwiVGhpcyB3aWxsIGRlbGV0ZSBBTEwgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBpbGx1c3RyYXRpb24uIEFyZSB5b3Ugc3VyZT9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSWxsdXN0cmF0aW9uKCBiYWNrZW5kLCBzdG9yYWdlTG9jYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0lsbHVzdHJhdGlvbkxpc3QoIGJhY2tlbmQsIGN1cnJlbnRPcGVyYXRpb24sIHtGTFVTSF9DQUNIRTogdHJ1ZX0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkbWF0Y2hJbmZvLnByZXBlbmQoJGRlbGV0ZUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5hcHBlbmQoJG1hdGNoSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAkY2hvb3Nlci5vZmYoJ3Nob3duJykub24oJ3Nob3duJywgcmVzaXplSWxsdXN0cmF0aW9uTGlzdCk7XG4gICAgICAgIC8vL1VTRUZVTD8gJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5jc3MoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XG4gICAgICAgIC8vJGNob29zZXIuZmluZCgnLmZvdW5kLW1hdGNoZXMnKS5jc3MoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgLy8gKHJlKWJpbmQgVUkgd2l0aCBLbm9ja291dFxuICAgICAgICB2YXIgJGJvdW5kRWxlbWVudHMgPSAkY2hvb3Nlci5maW5kKCcubW9kYWwtYm9keScpOyAvLyBhZGQgb3RoZXIgZWxlbWVudHM/XG4gICAgICAgICQuZWFjaCgkYm91bmRFbGVtZW50cywgZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgIGtvLmNsZWFuTm9kZShlbCk7XG4gICAgICAgICAgICBrby5hcHBseUJpbmRpbmdzKHt9LGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRjaG9vc2VyLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgIHJlc2l6ZUlsbHVzdHJhdGlvbkxpc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIHRoZSBpbml0aWFsIGxpc3QsIHRoZW4gcmV0dXJuIGhlcmVcbiAgICAgICAgbG9hZElsbHVzdHJhdGlvbkxpc3QoYmFja2VuZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzaG93SWxsdXN0cmF0aW9uTGlzdCggYmFja2VuZCwgY3VycmVudE9wZXJhdGlvbiApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNpemVJbGx1c3RyYXRpb25MaXN0KCkge1xuLyogTi5CLiB0aGlzIGRvZXNuJ3QgcmVhbGx5IGFwcGx5IHVubGVzcyB3ZSd2ZSBsb2NrZWQgdGhlIHBvcHVwJ3MgaGVpZ2h0IVxuICAgIC8vIHNpemUgc2Nyb2xsaW5nIGxpc3QgdG8gZml0IGluIHRoZSBjdXJyZW50IERPSS1sb29rdXAgcG9wdXAgd2luZG93XG4gICAgdmFyICRjaG9vc2VyID0gJCgnI3NpbXBsZS1jaG9vc2VyJyk7XG4gICAgdmFyICRtYXRjaExpc3RIb2xkZXIgPSAkY2hvb3Nlci5maW5kKCcuZm91bmQtbWF0Y2hlcycpO1xuICAgICRtYXRjaExpc3RIb2xkZXJcbiAgICAgICAgLmNzcygndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgIHZhciByZXN1bHRzTGlzdEhlaWdodCA9ICRjaG9vc2VyLmZpbmQoJy5tb2RhbC1ib2R5JykuaGVpZ2h0KCkgLSAkY2hvb3Nlci5maW5kKCcuYmVmb3JlLW1hdGNoZXMnKS5oZWlnaHQoKTtcbiAgICAkbWF0Y2hMaXN0SG9sZGVyXG4gICAgICAgIC5vdXRlckhlaWdodChyZXN1bHRzTGlzdEhlaWdodCk7XG4gICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XG4qL1xufVxuZnVuY3Rpb24gc2F2ZUN1cnJlbnRJbGx1c3RyYXRpb24oYmFja2VuZCwgc2F2ZVRvTG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7Rk9SQ0VfTkVXX0RPQzogZmFsc2UsIFJFRlJFU0hfTElTVDogZmFsc2V9O1xuICAgIGNvbnNvbGUubG9nKFwic2F2ZUN1cnJlbnRJbGx1c3RyYXRpb24oKSBDSEVDS0lORyBGT1IgU1BFQ0lGSUVEIEJBQ0tFTkQrTE9DQVRJT04uLi5cIik7XG4gICAgaWYgKCFiYWNrZW5kIHx8IChzYXZlVG9Mb2NhdGlvbiA9PT0gbnVsbCkpIHtcbiAgICAgICAgLy8gbm90IHNwZWNpZmllZCAoZS5nLiwgd2UgaGF2ZW4ndCBzYXZlZCB0aGUgY3VycmVudCBpbGx1c3RyYXRpb24gaW4gdGhpcyBzZXNzaW9uKVxuICAgICAgICBzaG93U3RvcmFnZU9wdGlvbnMoJ1NBVklOR19JTExVU1RSQVRJT04nKTsgIC8vIGRlZmVyIHRvIHRoZSBTYXZlIEFzLi4uIGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChiYWNrZW5kID09PSAnTE9DQUxfRklMRVNZU1RFTScpICYmIChzYXZlVG9Mb2NhdGlvbiA9PT0gJ1VOS05PV04nKSkge1xuICAgICAgICAvLyBwcm9wb3NlIGFuIGFwcHJvcHJpYXRlIGZpbGVuYW1lIGJhc2VkIG9uIGl0cyBpbnRlcm5hbCBuYW1lXG4gICAgICAgIHNhdmVUb0xvY2F0aW9uID0gZ2V0RGVmYXVsdEFyY2hpdmVGaWxlTmFtZSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLkZPUkNFX05FV19ET0MpIHtcbiAgICAgICAgc3dpdGNoIChiYWNrZW5kKSB7XG4gICAgICAgICAgICBjYXNlICdHSVRIVUJfUkVQTyc6XG4gICAgICAgICAgICAgICAgaWYgKCgnc2hhJyBpbiBpbGwubWV0YWRhdGEpICYmICh0eXBlb2YoaWxsLm1ldGFkYXRhLnNoYSkgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlsbC5tZXRhZGF0YS5zaGEoJycpOyAgLy8gdGhpcyBmb3JjZXMgbmV3IGRvYyBvbiBHaXRIdWJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcInNhdmVDdXJyZW50SWxsdXN0cmF0aW9uKCkgU1RBUlRJTkcgc2ltcGxlIChyZSlzYXZlLi4uXCIpO1xuICAgIC8vIFRPRE86IEhvdyBzaG91bGQgdGhpcyBJRCBiZSBkZXRlcm1pbmVkP1xuICAgIC8vICAtIHVuaXF1ZS9zZXJpYWxpemVkIHNsdWcsIGFsYSB0cmVlIGNvbGxlY3Rpb25zP1xuICAgIC8vICAtIGlmIHByb3ZpZGVkIGFzIGluY29taW5nIGFyZywgdXNlIHRvIFNhdmUgQXNcbiAgICAvLyAgLSBhZGQgYW4gZXhwbGljaXQgYXJnIGZvciBTQVZFLCBTQVZFX0FTLCBEVVBMSUNBVEVcbiAgICAvLyAgLSBzaG91bGQgdGhlc2UgZGV0YWlscyBiZSBkZWxlZ2F0ZWQgdG8gdGhlIHN0b3JhZ2UgYWRhcHRlcj9cbiAgICAvLyAgLSBPUiBzaG91bGQgd2UgcmVseSBlbnRpcmVseSBvbiAoYW5kIHBvc3NpYmx5IG1vZGlmeSkgaXRzIGludGVybmFsIG1ldGFkYXRhP1xuICAgIC8vIEN1cnJlbnQgYmVoYXZpb3IgKGluIElQeXRob24gbm90ZWJvb2spIGlzIHRvIGFzc3VtZSB0aGUgY3VycmVudCAobnRoKVxuICAgIC8vIHN0b3JhZ2Ugc2xvdCwgdW5sZXNzICdORVcnIG9yIGFub3RoZXIgaW50ZWdlciBpcyBhc3NlcnRlZCBoZXJlLlxuICAgIHN0b3JhZ2VbIGJhY2tlbmQgXS5zYXZlSWxsdXN0cmF0aW9uKHNhdmVUb0xvY2F0aW9uLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAvLyAocmUpbG9hZCB0aGUgc2F2ZWQgaWxsdXN0cmF0aW9uIChvciByZXBvcnQgYW55IGVycm9yKVxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIHJlc3BvbnNlLmVycm9yICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2N1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0LXNhdmVkIGluZm9cbiAgICAgICAgICAgIC8qIENvbmZpcm0gdGhhdCB0aGUgc2F2ZVRvTG9jYXRpb24gd2Fzbid0IGNoYW5nZWQgYnkgdGhlIHN0b3JhZ2UgYmFja2VuZCFcbiAgICAgICAgICAgICAqIFRoaXMgcHJvYmFibHkgbWVhbnMgY2hlY2tpbmcgdGhlIGlsbHVzdHJhdGlvbidzIHJldHVybmVkIG1ldGFkYXRhIChpZiBhbnkpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzd2l0Y2ggKGJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdHSVRIVUJfUkVQTyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBuZXcgaWQgYXNzaWduZWQgYnkgYmFja2VuZCAoYWxyZWFkeSBjaGFuZ2VkIGluIHRoZSBpbGx1c3RyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdNZXRhZGF0YUxvY2F0aW9uID0gaWxsLm1ldGFkYXRhLnVybCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXNzaWduZWRJRCA9IHN0b3JhZ2UuR0lUSFVCX1JFUE8uZ2V0SWxsdXN0cmF0aW9uSURGcm9tVVJMKG5ld01ldGFkYXRhTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoaXMgKmFzc2lnbmVkKiBsb2NhdGlvbiwgdnMuIHdoYXQgd2UgaW50ZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTGFzdFNhdmVkSW5mbyhiYWNrZW5kLCBhc3NpZ25lZElEKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSlVQWVRFUl9OT1RFQk9PSyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlc3Qgc2F2ZXMgdG8gSnVweXRlciBub3RlYm9vaywgc28gd2UgY2FuIHRyYW5zbGF0ZSAnTkVXJyAoc3RhdGVkIGludGVudCkgdG8gYW4gYWN0dWFsIHNsb3QgbnVtYmVyIVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2F2ZVRvTG9jYXRpb24gPT09ICdORVcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOLkIuIHJlc3BvbnNlLmRhdGEgaXMgdGhlICpuZXcqIGlsbHVzdHJhdGlvbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG93TWFueUlsbHVzdHJhdGlvbnMgPSByZXNwb25zZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTbG90UG9zaXRpb24gPSBob3dNYW55SWxsdXN0cmF0aW9ucyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVMYXN0U2F2ZWRJbmZvKGJhY2tlbmQsIG5ld1Nsb3RQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVMYXN0U2F2ZWRJbmZvKGJhY2tlbmQsIHNhdmVUb0xvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdMT0NBTF9GSUxFU1lTVEVNJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBXZSBjYW4ndCBzZWUgdGhlIG5ldyBsb2NhbCBmaWxlbmFtZSFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaWxsdXN0cmF0aW9uIGxpc3RcbiAgICAgICAgICAgIGlmIChvcHRpb25zLlJFRlJFU0hfTElTVCkge1xuICAgICAgICAgICAgICAgIHNob3dJbGx1c3RyYXRpb25MaXN0KCBiYWNrZW5kLCAnU0FWSU5HX0lMTFVTVFJBVElPTicsIHtGTFVTSF9DQUNIRTogdHJ1ZX0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVsZXRlSWxsdXN0cmF0aW9uKGJhY2tlbmQsIGRlbGV0ZUxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIC8qIE4uQi4gV2UgZ2VuZXJhbGx5IGFzc3VtZSB0aGlzIGlzIE5PVCB0aGUgY3VycmVudCAobGl2ZSkgaWxsdXN0cmF0aW9uLFxuICAgICAqIGJ1dCBhbm90aGVyIGNob3NlbiBmcm9tIGEgc3RvcmFnZSBwb3B1cCFcbiAgICAgKi9cbiAgICBjb25zb2xlLmxvZyhcImRlbGV0ZUlsbHVzdHJhdGlvbigpIENIRUNLSU5HIEZPUiBTUEVDSUZJRUQgQkFDS0VORCtMT0NBVElPTi4uLlwiKTtcbiAgICBpZiAoIWJhY2tlbmQgfHwgIWRlbGV0ZUxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkZWxldGVJbGx1c3RyYXRpb24oKSByZXF1aXJlcyBhIHN0b3JhZ2UgYmFja2VuZCBhbmQgbG9jYXRpb24hXCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiICBiYWNrZW5kOiBcIisgYmFja2VuZCArXCIgPFwiKyB0eXBlb2YoYmFja2VuZCkgK1wiPlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIiAgbG9jYXRpb246IFwiKyBkZWxldGVMb2NhdGlvbiArXCIgPFwiKyB0eXBlb2YoZGVsZXRlTG9jYXRpb24pICtcIj5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcImRlbGV0ZUlsbHVzdHJhdGlvbigpIFNUQVJUSU5HIHNpbXBsZSBkZWxldGlvbi4uLlwiKTtcbiAgICBzdG9yYWdlWyBiYWNrZW5kIF0uZGVsZXRlSWxsdXN0cmF0aW9uKGRlbGV0ZUxvY2F0aW9uLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAvLyAocmUpbG9hZCB0aGUgc2F2ZWQgaWxsdXN0cmF0aW9uIChvciByZXBvcnQgYW55IGVycm9yKVxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIHJlc3BvbnNlLmVycm9yICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGxpc3QgaW4gVUksIHRvIHNob3cgdGhhdCBpdCdzIHJlYWxseSBnb25lXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRlbGV0ZUlsbHVzdHJhdGlvbigpIGdhdmUgdGhpcyByZXNwb25zZSAobmV3IGlsbHVzdHJhdGlvbiBsaXN0PyBvciBzaW1wbGVyIHJlc3VsdD8pXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAvL2N1cnJlbnRJbGx1c3RyYXRpb25MaXN0ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIC8vIGFueSBjbGVhbnVwP1xuICAgICAgICAgICAgc3dpdGNoIChiYWNrZW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnR0lUSFVCX1JFUE8nOlxuICAgICAgICAgICAgICAgICAgICAvLyBEaWQgd2UganVzdCBkZWxldGUgdGhlIGN1cnJlbnRseSBsb2FkZWQgaWxsdXN0cmF0aW9uIT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgndXJsJyBpbiBpbGwubWV0YWRhdGEpICYmIChpbGwubWV0YWRhdGEudXJsKCkuZW5kc1dpdGgoICcvJysgZGVsZXRlTG9jYXRpb24gKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGl0cyBpbnRlcm5hbCAndXJsJyBhbmQgJ3NoYScsIHRvIGZvcmNlICdTYXZlIEFzJyBiZWhhdmlvciBuZXh0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3R5bGlzdC5kZWxldGVJbGx1c3RyYXRpb24oKTogY2xvYmJlcmVkIGxpdmUgaWxsdXN0cmF0aW9uISBzbyBjbGVhcmluZyBpdHMgU0hBIGFuZCBVUkwuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbGwubWV0YWRhdGEudXJsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlsbC5tZXRhZGF0YS5zaGEoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJMYXN0U2F2ZWRJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gdHlwaWNhbGx5IHJlbG9hZGluZyBhbiBpbGx1c3RyYXRpb24gbGlzdFxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaG93U3RvcmFnZU9wdGlvbnMoIGN1cnJlbnRPcGVyYXRpb24gKSB7XG4gICAgLy8gU2hvdyBhbGwgc3RvcmFnZSBiYWNrZW5kcywgaW5jbC4gZGlzYWJsZWQgLyBub3QgYXZhaWxhYmxlLlxuICAgIHZhciAkcG9wdXAgPSAkKCcjc3RvcmFnZS1vcHRpb25zLXBvcHVwJyk7XG4gICAgLy8gVE9ETzogJHBvcHVwLmZpbmQoJzppbnB1dCcpLnZhbCgnJyk7ICAvLyBjbGVhciBhbnkgb2xkIHZhbHVlcz9cblxuICAgIC8vIFNob3cgYXBwcm9wcmlhdGUgVUkgYW5kIGJlaGF2aW9yIGZvciB0aGUgZGVzaXJlZCBvcGVyYXRpb24gKGVnLCBTQVZJTkdfSUxMVVNUUkFUSU9OKVxuICAgICRwb3B1cC5maW5kKCdbY2xhc3NePWlmLV0nKS5oaWRlKCk7XG4gICAgJHBvcHVwLmZpbmQoJy5pZi0nKyBjdXJyZW50T3BlcmF0aW9uKS5zaG93KCk7ICAvLyBlZywgJy5pZi1TQVZJTkdfSUxMVVNUUkFUSU9OJ1xuICAgIHN3aXRjaCAoY3VycmVudE9wZXJhdGlvbikge1xuICAgICAgICBjYXNlICgnTE9BRElOR19JTExVU1RSQVRJT04nKTpcbiAgICAgICAgY2FzZSAoJ1NBVklOR19JTExVU1RSQVRJT04nKTpcbiAgICAgICAgLy9jYXNlICgnTE9BRElOR19URU1QTEFURScpOlxuICAgICAgICAvL2Nhc2UgKCdMT0FESU5HX1RFTVBMQVRFJyk6XG4gICAgICAgICAgICAvLyBhZGp1c3QgZGlzcGxheSBhbmQgYmVoYXZpb3IgaW4gdGhlIHNoYXJlZCBwb3B1cFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTUlTU0lORy9VTktOT1dOIHN0b3JhZ2Ugb3BlcmF0aW9uOiAnXCIrIFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVyYXRpb24gK1wiJyA8XCIrIHR5cGVvZihjdXJyZW50T3BlcmF0aW9uKSArXCI+XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgc2hvdWxkIHJlZmxlY3QgdGhlIGF2YWlsYWJpbGl0eSBvZiBlYWNoIHN0b3JhZ2UgYmFja2VuZCAoY2hlY2tcbiAgICAvLyBoZXJlLCBzbyB3ZSBkb24ndCBrZWVwIHRlc3RpbmcpXG4gICAgaWYgKHN0eWxpc3QudXRpbHMuYnJvd3NlclN1cHBvcnRzRmlsZUFQSSgpKSB7XG4gICAgICAgICRwb3B1cC5maW5kKCcuZmlsZS1hcGktc3VwcG9ydGVkJykuc2hvdygpO1xuICAgICAgICAkcG9wdXAuZmluZCgnLmZpbGUtYXBpLU5PVC1zdXBwb3J0ZWQnKS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJHBvcHVwLmZpbmQoJy5maWxlLWFwaS1zdXBwb3J0ZWQnKS5oaWRlKCk7XG4gICAgICAgICRwb3B1cC5maW5kKCcuZmlsZS1hcGktTk9ULXN1cHBvcnRlZCcpLnNob3coKTtcbiAgICB9XG4gICAgaWYgKGhvc3RBcHBsaWNhdGlvbiA9PT0gVHJlZUlsbHVzdHJhdG9yLmhvc3RBcHBsaWNhdGlvbnMuSlVQWVRFUl9OT1RFQk9PSykge1xuICAgICAgICAkcG9wdXAuZmluZCgnLm5vdGVib29rLXN0b3JhZ2Utc3VwcG9ydGVkJykuc2hvdygpO1xuICAgICAgICAkcG9wdXAuZmluZCgnLm5vdGVib29rLXN0b3JhZ2UtTk9ULXN1cHBvcnRlZCcpLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkcG9wdXAuZmluZCgnLm5vdGVib29rLXN0b3JhZ2Utc3VwcG9ydGVkJykuaGlkZSgpO1xuICAgICAgICAkcG9wdXAuZmluZCgnLm5vdGVib29rLXN0b3JhZ2UtTk9ULXN1cHBvcnRlZCcpLnNob3coKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZS5HSVRIVUJfUkVQTy51c2VySXNMb2dnZWRJbnRvR2l0SHViKCkpIHtcbiAgICAgICAgJCgnI2dpdGh1Yi1sb2dpbi1wYW5lbCcpLmhpZGUoKTtcbiAgICAgICAgJCgnI2dpdGh1Yi1sb2dnZWQtaW4nKS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI2dpdGh1Yi1sb2dpbi1wYW5lbCcpLnNob3coKTtcbiAgICAgICAgJCgnI2dpdGh1Yi1sb2dnZWQtaW4nKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgJHBvcHVwLm1vZGFsKCdzaG93Jyk7XG4gICAgLy8kcG9wdXAuZmluZCgnI2dpdGh1Yi1hdXRob3JpemUnKS51bmJpbmQoJ2NsaWNrJykuY2xpY2sobG9naW5Ub0dpdEh1Yik7XG5cbiAgICAvLyAocmUpYmluZCBVSSB3aXRoIEtub2Nrb3V0XG4gICAgdmFyICRib3VuZEVsZW1lbnRzID0gJCgnI3N0b3JhZ2Utb3B0aW9ucy1wb3B1cCAubW9kYWwtYm9keScpOyAvLyBhZGQgb3RoZXIgZWxlbWVudHM/XG4gICAgJC5lYWNoKCRib3VuZEVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICBrby5jbGVhbk5vZGUoZWwpO1xuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHt9LGVsKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVNhdmVPcHRpb25EZXRhaWxzKGNsaWNrZWQpIHtcbiAgICB2YXIgJGNsaWNrZWQgPSAkKGNsaWNrZWQpO1xuICAgIHZhciAkY3VycmVudE9wdGlvblBhbmVsID0gJGNsaWNrZWQuY2xvc2VzdCgnLm1vZGFsLWJvZHknKTtcbiAgICB2YXIgJG90aGVyT3B0aW9uUGFuZWxzID0gJGNsaWNrZWQuY2xvc2VzdCgnLm1vZGFsJykuZmluZCgnLm1vZGFsLWJvZHknKS5ub3QoJGN1cnJlbnRPcHRpb25QYW5lbCk7XG4gICAgJG90aGVyT3B0aW9uUGFuZWxzLmZpbmQoJy5vcHRpb24tZGV0YWlscycpLmhpZGUoKTtcbiAgICAkY3VycmVudE9wdGlvblBhbmVsLmZpbmQoJy5vcHRpb24tZGV0YWlscycpLnRvZ2dsZSgpO1xufVxuXG4vKlxuZnVuY3Rpb24gZ2F0aGVyU3RhdGljSW5wdXREYXRhKCkge1xuICAgIC8vIFRPRE86IFJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggLnBhdGgsIC52YWx1ZSwgb3RoZXIgc2Vuc2libGUgcHJvcGVydGllc1xuICAgIHJldHVybiBbIF07XG59XG5cbmZ1bmN0aW9uIGdhdGhlckFsbElucHV0RGF0YSgpIHtcbiAgICAvLyBUT0RPOiBSZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIC5wYXRoLCAudmFsdWUsIG90aGVyIHNlbnNpYmxlIHByb3BlcnRpZXNcbiAgICByZXR1cm4gWyBdO1xufVxuXG5mdW5jdGlvbiBnYXRoZXJBbGxUcmFuc2Zvcm1EYXRhKCkge1xuICAgIC8vIFRPRE86IFJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggLnBhdGgsIC52YWx1ZSwgb3RoZXIgc2Vuc2libGUgcHJvcGVydGllc1xuICAgIHJldHVybiBbIF07XG59XG4qL1xuXG5mdW5jdGlvbiBsb2FkQXJjaGl2ZUZyb21DaG9zZW5GaWxlKCB2bSwgZXZ0ICkge1xuICAgIC8vIEZpcnN0IHBhcmFtIChjb3JyZXNwb25kaW5nIHZpZXctbW9kZWwgZGF0YSkgaXMgcHJvYmFibHkgZW1wdHk7IGZvY3VzIG9uIHRoZSBldmVudCFcbiAgICAvLyBBU1NVTUUgd2UncmUgaW4gdGhlIHN0b3JhZ2Utb3B0aW9ucyBwb3B1cC5cbiAgICB2YXIgJGhpbnRBcmVhID0gJCgnI2xvY2FsLWZpbGVzeXN0ZW0td2FybmluZycpLmVxKDApO1xuICAgICRoaW50QXJlYS5odG1sKFwiXCIpOyAgLy8gY2xlYXIgZm9yIG5ldyByZXN1bHRzXG4gICAgc3dpdGNoKGV2dC5zcmNFbGVtZW50LmZpbGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlICgwKTpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gZmlsZShzKSBzZWxlY3RlZCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAoMSk6XG4gICAgICAgIGRlZmF1bHQ6ICAvLyBpZ25vcmUgbXVsdGlwbGUgZmlsZXMgZm9yIG5vdywganVzdCBsb2FkIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmFyIGZpbGVJbmZvID0gZXZ0LnNyY0VsZW1lbnQuZmlsZXNbMF07XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJmaWxlSW5mby5uYW1lID0gXCIrIGZpbGVJbmZvLm5hbWUpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZmlsZUluZm8udHlwZSA9IFwiKyBmaWxlSW5mby50eXBlKTtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkQXJjaGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3dpdGNoIChmaWxlSW5mby50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24vemlwJzpcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZEFyY2hpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUluZm8ubmFtZS5tYXRjaCgnLih6aXB8aWxsKSQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZEFyY2hpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkQXJjaGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIkFyY2hpdmVkIGlsbHVzdHJhdGlvbnMgc2hvdWxkIGVuZCBpbiA8Y29kZT4uemlwPC9jb2RlPiBvciA8Y29kZT4uaWxsPC9jb2RlPi4gQ2hvb3NlIGFub3RoZXIgZmlsZT9cIjtcbiAgICAgICAgICAgICAgICAkaGludEFyZWEuaHRtbChtc2cpLnNob3coKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGlsbCBoZXJlPyB0cnkgdG8gcmVhZCBhbmQgdW56aXAgdGhpcyBhcmNoaXZlIVxuICAgICAgICAgICAganN6aXAubG9hZEFzeW5jKGZpbGVJbmZvKSAgIC8vIHJlYWQgdGhlIEJsb2JcbiAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oemlwKSB7ICAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVhZGluZyBaSVAgY29udGVudHMuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlJlYWRpbmcgaWxsdXN0cmF0aW9uIGNvbnRlbnRzLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgICAkaGludEFyZWEuaHRtbChtc2cpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyB3aWxsIHdlIGtub3cgd2hlbiBpdCdzIGFsbCAoYXN5bmMpIGxvYWRlZD8gQ291bnQgZG93biBhcyBlYWNoIGVudHJ5IGlzIHJlYWQhXG4gICAgICAgICAgICAgICAgICAgICB2YXIgemlwRW50cmllc1RvTG9hZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbENhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHppcC5maWxlcykgeyB6aXBFbnRyaWVzVG9Mb2FkKys7IH1cbiAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXNoIG1vc3QgZm91bmQgZGF0YSBpbiB0aGUgY2FjaGUsIGJ1dCBtYWluIEpTT04gc2hvdWxkIGJlIHBhcnNlZFxuICAgICAgICAgICAgICAgICAgICAgdmFyIG1haW5JbGx1c3RyYXRpb25KU09OID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIHppcEVudHJ5KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyAgJysgemlwRW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coemlwRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgZGlyZWN0b3JpZXMgKG5vdGhpbmcgdG8gZG8gaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoemlwRW50cnkuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS53YXJuKFwiU0tJUFBJTkcgZGlyZWN0b3J5IFwiKyB6aXBFbnRyeS5uYW1lICtcIi4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwRW50cmllc1RvTG9hZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgYW5kIHN0b3JlIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgemlwRW50cnkuYXN5bmMoJ3RleHQnLCBmdW5jdGlvbihtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHByb2dyZXNzP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiUmVhZGluZyBpbGx1c3RyYXRpb24gY29udGVudHMgKFwiKyB6aXBFbnRyeS5uYW1lICtcIik6IFwiKyBtZXRhZGF0YS5wZXJjZW50LnRvRml4ZWQoMikgK1wiICVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRoaW50QXJlYS5odG1sKG1zZykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2VzcyB1bnppcHBpbmcgXCIrIHppcEVudHJ5Lm5hbWUgK1wiOlxcblwiKyBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXBFbnRyaWVzVG9Mb2FkLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgYW5kIHN0YXNoIHRoZSBtYWluIEpTT04gZGF0YTsgY2FjaGUgdGhlIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHppcEVudHJ5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFpbi5qc29uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5JbGx1c3RyYXRpb25KU09OID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBvdXIgaW5pdGlhbCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhY2hlWyB6aXBFbnRyeS5uYW1lIF0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoemlwRW50cmllc1RvTG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSByZWFkIGluIGFsbCB0aGUgWklQIGRhdGEhIG9wZW4gdGhpcyBpbGx1c3RyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHNldHRpbmcgaXRzIGluaXRpYWwgY2FjaGUpIGFuZCBjbG9zZSB0aGlzIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRJbGx1c3RyYXRpb25EYXRhKCBtYWluSWxsdXN0cmF0aW9uSlNPTiwgaW5pdGlhbENhY2hlLCAnRVhJU1RJTkcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3Qtc2F2ZWQgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZUxhc3RTYXZlZEluZm8oJ0xPQ0FMX0ZJTEVTWVNURU0nLCAnVU5LTk9XTicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVMYXN0U2F2ZWRJbmZvKCdMT0NBTF9GSUxFU1lTVEVNJywgZmlsZUluZm8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE4uQi4gdGhlIEZpbGUgQVBJICphbHdheXMqIGRvd25sb2FkcyB0byBhbiB1bnVzZWQgcGF0aCtmaWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjc3RvcmFnZS1vcHRpb25zLXBvcHVwJykubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlByb2JsZW0gdW56aXBwaW5nIFwiKyB6aXBFbnRyeS5uYW1lICtcIjpcXG5cIisgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRoaW50QXJlYS5odG1sKG1zZykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7ICAgICAgICAgLy8gZmFpbHVyZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiRXJyb3IgcmVhZGluZyA8c3Ryb25nPlwiICsgZmlsZUluZm8ubmFtZSArIFwiPC9zdHJvbmc+ISBJcyB0aGlzIGEgcHJvcGVyIHppcCBmaWxlP1wiO1xuICAgICAgICAgICAgICAgICAgICAgJGhpbnRBcmVhLmh0bWwobXNnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFyY2hpdmVGaWxlTmFtZSggY2FuZGlkYXRlRmlsZU5hbWUgKSB7XG4gICAgLy8gdHJ5IHRvIHVzZSBhIGNhbmRpZGF0ZSBuYW1lLCBpZiBwcm92aWRlZFxuICAgIHZhciBzdWdnZXN0ZWRGaWxlTmFtZSA9ICQudHJpbShjYW5kaWRhdGVGaWxlTmFtZSkgfHwgXG4gICAgICAgIHN0eWxpc3QuaWxsLm1ldGFkYXRhLm5hbWUoKSB8fCBcbiAgICAgICAgXCJVTlRJVExFRF9JTExVU1RSQVRJT05cIjtcbiAgICBpZiAoIXN1Z2dlc3RlZEZpbGVOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy56aXAnKSkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlTmFtZSArPSAnLnppcCc7XG4gICAgfVxuICAgIHJldHVybiBzdWdnZXN0ZWRGaWxlTmFtZTtcbn1cbmZ1bmN0aW9uIHNhdmVBcmNoaXZlV2l0aFN1Z2dlc3RlZE5hbWUoKSB7XG4gICAgdmFyICRmaWxlbmFtZUZpZWxkID0gJCgnaW5wdXQjc3VnZ2VzdGVkLWFyY2hpdmUtZmlsZW5hbWUnKTtcbiAgICB2YXIgc3VnZ2VzdGVkRmlsZU5hbWUgPSAkLnRyaW0oJGZpbGVuYW1lRmllbGQudmFsKCkpO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlTmFtZSkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlTmFtZSA9IGdldERlZmF1bHRBcmNoaXZlRmlsZU5hbWUoc3VnZ2VzdGVkRmlsZU5hbWUpO1xuICAgICAgICBzdHlsaXN0LnN0b3JhZ2VbIExPQ0FMX0ZJTEVTWVNURU0gXS5zYXZlSWxsdXN0cmF0aW9uKHN1Z2dlc3RlZEZpbGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsaXN0LnN0b3JhZ2VbIExPQ0FMX0ZJTEVTWVNURU0gXS5zYXZlSWxsdXN0cmF0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxhc3RTYXZlZEluZm8oJ0xPQ0FMX0ZJTEVTWVNURU0nLCBzdWdnZXN0ZWRGaWxlTmFtZSB8fCAnVU5LTk9XTicpO1xuICAgICQoJyNsb2NhbC1maWxlc3lzdGVtLXdhcm5pbmcnKS5zbGlkZURvd24oKTtcbn1cblxuLy8gRXhwb3NlIHNvbWUgbWVtYmVycyB0byBvdXRzaWRlIGNvZGUgKGVnLCBLbm9ja291dCBiaW5kaW5ncywgb25DbGlja1xuLy8gYXR0cmlidXRlcy4uLilcbnZhciBhcGkgPSBbXG4gICAgJ1RyZWVJbGx1c3RyYXRvcicsXG4gICAgJ3VzZXJMb2dpbicsXG4gICAgJ3VzZXJEaXNwbGF5TmFtZScsXG4gICAgJ3VzZXJFbWFpbCcsXG4gICAgJ3Nob3dTdG9yYWdlT3B0aW9ucycsXG4gICAgJ3RvZ2dsZVNhdmVPcHRpb25EZXRhaWxzJyxcbiAgICAndXNlckhhc1N0b3JhZ2VBY2Nlc3MnLFxuICAgICd1c2VySXNMb2dnZWRJbicsXG4gICAgJ3Nob3dJbGx1c3RyYXRpb25MaXN0JyxcbiAgICAnbG9hZElsbHVzdHJhdGlvbkxpc3QnLFxuICAgICdmZXRjaEFuZExvYWRFeGlzdGluZ0lsbHVzdHJhdGlvbicsXG4gICAgJ2ZldGNoQW5kTG9hZElsbHVzdHJhdGlvblRlbXBsYXRlJyxcbiAgICAnc2F2ZUN1cnJlbnRJbGx1c3RyYXRpb24nLFxuICAgICdpbmNoZXNUb0NlbnRpbWV0ZXJzJyxcbiAgICAnY2VudGltZXRlcnNUb0luY2hlcycsXG4gICAgJ2luY2hlc1RvUG9pbnRzJyxcbiAgICAncG9pbnRzVG9JbmNoZXMnLFxuICAgICdjZW50aW1ldGVyc1RvUG9pbnRzJyxcbiAgICAncG9pbnRzVG9DZW50aW1ldGVycycsXG4gICAgJ3BpeGVsc1RvSW5jaGVzJyxcbiAgICAnaW5jaGVzVG9QaXhlbHMnLFxuICAgICdwaXhlbHNUb0NlbnRpbWV0ZXJzJyxcbiAgICAnY2VudGltZXRlcnNUb1BpeGVscycsXG4gICAgJ3BpeGVsc1RvUGh5c2ljYWxVbml0cycsXG4gICAgJ3BoeXNpY2FsVW5pdHNUb1BpeGVscycsXG4gICAgJ3BvaW50c1RvQ2VudGltZXRlcnMnLFxuICAgICdnZXRQcmludEFyZWFMYW5kbWFya3MnLFxuICAgICd0b2dnbGVGaXhlZFJ1bGVycycsXG4gICAgJ3JlZnJlc2hWaXonLFxuICAgICdkb05vdGhpbmcnLFxuICAgICdicm93c2VyX3BwaScsXG4gICAgJ2ludGVybmFsX3BwaScsXG4gICAgJ2Rpc3BsYXlfcHBpJyxcbiAgICAnaW50ZXJuYWxVbml0c1RvT3ZlcmxheVBpeGVscycsXG4gICAgJ292ZXJsYXlQaXhlbHNUb0ludGVybmFsVW5pdHMnLFxuICAgICdhdmFpbGFibGVUcmVlcycsXG4gICAgJ2F2YWlsYWJsZURhdGFTb3VyY2VzJyxcbiAgICAnem9vbVZpZXdwb3J0JyxcbiAgICAncHJpbnRJbGx1c3RyYXRpb24nLFxuICAgICdyZXNpemVWaWV3cG9ydFRvU2hvd0FsbCcsXG4gICAgJ2F2YWlsYWJsZVN0eWxlR3VpZGVzJyxcbiAgICAnc2hvd1N0eWxlR3VpZGVQaWNrZXInLFxuICAgICdzaG93QWNjb3JkaW9uUGFuZWwnLFxuICAgICdzaG93QWNjb3JkaW9uUGFuZWxGb3JFbGVtZW50JyxcbiAgICAnYXBwbHlDaG9zZW5TdHlsZUd1aWRlJyxcbiAgICAnaGFuZGxlQ2hvc2VuTG9jYWxGaWxlJyxcbiAgICAnZW50ZXJGdWxsU2NyZWVuJyxcbiAgICAnZXhpdEZ1bGxTY3JlZW4nLFxuICAgICdpbGwnLFxuICAgIC8vJ2dhdGhlclN0YXRpY0lucHV0RGF0YScsXG4gICAgLy8nZ2F0aGVyQWxsSW5wdXREYXRhJyxcbiAgICAvLydnYXRoZXJBbGxUcmFuc2Zvcm1EYXRhJyxcbiAgICAnbG9hZEFyY2hpdmVGcm9tQ2hvc2VuRmlsZScsXG4gICAgJ2dldERlZmF1bHRBcmNoaXZlRmlsZU5hbWUnLFxuICAgICdzYXZlQXJjaGl2ZVdpdGhTdWdnZXN0ZWROYW1lJyxcbiAgICAnY2xlYXJMYXN0U2F2ZWRJbmZvJyxcbiAgICAndmlldycsXG4gICAgLy8nanN6aXAnLFxuICAgIC8vJ0ZpbGVTYXZlcicsXG4gICAgJ3V0aWxzJyxcbiAgICAnc3RvcmFnZSdcbl07XG4kLmVhY2goYXBpLCBmdW5jdGlvbihpLCBtZXRob2ROYW1lKSB7XG4gICAgLy8gcG9wdWxhdGUgdGhlIGRlZmF1bHQgJ21vZHVsZS5leHBvcnRzJyBvYmplY3RcbiAgICBleHBvcnRzWyBtZXRob2ROYW1lIF0gPSBldmFsKCBtZXRob2ROYW1lICk7XG59KTtcbiIsIi8qIFxuICogR2VuZXJhbGx5IHVzZWZ1bCB0b29scyBmb3IgbW9kdWxlcyBpbiBUcmVlIElsbHVzdHJhdG9yLiBUaGV5IG1pZ2h0IGJlXG4gKiBjb25jZXJuZWQgd2l0aCBkaXNwbGF5IGxvZ2ljLCBnZW9tZXRyeSBhbmQgdHJhbnNmb3JtYXRpb24sIHRleHQgZm9ybWF0dGluZztcbiAqIGFueXRoaW5nIHRoYXQgc3BhbnMgb3VyIG5vcm1hbCBsaW5lcyBvZiByZXNwb25zaWJpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBqaWdnbGUoIHJhbmdlICkge1xuICAgIC8vIFJldHVybiBhIG51bWJlciArLSB6ZXJvLCB3aXRoaW4gdGhpcyByYW5nZVxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiByYW5nZSAqIDIpIC0gcmFuZ2U7IFxufVxuXG4vKlxuICogUHJlcGFyZSBkYXRhIGZyb20gcmVuZGVyaW5nIHBpcGVsaW5lIGZvciBzdG9yYWdlIGluIFpJUCBhcmNoaXZlIG9yIHNpbWlsYXIuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGFGb3JTYXZlZEZpbGUoIGRhdGEgKSB7XG4gICAgLy8gVE9ETzogVGVzdCBkYXRhIGZvciBvdGhlciBzdWl0YWJsZSBvcHRpb25zIGxpa2Uge2Jhc2U2NDogdHJ1ZX1cbiAgICB2YXIgc2VyaWFsaXplZCA9IHt9O1xuICAgIHN3aXRjaCAodHlwZW9mIGRhdGEpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcm91YmxlIGNvbnZlcnRpbmcgb2JqZWN0IHRvIEpTT04hIFRyeSBhbm90aGVyIGFwcHJvYWNoP1wiKTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnZhbHVlID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBzZXJpYWxpemVkLnZhbHVlID0gZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2VyaWFsaXplZC52YWx1ZSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5vcHRpb25zID0ge307XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qIFwiU25pZmZlcnNcIiB0byBndWVzcyB0aGUgZm9ybWF0IG9mIHVzZXItZW50ZXJlZCB0cmVlIGRhdGEuIFxuICogTi5CLiB0aGVzZSBkb24ndCBuZWVkIHRvIGJlIGZvb2wtcHJvb2Y7IHRoZXkncmUganVzdCB1c2VkIHRvIHByZS1zZWxlY3RcbiAqIHRoZSBtb3N0IGxpa2VseSBmb3JtYXQuIFxuICovXG5mdW5jdGlvbiBpc1Byb2JhYmx5TmV3aWNrKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRhdGEgPSAkLnRyaW0oZGF0YSk7XG4gICAgLy8gTG9vayBmb3IgZXhwZWN0ZWQgc3RhcnQgYW5kIGVuZCBtYXJrc1xuICAgIC8vIE4uQi4gdGhpcyB3aWxsIHJlamVjdCBhIHZhbGlkIChidXQgdHJpdmlhbCkgc3RyaW5nIGxpa2UgJ0E7J1xuICAgIGlmIChkYXRhLnN0YXJ0c1dpdGgoJygnKSAmJiBkYXRhLmVuZHNXaXRoKCcpOycpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBtYXRjaGVzTkVYVVNCbG9ja1N0YXJ0ZXIgPSBuZXcgUmVnRXhwKCdiZWdpbiBcXFxcdys7JywgJ2knKTtcbmZ1bmN0aW9uIGlzUHJvYmFibHlORVhVUyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZihkYXRhKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBMb29rIGZvciByZXF1aXJlZCg/KSBmaXJzdCBsaW5lXG4gICAgaWYgKCQudHJpbShkYXRhKS5zdGFydHNXaXRoKFwiI25leHVzXCIpIHx8ICQudHJpbShkYXRhKS5zdGFydHNXaXRoKFwiI05FWFVTXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyAuLi4gb3IgYWNjZXB0IHR5cGljYWwgTkVYVVMgYmxvY2sgc3RhcnRlclxuICAgIGlmIChtYXRjaGVzTkVYVVNCbG9ja1N0YXJ0ZXIudGVzdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Byb2JhYmx5TmVYTUwoZGF0YSkge1xuICAgIC8qIE5PVEUgdGhhdCB0aGlzIGlzIHRoZSBtb3N0IFwiZXhwZW5zaXZlXCIgc25pZmZlciwgc28gaXQncyBwcm9iYWJseVxuICAgICAqIGJlc3QgdG8gY2hlY2sgdGhlIG90aGVycyBmaXJzdC5cbiAgICAgKi9cbiAgICB2YXIgdGVzdFhNTDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFhNTERvY3VtZW50KSB7XG4gICAgICAgIHRlc3RYTUwgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZXN0WE1MID0gJC5wYXJzZVhNTChkYXRhKTtcbiAgICAgICAgICAgIGlmICghdGVzdFhNTCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGRhdGEgaXMgbm90IGEgc3RyaW5nLCByZXN1bHQgaXMgbnVsbCBcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gdmFyIGZhaWxlZCB0byBwYXJzZSBhcyBYTUxcbiAgICAgICAgICAgIC8vL2NvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJCh0ZXN0WE1MKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBYTUwgaXMgc3RyYW5nZWx5IGVtcHR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJvb3ROb2RlTmFtZSA9ICQodGVzdFhNTCkuY2hpbGRyZW4oKVswXS5ub2RlTmFtZTtcbiAgICBzd2l0Y2goIHJvb3ROb2RlTmFtZSApIHtcbiAgICAgICAgY2FzZSAnbmV4Om5leG1sJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICduZXhtbCc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJvYmFibHlSUGh5bG8oZGF0YSkge1xuICAgIC8vIHRlc3QgZm9yIHZhbGlkIEpTT04vSlMgbmVzdGVkIGFycmF5LCB0aGVuIGV4YW1pbmUgaXRzIHN0cnVjdHVyZVxuICAgIHZhciB0ZXN0T2JqID0gY29lcmNlVG9KU09iamVjdChkYXRhKTtcbiAgICBpZiAoIXRlc3RPYmopIHJldHVybiBmYWxzZTtcbiAgICAvLyBjaGVjayBmb3IgYmFzaWMgcGh5bG8gZmllbGRzXG4gICAgcmV0dXJuICgnZWRnZScgaW4gdGVzdE9iaikgJiYgKCd0aXAubGFiZWwnIGluIHRlc3RPYmopICYmICgnTm5vZGUnIGluIHRlc3RPYmopO1xuICAgIC8vIFRPRE86IElzIHRpcC5sYWJlbCBhbiBvcHRpb25hbCBlbGVtZW50PyBDaG9vc2Ugc29tZXRoaW5nIGVsc2UgaW5zdGVhZD9cbn1cblxuZnVuY3Rpb24gaXNQcm9iYWJseU5leHNvbihkYXRhKSB7XG4gICAgLy8gdGVzdCBmb3IgdmFsaWQgSlNPTi9KUyBuZXN0ZWQgYXJyYXksIHRoZW4gZXhhbWluZSBpdHMgc3RydWN0dXJlXG4gICAgdmFyIHRlc3RPYmogPSBjb2VyY2VUb0pTT2JqZWN0KGRhdGEpO1xuICAgIGlmICghdGVzdE9iaikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGNoZWNrIGZvciBiYXNpYyBuZXhzb24gc3RydWN0dXJlXG4gICAgcmV0dXJuICgnZGF0YScgaW4gdGVzdE9iaikgJiYgKCduZXhtbCcgaW4gdGVzdE9iai5kYXRhKTtcbn1cblxuZnVuY3Rpb24gY29lcmNlVG9KU09iamVjdChkYXRhKSB7XG4gICAgLy8gcmV0dXJuIGEgcHJvcGVyIEpTIG9iamVjdCAob3IgbnVsbCBpZiBjb2VyY2lvbiBmYWlscylcbiAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgZmluZSBhcy1pc1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGpzT2JqZWN0ID0gZXZhbChkYXRhKTtcbiAgICAgICAgaWYgKCFqc09iamVjdCkge1xuICAgICAgICAgICAgLy8gaWYgZGF0YSBpcyBub3QgYSBzdHJpbmcsIHJlc3VsdCBpcyBudWxsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB2YXIgZmFpbGVkIHRvIGV2YWx1YXRlIHRvIGEgSlMgb2JqZWN0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb2VyY2lvbiB0byBKUyBvYmplY3QgZmFpbGVkIVwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGpzT2JqZWN0O1xufVxuXG4vKiBEZXRlY3QgYnJvd3NlciBjYXBhYmlsaXRpZXMgKi9cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c0ZpbGVBUEkoKSB7XG4gICAgLy8gQ2FuIGxvYWQgYW5kIG1hbmlwdWxhdGUgbG9jYWwgZmlsZXMgaW4gdGhpcyBicm93c2VyP1xuICAgIHJldHVybiAod2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iKSA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyogQ29waWVkIGZyb20gdmcuZGF0YS5waHlsb2dyYW0uanMsIGZvciB3aWRlciB1c2UgKGJ1dCBrZWVwaW5nIHRoZSBjb2RlIGluXG4gKiBib3RoIHBsYWNlcywgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIGluIHRoZSBWZWdhIHRyYW5zZm9ybSkuXG4gKi9cbmZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocikge1xuICAgIHJldHVybiAociAqIDE4MCAvIE1hdGguUEkpO1xufVxuZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkKSB7XG4gICAgcmV0dXJuIChkICogTWF0aC5QSSAvIDE4MCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEZWdyZWVzKGQpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHBvc2l0aXZlIGludGVnZXIsIGUuZy4gLTkwID09PiAyNzBcbiAgICByZXR1cm4gKGQgKyAoMzYwICogMykpICUgMzYwO1xufVxuXG4vLyBleHBvcnQgc29tZSBtZW1iZXJzIGFzIGEgc2ltcGxlIEFQSVxudmFyIGFwaSA9IFtcbiAgICAnamlnZ2xlJyxcbiAgICAnc2VyaWFsaXplRGF0YUZvclNhdmVkRmlsZScsXG4gICAgJ2lzUHJvYmFibHlOZXdpY2snLFxuICAgICdpc1Byb2JhYmx5TkVYVVMnLFxuICAgICdpc1Byb2JhYmx5TmVYTUwnLFxuICAgICdpc1Byb2JhYmx5UlBoeWxvJyxcbiAgICAnYnJvd3NlclN1cHBvcnRzRmlsZUFQSScsXG4gICAgJ3JhZGlhbnNUb0RlZ3JlZXMnLFxuICAgICdkZWdyZWVzVG9SYWRpYW5zJyxcbiAgICAnbm9ybWFsaXplRGVncmVlcydcbl07XG4kLmVhY2goYXBpLCBmdW5jdGlvbihpLCBtZXRob2ROYW1lKSB7XG4gICAgLy8gcG9wdWxhdGUgdGhlIGRlZmF1bHQgJ21vZHVsZS5leHBvcnRzJyBvYmplY3RcbiAgICBleHBvcnRzWyBtZXRob2ROYW1lIF0gPSBldmFsKCBtZXRob2ROYW1lICk7XG59KTtcblxuIiwiLyogXG4gKiBUcmFuc2Zvcm0gTkVYc29uIGRhdGEgaW50byBhIGZvcm0gc3VpdGFibGUgZm9yIHVzZSBpbiB0aGUgVHJlZSBJbGx1c3RyYXRvclxuICogYW5kIGQzLnBoeWxvZ3JhbS5qcy4gVGhpcyBleHRlbmRzIHRoZSBWZWdhJ3MgdmcuZGF0YSBzcGFjZSBzbyB3ZSBjYW4gdGFrZVxuICogYWR2YW50YWdlIG9mIGl0cyBwaXBlbGluZSBhbmQgb3RoZXIgZmVhdHVyZXMuIEl0J3MgcGF0dGVybmVkIGFmdGVyIHRoZSBcbiAqIHByb2plY3QncyB0cmVlbWFwLmpzLCB3aGljaCBhbHNvIGRvZXMgdHJhbnNmb3JtYXRpb24gdGllZCB0byBhIHNwZWNpZmljIFxuICogZDMgcmVwcmVzZW50YXRpb24uXG4gKiBcbiAqIEFudGljaXBhdGUgb3RoZXIgaW1wb3J0ZXJzIGxpa2UgdGhpcyBvbmUgZm9yIE5FWE1MLCBldGMuIChhc3N1bWVzIEpTT04/IG9yXG4gKiBjYW4gd2UgcGFyc2UgZnJlZS1mb3JtIHRleHQ/IFlFUywgc2luY2UgdmVnYSBoYW5kbGVzIENTViwgZXRjLikuIEVhY2ggb25lIFxuICogc2hvdWxkIHByb2R1Y2UgdGhlIHNhbWUgb3V0cHV0OiBhIHVuaWZvcm0gSlMgb2JqZWN0IHJlcHJlc2VudGluZyBhXG4gKiBkMy1yZWFkeSB0cmVlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL09wZW5UcmVlT2ZMaWZlL3RyZWUtaWxsdXN0cmF0b3Ivd2lraS9CdWlsZGluZy1vbi1EMy1hbmQtVmVnYSNkYXRhLWltcG9ydGVycylcbiAqXG4gKiBOT1RFIHRoYXQgdGhpcyBvdXRwdXQgY3JlYXRlcyBhIGJhc2ljIGxheW91dCB3aXRoIFggYW5kIFkgcG9zaXRpb24gZm9yIGVhY2hcbiAqIG5vZGUsIHNvIGFueSBicmFuY2gtcm90YXRpb24gc2NoZW1lIChlLmcuIGxhZGRlcml6ZWQgcmlnaHQpIG11c3QgYmUgYXBwbGllZFxuICogaGVyZSByYXRoZXIgdGhhbiBkb3duc3RyZWFtIVxuICovXG52YXIgdmcgID0gcmVxdWlyZSgndmVnYScpLFxuICAgIC8vZDMgID0gcmVxdWlyZSgnZDMnKSxcbiAgICBsb2cgID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgndmVnYS9zcmMvdHJhbnNmb3Jtcy9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gTmV4c29uKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgICAgdHJlZUlEOiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgICB0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbjoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDB9LFxuICAgICAgdHJlZVBvc2l0aW9uOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMH0sXG4gICAgICBicmFuY2hSb3RhdGlvbjoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdVTkNIQU5HRUQnfSxcbiAgICAgIG5vZGVMYWJlbEZpZWxkOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ29yaWdpbmFsTGFiZWwnfVxuICB9KTtcbiAgcmV0dXJuIHRoaXMucHJvZHVjZXModHJ1ZSlcbiAgICAgICAgICAgICAubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChOZXhzb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXhzb247XG5cbnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBsb2cuZGVidWcoaW5wdXQsIFsnY29udmVydGluZyB0byBuZXhzb24nXSk7XG5cbiAgdmFyIHRyZWVJRCA9IHRoaXMucGFyYW0oJ3RyZWVJRCcpLFxuICAgICAgdHJlZXNDb2xsZWN0aW9uUG9zaXRpb24gPSB0aGlzLnBhcmFtKCd0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvbicpLFxuICAgICAgdHJlZVBvc2l0aW9uID0gdGhpcy5wYXJhbSgndHJlZVBvc2l0aW9uJyksXG4gICAgICBicmFuY2hSb3RhdGlvbiA9IHRoaXMucGFyYW0oJ2JyYW5jaFJvdGF0aW9uJyksXG4gICAgICBub2RlTGFiZWxGaWVsZCA9IHRoaXMucGFyYW0oJ25vZGVMYWJlbEZpZWxkJyksXG4gICAgICBuZXhtbCA9IG51bGw7XG5cbiAgLypcbiAgICogTkVYc29uLXNwZWNpZmljIGxvZ2ljLCBlbmNhcHN1bGF0ZWQgZm9yIGVhc3kgYWNjZXNzIHRvIG5leG1sLCBldGMuXG4gICAqXG4gICAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vT3BlblRyZWVPZkxpZmUvb3BlbnRyZWUvYmxvYi83OWFhMWY0ZjcyOTQwYzBmNTcwOGZkMmNlZDU2MTkwZDhjMzRhZDlhL2N1cmF0b3Ivc3RhdGljL2pzL3N0dWR5LWVkaXRvci5qc1xuICAgKi9cbiAgdmFyIGZhc3RMb29rdXBzID0ge1xuICAgICAgJ05PREVTX0JZX0lEJzogbnVsbCxcbiAgICAgICdPVFVTX0JZX0lEJzogbnVsbCxcbiAgICAgICdFREdFU19CWV9TT1VSQ0VfSUQnOiBudWxsLFxuICAgICAgJ0VER0VTX0JZX1RBUkdFVF9JRCc6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0RmFzdExvb2t1cCggbG9va3VwTmFtZSApIHtcbiAgICAgIC8vIHJldHVybiAob3IgYnVpbGQpIGEgZmxhdCBsaXN0IG9mIE5leHNvbiBlbGVtZW50cyBieSBJRFxuICAgICAgaWYgKGxvb2t1cE5hbWUgaW4gZmFzdExvb2t1cHMpIHtcbiAgICAgICAgICBpZiAoZmFzdExvb2t1cHNbIGxvb2t1cE5hbWUgXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBidWlsZEZhc3RMb29rdXAoIGxvb2t1cE5hbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhc3RMb29rdXBzWyBsb29rdXBOYW1lIF07XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gc3VjaCBsb29rdXAgYXMgJ1wiKyBsb29rdXBOYW1lICtcIichXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRGYXN0TG9va3VwKCBsb29rdXBOYW1lICkge1xuICAgICAgLy8gKHJlKWJ1aWxkIGFuZCBzdG9yZSBhIGZsYXQgbGlzdCBvZiBOZXhzb24gZWxlbWVudHMgYnkgSURcbiAgICAgIGlmIChsb29rdXBOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgY2xlYXJGYXN0TG9va3VwKCBsb29rdXBOYW1lICk7XG4gICAgICAgICAgdmFyIG5ld0xvb2t1cCA9IHt9O1xuICAgICAgICAgIHN3aXRjaCggbG9va3VwTmFtZSApIHtcblxuICAgICAgICAgICAgICBjYXNlICdOT0RFU19CWV9JRCc6XG4gICAgICAgICAgICAgICAgICAvLyBhc3N1bWVzIHRoYXQgYWxsIG5vZGUgaWRzIGFyZSB1bmlxdWUsIGFjcm9zcyBhbGwgdHJlZXNcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLm5vZGUsIGZ1bmN0aW9uKCBpLCBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRzSUQgPSBub2RlWydAaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0c0lEIGluIG5ld0xvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVwbGljYXRlIG5vZGUgSUQgJ1wiKyBpdHNJRCArXCInIGZvdW5kIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMb29rdXBbIGl0c0lEIF0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdPVFVTX0JZX0lEJzpcbiAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZXMgdGhhdCBhbGwgbm9kZSBpZHMgYXJlIHVuaXF1ZSwgYWNyb3NzIGFsbCB0cmVlc1xuICAgICAgICAgICAgICAgICAgLy8gQU5EICdvdHVzJyBjb2xsZWN0aW9ucyFcbiAgICAgICAgICAgICAgICAgICQuZWFjaChuZXhtbC5vdHVzLCBmdW5jdGlvbiggaSwgb3R1c0NvbGxlY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG90dXNDb2xsZWN0aW9uLm90dSwgZnVuY3Rpb24oIGksIG90dSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0c0lEID0gb3R1WydAaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0c0lEIGluIG5ld0xvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVwbGljYXRlIG90dSBJRCAnXCIrIGl0c0lEICtcIicgZm91bmQhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgaXRzSUQgXSA9IG90dTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnRURHRVNfQllfU09VUkNFX0lEJzpcbiAgICAgICAgICAgICAgICAgIC8vIGFsbG93IG11bHRpcGxlIHZhbHVlcyBmb3IgZWFjaCBzb3VyY2UgKGllLCBtdWx0aXBsZSBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLmVkZ2UsIGZ1bmN0aW9uKCBpLCBlZGdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSUQgPSBlZGdlWydAc291cmNlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJRCBpbiBuZXdMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgc291cmNlSUQgXS5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFycmF5LCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgc291cmNlSUQgXSA9IFsgZWRnZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ0VER0VTX0JZX1RBUkdFVF9JRCc6XG4gICAgICAgICAgICAgICAgICAvLyBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgZm9yIGVhY2ggdGFyZ2V0IChmb3IgY29uZmxpY3RlZCB0cmVlcylcbiAgICAgICAgICAgICAgICAgIHZhciBhbGxUcmVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKG5leG1sLnRyZWVzLCBmdW5jdGlvbihpLCB0cmVlc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godHJlZXNDb2xsZWN0aW9uLnRyZWUsIGZ1bmN0aW9uKGksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHJlZXMucHVzaCggdHJlZSApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAkLmVhY2goYWxsVHJlZXMsIGZ1bmN0aW9uKCBpLCB0cmVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICQuZWFjaCh0cmVlLmVkZ2UsIGZ1bmN0aW9uKCBpLCBlZGdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SUQgPSBlZGdlWydAdGFyZ2V0J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJRCBpbiBuZXdMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgdGFyZ2V0SUQgXS5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFycmF5LCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xvb2t1cFsgdGFyZ2V0SUQgXSA9IFsgZWRnZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZhc3RMb29rdXBzWyBsb29rdXBOYW1lIF0gPSBuZXdMb29rdXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzdWNoIGxvb2t1cCBhcyAnXCIrIGxvb2t1cE5hbWUgK1wiJyFcIik7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJGYXN0TG9va3VwKCBsb29rdXBOYW1lICkge1xuICAgICAgLy8gY2xlYXIgY2hvc2VuIGxvb2t1cCwgb24gZGVtYW5kIChlZywgYWZ0ZXIgbWVyZ2luZyBpbiBuZXcgT1RVcylcbiAgICAgIGlmIChsb29rdXBOYW1lID09PSAnQUxMJykge1xuICAgICAgICAgIGZvciAodmFyIGFOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgICAgIGZhc3RMb29rdXBzWyBhTmFtZSBdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsb29rdXBOYW1lIGluIGZhc3RMb29rdXBzKSB7XG4gICAgICAgICAgZmFzdExvb2t1cHNbIGxvb2t1cE5hbWUgXSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHN1Y2ggbG9va3VwIGFzICdcIisgbG9va3VwTmFtZSArXCInIVwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXROZXhzb25DaGlsZHJlbihkKSB7XG4gICAgICB2YXIgcGFyZW50SUQgPSBkWydAaWQnXTtcbiAgICAgIHZhciBpdHNDaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIGNoaWxkRWRnZXMgPSBnZXRUcmVlRWRnZXNCeUlEKG51bGwsIHBhcmVudElELCAnU09VUkNFJyk7XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgb25lIGNoaWxkLCBpdCdzIHByb2JhYmx5IGEgbGF0ZW50IHJvb3Qtbm9kZSB0aGF0XG4gICAgICAvLyBzaG91bGQgYmUgaGlkZGVuIGluIHRoZSB0cmVlIHZpZXcuXG4gICAgICBpZiAoY2hpbGRFZGdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyB0cmVhdCBJVFMgY2hpbGQgbm9kZSBhcyBteSBpbW1lZGlhdGUgY2hpbGQgaW4gdGhlIGRpc3BsYXllZCB0cmVlXG4gICAgICAgICAgdmFyIG9ubHlDaGlsZE5vZGVJRCA9IGNoaWxkRWRnZXNbMF1bJ0B0YXJnZXQnXTtcbiAgICAgICAgICBjaGlsZEVkZ2VzID0gZ2V0VHJlZUVkZ2VzQnlJRChudWxsLCBvbmx5Q2hpbGROb2RlSUQsICdTT1VSQ0UnKTtcbiAgICAgIH1cblxuICAgICAgJC5lYWNoKGNoaWxkRWRnZXMsIGZ1bmN0aW9uKGluZGV4LCBlZGdlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkSUQgPSBlZGdlWydAdGFyZ2V0J107XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGdldFRyZWVOb2RlQnlJRChjaGlsZElEKTtcbiAgICAgICAgICBpZiAoISgnQGlkJyBpbiBjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCI+Pj4+Pj4+IGNoaWxkTm9kZSBpcyBhIDxcIisgdHlwZW9mKGNoaWxkTm9kZSkgK1wiPlwiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdHNDaGlsZHJlbi5wdXNoKCBjaGlsZE5vZGUgKTtcbiAgICAgIH0pO1xuICAgICAgLy8gTi5CLiBEMyBsYXlvdXRzIGV4cGVjdCBudWxsLCBpbnN0ZWFkIG9mIGFuIGVtcHR5IGFycmF5XG4gICAgICAvLy9yZXR1cm4gKGl0c0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkgPyBudWxsOiBpdHNDaGlsZHJlbjtcbiAgICAgIHJldHVybiBpdHNDaGlsZHJlbjtcbiAgfVxuICBmdW5jdGlvbiBjb3VudERlc2NlbmRhbnRUaXBzKCBub2RlICkge1xuICAgICAgLyogUmVjdXJzZSB0aHJvdWdoIGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGUgYW5kIGNvdW50IHRoZSB0aXBzLFxuICAgICAgICogYWRkaW5nIHRoZSB0b3RhbCBhcyBhbiBhZC1ob2MgcHJvcGVydHkgb2YgdGhlIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogU2luY2UgdGhlc2UgdG90YWxzIGFyZSBvZnRlbiB1c2VkIGluIGZvciBicmFuY2ggcm90YXRpb24sIHdlIHNob3VsZCBiZVxuICAgICAgICogYWJsZSB0byBwcmUtcHJvY2VzcyBub2RlcyBhcyBuZWVkZWQsIHRoZW4gcnVuIGEgZmluYWwgc3dlZXAgdGhhdFxuICAgICAgICogb25seSBwcm9jZXNzZXMgdW4tbW9kaWZpZWQgbm9kZXMuXG4gICAgICAgKlxuICAgICAgICogVE9ETzogQ291bnQganVzdCB0aXBzPyBvciBhbGwgZGVzY2VuZGFudHM/XG4gICAgICAgKi9cbiAgICAgIGlmICgnZGVzY2VuZGFudFRpcENvdW50JyBpbiBub2RlKSB7ICAgLy8gZG8gdGhpcyBvbmNlIG9ubHkhXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0TmV4c29uQ2hpbGRyZW4obm9kZSk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gdGhpcyBub2RlIGlzIGEgbGVhZiBhbmQgc2hvdWxkIFwiY291bnQgaXRzZWxmXCJcbiAgICAgICAgICBub2RlLmRlc2NlbmRhbnRUaXBDb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aXBDb3VudCA9IDA7XG4gICAgICAgICAgJC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihpLCBjaGlsZCkge1xuICAgICAgICAgICAgICBjb3VudERlc2NlbmRhbnRUaXBzKGNoaWxkKTtcbiAgICAgICAgICAgICAgdGlwQ291bnQgKz0gY2hpbGQuZGVzY2VuZGFudFRpcENvdW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5vZGUuZGVzY2VuZGFudFRpcENvdW50ID0gdGlwQ291bnQ7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduTm9kZUxhYmVscyggbm9kZSApIHtcbiAgICAgIC8qIEFkZCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgc2hvd24gYXMgbGFiZWxzLiBTaW5jZSB0aGVzZVxuICAgICAgICogY2FuIGFsc28gYmUgdXNlZCBpbiBhbiBhbHBoYWJldGljYWwgc29ydCAoZm9yIGJyYW5jaCByb3RhdGlvbiksIHdlXG4gICAgICAgKiBzaG91bGQgYmUgYWJsZSB0byBwcmUtcHJvY2VzcyB0aGVzZSBhcyBuZWVkZWQsIGZvbGxvd2VkIGJ5IGEgZmluYWxcbiAgICAgICAqIHN3ZWVwIHRoYXQganVzdCBwcm9jZXNzZXMgYW55IHVuLW1vZGlmaWVkIG5vZGVzLlxuICAgICAgICovXG4gICAgICBpZiAoJ29yaWdpbmFsTGFiZWwnIGluIG5vZGUpIHsgICAvLyBkbyB0aGlzIG9uY2Ugb25seSFcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKiBOLkIuIEl0J3MgYmVzdCB0byBwcm92aWRlIGF0IGxlYXN0IGFuIGVtcHR5IHN0cmluZyBmb3IgYWxsXG4gICAgICAgKiBwcm9wZXJ0aWVzLCB0byBhdm9pZCBzaG93aW5nICd1bmRlZmluZWQnIGxhYmVscyBpbiBzb21lIGJyb3dzZXJzLlxuICAgICAgICovXG4gICAgICBub2RlLmV4cGxpY2l0TGFiZWwgPSAnJztcbiAgICAgIG5vZGUub3JpZ2luYWxMYWJlbCA9ICcnO1xuICAgICAgbm9kZS5vdHRUYXhvbk5hbWUgPSAnJztcbiAgICAgIG5vZGUub3R0SWQgPSAnJztcbiAgICAgIGlmICgnbGFiZWwnIGluIG5vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCI+PiB0aGlzIG5vZGUgaGFzICdsYWJlbCdcIik7XG4gICAgICAgIG5vZGUuZXhwbGljaXRMYWJlbCA9IG5vZGVbJ2xhYmVsJ107XG4gICAgICB9XG4gICAgICBpZiAoJ0BsYWJlbCcgaW4gbm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+IHRoaXMgbm9kZSBoYXMgJ0BsYWJlbCdcIik7XG4gICAgICAgIG5vZGUuZXhwbGljaXRMYWJlbCA9IG5vZGVbJ0BsYWJlbCddO1xuICAgICAgfVxuICAgICAgaWYgKCdAb3R1JyBpbiBub2RlKSB7XG4gICAgICAgIHZhciBpdHNPVFUgPSBnZXRPVFVCeUlEKCBub2RlWydAb3R1J10gKTtcbiAgICAgICAgLy8gYXR0YWNoIE9UVSB3aXRoIHBvc3NpYmxlIGxhYmVsKHMpIGhlcmVcbiAgICAgICAgaWYgKGl0c09UVSkge1xuICAgICAgICAgIC8vIG51ZGdlIHRoZSByZWxldmFudCBwcm9wZXJ0aWVzIGludG8gYSBnZW5lcmljIGZvcm1cbiAgICAgICAgICBpZiAoJ15vdDpvcmlnaW5hbExhYmVsJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgIG5vZGUub3JpZ2luYWxMYWJlbCA9IGl0c09UVVsnXm90Om9yaWdpbmFsTGFiZWwnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdeb3Q6b3R0VGF4b25OYW1lJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgIG5vZGUub3R0VGF4b25OYW1lID0gaXRzT1RVWydeb3Q6b3R0VGF4b25OYW1lJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnXm90Om90dElkJyBpbiBpdHNPVFUpIHtcbiAgICAgICAgICAgIG5vZGUub3R0SWQgPSBpdHNPVFVbJ15vdDpvdHRJZCddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ0BsYWJlbCcgaW4gaXRzT1RVKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVuY29tbW9uLCBidXQgYXBwZWFycyBpbiBvdXIgY29udmVydGVkIE5ld2ljay5cbiAgICAgICAgICAgIC8vIFlpZWxkIHRvIGFuIGV4cGxpY2l0IGxhYmVsIG9uIHRoZSBub2RlIGl0c2VsZiFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiPj4gc3RlYWxpbmcgb3R1IGxhYmVsICdcIisgaXRzT1RVWydAbGFiZWwnXSArXCInIGZvciB0aGlzIG5vZGVcIik7XG4gICAgICAgICAgICBpZiAoJC50cmltKG5vZGUuZXhwbGljaXRMYWJlbCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgIG5vZGUuZXhwbGljaXRMYWJlbCA9IGl0c09UVVsnQGxhYmVsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VHJlZU5vZGVCeUlEKGlkKSB7XG4gICAgICAvLyBUaGVyZSBzaG91bGQgYmUgb25seSBvbmUgbWF0Y2hpbmcgKG9yIG5vbmUpIHdpdGhpbiBhIHRyZWVcbiAgICAgIC8vIChOT1RFIHRoYXQgd2Ugbm93IHVzZSBhIGZsYXQgY29sbGVjdGlvbiBhY3Jvc3MgYWxsIHRyZWVzLCBzbyB0aGVyZSdzIG5vICd0cmVlJyBhcmd1bWVudClcbiAgICAgIHZhciBsb29rdXAgPSBnZXRGYXN0TG9va3VwKCdOT0RFU19CWV9JRCcpO1xuICAgICAgcmV0dXJuIGxvb2t1cFsgaWQgXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldE9UVUJ5SUQoaWQpIHtcbiAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBtYXRjaGluZyAob3Igbm9uZSkgaW4gdGhpcyBzdHVkeVxuICAgICAgdmFyIGxvb2t1cCA9IGdldEZhc3RMb29rdXAoJ09UVVNfQllfSUQnKTtcbiAgICAgIHJldHVybiBsb29rdXBbIGlkIF0gfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRUcmVlRWRnZXNCeUlEKHRyZWUsIGlkLCBzb3VyY2VPclRhcmdldCkge1xuICAgICAgLy8gbG9vayBmb3IgYW55IGVkZ2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkICpub2RlKiBJRDsgcmV0dXJuXG4gICAgICAvLyBhbiBhcnJheSBvZiAwLCAxLCBvciBtb3JlIG1hdGNoaW5nIGVkZ2VzIHdpdGhpbiBhIHRyZWVcbiAgICAgIC8vXG4gICAgICAvLyAnc291cmNlT3JUYXJnZXQnIGxldHMgdXMgZmlsdGVyLCBzaG91bGQgYmUgJ1NPVVJDRScsICdUQVJHRVQnLCAnQU5ZJ1xuICAgICAgdmFyIGZvdW5kRWRnZXMgPSBbXTtcbiAgICAgIHZhciBtYXRjaGluZ0VkZ2VzID0gbnVsbDtcblxuICAgICAgaWYgKChzb3VyY2VPclRhcmdldCA9PT0gJ1NPVVJDRScpIHx8IChzb3VyY2VPclRhcmdldCA9PT0gJ0FOWScpKSB7XG4gICAgICAgICAgLy8gZmV0Y2ggYW5kIGFkZCBlZGdlcyB3aXRoIHRoaXMgc291cmNlIG5vZGVcbiAgICAgICAgICB2YXIgc291cmNlTG9va3VwID0gZ2V0RmFzdExvb2t1cCgnRURHRVNfQllfU09VUkNFX0lEJyk7XG4gICAgICAgICAgbWF0Y2hpbmdFZGdlcyA9IHNvdXJjZUxvb2t1cFsgaWQgXTtcbiAgICAgICAgICBpZiAobWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICBmb3VuZEVkZ2VzID0gZm91bmRFZGdlcy5jb25jYXQoIG1hdGNoaW5nRWRnZXMgKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoc291cmNlT3JUYXJnZXQgPT09ICdUQVJHRVQnKSB8fCAoc291cmNlT3JUYXJnZXQgPT09ICdBTlknKSkge1xuICAgICAgICAgIC8vIGZldGNoIGFuZCBhZGQgZWRnZXMgd2l0aCB0aGlzIHRhcmdldCBub2RlXG4gICAgICAgICAgdmFyIHRhcmdldExvb2t1cCA9IGdldEZhc3RMb29rdXAoJ0VER0VTX0JZX1RBUkdFVF9JRCcpO1xuICAgICAgICAgIG1hdGNoaW5nRWRnZXMgPSB0YXJnZXRMb29rdXBbIGlkIF07XG4gICAgICAgICAgaWYgKG1hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgZm91bmRFZGdlcyA9IGZvdW5kRWRnZXMuY29uY2F0KCBtYXRjaGluZ0VkZ2VzICk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm91bmRFZGdlcztcbiAgfVxuICBmdW5jdGlvbiBnZXRTcGVjaWZpZWRUcmVlKCkge1xuICAgIHZhciB0cmVlID0gbnVsbDtcbiAgICAvLyB0cnkgYWxsIGluY29taW5nIG9wdGlvbnMgdG8gbG9jYXRlIHRoaXMgdHJlZVxuICAgIGlmICgkLnRyaW0odHJlZUlEKSAhPT0gJycpIHtcbiAgICAgICAgdHJlZSA9IGdldFRyZWVCeUlEKHRyZWVJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJlZSA9IGdldFRyZWVCeVBvc2l0aW9uKHRyZWVzQ29sbGVjdGlvblBvc2l0aW9uLCB0cmVlUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUcmVlQnlJRChpZCkge1xuICAgICAgdmFyIGFsbFRyZWVzID0gW107XG4gICAgICBpZiAoIW5leG1sKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAkLmVhY2gobmV4bWwudHJlZXMsIGZ1bmN0aW9uKGksIHRyZWVzQ29sbGVjdGlvbikge1xuICAgICAgICAgICQuZWFjaCh0cmVlc0NvbGxlY3Rpb24udHJlZSwgZnVuY3Rpb24oaSwgdHJlZSkge1xuICAgICAgICAgICAgICBhbGxUcmVlcy5wdXNoKCB0cmVlICk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBmb3VuZFRyZWUgPSBudWxsO1xuICAgICAgJC5lYWNoKCBhbGxUcmVlcywgZnVuY3Rpb24oaSwgdHJlZSkge1xuICAgICAgICAgIGlmICh0cmVlWydAaWQnXSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgZm91bmRUcmVlID0gdHJlZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kVHJlZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUcmVlQnlQb3NpdGlvbihjb2xsZWN0aW9uUG9zLCB0cmVlUG9zKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBuZXhtbC50cmVlc1tjb2xsZWN0aW9uUG9zXTtcbiAgICB2YXIgdHJlZSA9IGNvbGxlY3Rpb24udHJlZVt0cmVlUG9zXTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb290Tm9kZSgpIHtcbiAgICAvLyB1c2Ugb3B0aW9ucyB0byBmaW5kIHRoZSByb290IG5vZGUsIG9yIHJldHVybiBudWxsXG4gICAgdmFyIGZvdW5kUm9vdCA9IG51bGw7XG4gICAgdmFyIHRyZWUgPSBnZXRTcGVjaWZpZWRUcmVlKCk7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3BlY2lmaWVkUm9vdCA9IHRyZWVbJ15vdDpzcGVjaWZpZWRSb290J10gfHwgbnVsbDtcbiAgICB2YXIgcm9vdE5vZGVJRCA9IHNwZWNpZmllZFJvb3QgPyBzcGVjaWZpZWRSb290IDogdHJlZS5ub2RlWzBdWydAaWQnXTtcbiAgICAkLmVhY2godHJlZS5ub2RlLCBmdW5jdGlvbihpLCBub2RlKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIG5vZGUgd2l0aCB0aGlzIElEIGFuZCBzZWUgaWYgaXQgaGFzIGFuIGFzc2lnbmVkIE9UVVxuICAgICAgICBpZiAobm9kZVsnQGlkJ10gPT09IHJvb3ROb2RlSUQpIHtcbiAgICAgICAgICAgIGZvdW5kUm9vdCA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmRSb290O1xuICB9XG4gIC8qIEVORCBvZiAnTkVYc29uLXNwZWNpZmljIGxvZ2ljJyAqL1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnQoZnVsbE5leHNvbikge1xuICAgIC8vIGNvbnZlcnQgYSBuZXcgKG9yIGNoYW5nZWQ/KSB0cmVlIHRvIFRyZWUgSWxsdXN0cmF0b3IncyBwcmVmZXJyZWQgZm9ybWF0XG4gICAgbmV4bWwgPSBmdWxsTmV4c29uLmRhdGEubmV4bWw7XG5cbiAgICAvKiBBcHBseSB0aGUgY2hvc2VuIGJyYW5jaC1yb3RhdGlvbiBtZXRob2QsIGkuZS4gaG93IGNoaWxkIG5vZGVzIGFyZVxuICAgICAqIG9yZGVyZWQgd2l0aGluIHRoZSB0cmVlLiBOb3RlIHRoYXQgYWxsIG9wdGlvbnMgaGVyZSBzaG91bGQgYmVcbiAgICAgKiBkZXRlcm1pbmlzdGljOyB0aGUgc2FtZSBpbnB1dCB0cmVlIGFuZCByb3RhdGlvbiBtZXRob2Qgc2hvdWxkICphbHdheXMqXG4gICAgICogcHJvZHVjZSB0aGUgc2FtZSBvdXRwdXQuIFdlJ2xsIGFjY29tcGxpc2ggdGhpcyBieSB1c2luZyBkMydzXG4gICAgICogYWxwaGFiZXRpY2FsIHNvcnQgYXMgdGhlIHRpZS1icmVha2VyLlxuICAgICAqXG4gICAgICogU29tZSBvZiB0aGVzZSBtZXRob2RzIGludHJvZHVjZSBuZXcgYnVyZGVuczpcbiAgICAgKiAgLSBTb3J0aW5nIGJ5IGNsYWRlIHNpemUgbWVhbnMgd2UgbmVlZCB0byByZWN1cnNlIGFuZCBjb3VudCBjaGlsZHJlbiBmb3JcbiAgICAgKiAgICBhbGwgbm9kZXMgYWhlYWQgb2YgdGltZS5cbiAgICAgKiAgLSBBbHBoYS1zb3J0aW5nIHVzZXMgYWN0aXZlIG5vZGUgbGFiZWxzLCBzbyB3ZSBuZWVkIHRvIGtub3cgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgY2hvaWNlcyBiZWxvdyBhcmUgZW51bWVyYXRlZCBpbiBUcmVlSWxsdXN0cmF0b3IuanMsIHNvIGFueVxuICAgICAqIGNoYW5nZXMgc2hvdWxkIGJlIHNoYXJlZCBpbiBib3RoIHBsYWNlcy5cbiAgICAgKi9cbiAgICB2YXIgYnJhbmNoUm90YXRvcjtcbiAgICBzd2l0Y2goYnJhbmNoUm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAnVU5DSEFOR0VEJzpcbiAgICAgICAgICAgIGJyYW5jaFJvdGF0b3IgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FMUEhBQkVUSUNBTCc6XG4gICAgICAgICAgICBicmFuY2hSb3RhdG9yID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgICAgICAgICAgLy8gc29ydCBiYXNlZCBvbiB0aGUgdXNlcidzIGNob3NlbiBmaWVsZCAocGFzc2VkIGFzIHBhcmFtKVxuICAgICAgICAgICAgICAgIGFzc2lnbk5vZGVMYWJlbHMoYSk7XG4gICAgICAgICAgICAgICAgYXNzaWduTm9kZUxhYmVscyhiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMuZGVzY2VuZGluZyhhWyBub2RlTGFiZWxGaWVsZCBdLCBiWyBub2RlTGFiZWxGaWVsZCBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTEFEREVSSVpFX1JJR0hUJzpcbiAgICAgICAgICAgIGJyYW5jaFJvdGF0b3IgPSBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICBjb3VudERlc2NlbmRhbnRUaXBzKGEpO1xuICAgICAgICAgICAgICAgIGNvdW50RGVzY2VuZGFudFRpcHMoYik7XG4gICAgICAgICAgICAgICAgaWYgKGEuZGVzY2VuZGFudFRpcENvdW50ID4gYi5kZXNjZW5kYW50VGlwQ291bnQpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYi5kZXNjZW5kYW50VGlwQ291bnQgPiBhLmRlc2NlbmRhbnRUaXBDb3VudCkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgLy8gU3RpbGwgaGVyZT8gRmFsbCBiYWNrIHRvIGFscGhhYmV0aWMgc29ydFxuICAgICAgICAgICAgICAgIGFzc2lnbk5vZGVMYWJlbHMoYSk7XG4gICAgICAgICAgICAgICAgYXNzaWduTm9kZUxhYmVscyhiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMuZGVzY2VuZGluZyhhWyBub2RlTGFiZWxGaWVsZCBdLCBiWyBub2RlTGFiZWxGaWVsZCBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTEFEREVSSVpFX0xFRlQnOlxuICAgICAgICAgICAgYnJhbmNoUm90YXRvciA9IGZ1bmN0aW9uKGEsYikge1xuICAgICAgICAgICAgICAgIGNvdW50RGVzY2VuZGFudFRpcHMoYSk7XG4gICAgICAgICAgICAgICAgY291bnREZXNjZW5kYW50VGlwcyhiKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5kZXNjZW5kYW50VGlwQ291bnQgPiBiLmRlc2NlbmRhbnRUaXBDb3VudCkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKGIuZGVzY2VuZGFudFRpcENvdW50ID4gYS5kZXNjZW5kYW50VGlwQ291bnQpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAvLyBTdGlsbCBoZXJlPyBGYWxsIGJhY2sgdG8gYWxwaGFiZXRpYyBzb3J0XG4gICAgICAgICAgICAgICAgYXNzaWduTm9kZUxhYmVscyhhKTtcbiAgICAgICAgICAgICAgICBhc3NpZ25Ob2RlTGFiZWxzKGIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkMy5kZXNjZW5kaW5nKGFbIG5vZGVMYWJlbEZpZWxkIF0sIGJbIG5vZGVMYWJlbEZpZWxkIF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaSUdfWkFHJzpcbiAgICAgICAgICAgIC8vIE1pbWljIHRoZSBsYWRkZXJpemUgb3B0aW9ucyBhYm92ZSwgYnV0IGFsdGVybmF0ZSBsZWZ0IGFuZCByaWdodCBlYWNoIHRpbWVcbiAgICAgICAgICAgIHZhciBsZWZ0T3JSaWdodCA9ICdMRUZUJztcbiAgICAgICAgICAgIGJyYW5jaFJvdGF0b3IgPSBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICBjb3VudERlc2NlbmRhbnRUaXBzKGEpO1xuICAgICAgICAgICAgICAgIGNvdW50RGVzY2VuZGFudFRpcHMoYik7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRPclJpZ2h0ID09PSAnTEVGVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdE9yUmlnaHQgPSAnUklHSFQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5kZXNjZW5kYW50VGlwQ291bnQgPiBiLmRlc2NlbmRhbnRUaXBDb3VudCkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmRlc2NlbmRhbnRUaXBDb3VudCA+IGEuZGVzY2VuZGFudFRpcENvdW50KSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgIC8vIHByZXN1bWFibHkgaXQncyAnUklHSFQnXG4gICAgICAgICAgICAgICAgICAgIGxlZnRPclJpZ2h0ID0gJ0xFRlQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5kZXNjZW5kYW50VGlwQ291bnQgPiBiLmRlc2NlbmRhbnRUaXBDb3VudCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYi5kZXNjZW5kYW50VGlwQ291bnQgPiBhLmRlc2NlbmRhbnRUaXBDb3VudCkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0aWxsIGhlcmU/IEZhbGwgYmFjayB0byBhbHBoYWJldGljIHNvcnRcbiAgICAgICAgICAgICAgICBhc3NpZ25Ob2RlTGFiZWxzKGEpO1xuICAgICAgICAgICAgICAgIGFzc2lnbk5vZGVMYWJlbHMoYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLmRlc2NlbmRpbmcoYVsgbm9kZUxhYmVsRmllbGQgXSwgYlsgbm9kZUxhYmVsRmllbGQgXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gc3VjaCBicmFuY2gtcm90YXRpb24gbWV0aG9kOiAnXCIrIGJyYW5jaFJvdGF0aW9uICtcIichXCIpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBkMy5sYXlvdXQuY2x1c3RlcigpICAvLyBvciB0cmVlIChzZWVtcyBtb3N0IGJhc2ljKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc2l6ZShbMS4wLCAxLjBdKSAgLy8ganVzdCBtYWtpbmcgdGhlIGRlZmF1bHQgc2l6ZSBleHBsaWNpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VwYXJhdGlvbihmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSB3YW50IGFsbCB0aXBzIChsZWF2ZXMpIHRvIGJlIGV2ZW5seSBzcGFjZWQsIHdoZXRoZXIgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBub3QgdGhleSBhcmUgc2libGluZ3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9DbHVzdGVyLUxheW91dCNzZXBhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIChhLnBhcmVudCA9PSBiLnBhcmVudCkgPyAxIDogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oZ2V0TmV4c29uQ2hpbGRyZW4pICAgLy8gZGVmaW5lZCBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoYnJhbmNoUm90YXRvciksICAgLy8gZGVmaW5lZCBhYm92ZVxuICAgICAgICBwYXJhbXMgPSBbICdzaXplJyBdLCAgLy8gW1wicm91bmRcIiwgXCJzdGlja3lcIiwgXCJyYXRpb1wiLCBcInBhZGRpbmdcIl0sXG4gICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAvL1wieFwiOiBcInhcIixcbiAgICAgICAgICAvL1wieVwiOiBcInlcIixcbiAgICAgICAgICAvL1wiZHhcIjogXCJ3aWR0aFwiLFxuICAgICAgICAgIC8vXCJkeVwiOiBcImhlaWdodFwiXG4gICAgICAgIH07XG5cbiAgICB2YXIgcm9vdE5vZGUgPSBnZXRSb290Tm9kZSgpOyAgLy8gZGVmaW5lZCBiZWxvd1xuICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIHJvb3Qgbm9kZSBmb3VuZCFcIik7XG4gICAgICBjb25zb2xlLndhcm4oXCIgIHRyZWVJRDogXCIrIHRyZWVJRCk7XG4gICAgICBjb25zb2xlLndhcm4oXCIgIHRyZWVzQ29sbGVjdGlvblBvc2l0aW9uOiBcIisgdHJlZXNDb2xsZWN0aW9uUG9zaXRpb24pO1xuICAgICAgY29uc29sZS53YXJuKFwiICB0cmVlUG9zaXRpb246IFwiKyB0cmVlUG9zaXRpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGEgPSB7XG4gICAgICAgIC8vIGNvcHkgX2lkIG9mIHNvdXJjZSBkYXRhXG4gICAgICAgICdfaWQnOiBmdWxsTmV4c29uLl9pZFxuICAgIH07XG5cbiAgICBkYXRhLnBoeWxvTm9kZXMgPSBsYXlvdXRcbiAgICAgIC8vLnNpemUodmcuZGF0YS5zaXplKHNpemUsIGdyb3VwKSlcbiAgICAgIC8vLnZhbHVlKHZhbHVlKVxuICAgICAgICAubm9kZXMocm9vdE5vZGUpO1xuXG4gICAgLyogTm9ybWFsaXplIHRoZSBub2RlIGxvY2F0aW9ucyB0byBmaWxsIHRoZSBzcGVjaWZpZWQgYXJlYS4gVGhpcyB3aWxsXG4gICAgICogZW5zdXJlIHRoYXQgdGhlIHJlbmRlcmVkIHRyZWUgbWF0Y2hlcyBvdXIgdXNlcidzIGNob3NlbiBzaXplLCBhbmQgdGhhdFxuICAgICAqIHJhZGlhbCB0cmVlcyBkb24ndCBoYXZlIHdlaXJkIGdhcHMuXG4gICAgICovXG4gICAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIG1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgJC5lYWNoKGRhdGEucGh5bG9Ob2RlcywgZnVuY3Rpb24oaSwgbm9kZSkge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgbm9kZS54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIG5vZGUueSk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBub2RlLngpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgbm9kZS55KTtcbiAgICB9KTtcbiAgICB2YXIgeFNjYWxlID0gMS4wIC8gKG1heFggLSBtaW5YKTtcbiAgICB2YXIgeVNjYWxlID0gMS4wIC8gKG1heFkgLSBtaW5ZKTtcbiAgICAkLmVhY2goZGF0YS5waHlsb05vZGVzLCBmdW5jdGlvbihpLCBub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSBtaW5YKSAqIHhTY2FsZTtcbiAgICAgICAgbm9kZS55ID0gKG5vZGUueSAtIG1pblkpICogeVNjYWxlO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGFsbCBwb3NzaWJsZSBsYWJlbHMgdG8gZWFjaCBub2RlXG4gICAgdmFyIHRyZWUgPSBnZXRTcGVjaWZpZWRUcmVlKCk7XG4gICAgJC5lYWNoKGRhdGEucGh5bG9Ob2RlcywgZnVuY3Rpb24oaSwgbm9kZSkge1xuICAgICAgICBhc3NpZ25Ob2RlTGFiZWxzKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgZGF0YS5waHlsb0VkZ2VzID0gbGF5b3V0LmxpbmtzKGRhdGEucGh5bG9Ob2Rlcyk7XG4vKiB0cmFuc2xhdGUgaW5jb21pbmcga2V5cyB0byB0aGVpciBvdXRwdXQgbmFtZXM/XG4gICAgdmFyIGtleXMgPSB2Zy5rZXlzKG91dHB1dCksXG4gICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxsZW47ICsraSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ICE9PSBvdXRwdXRba2V5XSkge1xuICAgICAgICAgIHZhbCA9IGRba2V5XTtcbiAgICAgICAgICBkZWxldGUgZFtrZXldO1xuICAgICAgICAgIGRbb3V0cHV0W2tleV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2QuY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihkKTtcbiAgICB9KTtcbiovXG5cbi8qXG4gICAgY29uc29sZS5sb2coXCJPVVRHT0lORyBkYXRhIGZyb20gbmV4c29uIHRyYW5zZm9ybTpcIik7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4qL1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIFxuICAvL2lucHV0LmFkZC5mb3JFYWNoKGNvbnZlcnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LmFkZC5sZW5ndGg7IGkrKykge1xuICAgIC8vIGFjdHVhbGx5IHJlcGxhY2UgZWFjaCBpdGVtIHdpdGggdGhlIG5ldyBzdHVjdHVyZVxuICAgIGlucHV0LmFkZFtpXSA9IGNvbnZlcnQoaW5wdXQuYWRkW2ldKTtcbiAgfVxuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIC8vaW5wdXQubW9kLmZvckVhY2goY29udmVydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5tb2QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGFjdHVhbGx5IHJlcGxhY2UgZWFjaCBpdGVtIHdpdGggdGhlIG5ldyBzdHVjdHVyZVxuICAgICAgaW5wdXQubW9kW2ldID0gY29udmVydChpbnB1dC5tb2RbaV0pO1xuICAgIH1cbiAgfVxuICAvLyByZXR1cm4gdGhlIG1vZGlmaWVkIENoYW5nZVNldFxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5leHNvbjtcblxuTmV4c29uLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJOZXhzb24gdHJhbnNmb3JtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUcmFuc2Zvcm1zIE5FWHNvbiBkYXRhIGludG8gYSBmb3JtIHN1aXRhYmxlIGZvciB1c2UgaW4gdGhlIFRyZWUgSWxsdXN0cmF0b3JcIlxuICAgICAgICAgICAgICAgKyBcIiBhbmQgZDMucGh5bG9ncmFtLmpzLlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1wiZW51bVwiOiBbXCJuZXhzb25cIl19LFxuICAgIFwidHJlZUlEXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBleHBsaWNpdCB0cmVlIElEIChzaG91bGQgYmUgZGVmaW5pdGl2ZSlcIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJzdHJpbmdcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSAgLy8gVE9ETzogc2lnbmFsP1xuICAgIH0sXG4gICAgXCJ0cmVlc0NvbGxlY3Rpb25Qb3NpdGlvblwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9vayBpbiB0aGUgbnRoICd0cmVlcycgZWxlbWVudCAoY29sbGVjdGlvbiBvZiAndHJlZScpXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwiaW50ZWdlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLCAgLy8gVE9ETzogc2lnbmFsP1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIFwidHJlZVBvc2l0aW9uXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb252ZXJ0IHRoZSBudGggJ3RyZWUnIGZvdW5kIGluIHRoaXMgY29sbGVjdGlvblwiLCAvLyBUT0RPOiBjb25maXJtXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwiaW50ZWdlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsICAvLyBUT0RPOiBjb25maXJtIHRoaXNcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eXBlXCJdICAvLyBUT0RPOiBhZGQgcmVxdWlyZWQgcGFyYW1zXG59O1xuIiwiLypcbiAgKEhlYXZpbHkpIGFkYXB0ZWQgZnJvbSBLZW4taWNoaSBVZWRhJ3MgJ2QzLnBoeWxvZ3JhbS5qcydcblxuICBXcmFwcGVyIGFyb3VuZCBhIGQzLWJhc2VkIHBoeWxvZ3JhbSAodHJlZSB3aGVyZSBicmFuY2ggbGVuZ3RocyBhcmUgc2NhbGVkKSxcbiAgcmVmYWN0b3JlZCBpbnRvIGEgVmVnYSB0cmFuc2Zvcm0uIFdoYXQgZG9lcyB0aGlzIGNoYW5nZT9cbiAgICAtIFJldHVybnMgdHJhbnNmb3JtZWQgZGF0YSAoYW4gb2JqZWN0IHdpdGggbm9kZXMgYW5kIGxpbmtzLCBwcm9qZWN0ZWQgdG9cbiAgICAgIHRoZSBjb29yZGluYXRlIHNwYWNlIGJhc2VkIG9uIHRoZSBjaG9zZW4gbGF5b3V0KS5cbiAgICAtIEFzc3VtZXMgYWxsIGluY29taW5nIGRhdGEgaGFzIHByb3BvcnRpb25hbCB4L3kgdmFsdWVzICgwLjAgdG8gMS4wKS5cbiAgICAtIERvZXNuJ3QgcmVuZGVyIGFueXRoaW5nISBKdXN0IHBhc3NlcyB0aGUgcHJvamVjdGVkIGRhdGEgZm9yIGRvd25zdHJlYW1cbiAgICAgIHJlbmRlcmluZy5cblxuICBUaGlzIGluY2x1ZGVzIG5ldyBhbmQgbW9kaWZpZWQgbGF5b3V0cywgaW5jbHVkaW5nXG4gICAgLSByYWRpYWwgKGNpcmN1bGFyKSBsYXlvdXQgd2l0aCAqc2NhbGVkKiBicmFuY2ggbGVuZ3Roc1xuICAgIC0gYSB0cmFkaXRpb25hbCBjbGFkb2dyYW0gd2l0aCBzdHJhaWdodCwgZGlhZ29uYWwgZWRnZXNcblxuICBDb3B5cmlnaHQgKGMpIDIwMTQsIEppbSBBbGxtYW5cbiAgQ29weXJpZ2h0IChjKSAyMDEzLCBLZW4taWNoaSBVZWRhXG5cbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5XG4gIGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZFxuICB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG4gIERPQ1VNRU5UQVRJT05cblxuICBidWlsZENhcnRlc2lhbihub2RlcywgbGlua3MsIG9wdGlvbnMpXG4gICAgQ3JlYXRlcyBhIHBoeWxvZ3JhbS5cbiAgICBBcmd1bWVudHM6XG4gICAgICBub2RlczogSlMgYXJyYXkgb2Ygbm9kZXNcbiAgICAgIGxpbmtzOiBKUyBhcnJheSBvZiBsaW5rc1xuICAgIE9wdGlvbnM6XG4gICAgICB0cmVlXG4gICAgICAgIFByZS1jb25zdHJ1Y3RlZCBkMyB0cmVlIGxheW91dC5cbiAgICAgIGRpYWdvbmFsXG4gICAgICAgIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgZCBhdHRyaWJ1dGUgZm9yIGFuIHN2ZzpwYXRoLiBEZWZhdWx0cyB0byBhXG4gICAgICAgIHJpZ2h0LWFuZ2xlIGRpYWdvbmFsLlxuICAgICAgc2tpcFRpY2tzXG4gICAgICAgIFNraXAgdGhlIHRpY2sgcnVsZS5cbiAgICAgIHNraXBCcmFuY2hMZW5ndGhTY2FsaW5nXG4gICAgICAgIE1ha2UgYSBkZW5kcm9ncmFtIGluc3RlYWQgb2YgYSBwaHlsb2dyYW0uXG4gIFxuICBidWlsZFJhZGlhbChub2RlcywgbGlua3MsIG9wdGlvbnMpXG4gICAgQ3JlYXRlcyBhIHJhZGlhbCBkZW5kcm9ncmFtLlxuICAgIE9wdGlvbnM6IHNhbWUgYXMgYnVpbGQsIGJ1dCB3aXRob3V0IGRpYWdvbmFsLCBza2lwVGlja3MsIGFuZFxuICAgICAgc2tpcEJyYW5jaExlbmd0aFNjYWxpbmdcbiAgXG4gIGJ1aWxkQ2xhZG9ncmFtKG5vZGVzLCBsaW5rcywgb3B0aW9ucylcbiAgICBDcmVhdGVzIGEgXCJ0cmlhbmd1bGFyXCIgZGVuZHJvZ3JhbVxuICAgIE9wdGlvbnM6IFRPRE9cblxuICByaWdodEFuZ2xlRGlhZ29uYWwoKVxuICAgIFNpbWlsYXIgdG8gZDMuZGlhZ29uYWwgZXhjZXB0IGl0IGNyZWF0ZSBhbiBvcnRob2dvbmFsIGNyb29rIGluc3RlYWQgb2YgYVxuICAgIHNtb290aCBCZXppZXIgY3VydmUuXG4gICAgXG4gIHJhZGlhbFJpZ2h0QW5nbGVEaWFnb25hbCgpXG4gICAgZDMucGh5bG9ncmFtLnJpZ2h0QW5nbGVEaWFnb25hbCBmb3IgcmFkaWFsIGxheW91dHMuXG4qL1xudmFyIHZnICA9IHJlcXVpcmUoJ3ZlZ2EnKSxcbiAgICBsb2cgID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgndmVnYS9zcmMvdHJhbnNmb3Jtcy9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gUGh5bG9ncmFtKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGxheW91dDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICdjYXJ0ZXNpYW4nfSxcbiAgICB3aWR0aDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IDEuMH0sXG4gICAgaGVpZ2h0OiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogMS4wfSxcbiAgICAvLyBzb21lIGFyZSBvbmx5IHVzZWQgaW4gcmFkaWFsIGxheW91dCwgaWdub3JlZCBpbiBvdGhlcnNcbiAgICByYWRpdXM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAwLjV9LFxuICAgIHJhZGlhbEFyYzoge3R5cGU6ICdhcnJheTx2YWx1ZT4nLCBkZWZhdWx0OiBbMCwgMzUwXX0sXG4gICAgcmFkaWFsU3dlZXA6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnQ0xPQ0tXSVNFJ30sICAvLyAnQ0xPQ0tXSVNFJyB8ICdDT1VOVEVSQ0xPQ0tXSVNFJ1xuICAgIC8vIG90aGVycyBhcmUgdXNlZCBvbmx5IGluIG5vbi1yYWRpYWwgbGF5b3V0c1xuICAgIHRpcHNBbGlnbm1lbnQ6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnUklHSFQnfSxcbiAgICBicmFuY2hTdHlsZToge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6ICcnfSwgLy8gdXN1LiBkZXRlcm1pbmVkIGJ5IGxheW91dFxuICAgIGJyYW5jaExlbmd0aHM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiAnJ30sXG4gICAgbm9kZUxhYmVsU291cmNlOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ01BUFBFRCd9LCAvLyAnT1JJR0lOQUwnIHwgJ01BUFBFRCdcbiAgICBzaG93RmFsbGJhY2tMYWJlbHM6IHt0eXBlOiAndmFsdWUnLCBkZWZhdWx0OiB0cnVlfVxuICAgIC8vIHNvbWUgYXJlIHJlY2tvbmVkIGludGVybmFsbHkgKG5vdCBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcilcbiAgICAvL2Rlc2NlbnRBeGlzOiB7dHlwZTogJ3ZhbHVlJywgZGVmYXVsdDogJ3gnfSwgLy8gJ3gnIHwgJ3knXG4gICAgLy9vcmllbnRhdGlvbjoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IC05MH0sXG4gIH0pO1xuICByZXR1cm4gdGhpcy5wcm9kdWNlcyh0cnVlKVxuICAgICAgICAgICAgIC5tdXRhdGVzKHRydWUpO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFBoeWxvZ3JhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBoeWxvZ3JhbTtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydtYWtpbmcgYSBwaHlsb2dyYW0nXSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5hZGQubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmJ1aWxkUGh5bG9ncmFtKGlucHV0LmFkZFtpXSk7XG4gIH1cbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lm1vZC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5idWlsZFBoeWxvZ3JhbShpbnB1dC5tb2RbaV0pO1xuICAgIH1cbiAgfVxuICAvKiBOLkIuIFR5cGljYWwgbm90YXRpb24gZG9lc24ndCB3b3JrIGhlcmUgKCd0aGlzJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgY2FsbGVkIGZ1bmMpXG4gIGlucHV0LmFkZC5mb3JFYWNoKCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2godGhpcy5idWlsZFBoeWxvZ3JhbSk7XG4gIH1cbiAgKi9cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5wcm90b3R5cGUuYnVpbGRQaHlsb2dyYW0gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgLy8gcmVhZCBpbiBwYXJhbXNcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5wYXJhbSgnbGF5b3V0Jyk7ICAvLyAnY2FydGVzaWFuJyB8ICdyYWRpYWwnIHwgJ2NsYWRvZ3JhbScgfCA/Pz9cblxuICAgIC8vIE5PVEUgdGhhdCB3aWR0aCBhbmQgaGVpZ2h0IHJlZmVyIHRvIHRoZSBmaW5hbCBkaXNwbGF5LCBzbyB0aGVzZSBtaWdodFxuICAgIC8vIG1hcCB0byBYIG9yIFkgY29vcmRpbmF0ZXMgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG4gICAgdmFyIHdpZHRoID0gdGhpcy5wYXJhbSgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5wYXJhbSgnaGVpZ2h0Jyk7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMucGFyYW0oJ3JhZGl1cycpOyAgLy8gZm9yIHJhZGlhbCBsYXlvdXRcbiAgICB2YXIgcmFkaWFsQXJjID0gdGhpcy5wYXJhbSgncmFkaWFsQXJjJyk7ICAvLyBhbmdsZXMgb2YgYXJjIChyYWRpYWwgbGF5b3V0IG9ubHkpXG4gICAgdmFyIHJhZGlhbFN3ZWVwID0gdGhpcy5wYXJhbSgncmFkaWFsU3dlZXAnKTsgIC8vICdDTE9DS1dJU0UnIG9yICdDT1VOVEVSQ0xPQ0tXSVNFJ1xuICAgIHZhciBicmFuY2hTdHlsZSA9IHRoaXMucGFyYW0oJ2JyYW5jaFN0eWxlJyk7XG4gICAgICAgIC8vICdyaWdodEFuZ2xlRGlhZ29uYWwnLCAncmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsJywgb3IgYSBzdGFuZGFyZFxuICAgICAgICAvLyBEMyBkaWFnb25hbDsgYnkgZGVmYXVsdCwgdGhpcyB3aWxsIGJlIGJhc2VkIG9uIHRoZSBjaG9zZW4gbGF5b3V0XG4gICAgdmFyIGJyYW5jaExlbmd0aHMgPSB0aGlzLnBhcmFtKCdicmFuY2hMZW5ndGhzJyk7XG4gICAgdmFyIHRpcHNBbGlnbm1lbnQgPSB0aGlzLnBhcmFtKCd0aXBzQWxpZ25tZW50Jyk7XG4gICAgICAgIC8vIGRpc3JlZ2FyZCBmb3IgcmFkaWFsIGxheW91dHM/XG4gICAgdmFyIG9yaWVudGF0aW9uOyAvLyB0aGlzLnBhcmFtKCdvcmllbnRhdGlvbicpO1xuICAgICAgICAvLyBkZWdyZWVzIG9mIHJvdGF0aW9uIGZyb20gZGVmYXVsdCAoMCwgLTkwLCA5MCwgMTgwKVxuICAgICAgICAvLyBOT1RFIHRoYXQgdGhpcyBpcyBub3Qgc2V0IGRpcmVjdGx5IChmcm9tIHZlZ2Egc3BlYykgYnV0IGZyb20gd2l0aGluXG4gICAgdmFyIGRlc2NlbnRBeGlzOyAvLyB0aGlzLnBhcmFtKCdkZXNjZW50QXhpcycpO1xuICAgICAgICAvLyBuZWVkZWQgdG8gcmVuZGVyIHBhdGhzIGNvcnJlY3RseVxuICAgICAgICAvLyBUT0RPOiBhZGQgbW9yZSBmcm9tIG9wdGlvbnMgYmVsb3dcbiAgICB2YXIgbm9kZUxhYmVsU291cmNlID0gdGhpcy5wYXJhbSgnbm9kZUxhYmVsU291cmNlJyk7ICAvLyAnT1JJR0lOQUwnIG9yICdNQVBQRUQnXG4gICAgICAgIC8vIGNob29zZSBwcmVmZXJyZWQgc291cmNlIGZvciBsYWJlbHM7IGZhbGwgYmFjayBhcyBuZWVkZWQgYW5kIHVzZSBtYXJrZXIgY2xhc3Nlc1xuICAgICAgICAvLyB0byBkaXN0aW5ndWlzaCB0aGVzZSBpbiBkaXNwbGF5XG4gICAgdmFyIHNob3dGYWxsYmFja0xhYmVscyA9IHRoaXMucGFyYW0oJ3Nob3dGYWxsYmFja0xhYmVscycpOyAgLy8gYm9vbGVhblxuXG4gICAgLyogYXBwbHkgc29tZSBpbnRlcm5hbCBjb25zdHJhaW50cyAoZm9ybWVybHkgaW4gcGFyYW0gc2V0dGVycykgKi9cblxuICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgICAvLyBOLkIuIHJhZGlhbCBsYXlvdXQgbmVlZHMgZml4ZWQgKC05MCkgb3JpZW50YXRpb25cbiAgICAgIG9yaWVudGF0aW9uID0gLTkwO1xuICAgICAgZGVzY2VudEF4aXMgPSAneCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCh0aXBzQWxpZ25tZW50KSB7XG4gICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgb3JpZW50YXRpb24gPSAxODA7XG4gICAgICAgICAgZGVzY2VudEF4aXMgPSAneSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JJR0hUJzpcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IC05MDtcbiAgICAgICAgICBkZXNjZW50QXhpcyA9ICd4JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQk9UVE9NJzpcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IDA7XG4gICAgICAgICAgZGVzY2VudEF4aXMgPSAneSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xFRlQnOlxuICAgICAgICAgIG9yaWVudGF0aW9uID0gOTA7XG4gICAgICAgICAgZGVzY2VudEF4aXMgPSAneCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGh5bG9ncmFtKGRhdGEpIHtcbiAgICAgIC8vIEV4cGVjdGluZyBpbmNvbWluZyBkYXRhIGluIHRoZSAncGh5bG90cmVlJyBmb3JtYXQgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL09wZW5UcmVlT2ZMaWZlL3RyZWUtaWxsdXN0cmF0b3Ivd2lraS9CdWlsZGluZy1vbi1EMy1hbmQtVmVnYVxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdTVEFSVElORyBwaHlsb2dyYW0gdHJhbnNmb3JtLi4uJyk7XG5cbiAgICAgIC8vIHNjYWxlIGFsbCBjb29yZGluYXRlcyBhcyBkaXJlY3RlZFxuICAgICAgaWYgKCh3aWR0aCAhPT0gMS4wKSB8fCAoaGVpZ2h0ICE9PSAxLjApKSB7XG4gICAgICAgICAgZGF0YS5waHlsb05vZGVzLm1hcChzY2FsZVBvaW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWVudGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgLy8gcm90YXRlIGFsbCBub2RlcyBieSBuIGRlZ3JlZXNcbiAgICAgICAgICBkYXRhLnBoeWxvTm9kZXMubWFwKHJvdGF0ZVBvaW50QnlPcmllbnRhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRoZSBjaG9zZW4gbGF5b3V0LCBpbiBhIDF4MSBcInZpcnR1YWwgc3BhY2VcIi4uP1xuICAgICAgdmFyIGxheW91dEdlbmVyYXRvcjtcbiAgICAgIHN3aXRjaChsYXlvdXQpIHtcbiAgICAgICAgICBjYXNlICdyYWRpYWwnOlxuICAgICAgICAgICAgICBsYXlvdXRHZW5lcmF0b3IgPSByYWRpYWxMYXlvdXQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NsYWRvZ3JhbSc6XG4gICAgICAgICAgICAgIGxheW91dEdlbmVyYXRvciA9IGNsYWRvZ3JhbUxheW91dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2FydGVzaWFuJzpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBsYXlvdXRHZW5lcmF0b3IgPSBjYXJ0ZXNpYW5MYXlvdXQ7XG4gICAgICB9XG4gICAgICBsYXlvdXRHZW5lcmF0b3IoZGF0YSk7XG5cbiAgICAgIC8vIHNldCAob3IgcmV2aXNlKSBwYXRocyBmb3IgYWxsIGxpbmtzXG4gICAgICB2YXIgcGF0aEdlbmVyYXRvcjtcbiAgICAgIHN3aXRjaChicmFuY2hTdHlsZSkge1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgLy8gaWYgbm9uZSBzcGVjaWZpZWQsIG1hdGNoIHRoZSBsYXlvdXRcbiAgICAgICAgICAgIHN3aXRjaChsYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpYWwnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYWRvZ3JhbSc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBzdHJhaWdodExpbmVEaWFnb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjYXJ0ZXNpYW4nOlxuICAgICAgICAgICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gcmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IGZvciBtb3JldHJhZGl0aW9uYWwgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IGQzLnN2Z1ticmFuY2hTdHlsZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJhaWdodExpbmVEaWFnb25hbCc6XG4gICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gc3RyYWlnaHRMaW5lRGlhZ29uYWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWwnOlxuICAgICAgICAgICAgcGF0aEdlbmVyYXRvciA9IHJhZGlhbFJpZ2h0QW5nbGVEaWFnb25hbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0QW5nbGVEaWFnb25hbCc6XG4gICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gcmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlhZ29uYWwnOlxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0IGFuZCBzd2l0Y2ggaXRzIHgveSBiaWFzXG4gICAgICAgICAgICBpZiAoZGVzY2VudEF4aXMgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcGllZCBmcm9tIHZnLmRhdGEubGluayA+IGRpYWdvbmFsWFxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGQuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IChzLnggKyB0LngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgcy54ICsgXCIsXCIgKyBzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICArIFwiQ1wiICsgbSAgICsgXCIsXCIgKyBzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiICsgbSAgICsgXCIsXCIgKyB0LnlcbiAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiICsgdC54ICsgXCIsXCIgKyB0Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoR2VuZXJhdG9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3BpZWQgZnJvbSB2Zy5kYXRhLmxpbmsgPiBkaWFnb25hbFlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBkLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBkLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAocy55ICsgdC55KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1cIiArIHMueCArIFwiLFwiICsgcy55XG4gICAgICAgICAgICAgICAgICAgICAgICAgKyBcIkNcIiArIHMueCArIFwiLFwiICsgbVxuICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgXCIgKyB0LnggKyBcIixcIiArIG1cbiAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiICsgdC54ICsgXCIsXCIgKyB0Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlhbCc6XG4gICAgICAgICAgICAvLyBpbnRlcmNlcHQgYW5kIHN3aXRjaCBpdHMgeC95IGJpYXNcbiAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBkMy5zdmcuZGlhZ29uYWwucmFkaWFsKCk7XG4gICAgICAgICAgICAgICAgLy8ucHJvamVjdGlvbihmdW5jdGlvbiAoZCkgeyByZXR1cm4gW2QueSwgZC54XTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBhdGhHZW5lcmF0b3IgPSBkMy5zdmdbYnJhbmNoU3R5bGVdKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGF0YS5waHlsb0VkZ2VzLmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICBkLnBhdGggPSBwYXRoR2VuZXJhdG9yKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8qIEdlbmVyYXRlIGEgXCJob3RzcG90XCIgcGF0aCBiYXNlZCBvbiBsYXlvdXQgYW5kIGRpbWVuc2lvbnMuIFxuICAgICAgICogKFRoaXMgaXMgdXNlZCB0byByZXNwb25kIHRvIG1vdXNlIGFjdGlvbnMsIGV0Yy4gd2hpbGUgZWRpdGluZy4pIFxuICAgICAgICovXG4gICAgICB2YXIgaG90c3BvdEdlbmVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFwiTSAyMDAgMTc1IEEgMjUgMjUgMCAxIDAgMjE3LjY3OCAyMTcuNjc4XCJcbiAgICAgICAgICBzd2l0Y2gobGF5b3V0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NhcnRlc2lhbic6XG4gICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpbmFsIGJvdW5kaW5nIGJveCBvZiBhbGwgbm9kZXNcbiAgICAgICAgICAgICAgICAgIHZhciBleHRlbnRzID0gZ2V0Qm91bmRpbmdCb3hGcm9tUG9pbnRzKCBkYXRhLnBoeWxvTm9kZXMgKTtcbiAgICAgICAgICAgICAgICAgIC8vIHJlbmFtZSBmb3IgY2xhcml0eVxuICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9ICAgICBleHRlbnRzLm1pblksXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAgIGV4dGVudHMubWF4WCxcbiAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSAgZXh0ZW50cy5tYXhZLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAgICBleHRlbnRzLm1pblg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJNIFwiKyBsZWZ0ICtcIixcIisgdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICtcIiBMIFwiKyByaWdodCArXCIsXCIrIHRvcFxuICAgICAgICAgICAgICAgICAgICAgICArXCIgTCBcIisgcmlnaHQgK1wiLFwiKyBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgK1wiIEwgXCIrIGxlZnQgK1wiLFwiKyBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgK1wiIFpcIjtcbiAgICAgICAgICAgICAgY2FzZSAnY2xhZG9ncmFtJzpcbiAgICAgICAgICAgICAgICAgIHZhciBleHRlbnRzID0gZ2V0Qm91bmRpbmdCb3hGcm9tUG9pbnRzKCBkYXRhLnBoeWxvTm9kZXMgKTtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJNIDAsMFwiOyAgIC8vIHN0YXJ0IGFuZCBlbmQgYXQgcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgICBzd2l0Y2godGlwc0FsaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUT1AnOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK1wiIEwgXCIrIGV4dGVudHMubWluWCArXCIsXCIrIGV4dGVudHMubWluWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcIiBMIFwiKyBleHRlbnRzLm1heFggK1wiLFwiKyBleHRlbnRzLm1pbllcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArXCIgWlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdSSUdIVCc6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArXCIgTCBcIisgZXh0ZW50cy5tYXhYICtcIixcIisgZXh0ZW50cy5taW5ZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK1wiIEwgXCIrIGV4dGVudHMubWF4WCArXCIsXCIrIGV4dGVudHMubWF4WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcIiBaXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JPVFRPTSc6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArXCIgTCBcIisgZXh0ZW50cy5taW5YICtcIixcIisgZXh0ZW50cy5tYXhZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK1wiIEwgXCIrIGV4dGVudHMubWF4WCArXCIsXCIrIGV4dGVudHMubWF4WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcIiBaXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xFRlQnOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK1wiIEwgXCIrIGV4dGVudHMubWluWCArXCIsXCIrIGV4dGVudHMubWluWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcIiBMIFwiKyBleHRlbnRzLm1pblggK1wiLFwiKyBleHRlbnRzLm1heFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArXCIgWlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdyYWRpYWwnOlxuICAgICAgICAgICAgICAgICAgLy8gc3dlZXAgb3V0IHRoZSBlbnRpcmUgYXJlYSBvZiB0aGUgZ3JhcGhcbiAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJNMCwwIExcIjsgICAvLyBzdGFydCBhdCByb290IG5vZGUsIGJlZ2luIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGZha2UgXCJlZGdlXCIgdG8gZGlzY2VybiB0aGUgZnVsbCBhcmNcbiAgICAgICAgICAgICAgICAgIHZhciBleHRlbnRzID0gIGdldEJvdW5kaW5nQm94RnJvbVBvaW50cyggZGF0YS5waHlsb05vZGVzLCB7dXNlQ29vcmRpbmF0ZXM6ICdDQVJURVNJQU4nfSApO1xuICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxXaWR0aEVkZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7Y2FydGVzaWFuX3g6IGV4dGVudHMubWF4WCwgY2FydGVzaWFuX3k6IGV4dGVudHMubWluWX0sXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB7Y2FydGVzaWFuX3g6IGV4dGVudHMubWF4WCwgY2FydGVzaWFuX3k6IGV4dGVudHMubWF4WX1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGZ1bGwgYXJjIGFzIGEgcGF0aCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIHZhciBwYXRoR2VuZXJhdG9yID0gcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHJvb3Qgbm9kZSBwb3NpdGlvbiBhbmQgY2xvc2UgdGhlIGZpbmFsIHNoYXBlXG4gICAgICAgICAgICAgICAgICAvLyBFWEFNUExFIG91dHB1dDogJ00tMjI4LDE5IEEyMjksMjI5IDAgMCwwIC0yMjcsMjZMLTIyNywyNidcbiAgICAgICAgICAgICAgICAgIC8vICAgIEJFQ09NRVMgJ00wLDAgTC0yMjgsMTkgQTIyOSwyMjkgMCAxLDEgLTIyNywyNkwtMjI3LDI2IFonXG4gICAgICAgICAgICAgICAgICBwYXRoICs9IHBhdGhHZW5lcmF0b3IoZnVsbFdpZHRoRWRnZSkuc2xpY2UoMSk7IC8vIHRyaW0gaW5pdGlhbCAnTSdcbiAgICAgICAgICAgICAgICAgIHBhdGggKz0gXCIgWlwiO1xuICAgICAgICAgICAgICAgICAgLy8gRmxpcCB0aGUgbGFyZ2UtYXJjIGFuZCBzd2VlcCBmbGFncyBmb3IgXCJvdXRlciBzd2VlcFwiOyBzZWVcbiAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvVHV0b3JpYWwvUGF0aHMjQXJjc1xuICAgICAgICAgICAgICAgICAgLy8gIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhRWxsaXB0aWNhbEFyY0NvbW1hbmRzXG4gICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKFwiMCAwLDAgXCIsIFwiMCAxLDEgXCIpOyBcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biB0cmVlIGxheW91dCBmb3IgYm91bmRpbmcgYm94IVwiKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk0gLTUwLC01MCBMIC01MCw1MCwgTCA1MCw1MCwgTCA1MCwtNTAgWlwiO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEdlbmVyYXRlIGEgc2VyaWVzIG9mIHZlcnRleCBoYW5kbGVzIGJhc2VkIG9uIGxheW91dCBhbmQgZGltZW5zaW9ucy5cbiAgICAgICAqIChUaGVzZSBhcmUgYWxzbyB1c2VkIHRvIHJlc3BvbmQgdG8gbW91c2UgYWN0aW9ucywgZXRjLiB3aGlsZSBlZGl0aW5nLilcbiAgICAgICAqL1xuICAgICAgdmFyIGhhbmRsZUdlbmVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBoYW5kbGVzID0gWyBdO1xuICAgICAgICAgIHZhciBtb3ZlSGFuZGxlVGlwID0gXCJEcmFnIHRvIG1vdmUgdGhpcyB0cmVlIG9uIHRoZSBwYWdlLlwiO1xuICAgICAgICAgIHZhciByZXNpemVIYW5kbGVUaXAgPSBcIkRyYWcgdG8gY2hhbmdlIHdpZHRoIGFuZCBoZWlnaHRcIjtcbiAgICAgICAgICBzd2l0Y2gobGF5b3V0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NhcnRlc2lhbic6XG4gICAgICAgICAgICAgIGNhc2UgJ2NsYWRvZ3JhbSc6XG4gICAgICAgICAgICAgICAgICAvLyBUaGVzZSB1c2UganVzdCB0d28gaGFuZGxlcyBvbiBcIm9wcG9zaXRlXCIgY29ybmVycyBmcm9tIHRoZSByb290IG5vZGUuXG4gICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goeyBuYW1lOiAnY2VudGVyJywgeDogMCwgeTogMCwgc2hhcGU6ICdkaWFtb25kJywgc2l6ZTogMTIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogbW92ZUhhbmRsZVRpcCB9KTtcbiAgICAgICAgICAgICAgICAgIHZhciBleHRlbnRzID0gZ2V0Qm91bmRpbmdCb3hGcm9tUG9pbnRzKCBkYXRhLnBoeWxvTm9kZXMgKTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCh0aXBzQWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcy5wdXNoKHsgbmFtZTogJ3RvcC1sZWZ0JywgeDogZXh0ZW50cy5taW5YLCB5OiBleHRlbnRzLm1pblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogcmVzaXplSGFuZGxlVGlwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXMucHVzaCh7IG5hbWU6ICd0b3AtcmlnaHQnLCB4OiBleHRlbnRzLm1heFgsIHk6IGV4dGVudHMubWluWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiByZXNpemVIYW5kbGVUaXAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JJR0hUJzpcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goeyBuYW1lOiAndG9wLXJpZ2h0JywgeDogZXh0ZW50cy5tYXhYLCB5OiBleHRlbnRzLm1pblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogcmVzaXplSGFuZGxlVGlwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXMucHVzaCh7IG5hbWU6ICdib3R0b20tcmlnaHQnLCB4OiBleHRlbnRzLm1heFgsIHk6IGV4dGVudHMubWF4WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiByZXNpemVIYW5kbGVUaXAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQk9UVE9NJzpcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goeyBuYW1lOiAnYm90dG9tLWxlZnQnLCB4OiBleHRlbnRzLm1pblgsIHk6IGV4dGVudHMubWF4WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiByZXNpemVIYW5kbGVUaXAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcy5wdXNoKHsgbmFtZTogJ2JvdHRvbS1yaWdodCcsIHg6IGV4dGVudHMubWF4WCwgeTogZXh0ZW50cy5tYXhZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHJlc2l6ZUhhbmRsZVRpcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcy5wdXNoKHsgbmFtZTogJ3RvcC1sZWZ0JywgeDogZXh0ZW50cy5taW5YLCB5OiBleHRlbnRzLm1pblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogcmVzaXplSGFuZGxlVGlwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXMucHVzaCh7IG5hbWU6ICdib3R0b20tbGVmdCcsIHg6IGV4dGVudHMubWluWCwgeTogZXh0ZW50cy5tYXhZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHJlc2l6ZUhhbmRsZVRpcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3JhZGlhbCc6XG4gICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goeyBuYW1lOiAnY2VudGVyJywgeDogMCwgeTogMCwgc2hhcGU6ICdkaWFtb25kJywgc2l6ZTogMTIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogbW92ZUhhbmRsZVRpcCB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIFJlY2tvbiB0aHJlZSBoYW5kbGUgcG9zaXRpb25zIChvbiBwZXJpbWV0ZXIpIGluIENhcnRlc2lhbiBjb29yZGluYXRlcy4uLlxuICAgICAgICAgICAgICAgICAgdmFyIGV4dGVudHMgPSBnZXRCb3VuZGluZ0JveEZyb21Qb2ludHMoIGRhdGEucGh5bG9Ob2Rlcywge3VzZUNvb3JkaW5hdGVzOiAnQ0FSVEVTSUFOJ30gKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0ge3g6IGV4dGVudHMubWF4WCwgeTogKHJhZGlhbFN3ZWVwID09PSAnQ0xPQ0tXSVNFJykgPyBleHRlbnRzLm1pblkgOiBleHRlbnRzLm1heFl9LFxuICAgICAgICAgICAgICAgICAgICAgIG1pZFBvaW50ID0gICB7eDogZXh0ZW50cy5tYXhYLCB5OiAoZXh0ZW50cy5tYXhZICsgZXh0ZW50cy5taW5ZKSAvIDJ9LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFBvaW50ID0gICB7eDogZXh0ZW50cy5tYXhYLCB5OiAocmFkaWFsU3dlZXAgPT09ICdDTE9DS1dJU0UnKSA/IGV4dGVudHMubWF4WSA6IGV4dGVudHMubWluWX07XG4gICAgICAgICAgICAgICAgICAvLyAuLi4gdGhlbiBjb252ZXJ0IHRvIHBvbGFyIGNvb3JkaW5hdGVzIChzaW1wbGUgYXJyYXlzKVxuICAgICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IGNhcnRlc2lhblRvUG9sYXJQcm9qZWN0aW9uKCBzdGFydFBvaW50LCB7cmV0dXJuVHlwZTogJ1BPTEFSX0NPT1JEUyd9ICk7XG4gICAgICAgICAgICAgICAgICBtaWRQb2ludCA9IGNhcnRlc2lhblRvUG9sYXJQcm9qZWN0aW9uKCBtaWRQb2ludCwge3JldHVyblR5cGU6ICdQT0xBUl9DT09SRFMnfSApO1xuICAgICAgICAgICAgICAgICAgZW5kUG9pbnQgPSBjYXJ0ZXNpYW5Ub1BvbGFyUHJvamVjdGlvbiggZW5kUG9pbnQsIHtyZXR1cm5UeXBlOiAnUE9MQVJfQ09PUkRTJ30gKTtcblxuICAgICAgICAgICAgICAgICAgLy8gcGFzcyBhbGwgcG9sYXIgcHJvcGVydGllcyAoYW5nbGUsIHJhZGl1cywgdGhldGEpIHBsdXMgYSBkZXNjcmlwdGl2ZSBuYW1lXG4gICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goICQuZXh0ZW5kKHN0YXJ0UG9pbnQsIHtuYW1lOiAnc3RhcnQtYW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogXCJEcmFnIHRvIGNoYW5nZSByYWRpdXMgYW5kIHN0YXJ0aW5nIGFuZ2xlXCJ9KSApO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlcy5wdXNoKCAkLmV4dGVuZChtaWRQb2ludCwge25hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IFwiRHJhZyB0byBjaGFuZ2UgdGhpcyB0cmVlJ3MgcmFkaXVzXCIgfSkgKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXMucHVzaCggJC5leHRlbmQoZW5kUG9pbnQsIHtuYW1lOiAnZW5kLWFuZ2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiBcIkRyYWcgdG8gY2hhbmdlIHJhZGl1cyBhbmQgZW5kaW5nIGFuZ2xlXCJ9KSApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGluIGRlZmF1bHQgcHJvcGVydGllcyBhcyBuZWVkZWRcbiAgICAgICAgICAkLmVhY2goaGFuZGxlcywgZnVuY3Rpb24oaSxoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXNbaV0gPSAkLmV4dGVuZCh7IHNoYXBlOidjaXJjbGUnLCBzaXplOjgwLCByb3RhdGU6MCB9LCBoYW5kbGVzW2ldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcztcbiAgICAgIH1cblxuICAgICAgZGF0YS5ob3RzcG90ID0gWyAgLy8gZW11bGF0ZSBhIHR1cGxlXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBcInBhdGhcIjogaG90c3BvdEdlbmVyYXRvcigpXG4gICAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIGRhdGEudmVydGV4SGFuZGxlcyA9IGhhbmRsZUdlbmVyYXRvcigpOyAvLyByZXR1cm5zIGFuIGFycmF5XG5cbiAgICAgIC8vIGNvcHkgbGF5b3V0IHByb3BlcnRpZXMgdG8gdGhlIHBoeWxvdHJlZSwgZm9yIHBvc3NpYmxlIHVzZSBkb3duc3RyZWFtXG4gICAgICBkYXRhLmxheW91dCA9IGxheW91dDtcbiAgICAgIGRhdGEudGlwc0FsaWdubWVudCA9IHRpcHNBbGlnbm1lbnQ7XG4gICAgICBkYXRhLmRlc2NlbnRBeGlzID0gZGVzY2VudEF4aXM7ICAvLyBpbXBsaWNpdCBpbiB0aXBzQWxpZ25tZW50P1xuICAgICAgZGF0YS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uOyAgLy8gaW1wbGljaXQgaW4gdGlwc0FsaWdubWVudD9cbiAgICAgIGRhdGEud2lkdGggPSB3aWR0aDtcbiAgICAgIGRhdGEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZGF0YS5yYWRpdXMgPSByYWRpdXM7XG4gICAgICBkYXRhLmJyYW5jaFN0eWxlID0gYnJhbmNoU3R5bGU7XG4gICAgICBkYXRhLmJyYW5jaExlbmd0aHMgPSBicmFuY2hMZW5ndGhzO1xuICAgICAgZGF0YS5ub2RlTGFiZWxTb3VyY2UgPSBub2RlTGFiZWxTb3VyY2U7XG4gICAgICBkYXRhLnNob3dGYWxsYmFja0xhYmVscyA9IHNob3dGYWxsYmFja0xhYmVscztcblxuICAgICAgLy8gY29weSBnZW5lcmF0b3JzIGZvciBob3RzcG90IGFuZCBvdGhlciBoYW5kbGVzXG4gICAgICAvL2RhdGEuaG90c3BvdEdlbmVyYXRvciA9IGhvdHNwb3RHZW5lcmF0b3I7XG4gICAgICAvL2RhdGEuaGFuZGxlR2VuZXJhdG9yID0gaGFuZGxlR2VuZXJhdG9yO1xuICAgICAgUGh5bG9ncmFtLmhvdHNwb3RHZW5lcmF0b3IgPSBob3RzcG90R2VuZXJhdG9yO1xuICAgICAgUGh5bG9ncmFtLmhhbmRsZUdlbmVyYXRvciA9IGhhbmRsZUdlbmVyYXRvcjtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgICAgXG4gICAgdmFyIGRpc3BsYWNlUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgZGVsdGEpIHtcbiAgICAgICAgLy8gd2hlcmUgJ2RlbHRhJyBpcyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcbiAgICAgICAgcG9pbnQueCArPSBkZWx0YS54O1xuICAgICAgICBwb2ludC55ICs9IGRlbHRhLnk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gd2lkdGggKm9yKiBoZWlnaHQsIGFzIGFwcHJvcHJpYXRlIGZvciB0aGUgY3VycmVudCBvcmllbnRhdGlvblxuICAgIHZhciBnZXRPdXRlckRpbWVuc2lvbkZvclggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIGNhc2UgLTE4MDpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG5cbiAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBjYXNlIC05MDpcbiAgICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgY2FzZSAtMjcwOlxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcImdldE91dGVyRGltZW5zaW9uRm9yWCgpOiBVbmV4cGVjdGVkIHZhbHVlIGZvciBvcmllbnRhdGlvbjogJ1wiKyBvcmllbnRhdGlvbiArXCInXCIpO1xuICAgIH1cbiAgICB2YXIgZ2V0T3V0ZXJEaW1lbnNpb25Gb3JZID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaChvcmllbnRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICBjYXNlIC0xODA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBjYXNlIC05MDpcbiAgICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgY2FzZSAtMjcwOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0T3V0ZXJEaW1lbnNpb25Gb3JZKCk6IFVuZXhwZWN0ZWQgdmFsdWUgZm9yIG9yaWVudGF0aW9uOiAnXCIrIG9yaWVudGF0aW9uICtcIidcIik7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAvLyB3aGVyZSBwb2ludCBpcyBhbnkgb2JqZWN0IGhhdmluZyB4IGFuZCB5IHByb3BlcnRpZXNcbiAgICAgICAgLy8gTk9URSB0aGF0IHdlJ3JlIHNjYWxpbmcgdXAgZnJvbSBmcmFjdGlvbmFsIHZhbHVlcyAoMC4wIC0gMS4wKSwgc29cbiAgICAgICAgLy8gdGhlIG5vbWluYWwgd2lkdGgraGVpZ2h0IGFyZSBhbHNvIG91ciBzY2FsaW5nIG11bHRpcGxpZXJzXG4gICAgICAgIHBvaW50LnggKj0gZ2V0T3V0ZXJEaW1lbnNpb25Gb3JYKCk7XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgICAgICBwb2ludC55ICo9IHJhZGl1cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50LnkgKj0gZ2V0T3V0ZXJEaW1lbnNpb25Gb3JZKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NhbGUgY2FydGVzaWFuX3ggYW5kIHksIGlmIHN0b3JlZFxuICAgICAgICBpZiAoJ2NhcnRlc2lhbl94JyBpbiBwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQuY2FydGVzaWFuX3ggKj0gZ2V0T3V0ZXJEaW1lbnNpb25Gb3JYKCk7XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feSAqPSBnZXRPdXRlckRpbWVuc2lvbkZvclkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuXG4gICAgdmFyIHJvdGF0ZVBvaW50QnlPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIC8vIHVzZSB0aGUgdmVnYSBpbnB1dCAnb3JpZW50YXRpb24nIHZhbHVlIHRvIHNwaW4gdGhlIHRyZWVcbiAgICAgICAgcmV0dXJuIHJvdGF0ZVBvaW50KHBvaW50LCBvcmllbnRhdGlvbik7XG4gICAgfVxuICAgIHZhciByb3RhdGVQb2ludEJ5WSA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIC8vIFkgY29vcmRpbmF0ZSBzaG91bGQgYmUgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgICAgICB2YXIgeUFuZ2xlID0gMzYwLjAgKiBwb2ludC54O1xuICAgICAgICByZXR1cm4gcm90YXRlUG9pbnQocG9pbnQsIHlBbmdsZSk7XG4gICAgfVxuXG4gICAgdmFyIHJvdGF0ZVBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIGFuZ2xlLCBwaXZvdCkge1xuICAgICAgICAvLyB3aGVyZSBwb2ludCBpcyBhbnkgb2JqZWN0IGhhdmluZyB4IGFuZCB5IHByb3BlcnRpZXMsIGFuZCAncGl2b3QnXG4gICAgICAgIC8vIGlzIGFuIG9wdGlvbmFsIHNlY29uZCBwb2ludFxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MsXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbixcbiAgICAgICAgICAgIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyhhbmdsZSB8fCBvcmllbnRhdGlvbiksIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBtaWRwb2ludCBpcyBvcmlnaW4gKDAsMClcbiAgICAgICAgICAgIHhtID0gKHBpdm90ICYmICd4JyBpbiBwaXZvdCkgPyBwaXZvdC54IDogMCxcbiAgICAgICAgICAgIHltID0gKHBpdm90ICYmICd5JyBpbiBwaXZvdCkgPyBwaXZvdC55IDogMCxcbiAgICAgICAgICAgIHggPSBwb2ludC54LCAgICAvLyBjYXB0dXJlIG9sZCB4IGFuZCB5IGZvciB0aGlzIHBvaW50XG4gICAgICAgICAgICB5ID0gcG9pbnQueTtcblxuICAgICAgICAvLyBzdWJ0cmFjdCBtaWRwb2ludHMsIHJvdGF0ZSBmcm9tIG9yaWdpbiwgdGhlbiByZXN0b3JlIHRoZW1cbiAgICAgICAgcG9pbnQueCA9ICh4IC0geG0pICogY29zKGFuZ2xlKSAtICh5IC0geW0pICogc2luKGFuZ2xlKSArIHhtO1xuICAgICAgICBwb2ludC55ID0gKHggLSB4bSkgKiBzaW4oYW5nbGUpICsgKHkgLSB5bSkgKiBjb3MoYW5nbGUpICsgeW07XG4gICAgICAgIGlmICgnY2FydGVzaWFuX3gnIGluIHBvaW50KSB7XG4gICAgICAgICAgICBjeCA9IHBvaW50LmNhcnRlc2lhbl94LCAgICAvLyBjYXB0dXJlIG9sZCBjb29yZHNcbiAgICAgICAgICAgIGN5ID0gcG9pbnQuY2FydGVzaWFuX3k7XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feCA9IChjeCAtIHhtKSAqIGNvcyhhbmdsZSkgLSAoY3kgLSB5bSkgKiBzaW4oYW5nbGUpICsgeG07XG4gICAgICAgICAgICBwb2ludC5jYXJ0ZXNpYW5feSA9IChjeCAtIHhtKSAqIHNpbihhbmdsZSkgKyAoY3kgLSB5bSkgKiBjb3MoYW5nbGUpICsgeW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocikge1xuICAgICAgICByZXR1cm4gKHIgKiAxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkKSB7XG4gICAgICAgIHJldHVybiAoZCAqIE1hdGguUEkgLyAxODApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEZWdyZWVzKGQpIHtcbiAgICAgICAgLy8gY29udmVydCB0byBwb3NpdGl2ZSBpbnRlZ2VyLCBlLmcuIC05MCA9PT4gMjcwXG4gICAgICAgIHJldHVybiAoZCArICgzNjAgKiAzKSkgJSAzNjA7XG4gICAgfVxuXG4gIC8vIENvbnZlcnQgWFkgYW5kIHJhZGl1cyB0byBhbmdsZSBvZiBhIGNpcmNsZSBjZW50ZXJlZCBhdCAwLDBcbiAgdmFyIGNvb3JkaW5hdGVUb0FuZ2xlID0gZnVuY3Rpb24oY29vcmQsIHJhZGl1cykge1xuICAgIHZhciB3aG9sZUFuZ2xlID0gMiAqIE1hdGguUEksXG4gICAgICAgIHF1YXJ0ZXJBbmdsZSA9IHdob2xlQW5nbGUgLyA0O1xuICAgIFxuICAgIHZhciBjb29yZFF1YWQgPSBjb29yZFswXSA+PSAwID9cbiAgICAgICAgICAgIChjb29yZFsxXSA+PSAwID8gMSA6IDIpIDpcbiAgICAgICAgICAgIChjb29yZFsxXSA+PSAwID8gNCA6IDMpLFxuICAgICAgICBjb29yZEJhc2VBbmdsZSA9IE1hdGguYWJzKE1hdGguYXNpbihjb29yZFsxXSAvIHJhZGl1cykpO1xuICAgIFxuICAgIC8vIFNpbmNlIHRoaXMgaXMganVzdCBiYXNlZCBvbiB0aGUgYW5nbGUgb2YgdGhlIHJpZ2h0IHRyaWFuZ2xlIGZvcm1lZFxuICAgIC8vIGJ5IHRoZSBjb29yZGluYXRlIGFuZCB0aGUgb3JpZ2luLCBlYWNoIHF1YWQgd2lsbCBoYXZlIGRpZmZlcmVudFxuICAgIC8vIG9mZnNldHNcbiAgICBzd2l0Y2ggKGNvb3JkUXVhZCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjb29yZEFuZ2xlID0gcXVhcnRlckFuZ2xlIC0gY29vcmRCYXNlQW5nbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBjb29yZEFuZ2xlID0gcXVhcnRlckFuZ2xlICsgY29vcmRCYXNlQW5nbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBjb29yZEFuZ2xlID0gMipxdWFydGVyQW5nbGUgKyBxdWFydGVyQW5nbGUgLSBjb29yZEJhc2VBbmdsZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgY29vcmRBbmdsZSA9IDMqcXVhcnRlckFuZ2xlICsgY29vcmRCYXNlQW5nbGU7XG4gICAgfVxuICAgIHJldHVybiBjb29yZEFuZ2xlO1xuICB9XG5cbiAgLyogcGF0aCBnZW5lcmF0b3JzICovXG5cbiAgdmFyIHN0cmFpZ2h0TGluZURpYWdvbmFsID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIGRvLW5vdGhpbmcgcHJvamVjdGlvbiAoanVzdCBpc29sYXRlcyB4IGFuZCB5KVxuICAgIHZhciBwcm9qZWN0aW9uID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gW2QueCwgZC55XTsgfVxuICAgIFxuICAgIHZhciBwYXRoID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgIHJldHVybiBcIk1cIiArIHBhdGhEYXRhWzBdICsgJyAnICsgcGF0aERhdGFbMV07XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGRpYWdvbmFsKGQpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IFtkLnNvdXJjZSwgZC50YXJnZXRdO1xuICAgICAgcGF0aERhdGEgPSBwYXRoRGF0YS5tYXAocHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gcGF0aChwYXRoRGF0YSk7XG4gICAgfVxuICAgIFxuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdGlvbiA9IHg7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBcbiAgICBkaWFnb25hbC5wYXRoID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGF0aDtcbiAgICAgIHBhdGggPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9XG5cbiAgdmFyIHJpZ2h0QW5nbGVEaWFnb25hbCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAvLyBkby1ub3RoaW5nIHByb2plY3Rpb24gKGp1c3QgaXNvbGF0ZXMgeCBhbmQgeSlcbiAgICB2YXIgcHJvamVjdGlvbiA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFtkLngsIGQueV07IH1cbiAgICBcbiAgICB2YXIgcGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICByZXR1cm4gXCJNXCIgKyBwYXRoRGF0YVswXSArICcgJyArIHBhdGhEYXRhWzFdICsgXCIgXCIgKyBwYXRoRGF0YVsyXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCkge1xuICAgICAgdmFyIG1pZHBvaW50WCA9IChkLnNvdXJjZS54ICsgZC50YXJnZXQueCkgLyAyLFxuICAgICAgICAgIG1pZHBvaW50WSA9IChkLnNvdXJjZS55ICsgZC50YXJnZXQueSkgLyAyLFxuICAgICAgICAgIHBhdGhEYXRhID0gKGRlc2NlbnRBeGlzID09PSAneCcpID9cbiAgICAgICAgICAgICAgICAgICAgW2Quc291cmNlLCB7eDogZC5zb3VyY2UueCwgeTogZC50YXJnZXQueX0sIGQudGFyZ2V0XSA6XG4gICAgICAgICAgICAgICAgICAgIFtkLnNvdXJjZSwge3g6IGQudGFyZ2V0LngsIHk6IGQuc291cmNlLnl9LCBkLnRhcmdldF07XG4gICAgICBwYXRoRGF0YSA9IHBhdGhEYXRhLm1hcChwcm9qZWN0aW9uKTtcbiAgICAgIHJldHVybiBwYXRoKHBhdGhEYXRhKVxuICAgIH1cbiAgICBcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3Rpb24gPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgXG4gICAgZGlhZ29uYWwucGF0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhdGg7XG4gICAgICBwYXRoID0geDtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBkaWFnb25hbDtcbiAgfVxuICBcbiAgdmFyIGNhcnRlc2lhblRvUG9sYXJQcm9qZWN0aW9uID0gZnVuY3Rpb24oZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtyZXR1cm5UeXBlOiAnWFktQVJSQVknfTsgLy8gb3IgJ1BPTEFSLUNPT1JEUydcbiAgICAvLyByYWRpdXMgaXMgc2ltcGx5IHRoZSB4IGNvb3JkaW5hdGVcbiAgICB2YXIgciA9IGQueDtcblxuICAgIC8vIEFuZ2xlIGlzIGluZmx1ZW5jZWQgYnkgdGhlIHNwZWNpZmllZCBzaXplLCBhcmMgYW5kIHN3ZWVwLlxuICAgIC8vIG1hcCBZIGNvb3JkaW5hdGUgdG8gdG90YWwgc3BlY2lmaWVkIHdpZHRoXG4gICAgdmFyIHRvdGFsQXJjRGVncmVlcztcbiAgICAvLyBmb3JjZSBib3RoIGFuZ2xlcyB0byBwb3NpdGl2ZSBudW1iZXJzXG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVEZWdyZWVzKHJhZGlhbEFyY1swXSk7XG4gICAgdmFyIGVuZEFuZ2xlID0gbm9ybWFsaXplRGVncmVlcyhyYWRpYWxBcmNbMV0pO1xuICAgIC8vIGNoZWNrIGZvciBhcmNzIHRoYXQgY3Jvc3MgdGhlIHplcm8gbGluZVxuICAgIHZhciBzaGlmdEFuZ2xlOyAgLy8gcGxvdCB0aGUgYWN0aXZlIGFyYyBzdGFydGluZyBoZXJlXG4gICAgaWYgKHJhZGlhbFN3ZWVwID09PSAnQ0xPQ0tXSVNFJykge1xuICAgICAgICB0b3RhbEFyY0RlZ3JlZXMgPSBub3JtYWxpemVEZWdyZWVzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICAgIHNoaWZ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIH0gZWxzZSB7IC8vIGFzc3VtZXMgJ0NPVU5URVJDTE9DS1dJU0UnKVxuICAgICAgICB0b3RhbEFyY0RlZ3JlZXMgPSBub3JtYWxpemVEZWdyZWVzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIHNoaWZ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9XG4gICAgLy8gUmVtYXAgWSB0byB0aGUgdHJlZSdzIGJvdW5kaW5nIGRpbWVuc2lvbiB0byBwbG90IGl0cyBhbmdsZSBjb3JyZWN0bHkgXG4gICAgdmFyIGFuZ2xlV2l0aGluQXJjID0gKChkLnkgLyBnZXRPdXRlckRpbWVuc2lvbkZvclgoKSkgKiB0b3RhbEFyY0RlZ3JlZXMpO1xuICAgIC8vIFRoaXMgZ2l2ZXMgdXMgdGhlIGFuZ2xlIHN0YXJ0aW5nIGZyb20gb25lIGVuZCBvZiB0aGUgYXJjOyBwbGFjZSB0aGlzIVxuICAgIHZhciBhbmdsZUZyb21PcmlnaW4gPSBub3JtYWxpemVEZWdyZWVzKGFuZ2xlV2l0aGluQXJjICsgc2hpZnRBbmdsZSk7XG5cbiAgICB2YXIgYSA9IGRlZ3JlZXNUb1JhZGlhbnMoIGFuZ2xlRnJvbU9yaWdpbik7ICAvLy8gIC8gMTgwICogTWF0aC5QSTtcbiAgICAvLyByZW1hcCBhbmdsZSB0byB0aGUgc3BlY2lmaWVkIGFyYywgaW4gdGhlIHN3ZWVwIGRpcmVjdGlvblxuXG4gICAgLy8gVE9ETzogcmVja29uIGFuZ2xlIGJhc2VkIG9uIGhlaWdodC93aWR0aCBhbmQgc3dlZXBcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5UeXBlID09PSAnUE9MQVJfQ09PUkRTJykge1xuICAgICAgICAvLyBhZGQgcmFkaXVzIGFuZCBhbmdsZSAodGhldGEpIGZvciBsYWJlbCBkaXNwbGF5IGluIHZlZ2FcbiAgICAgICAgdmFyIGxhYmVsQW5nbGUgPSBub3JtYWxpemVEZWdyZWVzKHJhZGlhbnNUb0RlZ3JlZXMoYSkpO1xuICAgICAgICB2YXIgbGFiZWxBbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgIC8vIFRPRE86IGFkanVzdGFibGUgbnVkZ2Ugc2VwYXJhdGVzIGxhYmVsIHRleHQgZnJvbSBkcmF3biBub2RlXG4gICAgICAgIHZhciBudWRnZVJhZGl1cyA9IDQ7IC8vIHB4P1xuICAgICAgICAvLyBUT0RPOiBhZGp1c3RhYmxlIG51ZGdlIChzaG91bGQgdmFyeSB3aXRoIHRleHQgc2l6ZSkgc2hpZnRzIGFuZ2xlXG4gICAgICAgIC8vIGZyb20gdGhlIGxhYmVsJ3MgYmFzZWxpbmUgdG8gdGhlIG1pZGRsZSBvZiBpdHMgeC1oZWlnaHRcbiAgICAgICAgdmFyIG51ZGdlVGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKDAuNik7XG5cbiAgICAgICAgLy8gdGVzdCBmb3IgdXBzaWRlLWRvd24gbGFiZWxzIChhc3N1bWluZyAwIGRlZyA9IGR1ZSByaWdodClcbiAgICAgICAgaWYgKChsYWJlbEFuZ2xlID4gOTApICYmIChsYWJlbEFuZ2xlIDwgMjcwKSkge1xuICAgICAgICAgICAgLy8gbGVmdC1zaWRlIGxhYmVscyBzaG91bGQgYmUgZmxpcHBlZCBhbmQgYWxpZ25lZCByaWdodFxuICAgICAgICAgICAgbGFiZWxBbGlnbm1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgbGFiZWxBbmdsZSA9IG5vcm1hbGl6ZURlZ3JlZXMobGFiZWxBbmdsZSArIDE4MCk7XG4gICAgICAgICAgICBudWRnZVRoZXRhID0gLShudWRnZVRoZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZUFuZExhYmVsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIC8vIFgsIFkgY29vcmRpbmF0ZXMgZm9yIHRoZSBub2RlIGl0c2VsZlxuICAgICAgICAgICAgJ3gnOiByICogTWF0aC5jb3MoYSksXG4gICAgICAgICAgICAneSc6IHIgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgcGxhY2luZyB0aGUgbGFiZWxcbiAgICAgICAgICAgICdyYWRpdXMnOiByICsgbnVkZ2VSYWRpdXMsXG4gICAgICAgICAgICAndGhldGEnOiBhIC0gZGVncmVlc1RvUmFkaWFucyhvcmllbnRhdGlvbikgKyBudWRnZVRoZXRhLCAvLyBpbiByYWRpYW5zIVxuICAgICAgICAgICAgJ2FuZ2xlJzogbGFiZWxBbmdsZSxcbiAgICAgICAgICAgICdhbGlnbic6IGxhYmVsQWxpZ25tZW50XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBub2RlQW5kTGFiZWxQcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldHVybiBYWS1DT09SRFMgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gW3IgKiBNYXRoLmNvcyhhKSwgciAqIE1hdGguc2luKGEpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmFkaWFsUmlnaHRBbmdsZURpYWdvbmFsID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIFdlIG5lZWQgYSBzdGFuZGFsb25lIHZlcnNpb24gb2YgdGhpcywgc2luY2Ugd2UncmUgbWFwcGluZyAocHJlc2VydmVkKVxuICAgIC8vIGNhcnRlc2lhbl94IGFuZCBjYXJ0ZXNpYW5feSB0byBwb2xhciBjb29yZGluYXRlcy5cblxuICAgIC8vIHRyYW5zbGF0ZSBmcm9tIGNhcnRlc2lhbiB0byBwb2xhciBjb29yZGluYXRlc1xuICAgIHZhciBwcm9qZWN0aW9uID0gY2FydGVzaWFuVG9Qb2xhclByb2plY3Rpb247XG4gICAgICAgICAgICBcbiAgICB2YXIgcGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICAgIHZhciBzcmMgPSBwYXRoRGF0YVswXSxcbiAgICAgICAgICAgIG1pZCA9IHBhdGhEYXRhWzFdLFxuICAgICAgICAgICAgZHN0ID0gcGF0aERhdGFbMl0sXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLnNxcnQoc3JjWzBdKnNyY1swXSArIHNyY1sxXSpzcmNbMV0pLFxuICAgICAgICAgICAgc3JjQW5nbGUgPSBjb29yZGluYXRlVG9BbmdsZShzcmMsIHJhZGl1cyksXG4gICAgICAgICAgICBtaWRBbmdsZSA9IGNvb3JkaW5hdGVUb0FuZ2xlKG1pZCwgcmFkaXVzKSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZSA9IE1hdGguYWJzKG1pZEFuZ2xlIC0gc3JjQW5nbGUpID4gTWF0aC5QSSA/IG1pZEFuZ2xlIDw9IHNyY0FuZ2xlIDogbWlkQW5nbGUgPiBzcmNBbmdsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gMCwgIC8vIHRoaXMgaXMgbW9vdCBmb3IgYSBjaXJjbGVcbiAgICAgICAgICAgIGxhcmdlQXJjID0gMCxcbiAgICAgICAgICAgIHN3ZWVwID0gY2xvY2t3aXNlID8gMCA6IDE7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gJ00nICsgc3JjICsgJyAnICtcbiAgICAgICAgICBcIkFcIiArIFtyYWRpdXMscmFkaXVzXSArICcgJyArIHJvdGF0aW9uICsgJyAnICsgbGFyZ2VBcmMrJywnK3N3ZWVwICsgJyAnICsgbWlkICtcbiAgICAgICAgICAnTCcgKyBkc3Q7XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nO1xuICAgIH1cbiAgICAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGRpYWdvbmFsKGQpIHtcbiAgICAgIHZhciBtaWRwb2ludFggPSAoZC5zb3VyY2UuY2FydGVzaWFuX3ggKyBkLnRhcmdldC5jYXJ0ZXNpYW5feCkgLyAyLFxuICAgICAgICAgIG1pZHBvaW50WSA9IChkLnNvdXJjZS5jYXJ0ZXNpYW5feSArIGQudGFyZ2V0LmNhcnRlc2lhbl95KSAvIDIsXG4gICAgICAgICAgcGF0aERhdGEgPSAoZGVzY2VudEF4aXMgPT09ICd4JykgP1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogZC5zb3VyY2UuY2FydGVzaWFuX3gsIHk6IGQuc291cmNlLmNhcnRlc2lhbl95fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feCwgeTogZC50YXJnZXQuY2FydGVzaWFuX3l9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6IGQudGFyZ2V0LmNhcnRlc2lhbl94LCB5OiBkLnRhcmdldC5jYXJ0ZXNpYW5feX1cbiAgICAgICAgICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feCwgeTogZC5zb3VyY2UuY2FydGVzaWFuX3l9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6IGQudGFyZ2V0LmNhcnRlc2lhbl94LCB5OiBkLnNvdXJjZS5jYXJ0ZXNpYW5feX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogZC50YXJnZXQuY2FydGVzaWFuX3gsIHk6IGQudGFyZ2V0LmNhcnRlc2lhbl95fVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgcGF0aERhdGEgPSBwYXRoRGF0YS5tYXAocHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gcGF0aChwYXRoRGF0YSlcbiAgICB9XG4gICAgICAgICAgICBcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH1cbiAgXG4gICAgLyogbGF5b3V0IGdlbmVyYXRvcnMgKHBvc2l0aW9uIHBvaW50cyBpbiAxLjAsIDEuMCBzcGFjZSkgKi9cbiAgICB2YXIgY2FydGVzaWFuTGF5b3V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvLyBwbGFjZSBhbGwgbm9kZXMgZm9yIHRoZSByYWRpYWwgbGF5b3V0IChhbHJlYWR5IGRvbmUpXG5cbiAgICAgICAgLy8ganVzdCBudWRnZSBhbGwgcG9pbnRzIHRvIHB1dCB0aGUgcm9vdCBub2RlIGF0IDAsMFxuICAgICAgICBtb3ZlUm9vdFRvT3JpZ2luKGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBtb3ZlUm9vdFRvT3JpZ2luID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gbW92ZSBhbGwgcG9pbnRzIHRvIHB1dCB0aGUgcm9vdCBub2RlIGF0IG9yaWdpbiAoMC4wKVxuICAgICAgICB2YXIgcm9vdE5vZGUgPSBkYXRhLnBoeWxvTm9kZXNbMF07ICAvLyBJIGJlbGlldmUgdGhpcyBpcyBhbHdheXMgdHJ1ZVxuICAgICAgICB2YXIgbnVkZ2VSb290VG9PcmlnaW4gPSB7eDogLShyb290Tm9kZS54KSwgeTogLShyb290Tm9kZS55KX07XG4gICAgICAgIHZhciBhbGlnblBvaW50c1RvT3JpZ2luID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGFjZVBvaW50KHBvaW50LCBudWRnZVJvb3RUb09yaWdpbik7XG4gICAgICAgIH07XG4gICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAoYWxpZ25Qb2ludHNUb09yaWdpbik7XG4gICAgfVxuXG4gICAgdmFyIGdldEJvdW5kaW5nQm94RnJvbVBvaW50cyA9IGZ1bmN0aW9uKCBwb2ludHMsIG9wdGlvbnMgKSB7XG4gICAgICAgIC8vIGdldCBYL1kgYm91bmRzIGZyb20gYSBsaXN0IG9mIHBvaW50LWxpa2Ugb2JqZWN0c1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7dXNlQ29vcmRpbmF0ZXM6ICdESVNQTEFZJ307XG4gICAgICAgIHZhciBleHRlbnRzID0ge1xuICAgICAgICAgICAgbWluWDogIE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtYXhYOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG1pblk6ICBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4WTogLU51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlQ29vcmRpbmF0ZXMgPT09ICdDQVJURVNJQU4nKSB7XG4gICAgICAgICAgICBwb2ludHMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblggPSBNYXRoLm1pbihuLmNhcnRlc2lhbl94LCBleHRlbnRzLm1pblgpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWluWSA9IE1hdGgubWluKG4uY2FydGVzaWFuX3ksIGV4dGVudHMubWluWSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhYID0gTWF0aC5tYXgobi5jYXJ0ZXNpYW5feCwgZXh0ZW50cy5tYXhYKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1heFkgPSBNYXRoLm1heChuLmNhcnRlc2lhbl95LCBleHRlbnRzLm1heFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblggPSBNYXRoLm1pbihuLngsIGV4dGVudHMubWluWCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5taW5ZID0gTWF0aC5taW4obi55LCBleHRlbnRzLm1pblkpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WCA9IE1hdGgubWF4KG4ueCwgZXh0ZW50cy5tYXhYKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1heFkgPSBNYXRoLm1heChuLnksIGV4dGVudHMubWF4WSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG5cbiAgICB2YXIgcmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvLyBwbGFjZSBhbGwgbm9kZXMgZm9yIHRoZSByYWRpYWwgbGF5b3V0XG5cbiAgICAgICAgLy8gUHJvamVjdCBwb2ludHMgKG5vZGVzKSB0byByYWRpYXRlIG91dCBmcm9tIGNlbnRlci5cbiAgICAgICAgbW92ZVJvb3RUb09yaWdpbihkYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8qIEFkanVzdCB0aGUgbGF5b3V0IHRvIHBsYWNlIFkgY29vcmRpbmF0ZXMgZnJvbSAxLjAgdG8gMS4wLFxuICAgICAgICAgKiBvdGhlcndpc2UgdGhlIHRyZWUgd2lsbCBcImJlbmQgb3ZlciBiYWNrd2FyZHNcIiBhbmQgaXRzIGdhcFxuICAgICAgICAgKiB3aWxsIGFwcGVhciByYW5kb21seSBvbiB0aGUgY2lyY3VtZmVyZW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBleHRlbnRzID0gZ2V0Qm91bmRpbmdCb3hGcm9tUG9pbnRzKCBkYXRhLnBoeWxvTm9kZXMgKTtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSBleHRlbnRzLm1pblk7XG4gICAgICAgIGlmICh5T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAkLmVhY2goIGRhdGEucGh5bG9Ob2RlcywgZnVuY3Rpb24oIGksIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS55IC09IHlPZmZzZXQ7ICAgLy8gdW5kbyB0aGUgb2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVzZXJ2ZUNhcnRlc2lhbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHBvaW50LmNhcnRlc2lhbl94ID0gcG9pbnQueDtcbiAgICAgICAgICAgIHBvaW50LmNhcnRlc2lhbl95ID0gcG9pbnQueTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnBoeWxvTm9kZXMubWFwKHByZXNlcnZlQ2FydGVzaWFuQ29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcGNvb3JkcyA9IGNhcnRlc2lhblRvUG9sYXJQcm9qZWN0aW9uKGQsIHtyZXR1cm5UeXBlOidQT0xBUl9DT09SRFMnfSk7XG4gICAgICAgICAgICBkLnJhZGl1cyAgPSBwY29vcmRzLnJhZGl1cztcbiAgICAgICAgICAgIGQudGhldGEgID0gcGNvb3Jkcy50aGV0YTtcbiAgICAgICAgICAgIGQuYW5nbGUgID0gcGNvb3Jkcy5hbmdsZTtcbiAgICAgICAgICAgIGQuYWxpZ24gID0gcGNvb3Jkcy5hbGlnbjtcbiAgICAgICAgICAgIGQueCA9IHBjb29yZHMueDtcbiAgICAgICAgICAgIGQueSA9IHBjb29yZHMueTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjbGFkb2dyYW1MYXlvdXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIHBsYWNlIGFsbCBub2RlcyBmb3IgdGhlIFwidHJpYW5ndWxhclwiIGNsYWRvZ3JhbSBsYXlvdXRcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBicmFuY2ggbGVuZ3Rocz9cblxuICAgICAgICAvLyBwcm9qZWN0IHBvaW50cyAobm9kZXMpIHRvIHJhZGlhdGUgb3V0IGZyb20gY2VudGVyXG4gICAgICAgIG1vdmVSb290VG9PcmlnaW4oZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvKiBQcmVjYWxjdWxhdGUgYXZhaWxhYmxlIGxlYWYtbm9kZSBwb3NpdGlvbnMgKGJhc2VkIG9uIG51bWJlciBvZlxuICAgICAgICAgKiBsZWF2ZXMsIGZpbmFsIHdpZHRoICYgaGVpZ2h0LCBhbmQgdGlwIGFsaWdubWVudCkuIFRoZW4gZG9cbiAgICAgICAgICogZGVwdGgtZmlyc3QgdHJhdmVyc2FsIGZyb20gdGhlIHJvb3QgdG8gYXNzaWduIHRoZSBsZWF2ZXMgdG8gdGhlc2VcbiAgICAgICAgICogcG9zaXRpb25zLCBwbGFjaW5nIGFsbCBhbmNlc3RvcnMgYWxvbmcgdGhlIHdheS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBsZWFmTm9kZXMgPSAkLmdyZXAoZGF0YS5waHlsb05vZGVzLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gblsnXm90OmlzTGVhZiddID09PSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbkxlYXZlcyA9IGxlYWZOb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgLyogSG93IGZhciBzaG91bGQgd2UgbW92ZSBvbiB0aGUgZGVzY2VudCBheGlzIGZvciBlYWNoIHN0ZXAgaW4gZGVwdGg/XG4gICAgICAgICAqIE5PVEUgdGhhdCB3ZSdsbCBub3JtYWxpemUgdGhpcyB0byBtYXRjaCB0aGUgb3JpZ2luYWwgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAqIGxhdGVyOyBmb3Igbm93LCBsZXQncyBtYXRjaCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBsZWFmIG5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGRlcHRoU3RlcDtcblxuICAgICAgICB2YXIgbGVhZlBvc2l0aW9ucyA9IFsgXTtcbiAgICAgICAgdmFyIHN0YXJ0aW5nTGVhZlgsIGxlYWZYc3RlcCxcbiAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlksIGxlYWZZc3RlcDtcbiAgICAgICAgc3dpdGNoKHRpcHNBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWCA9IC0od2lkdGggLyAyLjApO1xuICAgICAgICAgICAgICAgIGxlYWZYc3RlcCA9IHdpZHRoIC8gKG5MZWF2ZXMtMSk7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWSA9IC1oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGVhZllzdGVwID0gMDtcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZXAgPSAtbGVhZlhzdGVwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUklHSFQnOlxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBsZWFmWHN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlkgPSAtKGhlaWdodCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgbGVhZllzdGVwID0gaGVpZ2h0IC8gKG5MZWF2ZXMtMSk7XG4gICAgICAgICAgICAgICAgZGVwdGhTdGVwID0gbGVhZllzdGVwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQk9UVE9NJzpcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xlYWZYID0gLSh3aWR0aCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgbGVhZlhzdGVwID0gd2lkdGggLyAobkxlYXZlcy0xKTtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0xlYWZZID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxlYWZZc3RlcCA9IDA7XG4gICAgICAgICAgICAgICAgZGVwdGhTdGVwID0gbGVhZlhzdGVwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdMZWFmWCA9IC13aWR0aDtcbiAgICAgICAgICAgICAgICBsZWFmWHN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nTGVhZlkgPSAtKGhlaWdodCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgbGVhZllzdGVwID0gaGVpZ2h0IC8gKG5MZWF2ZXMtMSk7XG4gICAgICAgICAgICAgICAgZGVwdGhTdGVwID0gLWxlYWZZc3RlcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWZOb2Rlcy5tYXAoZnVuY3Rpb24obiwgaSkge1xuICAgICAgICAgICAgbGVhZlBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAneCc6IHN0YXJ0aW5nTGVhZlggKyAobGVhZlhzdGVwICogaSksXG4gICAgICAgICAgICAgICAgJ3knOiBzdGFydGluZ0xlYWZZICsgKGxlYWZZc3RlcCAqIGkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJvb3ROb2RlID0gZGF0YS5waHlsb05vZGVzWzBdOyAgLy8gSSBiZWxpZXZlIHRoaXMgaXMgYWx3YXlzIHRydWVcbiAgICAgICAgdmFyIGZ1bGxFeHRlbnRzID0gZGlzdHJpYnV0ZUNoaWxkcmVuQXNDbGFkb2dyYW0ocm9vdE5vZGUsIGxlYWZQb3NpdGlvbnMsIGRlcHRoU3RlcCk7XG5cbiAgICAgICAgLy8gcmVhbGlnbiByb290IG5vZGUgdG8gb3JpZ2luIChpdCBnZXRzIFwicHVzaGVkXCIgZmFyIGF3YXkgYnkgY29tcGxleCB0cmVlcylcbiAgICAgICAgbW92ZVJvb3RUb09yaWdpbihkYXRhKTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmVzdWx0aW5nIGxheW91dCB0byBtYXRjaCB0aGUgZGVzaXJlZCB3aWR0aCAob3IgaGVpZ2h0KVxuICAgICAgICBzd2l0Y2godGlwc0FsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSAnVE9QJzpcbiAgICAgICAgICAgIGNhc2UgJ0JPVFRPTSc6XG4gICAgICAgICAgICAgICAgLy8gd2lkdGggaXMgYWxyZWFkeSBnb29kOyBoZWlnaHQgc2hvdWxkIGJlIHNxdWVlemVkIChvciBzdHJldGNoZWQpXG4gICAgICAgICAgICAgICAgdmFyIHNxdWVlemUgPSBoZWlnaHQgLyAoZnVsbEV4dGVudHMubWF4WSAtIGZ1bGxFeHRlbnRzLm1pblkpO1xuICAgICAgICAgICAgICAgIHZhciBmaXRUb0hlaWdodCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgKj0gc3F1ZWV6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnBoeWxvTm9kZXMubWFwKGZpdFRvSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JJR0hUJzpcbiAgICAgICAgICAgIGNhc2UgJ0xFRlQnOlxuICAgICAgICAgICAgICAgIC8vIGhlaWdodCBpcyBhbHJlYWR5IGdvb2Q7IHdpZHRoIHNob3VsZCBiZSBzcXVlZXplZCAob3Igc3RyZXRjaGVkKVxuICAgICAgICAgICAgICAgIHZhciBzcXVlZXplID0gd2lkdGggLyAoZnVsbEV4dGVudHMubWF4WCAtIGZ1bGxFeHRlbnRzLm1pblgpO1xuICAgICAgICAgICAgICAgIHZhciBmaXRUb1dpZHRoID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCAqPSBzcXVlZXplO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEucGh5bG9Ob2Rlcy5tYXAoZml0VG9XaWR0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICBcbiAgICB2YXIgZGlzdHJpYnV0ZUNoaWxkcmVuQXNDbGFkb2dyYW0gPSBmdW5jdGlvbihub2RlLCBsZWFmUG9zaXRpb25zLCBkZXB0aFN0ZXApIHtcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgZXh0ZW50cyA9IHtcbiAgICAgICAgICAgIG1pblg6ICBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4WDogLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtaW5ZOiAgTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG1heFk6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgZGVzY2VuZGFudExlYWZDb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihuLCBpKSB7XG4gICAgICAgICAgICBpZiAoKG5bJ15vdDppc0xlYWYnXSA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgIC8vIFVzZSBhZGRpdGlvbmFsIHRlc3RzIGZvciBiYWRseS1mb3JtZWQgTmV4c29uLCB3aGVyZVxuICAgICAgICAgICAgICAgLy8gYSBcImtudWNrbGVcIiBjYW4gYXBwZWFyIGFzIGEgbm9uLWxlYWYgbm9kZSB3aXRoIG5vIGNoaWxkcmVuISlcbiAgICAgICAgICAgICAgICEobi5jaGlsZHJlbikgfHxcbiAgICAgICAgICAgICAgIChuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSBuZXh0IGF2YWlsYWJsZSBsZWFmIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGxlYWZQb3MgPSBsZWFmUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbi54ID0gbGVhZlBvcy54O1xuICAgICAgICAgICAgICAgIG4ueSA9IGxlYWZQb3MueTtcblxuICAgICAgICAgICAgICAgIGV4dGVudHMubWluWCA9IE1hdGgubWluKG4ueCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblkgPSBNYXRoLm1pbihuLnksIGV4dGVudHMubWluWSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhYID0gTWF0aC5tYXgobi54LCBleHRlbnRzLm1heFgpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSA9IE1hdGgubWF4KG4ueSwgZXh0ZW50cy5tYXhZKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRXh0ZW50cyA9IGRpc3RyaWJ1dGVDaGlsZHJlbkFzQ2xhZG9ncmFtKG4sIGxlYWZQb3NpdGlvbnMsIGRlcHRoU3RlcCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5taW5YID0gTWF0aC5taW4obi54LCBjaGlsZEV4dGVudHMubWluWCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLm1pblkgPSBNYXRoLm1pbihuLnksIGNoaWxkRXh0ZW50cy5taW5ZLCBleHRlbnRzLm1pblkpO1xuICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WCA9IE1hdGgubWF4KG4ueCwgY2hpbGRFeHRlbnRzLm1heFgsIGV4dGVudHMubWF4WCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhZID0gTWF0aC5tYXgobi55LCBjaGlsZEV4dGVudHMubWF4WSwgZXh0ZW50cy5tYXhZKTtcbiAgICAgICAgICAgICAgICBleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgKz0gY2hpbGRFeHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qIFBvc2l0aW9uIHRoaXMgbm9kZSBiYXNlZCBvbiBpdHMgZGVwdGggYW5kIGNoaWxkcmVuJ3MgcG9zaXRpb25zLlxuICAgICAgICAgKiBOb3RlIHRoYXQgd2UgbmVlZCB0byBwbGFjZSBpdCBvbiB0aGUgZGVzY2VudCBheGlzIHNvIHRoYXQgaXRcbiAgICAgICAgICogbWFpbnRhaW5zIChpZiBwb3NzaWJsZSkgdGhlIHByb3BlciBhbmdsZWQgZWRnZXMgZm9yIHRoZVxuICAgICAgICAgKiBjbGFkb2dyYW0gbGF5b3V0LiBUaGlzIHNvbWV0aW1lcyBtZWFucyB3ZSBuZWVkIHRvIGZvcmNlXG4gICAgICAgICAqIGxvbmdlciBlZGdlcyBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoKHRpcHNBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RPUCc6XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWSAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB4IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHhcbiAgICAgICAgICAgICAgICBub2RlLnggPSAoZXh0ZW50cy5tYXhYICsgZXh0ZW50cy5taW5YKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0JPVFRPTSc6XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWSAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WSAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB4IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHhcbiAgICAgICAgICAgICAgICBub2RlLnggPSAoZXh0ZW50cy5tYXhYICsgZXh0ZW50cy5taW5YKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JJR0hUJzpcbiAgICAgICAgICAgICAgICBub2RlLnggPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50cy5taW5YIC0gZGVwdGhTdGVwLCAgLy8gb25lIHN0ZXAgY2xvc2VyIHRvIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50cy5tYXhYIC0gKChleHRlbnRzLmRlc2NlbmRhbnRMZWFmQ291bnQgLSAxKSAqIGRlcHRoU3RlcClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIHkgc2hvdWxkIGJlIG1pZHBvaW50IG9mIGFsbCBkZXNjZW5kYW50cycgeVxuICAgICAgICAgICAgICAgIG5vZGUueSA9IChleHRlbnRzLm1heFkgKyBleHRlbnRzLm1pblkpIC8gMi4wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWF4WCAtIGRlcHRoU3RlcCwgIC8vIG9uZSBzdGVwIGNsb3NlciB0byByb290XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMubWluWCAtICgoZXh0ZW50cy5kZXNjZW5kYW50TGVhZkNvdW50IC0gMSkgKiBkZXB0aFN0ZXApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyB5IHNob3VsZCBiZSBtaWRwb2ludCBvZiBhbGwgZGVzY2VuZGFudHMnIHlcbiAgICAgICAgICAgICAgICBub2RlLnkgPSAoZXh0ZW50cy5tYXhZICsgZXh0ZW50cy5taW5ZKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBleHRlbnRzIGFuZCByZXR1cm4gdG8gcGFyZW50XG4gICAgICAgIGV4dGVudHMubWluWCA9IE1hdGgubWluKG5vZGUueCwgZXh0ZW50cy5taW5YKTtcbiAgICAgICAgZXh0ZW50cy5taW5ZID0gTWF0aC5taW4obm9kZS55LCBleHRlbnRzLm1pblkpO1xuICAgICAgICBleHRlbnRzLm1heFggPSBNYXRoLm1heChub2RlLngsIGV4dGVudHMubWF4WCk7XG4gICAgICAgIGV4dGVudHMubWF4WSA9IE1hdGgubWF4KG5vZGUueSwgZXh0ZW50cy5tYXhZKTtcblxuICAgICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gcGh5bG9ncmFtKGRhdGEpO1xufVxuXG5cblxuLyoqKioqIFNDUkFQIEFSRUEgKioqKiovXG5cbi8qXG4gIHN0eWxlVHJlZU5vZGVzID0gZnVuY3Rpb24odmlzKSB7XG5cbiAgICB2aXMuc2VsZWN0QWxsKCdnLm5vZGUgY2lyY2xlJylcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSk7XG5cbiAgICB2aXMuc2VsZWN0QWxsKCdnLmxlYWYubm9kZSBjaXJjbGUnKVxuICAgICAgICAuYXR0cihcInJcIiwgNC41KTtcbiAgICBcbiAgICB2aXMuc2VsZWN0QWxsKCdnLnJvb3Qubm9kZSBjaXJjbGUnKVxuICAgICAgICAuYXR0cihcInJcIiwgNC41KTtcbiAgfVxuKi9cbiAgXG4gIGZ1bmN0aW9uIHNjYWxlQnJhbmNoTGVuZ3Rocyhub2Rlcywgdykge1xuICAgIC8vIFZpc2l0IGFsbCBub2RlcyBhbmQgYWRqdXN0IHkgcG9zIHdpZHRoIGRpc3RhbmNlIG1ldHJpY1xuICAgIHZhciB2aXNpdFByZU9yZGVyID0gZnVuY3Rpb24ocm9vdCwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHJvb3QpXG4gICAgICBpZiAocm9vdC5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gcm9vdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgdmlzaXRQcmVPcmRlcihyb290LmNoaWxkcmVuW2ldLCBjYWxsYmFjaylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRQcmVPcmRlcihub2Rlc1swXSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgLy8gVE9ETzogaWYgd2UgaGF2ZSBtaXhlZCB0cmVlcyAoc29tZSBlZGdlcyB3aXRoIGxlbmd0aHMpLCBjb25zaWRlciAxXG4gICAgICAvLyBhcyBkZWZhdWx0IGxlbmd0aCB2ZXJzdXMgMD9cbiAgICAgIG5vZGUucm9vdERpc3QgPSAobm9kZS5wYXJlbnQgPyBub2RlLnBhcmVudC5yb290RGlzdCA6IDApICsgKG5vZGUubGVuZ3RoIHx8IDApXG4gICAgfSlcbiAgICB2YXIgcm9vdERpc3RzID0gbm9kZXMubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ucm9vdERpc3Q7IH0pO1xuICAgIHZhciB5c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgZDMubWF4KHJvb3REaXN0cyldKVxuICAgICAgLnJhbmdlKFswLCB3XSk7XG4gICAgdmlzaXRQcmVPcmRlcihub2Rlc1swXSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS55ID0geXNjYWxlKG5vZGUucm9vdERpc3QpXG4gICAgfSlcbiAgICByZXR1cm4geXNjYWxlXG4gIH1cbiAgXG4gIFxuICB2YXIgYnVpbGRDYXJ0ZXNpYW4gPSBmdW5jdGlvbihzZWxlY3Rvciwgbm9kZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciB3ID0gb3B0aW9ucy53aWR0aCB8fCBkMy5zZWxlY3Qoc2VsZWN0b3IpLnN0eWxlKCd3aWR0aCcpIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXR0cignd2lkdGgnKSxcbiAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGQzLnNlbGVjdChzZWxlY3Rvcikuc3R5bGUoJ2hlaWdodCcpIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXR0cignaGVpZ2h0JyksXG4gICAgICAgIHcgPSBwYXJzZUludCh3KSxcbiAgICAgICAgaCA9IHBhcnNlSW50KGgpO1xuICAgIHZhciB0cmVlID0gb3B0aW9ucy50cmVlIHx8IGQzLmxheW91dC5jbHVzdGVyKClcbiAgICAgIC5zaXplKFtoLCB3XSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuLmxlbmd0aCA6IC0xOyB9KVxuICAgIHZhciBkaWFnb25hbCA9IG9wdGlvbnMuZGlhZ29uYWwgfHwgcmlnaHRBbmdsZURpYWdvbmFsKCk7XG4gICAgdmFyIHZpcyA9IG9wdGlvbnMudmlzIHx8IGQzLnNlbGVjdChzZWxlY3RvcikuYXBwZW5kKFwic3ZnOnN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHcgKyAzMDApXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGggKyAzMClcbiAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgxMjAsIDIwKVwiKTtcblxuICAgIGlmICghb3B0aW9ucy52aXMpIHtcbiAgICAgIC8vIGFkZCBhbnkgc3BlY2lhbCBmaWx0ZXJzIChvbmNlIG9ubHkpXG4gICAgICBkMy5zZWxlY3Qoc2VsZWN0b3IpLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAuYXBwZW5kKCdkZWZzJylcbiAgICAgICAgIC5hcHBlbmQoXCJzdmc6ZmlsdGVyXCIpXG4gICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJoaWdobGlnaHRcIilcbiAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgLy8gYWRkIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoaXMgcGFyZW50XG4gICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXBwZW5kKFwic3ZnOmZlRmxvb2RcIilcbiAgICAgICAgICAgICAgICAgLy8uYXR0cihcImZsb29kLWNvbG9yXCIsIFwiI2ZmZWVkZFwiKSAgLy8gbWF0Y2hlcyAuaGVscC1ib3ggYmcgY29sb3IhXG4gICAgICAgICAgICAgICAgIC5hdHRyKFwiZmxvb2QtY29sb3JcIiwgXCIjZmZiMjY1XCIpICAgIC8vIGRhcmtlbmVkIHRvIGFsbG93IHRpbnRcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJmbG9vZC1vcGFjaXR5XCIsIFwiMC41XCIpXG4gICAgICAgICAgICAgICAgIC5hdHRyKFwicmVzdWx0XCIsIFwidGludFwiKTtcbiAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hcHBlbmQoXCJzdmc6ZmVCbGVuZFwiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcIm1vZGVcIiwgXCJtdWx0aXBseVwiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKVxuICAgICAgICAgICAgICAgICAuYXR0cihcImluMlwiLCBcInRpbnRcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJpbjNcIiwgXCJCYWNrZ3JvdW5kSW1hZ2VcIik7XG4gICAgICAgICAgICAgICAvKiBBTFRFUk5BVElWRSBTT0xVVElPTiwgdXNpbmcgZmVDb21wb3NpdGVcbiAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hcHBlbmQoXCJzdmc6ZmVDb21wb3NpdGVcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJpblwiLCBcIlNvdXJjZUdyYXBoaWNcIik7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gdHJlZShub2Rlcyk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuc2tpcEJyYW5jaExlbmd0aFNjYWxpbmcpIHtcbiAgICAgIHZhciB5c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCB3XSlcbiAgICAgICAgLnJhbmdlKFswLCB3XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5c2NhbGUgPSBzY2FsZUJyYW5jaExlbmd0aHMobm9kZXMsIHcpXG4gICAgfVxuICAgIFxuICAgIGlmICghb3B0aW9ucy5za2lwVGlja3MpIHtcbiAgICAgIHZhciBsaW5lcyA9IHZpcy5zZWxlY3RBbGwoJ2xpbmUnKVxuICAgICAgICAgIC5kYXRhKHlzY2FsZS50aWNrcygxMCkpO1xuICAgICAgXG4gICAgICBsaW5lc1xuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAgICAgICAuYXR0cigneTEnLCAwKVxuICAgICAgICAgIC5hdHRyKCd5MicsIGgpXG4gICAgICAgICAgLmF0dHIoJ3gxJywgeXNjYWxlKVxuICAgICAgICAgIC5hdHRyKCd4MicsIHlzY2FsZSlcbiAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiNlZWVcIik7XG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgIHZhciB0ZXh0X3J1bGVzID0gdmlzLnNlbGVjdEFsbChcInRleHQucnVsZVwiKVxuICAgICAgICAgIC5kYXRhKHlzY2FsZS50aWNrcygxMCkpO1xuXG4gICAgICB0ZXh0X3J1bGVzXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInN2Zzp0ZXh0XCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJ1bGVcIilcbiAgICAgICAgICAuYXR0cihcInhcIiwgeXNjYWxlKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgLTMpXG4gICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnOHB4JylcbiAgICAgICAgICAuYXR0cignZmlsbCcsICcjY2NjJylcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLnJvdW5kKGQqMTAwKSAvIDEwMDsgfSk7XG5cbiAgICAgIHRleHRfcnVsZXNcbiAgICAgICAgLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG4gICAgICAgIFxuICAgIFxuICAgIC8vIERBVEEgSk9JTlxuICAgIC8qIG1vcmUgaW50ZXJhY3Rpb25zIGFuZCBzdHlsZXMgb24gZmluYWwgbWFya3NcbiAgICB2YXIgcGF0aF9saW5rcyA9IHZpcy5zZWxlY3RBbGwoXCJwYXRoLmxpbmtcIilcbiAgICAgICAgLmRhdGEodHJlZS5saW5rcyhub2RlcyksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc291cmNlWydAaWQnXSArJ18nKyBkLnRhcmdldFsnQGlkJ107IH0pO1xuXG4gICAgdmFyIHBhdGhfbGlua190cmlnZ2VycyA9IHZpcy5zZWxlY3RBbGwoXCJwYXRoLmxpbmstdHJpZ2dlclwiKVxuICAgICAgICAuZGF0YSh0cmVlLmxpbmtzKG5vZGVzKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2VbJ0BpZCddICsnXycrIGQudGFyZ2V0WydAaWQnXSArJ190cmlnZ2VyJzsgfSk7XG5cbiAgICB2YXIgZ19ub2RlcyA9IHZpcy5zZWxlY3RBbGwoXCJnLm5vZGVcIilcbiAgICAgICAgLmRhdGEobm9kZXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbJ0BpZCddOyB9KTtcblxuICAgIC8vIFVQREFURSAob25seSBhZmZlY3RzIGV4aXN0aW5nIGxpbmtzKVxuICAgIHBhdGhfbGlua3NcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjYWFhXCIpO1xuICAgIFxuICAgIHBhdGhfbGlua190cmlnZ2Vyc1xuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIm9yYW5nZVwiKTtcblxuICAgIFxuICAgIC8vIEVOVEVSIChvbmx5IGFmZmVjdHMgbmV3IGxpbmtzOyBkbyBvbmUtdGltZSBpbml0aWFsaXphdGlvbiBoZXJlKVxuICAgIHBhdGhfbGlua3NcbiAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInN2ZzpwYXRoXCIpICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlZCAodmlzaWJsZSkgZWRnZVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmtcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiI2YzM1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgXCI0cHhcIik7XG4gICAgXG4gICAgcGF0aF9saW5rX3RyaWdnZXJzXG4gICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoXCJzdmc6cGF0aFwiKSAgICAgICAgICAgICAgICAgICAvLyBcImhpdCBhcmVhXCIgZm9yIGNsaWNraW5nIGVkZ2VcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5rLXRyaWdnZXJcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwicmVkXCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCBcIjRweFwiKVxuICAgICAgICAgICAgLy8uYXR0cigncG9pbnRlci1ldmVudHMnLCAnYWxsJylcblxuICAgIGdfbm9kZXNcbiAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAgIC5hcHBlbmQoXCJzdmc6Y2lyY2xlXCIpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMi41KVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdyZWQnKVxuICAgICAgICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpICAgICAgLy8gZGV0ZWN0IG9uIGludmlzaWJsZSBzdHVmZlxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1vcGFjaXR5JywgJzAuMCcpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgJzhweCcpO1xuXG4gICAgLy8gRU5URVIgKyBVUERBVEUgKGFmZmVjdHMgYWxsIG5ldyBBTkQgZXhpc3RpbmcgbGlua3MpXG4gICAgcGF0aF9saW5rc1xuICAgICAgICAuYXR0cihcImRcIiwgZGlhZ29uYWwpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsaW5rIFwiKyAoZC5zb3VyY2UuaW5ncm91cCA/IFwiaW5ncm91cFwiIDogXCJvdXRncm91cFwiKTsgfSk7XG4gICAgICAgIFxuICAgIHBhdGhfbGlua190cmlnZ2Vyc1xuICAgICAgICAuYXR0cihcImRcIiwgZGlhZ29uYWwpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsaW5rLXRyaWdnZXIgXCIrIChkLnNvdXJjZS5pbmdyb3VwID8gXCJpbmdyb3VwXCIgOiBcIm91dGdyb3VwXCIpOyB9KTtcblxuICAgIGdfbm9kZXNcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgLy8gTi5CLiBUaGVzZSBjbGFzc2VzIGFyZSBvdmVycmlkZGVuIGJ5IHN0dWR5LWVkaXRvci5qcyFcbiAgICAgICAgICBpZiAobi5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG4uZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJyb290IG5vZGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcImlubmVyIG5vZGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwibGVhZiBub2RlXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChcIm5vZGVib3gtXCIrIGRbJ0BpZCddKTsgfSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBkLnkgKyBcIixcIiArIGQueCArIFwiKVwiOyB9KVxuXG4gICAgLy8gRVhJVFxuICAgIHBhdGhfbGlua3NcbiAgICAgIC5leGl0KClcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgcGF0aF9saW5rX3RyaWdnZXJzXG4gICAgICAuZXhpdCgpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGdfbm9kZXNcbiAgICAgIC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAqL1xuICAgIC8vIGFueSBkeW5hbWljIHJlYWRqdXN0bWVudHMgb2Ygbm9uLUNTUyBhdHRyaWJ1dGVzXG4gICAgLy8vc3R5bGVUcmVlTm9kZXModmlzKTtcbiAgICBcbiAgICAvKiBub2RlIGxhYmVsaW5nXG4gICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgU1VQRVItU0xPVyB3aXRoIGxhcmdlIHRyZWVzPyBsaWtlIE1JTlVURVMgdG8gcnVuLi4uXG4gICAgLy8gSXMgdGhlcmUgYSBmYXN0ZXIvY3J1ZGVyIHdheSB0byBjbGVhciB0aGUgZGVja3M/XG4gICAgdmlzLnNlbGVjdEFsbCgnZy5ub2RlIHRleHQnKS5yZW1vdmUoKTtcblxuICAgIC8vIHByb3ZpZGUgYW4gZW1wdHkgbGFiZWwgYXMgbGFzdCByZXNvcnQsIHNvIHdlIGNhbiBzZWUgaGlnaGxpZ2h0c1xuICAgIHZhciBkZWZhdWx0Tm9kZUxhYmVsID0gXCJ1bm5hbWVkXCI7XG5cbiAgICBpZiAoIW9wdGlvbnMuc2tpcExhYmVscykge1xuICAgICAgLy8gcmVmcmVzaCBhbGwgbGFiZWxzIGJhc2VkIG9uIHRyZWUgcG9zaXRpb25cbiAgICAgIHZpcy5zZWxlY3RBbGwoJ2cubm9kZScpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6dGV4dFwiKVxuICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAgICAgICAuYXR0cihcImR4XCIsIC02KVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgLTYpXG4gICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCAnZW5kJylcbiAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxuICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICBzd2l0Y2goZC5sYWJlbFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgKCdtYXBwZWQgbGFiZWwnKTpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyMwMDAnO1xuICAgICAgICAgICAgICAgICAgY2FzZSAoJ25vZGUgaWQnKTpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5hbWJpZ3VvdXNMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyNiOTRhNDgnOyAgLy8gc2hvdyBhbWJpZ3VvdXMgbGFiZWxzLCBtYXRjaCByZWQgcHJvbXB0c1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5hZGphY2VudEVkZ2VMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyM4ODgnO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnIzg4OCc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyM4ODgnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLy8udGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLmxlbmd0aDsgfSk7XG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtc3R5bGUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoZC5sYWJlbFR5cGUgPT09ICdtYXBwZWQgbGFiZWwnID8gJ2luaGVyaXQnIDogJ2l0YWxpYycpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gKGQubmFtZSArICcgKCcrZC5sZW5ndGgrJyknKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVMYWJlbCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoZC5sYWJlbFR5cGUgPT09ICdub2RlIGlkJykge1xuICAgICAgICAgICAgICAgICAgbm9kZUxhYmVsID0gJyc7ICAvLyBoaWRlIHRoZXNlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBub2RlTGFiZWwgPSBkLm5hbWUgfHwgZGVmYXVsdE5vZGVMYWJlbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc3VwcGxlbWVudGFsTGFiZWwgPSBkLmFtYmlndW91c0xhYmVsIHx8IGQuYWRqYWNlbnRFZGdlTGFiZWw7XG4gICAgICAgICAgICAgIGlmIChzdXBwbGVtZW50YWxMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVMYWJlbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlTGFiZWwgPSBzdXBwbGVtZW50YWxMYWJlbDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZUxhYmVsID0gbm9kZUxhYmVsICtcIiBbXCIrIHN1cHBsZW1lbnRhbExhYmVsICtcIl1cIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbm9kZUxhYmVsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICB2aXMuc2VsZWN0QWxsKCdnLnJvb3Qubm9kZSB0ZXh0JylcbiAgICAgICAgICAuYXR0cihcImR4XCIsIC04KVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMyk7XG5cbiAgICAgIHZpcy5zZWxlY3RBbGwoJ2cubGVhZi5ub2RlIHRleHQnKVxuICAgICAgICAuYXR0cihcImR4XCIsIDgpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgMylcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xuICAgIH1cbiAgICBcbiAgICAqL1xuXG4gICAgcmV0dXJuIHt0cmVlOiB0cmVlLCB2aXM6IHZpc31cbiAgfVxuICBcbiAgdmFyIGJ1aWxkUmFkaWFsID0gZnVuY3Rpb24obm9kZXMsIGxpbmtzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAvKiBzZXQgd2lkdGgsIHJhZGl1cywgc3BhY2UgZm9yIGVkZ2UgbGFiZWxzXG4gICAgdmFyIHcgPSBvcHRpb25zLndpZHRoIHx8IGQzLnNlbGVjdChzZWxlY3Rvcikuc3R5bGUoJ3dpZHRoJykgfHwgZDMuc2VsZWN0KHNlbGVjdG9yKS5hdHRyKCd3aWR0aCcpLFxuICAgICAgICByID0gdyAvIDIsXG4gICAgICAgIC8vIE5PVEUgdGhlIGZ1ZGdlIGZhY3RvciBoZXJlOyBsb25nZXIgbGFiZWxzIHdpbGwgYmUgY2xpcHBlZCFcbiAgICAgICAgbGFiZWxXaWR0aCA9IG9wdGlvbnMuc2tpcExhYmVscyA/IDEwIDogb3B0aW9ucy5sYWJlbFdpZHRoIHx8IDEyMDtcbiAgICAqL1xuICAgIFxuICAgIC8qIGJ1aWxkIFNWRywgc2V0IHNpemUgYW5kIG9mZmV0IChjZW50ZXIgaXMgMCwwKVxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3Qoc2VsZWN0b3IpLmFwcGVuZChcInN2ZzpzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByICogMilcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgciAqIDIpXG4gICAgICAuYXBwZW5kKFwic3ZnOmdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyByICsgXCIsXCIgKyByICsgXCIpXCIpO1xuICAgICovXG4gICAgICAgIFxuICAgIC8qIHNldCBzcGFjZSB3aXRoIHggYXMgcG9sYXIgY29vcmRpbmF0ZXMgKDM2MCBkZWdyZWVzKSwgeSA9IDEuMCAqL1xuICAgIHZhciB0cmVlID0gZDMubGF5b3V0LnRyZWUoKSAgLy8gVE9ETzogdXNlIGNsdXN0ZXIgaGVyZT9cbiAgICAgIC5zaXplKFszNjAsIDUwMF0pICAgLy8gV0FTIChbMzYwLCByIC0gbGFiZWxXaWR0aF0pXG4gICAgICAvLyBzb3J0IHBvcHVsb3VzIHRvIHNwYXJzZSBicmFuY2hlc1xuICAgICAgLnNvcnQoZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5jaGlsZHJlbiA/IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDogLTE7IH0pXG4gICAgICAuc2VwYXJhdGlvbihmdW5jdGlvbihhLCBiKSB7IHJldHVybiAoYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoOyB9KTtcbiAgICBcbiAgICB2YXIgcGh5bG9ncmFtID0gYnVpbGRDYXJ0ZXNpYW4oc2VsZWN0b3IsIG5vZGVzLCB7XG4gICAgICB2aXM6IHZpcyxcbiAgICAgIHRyZWU6IHRyZWUsXG4gICAgICBza2lwQnJhbmNoTGVuZ3RoU2NhbGluZzogdHJ1ZSxcbiAgICAgIHNraXBUaWNrczogdHJ1ZSxcbiAgICAgIHNraXBMYWJlbHM6IG9wdGlvbnMuc2tpcExhYmVscyxcbiAgICAgIGRpYWdvbmFsOiByYWRpYWxSaWdodEFuZ2xlRGlhZ29uYWwoKVxuICAgIH0pXG4gICAgdmlzLnNlbGVjdEFsbCgnZy5ub2RlJylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwicm90YXRlKFwiICsgKGQueCAtIDkwKSArIFwiKXRyYW5zbGF0ZShcIiArIGQueSArIFwiKVwiOyB9KVxuICAgIFxuICAgIGlmICghb3B0aW9ucy5za2lwTGFiZWxzKSB7XG4gICAgICB2aXMuc2VsZWN0QWxsKCdnLmxlYWYubm9kZSB0ZXh0JylcbiAgICAgICAgLmF0dHIoXCJkeFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyA4IDogLTg7IH0pXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzFlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IFwic3RhcnRcIiA6IFwiZW5kXCI7IH0pXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IG51bGwgOiBcInJvdGF0ZSgxODApXCI7IH0pXG4gICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKTtcblxuICAgICAgdmlzLnNlbGVjdEFsbCgnZy5pbm5lci5ub2RlIHRleHQnKVxuICAgICAgICAuYXR0cihcImR4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCA8IDE4MCA/IC02IDogNjsgfSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyBcImVuZFwiIDogXCJzdGFydFwiOyB9KVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggPCAxODAgPyBudWxsIDogXCJyb3RhdGUoMTgwKVwiOyB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHt0cmVlOiB0cmVlLCB2aXM6IHZpc31cbiAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBoeWxvZ3JhbTtcblxuUGh5bG9ncmFtLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJQaHlsb2dyYW0gdHJhbnNmb3JtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQcm9qZWN0cyBoaWVyYXJjaGljYWwgZGF0YSAocHJlc3VtYWJseSBhIHRyZWUpIGludG8gb25lIG9mIHNldmVyYWwgbGF5b3V0cyBcIitcbiAgICAgICAgICAgICAgICAgXCJhbmQgcGFzc2VzIHRoZSByZXN1bHRzIGZvciBkb3duc3RyZWFtIHJlbmRlcmluZy5cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ0eXBlXCI6IHtcImVudW1cIjogW1wicGh5bG9ncmFtXCJdfSxcbiAgICBcImxheW91dFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdWxkIGJlICdyYWRpYWwnLCAnY2xhZG9ncmFtJywgb3IgJ2NhcnRlc2lhbicuXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImRlZmF1bHRcIjogJ2NhcnRlc2lhbidcbiAgICB9LFxuICAgIFwid2lkdGhcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZHRoIG9mIG92ZXJhbGwgcGh5bG9ncmFtLCBpbiBjaG9zZW4gcGh5c2ljYWwgdW5pdHNcIiwgLy8gVE9ETzogQ09ORklSTVxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIm51bWJlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMFxuICAgIH0sXG4gICAgXCJoZWlnaHRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCBvZiBvdmVyYWxsIHBoeWxvZ3JhbSwgaW4gY2hvc2VuIHBoeXNpY2FsIHVuaXRzXCIsIC8vIFRPRE86IENPTkZJUk1cbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJudW1iZXJcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSxcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjBcbiAgICB9LFxuICAgIFwicmFkaXVzXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSYWRpdXMgKGZyb20gY2VudGVyIHRvIGVkZ2UpIG9mIGEgcmFkaWFsIGxheW91dCwgaW4gYXJiaXRyYXJ5IHVuaXRzLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIm51bWJlclwifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IDAuNVxuICAgIH0sXG4gICAgXCJyYWRpYWxBcmNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuZ2xlcyBvZiBhcmMgW3N0YXJ0LCBlbmRdIGZvciBhIGNpcmN1bGFyIGxheW91dC5cIixcbiAgICAgIFwib25lT2ZcIjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDIsXG4gICAgICAgICAgICBcIm1heEl0ZW1zXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFswLCAzNTBdXG4gICAgfSxcbiAgICBcInJhZGlhbFN3ZWVwXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEaXJlY3Rpb24gb2YgYXJjLCBDTE9DS1dJU0Ugb3IgQ09VTlRFUkNMT0NLV0lTRS5cIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJzdHJpbmdcIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSxcbiAgICAgIFwiZW51bVwiOiBbXCJDTE9DS1dJU0VcIiwgXCJDT1VOVEVSQ0xPQ0tXSVNFXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICdDTE9DS1dJU0UnXG4gICAgfSxcbiAgICBcInRpcHNBbGlnbm1lbnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIldoaWNoIGVkZ2Ugd2lsbCBzaG93IHRoZSBsYWJlbGVkIHRpcHMuXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImVudW1cIjogW1wiVE9QXCIsIFwiUklHSFRcIiwgXCJCT1RUT01cIiwgXCJMRUZUXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICdyaWdodCdcbiAgICB9LFxuICAgIFwiYnJhbmNoU3R5bGVcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk92ZXJyaWRlIHRoZSBsYXlvdXQncyBzdHlsZSAocmFyZWx5IHVzZWQpLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLFxuICAgICAgXCJlbnVtXCI6IFtcInJpZ2h0QW5nbGVEaWFnb25hbFwiLCBcInJhZGlhbFJpZ2h0QW5nbGVEaWFnb25hbFwiLFxuICAgICAgICAgICAgICAgXCJzdHJhaWdodExpbmVEaWFnb25hbFwiLCBcImRpYWdvbmFsXCIsIFwicmFkaWFsXCJdLFxuICAgICAgXCJkZWZhdWx0XCI6ICcnXG4gICAgfSxcbiAgICBcImJyYW5jaExlbmd0aHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk1hcCBhIGRhdGEgZmllbGQgdG8gYnJhbmNoIGxlbmd0aHMgKE5PVCBZRVQgSU1QTEVNRU5URUQpLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dLCAgLy8gaXMgdGhpcyB0eXBlIFwiZmllbGRcIj9cbiAgICAgIFwiZGVmYXVsdFwiOiAnJ1xuICAgIH0sXG4gICAgXCJub2RlTGFiZWxTb3VyY2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvb2sgZm9yIHRpcCBsYWJlbHMgaW4gYSBkYXRhIGZpZWxkLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcIlhYWFhYWFhYWFhYXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImVudW1cIjogW1wiWFhYWFhYWFhYWFhcIiwgXCJYWFhYWFhYWFhYWFwiXSxcbiAgICAgIFwiZGVmYXVsdFwiOiAnJ1xuICAgIH0sXG4gICAgXCJzaG93RmFsbGJhY2tMYWJlbHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByaW1hcnkgbGFiZWwgaXMgbm90IGZvdW5kLCBzaG93IGFsdGVybmF0aXZlcy5cIixcbiAgICAgIFwib25lT2ZcIjogW3tcInR5cGVcIjogXCJib29sZWFuXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0sXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsICAvLyBUT0RPOiBjb25maXJtIHRoaXNcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eXBlXCJdICAvLyBUT0RPOiByZXZpZXcgcGFyYW1zIVxufTtcbiIsIi8qIFxuICogQSBzaW1wbGUgdHJhbnNmb3JtIHRvIGdyYWIgdGhlIG5hbWVkIHByb3BlcnR5IGZyb20gYSBKUyBvYmplY3QgKG5vdCBhblxuICogYXJyYXkpLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBkZWFsIHdpdGggaGllcmFyY2hpY2FsIGRhdGEgd2l0aCBcbiAqIG11bHRpcGxlIFwiaW5uZXJcIiBkYXRhc2V0cyAoZWcsIG5vZGVzIGFuZCBlZGdlcykgYW5kIGNvbXBsZXggdXBzdHJlYW1cbiAqIHRyYW5zZm9ybXMuXG4gKlxuICogRVhBTVBMRTpcbiAqICAgIFwiZnJvbVwiOiB7XG4gKiAgICAgIFwiZGF0YVwiOiBcInBoeWxvVHJlZVwiLCBcbiAqICAgICAgXCJ0cmFuc2Zvcm1cIjogW1xuICogICAgICAgICAge1widHlwZVwiOlwicGx1Y2tcIiwgXCJmaWVsZFwiOlwicGh5bG9Ob2Rlc1wiIH1cbiAqICAgICAgXSBcbiAqICB9LFxuICovXG52YXIgdmcgID0gcmVxdWlyZSgndmVnYScpLFxuICAgIGxvZyAgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybScpO1xuXG5mdW5jdGlvbiBQbHVjayhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICAgIGZpZWxkOiB7dHlwZTogJ2ZpZWxkJ31cbiAgfSk7XG4gIC8vIFRPRE86IGNvbmZpcm0gdGhhdCB0aGlzIGlzIGFwcHJvcHJpYXRlIGhlcmVcbiAgcmV0dXJuIHRoaXMucHJvZHVjZXModHJ1ZSlcbiAgICAgICAgICAgICAubXV0YXRlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChQbHVjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWNrO1xuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbJ3BsdWNraW5nJ10pO1xuXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZCA9IHRoaXMucGFyYW0oJ2ZpZWxkJyk7XG5cbiAgLy8gRm9yIG5vdywgdGhpcyB0cmFuc2Zvcm0gQVNTVU1FUyBqdXN0IG9uZSBpbmNvbWluZyB0dXBsZSwgd2hpY2ggd2lsbCBiZVxuICAvLyBjb21wbGV0ZWx5IHJlcGxhY2VkIGJ5IHRoZSBwbHVja2VkIHZhbHVlcy5cbiAgYXNzZXJ0KGlucHV0LmFkZC5sZW5ndGggPCAyLCBcbiAgICAgICAgIFwiVGhlIHBsdWNrIHRyYW5zZm9ybSBjYW4gb25seSByZXBsYWNlIGEgc2luZ2xlIGFkZGVkIGRhdHVtLlwiKTtcbiAgdmFyIHBsdWNrZWRWYWx1ZXMgPSBmaWVsZC5hY2Nlc3NvcihpbnB1dC5hZGRbMF0pOyAvLyByZXR1cm5zIHBsdWNrZWQgYXJyYXlcbiAgLy8gYWRkIF9pZCBwcm9wZXJ0aWVzPyBub3QgY2xlYXIgaWYgdGhpcyBpcyBuZWVkZWRcbiAgdmFyIG5leHRBdmFpbGFibGVJRCA9IDEwMDAwMDA7XG4gIHZhciBhc3NpZ25VbmlxdWVJRCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghKCdfaWQnIGluIG9iaikpIHtcbiAgICAgIG9iai5faWQgPSAoJ18nKyArK25leHRBdmFpbGFibGVJRCk7XG4gICAgfVxuICB9XG4gIHBsdWNrZWRWYWx1ZXMuZm9yRWFjaChhc3NpZ25VbmlxdWVJRCk7XG4gIGlucHV0LmFkZCA9IHBsdWNrZWRWYWx1ZXM7ICAgIC8vIHJlcGxhY2UgdGhlIGluY29taW5nIHR1cGxlXG5cbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICAvLyBBY3R1YWxseSwgd2UgY2FuIGFsc28gcmVwbGFjZSBqdXN0IG9uZSBtb2RpZmllZCB0dXBsZSwgaWYgZm91bmRcbiAgICBhc3NlcnQoaW5wdXQubW9kLmxlbmd0aCA8IDIsIFxuICAgICAgICAgICBcIlRoZSBwbHVjayB0cmFuc2Zvcm0gY2FuIG9ubHkgcmVwbGFjZSBhIHNpbmdsZSBtb2RpZmllZCBkYXR1bS5cIik7XG4gICAgcGx1Y2tlZFZhbHVlcyA9IGZpZWxkLmFjY2Vzc29yKGlucHV0Lm1vZFswXSk7XG4gICAgcGx1Y2tlZFZhbHVlcy5mb3JFYWNoKGFzc2lnblVuaXF1ZUlEKTtcbiAgICBpbnB1dC5tb2QgPSBwbHVja2VkVmFsdWVzO1xuICB9XG4gIC8vIHJldHVybiB0aGUgbW9kaWZpZWQgQ2hhbmdlU2V0XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Y2s7XG5cblBsdWNrLnNjaGVtYSA9IHtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJQbHVjayB0cmFuc2Zvcm1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkdyYWJzIGEgcHJvcGVydHkgKG9yIGRlZXBlciBwYXRoKSBmcm9tIGEgaGllcmFyY2h5LlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1wiZW51bVwiOiBbXCJwbHVja1wiXX0sXG4gICAgXCJmaWVsZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hpY2ggZmllbGQgb2YgdGhlIGRhdGEgeW91IHdhbnQgdG8gc2VsZWN0LlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcImZpZWxkXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV0gIC8vIFRPRE86IHNpZ25hbD9cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1widHlwZVwiLCBcImZpZWxkXCJdXG59O1xuXG4vKlxudmcudHJhbnNmb3Jtcy5wbHVjayA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBmaWVsZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcGx1Y2soZGF0YSkgeyAgICBcbiAgICB2YXIgcmVzdWx0ID0gZmllbGQoZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBcbiAgcGx1Y2suZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gICAgZmllbGQgPSB2Zy5hY2Nlc3NvcihmKTtcbiAgICByZXR1cm4gcGx1Y2s7XG4gIH07XG5cbiAgcmV0dXJuIHBsdWNrO1xufTtcbiovXG4iLCIvKiBcbiAqIFN0b3JlIHRoZSBpbmNvbWluZyBkYXRhIChpZiBpdCdzIG5vdCBhbHJlYWR5IGZvdW5kKSB1c2luZyB0aGUgc3BlY2lmaWVkXG4gKiBmdW5jdGlvbiBhbmQga2V5LCB0aGVuIHBhc3MgaXQgYWxvbmcgdW5jaGFuZ2VkLlxuICpcbiAqIFRoaXMgaXMgYSBcImRvLW5vdGhpbmdcIiBkYXRhIHRyYW5zZm9ybSB0byBhbGxvdyBjYWNoaW5nIG9mIGludGVybWVkaWF0ZSByZXN1bHRzXG4gKiBmcm9tIHdpdGhpbiBhIFZlZ2EgcGlwZWxpbmUgKGEgc2VyaWVzIG9mIHRyYW5zZm9ybXMpLiBUaGUgaW50ZW50IGlzIHRvXG4gKiBzdXBwb3J0IGEgbXVjaCBmYXN0ZXIgcGlwZWxpbmUgZm9yIGZyZXF1ZW50bHkgbW9kaWZpZWQgdmlzdWFsaXphdGlvbnMsIGFzXG4gKiB1c2VkIGluIHRoZSBUcmVlIElsbHVzdHJhdG9yIHByb2plY3Q6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9PcGVuVHJlZU9mTGlmZS90cmVlLWlsbHVzdHJhdG9yXG4gKiBcbiAqIE5vdGUgdGhhdCB0aGlzIHRyYW5zZm9ybSBkb2Vzbid0IGNvbmNlcm4gaXRzZWxmIHdpdGggdGhlIGRldGFpbHMgb2YgdGhlIGNhY2hpbmcgXG4gKiBtZWNoYW5pc207IGl0J3MgYXNzdW1lZCB0byBiZSBhbiBleGlzdGluZyBrZXkvdmFsdWUgc3RvcmUsIHBlcmhhcHMgYSBzaW1wbGVcbiAqIGFzc29jaWF0aXZlIGFycmF5IG9yIHNvbWV0aGluZyBzbWFydGVyLiBTaW1pbGFybHksIHRoZSBob3N0IGFwcGxpY2F0aW9uIGlzXG4gKiByZXNwb25zaWJsZSBmb3IgZGVmaW5pbmcgaWRlbXBvdGVudCBrZXlzIGZvciBjYWNoZWQgZGF0YS5cbiAqIFxuICogQWxzbywgbm90ZSB0aGF0IHRoaXMgZG9lc24ndCAqcmV0cmlldmUqIGNhY2hlZCBkYXRhIG9yIHNwZWVkIHRoaW5ncyB1cCBvblxuICogaXRzIG93biEgSW5zdGVhZCwgYnkgZmVlZGluZyBhIGNhY2hlIGl0IGVuYWJsZXMgdGhlIGhvc3QgYXBwbGljYXRpb24gdG9cbiAqIGNvbnN0cnVjdCBhIHNpbXBsZXIgcGlwZWxpbmUgYnkgcHJvdmlkaW5nIGNhY2hlZCBkYXRhIGluc3RlYWQgb2YgVVJMcyxcbiAqIG9taXR0aW5nIHVubmVlZGVkIHRyYW5zZm9ybXMsIGV0Yy5cbiAqL1xudmFyIHZnICA9IHJlcXVpcmUoJ3ZlZ2EnKSxcbiAgICBsb2cgID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JyksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgndmVnYS9zcmMvdHJhbnNmb3Jtcy9UcmFuc2Zvcm0nKTtcblxuZnVuY3Rpb24gU3Rhc2goZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgICBjYWNoZVNldHRlcjoge3R5cGU6ICd2YWx1ZSd9LFxuICAgICAga2V5OiB7dHlwZTogJ3ZhbHVlJ30sXG4gICAgICBmbHVzaDoge3R5cGU6ICd2YWx1ZScsIGRlZmF1bHQ6IGZhbHNlfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbiAgLy8gVE9ETzogYWRkIGNhbGxzIHRvIG11dGF0ZXMoKSwgcm91dGVyKCk/XG59XG5cbnZhciBwcm90b3R5cGUgPSAoU3Rhc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFzaDtcblxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydzdGFzaGluZyddKTtcblxuICB2YXIgY2FjaGVTZXR0ZXIgPSB0aGlzLnBhcmFtKCdjYWNoZVNldHRlcicpLFxuICAgICAgc2V0Q2FjaGVJdGVtID0gZXZhbChjYWNoZVNldHRlciksXG4gICAgICBrZXkgPSB0aGlzLnBhcmFtKCdrZXknKSxcbiAgICAgIGZsdXNoID0gdGhpcy5wYXJhbSgnZmx1c2gnKTtcblxuICBpZiAoIXNldENhY2hlSXRlbSB8fCAodHlwZW9mIHNldENhY2hlSXRlbSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBpZiBhbiBpbnZhbGlkIGNhY2hlIHNldHRlciBpcyBzdWJtaXR0ZWQsIHRyZWF0IHRoaXMgYXMgYSBuby1vcFxuICAgIGNvbnNvbGUud2Fybignc3Rhc2ggdHJhbnNmb3JtOiBubyBjYWxsYWJsZS9mdW5jdGlvbiBmb3VuZCBpbiBldmFsKCcrIGNhY2hlU2V0dGVyICsnKSEgc2tpcHBpbmcgdGhpcyBkYXRhJyk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgLy8gRm9yIG5vdywgdGhpcyB0cmFuc2Zvcm0gQVNTVU1FUyBqdXN0IG9uZSBpbmNvbWluZyB0dXBsZS5cbiAgYXNzZXJ0KGlucHV0LmFkZC5sZW5ndGggPiAwLFxuICAgICAgICAgXCJUaGUgc3Rhc2ggdHJhbnNmb3JtIGV4cGVjdHMgYW4gYWRkZWQgZGF0dW0gKG5vbmUgZm91bmQpLlwiKTtcbiAgYXNzZXJ0KChpbnB1dC5hZGQubGVuZ3RoIDwgMiAmJlxuICAgICAgICAgIGlucHV0Lm1vZC5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICBpbnB1dC5yZW0ubGVuZ3RoID09PSAwKSxcbiAgICAgICAgIFwiVGhlIHN0YXNoIHRyYW5zZm9ybSBvbmx5IHN0b3JlcyBhIHNpbmdsZSBhZGRlZCBkYXR1bS5cIik7XG5cbiAgLyogU3Rhc2ggYSBzaW5nbGUgaW5jb21pbmcgZGF0dW0uIE5vdGUgdGhhdCB3ZSBhY3R1YWxseSBzdG9yZSBhICpjb3B5KiBvZlxuICAgKiB0aGUgZGF0YSwgc2luY2UgVmVnYSBhbHdheXMgY2xvbmVzIGRhdGEgaW4gYSBzcGVjIChzZWUgY29tbWVudCBhYm92ZSkuXG4gICAqIEJlIHN1cmUgdG8gY2FjaGUgdGhlIFwicmF3XCIgZGF0YSBhcyByZXR1cm5lZCBmcm9tIHNvdXJjZSFcbiAgICovXG4gIHZhciByYXdWYWx1ZSA9IGRsLmR1cGxpY2F0ZShpbnB1dC5hZGRbMF0pO1xuICAvLyBOLkIuIGRsLmR1cGxpY2F0ZSBjbGVhbnMgdXAgYW55IHdlaXJkIG1ldGhvZHMgYW5kIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgc2V0Q2FjaGVJdGVtKCBrZXksIHJhd1ZhbHVlLCBmbHVzaCk7XG5cbi8qIE9SIHNob3VsZCB3ZSBzdGFzaCBhbGwgZGF0YSBwaWVjZW1lYWwsIGJhc2VkIG9uIHN0YXRlPz9cbiAgLy8gbW92ZSBuZXcgKGFuZCBwb3NzaWJseSBjaGFuZ2VkKSBkYXRhIHRvIHRoZSBjYWNoZVxuICBmdW5jdGlvbiBzZXQoeCkge1xuICAgIC8vbW92ZSBvbmUgZGF0dW0gKHR1cGxlPykgaW50byB0aGUgY2FjaGVcbiAgICBjb25zb2xlLmxvZyhcInNldHRpbmcgJ1wiKyB4ICtcIicuLi5cIik7XG4gICAgLy9UdXBsZS5zZXQoeCwgZmllbGQsIGV4cHIoeCwgbnVsbCwgc2lnbmFscykpO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuKi9cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFzaDtcblxuU3Rhc2guc2NoZW1hID0ge1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIlN0YXNoIHRyYW5zZm9ybVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU3RvcmVzIHRoZSBpbmNvbWluZyBkYXRhIChpZiBpdCdzIG5vdCBhbHJlYWR5IGZvdW5kKSBpbiB0aGVcIiArXG4gICAgXCIgc3BlY2lmaWVkIG9iamVjdCB1c2luZyB0aGUgc3BlY2lmaWVkIGtleSwgdGhlbiBwYXNzZXMgaXQgYWxvbmcgdW5jaGFuZ2VkLlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1wiZW51bVwiOiBbXCJzdGFzaFwiXX0sXG4gICAgXCJjYWNoZVNldHRlclwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIChmdWxsLCBnbG9iYWwpIG5hbWUgb2YgYSBjYWNoZSdzIHNldHRlciBmdW5jdGlvblwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcInN0cmluZ1wifSwge1wiJHJlZlwiOiBcIiMvcmVmcy9zaWduYWxcIn1dICAvLyBUT0RPOiBzaWduYWw/XG4gICAgfSxcbiAgICBcImtleVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSB1bmlxdWUga2V5IGZvciB0aGlzIGRhdGEgaW4gdGhlIHN0YXNoXCIsXG4gICAgICBcIm9uZU9mXCI6IFt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LCB7XCIkcmVmXCI6IFwiIy9yZWZzL3NpZ25hbFwifV1cbiAgICB9LFxuICAgIFwiZmx1c2hcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRydWUsIHdpbGwgcmVwbGFjZSBhbnkgZXhpc3Rpbmcgc3Rhc2hlZCBkYXRhLlwiLFxuICAgICAgXCJvbmVPZlwiOiBbe1widHlwZVwiOiBcImJvb2xlYW5cIn0sIHtcIiRyZWZcIjogXCIjL3JlZnMvc2lnbmFsXCJ9XSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSwgIC8vIFRPRE86IGNvbmZpcm0gdGhpc1xuICBcInJlcXVpcmVkXCI6IFtcInR5cGVcIiwgXCJrZXlcIiwgXCJjYWNoZVNldHRlclwiXVxufTtcbiJdfQ==
